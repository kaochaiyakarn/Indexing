artificial intelligence hardness approximate reasoning dan roth division applied sciences harvard university cambridge ma 
das harvard edu ai problems formalized reduce evaluating probability propositional expression true 
show problem computationally intractable surprisingly restricted cases settle approximation probability 
consider various methods approximate reasoning computing degree belief bayesian belief networks reasoning techniques constraint satisfaction knowledge compilation approximation avoid computational difficulties reduce model counting problems propositional domain 
prove counting satisfying assignments propositional languages intractable horn monotone formulae size clauses number occurrences variables extremely limited 
contrasted case deductive reasoning horn theories theories binary clauses distinguished existence linear time satisfiability algorithms 
surprising show approximating number satisfying assignments approximating approximate reasoning intractable restricted theories 
identify restricted classes propositional formulae efficient algorithms counting satisfying assignments 
preliminary version appeared proceedings th international joint conference artificial intelligence ijcai 
supported nsf ccr ccr darpa afosr 
investigating computational cost tasks interest ai argued essential understanding ability characterize tasks finding knowledge representation systems adequate 
problem discussed extensively context problem propositional satisfiability typical np hard problem special concern ai direct relationship deductive reasoning 
forms reasoning including default reasoning planning direct appeal satisfiability shown np hard 
practice fundamental disagreement implications 
debate restrict form statements knowledge base settle approximate output 
consequence intensive research direction identification restricted languages propositional satisfiability solved efficiently horn theories 
consider related problem counting satisfying assignments propositional formulae 
argue role played satisfiability problems ai problems deduction special concern replaced counting satisfying assignments approximate reasoning techniques 
support argument show various methods approximate reasoning computing degree belief bayesian belief networks equivalent computationally solving counting problems 
show considering problem counting solutions valuable approach evaluating techniques approximations effort avoid computational difficulties constraint satisfaction knowledge compilation analyze computational complexity counting satisfying assignments propositional languages prove intractable horn monotone formulae size clauses number occurrences variable formula extremely limited 
contrasted case deductive reasoning horn theories theories binary clauses distinguished existence linear time algorithms satisfiability 
surprising show approximating number satisfying assignments approximating approximate reasoning intractable restricted theories 
identify restricted classes propositional formulae develop efficient algorithms counting satisfying assignments 
positive results find tractable languages approximate reasoning technique discussed believe main contribution presentation widely applicable surprising hardness results 
implies research directed away investigating structural constraints world investigating distributional constraints suggests reconsider model reasoning problem 
discuss issues section 
section give background material computational complexity counting problems section positive negative results exact approximate counting satisfying assignments 
main results section put model counting results context various approximate reasoning techniques reducing techniques counting problems 
proofs technical results appear appendix 
computational complexity counting problems give section brief overview computational complexity counting problems related problems approximate counting random generation solutions 
detailed discussion consult 
large number decision problems naturally associate counting problem 
example counting number satisfying assignments boolean formula counting number perfect matchings bipartite graph counting number cycles graph 
clearly counting version hard decision problem cases decision problem easy computationally efficient method known counting number distinct solutions 
class introduced valiant effort explain phenomena 
counting problem belongs non deterministic algorithm instance associated decision problem number guesses lead acceptance equal number distinct solutions algorithm polynomial size usual hardest problems complexity class complete class 
particular shown counting number satisfying assignments cnf formula counting versions np complete problems complete significantly shown counting versions problems complete class 
examples include counting number satisfying assignments dnf formula counting number cycles graph problems 
problems complete hard np complete problems probably harder 
evidence hardness problems supplied result implies call oracle suffices solve problem polynomial hierarchy deterministic polynomial time 
may serve indication outside polynomial hierarchy 
natural consider problem approximate counting 
notion approximation relative approximation 
positive numbers ffi 
say approximates ffi ffi ffi approximating solution problem easier finding exact solution 
fact harder solving np hard problems 
example exists polynomial time randomized algorithm approximates number satisfying assignments dnf formula constant ratio 
possible complete problem underlying decision problem easy resist efficient approximate solution 
example exhibit similar phenomenon 
prove various propositional languages solving satisfiability easy np hard approximate number satisfying assignments weak sense 
notion relative approximation discuss probabilities 
worth noticing notion approximation preserved computing ratios quantities 
assume approximate ffi find ffi ffi ffi ffi ffi ffi yields relative approximation ratio ffi ffi 
particular computing conditional probability yjx event evidence yjx definition terms counting turing machines 
conclude proposition complexity computing relative approximation conditional probability yjx polynomially related computing relative approximation unconditional probability 
note related class problems interest ai randomly generating solutions uniform distribution shown equivalent randomized approximate counting wide class problems 
natural problems considered finding satisfying assignments boolean formulae various graph problems class 
computational complexity point view consider problems exact approximate counting 
summary model counting results section summarize results exact approximate counting satisfying assignments propositional languages 
include hardness results exact approximate counting positive results exact counting 
complete proofs results appendix 
sat sat denote problem counting approximating respectively number satisfying assignments formula propositional language problem sat problem hierarchy obtained place additional restrictions relaxations allowed instances 
propositional languages define instance instance 
horn cnf 
clearly solve problem sat solve problem sat prove hardness results consider restricted languages 
argument holds corresponding approximation problem 
notations conventions denoting propositional languages lang class boolean formulae integers denotes subclass formulae lang clause consists literals lang denotes class lang formulae variable occurs times 
degree formulae 
example moncnf consists monotone cnf formulae clauses length horn consists horn formulae clauses length variable occurs times 
sat boolean formulae 
mon boolean formulae variables unnegated monotone formulae 
cnf boolean formulae conjunctive normal form moncnf monotone cnf 
horn cnf clauses unnegated variable horn clauses 
moncnf set variables divided sets clause contains variable 
mean procedure relatively approximates unconditional probabilities say polynomial ffi yields procedure relatively approximate conditional probabilities polynomial ffi course vice versa 
cnf horn moncnf horn moncnf mon moncnf horn mon horn acyclic moncnf hard approximate hard count count sat hard sat easy acyclic horn complexity approximately counting satisfying assignments acyclic moncnf moncnf theory oe undirected graph containing vertex variable oe edge connecting vertices corresponding variables appear clause 
oe acyclic moncnf corresponding graph acyclic 
acyclic horn horn theory oe directed graph containing vertex literal oe edge vertex corresponding literal body rule negative variable clause representation rule vertex corresponding literal head rule positive variable clause representation rule 
special nodes added clauses empty body empty head 
oe acyclic horn connected component corresponding graph directed tree 
summarizes results presents hierarchy propositional languages classification complexity sat sat 
comment results imply similar results restricted languages noticeable various propositional languages having efficient algorithms satisfiability restricted versions horn exact counting complete fact case horn theories situation fully understood give efficient algorithm possible case horn 
situation approximate counting surprising restricted classes horn theories horn np hard approximate number satisfying assignments say formulae variables 
similar results hold moncnf theories bounded degree case open 
notice place language horn moncnf horn contain moncnf 
horn contains anti moncnf variables formula negated unnegated clearly counting results hold moncnf hold anti moncnf 
positive results virtually complete complexity picture directly applied reasoning techniques considered 
statements results formally state technical results outlined 
state results important languages results languages easily deduced inclusion described 
proofs appendix 
theorem hardness exact counting sigma propositional formula variables 
propositional languages counting number satisfying assignments sigma complete moncnf horn horn mon theorem hardness approximation sigma propositional formula variables ffl constant 
propositional languages approximating number satisfying assignments sigma gammaffl np hard moncnf horn theorem positive results sigma propositional formula variables 
propositional languages exists efficient algorithm counting number satisfying assignments sigma 
moncnf horn acyclic moncnf acyclic horn reducing approximate reasoning counting section consider various techniques approximate reasoning show case inference equivalent solving counting problem 
start considering case computing degree belief underpinning approximate reasoning 
consider bayesian belief networks reasoning approximate theories constraint satisfaction problems 
discuss previous relates approximate reasoning counting problems results apply 
degree belief inference degree belief generalization deductive inference knowledge base augmented statistical information effort avoid computationally hard task deductive inference 
consider knowledge base consisting propositional theory sigma assume assign degree belief particular statement ff 
situation natural various ai problems planning expert systems actions agent takes may depend crucially degree belief 
suggested kind reasoning expert system knowledge base facts possibly associated probabilities want compute probability sentence interest 
probabilistic logic probability sentence sum probabilities sets possible worlds sentence true 
general approach computing degree belief assigning equal degree belief basic situations consistent knowledge base computing fraction consistent query 
done apply principle determine basic situations 
consider question computing degree belief restricted case knowledge base consists propositional theory contains statistical information 
hardness results get restricted case just highlight computational difficulties general cases approach possible models theory equal weight interested computational complexity computing degree belief propositional formula fraction models consistent propositional query 
propositional theory sigma variables probability sigma satisfied sigma computed uniform distribution set possible assignments sigma 
sigma probf sigma tg jm sigma sigma denotes set satisfying assignments sigma jm sigma denotes size stands truth value 
propositional theory sigma propositional statement ff degree belief ff conditional probability ff respect sigma ffj sigma fraction satisfying assignments sigma satisfy ff ffj sigma sigma sigma tg jm ff sigma jm sigma observation jm ff variable discussion section proposition implies proposition complexity computing approximating degree belief propositional statement respect propositional theory polynomially related complexity computing approximating number models propositional statement 
results theorem theorem theorem problem computing degree belief propositional statement variables respect propositional theory complete fixed ffl approximating probability gammaffl np hard 
order version problem considered shown problems want ask highly undecidable 
cases shown asymptotic conditional probabilities exist computed 
strictly speaking problem computing degree belief easily seen equivalent problem class 
keep loose interpretation rest 
bayesian belief networks bayesian belief networks provide natural method representing probabilistic dependencies set variables considered efficient expressive language representing knowledge domains 
consider class multiple connected belief network networks contain pair nodes variables undirected path connecting 
argued expressiveness networks required representing knowledge domains medicine 
briefly general class belief networks associated inference problem show reduce inference problem counting satisfying assignments propositional formula 
definitions elaborate discussion bayesian belief networks expressiveness representation type inference utilize see 
bayesian belief network casual network consists graphical structure augmented set probabilities 
graphical structure directed acyclic graph dag nodes represent random variables domain variables edges represent existence direct casual influence linked variables 
conditional probability associated group edges directed node single edge 
prior probabilities assigned source nodes node incoming edge 
represent belief network triple set vertices variables set edges set probabilities 
particular consists prior probability functions source node conditional probabilities functions fp jy ij ij px node set direct predecessors 
notation inadvertently clear refer variable 
see construction proof theorem example belief network 
general probability distribution represented bayesian belief network 
dag easy specify consistently conditional probabilities 
needs sure conditional probabilities attached satisfy node jp 
complexity analysis take complexity parameter number nodes belief network 
notice conditional probabilities tables associated network exponential practitioners bayesian belief networks try avoid case course 
reduction conditional probabilities tables concise representations polynomial number nodes network sense think complexity measure total size network including conditional probabilities tables 
general inference problem belief network calculating posterior probability js single instantiated variable conjunction instantiated variables 
restricted form probabilistic inference determining propositional variable explicit conditioning information analyzed proved np hard 
hardness result exact inference problem shows expect develop general purpose algorithms probabilistic inference polynomial running time need divert attention trying construct approximation algorithms probabilistic inference 
results show case theorem problem computing probability node bayesian belief network true complete fixed ffl approximating probability gammaffl size network np hard 
proof proof reduction 
major differences reduce problem counting satisfying assignments propositional formula computing probability node bayesian belief network true results section start reduction restricted propositional formula yielding restricted network topology 
reduce problem counting satisfying assignments moncnf formula computing probability node bayesian belief network true 
reduction preserves number satisfying assignments reduction holds problem approximating probability 
consider instance moncnf sigma fc clauses set fu boolean variables 
construct belief network bn containing variable jm sigma construct bn show define vertices edges set prior conditional probabilities defined set vertices variable clause set edges consists edges variable connected clauses appears total edges sigma moncnf connected clauses depicts bn generated procedure instance moncnf fu sigma set probabilities defined follows source nodes belief network generated moncnf formula sigma prior probability incoming edges node corresponding clause define conditional probability node satisfied assignment variables clause 
formally define conditional probabilities ju assignment satisfies possible results hinge hardness solving satisfiability done polynomial time moncnf 
conditional probability edges coming node defined jc easy see structure defined bayesian belief network 
clear construction belief network moncnf instance accomplished time polynomial size moncnf instance compute probability 
assignment input variables assignment clauses 
construction gamma gamma jc suppose sigma satisfiable satisfying assignments 
clearly definition conditional probability ju jc assignment terms equal 
internal sum equation equal satisfying assignment sigma equal 
get jm sigma applying results theorem theorem completes proof 
considered computational complexity computing probability node bayesian belief network true 
compute conditional probability yjx sets nodes network notice yjx clear exact computation conditional probability hard computing unconditional probability single source node 
proposition case problem approximating conditional probability conclude theorem problem computing conditional probability node evidence bayesian belief network complete fixed ffl approximating probability gammaffl size network np hard 
note reduction modified hold restricted network topology limited degree degree restrictions topologies network utilized reduce problems counting satisfying assignments syntactically restricted cnf formulae computing probability node network true 
light results section yield stronger hardness results 
dagum luby stronger result implying hardness computing absolute approximation probabilities bayesian networks 
results different show inference equivalent counting combined results section implies hardness results restricted network topologies 
relies fact define conditional probabilities concisely 
general node associated conditional probability table exponential size network 
reasoning approximate theories theory reasoning approximate theories introduced selman kautz series papers new approach developing efficient knowledge representation systems 
goal speed inference replacing original theory theories belong different propositional language approximate original theory 
approximate theory implies original theory lower bound implied upper bound 
reasoning approximations original theory guarantee exact reasoning provide quick necessarily complete see answer inference problem 
happen allows efficient deduction class propositional horn formulae course computing approximations hard computational problem suggested line compilation process 
computational aspects computing theory approximations reasoning studied 
concentrate discussing horn approximation 
notational convenience confusion arise identify section propositional theory sigma set models satisfying assignments 
observe connective implies boolean functions propositional formulae equivalent connective subset equal subsets models 
sigma sigma sigma sigma consider propositional theory sigma 
horn theories sigma lb sigma ub horn lower bound horn upper bound respectively sigma sigma lb sigma sigma ub equivalently subset notations sigma lb sigma sigma ub sigma glb sigma lub greatest horn lower bound horn upper bound respectively sigma called horn approximations original theory sigma 
order answer sigma ff horn approximation inference procedure way test sigma lub ff 
answer inference procedure answers sigma ff 
test sigma glb ff 
answer inference procedure answers sigma ff 
inference procedure returns don know 
aside computational problems related horn approximations computing approximations question size formula representing approximations see third major question harder analyze question evaluating utility reasoning approximate theories 
clearly query sigma lub ff sigma glb ff answer question sigma ff correct 
total performance inference procedure determined queries answered don know forcing procedure resort original inference problem order answer query 
consider theory sigma sigma lub upper bound approximation 
proposition number queries reasoning approximate theories returns don know exponential sigma lub sigmaj 
implication problem horn theories solved linear time combined length theory query 
remains true broader class queries dnf formulae disjunct contains negative literal arbitrary cnf formulae 
proof sigma lub sigma 
subset ae define query ff sigma 
set models ff consists models sigma models set 
ae sigma glb ff sigma glb sigma sigma lub ff jsj gamma queries ff reasoning approximate theories returns don know 
shown family propositional languages consists formulae horn formulae literals clause construct examples theories sigma sigma lub sigmaj exponential number variables sigma lub upper bound sigma 
surprisingly construct horn theories properties 
proposition leads double exponential number queries reasoning approximate theories returns don know 
tools developed allow construction examples language respect want consider theory approximation 
briefly describe example case horn approximation consider theory sigma gamma easy see number models sigma upper approximation sigma respect horn sigma lub shown contain models size argued fact set models horn formula closed intersection bitwise see 
size sigma lub sigma exponential number variables 
question partially addressed learning techniques find approximation 
done general theory horn approximations approximation defined terms containment logical strength guarantee approximation close optimal optimal approximates original theory reasonable bound sense answers fraction queries correctly 
counting approach suggest shed light problem 
argued reasonable way estimate utility reasoning approximate theories define terms proximity number models correlates positively number queries answered correctly answered don know approximations 
examples indicate restriction imposed queries syntactically similar propositional languages horn formulae formulae far terms number models produce unacceptable behavior 
argument exhibited proposition shows heart problem fact queries reasoner unrestricted 
motivates investigation direction reasoning restricted queries possible avoid difficulties 
experimental analysis severe restrictions classes queries allowed reasoning approximate theories shown succeed large percentage queries 
general analysis developed shown particular reasoning upper bound theory sigma respect correct queries belong language constraint satisfaction problems constraint satisfaction problems csp provide convenient way expressing declarative knowledge focusing local relationships entities domain 
constraint satisfaction problem involves set variables having domains defines set values variable may assume 
ary relation variables subset cartesian product theta theta theta constraint variables subset cartesian product domains 
set tuples satisfying constraints solutions csp 
problem find solutions solution 
general constraint satisfaction problems hard generalization satisfiability cnf formulae 
cnf formula constraint satisfaction problem clause relation consisting tuples literal 
set solutions csp set satisfying assignments formula 
particular consider network binary constraints usually done problem represented sat formula 
finding solutions clearly enumeration problem results section associated counting problem complete non trivial cases finding solution constraint satisfaction problem known hard general discussed different heuristics techniques find approximate solutions 
discuss counting point view observe discussion implies computing approximating number solutions binary csp problem hard computing approximating number solutions moncnf formula 
results theorem theorem theorem problem computing number solutions binary csp problem complete fixed ffl approximating number gammaffl np hard 
search techniques traditionally solve csps 
techniques require worst case exponential search time analyzing techniques order get performance guarantees usually hard 
exemplify counting point view taken evaluate class heuristics restrict feasibility 
dechter pearl suggest counting guide search estimate confidence specific solution extended full solution 
specifically suggested simplify pending subproblems simplifying assumptions continuing portion search graph count number consistent solutions simplified subproblem order candidates counts decide pending subproblems 
intuition heuristics number solutions simplified version problem estimate number solutions original problem indicative chance retain surviving solution 
results section restrict utility heuristics ways simplified subproblem tree syntactically constraint structure see theorem order able get count solutions simplified version 
significantly case original problem possesses non trivial structure number solutions ary relation represented network binary constraints variables 
comment valiant results fact imply simple conditions finding solution easy problem satisfies form self reducibility enumerating solutions polynomial number counting problem hard 
conditions trivially hold horn formulae subclasses csp 
simplified version indicative number solutions original problem 
approximate number solutions original problem shown hard 
summarize corollary counting heuristics constraint satisfaction problem computationally intractable 
hand positive results theorem identify restricted domains counting techniques shown useful 
related results related result reduction approximate reasoning technique counting problem 
shows reduction problem computing dempster rule combination main tool dempster shafer theory evidence hard problem computing number satisfying assignments propositional cnf formula results strengthened theorem theorem 
immediate results get approximate version dempster rule combination hard compute hardness result dempster shafer theory holds severely restrict basic probability assignments allowed evidence dempster shafer theory 
discussion put results complexity counting approximating number satisfying assignments propositional formulae context various approximate reasoning techniques 
significance approach illustrated showing various supposedly different methods approximate reasoning equivalent counting 
worth noticing example active discussion approximate reasoning community differences semantical basis dempster shafer theory bayesian approach see show computational problem underlying approaches computing inference equivalent counting satisfying assignments theory 
shown approach valuable evaluating techniques approximations effort avoid computational difficulties 
exemplified analyzing heuristics constraint satisfaction problems utility reasoning approximate theories 
believe approach developed useful analysis problems interest ai 
hardness results indicate problems computing degree belief probabilistic reasoning approximate reasoning techniques expect develop generalpurpose algorithms polynomial running time 
computing approximate inference proved intractable 
results rule possibility developing efficient algorithms apply restricted cases positive results suggest identifying positive results investigating apply various techniques direction extend 
mention particular problem approximately counting number satisfying assignments bounded degree moncnf formulae 
problem left open see solution develop efficient algorithms constraint satisfaction problems example 
similar result different reduction proved independently provan 
greg provan bringing attention 
positive results important pointing tractability frontiers provide collection techniques enhance understanding problems develop new results possibly problems interest ai 
extent hardness results apply restricted propositional languages restricted topologies bayesian networks imply research directed away investigating structural constraints world investigating distributional constraints limiting reasoning tasks world reason 
include constraining distributions represent belief networks second imply studying restrictions type queries need respond 
motivated results section suggest possible approach allow efficient reasoning constrain queries world 
partly motivated results shown constraining queries gets difficulties section leads correct reasoning approximate theories 
possible interpretation surprising widely applicable results need reconsider way model reasoning problem 
way get difficulties allow reasoner ways access world addition fixed formula bayesian network knowledge approach analyze 
promising results direction 
acknowledgments am grateful les valiant helpful discussions comments earlier draft 
karen daniels roni khardon comments earlier draft 
bacchus 
representing reasoning probabilistic knowledge logical approach probabilities 
mit press 
bacchus grove halpern koller 
statistics beliefs 
proceedings national conference artificial intelligence pages 
cadoli 
semantical computational aspects horn approximations 
proceedings international joint conference artificial intelligence pages august 
carnap 
logical foundations probability 
university chicago press chicago 
cooper 
computational complexity probabilistic inference bayesian belief networks 
artificial intelligence 
dagum luby 
approximating probabilistic inference bayesian belief networks np hard 
artificial intelligence 
dechter 
constraint networks 
shapiro editor encyclopedia artificial intelligence 
john wiley sons 
dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
dechter pearl 
structure identification relational data 
artificial intelligence 
garey johnson 
computers intractability guide theory np completeness 
freeman san francisco 
greiner schuurmans 
learning useful horn approximations 
proceedings international conference principles knowledge representation reasoning pages 
grove halpern koller 
asymptotic conditional probabilities order logic 
acm symp 
theory computing number pages 

intelligent decision systems 
addison wesley reading ma 
jerrum valiant vazirani 
random generation combinatorial structures uniform distribution 
theoretical computer science 
karp luby 
monte carlo algorithms enumeration reliability problems 
ieee symp 
foundation computer science number pages 
kautz kearns selman 
horn approximations empirical data 
artificial intelligence 
forthcoming 
kautz selman 
general framework knowledge compilation 
proceedings international workshop processing declarative knowledge germany july 
kautz selman 
forming concepts fast inference 
proceedings national conference artificial intelligence pages 
kautz selman 
empirical evaluation knowledge compilation theory approximation 
proceedings national conference artificial intelligence pages 
khardon roth 
learning reason 
proceedings national conference artificial intelligence pages 
submitted publication 
full version technical report tr aiken computation lab harvard university january 
khardon roth 
reasoning models 
proceedings national conference artificial intelligence pages 
submitted publication 
full version technical report tr aiken computation lab harvard university january 
levesque 
making believers computers 
artificial intelligence 
montanari 
networks constraint fundamental properties applications picture processing 
inf 
sci 
nilsson 
probabilistic logic 
artificial intelligence 

dempster rule combination complete 
artificial intelligence 
pearl 
probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufman 
pearl 
reasoning belief functions analysis compatibility 
international journal approximate reasoning 
poole 
hardness approximate reasoning 
proceedings international joint conference artificial intelligence pages august 
provan ball 
complexity counting cuts computing probability graph connected 
siam journal computing nov 
provan 
logical analysis dempster shafer theory 
international journal approximate reasoning 
provan 
validity dempster shafer belief functions 
international journal approximate reasoning 
selman kautz 
knowledge compilation horn approximations 
proceedings national conference artificial intelligence pages 
shafer 
perspectives theory practice belief functions 
international journal approximate reasoning 
sinclair 
randomized algorithms counting generating combinatorial structures 
phd thesis department computer science university edinburgh 
stockmeyer 
approximation algorithms siam journal computing 
toda 
computational power pp 
ieee symp 
foundation computer science number pages 
valiant 
complexity computing permanent 
theoretical computer science 
valiant 
complexity enumeration reliability problems 
siam journal computing 
valiant 
theory learnable 
communications acm nov 
appendix proofs section formally state prove results outlined section 
results stated important languages results languages easily deduced inclusion described section 
results section summarized theorems section theorem prove results hardness exact counting 
section theorem prove results hardness approximate counting 
section theorem give positive results exact counting describing efficient algorithms counting satisfying assignments formulae languages 
preliminaries boolean function denote set satisfying assignments jm size 
denote ng 
lemma problem counting number satisfying assignments moncnf equivalent problem counting number independent sets graph 
proof graph associate monotone cnf phi variables fx xng follows phi inverse mapping defined manner formula phi moncnf fx xng construct graph phi fv vn follows iff clause phi fv ig independent set assignment defined ae satisfies phi reason clause variables assigned definition phi independent set direction assume satisfying assignment phi fi fv ig independent set phi reason definition graph phi vertices share edge clause phi satisfy 
corollary problem counting number satisfying assignments moncnf equivalent problem counting number independent sets graph degree proof mapping defined lemma maps graphs degree formulae 
exact counting theorem hardness exact counting sigma propositional formula variables 
propositional languages counting number satisfying assignments sigma complete moncnf horn horn mon proof known proved 
get negating variables bipartite sets 
prove formula phi horn rewrite changing number solutions horn formula 
phi horn formula fx xng assume appears times phi negated unnegated 
introduce new variables fx replace jth appearance phi get sigma horn formula 
conjoin sigma gamma gamma horn formula gamma gamma clearly phi sigma gamma number satisfying assignments horn formula sigma gamma equal number satisfying assignments original horn formula counting problems languages equivalent 
different rewriting technique 
cnf formula phi rewrite preserving number satisfying assignments sigma gamma sigma gamma monotone sigma sigma gamma mon 
sigma gammaj sigmaj gamma sigma gammaj hardness exact counting mon formulae results hardness counting cnf formulae cf 

rewriting phi variable appears negated unnegated phi replace unnegated occurrences negated occurrences resulting formula moncnf formula phi force denote phi gamma clear phi phi phi gamma sigma gamma sigma phi phi moncnf formula gamma mon formula dnf form result follows 
approximate counting theorem hardness approximation sigma propositional formula variables 
propositional languages approximating number satisfying assignments sigma factor gammaffl fixed ffl np hard 
moncnf horn proof get rewriting technique non monotone clauses theorem 
technique leaves number solutions increase number variables easily handled 
notice rewriting technique theorem extend approximations 
lemma provides main step proof 
proof blow technique developed 
different version lemma appears 
lemma ffl approximating number independent sets graph vertices gammaffl np hard 
proof blow technique introduced reduce problem approximating number independent sets independent set problem 
jv construct graph approximating number independent sets gammaffl solve independent set defined follows vertex blown cloud vertices construct complete bipartite graph edges connecting 
formally fv mgg mgg assume contains independent set size fv mgg independent set size km subsets independent set independent sets nmin km independent sets hand contains independent set size independent set contains vertices gamma clouds corresponding vertices projection clouds generate independent set size larger gamma 
particular largest independent set size gamma different independent sets size 
nmax gamma gamma delta gamma independent sets case independent set np hard 
ffl choose large gamma gamma ffl blow graph size jv nm nmin nmax km gamma gamma delta gamma gamma gamma delta gamma gamma delta gamman gamma jv gamma notice blow procedure polynomial size original graph 
approximate number independent sets jv gammaffl jv gamma approximation decide graph nmin nmax independent sets 
argued leads deciding independent set 
proved lemma counting number satisfying assignments moncnf equivalent problem counting number independent sets graph 
lemma implies theorem 
positive results theorem positive results sigma propositional formula variables 
propositional languages exists efficient algorithm counting number satisfying assignments sigma 
moncnf cnf acyclic moncnf acyclic horn proof prove developing closed form formula easy evaluate number independent sets graphs degree 
cases develop efficient algorithms 
problem counting independent sets trees give efficient recursive algorithm 
algorithms elaborate 
cases start constructing chains form original theory 
show original theory represented composition chains develop compositions rules allow count number satisfying assignments composite chains 
difference type compositions allowed 
note sub cases respectively give separate proofs cases considerably simpler 
proof corollary count number independent sets degree graph 
consider empty set independent set 
connected graph maximal degree vertices 
cycle case vertices degree arm exactly vertices degree 
lemma denote number independent sets cycle length number independent sets arm length dn gamma gammaj delta ii bn gamma gammaj delta gamma gammaj gamma gamma delta proof denote respectively number independent sets size arm respectively cycle length counts independent sets contain fixed vertex cycle 
problem computing reduces combinatorial problem find number selections integers set ng consecutive numbers selected 
count number consider selection different numbers gamma 
mapping adds number selected second gamma jth correspondence selections legal selections count 
get gamma get total number sum dn add empty set 
ii claim gamma gamma 
see consider cycle arm points vn 
adjacent cycle 
term corresponds independent sets cycle contain say second term correspond contain 
group contain get shifting set contains place 
gamma gamma gamma just add adjacent vertices prefix selected get gamma gamma gamma gamma get total number sum bn add empty set 
immediate consequence lemma get lemma graph maximal degree assume connected components sizes respectively 
number independent sets fa cg depends component arm cycle 
proof clauses cnf theory form literal variable xn negation variable appears twice theory 
literal appears twice negation appears theory literal negation appear 
notice implication representations clause equivalent representation convenient implication representation assume hold representations convenient 
literal appears antecedent consequent clauses combine chain contains occurrence var theory 
call theory simple chain 
case antecedent consequent 
antecedent consequent literals degree theory literals degree 
antecedent consequent literals underlying variable case literals chain 
say simple chain cnf theory maximal extended theory contains clause consequent clause antecedent 
notice maximal simple chains theory consequents respectively 
reason case reverse negate literals get equivalent chain antecedent 
new chain concatenated contradicting maximality 
simple chain called cycle var var case variables degree 
maximal simple chains cnf theory sigma 
assume antecedent 
case compose simple chains say composite chain 
similarly composed common consequent 
notice literal appears maximal simple chains appear antecedent consequent 
internal contradicts degree requirement consequent antecedent contradicts maximality chain 
repeat process composition chains sigma simple composite share variable 
chains share antecedents consequents composing results closed composite chain 
composite chain closed exactly literals degree say decide arbitrarily denote tail head tail head composite chain antecedents consequents combination 
chain variables fx variables appear denote nc number assignments fx satisfy likewise denote nc jh nc jt number assignments fx satisfy force head respectively tail literal nc jt force head tail value 
notice values nc determine possible values necessary compute values composite chain 
closed chain compute nc chain composed 
cnf theory count number satisfying assignments decompose simple chains cycles 
number satisfying assignments simple theories lemma 
argued variable common chains antecedent consequent 
derive lemma lemma composition rule shows compute number satisfying assignments conjunction theories restriction theories part cnf theory 
composition rule applied composite chains compositions 
point theory represented conjunction disjoint theories lemma compute total number satisfying assignments 
describe algorithm details prove lemmas show correctness 
algorithm count horn sigma jm cnf theory cnf var var jk xn procedure counts number satisfying assignments sigma construct simple chains ffl represent clause ffl fix order clauses 
start clause greedily combine 
clause check representations combined way 
go maximal simple chain 
ffl starting available clause repeat procedure clauses part previously constructed chains 
go combination 
variable occurs consequent antecedent 
sure process constants internal chain 
ffl simple chain form compute lemma value nc clauses length represented way 
fact constants appear theory twice affect correctness algorithm 
see 
notice process combination steps required degree variable sigma resulting chains uniquely defined 
combine chains ffl sigma represented conjunction simple chains combine chains common variable antecedent consequent 
ffl combination step resulting composite chain compute lemma lemma values nc ffl go chains common variables 
combinations steps required degree variable sigma 
process results disjoint composite chains 
compute number satisfying assignments fc set disjoint composite chains previous stage 
nc number assignments satisfy counted variables variables xn fc lemma number satisfying assignments sigma jm sigma gammar pi nc correctness clear maximal simple chains constructed algorithm unique composite chains 
clear construction efficient 
just need show derive number satisfying assignments process 
show lemmas 
lemma sigma formula xn appears exactly conjuncts nc number independent sets sigma number independent sets sigma 
sigma pi nc proof clear fact variable disjoint 
initial step computing number satisfying assignments lemma lemma consider simple chain underlying variables different nc 
ii nc 
iii nc 
proof note need consider index 
possibilities satisfying assignment variables 
statements follow similarly 
ii literals 
iii gamma 
lemma shows compute number satisfying assignments composing chains 
lemma composite chains exactly variable common 
assume loss generality common variable tail tail composite chain degree variable coming head degree coming 
appears positive negative respectively variable chains antecedent chains consequent 
case nc nc jt nc jt nc jt nc jt jt nc jt nc jt nc jt nc jt jh nc jt nc jt nc jt nc jt jt nc jt nc jt nc jt nc jt ii assume appears positive variable negative variable case antecedent chains say consequent 
nc nc jt nc jt nc jt nc jt jt nc jt nc jt nc jt nc jt jh nc jt nc jt nc jt nc jt jt nc jt nc jt nc jt nc jt proof proof immediate notational assumption observation possible satisfying assignments counted way satisfying assignment possible 
lemma composite chains exactly variables common 
assume loss generality literals variable tail variable head chains 
result composition closed chain sufficient compute nc 
appear positive negative respectively variables chains antecedent chains consequent nc nc jt nc jt ii occurrences positive appears positive variable negated nc nc jt jt iii appear positive variable chain negated nc nc jt jt example consider case composing simple maximal chains gamma gamma different tail variable chains tail head respectively composite chain 
easy see nc nc jt nc jx nc jh nc jy nc jt 
nc gamma gamma 
proof proof immediate notational assumption observation possible satisfying assignments counted way satisfying assignment possible 
observations computation done time polynomial size formula completes correctness proof algorithm count cnf 
note case clauses contain constant appear tail head chain algorithm handle multiple occurrences 
fact true general 
composition rule holds require degree variables appear internal simple chain degree variables occurrences theory positive negative restricted 
problem case composite chain possible connection points number need keep track order implement algorithm grows exponentially 
allow logarithmic number variables unrestricted degree 
proof lemma sigma acyclic moncnf sufficient count number independent sets corresponding graph definition acyclic moncnf formula section acyclic graph 
consider case connected acyclic graph tree 
lemma tree vertices 
number independent sets computed time 
proof tree root vertex denote subtree root 
denotes set vertices children gc grandchildren denote number independent sets tree rooted independent sets denotes number contain root denotes number contain root notice independent set fz independent set claim represent number independent sets terms number independent sets subtrees claim defined pi ii pi gc iii pi gc pi proof fy fi collection independent sets respective trees independent set contain direction clearly independent set contain decomposed uniquely 
ii similarly independent set clearly gc fz independent set direction gc fz fi collection independent sets clearly fxg independent set contains vertex 
iii immediate ii 
algorithm count tree computes number independent sets tree 
denote rank vertex rank defined follows leaf 
internal node tree define max 
denote set vertices assume tree collection sets algorithm compute number independent sets tree rooted values boundary conditions notice tree contains single vertex children root leaves leaves correctness algorithm follows claim discussion completes proof lemma 
acyclic undirected graph union disjoint trees lemma completes proof 
count empty set independent sets 
count tree 
jc pi gc pi counting independent sets tree proof proof assume graph corresponds horn formula sigma connected component tree 
counting algorithm similar acyclic monotone case 
prove claim analog claim count satisfying assignments algorithm count tree 
claim denote number assignments satisfy conjunction clauses correspond tree rooted respect variables 
respectively denotes assignments assigned respectively 
pi ii pi iii pi pi proof prove observe assigned restrictions satisfying assignments tree rooted 
subtrees rooted different elements disjoint get result 
get ii observing assignment satisfies formula corresponding assigned iff assigned 
iii immediate ii 
noticing corresponding tree depth number satisfying assignments leaves serves boundary condition procedure uses claim count number satisfying assignments acyclic horn formula sigma 
similar algorithm count tree proof get algorithm computes number satisfying assignments efficiently 
