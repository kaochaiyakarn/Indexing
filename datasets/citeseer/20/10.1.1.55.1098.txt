logic computer science modelling reasoning systems michael huth department computing information sciences kansas state university usa 
mark ryan school computer science university birmingham uk 
contents preface acknowledgments propositional logic declarative sentences natural deduction rules natural deduction derived rules natural deduction summary provable equivalence aside proof contradiction propositional logic formal language semantics propositional logic meaning logical connectives mathematical induction soundness propositional logic completeness propositional logic normal forms semantic equivalence satisfiability validity conjunctive normal forms validity horn clauses satisfiability bibliographic notes predicate logic need richer language predicate logic formal language iii iv contents terms formulas free bound variables substitution proof theory predicate logic natural deduction rules quantifier equivalences semantics predicate logic models semantic entailment semantics equality undecidability predicate logic bibliographic notes verification model checking motivation verification syntax computation tree logic semantics computation tree logic practical patterns specifications important equivalences ctl formulas example mutual exclusion modelling attempt second modelling attempt model checking algorithm labelling algorithm pseudo code model checking algorithm state explosion problem smv system modules smv synchronous asynchronous composition mutual exclusion revisited alternating bit protocol model checking fairness alternatives extensions ctl linear time temporal logic ctl expressive power ctl fixed point characterization ctl monotone functions correctness contents correctness bibliographic notes program verification specify verify code 
framework software verification core programming language hoare triples partial total correctness program variables logical variables proof calculus partial correctness proof rules proof tableaux case study minimal sum section proof calculus total correctness bibliographic notes modal logics agents modes truth basic modal logic syntax semantics logic engineering stock valid formulas important properties accessibility relation correspondence theory modal logics semantic entailment natural deduction reasoning knowledge multi agent system examples modal logic kt natural deduction kt formalising examples bibliographic notes binary decision diagrams representing boolean functions propositional formulas truth tables binary decision diagrams vi contents ordered bdds algorithms reduced obdds algorithm reduce algorithm apply algorithm restrict algorithm exists assessment obdds symbolic model checking representing subsets set states representing transition relation implementing functions pre pre synthesising obdds relational calculus syntax semantics coding ctl models specifications bibliographic notes index bibliography preface motivation writing book years brought development powerful tools verifying specifications hardware software systems 
industry realized impact importance tools design implementation processes 
major companies intel siemens bt ibm actively investigating technology incorporation planning production departments 
necessitates availability basic formal training allows undergraduate students working programmers graduate students gain sufficient proficiency reasoning frameworks 
shift information technologies internet data access processing means increased demand qualified individuals reason sophisticated autonomous agent software able interact agents gather desired information large networks 
book addresses needs providing sound basis logic followed logical frameworks modelling reasoning computer systems 
provides simple clear presentation material 
carefully chosen core essential terminology introduced technicalities introduced required applications 
believe proposed course material vital contribution preparing undergraduate students today fast paced changeable professional environments 
confidence stems topicality proposed applications conviction solid background logical structures formalisms serve buoy rough waters software hardware developments 
preface abundance books mathematical logic logic computer science market 
aware book suits contemporary applications driven courses teach taught computer science curricula 
existing books tend written logicians computer science students heavy overloaded technical terminology 
ties computer science merely foundational nature isomorphism cut elimination sequent calculi 
evident need book introduces contemporary applications logic taken industry book accessible students want learn logic sake 
important say book provide completely omitted applications design theorem provers exposure constructive type theories calculus constructions logical framework mathematical foundation program synthesis design analysis implementation programming languages 
decision means meant represent judgment topics 
hope anticipate address important issues text suitable undergraduates 
reasons adopting book book zooms concepts heart logic presents contemporary fashion 
way discussing implementation principles material creates stimulating overlaps standard courses formal language theory data types programming 
differs existing books subject ways ffl new technical concepts introduced needed sake 
emphasis applications mathematical technicalities 
technicalities treated necessary rigour 
ffl introduce accessible level framework program verification symbolic model checking currently available research papers 
hot topic industry graduates fluent material highly sought 
ffl text supplemented web site offers additional www cs bham ac uk research lics preface material useful classroom presentations postscript files figures online overhead projector presentations html files smv code featured book 
ffl sections book exercises marked exercises 



provided sample solutions bona fide teachers instructors may obtain postscript files directly cambridge university press 
exercises short bar shown order reader know pick text 
outline book book observation logics design specification verification computer systems fundamentally deal satisfaction relation ffl oe sort situation model snapshot system oe specification formula logic expressing true situation example model communications protocol oe property protocol fair 
heart setup ffl computable compositional way 
fixing situation determine ffl oe holds recursively determining subformulas oe 
expand view particular logic ctl computation modelling situation may done purely symbolically boolean formulas 
tools support reasoning approach applicable quite realistic systems designs 
brief synopsis book covers chapter propositional logic common starting point backbone course book text courses presuppose knowledge propositional logic 
sections provide preface ffl complete presentation natural deduction style proof system propositional logic discussion intuitionistic fragment ffl section propositional logic formal language ffl semantics propositional logic constructively prove soundness completeness proof system respect usual truth table semantics discuss notions equivalence satisfiability validity cover principle mathematical induction needed soundness employed book central reasoning tools computer science feature section disjunctive normal forms horn formulas presentation highlights development algorithms computing normal forms discussing correctness 
chapter addresses predicate logic 
chapter ffl motivate need richer logics symbolic representations natural language sentences ffl define study predicate logic formal language standard notions static scoping free bound variables substitution ffl familiarize students semantics ffl introduce natural deduction style proof system predicate logic enriching proof system chapter elimination rules quantifiers system prove standard quantifier equivalences ffl church proof undecidability satisfaction predicate logic reduction post correspondence problem 
chapter introduces students model checking state art technique verifying concurrent systems 
ffl focus syntax semantics ctl computation tree logic derive standard algorithm model checking ctl formulas ffl students practice synthesis interpretation practically relevant frequently occurring specifications ctl ffl case studies great detail mutual exclusion protocol alternating bit protocol protocols developed labelled transition systems preface ffl introduce symbolic model verifier smv provide smv code case studies discuss relevant ctl specifications ffl explain ctl smv manage incorporate fairness constraints ffl discuss logics ltl ctl compare expressive power ctl ffl give fixed point characterization ctl operators express invariant behaviour ffl conclude pointing practical specifications obey common patterns offer pointers web sites patterns developed surveyed documented 
chapter covers program verification discussing deductive reasoning imperative programs presents floyd hoare style program logic sequential imperative core programming language reminiscent fragment programming language 
emphasis correctness proofs partial total correctness fairly simple programs 
main objective challenge students systematically develop small programs meeting required input output behaviour 
particular need develop ability come characterizing invariants loops 
chapter discusses modal logics agents 
modal logics motivated desire possible world semantics 
ffl discuss general syntax semantics extension propositional logic deduction calculus basic modal logic 
theme part chapter logic engineering oe means agent knows oe axioms inference rules engineer 
carry task various meanings 
ffl second part chapter devoted study modal logic modelling general reasoning knowledge multiagent system kt 
carefully explains epistemological puzzles solved modal logic 
chapter introduces binary decision diagrams data structure boolean functions 
ffl describe ordered binary decision diagrams obdds accompanying algorithms ffl discuss extensions variations obdds limitations ffl explain ctl models coded boolean formulas preface ffl syntax semantics relational mu calculus code ctl models specification presence simple fairness constraints 
chapter create stimulating links courses algorithms data structures courses circuit design foundation implementation projects develop tools supporting reasoning concepts developed chapters 
chapter provide pointers literature sites free software may downloaded applicable 
detailed index allow quick discovery cross connections chapters 
dependency chapters prerequisites 
book requires students know basics elementary arithmetic naive set theoretic concepts notation 
core material chapter sections essential chapters follow 
chapter depends chapter basic understanding static scoping rules covered chapter may easily cover sections having done chapter 
dependency graph chapters seen suggested course outlines suggest different ways teaching text week course 
ffl course chapters suitable students specialising database information systems artificial intelligence choice material prepare advanced topics database programming automated deduction 
preface ffl course chapters focus complete development verification framework concurrent systems implementation level 
ffl course chapters provide broader presentation logical foundations programming 
suitable courses book 
book main text book course logic computer science specification verification computer systems programs 
may quite useful additional text courses algorithms data structures logic artificial intelligence sequential circuit chip design validation discrete mathematics computer scientists formal language theory courses networks operating systems 
www page book supported www page contains list errata smv source code examples chapter exercises details obtain solutions exercises book marked links relevant pages 
url book page www cs bham ac uk research lics acknowledgments people directly indirectly assisted writing book 
david schmidt kindly provided exercises chapter 
pointed typographical errors authors allowed exercises book notably exercises 
borrowed exercises examples hod 
ariola josh hodas jan komorowski sergey scott smolka steve vickers corresponded text comments appreciated 
matt dwyer john hatcliff useful comments drafts chapter 
number people read provided useful comments chapters including graham clark christian anthony hook achim jung kevin lucas roberto segala alan sexton allen stoughton 
numerous students kansas state university university birmingham feedback various kinds influenced choice presentation topics 
acknowledge paul taylor package proof boxes 
half dozen anonymous referees critical constructive comments helped improve text various ways 
spite contributions may errors book take responsibility 
index abp acknowledgment channel alternating control bit fairness main smv program absorption laws data type sets abstraction non determinism accessibility relation adequate set connectives ctl propositional logic agent algebraic specification algorithm deterministic algorithm apply complexity control structure recursive descent algorithm cnf algorithm reduce complexity algorithm restrict complexity algorithm reduce example execution alternating bit protocol elimination application domain approach model proof approximants mz mz arity array bounds field integers section artificial intelligence artificial language assignment initial non deterministic program notation statement associativity laws assumption discharging stack assumptions temporary asynchronous circuit interleaving atom marking atomic formula modal logic predicate logic meaning axiom assignment equality modal logic instance schemes backus naur form bnf backwards breadth search base case basic modal logic bdd hi lo index boolean function complement consistent path edge examples ordering layer variables line dashed solid ordered read reduced removal duplicate non terminals removal duplicate terminals removal redundant tests satisfiable read bdd obdd duplicated belief binary decision diagram binary decision tree redundancies binding priorities basic modal logic integer expressions kt predicate logic propositional logic relational mu calculus bit control significant significant bit channel bit channel blocks code boole boolean algebra boolean connective boolean existential quantification boolean expression boolean forall quantification boolean formula independent variable semantically equivalent truth table boolean function don care conditions binary decision tree symbolic representation boolean guard boolean variable bottom bottom elimination bottom see elimination box elimination box branching time logic case overlap case analysis case statement characteristic function church circuit bit comparator asynchronous sequential synchronous circular definition clarke classical logic client clock tick closure propositional logic cnf code specification verification coding af ef eu ex examples symbolic evaluation fair fair eu fair ex set fair states command atomic compound common knowledge invariant communicating processes communication protocol completeness natural deduction predicate logic natural deduction propositional logic complexity exponential apply brute force minimal sum section algorithm fairness labelling algorithm labelling composition sequential synchronous compositional semantics compositionality model checking computability computation index intractable computation path fair computation trace computation tree logic computational behaviour computer program concatenation concurrency conjunct conjunction infinite connective adequate set unary consistency constant symbol contradiction control structure controlling value copy rule core programming language correspondence theory counter example counter trace critical section ctl subset ctl expressive power modalities model checker boolean combinations path formulas ctl connectives fair ctl formula square brackets ctl dag dashed box flavour data structure de morgan laws modalities deadlock debugging systems decision problem validity predicate logic decision procedure declarative explanation declarative sentence truth value default case definition inductive description informal language dijkstra directed graph acyclic cycle disjunction literals distributivity laws box modality connective propositional logic dividend don care links double negation elimination double negation elimination rule emerson encoding entailment program logics environment non determinism concurrent programs predicate logic formulas equality intentional program notation symbol equivalence relation equivalent formulas basic modal logic ctl kt kt ltl predicate logic propositional logic relational mu calculus exclusive existential quantifier exists elimination exists factorial natural number program fairness nested fixed points symbolic model checking fairness constraint simple fairness running fibonacci numbers field index finite automata finite data structure order logic fixed point greatest semantics ctl flow control index floyd loop forall elimination forall formal path formula height horn immediate subformula basic modal logic ctl atomic ill formed formed ltl valid predicate logic propositional logic formed relational mu calculus positive scheme propositional logic instance subformula frame free oe frege function predicate logic monotone non example recursive sat termination symbol binary translate function pre function pre function sat correctness excludes includes includes world reachable steps godel gentzen grammar clause halpern hoare triple hoare hodges horn clause hybrid rule statement implication logical implies elimination implies order representation inconsistency index induction course values hypothesis model checking mathematical inductive step infix notation information negative information content input parameter integer expression integer label integer multiplication interface logics interleaving formulas code transitions rules introspection negative positive intuitionistic logic invariants discovering iterative squaring jape justification knaster tarski theorem knowledge common distributed false formula positive idealised multi agent system modality agent kozen kripke model counter example kt index kripke label adding deleting labelling af eu ex labelling algorithm labelling function coding subsets ctl model kripke model frame language construct law excluded middle laws arithmetic lem instance linear time logic linear time temporal logic literal liveness property logic engineering logic programming logical level look table dated ltl machine state manna mcmillan computed obdds minimal sum section minimal sum section problem modal connective cg modal logic kt kt normal modality diamond path model kt basic modal logic ctl pictorial representation intuitionistic propositional logic kt kt predicate logic propositional logic model checker model checking algorithm debugging example fairness constraints model ctl model verification module modulo counter modus ponens modus muddy children puzzle mutex model pictorial representation mutual exclusion natural deduction extension predicate logic modal logic temporal logic inventor natural deduction rules basic modal logic kt predicate logic propositional logic necessity logical physical negation negation elimination see bottom elimination negation nested boolean quantification network architecture synchronous strict sequencing node initial leaf non terminal terminal non blocking protocol non determinism non termination normal form conjunctive disjunctive negation ctl ltl product sums sum products elimination index obdd absence redundant variables canonical form complementation definition extensions pre pre integer multiplication intersection limitations nested boolean quantification parity function odd parity function transition relation optimal ordering reduced unique representation reduced logical iff representing subsets running time algorithms upper bounds sensitivity size synthesis boolean formula test implication satisfiability semantic equivalence validity union variations odd parity function omniscience logical elimination overloading proof rules parity function obdd parity obdd parse tree predicate logic formula term basic modal logic formula ctl formula propositional logic formula root subtree underspecified partial correctness partial order reduction pattern pattern matching place holder pnueli possibility logical possible world semantics post correspondence problem postcondition program logic prawitz precondition program logic weakest algorithm predicate binary number arguments symbols unary predicate logic extension prefix notation ordering premise preprocessing prior problem instance reduction procedural interpretation process concurrent instantiation processor program behaviour bug code construct correctness derived diverging documentation environment finite state fragment logic methodology procedures sequential termination variable verification formal program execution programming language imperative proof box forall modal logic index opening side side contradiction calculus construction constructive dashed box fragment indirect correctness termination partial partial correctness search solid box strategy subproof tableaux theory total correctness proof rules implication assignment conjunction disjunction double negation equality existential quantification statements modified implication kt negation quantifiers sequential composition universal quantification statements schema subformula property proof tableaux complete proof verification proposition propositional logic protocol provability undecidability predicate logic quantifier equivalences predicate logic binding priorities equivalences meaning reasoning knowledge constructive arbitrary related world informal quantitative unsound record field recursion mutual recursive call reductio ad reduction absurdity regular language relation binary euclidean functional linear reflexive formula serial symmetric formula total transition transitive formula relational mu calculus explicit substitution fixed point operators restriction root parse tree rule derived hybrid safety property satisfaction frame frame kt satisfaction relation relational mu calculus basic modal logic ctl kt ltl partial correctness predicate logic relational mu calculus total correctness satisfiability sat deciding predicate logic formula propositional logic formula undecidability predicate logic scc fair scheduler fair scope dummy variable variable assumption index search space semantic entailment basic modal logic kt normal modal logics predicate logic propositional logic relational mu calculus semantic equivalence semantics basic modal logic boolean quantification ctl equality predicate logic propositional logic relational mu calculus sentence atomic components declarative predicate logic sequent invalid unsound shannon expansion side condition sifakis smv main program abp module receiver sender channel instantiation process program example mutex specification soundness forall elimination natural deduction basic modal logic predicate logic propositional logic program logics proof rule statements substitution principle spec specification ctl formula abp formal informal language predicate patterns practical pattern symmetric truth table spin state critical explosion explosion problem fair formula global graph initial non critical system reachable resulting space splitting states transition trying storage location state string binary empty strongly connected component structural induction substitution predicate logic instance instance tautology principle symbolic model checking symbolic model verifier syntactic category domain syntax basic modal logic boolean expressions boolean formulas ctl ctl horn formulas kt literals ltl predicate logic propositional logic relational mu calculus terms system asynchronous interleaving model simultaneous model axiomatic commercial critical component index concurrent debugging description design development elevator finite state hybrid infinite state mission critical multi agent physical reactive safety critical transition verification tautology temporal connective af ag au ax ef eu ex temporal connectives temporal logic term interpretation term rewriting system termination proof non theorem prover proving time continuous discrete top total correctness transition relation smv programs transition system abp program mutex code smv program unwinding translation english predicate logic tree infinite truth dynamic mode knowledge static value predicate logic propositional logic truth table conjunction truth tables type checking theory unary connective undecidability provability satisfiability validity predicate logic universal quantification universal quantifier universe concrete values unsound sequent natural language negating weak updated valuation validity basic modal logic kt propositional logic undecidability predicate logic valuation predicate logic propositional logic relational mu calculus value initial variable boolean bound capture dummy free local logical variable ordering compatible list variant verification full method communication protocols hardware software systems post development pre development process program property property oriented semi automatic techniques index weak ctl ctl ltl weakest precondition statement body non termination wise men puzzle word empty world possible related year problem bibliography ake akers 
binary decision diagrams 
ieee transactions computers 
ao apt 
olderog 
verification sequential concurrent programs 
springer verlag 
bac backhouse 
program construction verification 
prentice hall 
bcm burch clarke mcmillan dill hwang 
symbolic model checking states 
ieee symposium logic computer science 
ieee computer society press 
eisenbach vickers 
reasoned programming 
prentice hall 
bj jeffrey 
computability logic 
cambridge university press nd edition 
boo george boole 
investigation laws thought 
dover new york ny usa 
bra 
verifying temporal properties systems 
boston mass 
bry bryant 
graph algorithms boolean function manipulation 
ieee transactions compilers 
bry bryant 
complexity vlsi implementations graph representations boolean functions applications integer multiplication 
ieee transactions computers february 
bry bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys september 
ce clarke emerson 
synthesis synchronization skeletons branching time temporal logic 
kozen editor logic programs workshop number lncs 
springer verlag 
cgl clarke grumberg long 
verification tools finite state concurrent systems 
decade concurrency number lecture notes computer science pages 
springer verlag 
cgl clarke grumberg long 
model checking abstraction 
acm transactions programming languages systems september 
bibliography che chellas 
modal logic 
cambridge university press 
dam dams 
interpretation partition refinement model checking 
phd thesis institute programming research algorithmics 
eindhoven university technology july 
dij dijkstra 
discipline programming 
prentice hall 
dp davies pfenning 
modal analysis staged computation 
rd annual acm symposium principles programming languages 
acm press january 
en elmasri navathe 
fundamentals database systems 
benjamin cummings 
ronald fagin joseph halpern yoram moses moshe vardi 
reasoning knowledge 
mit press cambridge 
fit fitting 
basic modal logic 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming volume 
oxford university press 
fit fitting 
order logic automated theorem proving 
springer nd edition 
fra francez 
program verification 
addison wesley 
fre frege 
der 

vol 
ii jena 
gal gallier 
logic computer science 
john wiley 
gen gentzen 
investigations logical deduction 
szabo editor collected papers gerhard gentzen chapter pages 
north holland publishing 
gol goldblatt 
logics time computation 
csli lecture notes 
gri gries 
note standard strategy developing loop invariants loops 
science computer programming 
ham hamilton 
logic mathematicians 
cambridge university press 
hoa hoare 
axiomatic basis computer programming 
communications acm 
hod hodges 
logic 
penguin books 
hod hodges 
elementary predicate logic 
gabbay guenthner editors handbook philosophical logic volume 
dordrecht reidel 
hol holzmann 
design validation computer protocols 
prentice hall 
koz kozen 
results propositional mu calculus 
theoretical computer science 
lee lee 
representation switching circuits binary decision programs 
bell system technical journal 
lon long 
model checking abstraction compositional verification 
phd thesis school computer science carnegie mellon university july 
mcm mcmillan 
symbolic model checking 
kluwer academic publishers 
mp manna pnueli 
temporal logic reactive concurrent systems specification 
springer verlag 
bibliography mp manna pnueli 
temporal verification reactive systems safety 
springer verlag 

ch 
meyer van der hoek 
epistemic logic ai computer science volume cambridge tracts theoretical computer science 
cambridge university press 
pap papadimitriou 
computational complexity 
addison wesley 
pau paulson 
ml working programmer 
cambridge university press 
pnu pnueli 
temporal logic programs 
theoretical computer science 
pop 
steps modal logic 
cambridge university press 
pra prawitz 
natural deduction proof theoretical study 
almqvist wiksell 
qs sifakis 
specification verification concurrent systems cesar 
proceedings fifth international symposium programming 
ros roscoe 
theory practice concurrency 
prentice hall 
sa antoniou 
logic foundation computer science 
addison wesley 
sch 
logik fur 

sch schmidt 
structure typed programming languages 
foundations computing 
mit press 
sim simpson 
proof theory semantics intuitionistic modal logic 
phd thesis university edinburgh department computer science 
tay taylor 
models computation formal languages 
oxford university press 
tennent 
semantics programming languages 
prentice hall 
tur turner 
constructive foundations functional languages 
mcgraw hill 
vd van dalen 
logic structure 

springer verlag rd edition 
wei weiss 
data structures problem solving java 
addison wesley 
