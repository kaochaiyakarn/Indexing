survey assessment software process representation formalisms pasquale sergio carlo ghezzi angelo politecnico di milano esprit iii project technical report december process modeling young active research area 
years new languages methods proposed describe software processes 
try clarify issues involved software process modeling identify main approaches 
start motivating process modeling main objectives 
propose list desirable features process languages 
features grouped provided languages fields specific features process domain 
review main existing approaches propose classification scheme 
industrial products produced set pre established methods procedures integrated production process 
goal production processes produce quality artifacts reliable predictable efficient manner 
software artifacts result software production processes involve number steps activities conception idea delivery system evolution 
wide consensus quality artifacts depends process produced 
traditional industrial production processes may applied software order help improve software processes support production high quality software systems 
software distinguishing characteristics traditional production processes inadequate 
software production process multi person largely intellectual design activity partially automated 
cooperation humans coordination human activities play fundamental role 
evolutionary activity software products subject continuous modifications software process modified executed process product requirements highly unstable 
focus software processes relevant research theme quite quickly drawn considerable interest academia industry 
series workshops software processes organized th 
international software process workshop held october international conference launched series held 
possible group current software processes broad areas 
focuses managerial issues aims improving current industrial practices focusing organizational issues 
relevant done software engineering institute sei carnegie mellon 
describes methodology developed sei software process assessment known maturity framework 
area includes criticism conventional waterfall process study new paradigms 
second research area addresses technical issues involved specifying mechanically supporting software processes 
starting point recognition universally valid software process automated replicated new application development 
process support environment tailored possibly new application development 
area software process representation notations play important role 
able representation formalism describing software processes improve communication people technical managerial level 
able automate parts process 
general agreement possible describe real practical software processes completely formal way 
advantages partial formalization valuable 
successful modeling requires adequate notation language 
notations textual graphical mixed text graphics 
notations defined syntax qualify languages 
languages formally defined semantics amenable formal reasoning 
terms notation language interchangeably concentrating facilities offered describe software processes 
primitives software process mod eling language chosen process concepts naturally expressed 
aware probably process language defined 
quoting rombach effectiveness tool general process description language particular depends context objectives degree features understood 
organization follows 
section identify general objectives software process modeling 
section derive list properties requirements software process representation language 
section provide classification different process language approaches evaluate approaches 
section draw 
software process modeling objectives process modeling relatively new research area consequently general consensus final objectives 
main goals may classified follows 
communicating 
software process framework interacting agents cooperate develop software applications support evolution produce maintain reusable components different kinds roles may involved different people may interacting process managers software engineers users software process common ground individuals cooperatively 
despite importance process normally left implicit little attention paid making clearly understood participants process 
providing explicit representation process clearly understood helps improve communication people 
estimating planning 
engineering project expected produce reliable product limited time limited resources 
initial part project manager responsibility estimate resources needed accomplish task terms man months total expected duration 
initial estimate plan constructed utilization resources process milestones met deliverables produced controls accomplished explicit representation software process provides rigorous framework estimating planning 
explicitly represented processes may formally analyzed order complement manager judgement intuition 
example managers may simulate effect decisions evaluate implications examine past decisions taken similar circumstances 
managing re planning 
process descriptions help managers monitor project respect plan react deviations may occur re planning re estimating 
forms change anticipated defined software process form possible iterations forms require structure process deeply modified 
changes quite critical deal 
change applied process resumes execution state may inconsistent change ideally system tolerate inconsistency possibly return consistent state gradual fashion 
measuring 
measures provide quantitative assessments process product qualities 
assess going process decide modification applied process order improve 
having explicit representation software process may precisely define perform measurements 
measures may collected automatically 
measures turn may provide quantitative evidence merits weaknesses different processes helps improve processes experimentation 
configuring 
main assumption software process blanket process model exists suitable process model defined depending nature project developed 
process adapted organization project hand may evolve quality improvements example incorporating new tools techniques 
providing notation explicit process representation principle may configure desired process support environment 
defined process activities performed humans mechanically supported tools provided environment 
number process centered software development environments currently designed arcadia esf 
consequently may view software process description specification environment configuration 
reusing 
processes need defined scratch time 
process descriptions help materialize previous experiences terms knowledge may reused basis new processes new projects 
presently widely practiced form process reuse personnel reuse 
software specialists transferred project may apply previous experience new development 
providing explicit process representations knowledge independent individuals process reuse may standard 
executing 
process description defines activities performed software engineering environment management technical ties 
activities performed concurrently geographically dispersed units 
depending level formality notation process representation may derive interpreter notation 
notation executable possibly different levels completeness 
exactly happens aforementioned environments 
word enaction execution interpretation process modeling area mean execution process done machines symbiosis human beings computers 
verifying 
formal notation process specification provides powerful ways process verification 
example process verifications finite state machines petri nets may verified showing certain properties hold certain desirable states reachable arise petri net behavior 
form process verification may provided simulation 
simulation may obtained execution process language may generate process scenarios support form analysis happens certain activities executed parallel sequentially 
said execution possible interpreter notation act run time engine development environment 
case explicit formal process description may input environment configuration activity provides communication infrastructure supporting cooperative individuals involved process consistent process description 
infrastructure part automatically derived process formal description 
significant step tailoring process centered environment needs specific project developed 
software process language features objectives desirable features process language 
features evaluate various proposed approaches process modeling 
software production process may addressed points view 
single approach able adequately capture multiple aspects process modeling 
software process field may viewed synthesis diverse areas research application addition peculiarities 
software process languages profit previous linguistic approaches borrowing language features areas adding new features specific software process applications 
idea classify software process language features provided languages fields specific features process domain 
features inherited general purpose sequential programming languages features different ways extents modern programming languages 
applicability limited development programs implement general principles apply process modeling 
mention ffl abstraction ffl modularity ffl genericity ffl nondeterminism 
abstraction mechanism allows focus important aspects system irrelevant details remain hidden 
abstraction important process modeling helps mastering complexity process allowing designer user process concentrate important phase software development 
feature related abstraction modularity provides possibility structuring specification program logically independent units called modules 
genericity provides way describing general solution set related problems parameterizing respect possible instantiations 
generic solution instantiated specific problem 
modularity genericity features great importance process languages essential reusability evolvability 
certain levels abstraction description process may useful specify choice open alternatives performed 
kind underspecification called nondeterminism supported process modeling language 
features inherited concurrent reactive realtime system languages concurrency increasingly important programming language feature 
software processes intrinsically concurrent members software development team concurrently interact accomplishing tasks 
language provide mechanisms specifying concurrent activities synchronizing evolution 
software processes common reactive realtime systems 
fact software processes may viewed set activities proceed parallel react external events may occur unpredictable times 
activities scheduled way respects logical precedence relations meets required deadlines 
correctness process depends correct execution individual steps meeting time constraints 
time constraints process modeling different order magnitude ones find critical real time systems basic characteristics time dependent shared kinds systems 
order appropriately model software production process process modeling languages include features inherited concurrent real time languages ffl parallelism ffl time constraints specification ffl description interaction environment 
features inherited database languages influence databases software processes new 
databases part software engineering environments provide repository persistent data stored accessed concurrently multiple users 
application databases software processes brought new problems database field 
traditional database technology able efficiently deal objects different degrees granularity needed software development environments 
example needs represent large objects programs manuals executable code fine grained levels individual node parse tree representing statement 
addition traditional databases provide specific facilities deal versioned objects 
conversely software artifacts subject continuous evolutionary changes development history stored maintained different versions 
traditional transaction model inadequate software process applications 
transactions may long duration may require user interaction multiuser synergistic efforts 
sample software engineering transactions may correspond building new release performing regression testing performing corrective maintenance 
acceptable possible lock accesses involved data roll back transaction reason commit 
development advanced non conventional database systems presently active research topic spans variety applications areas cad software engineering environments 
process language integrated underlying software engineering database order support cooperation project group controlling access different versions different documents 
points summarize required process languages features coming database field ffl provide conceptual data model independent physical model ffl efficiently handle persistent objects different granularity ffl support long transactions ffl support versioning 
software process specific features software processes characteristics different processes 
software production creative intellectual activity completely formalizable 
software process modeling languages support incomplete ambiguous informal descriptions formal ones 
describe interaction humans interactions automatic tools 
consequence execution activities involved software process done entirely computers 
fact partially formalized formalizable activities require human intervention 
process languages able describe binding activities computer devices model human intervention tool invocation tool required carry task 
true fact materializing process simply writing big step making process explicit implicit repeatable understandable transferable 
additional substantial advantage precise description analyzed enacted people involved process constrained follow 
analysis process may performed simulating execution 
analyzing results simulation may evaluate effect certain process design decisions implications certain managerial decisions perform kind process assessment enacting 
forms assessment performed enaction providing process measurements process features process productivity cost risk assessed 
measurement integrated software process provide line feedback managers improve correct development carried advice structuring processes 
process languages offering measurement analysis facilities effectively contribute management software project 
process centered environment process model code executed process interpreter said interpreter consists mixture machines humans 
automation may obtained process language interpreter integrate individual tool fragments larger grain tools 
addition process models help control evolution process support coordination cooperation people working software project providing guidance assistance development cycle 
software production process may take long time subject changes time 
software process language flexible allow dynamic process modification enacted 
modifications may caused deviations manager plans may range changes assignment tasks persons serious changes regarding example precedence relation activities 
process language impose restrictions kinds allowed modifications guarantee example consistency preserved certain properties maintained 
software production process representable process language 
includes technical activities management activities 
management basic problem software production 
management decisions strong impact technical aspects project 
project may fail poor management correct technical point view 
management activities include resource management planning controlling 
satisfy management requirements process language offer tools build schedules resources efficient way assist manager making estimates example simulating process said notify managers soon technical steps accomplished provide adequate policies exception handling detect correct deviations plans 
distinctive features required process modeling languages may summarized follows ffl permit coexistence formally described parts informal incomplete ambiguous parts process specification ffl support binding execution different parts process computing devices human beings predefined tools 
ffl support controlled modification enactment 
ffl represent technical activities 
ffl provide analysis tools including process product measurement facilities scheduling planning tools ffl represent done certain activity fails 
classification assessment purpose section give succinct overview relevant approaches software process languages literature 
area rapid evolution languages evolving overview may inaccurate incomplete points 
overview illustrates main directions followed research area software process modeling describes main benefits may expected 
table show classification relevant approaches 
considered process language representation style kind interface textual vs graphical 
languages combine different representation styles classified just style 
considered styles logic rules ru denotes ruled logic language approaches attribute grammars gr automata includes finite state automata petri nets imperative programming languages ip artificial intelligence ai refers languages ai techniques event formalisms data types adt 
sample process modeling languages surveyed order discuss pros cons different approaches 
cases include small example give concrete flavor language 
adele adele environment built central versioned database components environment stored 
adele database entity relationship model extended object oriented fashion supporting long transactions user defined commands activities 
tasks having long duration performed directly database 
adele mono version sub database associated user set directories files set tools task 
coordination managed activity manager trigger mechanism 
triggers actions executed automatically condition holds 
trigger mechanism style ru gr ip ai adt tx gr adele alf appl entity epos marvel merlin mvp spade table classification software process languages support process specific actions constraint integrity checking propagating updates instance interface module modified trigger mechanism may evaluate impact modification related modules causing affected modules notified recompiled necessary 
adele specifically designed manage activity coordination software production process 
currently intention offer mechanism complete formalization software processes help control software production processes 
alf alf software process model described hierarchy model assisted software processes 
describes part software process model turn detailed 
permits description different levels abstraction 
generic description instantiated executed 
instantiation need completed enaction begins 
instantiation enaction may interleave part development executed may taken account instantiate part 
described tuple om op ex ru ch 
om object model provides conceptual data model era entities relationships attributes 
ex set expressions specified order logic language describe operator types op rules ru characteristics ch 
operator types describe semantics software process activities terms pre post conditions 
rules de fine possible automatic reactions specific situations arising software process 
characteristics specify constraints process states satisfied raise exception condition 
set orderings specified path expressions specify operators executed parallel alternatively sequentially 
alf main goals provide assistance software development 
user receives guidance certain process works perform certain action 
addition explanations invocation operator rejected system takes initiative operation invocation violate characteristic 
appl appl process programming language part arcadia project 
basically appl superset ada enables definition relations software objects 
fact relations appl data model extension conventional codd model relations class objects 
ada appl inherits language basic features type system module definition style packages task communication paradigm rendezvous 
appl process descriptions procedural way 
certain aspects consistency conditions may specified rule style 
order show appl process program looks taken presents appl function obviously part larger program telling result test ok function function result needed declare result derived result needed req output result fcn output needed result observ timing needed time false true endif appl example 
checks result satisfies needs computed function test execution time testcase equal execution time needed 
part environment software project management 
software development process described modified deterministic petri net model augmented graphs describe hierarchical decomposition activities documents 
words hierarchical abstraction graphs parallelism petri nets may expressed model 
taken shows way petri nets graph combined model 
database support exists offering example 
extendible object oriented conceptual schema contains description objects relation 
object types operations defined order keep time information time stamp corresponding global clock associated document created 
interesting feature model token game may played different levels abstraction letting newly created tokens propagate upwards hierarchical structure 
stated mechanism provides valuable assistance version control configuration management 
introduced informal way semantics obscure 
entity model modeling software processes centered entities considered persistent non transient objects existence limited phase software process spans entirety 
examples entities requirements document finished programs documentation design general artifact produced process execution entities involved modeled process described means states successively undergo events trigger transitions states 
states characterized fact non zero length time intervals transitions states considered instantaneous 
software process described set cooperating finite state machines statemate facilities parallel composition system subcomponents communications 
entity number states represented orthogonal component orthogonal components represent entities evolving concurrently 
instance taken depicts entity process description sample software process consisting entities module code module unit tests test execution 
entities represented high level orthogonal state components corresponding filled quadrants upstream downstream entities lower right quadrant temporarily left unspecified 
states quadrants depict possible states entities transitions represented lines labels define triggers cause transition 
default transitions small dot lead outer state initial states non existing entity new newly produced entity indicating process begins entities states 
noted transitions component may labeled events occurring parallel orthogonal component labels may boolean compositions elementary events 
facilities statemate exploited perform schedule planning analysis modeled process 
initial idealized model called unconstrained process model obtained assuming unconstrained availability resources supporting tasks transitions states process 
analysis exclusively logical interconnections transitions events 
providing additional information number times loops performed time length iteration estimates possible evolutions process form gantt charts derived 
second model called constrained process model takes account limitations available resources typical real software organizations personnel computing resources may available desired quantities 
entity model example 
analysis constrained model results gantt charts permit realistic accurate simulation process practice process enactment 
epos epos multi paradigm system combines unified framework characteristics distinct approaches 
epos descriptions process data process operates stored unique object oriented repository entity relationship data model 
architecture possible describe simultaneously integrated framework management successive product configurations process performed order produce 
relationships database active creation update related objects performed interrogation search data base lazy eager strategy 
actions originated activations rules possess triggering mechanism forward backward activation pre post conditions imperative code part 
various elements process tasks procedures tools roles modeled set types organized objectoriented hierarchical inheritance structure 
example consider reported shows fragment epos type hierarchy 
type hierarchy shows epos repository simultaneously contains description artifacts software process agents automatic human involved active components process procedural non procedural description process 
process instance modeled set tasks dynamically created 
task may initiated user environment root type persistent objects version groups general relationships general entities software component passive procedure actor manual automatic agent tool automatic tool role generic person task active process chained task epos type hierarchy fragment 
issuing change command data base 
execution process handled activity manager builder planner components 
activity manager formulates possibly interaction user task descriptions builder governs task instantiation planner handles task execution goal directed heuristics 
epos process environment possesses rich variety features borrowed nearly approaches literature allow dynamic flexible management processes 
quite difficult get picture system combines numerous heterogeneous constructs facilities providing available literature detailed formal semantics 
highly dynamic structure epos process model prevents users having clear mental picture properties reasoning behavior 
nets nets high level petri net notation built top predicate transition nets 
provide extensions proved useful support software process modeling including example ability associate policy places random fifo lifo different firing behaviors respect number consumed produced tokens mult complex petri net formalism nets naturally represent nondeterminism parallelism 
possible associate value transition order model duration activity represented transition 
information simulation mode animate behavior described net 
objects involved process net modeling waterfall software process 
described extensible set object types 
example taken illustrates waterfall process modeled nets 
place annotated policy object type 
transitions marked dec detailed subnet 
nets suitable representation complex activities 
developed special attention simulation validation support analysis properties modeled process 
possible underlying predicate transition net order perform analysis invariant analysis 
nets support simulation dynamic modification process support full enactment 
hierarchical functional software process description enaction developed tokyo institute technology prototyped part sage programming environment 
provides functional approach theory attribute grammars 
basic idea activities functions produce output objects input objects 
activities decomposed grammar rules attribute rules describe input output relationships terms associated 
functional language reflective execution status treated basic data type handled formalisms 
means process may modified process 
precisely activity inputs outputs may represented grammar nonterminal inherited attributes synthesized attributes shown activities may decomposed grammar rules 
example rule gives high level description jsp function describes specification transformed program jsp methodology 
jsp spec spec activity 
spec operators operators rule describes program tree lists operators needed program produces intermediate program performs specific jsp function program inversion 
intrinsically concurrent explicit dependencies attributes may evaluated parallel 
describe nondeterminism having rules activity 
language may interact object base jy input objects may extracted database output objects may inserted database 
published examples theory underlying language clear 
clear papers human interaction process modeled handled environment 
marvel marvel project administrator specifies software process model terms rules 
rules classified different sets project rule set describes process specific issues project type set specify data object oriented classes project tool set describes interface external tools 
project rule set composed kinds rules activation rules inference rules 
activation rules control initiation development activities typically involve invocation tool 
generally multiple mutually exclusive sets effects may different conditions 
example rule modeling invocation compiler may success producing object code may fail producing set error messages 
inference rules define relation attributes objects activity invocation part left empty single effect 
example activation rule consider compile rule shown taken 
typed object file parameter parameter name 
follows condition satisfied rule execution 
curly braces follows activity invocation contains invocation tools case invocation compiler 
rule finishes list exclusive sets effects 
set effects conjunction logical predicates assign values attributes parameter objects 
rules may executed applying forward backward chaining 
user wants execute rule condition satisfied backward chaining applied fire rules effect satisfy condition 
result backward chaining satisfaction action compile 
compile status compiler compile contents object code error msg compile status compiled object time stamp currenttime compile status error marvel activation rule 
notification user command executed 
condition satisfied activity initiated terminates rule effects asserted 
may enable execution rules causing forward chaining 
merlin merlin software process modeling language rule technique build knowledge base describing software process 
rules facts knowledge base may interpreted forms backward forward chaining 
backwards rules facts prolog notation interpreted prolog manner 
backward mechanism exploited select roles activities user may perform 
collect information order answer queries process state 
forward chaining applied explicit guidance provided system 
rules interpreted forward chaining consist precondition list activities postcondition 
worth noting changes occur runtime persistent knowledge base 
feature gives possibility interrupt process execution restart exactly point stopped 
merlin supports basic abstractions software process activities software objects roles resources 
time lacks structuring mechanisms large rule sets 
parallelism recognized central research topic currently supported 
rules facts may dynamically inserted deleted knowledge base model exhibits great flexibility representing changes occur process execution 
order give flavor merlin consider scenario roles designer programmer tester exist 
association people roles described facts form role role name 
taken shows user starts working merlin rule execute job executed 
suppose user case role tester 
consequently unify tester test rule called 
tester selects item list items done 
item list corresponds rule 
suppose item test environment chosen 
checked person assigned test module module project proj testing module incomplete 
test rule executed test menu displayed 
described mechanism corresponds backward chaining 
execution test done forward chaining guidance user possible activities modeled explicitly 
note shown rule forward chaining rules different syntax provide way test preconditions action insert postconditions knowledge base 
mvp mvp multi view process modeling going project developed university maryland 
mvp textual process language defined project 
main goal building descriptive models large real world software processes having ways analyze execute able improve 
specific emphasis mvp project process improvement measures gathered process executed process packaging support process reuse 
mvp process models typed descriptions 
specific processes instances types 
define new process models may elementary process product resource models building blocks 
environment software process modeling combination logic programming blackboard paradigm problem solving 
atomic entities roles professionals services model typical resources software development process 
composed entities processes environments model activities performed develop software product 
entities may hierarchically decomposed introducing descriptions different levels abstraction 
agents connected blackboards 
agent behaves reactive system reacts presence facts blackboard 
behavior agent defined theory 
theory set reaction patterns execute job check identification name select task name 
select task name role tester name test name display menu check continuation item test item item 
select task name display 
test name display menu test item item name item 
item name test environment tester proj module name tested proj module incomplete test proj module test name 
test proj module exist test environment proj module incomplete call editor proj module status insert exist test environment proj module status 
merlin example 
prolog program known knowledge base 
pattern defines pair stimulus response 
stimulus set facts response goal called body set facts called success set 
optionally similar failure set 
machine governing process enactment highly nondeterministic 
agents execute concurrently reading information blackboards 
agent considers patterns theory parallel 
pattern fire blackboard contains facts unify listed stimulus set 
pattern chosen nondeterministically body executed prolog knowledge base 
execution terminates success facts success set written failure set written 
communication agents obtained allowing agents write blackboards 
documents involved software development may kept database offered environment service 
dbs database service provides predefined schemes predefined documents related accepts new scheme definitions 
spade spade software process environment currently developed politecnico di milano 
environment includes process language called slang built top high level petri net formalism called er nets 
slang distributed notion state described marking net 
transitions represent events may may occur state transition firing represents occurrence event 
conditions occurrence event local described input places 
net topology describes precedence relation events describes parallelism conflict situations 
places viewed distributed persistent object repositories model collections data tools resources actions executed response occurrence event modeled logic language 
timing information time interval event may occur specified associating time stamps tokens time changes actions 
toy example slang net showing manage editing modules 
set modules developed module owner assigned engineer 
edit requests arrive programmers working process 
request issued owner module module goes state module edited 
request issued programmer parallel version module created edited 
addition owner module notified mail new version module exists 
slang highly expressive allows representation different aspects process human resource management interaction net executor hosting environment precedence relation events time information homogeneous way 
open issues immaturity process modeling field manifest high level semantic ambiguity lack consolidation software representation languages 
young area open issues especially areas ffl representation interaction humans slang example 
ffl mechanisms manage failures unforeseen events ffl mechanisms guarantee modification process fly done disciplined controlled way ffl integration process modeling process management planning monitoring 
ffl integration process data modeling software engineering databases long transactions 
said existing paradigm expressive adequately model aspects software process 
tackle problem languages adopted multi paradigm approach 
expressive power provided different languages order describe software processes demonstrated far case studies context exercises proposed international software process workshops 
case studies source inspiration extensions incorporated various language proposals 
existing languages evolving syntax semantics seldom defined precise formal way 
comparisons evaluations difficult firm grounds 
eventually languages consolidated formal definition shall 
notations lacking precise meaning 
languages petri nets able model parallelism nondeterminism naturally explicitly 
true rule languages execution control implicit 
hand rule system dynamic modification process dealt natural homogeneous way 
presently software process language provides satisfactory solution required features especially distinctive features process models 
experimentation research needed required language features identified 

ciancarini software process enactment proceedings th 
acm sigsoft symposium software development environments irvine california december 

definition enactment software process entities european workshop software process modeling milan italy may 

hierarchical specification software processes european workshop software process modeling milan italy may 

balzer don know software processes european observatory software engineering case software quality milano october 

fuggetta ghezzi software processes real time systems case study high level petri nets proceedings international phoenix conference computers communications arizona april 

fuggetta ghezzi process enactment spade 
proceedings second european workshop software process technology norway september 
kaiser concurrency control advanced database applications acm computing surveys vol september 

kaiser scaling rule software development environments proceeding rd 
european software engineering conference esec 
milan italy october 

estublier melo adele approach software development coordination european workshop software process modeling milan italy may 


ph 
griffiths ph 
presentation alf project proceedings international conference system development environments factories berlin may 

cameron jsp jsd jackson approach software development ieee computer society press silver spring maryland 

conradi software process management epos ifip wg meeting september 

managing software process environment proceedings og th 
acm symposium practical software development environments irvine california december 

ed proceedings rd 
international software process workshop colorado usa november 

emmerich nets petri net sofware process modeling language proceedings th 
inter national workshop sofware specification design como italy september 

emmerich schafer merlin knowledgebased process modeling european workshop software process modeling milan italy may 

eureka software factory concepts accomplishments proc 
rd 
european software engineering conference esec 
milan italy october 

predicate transition nets advances petri nets lncs springer verlag 

validation verification software process models ph 
thesis dortmund university 

harel naamad pnueli sherman statemate working environment development complex reactive systems 
th 
international conference software engineering 

humphrey managing software process sei series software engineering addison wesley 

humphrey kellner software process modeling principles entity process models proceedings th 
international conference software engineering 
schafer step knowledge software process modeling proceedings conference system development environments factories 
larsen conradi software process modeling evolution epos proceedings th international conference knowledge engineering software engineering capri italy june 

kaiser preliminary experience process modeling marvel sde kernel proceedings ieee rd hawaii software track 

kaiser feiler architecture intelligent assistance software development proceedings th 
international conference software engineering monterey april 

katayama hierarchical functional software process description enaction proceedings th 
international conference software engineering pittsburgh pa 

liu conradi process modeling paradigms evaluation european workshop software process modeling milan italy may 

liu horowitz formal model software project management ieee transactions software engineering october 

zucker griffiths approach software process description instantiation enaction european workshop software process modeling milan italy may 

osterweil software process software proceedings th 
international conference software engineering 

perry ed proceedings th international software process workshop kennebunkport maine usa september 

rombach framework assessing process representations internal report university maryland 

rombach mvp language process modeling submitted publication ieee transactions software engineering 

sutton heimbigner osterweil language constructs managing change process centered environments proceedings th 
acm sigsoft symposium software development environments irvine california december 

taylor belz clarke osterweil selby wolf young foundations arcadia environment architecture 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments acm november 

ed proceedings th international software process workshop uk may 
