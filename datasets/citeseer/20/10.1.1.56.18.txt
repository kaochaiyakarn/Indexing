agents simulating implementing petri nets tom holvoet pierre department computer science leuven celestijnenlaan leuven belgium mail tom holvoet cs kuleuven ac presents software architecture simulating implementing petri nets 
objectoriented techniques autonomous agents 
enables adaptation extension software architecture new alternatively defined features 
agents allow model net set autonomous cooperating entities 
result flexible extendible framework reusable components efficiently implementing large family petri net classes 
execution performed mono processor parallel distributed system 
result execution environments parallel applications 
petri nets commonly formalism modelling analysing complex concurrent systems 
simple powerful visual formalism describing concurrency synchronization causality nondeterminism system activities 
fact petri nets lean deriving useful properties place transition invariants petri net system specification starting point important development activities simulation implementation 
simulation petri net helps obtaining basic intuition behaviour modelled system enables experimental analysis empirical validation model 
implementing petri net means providing executable program behaves exactly modelled specification 
existing systems environments support petri net simulation implementation inflexible design decisions taken class petri nets transition rule transition scheduling policy system select transitions checking enabledness possibly fire case distributed implementation simulation policy balancing load set processors 
systems design decisions influence kind petri net provided application developers 
describe principles developing reusable flexible extendible software architecture efficient parallel distributed simulation implementation large family petri net classes partial prototype realisation 
approach research assistant belgian fund scientific research object orientation allows obtain software quality characteristics mentioned agents provide appropriate abstractions developing concurrent distributed applications 
note intention fancy tool large amount functionality analyzing petri nets 
purpose apply promising software development techniques implementing simulating petri nets seen example concurrent application 
general philosophy goals support large family petri net classes intention approach support class petri nets retains local control property nets transition depends vicinity transitions case timed stochastic petri nets 
pretend provide implementation classes petri nets claim implementation member family petri net classes requires highly reduced amount manpower 
efficient implementation simulation want provide software architecture allows efficient parallel distributed implementation large family petri nets 
possible properties particular classes nets order reduce execution time 
software quality flexibility reusability extendibility characteristics high quality software 
underestimated area petri net implementations show benefits software complies properties 
parallel distributed execution simulating large petri net known computationally expensive task 
order available system mono processor multi processor shared memory multi computer distributed memory full extend suitable implementation allow parallelism distribution flexible way 
suitable dynamic load balancing policy exhibits key role success distributed implementations 
objects agents approach adopt developing software architecture petri net implementation pillars agents object orientation 
developing system agents means modeling realizing system set autonomous active objects 
agents proactive decide actions perform act independently concurrently cooperate trough message passing 
passive objects hand autonomous active behaviour merely reactive respond messages sent initiate action autonomously 
agents modeling systems accepted step forward better modeling techniques 
agent model distribution parallelism implicit 
concrete reification agents object parallel distribution described orthogonally logical aspects agent model 
suitable environment provide concepts load balancing location independent object invocation 
excerpt software infrastructure backbone design software architecture implementation class petri nets consisting set possibly annotated places transitions edges tokens 
dynamic behaviour nets described generic enabling rule transition enabled fire 
particular class nets described specialization generic net 
implementation particular class petri nets modelled implemented specializations components generic net implementation particular inheritance 
step architecture set basic classes places class passive objects place 
instances class represent places petri net 
place objects mainly serve token containers queried manipulated behalf objects transition firing 
edges edge class represents edges petri net 
edges conceived relationship place object transition object 
edge objects constitute autonomous behaviour 
interface represents reactive behaviour offering particular functionality transition objects 
tokens tokens plain passive objects 
transitions class agents petri net implementation class transitions 
transition agents proactive repeatedly try fire transition represent 
overview refine model provide support implementation number known classes petri nets 
build inheritance hierarchy components 
places extend model set subclasses place class 
inheritance hierarchy see places result classes petri nets investigating functionality respective places 
subsequent subclass imposes additional restrictions places subclass correspond places particular classes petri nets 
mentioned objects class place represent places contain number kind token 
interface operations available objects object constructor 
specialisations place class class class 
models places labelled capacity indicates number tokens place contain 
type tokens remains unspecified 
specializes places way 
name indicates objects contain number tokens specific type 
type places represented attribute objects 
model places contain restricted number tokens specific type represented class 
multiple inheritance relation class inherits class class models places possess properties 
class condition inherits class imposing additional property place contain type token 
hierarchy deals properties places concerning tokens contain hierarchy focusing properties modelled 
mainly concern strategies order tokens retrieved places 
strategies fifo random policy priority token selection tokens assigned priorities 
modelled providing class models places imposed strategy token delivery 
descendants class classes 
place net particular petri net implementation ought follow particular strategy instance class inheriting token containment class appropriate class realizes order tokens 
consider place pr net fifo ordering imposed meaning multiple tokens unified arc variables order fulfill corresponding transition predicate token place longest time selected 
place instance class multiply inheriting classes place 
transitions behaviour transitions kind petri net rephrased terms transition objects 
accordingly modelled subclasses transition class 
allows provide efficient implementations firing protocol transition rule definition net allows 
edges edges model objects interconnect place transition vice versa 
task twofold demand transition object check agree transition enabledness case net transition input edge able check token associated input place shift tokens extract tokens transitions case input edge accept tokens transition shift output places 
interfaces edge objects mutatis mutandis convenient check agreement enabling corresponding transition 
inheritance hierarchy similar part place hierarchy respective class names 
tokens tokens objects 
type tokens represented attribute token objects 
special case anonymous tokens nets nets token objects attribute value set anonymous 
complicated types tokens coloured tokens instances subclasses tokens class defined designer cpn 
extendibility illustrations researchers proposed extensions standard petri net definitions reasons expressive power expressive comfort inhibitor arcs clearing arcs transitions shift tokens output places depending preconditions information arcs 
section want illustrate strength extendibility reusability architecture showing new petri net features easily included 
depicts class hierarchy architecture enhanced extensions mentioned section 
inhibitor arcs shown systems modelled petri nets introducing inhibitor arcs producer consumer systems priority mur 
inhibitor arc arc connects place transition effect net behaviour transition disabled place contains token 
incorporate inhibitor arcs architecture new classes defined 
base class inhibitor models basic notion inhibitor arcs 
class inherits inhibitor class class models inhibitor arcs similar ones mentioned 
transition queries object checks appropriate tokens available 
class represents inhibitor arcs prevent transition enabled corresponding place contains number tokens denoted arc label 
traditional kind inhibitor arc represented class agrees transition enabledness tokens available corresponding place 
including inhibitor arc petri net straightforward 
transition object need adaption implementation 
maintains list input arrows ordinary inhibitor arcs polymorphism transition rule remains queries arrows approval enabledness 
clearing arcs clearing arcs special kind input arcs withdraw tokens respective input places corresponding transition fires 
result classes representing objects withdraw tokens types mentioned label input place modelling arcs withdraw tokens input place 
similar inhibitor arcs clearing arcs included implementation simulation net changes 
transitions bas transitions proposed modelling actions way 
depending result transition firing tokens shifted subset output places 
provide new class inherits transition class adapts firing protocol token shifting output places conditioned predicate provided output arrow 
distributed execution environment executing agent systems parallel distributed computer system 
provides support ffl active objects agents ffl location independent object invocation physical distribution objects processors transparent objects 
ffl dynamic load balancing distributed load balancer tries enhance processor occupation migrate objects processors customizable policy 
ffl fault tolerance management ffl 
petri net implementation simulation architecture consists set communicating objects autonomously active 
environment manages execution object oriented applications manage petri net implementation simulation 
allows execute net distributed environment 
obtain execution meets efficiency expectations customize environment providing appropriate load balancer 
problem distributed allocation net components dealt ways 
clustering technique intends allocate sets potentially conflicting transitions conflict cluster wik places influencing enabling processor 
strategy uses semi flows clustering 
net related techniques prove usefulness 
environment allows detect clusters closely coupled objects objects high degree mutual invocations 
net implementation reveal clusters transitions places depend 
node place transition monotype condition row arrow row ce inhibitor transition traditional pt extended class diagram petri net framework software architecture implementing simulating petri nets 
underlying philosophy quite different existing systems approaches aim kind net mono processor parallel distributed systems 
architecture designed implemented object orientation agents appear perfect methodology developing extendible flexible complex concurrent systems 
real world entities fact autonomously active cooperating substances 
agents software abstractions entities 
context nets transitions really concurrent cooperating entities agents fit modelling transition activity 
allowing agents mobile bound physical processor distributed environment automatically entails distributed simulation implementation nets 
dynamic allocation described independently load balancer 
object orientation provides techniques mechanisms inheritance polymorphism dynamic binding prove essential software extendibility flexibility reusability 
architecture allows provide support kind net eases addition new net features alteration existing components 
open implementation design decisions firing protocol enabling rule nicely changed 
focus tools developing nets 
tools responsible checking consistency nets condition places transitions predicates 
support extensions adaptations architecture perform run time simulation analysis 
started working non trivial hv application provide hands expertise tools environment 
bas bastide 
objets un pour la des systems 
phd thesis universite paul sabatier de toulouse february 
hv holvoet 
pn tox paradigm development environment object concurrency specifications 
proceedings workshop object oriented programming models concurrency turin italy 
appear 
pierre 
object parallelism 
proceedings object oriented numerics conference april 
mur murata 
petri nets properties analysis applications 
proceedings ieee volume pages 
de pauw vlissides 
modeling object oriented program execution 
proceedings european conference object oriented programming pages 
wik 
object nets canonical class models behaviour simulation structure synthesis distributed systems proceedings intl seminar modelling evaluation optimization dependable computer systems pages 
