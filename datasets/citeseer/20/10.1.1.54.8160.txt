truly concurrent view linda interprocess communication busi gorrieri zavattaro technical report ublcs february department computer science university bologna zamboni bologna italy university bologna department computer science research technical reports available postscript format anonymous ftp area ftp cs unibo pub tr ublcs www url www cs unibo 
plain text abstracts organized year available directory abstracts 
local authors reached mail address name cs unibo 
questions comments addressed tr admin cs unibo 
titles ublcs technical report series building hypermedia learning framework design user interface february 
bologna optimal higher order machine asperti march 
synchronization support group membership services reliable distributed multimedia applications march revised july 
inherent cost strong partial view synchronous communication babao glu 
april 
complexity beta reduction asperti july 
optimal multi block read schedules partitioned signature files ciaccia august 
integrating performance functional analysis concurrent systems empa bernardo gorrieri september revised march 
programming view synchrony babao glu bartoli dini september 
generative communication process algebra ciancarini gorrieri zavattaro october 
dynamic declustering methods parallel grid files ciaccia november 
group membership view synchrony partitionable asynchronous distributed systems specifications babao glu montresor november revised september 
investigation optimal implementation processes laneve january 
chaos cellular automata january 
enriched view synchrony paradigm programming dependable applications partitionable asynchronous distributed systems babao glu bartoli dini february revised november 
may testing join calculus laneve march 
shape shade coordination system castellani ciancarini rossi march 
engineering formal requirements analysis testing method documents ciancarini mascolo march 
bayesian belief networks automated assessment students knowledge geometry problem solving procedures march 
virtual interactions investigation dynamics sharing graphs asperti laneve april 
algebra actors april 
mobile petri nets asperti busi may 
communication support critical distributed multimedia applications experimental study may 
logic coordination language chemical metaphor ciancarini july 
parallelization concurrent systems corradini gorrieri august revised december 
compositional security checker tool verification information flow security properties focardi gorrieri august 
jada coordination toolkit java ciancarini rossi october 
fault tolerance view synchrony partitionable asynchronous distributed systems montresor december 
tutorial empa theory concurrent processes nondeterminism priorities probabilities time bernardo gorrieri december 
partitionable group membership specification algorithms babao glu montresor january 
truly concurrent view linda interprocess communication busi gorrieri zavattaro technical report ublcs february linda coordination language provides communication means primitives allowing insertion reading withdrawal elements shared data space 
communication mechanism referred generative communication concurrent languages shared prolog lo gamma 
introduce process calculus embeds linda coordination primitives inp operation considered papers semantics linda 
introduce truly concurrent semantics linda providing calculus net semantics contextual nets 
kind nets allows model high level true concurrency embed notion reading consuming read operation linda 
example approach parallel read simultaneous reading message modeled 
asynchronous communication realized means insertion reading withdrawal elements shared multiset peculiar feature family coordination languages gc 
representative language family coordination language linda gel 
linda provides interprocess communication medium called tuple space ts short shared memory contains set messages produced set processes 
ts accessible parallel process means coordination primitives message produces message read message reads message consuming message reads consumes message predicates message looks message ts message boolean value true returned false inp message looks message ts message removed boolean value true returned false 
peculiar features linda interprocess communication listed follows ffl process insert message ts performing operation 
ffl process perform read operation required message ts blocks 
side effect execution operation withdrawal read message 
ffl process evaluate inp predicate returns boolean value predicate forms read respectively sense look specified message ts way read message return boolean value false blocking 
message behaviour read value true returned 
ffl insertion order messages ts influence reading order 
ffl multiple occurrences message ts time ts multiset messages 
communication mechanism said generative message generated process independent existence ts explicitly withdrawn 
fact insertion ts message equally accessible processes bound 
frameworks reason formally generative communication introduced cjy dp takes account inp operations 
aim analyze operations idea adapt process algebra introduced order deal new features 
generative communication embedded process algebra introducing additions ccs mil ffl autonomous agent hai introduced represent sent message ffl prefix denotes sent 
execution consists addition agent hai environment gamma 
label step representing operation local autonomous step computation depend environment 
ffl extra prefix introduced represent request reading message consuming 
ffl agent hai consumed agent performs operation hai gamma 
read agent performs read operation hai gamma 
hai labels represents complementary actions respectively 
order deal predicates introduce new constructor consists sort 
fact denote process requires ublcs 
communicating processes 

processes performing inp self loops labeled omitted 
message remove simply read respectively 
message agent behaves behaviour agent described items ffl agent reads required message performing action gamma 
ffl required message agent performing action signals absence message environment gamma 
ffl agent performs operation composed parallel agents contain message agents able perform action gamma 
gamma jq gamma 
jq ffl agent performs operation restricted message operation local step computation labeled search finished 
fact necessary test absence message local message name gamma 
gamma 
compares different cases generative graph reader performs operation considered second graph describes case read operation 
important difference cases due behavior synchronization simultaneous execution complementary actions ublcs language semantics null agent hai message agent prefix operator non blocking input operator choice operator jq parallel operator restriction operator agent variable rec recursion operator table 
syntax 

fact reader performs operation message withdrawn executes read agent hai removed 
shows behaviors agents 
interesting see agent able perform action presence message environment agent hai removed executing action performed 
read operations difference agents due behaviour synchronization case inp predicate message removed kept 
introduce truly concurrent semantics generative communication providing calculus net semantics contextual nets bp 
kind nets allows model high level true concurrency embed notion reading consuming read operation 
example framework introduce parallel read simultaneous reading message allowed 
language semantics ffl message ranged denumerable set messages ffl fa ranged set prefixes ffl label fa ranged ff fi set labels ffl delta label gamma 
label partial function ffl label gamma 
message total function ffl ranged set agent variables 
agent expressions ranged defined table 
null agent class terms hai represent possible elementary agents 
term deadlocked agent able perform kind action hai represents message inserted ts ready read withdrawn 
prefix operator define agent perform action going 
actions depending kind prefixes corresponding read operation local autonomous steps computation respectively 
non blocking input operator represent behavior evaluation inp predicates 
fact agent requires ublcs language semantics hai gamma 
read hai gamma 
hai pref gamma 
gamma 
gamma 
gamma 
choice ff gamma 
ff gamma 
par ff gamma 
jq ff gamma 
jq ff gamma 
gamma jq gamma 
jq synch ff gamma 
ff gamma 
jq gamma 
jq restriction ff gamma 
ff gamma 
ff gamma 
gamma 
recursion rec ff gamma 
rec ff gamma 
table 
operational semantics symmetric rules omitted 
message withdrawn read respectively message behaves meaning operators usual 
choice operator represent non deterministic alternative choice combined agents 
parallel operator combine agents able perform actions parallel synchronize complementary actions 
restriction operator define local actions 
recursion operator definition recursive agents 
say bound occurrence subexpression rec guarded occurrence subexpression say closed guarded bound guarded variables occur 
agent set closed guarded terms 
closed guarded terms considered range agent 
operational semantics language described labeled transition system agent label gamma 
labeled relation gamma agent theta label theta agent smallest satisfies axioms rules table symmetric rules 
choice par omitted sake simplicity 
rules format gv ublcs truly concurrent semantics canonical system transition relations agreeing rules exists strong bisimulation bisimulation congruence operators 
definition binary symmetric relation agent bisimulation ff gamma 
imply exists ff gamma 
agents bisimilar written exists bisimulation truly concurrent semantics section introduce truly concurrent semantics generative communication providing calculus net semantics contextual nets bp 
kind nets allows show intended parallelism embed notion reading consuming read operation 
example framework introduce parallel read simultaneous reading message allowed 
basic idea underlying definition operational net semantics process algebra ddm decompose process multiset sequential components thought running parallel 
sequential corresponding place net represented token place 
actions represented labeled transitions consume produce multisets sequential components contextual conditions satisfied 
extend approach language representing tuples tokens corresponding places net way faithfully model read operation tuple transition contextual arc tests presence token corresponding place 
representation inp predicates inhibitor arcs test tuple place absence tokens transitions representing selection branch 
nets concrete distributed model offer discriminating observability criterions 
study called step semantics permits observe potential parallelism system describe causal bisimulation gives complete account dependencies transitions net 
think concrete semantics useful define descriptions systems closer implementations offer better understanding system 
subsection report definition contextual nets step causal semantics 
subsection formally define net semantics language proof sos semantics sequential execution net provided 
examples illustrating contextual arcs reported 
contextual nets recall simple place transition nets capacity constraints places see gol 
extend contextual arcs see bp ris 
provide characterization model convenient aims 
definition set finite multiset function 
set dom fs finite 
multiplicity element natural number 
set finite multisets denoted fin ranged multiset dom called empty set finite sets denoted fin 
finite subset abuse notation denote multiset ma defined follows ma 
write operator phi denotes multiset union phi 
operator denotes multiset difference gamma 
scalar product delta number delta delta 
ublcs truly concurrent semantics function function extended multisets way fin 
definition net tuple act set places act set labels fin theta act theta fin set transitions 
finite multiset set places called marking 
marking place say place contains tokens 
transition usually written form gamma 
marking usually denoted ffl called preset represents tokens consumed marking usually denoted ffl called postset represents tokens produced called label denoted 
transition enabled ffl execution transition enabled produces marking ffl phi ffl written tim marked net tuple act act net nonempty finite multiset called initial marking 
definition contextual net cn net short tuple act set places act set labels fin theta fin theta fin theta act theta fin set transitions 
transition usually written form gamma 
set denoted called contextual set represented tokens tested presence set denoted ffi called inhibitor set represents tokens tested absence markings 
changes definition enabling transition enabled ffl phi dom ffi 
transition ffi dom ffl called blocked unblocked 
execution transition enabled producing marking written tim defined 
definition act contextual net 
interleaving marking graph fin act fin theta act theta fin defined gamma 
iff exists transition tim denote interleaving marking graph reachable initial marking img labeled transition system bisimulation equivalence defined markings denote bisimilar 
step semantics finite non empty multiset set called step 
transitions happen step happen order 
check tokens place tested presence occurrence transition consumed occurrence transition produce tokens place tested absence 
step enabled iff ffl phi delta ffl dom ffl dom ffi dom ffl dom dom ffl ffi execution step enabled produces marking phi delta ffl written gim step marking graph smg fin fin act fin theta fin act thetam fin defined gamma 
iff exists step gim 
smg labeled transition system define notion step bisimulation ublcs truly concurrent semantics equivalence markings 
causal semantics bp causal semantics contextual nets proposed causal trees dd 
current state net represented marking events occur net execution occurrences transitions 
standard immediate causes event consist set events produced tokens consumes record information enrich current state decorating token history event produced distinguish different occurrences transition record number occurrences transition happened 
transition fire need check token positive contextual place inhibiting place empty contain token 
standard causes decorations tokens consumes event types causes positive contextual ones contextual place decoration tokens contains inhibiting ones set events removed tokens inhibiting places 
information inhibiting causes obtained decorating place set events consumed tokens 
enriched state containing information history tokens number transitions occurrences happened set events consumed tokens place called configuration 
initial configuration net obtained setting zero numbers occurrences transition decorating tokens initial marking special symbol meaning produced event 
event occurs looking histories tokens consumes tests presence set events associated inhibiting places obtain information immediate causal dependencies 
obviously consumption tokens decorated add causal dependencies 
immediate causal execution event transition configuration labeled event set immediate causal dependencies 
causal tree tree labeled pairs composed action set relative pointers predecessors caused action 
set immediate causal firing sequences net easily construct causal tree representing causal execution net perform transitive closure immediate causal relation events events replacing event label transition occurrence set events representing causes relative pointers 
causal bisimulation nets reduced bisimulation corresponding causal trees 
formal definition causal semantics contextual nets reported appendix net semantics need introduce new set symbols conflict names model choice operator agent form interpreted parallel composition kp kq called conflict name contrasting conflict name 
alternative agents considered parallel agents decorated contrasting conflict names 
net semantics contains place conflict name holding token inhibits transitions starting places agents decorated symmetrically assumption 
formally denumerable set symbols disjoint message cg con set conflict names 
con ranged assumption conflict set finite subset con ranged ig 
singleton drop set brackets notational convenience 
model restriction operator partition set message sets visible messages denoted message invisible ones 
visible messages occur label observable transition invisible ones 
assume agent initially uses names message 
denotation agent pna obtained denotation renaming free occurrences scope inner ublcs truly concurrent semantics dec dec hai dec pg dec qg dec dec phi dec new dec jq dec phi dec dec pna dec fb ag new dec rec dec xg table 
decomposition function restriction na invisible name action name invisible performed synchronization 
ddm forget structure parallel composition agents need fresh invisible names rename restriction binders 
set places defined follows fi con fi con con hai message agent represent sequential processes conflict set conflict set associated sequential process omitted empty 
conflict name place name 
prevent execution transition sequential process better describe implementation distributed choice assume sequential processes interpreted parallel composition execution action produce token place preventing execution action 
order define decomposition function dec associates finite multiset process need auxiliary definitions 
operator defined places follows hai hai substitution message invisible message defined agents usual way restriction operator acting binder 
pna fb ag pna pnc fb ag ag nc note restricted names visible ones need alpha conversion avoid name clashes 
substitution defined places follows hci fb ag agi fb ag fb ag fb ag fb ag fb ag set conflicts place defined fk ig ae fkg kg hai extended markings dom ublcs truly concurrent semantics gamma 
message gamma 
message fi pg gamma 
dec phi message fia gamma 
phi dec phi fi qg gamma 
dec phi message fi qg gamma 
dec phi message fi qg gamma 
dec phi fia gamma 
dec phi fia gamma 
dec phi fia pg gamma 
dec phi fia qg gamma 
dec phi table 
axiom schemata transitions set message names place defined hai fag extended markings dom set invisible message names marking defined follows sake simplicity write functions multiple arguments meaning union applications argument 
means 
function dec agent fin defines decomposition agents markings reported table 
agent generates tokens 
decomposition hai produces token place hai 
decomposition sequential processes produces token corresponding place empty set conflicts 
alternative composition agent turned multiset union markings place dec decorated singleton fkg symmetrically place dec decorated kg 
parallel composition interpreted multiset union 
decomposition restricted agent pna multiset obtained decomposition new name substituted bound name recursive process unwound decomposed 
note function dec defined renaming conflicts invisible names actual choice new conflict new invisible name inessential 
ublcs truly concurrent semantics net language triple label set net transitions set generated axiom schemata reported table 
axioms deal observable actions performed message agent perform output action consume token place message agent non consuming output test place presence 
axiom non output prefixes token places contrasting conflict names transition produces tokens dec token place conflicts way sequential process decorated conflict blocked forever 
axiom deals output prefix invisible action performed token message agent corresponding prefix name produced 
note axiom applied independently status visible invisible prefix name 
axiom observable action performed non blocking operation definition similar axiom 
axioms asked non blocking operation tested absence test successful branch operation selected 
note transition labeled observable action contains visible name 
axioms describe withdrawal message sequential process token place corresponding required message agent sequential process consumes evolves 
axioms deal reading message 
note conflict set necessary tuples condition occurrence tuples inside operands choice imposed processes 
fact proposition holds processes proposition process 
hai dom dec phi dec 
tuple hai occurs decomposition name invisible means tuple occurs inside subterm form rna 
transitions tuple tested consumed generated axioms axioms consume sequential agent means agent produced decomposition subterm lies inside restriction tuple implies sequential agent conflict agents conflict tuple conflict set sequential agent sufficient disable elements conflict tuple 
process net associated subnet reachable initial marking dec 
theorems compare interleaving semantics agent interleaving marking graph net marked initial marking dec 
final corollary states net translation fully interleaving bisimulation equivalence 
sketch proof appendix theorem process 
ff gamma 
exists marking dec ff gamma 
dec 
theorem process 
dec ff gamma 
exists process ff gamma 
dec 
corollary processes 
dec dec 
ublcs examples ka kb dec dec 
net semantics agent dec dec dec 
net semantics agent 
examples section analyze examples advantages contextual nets standard nets inhibitors contextual arcs 
inhibitor contextual arcs graphically distinguished standard arcs denoted lines arrows denoted lines small circle simple lines circle arrow respectively 
inhibitor arcs inhibitor arcs net semantics order represent behavior alternative choice operator testing absence certain message ts evaluation inp predicates 
net semantics agent shows inhibitor arcs ensure actions fired 
fact transitions enabled happen step 
fired token inserted conflict place disallows 
shows net agent 
possible transitions place labeled involved consists local execution action places involved fired message tokens place labeled hai representing reading message agent net semantics similar transition remove tokens place labeled hai place hai transition contextual arc standard 
ublcs examples dec dec dec dec dec dec 
net interpretations concurrent reading operations 
contextual arcs contextual arcs embed notion reading consuming read operator predicate 
kind arcs possible capture high level true concurrency 
interesting example due case parallel read simultaneous execution read operations message 
papers semantics linda kind potential parallelism taken account 
shows net semantics concurrent reading operations executed message particular consider agent ja na 
net obtained approach contextual arcs allow firing transitions representing execution reading operations step 
second net semantics linda cjy transitions allowed executed simultaneously 
fact execution read prefix message consists consumption insertion token place labeled hai considered 
third net obtained applying standard net semantics ccs ddm approach representation read operation dp 
read operation obtained operations sense agent behaviour standard net semantics similar proposed cjy consumption token place labeled hai new insertion transition labeled fired 
ublcs bp busi 
causal semantics contextual nets 
proc 
world scientific 
ciancarini gorrieri zavattaro 
calculus generative communication 
proc 
chapman hall 
cjy ciancarini jensen 
operational semantics coordination language 
object models languages concurrent systems lncs springer verlag 
dd ph 
darondeau degano 
causal trees 
proc 
icalp lncs springer verlag 
ddm degano de nicola montanari 
distributed operational semantics ccs systems 
acta informatica 
dp de nicola pugliese 
process algebra linda 
proc 
coordination lncs springer verlag 
gc gelernter carriero 
coordination languages significance 
communications acm 
gel gelernter 
generative communication linda 
acm transactions programming languages systems 
gol goltz 
ccs petri nets 
lncs springer verlag 
gv groote vaandrager 
structured operational semantics bisimulation congruence 
information computation 
mil milner 
communication concurrency 
prentice hall 
montanari rossi 
contextual nets 
acta informatica 
ris 
modelling systems shared resources petri nets 
ph thesis university pisa td 
causal semantics contextual nets marked contextual net show generate causal tree dd 
construction proceeds defining types tokens essentially decoration token records information way generated occurrence transition produced 
place contain simply set tokens multiset token types individual token remembers origin 
introduce notion configuration marked net essentially defines pieces information 
marking net tokens decorated type history 
second function associates place set transitions consumed tokens place useful consider transition consumes token inhibitor set transition causes third piece information counter occurrences transitions 
definition act marked contextual net 
set token types theta theta fg ranged type tokens produced th occurrence transition type tokens initial marking 
configuration fl net triple ffl theta 
describes place number tokens type contains 
ffl 
theta describes place set occurrences transitions consumed tokens place 
ffl 
defines number occurrences transition 
initial configuration net fl ae ublcs causal semantics contextual nets fl fl denote firing transition configuration fl configuration fl th time transition fired 
set records immediate causes firing occurrence elements occurrences transitions 
definition rule causal firing rule follows 
ffl ffl ffl ae ffl phi ffl ffi ffl gamma ffl ffi ffl phi ae ffl ffl ae ffl ffl ffl ae causal firing sequence cfs defined inductively follows ffl fl cfs ffl fl ifl gamma cn gamma ifl gamma cfs fl gamma cn ifl fl ifl gamma cn gamma ifl gamma cn ifl cfs 
set causal firing sequences net denoted cfs 
causal dependencies produce relation events transitive closure partial order 
definition fl ifl cn ifl causal firing sequence 
define relation oe oe iff proposition oe strict partial order 
causal trees dd trees labeled pairs action set relative pointers predecessors caused action associate causal tree set causal firing sequences cfs 
definition causal tree act tree ffl set nodes ffl theta set arcs ffl act theta fin 
labeling function 
definition causal tree net tree ct defined follows ffl cfs ffl oe oe oe oe cfs ffl oe fl ifl gamma cn gamma ifl gamma oe oe cn ifl fn gammai oe 
ublcs oe gamma 
oe mean exists arc labeled nodes oe oe definition marked nets binary relation cfs theta cfs causal bisimulation ffl fl fl fl initial configuration ffl oe oe oe gamma 
oe exists oe oe gamma 
oe oe oe ffl oe oe oe gamma 
oe exists oe oe gamma 
oe oe oe nets causal bisimilar iff exists causal bisimulation 
sketch proof interleaving semantics agent interleaving marking graph net marked initial marking dec 
recall measure processes proof induction theorem definition complexity process defined way complexity complexity hai complexity complexity complexity complexity jq complexity complexity complexity pna complexity rec complexity note process closed guarded term definition complexity useless 
observations propositions preparatory proof main result 
theorems compare transition system interleaving marking graph 
final corollary states net translation fully interleaving bisimulation equivalence 
proposition marking hold ffl ff gamma 
ff ff message 
ffl hai dom message iff gamma 
proposition process 
gamma 
iff hai dom dec message 
proposition markings 
hai dom phi fkg phi km phi km phi proof relation phi delta fkg phi km phi km phi bisimulation markings 
proposition markings 
phi phi proof relation phi phi markings bisimulation markings 
proposition process fresh name 
dec ag dec fb ag renaming fresh conflicts invisible names introduced decomposition 
ublcs proposition markings fresh name 
mfb ag fb ag 
theorem process 
ff gamma 
exists marking dec ff gamma 
dec 
proof induction proof transition ff gamma 
show proof cases give idea complete proof ffl transition instance axiom hai gamma 
hai ff 
dec hai names occurring agents visible message axiom net transitions obtain dec dec hai gamma 
dec dec 
ffl rule proof ff gamma 
qjr ff gamma 
jr ff qjr jr ff gamma 
inductive hypothesis obtain dec ff gamma 
dec 
side condition ff transition generated axiom net transitions 
proof proceeds case analysis remaining axioms 
analyse case axiom 
transition dec ff gamma 
dec obtained axiom dec contains sequential process dec fi phi set inhibitor arcs transition follows 
side condition axiom ensures message dec phi phi dec dec qjr dec phi dec fi phi phi dec 
fresh conflict name time decomposition choice composition processes performed ensures dom dec 
apply axiom marking dec obtaining dec fi phi phi dec gamma 
dec phi phi phi dec phi dec 
dec phi phi dec 
fresh conflict names holds fresh invisible names apply proposition markings dec dec dec obtain phi dec dec phi dec dec jr dec 
theorem process 
dec ff gamma 
exists process ff gamma 
dec 
proof induction complexity show proof cases 
ffl dec qg 
transition instance axiom ff dec 
transition gamma 
instance axiom sos interleaving semantics side condition satisfied 
transition instance axiom ff phi dec 
transition gamma 
instance axiom sos interleaving semantics dec dec hai phi dec phi dec ffl rec dec rec dec xg 
set agents consists closed guarded terms complexity xg strictly complexity rec inductive hypothesis exists xg ff gamma 
dec applying rule recursion sos interleaving semantics obtain rec ff gamma 
corollary processes 
dec dec 
ublcs 
