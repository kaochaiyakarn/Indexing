interpretation objects object types mart abadi digital systems research center ma pa dec com luca cardelli digital systems research center luca pa dec com ramesh viswanathan isaac newton institute mathematical sciences viswanathan newton cam ac uk interpretation typed object oriented concepts terms understood purely procedural concepts 
precisely give compositional translation basic object calculus supporting method invocation functional method update subtyping polymorphic calculus recursive types subtyping 
translation techniques apply imperative version object calculus includes inplace method update object cloning 
translation easily extends self types interesting object oriented constructs 
object oriented programming languages introduced numerous ideas structures techniques 
contributions conceptually clear sound original useful 
basic contributions notion self operations associated object methods refer object self invoke operations self dynamic dispatch 
related contribution notion subsumption object replaced subsumed object supports operations typed languages subsumption rules subclassing subtyping 
object oriented programming limited objectoriented languages 
emulate objects procedural languages scheme possible despite originality object oriented programming reduced procedural programming 
reduction straightforward 
interesting difficulties arise level types natural definition objects records functions self application semantics kam validate expected subsumption blocked 
address digital systems research center lytton avenue palo alto california supported nsf ccr rosenbaum fellowship 
address isaac newton institute mathematical sciences clarkson road cambridge cb eh appear proceedings rd annual acm sigplan sigact symposium principles programming languages january st petersburg beach florida 
develop interpretation objectoriented programming terms procedural programming specifically terms fairly standard calculus subtyping 
show translation objects records functions translation object types types built record types existential types recursive types 
ingredients surprising combination new 
translation faithful respects operational semantics typing rules subtyping rules yields syntactic proof soundness rules 
order interpretation manageable precise develop context object calculi ac 
object calculi formalisms analogous calculi objects functions 
primitives objects method invocation method update imperative calculi cloning 
method update unusual forms method update appear languages lie tai app car 
primitives quite expressive allow representations classbased object notions example classes subclasses protection prototyping mode switching 
typed object calculi include subtyping relation subsumption rule 
believe interpretation objects compelling reasons 
ffl precise vague intuition objects data types recursive types 
intuition important previous works studied calculi subtyping emulate objects various extents see section 
target calculus translation result previous works 
ffl translation sufficiently complicated confirm objects provide useful abstraction independent procedural concepts 
hand simple serve explanation objects terms understood constructs 
ffl translation limited particular object calculus 
modifications applies functional imperative execution models adapted account self types structural rules ac operationally sound unsound common denotational models 
section review background describing related works give informal overview interpretation 
section defines version translation precisely section gives imperative translation section deals additional type constructs 
informal review overview review basic untyped object calculus ac notation follows 
calculus object xn bn collection methods xn bn respective names method bodies bn variables xn denote self 
order methods matter 
operations objects method invocation method update 
object xn bn invocation method written consists replacing method update yields object take update construct functional create new object 
fields instance variables easily expressible methods self parameters 
untyped calculus basis order calculus subtyping called ob ob object type bn type objects methods invoked result values types bn respectively 
characteristic object oriented languages object methods object fewer methods expected 
ob supported subtyping relation 
object type methods subtype object type fewer methods provided common methods exactly result types example types self application semantics kam provides satisfactory explanation untyped objects records functions 
write fl ang record fields values delta extracting field record delta updating field record self application semantics method function self parameter object record functions method invocation field selection plus method update record update fl delta delta interpretation respects operational behavior method invocation method update 
unfortunately self application semantics extend typed systems ob particular validate essential object types 
self application semantics naturally interpret object type recursive record type solution type equation fl fl denotes evident record type 
contravariant occurrences object type obtain valid ob 
part difficulty interpretations objects 
defined ways emulating objects procedural settings precise translations somewhat hard give full account scope 
short contributed interesting useful techniques suffer limitations 
recursive record semantics car validates expected model method update field update generator semantics coo deals update cost separating objects object generators 
existential interpretation pt hp validates expected models class constructs methods fields rigidly separated fields updated unfortunately translation objects type directed elaborate 
imperative interpretation solve problems semantics judicious side effects main limitation model cloning construct object imperative languages 
interpretations give subtyping altogether reduce coercion functions ac em coercion functions cumbersome destroy flavor original programs preclude explanation object subtyping terms primitive subtyping relations 
point possible easy understand computational behavior objects desired typing subtyping properties fundamentally different records functions 
view originally led formulation object calculi 
interpretation objects discuss sheds new light matter 
provide complete account objects terms records functions 
applies class object constructs places restrictions method update validates expected 
hand straightforward remove usefulness object calculi setting studying object oriented concepts 
develop translations object calculi calculi 
translations faithful respect operational semantics typing rules subtyping rules object calculi 
translation maps ob polymorphic calculus subtyping recursive types preview translation explaining informally treats types 
consider type bn 
subsumption object containing additional methods element think true type type listing methods type partially reveals true type publicly visible methods take translation object type type abstraction representation type true type object 
notation type abstraction interface unknown representation type subtype define recursive type equation fl sel upd self xg subtyping assumption representation type expresses true type known subtype table operational semantics ob ob fx eval select fag eval update ng eval beta eval beta bfa eval record select fl delta eval unfold unfold fold eval unpack open dfx xg pack fxg object type 
field sel method treated function self 
field upd provides ability update method new method function self returns new object 
field self object methods including private ones self methods access methods listed interface 
ingredients translation necessary 
particular existential types addition recursive types essential getting desired 
similarly essential model method update field upd method update modeled update field sel leave field self unaffected operational semantics distorted 
section detail translation ob section consider imperative version translation deals correctly cloning ways simpler functional side effects 
section show translation ob extended account richer object type constructs self types variance annotations 
interpretation object calculus functional update section describe translation object calculus ob functional calculus sections briefly describe calculi ob section detail translation ob precise typing rules calculi appendices object calculus ob types ob generated grammar top 
type top supertype types type objects methods returning results type terms calculus similar untyped calculus described section bound variables type annotations subset terms generated grammar identified typed terms set typing rules described appendix rules derive judgements form assertion environment describing assumptions free variables assertion pi means formed environment means formed type means subtype means formed term type important rule sub object states subtype method names result types methods exactly object types invariant component types 
operational semantics defined reduction system free side effects 
primitive redexes table correspond method invocation method update write distinguish variable may occur free result replacing clear context 
step reduction relation gamma 
congruence closure reduce subterm redex step reduction relation gamma 
reflexive transitive closure gamma 
define results terms form say closed term converges write exists result gamma 
ov 
functional calculus system standard extension system recursive types subtyping 
records existentially quantified types encodable terms constructs primitive simplicity 
system defined detail appendix section describe informally constructs 
records collections fields associated values operation records field extraction written delta 
basic types function types record types 
record type fl lists field names types values associated 
record types covariant component types 
recursive type denote solution type equation occur free isomorphism unfolding bf constructs fold unfold type unfold unfolded type unfolded type fold type 
existentially quantified type type term roughly exists type subtype term type 
formally term type term pack type 
achieve packing term type hiding information type realizes 
recall data abstractions existential types mp 
term type access inside writing term open stands representation type inside 
typing rules ensure assume information subtype type specified depend representation type occur free table specifies reduction step reduction relation gamma 
congruence closure gamma 
reflexive transitive closure gamma 
ob distinguish certain terms results set results defined appendix includes abstractions records 
say closed term converges write exists result gamma 
recursive types easily define call byname fixed point operator 
routine define letrec write letrec delta delta delta xn denote recursive definition function type 
delta delta delta term translation ready describe translation ob translation parts 
part translation types maps type ob type defined induction structure types ob top top fl sel upd self xg interpretation object types section equation equation defining existential type recursively 
note translation object type field sel type covariant field upd contravariant interpretation explains invariance object types component types arising covariance due invocation contravariance due update 
key consequence translation object types gives expected 
formally translation types define mapping environments establish theorem states formed types ob get mapped formed types subtyping judgements ob preserved translation 
oe oe theorem 
pi derivable ob pi derivable 
derivable ob derivable 
derivable ob derivable second part translation terms 
main ideas translation terms transparent informally explain results translation untyped terms omitting type annotations associated recursive existential types details precise 
informally term ob mapped meaning hhaii term 
apart typing restrictions imposed recursive existential types translation object type record type fields sel upd method field self field sel method treated function self field upd returns new object applied new method treated function self 
understanding translations method invocation update straightforward 
hha ii hhaii delta sel hhaii delta self hha bii hhaii delta upd delicate part translation terms objects 
may expected computationally interesting far just delegated responsibility fields sel upd provided interface objects 
understand translation objects instructive consider incorrect attempt explain presence field upd suppose chose field upd record interface objects modeled method update update field sel object bii delta sel wrong invoking method interpreted extracting sel field applying field self object record field sel equal method treated function self parameter method invocation modeled application field self field self object 
arrive recursive definition fl sel ii self wrong problem functional interpretation objects method gets updated object changes update field record change reflected field self consequently lose dynamic binding self 
method uses body invocation modeled application table translation ob hh ii letrec create fn fold pack fl sel upd create gamma fn self create fn create ii xn ii xn hha lii open unfold ll fl sel self xg delta sel delta self ai hha open unfold delta upd field self see result update 
important idea context translation method update modeled record update 
second idea glean flawed attempt defining object recursively reflect computational behavior objects accurately 
intuitively update chance working recursion freezes self state object time creation recursion soon 
familiar recursive record interpretation car may note source problems modeling method update traced early recursion 
solution define object recursively dependence object methods recursively 
define function create applied methods returns object methods definition create recursive 
object defined application create methods follows letrec create delta delta delta fn fl sel upd create delta delta delta gamma delta delta delta fn self create delta delta delta fn create ii xn define translation terms typing annotations precisely 
notation 
notation 
object type define type free variable fl sel upd self xg 
method name ob type define type ll ll fl sel self xg 
suppose term environment provable ob minimum types property ob ac invariance object types ai unique type provable exists undefined 
term ob environment table defines term translation proceeds induction structure particular translation judgement depend derivation ob consequently avoid coherence issues proofs 
inclusion environment defining meaning term arises purely technical reasons 
give necessary type annotations translation method invocation 
omitted type annotations target calculus put type information syntax term method invocation defined meaning term dependence environment 
remarks regarding translation terms order 
translation method invocation explains presence field self translation object types delta self lead typable result 
translation method update motivated reduction rule eval update asserts type annotation updated object 
acceptable point view typing fit rule eval update 
theorem states translation preserves typing judgements computational behavior terms 
theorem 
derivable ob derivable 
derivable ob gamma 
gamma 
translation serve basis validating reasoning principles objects reasoning principles functions 
particular prove objects equivalent showing translations equivalent 
able check non trivial object equivalences manner 
proof method complete translation fully sound translation computationally adequate show 
closed ob terms type say operationally equivalent type write jo context delta typed assuming hole delta type define relation operational equivalence similarly write jf part theorem states translation computationally adequate second part corollary states ob terms operationally equivalent translations operationally equivalent 
theorem assume derivable ob 
hhaii 
hhaii jf jo summary key ideas translation 
interpreting object type recursive type abstraction gives desired 
second model method invocation application object field self holds current value object 
splitting method field invocation field update recursion function creates objects obtain dynamic binding 
interpretation imperative object calculus section show ideas embodied translation described section useful interpretation imperative object oriented constructs 
formal setting imperative object calculus ac 
imperative object calculus terms untyped imperative object calculus generated grammar clone previous calculus imperative calculus terms corresponding objects method invocation method update 
operational semantics imperative method names denote locations closures corresponding methods stored method update done place 
method update side effect changing object returning new object 
addition new primitives clone returns shallow copy object object method suite stored fresh memory locations construct evaluates term binds variable evaluates second term variable scope 
sequential evaluation eagerly evaluated fields defined 
type system appendix extension ob translation translate imperative object calculus imperative version describe informally 
syntax imperative version extends field update records written delta uninitialized value type written nil 
presence field update record types invariant components 
operational semantics imperative version significantly different respects field names records denote memory locations field update done place 
accurate think record collection memory locations collection values 
presence side effects needs fix evaluation order assume call value evaluation target calculus 
defined defined free main departure translation described section imperative setting split method distinct fields corresponding method invocation method update 
recall essential reason split functional case field self detect change method method update modeled record update field corresponding method 
presence imperative features target calculus field self store pointer record meaning object ensuring changes fields record reflected self translation types uses ideas described section 
addition include cloning function public interface object 
types top top fl clone fg self xg distinction fields self clone contains pointer record returns shallow copy record dummy abstraction need distinguish method invocation apply method object shallow copy object 
recursive type abstraction yields desired 
table translation imperative object calculus sketch hh ii letrec create fn fl clone nil self delta clone create delta delta delta delta delta delta self delta self create ii xn ii hha ii hhaii delta delta self hha bii hhaii delta ii hhaii delta clone fg bii hhaii give precise definition translation terms 
refer table states translation omitting type annotations terms 
translation object declare skeletal record structure fields clone self uninitialized update fields point circularly record structure 
note retained idea defining create function recursively object recursively 
necessary cloning return correct copy object updates defined object recursively clone frozen return shallow copy state object time creation 
cf 
semantics accommodate cloning 
translation field clone defined abstraction application create terminates call value evaluation 
method invocation interpreted way functional case method update interpreted record update 
cloning interpreted application field clone dummy argument empty record 
precise definition translation terms table relies notation notation 
define imp fxg fl clone fg self xg 
method name type imp fl self xg 
type ai minimum type environment type provable undefined typable type ai section 
prove soundness theorem translation 
omit statement requires lengthy definitions detailing relating operational semantics imperative calculi 
extensions richer object types section consider richer typing disciplines objects variance annotations self types structural rules described ac show translation extends account 
section giving overview typing disciplines informal description interpretation 
section describe enriched object calculus precisely 
section give translation object calculus 
preview variance annotations variance annotations extension object types symbols gamma attached method names object types 
annotation indicates method invocable gamma indicates updatable indicates 
annotations allow finer protection access methods give desirable subtyping properties 
object types covariant types components contravariant types gamma components invariant types components 
variance annotations naturally fit framework interpretation 
translate object types recursive type abstractions record components sel upd method sel component upd component gamma self types self type construct yields flexible typing objects methods return objects type self 
extending notation object types write obj fxg obj binds type variable occur covariantly result types intuitively variable stands type self called self type 
longer object type subtype shorter obj obj recall translation simple object types equation viewed representation type true table translation imperative object calculus hh ii letrec create fn imp fa fl clone nil fg self nil delta clone fg create delta delta delta delta delta delta self fold pack imp fxg delta self create ii xn ii xn hha lii open unfold imp fl self xg delta delta self ai hha open unfold imp fxg fold pack delta imp fx iie open unfold imp fxg delta clone fg ai type object 
take true type self type obj fxg fl sel fxg upd fxg self xg straightforward extension interpretation accounts self types 
structural rules subtyping rules object types assert longer object type subtype shorter object type structural rules arise consequence stronger structural assumption subtypes object type longer object types 
example structural rule simple object types ob modification rule val update table struct val update interpretation structural assumptions object types reflected structural assumptions recursive types 
specifically structural rules object types validated strengthen target calculus structural rule recursive types struct val unfold unfold rule struct val unfold seen consequence assuming subtype recursive type arises reflexivity rule sub refl table subtyping rule recursive types sub rec table 
example suppose sub rec 
form fxg unfold fcg 
op fxg particular get fcg subsumption get consequent rule struct val unfold 
see informally rule struct val update validated struct val unfold 
assume hhaii definition recursive type applying struct val unfold conclude unfold hhaii upd delta delta delta result update type upd returns result type contrast weaker non structural rule val unfold table conclude unfold hhaii result update weaker type enriched object calculus calculus ob str extension ob variance annotations self types structural rules 
semantics ob semantics ob str free sideeffects 
types ob str generated grammar top obj fxg gamma described section obj binds self type variance annotation specifies operations permissible method table operational semantics ob str obj fx eval select fa ag eval update yg obj ag ng self types term syntax ob str slightly different ob obj object form obj standing self type 
method update written known type denotes self type bound object updated usual self parameter method parameter useful type weaker type typing rules ob str structural 
appear appendix operational semantics defined reduction system redexes table 
rule method update note object gets substituted parameter apart difference corresponding rules ob type propagation actual type self gets substituted formal type parameter standing self type 
denote step reduction relation ob str gamma 
os translation translate ob str extension str extension operational semantics includes structural rule rule struct val unfold section 
translation types combines ideas variance annotations self types described section top top obj fxg fxg self xg free fields fxg defined case analysis variance annotation follows fxg sel fxg gamma fxg upd fxg fxg fxg gamma fxg define translation environments section additional clause theorem states formed environments mapped formed environments wellformed types mapped formed types translation preserves subtyping judgements 
theorem 
pi derivable ob str pi derivable fortiori str 
derivable ob str derivable fortiori str 
derivable ob str derivable fortiori str give translation terms table notation notation 
obj fxg define str fxg fxg self xg 
type environment method name define ob str type ha ei follows 
obj ha ei 
type variable ha ei ha cases top ha ei undefined 

section type ai minimum type environment 
prove minimum type exists ob str omit type annotations translation terms basically described ob main novelty translation shows attach suitable type annotations untyped terms described section typed terms ob str get mapped typed terms str theorem states translation preserves typing judgements computational behavior 
theorem 
derivable ob str derivable str 
derivable ob str gamma 
gamma 
table translation ob str str fxg ii letrec create fa fn fa fold pack fl sel upd fa create gamma fn self create fn str fxg create xn xn obj fxg hha lii open unfold fl sel fxg self xg delta sel delta self fa ai ha ei hha open unfold fl upd fxg self xg delta upd delta self ha ei new interpretation objects object types preserves subtyping behavior basic idea works functional imperative semantics 
interpretation general previous solutions handles object constructs cloning method update common class constructs 
simpler proposals sense syntax directed 
interpretation kind 
interpretation offers insights nature objects 
describes principle type safe way coding objects procedural languages 
case limited interpretations actual programming practice pragmatic complexity 
fact confirms commonly held belief object oriented languages differ significantly procedural languages practical expressive power 
ac abadi luca cardelli 
semantics object types 
proceedings ninth annual symposium logic computer science pages july 
ac abadi luca cardelli 
theory primitive objects untyped order systems 
theoretical aspects computer software pages 
springer verlag april 
ac abadi cardelli 
imperative object calculus basic typing soundness 
proceedings second acm sigplan workshop state programming languages 
technical report uiucdcs department computer science university illinois urbanachampaign january 
ac martin abadi luca cardelli 
imperative object calculus 
mosses nielsen schwartzbach editors tapsoft theory practice software development pages 
springer verlag lncs may 
agesen chambers bak chang holzle maloney smith ungar wolczko 
self programmer manual 
sun microsystems 
andersen 
general fine grained firstclass object language 
journal object oriented programming 
app apple computer apple programming language 
car cardelli 
semantics multiple inheritance 
information computation 
special issue devoted symp 
semantics data types sophia antipolis france 
car cardelli 
language distributed scope 
conference record second annual acm symposium principles programming languages 
coo cook 
denotational semantics inheritance 
phd thesis brown university 
smith trifonov 
interpretation typed oop language state 
lisp symbolic computation 
appear 
hp martin hofmann benjamin pierce 
unifying type theoretic framework objects 
journal functional programming 
appear 
previous version appeared symposium theoretical aspects computer science pages 
kam kamin 
inheritance smalltalk denotational definition 
acm symp 
principles programming languages pages 
lie lieberman 
preview act 
technical report ai memo mit 
myers vander zanden 
declarative programming prototype instance system object oriented programming writing methods 
proc 
oopsla pages 
madsen moller pedersen nygaard 
object oriented programming beta programming language 
addison wesley 
mp mitchell plotkin 
types existential types 
acm trans 
programming languages systems 
preliminary version appeared proc 
th acm symp 
principles programming languages 
pt benjamin pierce david turner 
simple type theoretic foundations object oriented programming 
journal functional programming 
em emy 
programming objects ml art extension ml record types 
theoretical aspects computer software 
springerverlag april 
tai taivalsaari 
prototype objectoriented language concatenation module operations 
technical report university victoria 
appendix appendix summarize calculi giving grammars rules 
assertions form indicate hypotheses convention means pi 
ob calculus calculus ob consists rules tables 
syntax environments types top variables terms results calculus calculus consists rules tables 
syntax environments type variables types top fl variables terms fl delta fold unfold pack open results fl fold pack definitions set results adopted 
convenient adequacy theorem particularly compelling 
fortunately techniques sensitive changes definition set results 
imperative variant ob typed imperative object calculus contains rules ob described appendix contains typing rules table additional terms 
ob prove minimum types property typed imperative calculus 
convenient departure original calculus ac terms described contain type information 
syntax environments types top variables terms clone ob str calculus calculus ob str consists rules table rules env type sub table rules table 
syntax environments type variables types top obj gamma variables terms obj table common typing rules environments env pi env pi dom subtyping sub refl sub trans val top type top pi top sub top top variable typing val pi table additional typing rules ob object types subtyping type object sub object term typings val object val select val update table additional typing rules environments env pi dom types type pi type type record fl type rec top type type exists subtyping sub pi sub sub record fl fl sub rec top sub sub exists term typings val fun val appl val record fl fl val record select fl delta val fold fold val unfold unfold val fun val appl bfa val pack pack val open open table additional typing rules imperative calculus val clone clone val table additional typing rules ob str variance sub covariant sub contravariant gamma gamma sub invariant object types subtyping type object top fxg obj gamma covariant sub object obj fxg obj fxg fy fy term typings val object fag fag obj fxg obj fxg struct val select obj fxg fag struct val update obj fxg gamma fy 
