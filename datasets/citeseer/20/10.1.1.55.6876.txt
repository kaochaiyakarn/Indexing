gamma chemical reaction model years 
ban atre le irisa inria campus de beaulieu rennes france email irisa fr gamma originally proposed formalism definition programs artificial sequentiality 
basic idea underlying formalism describe computation form chemical reaction collection individual pieces data 
due minimal nature language absence sequential bias possible exploit initial paradigm various directions 
reviews done various groups lines current perspectives research gamma 
sake clarity separate contributions categories relevance chemical reaction model software engineering extensions original model implementation issues 
basic chemical reaction model notion sequential computation played central role design programming languages past 
state affairs justified reasons ffl sequential models execution provide form abstraction algorithms matching intuitive perception program defined recipe preparing desired result 
ffl actual implementations programs single processor architectures reflecting sequential view 
computer science landscape evolved considerably limitations sequential view obvious 
changes caused tremendous increase size complexity real software applications dramatic progress hardware technology 
examine issues turn assess impact programming languages 

evolution software result growing needs information processing decreasing cost hardware seen tremendous proliferation software systems 
particular embedded systems affect basically aspect daily life remote control units television sets switching telephone networks automatic train control evolution introduces new problems ffl software systems safety critical applications nuclear industry airplane control require high level reliability 
way meet requirement develop software rigorous way relying possible formal methods 
formal language vdm specify software non ambiguous way specification serve basis development software 
ideally software product proven correct respect specification 
implies discipline programming crucially required places strong requirements languages programming languages carefully designed order possible prove properties programs 
ffl softwares tend grow size complexity developed long period time extremely difficult understand maintain 
cost incurred complexity serious concern major challenge today provide ways organising software order big applications manageable favour reuse existing products 
languages proposed tackle problems called software architecture languages coordination languages key feature languages allow description interactions individual components may written different programming languages leading new class challenging inter operability problems 
due sequential bias traditional programming languages suited take challenges lead programs extremely complex correctness proofs provide required level abstraction describe software architectures 

evolution hardware seen years widespread development electronic networks possible progress communication technology 
trend accelerated 
consequence computer longer considered isolation seen node graph representing distributed system 
individual computers longer single processors parallelism integrated various ways levels computation low level pipelining superscalar processors shared memory multiprocessors fine grained parallel machines 
programming machines obviously requires parallel languages models computation 
situation created double evolution placed new needs design languages sequentiality longer seen prime programming paradigm just possible forms cooperation individual entities 
gamma formalism proposed years ago precisely capture intuition computation global evolution collection atomic values interacting freely 
gamma kernel language introduced intuitively chemical reaction metaphor 
unique data structure gamma multiset seen chemical solution 
simple program pair reaction condition action 
execution proceeds replacing multiset elements satisfying reaction condition products action 
result obtained stable state reached say reactions take place 
example gamma program computing non empty set 
max specifies property satisfied selected elements elements replaced set value said definition order evaluation comparisons 
disjoint pairs elements satisfy condition reactions performed parallel 
consider introductory example sorting program 
represent sequence set pairs index value program exchanges ill ordered values stable state reached values ordered 
sort 
possibility getting rid artificial sequentiality gamma important consequences ffl confers high level nature language allows programmer describe programs way 
sense say possible gamma express idea algorithm unnecessary linguistic exchange ill ordered values values ordered sorting algorithm 
gamma suitable intermediate language program derivation process gamma programs easier prove correct respect specification refined sake efficiency second stage 
may involve extra sequentiality crucial methodological advantage approach logical issues decoupled implementation issues 
gamma originally proposed context systematic program derivation ffl gamma programs sequential bias language naturally leads construction parallel programs fact harder write sequential program parallel program gamma 
gamma potential candidate software architecture language atomic actions individual pieces software multiset cooperation facility 
conclude quote dijkstra years ago lesson learned past development richer powerful programming languages mistake sense baroque idiosyncrasies really unmanageable mechanically mentally 
see great systematic modest programming languages 
believe statement relevant minimal nature original gamma formalism factor possible various developments sketched 
sake clarity provide section basic intuitions programming style entailed gamma relevance program construction software engineering 
section describe number variations elaborations original chemical reaction metaphor 
section devoted implementation issues section sketch related research perspectives area 
chemical reaction basis software engineering chemical reaction model basic paradigm deep effect way thinking algorithms 
try convey programming style favoured gamma simple examples 
introduce basic programming schemes called tropes emerged experience writing gamma programs 
slightly formal view show possible extract useful properties definition gamma program alternatively derive gamma programs specifications systematic way 
new programming style come back straightforward max program defined illustrate distinguishing features gamma max order write program computing maximum set values traditional language choose representation set 
representation typically array imperative language list declarative language 
program defined iteration array recursive walk list 
important point data structure impose constraints order elements accessed 
course parallel versions imperative functional programs defined solutions divide conquer paradigm example really model total absence ordering elements achieved gamma program 
essential feature gamma programming style data structure longer seen hierarchy walked decomposed program order extract atomic values 
atomic values gathered single bag computation result individual interactions 
related notion locality principle gamma individual values may react produce new values completely independent way 
consequence reaction condition include global condition properties properties cardinality multiset 
locality principle crucial easier reason programs encapsulates intuition hidden control constraints gamma programs 
consider problem computing prime numbers value basic idea algorithm described follows start set values remove set element multiple element 
gamma program built sequential composition iota computes set values rem removes multiples 
program iota reactions splits interval parts second replaces interval value primes rem iota iota 
rem multiple reaction increases size multiset second keeps constant third multiset shrink 
contrast usual sequential parallel solutions problem usually successive application gamma program proceeds collection atomic actions applying individual independent pieces data 
program exhibiting expansion shrinking phases gamma version fibonacci function fib add dec dec gamma gamma add rue initial value decomposed dec number ones summed add produce result 
phase corresponds recursive descent usual functional definition fib fib gamma fib gamma reduction phase counterpart recursive ascent 
gamma program introduce constraint way additions carried contrasts functional version additions performed order imposed recursion tree execution 
example consider maximum segment sum problem 
input parameter sequence integers 
segment subsequence consecutive elements sum segment sum values 
program returns maximum segment sum initial sequence 
elements multiset triples position value sequence maximum sum computed far segments position field triple originally set field 
program max computes local maxima max returns global maximum 
max max max 
max 
tropes basic programming schemes reader may noticed number recurrent programming patterns small examples previous section 
experience writing gamma programs came small number program schemes necessary write applications 
focus section schemes called tropes transmuter reducer optimiser expander selector 
tropes schemata basic reaction action pairs defined way 
notice reducer selector strictly decrease size multiset expander increases size transmuter optimiser keep size constant 
provide intuition tropes examples involving tropes 
transmuter transmuter applies operation elements multiset element satisfies condition example program returns initial triple triple third component records number times multiple nt multiple second reaction definition iota previous section expressed transmuter rp reducer reduces size multiset applying function pairs elements satisfying condition 
counterpart traditional functional reduce operator obtained true reaction condition 
instance program add appeared definition fib de expressed add rue expander expander decompose elements multiset collection basic values 
example ones decomposes positive values occurrences 
ones gamma program iota redefined composition expander transmuter iota selector selector acts filter removing multiset elements satisfying certain condition 
example program max de defined max 
program rem definition primes example selector rem multiple 
program primes expressed follows primes rem iota note selector corresponds reaction removes selected elements multiset 
optimiser optimises multiset particular criterion expressed ordering preserving structure multiset described relation 
sort program section instance optimiser scheme sort section examples involving combinations tropes 
consider longest problem 
subsequence obtained sequence deleting necessarily adjacent values 
subsequence called values non decreasing order 
problem compute length longest sequence 
represent sequence set triples xn xn value index length longest known index solution tropes composition optimiser finding length longest particular index selector evaluating maximum lengths 
lup maxl li li xn xn xn xn xn maxl xn maximum segment sum program previous section defined terms tropes similar way 
fibonacci function expressed combination tropes fib add zero dec fng dec gamma gamma zero add rue examples interested reader find longer series examples chosen wider range domains string processing problems graph problems geometric problems 
just sketch section small selection applications consider significant size target domain 
image processing applications gamma project aiming experimenting high level programming languages prototyping image processing applications application recognition topography vascular cerebral network 
treatment decomposed main phases 
step consists discovering skeleton image extracting number significant pixels 

second step gathers consecutive pixels segments length 

third step tries establish correspondences segments images 
steps aim reducing combinatorics problem pave way third step 
correspondence segments derive correspondence pixels build representation 
version application written pl start experiment getting huge quite difficult master 
benefits rewriting application gamma better understanding key steps application discovery number bugs original software 
gamma context executable specification language turned suited description class algorithms 
basic reason probably treatments image processing naturally expressed collections local applications specific rules 
order convey intuition relevance gamma kind applications describe small part stage called edge detection problem 
point image originally associated grey intensity level 
intensity gradient computed point edges defined points gradient greater threshold gradient point computed relative neighbours points distance considered computation gradient 
gradient point defined way maximum neighbourhood gamma minimum neighbourhood neighbourhood distance dg multiset quadruples min max 
coordinates point intensity level min max current values respectively minimum neighbourhood maximum neighbourhood 
sequel capital letters denote quadruples min max access corresponding fields 
initial value min max fields evaluation consists decreasing min increasing max limit values reached 
achieved program dci 
program sel discards points gradient threshold removes unnecessary fields remaining elements 
edges sel dci dci 
max min distance 
min max distance sel 
max gamma min 
max gamma min version program terms tropes section 
example application gamma image processing reported aim application generate fractals model growth biological objects 
facility expression problem gamma seen great advantage 
experiences lack efficient general purpose implementation gamma mentioned serious drawback prevented test large examples 
postpone discussion implementation issues section 
reactive programming problems considered far essentially algorithmic 
suggest gamma quite different way subsection longer interested result evaluation programs typically non terminating possible values multiset computation 
operating system kernel defined gamma extended fairness assumption proven correct framework inspired unity logic basis solution system program manipulates structures form represent respectively state mailbox channel associated process functions called system 
system program includes rules form ready fmg rue rue reaction describes sequential computation remaining deal communication processes mailboxes 
important result described definition temporal logic version gamma extended fairness assumption derivation kernel file management system successive refinements temporal logic specification 
refinement step results greater level detail definition network processes 
aware comparable attempts area operating systems 
software architecture related area application attracts growing interest formal definition software architectures 
stated software systems complex system structure software architecture central design problem 
important step discipline software formal basis describing analysing designs 
typical examples software architectures clientserver organisation layered systems blackboard architecture 
despite popularity topic little attention focused methods comparing software architectures proving satisfy certain properties 
major reason tasks difficult lack common formally language describing software architectures 
descriptions typically expressed informally box lines drawings indicating global organisation computational entities interactions chemical reaction model formal basis specifying software architectures application considered multiphase compiler architectures defined variation basic gamma model called chemical machine described section 
different phases compiler called lexer parser optimiser generator 
initial phase called text generates source text 
types data elements circulating architecture char tok phr obj 
elements multiset forms pi pi phase pi phase pi phase pi pi pi free constructor represent data types phase phases mentioned 
element starting resp 
corresponds phase consuming inputs resp 
producing outputs 
element starting phase ready interact 
seen ports defining communications take place state 
typical reaction definition architecture pi pi pi pi pi pi pi pi rule describes pairwise communication processing elements consumes input produced output processing element example reaction tok pi phr pi parser tok pi lexer pi char phr pi parser pi tok lexer pi char pi tok represents consumption parser tokens produced lexer 
reaction parser ready produce output lexer inert completed job 
fact reaction may applied active process piece text 
major benefit approach possible define architectures application compare formal way 
example defines correspondence multisets generated versions multiphase compiler establishes form bisimulation architectures 
prove normalisation properties programs 
approach described focuses interconnection individual components software architecture 
version gamma possible manipulate relations values multiset exactly way values 
extension called structured gamma section 
relevance description software architecture comes fact connections individual pieces software class objects invariance properties proven structure network 
example architecture multiphase compiler suggested characterised multisets particular type including values corresponding processing elements relations corresponding links values role played implicitly data types communication ports 
evolution computation defined terms reaction rules possible prove rules maintain invariant defining architecture implies instance parser consume values produced lexer 
words definition static aspect software architecture separated specification dynamic component 
type structure multisets manipulated program defining 
program derivation previous sections tried convey programming style entailed chemical reaction model series examples 
said word possibility formal reasoning gamma programs 
semantics language terms multiset rewriting proposed discussed intend go formal aspects suggest techniques prove properties programs derive programs specifications 
order prove correctness program imperative language common practice consists splitting property parts invariant holds computation variant required hold computation 
case total correctness necessary prove program terminate 
important observation concerning variant property gamma program terminates reaction take place means tuples elements satisfy reaction condition 
obtain variant program negation reaction condition 
consider example sort program introduced section 
reaction condition corresponds property negation variant informative ordering property 
invariant program ensure set indexes multiset values constant 
checked simple inspection action easy see global invariance follows local invariance 
order prove termination program provide wellfounded ordering ordering infinite descending sequences elements show application action decreases multiset ordering 
aim resort result allowing derivation founded ordering multisets founded ordering elements multiset 
ordering ae ordering multisets defined way ae multisets gamma ordering ae multisets founded ordering founded 
result fortunate definition ae precisely behaviour gamma removing elements multiset inserting new elements 
significance result allows reduce proof termination essentially global property local condition 
order prove termination sort program ordering elements multiset easy see ordering founded set indexes multiset values finite corresponding multiset ordering founded 
left proof value produced action find consumed value strictly greater 
prove observe 

concludes correctness proof sort program 
proving program posteriori may appropriate start specification try construct program systematic way 
derived program correct construction 
method derivation gamma programs specifications order logic proposed basic strategy consists splitting specification properties play roles invariant variant program derived 
invariant chosen part specification satisfied input multiset established initialisation program 
variant involves quantifiers negation yields reaction condition program directly 
technique deriving action consists validating variant locally maintaining invariant 
constraints strong guide construction action 
consider example rem program definition prime section 
input multiset ng possible specification result ng ng ng multiple multiple properties satisfied input multiset ng invariant defined variant 
negation variant multiple yields reaction condition multiple 
action satisfy invariant means value outside ng added multiset value removed multiset multiple value 
hand action establish variant locally means returned values contain multiples 
action return remove possibility return action satisfies conditions derived program rem multiple interested reader find complete examples slightly different approach taken introduces general form specification derivation corresponding gamma program 
shown number classical apparently unrelated problems knapsack paths maximum segment sum longest problems turn instances generic specification 
generic derivation instantiated applications yielding corresponding gamma programs 
conclude section stress pervasive influence locality principle stated correctness proofs derivations 
part correctness proof sort program sketched exploits feature reducing global reasoning manipulation properties multiset local reasoning elements involved single reaction 
major benefit systematic derivation approach leads unexpected parallel solutions problems considered inherently sequential 
probably best way explore new style programming avoid pitfall trying recast gamma framework traditional programming patterns 
elaborations basic chemical reaction model chemical reaction model served basis number works led extensions minimal version described far 
section review important elaborations chemical reaction model proposed literature 
proposals put forward theoretical objectives mind aim making model practically usable 
extensions quite significant open new areas research important note fundamental characteristics model expression computation global result successive applications local independent atomic reactions 
chemical machine chemical machine cham proposed berry boudol describe operational semantics process calculi 
important additions gamma notions membrane mechanism 
membranes encapsulate solutions force reactions occur locally 
terms multisets membrane introduce multiset molecules inside multiset say transform solution single molecule mechanism describe communications encapsulated solution environment 
reversible operator extracts element solution fm mn fm mn fm fm mn gg new molecule react fm mng allowed continue internal reactions 
main role allow molecule visible outside membrane take part reaction embedding solution 
need membranes emerged description ccs cham especially treatment restriction operation restricts communication capabilities process labels different particular value 
computation rules cham classified general laws classes rules ffl general laws include chemical law membrane law fc fc shows reactions performed freely solution captures locality principle 
allows reactions take place membrane denotes context solution 
ffl class rules corresponds proper reaction rules similar rules far 
definition specific cham requires specification syntax molecules associated reaction rules 
example molecules ccs processes rule corresponding communication ccs ff ff 
ffl second kind rules called structural reversible 
decomposed inverse relations called respectively heating cooling rules 
ones break complex molecules smaller ones preparing reactions second ones rebuild heavy molecules light ones 
continuing ccs example structural rule ccs parallel composition operator 
cham define semantics various process calculi tccs milner calculus mobile processes concurrent lambda calculus 
cham call need reduction strategy calculus defined cham inspired number contributions 
mention ffl uses linear cham describe operational semantics proof expressions classical linear logic 
ffl defines operational semantics calculus cham style 
ffl describes graph reduction terms cham 
ffl applies cham context facile implementation 
cham approach illustrates significance multisets connection concurrency 
fact multisets inherently unordered suitable basis modelling concurrency essentially associative commutative notion 
stated sos style semantics labelled transitions necessary overcome rigidity syntax performing communications syntactically distant agents 
contrary cham just syntactic distance vanish putting molecules contact want communicate communication direct 
consequence possible bring semantics concurrent systems nearer execution process sequential languages evaluation mechanism functional languages composition operators gamma gamma programs far single block reaction rules 
basic version language provide facility building complex programs simple ones 
sake modularity desirable language offers rich set operators combining programs 
fundamental operators enjoy useful collection algebraic laws order possible reason programs 
section sketch proposals extend gamma facilities structuring programs 
presents set operators gamma studies semantics corresponding calculus programs 
basic operators considered sequential composition ffi parallel composition intuition ffi stable multiset reached execution argument hand result obtained roughly speaking executing reactions order possibly parallel terminating proceed 
termination condition particularly significant heavily influences choice semantics parallel composition 
example sequential composition gamma programs consider version sort 
sort match ffi init init 
integer match 
program sort takes multiset integers returns increasing list encoded multiset pairs index value 
reaction init gives integer initial rank 
completed match takes elements rank increases rank larger 
case parallel composition slightly involved 
fact sort defined sort match init reactions match executed parallel reactions init provided apply subsets implied fact respective reaction conditions exclusive 
far semantics parallel composition concerned key point synchronised termination required terminate 
may case stage computation reaction conditions resp 
holds reactions resp 
may create new values able take part reactions resp 

situation precisely occurs example reaction match take place initial multiset init transforms multiset triggers subsequent reactions match 
termination condition indicates terminate terminate composition 
contrasts asynchronous termination condition process calculi terminates reduces nil jj 
gamma programs compared rewriting systems parallel composition union rewriting systems 
context natural say normal form reached systems possess rule apply term 
new vision parallel composition combination sequential composition creates interesting semantical problems studied defines set program refinement equivalence laws parallel sequential composition considering input output behaviour induced operational semantics 
particular attention paid conditions ffi transformed vice versa 
transformations useful improve efficiency program respect particular machine implementation strategy 
take example illustrate point connected singleton ffi nodes nodes nodes program detect graph strongly connected 
initial multiset representation graph consists collection singleton sets nodes collection edges 
pair represents edge linking nodes proceeds building bigger bigger aggregates connected nodes 
predicate nodes simply allows reactions distinguish edge node set 
remove edges connecting nodes belonging set 
process stabilised graph connected nodes gathered single set 
tested primitive singleton specified 
algebra programs defined show example equivalent ffi means reactions postponed reactions take place 
target architecture sequential parallel relatively processors ffip efficient useless tests reaction condition avoided turn better version executed massively parallel machine unnecessary edges removed time aggregates built operational semantics mentioned compositional difficult reasoning large programs 
proposes solution problem defining compositional semantics language transition traces presents number basic laws programs semantics 
laws established operational semantics remain valid transition trace semantics transition traces distinguish programs identical input output behaviour behave differently different contexts 
shown interesting properties hold great advantage new semantics laws modular way prove properties large programs 
results specialised derive useful properties tropes useful properties common forms gamma programs 
application consider image processing program edges introduced section 
program expressed terms tropes follows edges disc rf ffi max min min distance oe min oe max max distance disc max gamma min rf max gamma min transformations justified general properties tropes derived compositional semantics disc rf disc ffi rf disc rf rf ffi disc ffi ffi composition operators studied general framework called reduction systems sets equipped collection binary rewrite relations 
led new graph representation gamma programs forms better basis study compositional semantics refinement laws 
roughly speaking nodes graphs correspond sets basic programs reaction conditions active stage computation edge represents internal termination step 
example graph associated program ffi ffi defined nodes fp fp fp fp edges 
control starts node root graph proceed terminates start terminates 
final state representation suited study program logics led discovery additional laws gamma programs 
different approach definition compositional semantics taken proposes alternative definition parallel composition operator 
sequential composition context sensitive respect parallel composition example ffi reduce multiset inert program possibly produce new values consumed convincingly argues choice lead undesired computations coherent choice synchronous termination corresponds context sensitive condition terminate multiset inert solution separation reduction rules proper transformations correspond individual chemical reactions transformations modify program effect multiset 
resulting definition parallel operator restricts non determinism possible avoid undesired computations 
observational equivalence concept strong bisimulation defined shown congruence semantics gamma proposed including defines congruence transition assertions describes behaviour gamma programs lamport temporal logic actions 
denotational semantics expressed terms transition traces derive program logic gamma 
derivation abramsky framework domain theory logical form 
higher order gamma suggested previous section proposals extension gamma primitive operators 
approach composition operators language consists providing way programmer define higher order programs 
traditional view functional programming area requires able manipulate programs ordinary data 
approach followed proposes higher order version gamma 
definition gamma far involves different kinds terms programs multisets 
multiset data structure programs described collections pairs reaction condition action 
main extension higher order gamma consists unifying categories expressions single notion configuration 
important consequence approach active configurations may occur inside multisets reactions take place simultaneously different levels 
conditions satisfied simple program terminate tuple elements satisfies reaction condition multiset contain active elements 
configuration denoted rog ar arn consists possibly empty program rog record named multisets ar configuration empty program component called passive active 
record component configuration seen environment program 
component environment typed multiset 
simple programs extract elements multisets produce new elements 
stable component configuration obtained result ar operational semantics essentially extended rules capture higher order features fxg phi fx phi ar ar second rule respectively account computation active configurations inside multisets transformation multisets containing active configurations inside configuration 
note rules similar chemical law membrane law cham section 
take example illustrate expressive power provided extension 
application sequential composition operator simple programs defined higher order gamma need included primitive 
ffip defined configuration multiset containing active configuration initially 
note reactions apply passive values means stable state new active configuration inserted computation start 
stable state obtained extracted top level configuration access operation denoted higher order gamma provide formal specification real life distributed system lotus notes groupware product 
relevance formalism illustrated detection errors initial specification elimination overly restrictive data structures exposition natural parallelism replication algorithm 
shows useful combining forms defined higher order gamma including chemical machine 
possible express sophisticated control strategies scan vector model suitable execution fine grained parallel machines 
generalisation chemical model higher order structured gamma sections illustrated fact choice multiset unique data constructor central design gamma 
may lead programs unnecessary complex programmer needs encode specific data structures 
example necessary resort pairs index value represent sequences sort program 
trees graphs encoded similar way 
lack structuring detrimental reasoning programs implementing 
proposal attempt solve problem basic qualities language 
point particular acceptable take usual view recursive type definitions lead recursive style programming fundamental locality principle data structure manipulated 
solution proposed notion structured multiset seen set addresses satisfying specific relations associated value 
type defined terms rewrite rules structured multiset belongs type underlying set addresses satisfies invariant expressed rewrite system defining example list type defined rewrite system list means multiset reduced singleton list belongs list type 
variables rules instantiated addresses multiset 
seen non terminal standing list starting address element list 
circular list defined follows circular note different variable names rule significant variables instantiated address variables name 
definition non terminal list starting position position reaction structured gamma ffl test modify relations addresses 
ffl test modify values associated addresses 
examples programs operating lists sort list mult list iota list gamma actions described assignments addresses 
consumed address occur result action disappears multiset case mult program 
hand new addresses added multiset value iota program 
actions state explicitly relations modified 
instance sort modify relation mult shrinks list removing intermediate element significance approach programmer define types programs checked type definitions 
verification automatically term rewriting techniques notion critical pairs 
example possible check programs manipulate multisets type list words list property invariant programs 
important notice new structuring possibility obtained sacrificing fundamental qualities language 
gamma programs just particular cases structured gamma programs structured gamma programs translated straightforward way gamma gamma logic programming original setting main features gamma multiset fixed collection condition action pairs 
types objects multiset language definition actions left unspecified 
consequence gamma seen coordination language language coordinating applications written different languages 
defined actions functions proposals integration gamma logic programming languages 
main questions answered respect integration ffl kind logical objects contained multiset 
ffl condition action pairs defined 
approach followed uses multisets terms describes conditions actions predicates 
semantics extension logic programming multisets defined form soundness completeness proven 
involves definition multiset unification careful integration operational semantics gamma choices reaction conditions backtrackable 
model implemented extension godel strongly typed logic programming language rich module system 
extension called gammalog includes sequential parallel composition operators introduced approach followed objects multisets goal formulas condition action pairs goal directed deduction rules 
results lo extension lo seen elaboration basic chemical reaction model 
lo fragment linear logic admits goal directed proofs 
notion multisets goal formulas natural lo difference intuitionistic logic linear logic 
lo offers naturally multiple multisets permits spawn subproofs associated multisets 
lo seen higher order extension lo way prolog higher order extension prolog 
implication goals provides ability construct augment program run time multisets leads uniform treatment programs data 
chemistry computing implementation issues mentioned previous sections philosophy gamma introduce clear separation correctness issues efficiency issues program design 
traditional programming languages encourage emergence solutions overconstrained compared logic problem solved 
particular sequential data structures arrays lists favour solutions iteration recursion inherently sequential limit dramatically possibility concurrent execution 
contrast gamma seen specification language introduce unnecessary sequentiality 
consequence gamma program usually far away real architecture designing reasonably efficient implementation language straightforward 
section reviews efforts order improve implementation gamma 
sequential implementation gamma consider simple form gamma program xn xn xn straightforward implementation program described imperative program tuples remain processed choose tuple xn processed xn remove xn replace xn naive implementation puts forward problems tackled order produce gamma implementation realistic complexity 
hardest problem concerns construction tuples checked reaction 
blind approach problem leads complexity thorough analysis possible relationships elements multiset shape reaction condition may lead improvements highly optimise execution produce acceptable performances 
thesis studied optimisations summarised 
important source inefficiency comes useless redundant deemed fail checks reaction condition 
optimisations dramatically reduce overhead resulting redundancy 
decomposition reaction condition considering may decompose conjunction simpler conditions xn rn xn test condition done incrementally avoiding construction tuples prefix satisfy 
detection neighbourhood relationships analysis reaction condition may provide information limit search space 
example may happen reaction condition adjacent values react values possessing common flag confronted 
properties detected compile time situations sorting examples pattern detection image processing applications run time improvement considerable 

control non determinism gamma paradigm imposes constraint way tuples formed 
shows limiting nondeterminism imposing ordering choice values checked reaction condition fruitful 
interesting described known efficient versions sequential algorithms shortest path instance rediscovered justified result naive implementation gamma 
case drastic optimisations rely structural properties values belonging multiset neighbourhood relationship ordering choice values 
properties difficult find automatically optimisations described seen refinement steps compilation techniques 
reason proposals enrich gamma features exploited compiler reduce overhead associated magic process come back extensions 
parallel implementations gamma property gamma advantage potential concurrent interpretation 
principle due locality property tuple elements fulfilling reaction condition handled simultaneously 
clear managing parallelism efficiently difficult task complex choices order map chemical model parallel architectures 
section sketches attempts provide parallel implementations gamma programs 
implementations distributed memory parallel machines protocols proposed implementation gamma network communicating machines 
major problems solved 
detection tuples may react 

transformation multiset application reactions 

detection termination 
proposed protocols differ way rewritings controlled case central controller manages information transfers processing elements case information transfers managed fully way 
ffl synchronous gamma machine protocol step cardinality argument multiset algorithm 
controller connected processors pm gamma monitors information exchanges processors 
elements multiset distributed local memories 
sake simplicity assume number processors equals number values multiset reactions actions binary 
processor possesses variable indicating identity correspondent step execution 
values initialised gamma mod computation step value updated mod providing new configuration producing new set pairs reaction condition may applied 
starting step sequence consecutive steps generates possible configurations 
property detect termination system gamma configurations built reaction 
synchronous implementation implemented connexion machine experiments conducted maspar simd machine describes implementation gamma results speed exploitation parallel resources 
shows higher order gamma programs refined efficient execution parallel machine 
ffl asynchronous gamma machine values multiset spread chain processors 
central controller system processor knows neighbours 
processor manages variables value indexes number exchanges undergone number successive exchanges processors possessing values gamma 
proven processor possesses value gamma value involved reaction corresponding process activity 
termination detection algorithm fully distributed chain processors cost detection high compared cost computation solution implemented intel ipsc machine connexion machine results show exploitation processing power speedup 
distributed operating system kernel developed order circumvent hypotheses number processors number values 
implementation shared memory machines seen shared memory model multiset unique data structure elements extracted elements resulting reaction stored 
clear shared memory multiprocessors candidates parallel implementations gamma 
specific software architecture developed order provide efficient gamma implementation sequent multiprocessor machine 
techniques experimented order improve significantly performances ffl variables reaction condition ordered way part condition tested early possible selected elements 
partial test fails remaining elements ignored 
optimisation similar technique described ffl operations defined terms arithmetic comparisons optimised restricting range bag elements considered 
equality operation especially interesting respect 
order implement optimisation physical organisation multiset reflect arithmetic relation elements 
proposes ordered trees hashing tables represent multisets 
idea close methods implementation relational data base systems 
ffl redundant evaluations avoided keeping track performed evaluations log contains elements generation 
generation processed generation fully processed 
achieved keeping generation auxiliary multiset transferred original multiset generation completely processed 
kernel operating system developed order cope various traditional problems particular synchronisation required gamma multiset element participate reaction time 
experiments carried various examples 
show impact proposed optimisations performances difficult compare traditional imperative implementations look promising 
group investigated gamma paradigm functional language introduce multiset data structuring facility multiset versions operations fold map 
various implementations operations shared memory multiprocessor investigated evaluated 
hardware implementation gamma tropes tropes defined section 
basis design specialised architecture hardware skeleton associated skeletons parameterised combined program implemented 
circuit produced program description 
hardware platform prl dec perle board built large array bit level configurable logic cells array surrounded local ram banks cache programmable board additional logic manage host bus interface 
programming perle consists describing architecture built primitives functions 
final objective provide environment compiles gamma programs tropes hardware perle code 
step manual translation gamma perle applied classical examples prime factorisation performances compared implementations problems sparc workstations 
perle implementation ranges sparc sparc implementations showing proposed approach may lead reasonable performances high level language gamma 
number languages formalisms bearing similarities chemical reaction paradigm proposed literature 
briefly review significant ones ffl programming notation called introduced essentially tuple names defining relation entities 
state changed creation new representing new relations derived existing ones 
contrast gamma model deterministic satisfy locality properties dues presence properties 
ffl unity program basically set multiple assignment statements 
program execution consists selecting non deterministically fairness condition assignment statement executing repeating forever 
defines temporal logic language associated proof system systematic development parallel programs 
unity programs look gamma programs example exchange sort program 
main departures gamma array basic data structure absence locality property 
hand unity allows programmer distinguish synchronous asynchronous computations suitable effective programming languages parallel machines 
vein unity action systems od programs consisting collection guarded atomic actions executed long guard remains true 
ffl linda contains simple commands operating tuple space 
producer add value tuple space consumer read destructively value tuple space 
linda elegant communication model easily incorporated existing programming languages 
ffl lo linear objects originally proposed integration logic programming object oriented programming 
seen extension prolog formulae having multiple heads 
object oriented point view formulae implement methods 
method selected head matches goal corresponding object current state 
head formula seen set resources consumed application method tail set resources produced method 
lo foundation interaction machines extending chemical reaction metaphor notion broadcast communication agents created dynamically reactions extra effect broadcasting value agents 
translation gamma language linear logic dual perspective interesting note physical modelling community borrowed concepts computer science leading formalisms bear similarities higher order gamma 
example trend activity turing gas molecules float random solution reacting come contact 
language akin lambda calculus express symbolic computation involved reactions 
hope shown chemical reaction paradigm active research topic 
basically distinguish main directions current works area 
follows seminal presentation cham explores paradigm theoretical setting order provide better foundations definition semantics concurrent languages survey trend 
second practically oriented studies usefulness paradigm specific application domains tries extend formalism usable terms efficiency software engineering new illustration relevance paradigm proving properties distributed systems provided context formal verification cryptographic protocols 
shown protocols expressed naturally terms chemical reactions multiset containing states trusted untrusted agents 
example known protocol described collection fourteen reactions 
proposals enhancing basic version gamma mention ffl language schedules new approach providing extra information control gamma programs 
key idea separate definition gamma program parts individual reactions correspond single application rewrite rule schedules specify control part program 
language schedules includes iteration sequential parallel composition non determinism 
nice property schedules disentangle orthogonal features gamma choice multisets data structure mechanism control structure allow user choice concerning control component program 
ffl local linear logic interesting proposal increasing efficiency gamma compromising style 
local linear logic extends principle resource consciousness linear logic notion locality consciousness 
locality expressed associating indices elements sequence imposing elements move correct place sequence 
words multiset replaced self ordering sequence 
ffl structured version gamma described section promising research direction respect implementation issues structure data explicit available compiler 
proposals tackle problem complementary ways schedules introduce way master control local linear logic structured gamma different means structuring multiset 
crucial issue proposals carefully designed order preserve fundamental qualities formalism 
efforts hopefully converge new generation practical languages sounds principles chemical reaction paradigm 
acknowledgments express people contributed development gamma years 
numerous named individually hope forgotten bibliography 
grateful referees careful reading valuable suggestions 

abramsky computational interpretations linear logic theoretical computer science vol 
pp 


allen garlan formalising architectural connection proceedings ieee th international conference software engineering pp 



andreoli pareschi linear objects logical processes built new generation computing vol 
pp 



andreoli ciancarini pareschi interaction machines proc 
workshop research directions concurrent object oriented programming 


andreoli coordination lo volume 

back refinement calculus part ii parallel reactive programs proc 
workshop stepwise refinement distributed systems models formalisms correctness springer verlag lncs 


banatre coutant le parallel machine multiset transformation programming style generation computer systems pp 



banatre coutant le parallel machines multiset transformation programming style oldenburg verlag vol 
pp 



banatre le gamma model discipline programming science computer programming vol 
pp 



banatre le programming multiset transformation communications acm vol 
pp 
january 

bertin vuillemin programmable active memories performance assessment proc 
workshop parallel architectures efficient springer verlag lncs pp 


berry boudol chemical machine theoretical computer science vol 
pp 


approach formal verification cryptographic protocols proc 
rd acm conference computer communication security 

boudol chemical machines proc 
workshop decade concurrency springer verlag lncs pp 


advantages formal specifications case study replication lotus notes proc 
conference formal models open object distributed systems march 

guglielmi linear logic view gamma style computations proof searches volume 

chandy misra parallel program design foundation addison wesley 

carriero gelernter linda context communications acm vol 
pp 
april 

de jong schedules multiset transformer programs volume 

de jong compositional method coordinating gamma programs proc 
coordination conference springer verlag lncs appear 

ciancarini logic language multiset rewriting volume 

ciancarini gorrieri zavattaro alternative semantics calculus gamma programs volume 

cohen calculus higher order multiset programming proc 
coordination conference springer verlag lncs appear 

techniques analyse de mise en des programmes gamma thesis university rennes 

implementation gamma connection machine proc 
workshop research directions high level parallel programming mont saint michel springer verlag lncs pp 


syst ematique un algorithme de segmentation images aide de gamma techniques sciences vol 
pp 


dershowitz manna proving termination multiset ordering communications acm vol 
pp 
august 

dijkstra humble programmer communications acm vol 
pp 
october 

hankin jensen congruence gamma programs proc 
wsa conference 

fontana algorithmic chemistry proc 
workshop artificial life santa fe new mexico addison wesley pp 


fradet le structured gamma irisa research report pi march 

gay hankin program logic gamma volume 

gelernter generative communication linda acm transactions programming languages systems vol 
pp 
january 

parallel implementation bags proc 
conference linz austria 

hankin le sands calculus gamma programs proc 
th workshop languages compilers parallel computing yale springer verlag lncs 

hankin le sands parallel programming style algebra programs proc 
parle conference munich springer verlag lncs pp 


inverardi wolf formal specification analysis software architectures chemical machine model ieee transactions software engineering vol 
pp 
april 

jeffrey chemical machine graph reduction tr university sussex 

parallel implementation bags proc 
acm conf 
functional programming computer architecture acm pp 


le higher order multiset programming proc 
dimacs workshop specifications parallel algorithms american mathematical society dimacs series discrete mathematics vol 


leth thomsen facile chemistry tr ecrc 

lin peng huan kam wing ng yong qiang sun implementing higher order gamma maspar case study journal systems engineering electronics vol 


lin peng huan kam wing ng yong qiang sun implementing gamma maspar mp journal computer science technology appear 

gamma chromatic typing vegetation volume 

hartel local linear logic locality consciousness multiset transformation proc 
programming languages implementations logics programs plilp utrecht springer verlag lncs pp 


milner communication concurrency international series computer science prentice hall englewood cliffs nj 

milner functions processes mathematical structures computer science vol 
pp 


parallel programming bags proc 
workshop research directions high level parallel programming mont saint michel springer verlag lncs pp 


rem program notation tuples variables acm transactions programming languages systems vol 
pp 
july 

reynolds temporal semantics gamma volume 


de roever formal methods real time system specification proc 
euromicro panel discussion june athens 

ruiz une approche la de syst emes en gamma thesis university rennes july 

sands compositional semantics combining forms gamma programs proc 
formal methods programming applications conference springer verlag lncs pp 


sands composed reduction systems volume 

van gammalog goal directed proofs internal report 

synth ese de programmes gamma en logique reconfigurable technique science vol 
pp 

