specification verification fault tolerance timing scheduling zhiming liu department mathematics computer science university leicester leicester le rh mail liu mcs le ac uk joseph department computer science university warwick coventry cv fault tolerance timing considered implementation issues program quite distinct functional safety liveness properties 
shown non functional functional properties verified similar way 
practical question determining real time program meet deadlines showing feasible schedule usually done scheduling theory quite separately verification properties program 
hard results scheduling analysis design re design fault tolerant real time programs 
shows fault tolerance timing schedulability specified verified single notation model 
allows unified view taken functional non functional properties programs simple transformational method combine properties 
permits results scheduling theory interpreted formal proof framework 
notation model illustrated simple example 
keywords fault tolerance real time specification verification transformation schedulability 
concerns development formal techniques specification verification systematic construction safety critical computer systems 
examples systems include concurrent real time systems communication networks air traffic control systems process control systems 
satisfactory functioning depends crucially correctness dependability design implementation hardware software systems 
correct reliable construction safety critical systems particularly challenging concerned things inter related issues concurrency fault tolerance timing schedulability analysis 
joseph current address tata research development design centre industrial estate india mail tcs 
historical background starting early formal techniques design analysis concurrent systems seen considerable development 
significant contribution better understanding behaviour concurrent systems reliable construction 
widely studied methods formal specification development verification concurrent systems temporal logic 
traditional temporal logic methods similar formalisms discrete event approach case transition systems kel pnu mp lam pnu automata ces cdk action systems bac cm 
models away time behaviour describe ordering events system 
temporal logic specification verification typically concerned qualitative functional properties safety invariance liveness responsiveness hmp 
transition systems similar models temporal logic specification reasoning successfully untimed concurrent systems expressive systems quantitative temporal requirements ad bounded invariance bounded responsiveness hmp hmp 
real time introduced transition systems associating lower upper bounds enabled transitions ph introducing explicit clocks ad 
specification verification temporal logic extended bounded quantized temporal operators esp ph koy addition explicit clock variables ph ah 
relationship approaches extent translated investigated hmp 
construction safe dependable computing system goal formal specification development verification methods mainly part fault approach system safety dependability improved priori fault avoidance fault removal avi 
path goal fault tolerance complementary fault substitute avi 
protective redundancy system designed fault tolerant incorporating additional components algorithms ensure occurrence error state result system failures ran rlt lsp 
fault tolerance means new concept neu little formal treatment fault tolerance mj ss cri liu lj lj lj 
papers treat untimed fault tolerant systems 
ch sg lm lj shown fault tolerance timing properties formally treated 
issue schedulability arises real time program implemented system limited resources processors jg 
infeasible implementation real time program meet timing requirement program formally proven correct 
words correctness real time program hoo treated formal framework usually conditional feasible implementation 
schedulability long time concern scheduling theory ll jp lsd abr bw models techniques quite different formal specification development methods 
relationship computational model scheduling analysis model interleaving model formal development clear 
results obtained scheduling theory hard relate formal development system 
possible verify schedulability program formal framework pbr fs lz provides starting point proof theoretic interpretation results scheduling theory 
overview show fault tolerance schedulability functional time correctness specified verified single formal framework 
transition systems kel pnu program model temporal logic actions tla lam specification notation 
physical faults system modelled caused set fault actions perform state transformations way program actions 
fault tolerance achieved program tolerant faults adding appropriate recovery actions ran rlt liu lj lj lj 
shall show proof fault tolerance different proof functional property 
real time programs action program associated volatile lower bound volatile upper bound meaning action performed continuously enabled time units continuously enabled time units performed 
volatile time bounds correspondingly volatile timers clock variables explicit clock modelling approach described literature see previous subsection specify time criticality operation 
deal real time scheduling important model actions pre emption level abstraction suitable measuring time intervals ensure pre emption execution respects atomicity actions 
level detailed fine structured difficult prove feasibility 
achieve persistent time bounds lj constrain cumulative execution time action execution program scheduler 
persistent lower bound action means action performed finished executed processor total time units necessarily continuously persistent upper bound means executed processor total time units completed 
tla programs properties specified logical formulas allows logical characterisation treatment refinement relation programs 
shall show approach untimed program fault assumptions timing assumptions scheduling policies specified separate tla formulas 
specification verification different properties easier write understand various kinds properties combined program specification kind property treated part separate theory 
established computational model logic significant advantages specially designed semantic model logic ss cri ch sg fault tolerance pbr lz fw schedulability 
effort needed understand model logic 
second existing methods specification refinement verification readily applied deal fault tolerance schedulability 
existing mechanical proof assistance model checking methods tools ces acd hnsy ad ah bcd 
outline follows 
section introduces computational model temporal logic actions program specification verification refinement 
section show physical faults specified fault tolerance achieved transforming non fault tolerant program fault tolerance verified refined 
section extends method section specification verification real time programs 
volatile time bounds actions characterised 
combine section techniques fault tolerance real time 
section show real time scheduling policies specified combined program specification verification schedulability program 
persistent time bounds introduced characterise pre emption actions 
section shows feasible schedule real time program refinement program fault tolerant feasible schedule real time program fault tolerant refinement program 
proof rules feasibility fault tolerant feasibility developed permit methods results scheduling theory formally verified 
notation model techniques illustrated simple processor memory interface program 
compare approach related section section 
program specification verification refinement section introduces transition system widely computational model temporal logic 
model serves semantic model tla shall specification verification 
shall demonstrate set computations transition system fully characterised normal form tla formula vice versa normal form tla formula fully defines equivalent class transition systems set computations 
fact justifies formal treatment refinement relation programs implication normal specification program refined refined program 
model provides interface tla mp hmp proof methods styles structural inductive rules developed effectively 
experience suggests computational model helpful understanding logic 
especially case real time system defining timing terms lower upper bounds action easier logical definition 
computational model program represented transition system action system tuple theta 
finite non empty set state variables 
state program mapping associated set values assigns variable value 
state subset variables denote values assigned subset 

initial condition theta assertion defines set initial states 

finite set atomic actions 
action semantically binary relation states program defines state possibly empty set successor states 
action enabled state 
transition relation states written infinite sequence oe oe oe states computation execution sequence run transition system theta iff satisfies requirements initiality oe satisfies theta 
oe oe stuttering step action oe oe diligent step 
case say step taken position oe 
computation starts initial state satisfying theta contains infinitely diligent steps terminates infinite stuttering suffix 
set computations program stuttering closed infinite state sequence oe computation program state sequence obtained oe adding deleting finite number stuttering steps 
stuttering closed property essential dealing deal refinement programs 
specification verification tla lam specification verification properties program atomic action logically defined action formula order boolean valued expression state variables primed versions specifies relation values variables execution action values primed variables execution action 
action interpreted pairs states hs iff holds models tla formulas infinite state sequences 
action formula tla formula satisfied sequence oe program denoted oe hoe oe order state predicate particular action formula primed variables oe satisfies initial state oe oe satisfies oe 
order state predicate action occurrence state variable replaced primed version 
formulas composed boolean connectives standard semantics 
quantification possible set logical rigid variables values fixed states set state flexible variables values change state state modal operators linear temporal logic mp constructing formulas 
dual operator oe satisfies suffixes oe satisfy eventually defined satisfied oe suffix oe satisfies 
primitives operators general requirement safety property lam lam liveness property concurrent system specified tla formula 
show set computations transition system fully specified tla formula 
introduce abbreviations 
action set state variables primed versions enabling condition defined order predicate en true state iff state hs step en delta quantification treated rigid variables 
action usually changes subset state variables leaving unchanged 
finite set variables define unchanged example atomic action form guarded command gamma 
gamma described action formula gamma unchanged gamma fxg enabling condition guard 
lam boldface quantify state variables 
examples omit unchanged part specification action assuming changes values variables primed versions referred action formula 
specify stuttering define abbreviation action finite set state variables delta unchanged asserting step step step change values state variables program theta np delta np state transition relation atomic actions exact specification expressed formula pi delta theta np satisfied computation oe iff oe computation alternatively finite non empty set state variables state predicate theta equal false action formula theta defines transition system execution initial state satisfies theta step transition step stuttering step 
exact specification defines possible sequences values may taken state variables including internal variables 
existential quantification hide internal variables canonical specification phi delta pi infinite state sequence oe satisfies phi iff infinite state sequence satisfies pi differs oe values assigned variables formulas pi phi safety properties satisfied infinite state sequence iff satisfied finite prefix sequence 
safety properties allow computations system performs correctly leaves values variables unchanged 
behaviours undesirable distributed systems ruled adding fairness properties 
simplicity shall consider safety properties liveness properties fault tolerant systems treated lj 
example processor simple system issues read write operations executed memory 
processor memory interface registers represented state variables op set processor chosen operation reset memory execution value space wg ready read write respectively 
val set processor value written write memory return result read value space set integers interface program internal variable denotes data memory 
delta fop val dg theta delta op wg initial condition delta op rdy op processor issues read delta op rdy op val processor issues write delta op op rdy val memory executes read delta op op rdy val memory executes write fr actions program theta program np state transition relation pi theta np exact specification phi theta np hiding internal variable actions processor combined single nondeterministic action rw delta op rdy op op val tla verification program property specified formula contain free internal variables proving validity implication phi 
relatively complete proof system lam additional rules logic reasoning programs 
valid tla formula provable axioms proof rules tla proof system valid action formulas provable 
temporal operators computational model mp rules methods provided verification 
refinement mapping relation programs theta theta characterises refinement program correctly implements phi theta np phi theta np canonical specifications respectively fx fy refinement relation formalised iff phi phi prove implication define state functions terms variables prove implication pi pi pi obtained pi substituting free occurrences pi collection state functions called refinement mapping 
substitutions applied sub formula pi 
concrete state function implements variable proof implication carried steps 
initiality preservation theta theta 
step simulation np np np disjunction actions step simulation proved showing np step state transition corresponds diligent step stuttering step validity implication phi phi imply existence refinement mapping general refinement mappings adding dummy auxiliary variables specifications 
refinement mapping verification refinement straightforward aided mechanical means 
finding refinement mapping may difficult known obtained hand knowing state variable implemented variables possible define mapping 
refinement supports step wise development small number state variables refined step 
fault tolerance physical fault occurring execution program theta cause transition valid state error state 
may lead failure state violates specification physical fault modelled atomic fault action 
example malicious fault may set variables arbitrary values crash processor may cause variables unavailable fault may cause loss message channel 
physical faults described set atomic actions interfere execution possibly changing values variables fault environment specified action formula disjunction action formulas executing theta system fault environment equivalent interleaving execution actions interference execution defined transformation delta theta exact canonical specifications computations executed system faults pi theta np phi theta np fault prone properties derived properties affected version computation affected computation example continued processor memory interface assume memory faulty value may corrupted 
fault represented atomic operation fault delta fault environment contain single action fault affected version theta fr fault np fault pi theta phi pi program tolerate set faults correcting actions carried prevent error state entered fault transition leading failure state occurrence violate program requirement specification 
example affected version refinement implies tolerate fault set faults program called tolerant implementation property requirement implementation phi means behaviours comply specification despite presence faults property canonical specification program phi theta np program tolerant refinement denoted tolerant implementation phi 
tolerant refinement relation stronger ordinary refinement relation tolerant refinement refinement general converse true 
tolerant refinement generally reflexive transitive ll ll fault tolerant refinements fault monotonic means program tolerates set faults tolerates subset faults realistic modelling usually requires addition fault actions behavioural fault assumption global properties maximum number memories corrupted time minimum time faults 
suggests exact specification affected computations general specified pi tolerant refinement proved condition pi pi equivalent pi pi indicates proof tolerant refinement established proving initiality preservation step simulation assumption behavioural fault assumption prevents certain fault transitions place states general safety property form 
equivalence formula np transformed equivalent formula fact constrain actions obtained np enhancing enabling conditions fault actions easily achieved linear time model tla 
discussion fault monotonicity branching time model see jj 
pi pi equals pi 
implies behavioural assumption encoded set fault actions standard steps proving refinement directly applied transformed specification pi 
methods proving fault tolerant refinement demonstrated example section 
separation fault actions behavioural assumptions simplifies specification affected computations program coding assumptions fault action proof easier 
example continued fault free memory processor memory interface implemented memories time suffers faults 
data memories memory subject fault 
variables value space indicate corrupted 
fault actions specified follows fault corrupts delta fault fault fault fault fault delta corrupted memory time define auxiliary function vote delta program tolerates faults vote function mask corrupted copy memory affected version specified follows delta fop val theta delta op wg initially contain value delta op rdy op delta op rdy op val delta op op rdy val vote return voted value delta op op rdy val write simultaneously overwrite corrupted copy fr actions theta program np state relation pi theta np exact specification phi pi canonical specification theta fault affected program np pi theta np phi pi prove refinement relation assumption define mapping states vote 
definition fault tolerant refinement need prove pi pi pi pi obtained substituting occurrences pi 
proof tolerant refinement initiality preservation theta theta holds trivially vote definition 
step simulation case equal respectively case right hand side op op rdy vote val case fault step changes values val op sufficient show fault step changes prove proofs similar 
assumption tla rule proving invariance property follows invariance property fault implies fault unchanged 
prove fault tolerant refinement follows 
ffl transform theta np pi delta theta np fault delta phi phi phi modulo 
ffl prove pi pi establishing initiality preservation step simulation 
timing section shows framework section untimed programs applied real time programs 
modelling real time programs common timing constraints program require actions executed early late processor memory interface example time synchronisation processor memory 
ensure value written overwritten read memory execute read operation slowly processor issue write command soon 
time represented non negative real numbers timing constraints execution action program specified assigning action volatile lower time bound volatile upper time bound value special value denotes absence upper bound 
real number assumed semantic interpretation action performed continuously enabled time units performed continuously enabled time units 
real time program represented triple hp untimed program defined previous section functions defining lower bound upper bound action example continued untimed processor memory interface processor memory synchronised timing guarding processor actions 
assume processor periodically issues operation 
ensure operation executed memory operation issued processor period ae issuing operation processor greater upper bound deadline memory execute operation 
real time program hp described follows methods results apply discrete time domains 
delta fop val cg add internal variable theta delta op fr wg op completed rw delta op issues read operation op val write operation delta op val similar original delta op val similar original delta actions program rw rw ae rw period memory actions lower bound ae memory actions upper bound hv theta real time program specification untimed programs shall need exact specification pi real time program distinguished state variable represent time action advance time assumptions ffl time starts initially 
ffl time decreases assumptions combined specify real time rt delta assume program state time change simultaneously program state changed program actions action conjunction pi rt specifies interleaving program actions advance time 
program actions constrained volatile lower bound upper bound conditions 
introduce auxiliary state variable volatile ffi timer action enabled state disabled taken assigned clock time ffi units time volatile ffi delta en ffi en en en ffi en en en step take place time reaches clock time mintime delta conjunction formula volatile ffi specify lower bound condition volatile ffi upper bound conjoined formula maxtime delta true en taken time en en timers set reset volatile bound condition action real time program hp action volatile timer volatile timer conjunction volatile mintime equals true specifies lower bound action step take place time units enabled step occur time units re enabled 
lower bound condition program conjunction lower bound conditions actions lb delta volatile mintime similarly upper bound condition program specified formula ub delta volatile maxtime volatile maxtime equals true eliminated conjunction 
lower upper bound conditions action illustrated 
time bound specification program conjunction lb ub 
real time executions program exactly specified pi delta pi rt hiding internal variables auxiliary timers denoted timer gives canonical specification phi delta timer pi example continued timed processor memory interface time bound conditions specified lb volatile rw rw ae mintime rw rw ub volatile rw rw ae maxtime rw volatile maxtime tr volatile maxtime tw pi theta rw rt lb ub phi rw rw tr tw pi computations real time program hp infinite state sequences variables plus global clock variables timers satisfy pi 
set state sequences empty initial condition satisfiable note non zeno property pi phi safety properties satisfied computation stuttering step 
particular allow called zeno computation finite number steps reaches state time remains bounded 
zeno computations ruled adding pi time diverges non zeno condition nz delta asserting time advance finite bound finite number actions performed finite interval time 
real time program non zeno finite prefix computations completed satisfy nz non zeno programs physically implementable schedulable 
checking nonzeno conditions studied eme 
shall consider non zeno programs take nz axiom 
verification refinement timed untimed properties programs specified way tla 
example bounded response property occurs execution occur ffi time units described ffi delta ffi prove real time program satisfies implements timing property prove implication property specification phi program 
example real time processor memory interface satisfies property op val asserts value memory output units time processor issues read operation 
implication phi op val proved proving pi op val refinement relation real time programs defined implication phi phi refinement mapping 
verify initiality preservation step simulation convert exact specification pi delta theta rt form theta equals plus timers theta obtained theta conjoining initial conditions timers 
action formula 
fault tolerance timing fault tolerant systems real time constraints 
important timing properties program refined functional fault tolerant properties defined program specification 
section extends transformational approach fault tolerance adding time bounds actions 
allow fault tolerant redundant actions specified time constraints 
functional properties faults modelled set atomic actions specified action formula time bounds actions equivalently lower upper bound fault action respectively 
real time program hp affected version defined delta hf domain extended action assigned time bounds 
achieve fault tolerance real time system timing assumption occurrence faults especially deadlines required met 
assumption usually constraint frequency occurrence faults minimum time faults occur 
period long recovery computation take place progress recovery fault 
formula non negative real number hold continuously units time delta fault modelled atomic action specified action formula 
timing assumption faults conjunction assumptions form fault occurs fault occur units time 
assumption denoted exact canonical specifications affected version respectively pi theta rt pi rt phi timer pi affected version real time program real time program 
normal form allows definition fault tolerance real time systems way untimed systems 
real time program tolerant implementation real time property implication phi holds 
tolerant refinement real time program implication phi phi holds 
example continued section showed untimed fault free processor memory interface implemented untimed version faulty memories values may corrupted set faults assumption show timed version refined timed version specification underlying untimed program changed slightly removing guard condition processor actions fop val theta op fr wg rw op op val op val vote op val np rw pi theta np phi pi meeting timing properties requires time bounds actions implementation guarantee period processor issue operation ae upper bound memory execute issued operation completion greater rw rw ae prove assumption consider case simply lowering upper bound raising lower bound action obviously refinement 
define refinement mapping states variables states internal variables including volatile timers follows delta vote delta rw delta rw rw delta rw tr delta tw delta tw implication pi pi proved way untimed faulttolerance section 
assumption relaxed timing assumption delta ae phi phi asserts written memories may corrupted read operation completely executed 
hp tolerant refinement fault assumption specifications demonstrate practical fact achieve fault tolerance timing constraints powerful faster machine needed 
execution multiple assignment machine slower execution single assignment machine non fault tolerant implementation execution multiple read operation voting function slower execution single read operation machine speed original time bounds slack accommodate redundant actions fault tolerance 
refine actions memories executed different processes voting action done process 
specification variables initial condition actions fop val op val theta op fr wg op op op op rw op op op op op op op op val op val op val vote val vote val val val vote theta newly introduced internal variables op contain operations issued process denote operations issued process completed synchronise read actions vote action vote done reads completed 
timing properties require time bounds actions implementation guarantee period processor issue operation ae upper bound wi th memory execute issued write greater sum upper bound ri th memory execute issued read operation upper bound vote vote action greater 
rw rw ae vote dw vote vote dw vote refinement fault tolerance proved showing validity implication phi phi refinement mapping dw vote delta delta val tr delta minft vote op tw delta minft important notice easier understand prove refinement refinement done step wise 
refine program replacing write operations setting 
refine program replacing read operations plus vote setting vote 
scale upper bounds new operations get feasible real time scheduling refinement model parallel execution program partition actions sets processes shared state variable actions different processes private state variable actions process 
actions executed parallel process share variables shared variables accessed mutual exclusion 
concurrent system processes communicate executing actions shared variables 
assume process concurrent program sequential atomic action process enabled time action process may non deterministic may carry state different states different executions 
real time program implemented system assigning processes set mg processors executing scheduler 
implementation correct iff meets functional requirements defined actions timing constraints defined time bound functions adding scheduling primitives programming specification language hoo program scheduler modelled specified single semantic model correctness proved separately 
application scheduler program set processors described transformation program schedulability program determined reasoning transformed scheduled program 
transformations separating program scheduler helps preserve independence program scheduling decisions 
programmer need take account system scheduler program ready implemented 
allows feasibility program different schedulers effect scheduler different programs investigated 
feasibility implementation program proved considering scheduling policy low level implementation details 
shall describe functional timing aspects scheduler determine affect execution program 
untimed scheduling assume scheduler allocates process execution processor submit action removes process processor retrieve action 
shall say process processor process allocated processor 
atomic action process executed process processor action enabled 
boolean variable run true process processor 
effect scheduling represented transformation atomic action process transformed strengthening enabling condition boolean variable run denote transformed action 
delta run en run en process executed processor actions enabled 
scheduler functionally described untimed program initial condition idle delta run guarantees process processor submit retrieve actions modify variables run generic description scheduler applied program system number processors 
program set processors left parameters replaced respectively concrete program definition specific system 
scheduling set processors described transformation 
initial condition scheduled program conjunction initial conditions idle theta 
actions formed union actions execution interleaved 
execution state sequence oe union state variables scheduler variables program 
initial state oe satisfies initial conditions theta idle 
step oe oe conditions holds oe oe oe produced oe action oe produced execution action process enabling condition predicate run true oe set executions specified pi idle theta assume change state 
gives compositional specification pi pi pi seen holds action pi pi 
pi implies pi 
shows refines transformation scheduler preserves functional properties timed scheduling timing properties executions depend number processors execution speed 
assume hard execution time needed atomic operation processor lies real interval execution processor starts time finishes time total execution time interval lies interval 
functions define persistent time bounds actions 
real time program delta hg ui 
guarantee implementation satisfies real time deadlines computational overhead submit retrieve actions bounded 
scheduler time bounds action real time scheduler real time scheduled program delta hi functions respectively union functions union words execution speed processors timing properties scheduler determine timing properties scheduled program 
actions scheduler interrupted time bounds actions volatile 
execution process action may pre empted priority pre emptive scheduler 
time bounds actions persistent general 
concurrent program pre empted action may disabled execution actions processes 
pre empted process resumed pre empted disabled action executed enabled action process selected execution 
reason persistent ffi timer action process defined follows persistent ffi delta ffi ffi taken en running en ffi disabled en run gamma pre empted informally 
persistent ffi timer initially set ffi 
stays ffi time units ahead long enabled en holds 
remains unchanged time enabled run en holds record execution time 
reset just step taken disabled 
changes rate enabled run en run holds time process waiting processor execution pre empted counted execution time 
conditions guarantee timer persistent pre empted pre empted intermediate state point pre emption observable actions 
conjunction defining formula persistent timer action maxtime persistent maxtime specification upper persistent time bound condition action asserts step state transition take place accumulated time enabled run reaches 
similarly lower persistent time bound condition action specified persistent mintime functions set set set set set set disjoint union function set set set equals elements set elements set notice pre emption execution program en run en ensured scheduler persistent timer formulas equivalent volatile timer 
ffi initially sets ffi keeps resetting ffi long en 
volatile ffi sets keeps unchanged en true sets ffi 

assume en run true say set ffi ffi 
ffi increases rate increases pre emption 
volatile ffi set kept unchanged run true set ffi persistent timers allow treatment pre emptive non pre emptive scheduling 
specification timing condition defined delta persistent mintime persistent maxtime exact specification timed scheduled program pi pi pi rt pi pi correctness timed scheduled program determined respect specification refer variables modified scheduler variables internal hidden canonical specification phi delta phi phi shall specification section consider ways applying transformational approach real time scheduling 
reasoning scheduled programs consider implementation real time program real time scheduler satisfies property 
proof implementation satisfies high level timing property free state variables external variables initial basis proofs detailed low level properties established 
assumption program scheduler change variables satisfies property phi implies satisfies represented proof rule phi phi phi treating effect scheduling transformation program specification allows specification scheduler policy prove timing properties implementation real time program 
feasibility definition verification timed scheduled program feasible phi phi refinement mapping implication proved pi pi notice correctness scheduler defined respect specification scheduling policy feasibility relates specification program scheduled specification scheduled program requires time bounds actions met 
assuming phi feasibility proved rule implication phi phi formula manipulated steps refinement mapping 
step introduce auxiliary dummy timers corresponding timers understood allowing scheduler copy timers hp define set auxiliary variables dummies delta fh ag respectively defined formulas volatile volatile 
dummies delta volatile volatile equivalent dummies phi dummies phi step define refinement mapping 
recall internal variables assumed refinement mapping states timer dummies states timer defined follows timer timer timer timer delta pi dummies 
proved proving pi step discard identical substitutions 
recall pi pi rt 
obviously rt rt pi pi 
pi implies pi turn implies pi 
rt pi discarded right hand side implication 
step discard actions timers 
volatile mintime volatile maxtime dummies maxtime mintime dummies appears left hand side remains proved implication holds action maxtime mintime proof rules feasibility implication suggests feasibility implementation real time program proved rule phi maxtime mintime phi phi notice maxtime mintime contain primed state variables 
rules proving invariant properties directly establish premises rule 
provide rules introducing invariants 
prove premise rule rule 
phi en maxtime symmetry premise rule phi run mintime converted normal form conjunction safety property liveness property theta sets variables theta state predicate action time divergence property 
formula denoted omega invariant omega proved rule theta initially holds step transition preserves omega feasibility fault tolerant real time programs occurrence fault action depend scheduler affected scheduled program scheduler modelled exact specification pi pi pi rt previous subsection redefined delta pi dummies set dummy variables dummies refinement mapping previous subsection implementation feasible implication holds pi equations rules previous section remain valid fault tolerant feasibility 
assume real time program hp tolerant refinement program set fault actions 
tolerant feasible implementation tolerant refinement assumes execution scheduler faulty tolerance provided program scheduled 
possible non fault tolerant program executed specially designed scheduler implementation faulty program fault tolerant lj 
scheduling open systems model programs far assumed real time program implements specification closed system values supplied program initial values variables executing nondeterministic input operation 
cases program linked external environment receives data send responses 
appearance inputs follows timing pattern example periodic aperiodic repetition 
open system pair consisting program interacts environment set variables union sets local variables set interface variables interact 
program consist initial predicate theta local variables set atomic actions program variables environment consist initial predicate theta environment variables set atomic actions variables action formula defines state transitions changes values interface variables 
required np ne define pi delta theta np phi delta pi pi delta theta ne phi delta pi specification phi open system defines condition system guarantees property phi environment satisfies assumption phi 
phi delta phi phi conjunction phi phi describes closed system consisting environment theta theta np ne program refines implements program environment iff phi phi phi phi reduces phi phi phi program environment treated real time programs hp respectively 
time global need advanced 
choose program advance time define phi delta timer pi real time open system specified phi delta phi phi real time property open system states program guarantees property environment assumption requires proving implication phi phi equivalently phi phi real time environment implementation real time program scheduler set processors described transformation delta defined section closed system denotes variables may changed scheduler 
feasibility implementation relies proving refinement relation implication phi phi equivalently proving phi phi phi easy see rules apply open systems 
canonical form open real time specification simpler sufficient purposes shall considering problem composing open systems 
example continued timed fault tolerance processor memory interface program rw environment action lower upper bounds period set ae 
partition remaining actions processes fr vote dw vote vote vote deadline memory actions real time interface program implemented memory processes implemented single processor non deterministic scheduler 
ignore details scheduler program assume randomly chooses enabled process 
overhead scheduling scheduler specified real time program hs delta theta delta idle delta true action enabled false sch delta idle phi phi run idle sch assume computation times actions processes satisfy condition vote minfd vote vote proved rules section implementation scheduler processor fault feasible 
intuitively processor actions ensure read write tasks arrive time 
write read operation issued write read tasks enabled processes 
scheduler selects process time execute executed total takes sum computation times tasks 
vote process ready processes ready 
proof sketch tolerant feasibility rule section requires prove predicates invariants implementation delta op delta op delta proofs invariants similar 
sketch proof 
general may possible prove invariant directly rule section 
rule prove stronger invariant implies prove invariant prove invariants conjunction invariant implies delta op run notice op run gamma informally invariant timers respectively set op changed false true overhead scheduling advance ready processes scheduled execution 
read operation issued scheduler chooses process execution invariant 
delta op run gamma gamma proof invariant uses invariant implication facts 
transition non op run state op run state transition op run state carried scheduling action 
scheduling action change timers 
formally action delta op run run implication gamma unchanged gamma gamma 
amount time op run remained true time gamma gamma spent execution added persistent 
action may falsify delta op op op run gamma ignore changes variables irrelevant clearly gamma gamma gamma gamma gamma gamma similar invariant scheduler chooses execution delta op run gamma gamma scheduler chooses execution delta op run gamma invariants consider cases processes completed issued read operation 
invariants cases completed operation 
completed operation invariant delta op op op run gamma gamma characterises fact time spent execution partial execution added proof invariant uses similarly completed operation invariant delta op op op run gamma gamma invariant delta op op op gamma characterises fact time spent execution added nondeterministic scheduler refined deterministic assigning priorities processes 
example process higher priority modify action sch scheduler sch process highest priority ready processes scheduled execution pre emption allowed sch delta idle run idle run idle run idle run run idle modified scheduler gives feasible tolerant implementation processor new action sch action implies old sch 
fixed priority scheduling pre emption techniques previous subsections produce results similar obtained scheduling theory 
demonstrate proving feasibility condition bw implementing set independent tasks fixed priority scheduling pre emption 
consider open system program consists independent processes tasks represented atomic actions environment represent actions releasing invoking activating tasks periodically 
general actions may clock events external events processes need respond 
ae period specification program specify system tla inv com integer variables representing number invocations completions task specification real time system theta delta inv com ff delta inv inv action task invocation delta inv com com com action task completion delta com com ff ff ae period invocation deadline task basic functional requirement system invocation task completed invocation phi phi inv com inv gamma rules proving invariant tla implication holds ae shown implementation program uniprocessor system feasible 
specification scheduling policy system implemented single processor pre emptive fixed priority scheduler assume scheduling overhead 
higher priority denote enabling condition task hr assert highest priority current enabled ready tasks delta inv com hr delta scheduler denoted hs specified follows sch delta idle hr run higher task runs run hr run run higher task pre lower task sch sch sch overhead specifications various scheduling policies 
time process running processor valid delta run run feasibility computation time task interval assume ae non negative integers worst case response time completion time task defined recursive equation jp 
shall equivalent recurrence relation defined bw 
th response time process gamma ae theta initially set lim scheduling theory shows implementation program scheduler processor feasible iff condition shown necessary finding execution task misses deadline condition hold 
prove formally condition sufficient need prove refinement 
theorem program scheduler processor provided implication section equivalent showing holds 
pi pi pi dummies pi dummies refinement mapping defined section 
proving discuss persistent timer predict completion time invocation task considering invocation 
special case consider time completion invocation task com inv 
assume tasks gamma higher priorities met deadlines far 
worst case tasks units computation time time spent executing higher priority processes comp delta gamma com theta gamma inv gamma com theta gamma gamma gamma gamma time spent far invocation comp gamma inv theta gamma gamma inv gamma com theta gamma assume ffi time spent comp ffi persistent time tasks higher priorities executed comp gamma ffi predicts cumulative time needed complete exceed gamma ffi time may divided smaller units sum invocation completed deadline exceed equal completion 
need prove left hand side lhs implication predicate invariant com inv com comp general time invocation completed gamma records time value time current invocation time remained unchanged completed 
definition longest possible time comp spent executing tasks priorities higher defined equation generalised comp delta gamma inv theta ae gamma gamma ae theta gamma gamma inv gamma com theta gamma leads lemma implies theorem 
lemma lhs invariants delta com inv comp gamma delta com inv comp gamma gamma gamma ae theta delta com inv comp delta inv gamma com inv proof lemma proof follows general routine proving invariants showing holds initially preserved allowed state transition program 
easy check invariants hold 
assume hold gamma 
prove hold take case invocation execution invocation 
proof general case similar 
special case lemma rewritten follows delta com inv comp delta com inv comp gamma dnow ae theta delta com inv comp delta inv gamma com inv comp gamma inv theta gamma gamma inv gamma com theta gamma initially holds analyze possible state transitions allowed lhs may change states variables occurring comp 
case gamma delta com inv inv case com comp gamma gamma easy prove lhs gamma gamma 
case gamma consider delta com com com induction assumption inv gamma com inv know equal com gamma inv theta gamma inv gamma com theta gamma holds 
case gamma define delta com com inv run gamma delta com inv gamma note inv gamma com iff com inv induction assumption com gamma gamma inv theta gamma inv gamma com theta gamma gamma gamma com gamma inv theta gamma gamma inv gamma com theta gamma holds 
case consider delta com run defined case taken account 
argument case leads com gamma inv theta gamma gamma inv gamma com theta gamma holds 
cases prove invariant proof follows facts theta ae iff inv inv gamma com dnow ae inv theta ae ae prove invariant note maxtime forces comp allowed transition assume comp inequation comp gamma dnow ae theta lemma gamma comp ae inequation gamma dr ae theta definition general cases proved way 
assumption cases guarantee deadline task met 
ensures holds 
notice proof gamma induction assumption 
proved lemma 
proof theorem follows rule section straightforward way lemma 
discussion example section deals independent periodic tasks fixed priorities 
method scheduling theory tasks extended deal communicating tasks 
example tasks may communicate asynchronously protected shared object pso bw 
tasks may periodic sporadic 
scheduler ceiling priorities worst response time task calculated recurrence relation gamma ae theta worst blocking time task lower priority ae minimum inter arrival time task period periodic 
feasibility analysis fault tolerant real time tasks bdp recurrence relation worst response time task extended deal fault tolerant tasks re execution affected task forward recovery recovery blocks checkpointing backward recovery 
case fault tolerance re execution response time task calculated recurrence relation gamma ae theta theta maxfc minimum time occurrences faults 
formal method scheduling analysis applied communicating fault tolerant tasks 
allows combine previous fault tolerance real time liu lj lj lj lj formally treat re execution forward recovery recovery blocks checkpointing backward recovery model provide means formally dealing real time program refinement fault tolerance schedulability single consistent framework 
related approaches formalising real time scheduling 
duration calculus zhou zz separately specified scheduler scheduled program 
duration calculus powerful verification tools proving program refinement 
lz describes case study scheduling oriented model real time systems called tam 
fw extends back action systems bac timing priorities uses notation specification refinement 
models appear complicated necessary 
example priorities scheduling defined simple state variables standard actions shown complex models structures needed 
timed ccs jj deals dynamic scheduling presence faults modelling resources schedulers processes 
serves model event process algebras tend different syntax traditional programming languages possible consider extensions persistent timers enable pre emption modelled 
earlier approaches volatile time bounds explicitly implicitly program verification scheduling analysis 
dealing pre emption interruption real time scheduling volatile time bounds requires scheduled action explicitly divided smaller actions steps execution pre emption occur 
atomicity original action preserved requires auxiliary internal variables 
feasibility implementation established reasoning step level program 
devices difficult reason formal methods results scheduling theory especially fact informal accumulated execution time tasks 
approach verification schedulability uses algorithms computing quantitative information implementation lower bound upper bound delay sets states ccm cc 
quantitative information determine feasibility implementation verify timing properties symbolic model checking techniques mcm 
significant differences described 
algorithms model checking procedures described ccm effectively discrete time domain finite state system contrast analysis time modelled reals systems may finite infinite set states 

framework allows program development refinement integrated scheduling theory methods results formal interpreted verified correctly 
ccm uses scheduling algorithm obtain implementation tests schedulability 
verification theorem scheduling theory valid program model compare section 
fact application theorem recurrence relation aircraft control system example ccm cc leads directly feasibility obtained 

compared ccm cc concentrates timing aspects deals wider range inter related issues concurrency timing fault tolerance schedulability refinement techniques fault tolerant real time programs 
general model checking techniques especially effective necessary safety critical applications 
general applicability restricted questions undecidability ad complexity issues ah especially systems continuous time domain 
problems serious fault tolerance real time considered 
model checking general verification methods complementary totally replaced 
recognize role model checking decision procedure proof checker applied possible 
formal development verification real time program requires logical structure functional timing properties program specified reasoned 
practical cases programs executed scheduler actions control program execution timing properties 
program executed failure prone system fault tolerance needed 
fault tolerance schedulability affect affect functionality timing program 
presents framework believe suitable coherent understanding relationship theories concurrency real time fault tolerance analysis formal systematic development safety timing critical computer systems 
scheduling theory provides powerful techniques determining timing properties restricted class real time programs provide means verifying functional properties 
methods augmented traditional program verification techniques different analytical framework making hard relate results rigorous way 
particularly important mechanised verification performed program properties certified necessary safety critical applications 
previous showed schedulability real time program established techniques similar 
important observation simplify verification useful reduce number actions specifying high level possible 
accurate verification timing properties necessary fine level granularity time bounds action deadline requires specifying actions low level possible pre emption precisely modelled timing properties related obtained scheduling theory 
address issue providing kinds timers volatile timers record times actions continuously enabled persistent timers sum duration actions executed 
persistent timers allows timing effects lower level actions pre emption considered abstractly higher level 
longer matters exactly action pre empted important time executed pre emption time preempted 
action may pre empted number times single timer record timing properties 
kinds timers solves problem cause major restriction application formal verification methods validation real time programs 
feasible automated verification programs specification level allowing timing properties considered details implementation 
naturally implementation complete scheduling analysis required validate provide independent certification timing properties 
method independent programming language 
program scheduler specifications refined feasibility correctness preserved step 
great advantage proving feasibility require code program developed 
advantages single consistent treatment fault tolerance timing schedulability 
allow unified view taken functional non functional properties programs simple transformational method combine properties possible uniform method verification 
verification schedulability proof framework inevitably cumbersome simple schedulability test scheduling theory 
common framework means formal verification test schedulability defined theorem verification done proof theory invoking oracle decision procedure uses scheduling theory rapid analysis 
wish tomasz gavin lowe anders ravn li comments suggestions earlier versions 
abr audsley burns richardson wellings 
applying new scheduling theory static priority pre emptive scheduling 
technical report department computer science university york 
acd alur courcoubetis dill 
model checking real time systems 
proceedings th ieee symposium logic computer science pages 
ieee computer society press 
ad alur dill 
automata modelling real time systems 
paterson editor icalp automata languages programming lecture notes computer science pages 
springer verlag 
ah alur henzinger 
real time logics complexity expressiveness 
proceedings th annual symposium logic computer science pages 
ieee computer society 
abadi lamport 
existence refinement mapping 
theoretical computer science 
abadi lamport 
old fashioned recipe real time 
de bakker huizing de rover rozenberg editors real time theory practice lecture notes computer science 
springer verlag netherlands 
alpern schneider 
defining liveness 
information processing letters 
avi avizienis 
fault tolerant systems 
ieee transactions software engineering december 
bac back 
calculus refinements program derivations 
acta informatica 
bcd burch clarke dill hwang mcmillan 
symbolic model checking states 
proceedings th ieee symposium logic computer science pages 
ieee computer society press 
bdp burns davis 
feasibility analysis fault tolerant real time tasks 
technical report department computer science university york 
bh bernstein harter 
proving real time properties programs temporal logic 
proc 
th annual symposium operating systems principles pages 
acm press 
bj rner manna sipma uribe 
deductive verification real time systems step 
rus editors proceedings transformation reactive systems development arts lecture notes computer science pages 
springer palma spain 
bw burns wellings 
advanced fixed priority scheduling 
joseph editor real time systems specification verification analysis pages 
prentice hall london 
cc campos clarke 
language representing time efficiently bdds 
rus editors proceedings transformation reactive systems development arts lecture notes computer science pages 
springer palma spain 
ccm campos clarke 
computing quantitative finite state real time systems 
proceedings ieee real time systems symposium 
ieee computer society press 
cdk clarke kurshan 
unified approach showing language containment equivalence various types automata 
arnold jones editors proceedings th trees algebra programming lecture notes computer science 
springer verlag copenhagen denmark 
ces clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm transactions programming languages systems 
ch 
parameterized semantics fault tolerant real time systems 
editor formal techniques real time fault tolerant systems pages 
kluwer academic publishers boston 
cm chandy misra 
parallel program design foundation 
addison wesley publishing new york 
cri cristian 
rigorous approach fault tolerant programming 
ieee transactions software engineering se 

de roever 
real time programming asynchronous message passing 
proc 
nd acm annual symposium principles distributed computing pages 
acm press 
engberg gr lamport 
mechanical verification concurrent systems tla 
proceedings th international conference computer aided verification lecture notes computer science 
springer verlag heidelberg new york 
eme emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume pages 
science publishers north holland 
esp ewald shasha pnueli 
temporal verification carrier sense local area network protocols 
proc 
th acm symposium principles programming languages pages 
acm press 
fs fix schneider 
reason programs exploiting environment 
technical report tr department computer science cornell university ithaca new york 
fw wellings 
action formal model concurrent real time systems 
formal aspects computing 
hmp henzinger manna pnueli 
temporal proof methodologies real time systems 
proceedings th acm annual symposium principles programming languages pages 
acm press 
hmp henzinger manna pnueli 
temporal proof methodologies timed transition systems 
information computation 
hnsy henzinger nicollin sifakis yovine 
model checking real time systems 
proceedings th annual symposium logic computer science 
ieee computer society 
hoo 
specification compositional verification real time systems lecture notes computer science 
springer verlag berlin 
jg joseph 
real real time systems 
proceedings ieee real time systems symposium pages huntsville alabama december 
ieee computer society press 
jj joseph 
dynamic scheduling presence faults specification verification 
jonsson parrow editors proceedings th international symposium formal techniques real time fault tolerant systems lecture notes computer science pages 
springer uppsala sweden 
jp joseph 
finding response times real time system 
computer journal 
kel keller 
formal verification parallel programs 
communication acm 
koy 
specifying message passing time critical systems temporal logic 
phd thesis eindhoven university technology 
lam lamport 
proving correctness multiprocess programs 
ieee transactions software engineering 
lam lamport 
temporal logic 
mason editor proceedings ifip th world congress pages amsterdam netherlands 
north holland 
lam lamport 
basic concepts 
paul editors distributed systems methods tools specification lecture notes computer science 
springer verlag berlin 
lam lamport 
temporal logic actions 
acm transactions programming languages systems 
liu liu 
fault tolerant transformations 
phd thesis department computer science university warwick 
lj liu joseph 
transformation programs fault tolerance 
formal aspects computing 
lj liu joseph 
specifying verifying recovery asynchronous communicating systems 
editor formal techniques real time fault tolerant systems pages 
kluwer academic publishers boston 
lj liu joseph 
stepwise development fault tolerant reactive systems 
langmaack 
de roever editors proceedings rd international symposium formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag germany september 
lj liu joseph 
verification fault tolerance real time 
proceedings th annual international symposium fault tolerant computing pages sendai japan 
ieee computer society 
lj liu joseph 
verification fault tolerance real time 
technical report department mathematics computer science university leicester 
lj liu joseph 
real time scheduling program refinement 
rus editors proceedings transformation reactive systems development arts lecture notes computer science pages 
springer palma spain 
liu joseph 
verification schedulability 
formal aspects computing 
ll liu layland 
scheduling multiprogramming hard real time environment 
journal acm 
lm lamport merz 
specifying verifying fault tolerant systems 

de roever editors proceedings rd international symposium formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag germany 
lsd lehoczky sha ding 
rate scheduling algorithms exact characterisation average case behaviour 
proceedings th ieee real time systems symposium pages 
ieee computer society press 
lsp lamport shostak marshall pease 
byzantine generals problems 
acm transactions programming languages systems 
lz lowe 
refinement complex systems case study 
technical report prg tr oxford university computing laboratory 
mcm mcmillan 
symbolic model checking approach state explosion problem 
phd thesis scs carnegie mellon university 
mj joseph 
cooperative recovery faults distributed programs 
mason editor proceedings ifip th world congress pages amsterdam netherlands 
north holland 
mp manna pnueli 
temporal framework concurrent programs 
boyer moore editors correctness problem computer science pages 
academic press 
mp manna pnueli 
temporal logic reactive concurrent systems specification 
springer verlag new york 
neu von neumann 
probabilistic logics synthesis reliable organisms unreliable components 
shannon editors automata studies pages princeton 
princeton university press 
pbr burns raymond 
formal specification proofs inheritance protocols real time scheduling 
software engineering journal 
ph pnueli harel 
applications temporal logic specification real time systems 
joseph editor formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag 
pnu pnueli 
temporal logic programs 
proceedings th annual symposium foundations computer science pages 
ieee computer society press 
pnu pnueli 
applications temporal logic specification verification reactive systems survey current trends 
de bakker 
de roever rozenberg editors current trends concurrency lecture notes computer science pages 
springer verlag 
ran randell 
system structure software fault tolerance 
ieee transactions software engineering se june 
rlt randell lee 
reliability issues computing systems design 
computing survey 
sg gerth 
compositional proof theory fault tolerant real time systems 
proceedings th symposium reliable distributed systems pages 
ieee computer society press 
ss schlichting schneider 
fail processors approach designing fault tolerant computing systems 
acm transactions computer systems 
zhou hoare ravn 
calculus durations 
information processing letters december 
zhou hansen ravn rischel 
duration specifications shared processors 
editor proceedings nd international symposium formal techniques real time fault tolerant systems lecture notes computer science 
springer verlag nijmegen netherlands january 
zz zhang zhou 
formal proof deadline driven scheduler 

de roever editors proceedings rd international symposium formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag 
