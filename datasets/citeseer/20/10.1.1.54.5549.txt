theory may testing asynchronous languages michele boreale rocco de nicola rosario pugliese dipartimento di scienze dell informazione universit di roma la sapienza dipartimento di sistemi informatica universit di firenze asynchronous communication mechanisms usually basis real distributed systems protocols 
systems asynchronous may testing exactly needed capture safety certain security properties 
study may testing equivalence focusing asynchronous versions ccs 
start operational testing preorder provide finitary fully trace models complete inequational axiomatizations 
results throw light differences synchronous asynchronous systems weaker testing power asynchronous observations 
distributed systems rely asynchronous communication primitives exchanging information 
properties systems conveniently expressed verified means behavioural equivalences 
particular may testing exactly needed reasoning safety properties respect assumption asynchrony play crucial role 
example consider trivial communication protocol users share private channel protocol requires uses send bit information receives messages channels send channel message received ordering inputs depends message received calculus formulate protocol follows meaning various operator usual particular stands creation local channel cb dy dy secrecy ability keep datum secret important property want check protocol externally possible guess message behaviour system property formalized requiring behaviour protocol depend bit sends words processes equivalent 
intended equivalence may semantics means external observer notice difference 
easy see observer tell apart synchronous communication traffic analysis 
equivalent truly asynchronous scenario ordering arrival outgoing messages guaranteed 
important full understanding may semantics asynchronous settings manageable reasoning techniques 
investigated impact testing framework proposed asynchronous variants ccs calculus 
particular observers independent characterization asynchronous testing preorders 
characterization starting point defining finitary trace model complete axiomatization may testing preorder 
main source complications arising operationally denotationally modelling asynchronous processes non blocking nature output primitives 
absence explicit structures buffering messages demands processes able take account messages sent environment time demanded processes receptive 
simple approach problem leads models possible inputs outputs environment stage explicitly described 
result infinitary descriptions obtained simple non recursive processes 
example operational description null process recx stands input action complementary output rec recursion operator :10.1.1.53.4500
similarly presents trace model permits arbitrary gaps traces take account external influence processes behaviour 
view considerations task providing finitary models asynchronous processes certainly interest 
provide fully trace model minimizing set traces process preorder traces 
intuition preorder trace leads successful interaction environment smaller leads success 
turns comparing processes minimal traces need taken account 
leads model assigns finite denotations finite processes 
interpretation may preorder suggested model follows consuming multisets messages output actions produce multisets messages building preorder traces provide complete equational axiomatization asynchronous ccs 
axiomatization relies laws specific asynchronous testing sound synchronous may preorder laws understood stating processes insensitive generation ordering messages environment execution depending availability consumption worse immediately re issued 
completeness proof relies existence canonical forms directly inspired finitary trace model 
develop model axiomatization asynchronous ccs asynchronous calculus 
simpler calculus sufficient isolate key issues asynchrony 
trace interpretation axiomatization calculus dictated ccs 
rest organized follows 
section introduces asynchronous ccs may testing preorder 
section fully trace interpretation processes complete proof system finite processes respectively 
section results previous sections extended calculus 
final section contains concluding remarks discussion related 
ar gamma 
ar gamma 
ar gamma 
gamma 
ffg ar gamma 
pnl gamma 
nl ar gamma 
gamma 
ar recx gamma 
recx gamma 
ar gamma 
gamma 
gamma 
operational semantics accs symmetric rule ar omitted asynchronous ccs section syntax operational testing semantics asynchronous ccs accs short 
differs standard ccs guarded choices output guards allowed 
absence output guards forces asynchrony possible define processes causally depend output actions 
syntax ranged infinite set names model input actions fa ng ranged set names model outputs 
disjoint bijection complementation function delta define set visible actions range 
distinct action set actions labels ranged 
shall range subsets ranged countable set process variables 
definition set accs terms generated grammar fi fi fi fi fi fi fi fi fi fi fi fi recx fi fi fi fi called relabelling function injective fl lg finite 
extend letting 
ranged denote set closed guarded terms processes terms occurrence agent variable lies scope recx operators 
sequel write 
usual write term obtained replacing occurrence possible renaming bound process variables 
write denote set visible actions occurring operational semantics labelled transition system gamma 
defined 
usual ffl denote reflexive transitive closure gamma 
resp 
gamma 
gamma 
resp 
gamma 
gamma 
ls write gamma 
gamma 
similarly 
call language generated set fs say process stable gamma 
ffl deletion la postponement ffl aa annihilation trace ordering laws may semantics ready instantiate general framework testing equivalences accs 
consider may preorder equivalence 
definition observers accs processes perform distinct success action 
computation process observer sequence transitions gamma 
gamma 
delta delta delta gamma 
delta delta delta infinite stable 
computation successful iff exists gamma 
definition process observer say may iff exists successful computation definition define preorder processes iff observer may implies denote equivalence obtained kernel preorder gamma 
universal quantification observers difficult operational definition may preorder calls alternative characterization 
synchronous case characterization simply trace inclusion see 
weaker condition required advantage preorder single traces 
definition preorder preserved trace composition satisfying laws 
intuition laws process interacts environment performing sequence actions interaction possible process performs put differently environment offers offers specifically law deletion says process inputs forced take place 
example bc abc environment offers sequence abc offers bc causal dependence bc output law postponement says observations process inputs delayed 
example bac abc 
environment offers abc offers bac 
law annihilation allows environment internally consume pairs complementary actions aab 
environment offers aab internally consume offer definition alternative preorder processes write iff exists theorem processes iff relying easily prove pre congruence 
finitary trace model fully set theoretic interpretation obtained interpreting set traces fs sg ordering interpretations set inclusion 
naive interpretation satisfactory includes infinitely traces finite processes instance fffl aa aaa bb informative set theoretic interpretation assign finite sets finite processes 
obtain interpretation shall minimize language process trace preorder 
sequel denote equivalence class set fs shall define partial order denotations 
definition denotations ffl consider set equivalence classes 
say denotation 
call set denotations 
ffl ordered setting iff words denotation set equivalence classes minimal lemma follows applying standard arguments particular anti symmetry property follows minimality 
lemma partial order 
definition interpret denotation def implies example ffl def 
fffl aa ab aab laws sufficient conclude ffl minimal ffl ffl def fffl ab abc ba bac bc bca set minimal traces ffl bc abc conclude ffl bc abc bca ffl def calculations find ffl abc implies lemma set equivalence classes 
minimal elements obvious ordering iff 
theorem full abstraction proof alternative characterization suppose show choose minimal set exists virtue lemma 
definition delta opposite implication proven similarly 
possible give concrete representation equivalence classes 
proposition delta delta delta trace resp trace containing inputs resp 
outputs 
suppose form delta delta delta mn permutation essence proposition allows treat equivalence classes traces sequences multisets input actions alternate sequences output actions 
model optimized 
example defining delta possible enrich theory commutativity law outputs ab ba permit view sequences outputs multisets leading smaller denotations processes 
instance denotation process example reduce ffl bc abc similar optimization definition canonical traces section 
proof system accs section define proof system finite accs prove sound complete respect finite processes 
rest section shall confine sub language recursion rec 
proof system call equational laws table plus usual inference rules reflexivity transitivity substitutivity context 
equation abbreviation pairs inequations write indicate derived proof system define ng gn laws 
convention empty summation denotes 
laws differentiate asynchronous synchronous may testing sound synchronous may preorder 
laws understood corresponding intuition consuming messages output actions environment produce messages produce 
particular law states processes insensitive arrival ordering messages environment law says execution depends availability message worse immediately re issued 
laws table sound synchronous may testing 
laws table easily proven sound relying preorder consider derived laws 
inequality derived noting implies apply 
particular 
consequence law get 
discuss completeness proof system 
shall rely existence certain canonical forms processes unique associativity commutativity summation parallel composition permutation consecutive input actions 
result independent interest leads unique compact representatives equivalence classes processes 
canonical form process obtained minimizing set traces trace preorder extends commutativity law output actions 
definition preorder traces induced laws plus law ab ba 
course included exp ffg ffg ffg nl ig nl nl pnl nl pnl na na na pna table laws accs definition canonical forms ffl act process defined induction follows ffl def def def 
ffl consider fin say complete minimal ffl canonical form process form fin complete minimal 
note complete set contain empty trace ffl 
prove uniqueness canonical forms 
proof decomposed simple lemmas needed completeness proof 
lemma 
proof proof goes induction length interesting case 
cases thesis follows law induction hypothesis oeae traces oe ae 
case get induction hypothesis oeae oeae applying commutativity parallel composition law get oeae thesis 
lemma def def canonical forms proof implies completeness obtain write ac derived laws 
proof lemma just note equivalent laws derive lemma ac 
theorem uniqueness canonical forms ac proof suppose 
prove result follow lemma symmetry 
suppose lemma deduce deduce existence minimality deduce example consider def 
get canonical form compute language obtain complete set fffl ab ba bb abb bab 
minimize finding minimal set fffl ag complete 
canonical form proceed proving completeness proof system 
result crucial prove existence canonical forms finite processes 
lemma absorption 
proof note laws easily derived proof system prove thesis induction number times laws derive proof relies laws commutativity parallel composition 
example analyze base case derived application 
means oeae traces oe ae 
note term obtained replacing single occurrence 
congruence law get oe ae oe ae existence canonical form guaranteed lemma exists canonical form proof induction laws tables easy show provably equivalent process set consider facts 


complete set 
suppose gamma fs complete 
fact consequence lemma fact consequence definition complete set part lemma plus idempotence summation 
applying fact saturate proving equivalent summation complete set applying fact get rid redundant traces proving equivalent summation complete minimal set traces 
theorem completeness proof lemma assume canonical form say def def 
sufficient show thesis follows law fact follows lemma absorption lemma 
calculus section discuss extensions theory asynchronous variant calculus 
syntax semantics countable set names ranged 
processes ranged syntax asynchronous calculus contains operators inaction output action guarded summation restriction parallel composition matching replication ab ff ff input action silent action free names bound names process written fn bn respectively arise expected names written fn bn 
usual shall consider processes ff equivalence 
means ff equivalent processes transitions bound names assumed clash free names 
omit definition operational semantics see remind labels transitions actions ranged forms interaction ab input ab output bound output 
functions bn delta fn delta delta extended actions expected particular bn bn 
definition may preorder calculus formally accs 
note usual preserved input prefix due presence matching see 
input action bn input action bn ab ab ac bg trace ordering laws trace preorder extend operational semantics calculus rule ab gamma 
fn gamma 
new kind action called bound input extend bn delta bound inputs letting bn fbg 
shall denote set visible non actions including bound inputs range 
trace say normal dot stands trace composition bn occur bn different bound name occurring functions bn delta fn delta extended normal traces expected 
consider normal traces ff equivalence 
set normal traces denoted ranged shall normal traces 
complementation function defined setting def ab def ab ab def ab def note presence bound names requires slightly different definition trace preorder 
definition binary relation containing pairs satisfy laws define reflexive transitive closure rules natural extensions asynchronous calculus rules accs 
extra attention paid bound names execution environment output declaring new name bound output postponed actions name 
example action postponed execution observer ab 
accordingly observed process input action receiving new name postponed action rule specific calculus linked impossibility observers fully discriminate free bound outputs 
informally rule states bound new name acceptable observer public name acceptable 
rule disappear extended language mismatch operator considered permits full discrimination free bound outputs 
definition calculus relies trace preorder remains formally unchanged accs usual proviso regarding freshness bound names 
prove coincide calculus 
results obtained accs trace model carry smoothly calculus 
proof system sound complete inequational proof system finite replication part language obtained translating proof system accs calculus adding new laws done 
new laws replaces substitutivity rule input prefix concerned matching related law 
fn pf xg qf xg exp ff ff ff resp 
ff bind free names resp 

ff ff ff ff eb ff ab ff ff ab ff ab pf cg ab ff ab ff ff ff ff ff bd bd pf cg ab ac pf cg table laws asynchronous calculus write inequality derivable system table 
soundness system straightforward 
completeness requires appropriate definition canonical form 
implies extending commutativity output actions 
definition preorder trace preorder induced laws plus laws ffl bn fn bn fn ffl cb ab definition canonical forms normal trace 
process defined duction follows ffl def def ab def ab ab def fresh def ab modulo new definitions definitions complete set minimal set canonical form remain formally definition 
lemma lemma extend calculus difficulty 
sketch 
lemma 
proof proof parallels lemma 
analyze case ab interesting 
depending actions action ab interleaved possible cases 
action ab fired 
oe ae oe ae 
oe ae oe ae 
oe oe ab ae oe oe ae case thesis follows induction hypothesis 
analyze case easier 
induction hypothesis oe oe ae def ab oe oe ae ab hand applying commutativity push ab rightward inside get oe oe ab ae oe push rightward getting thesis case 
lemma 
proof thesis proven induction number times laws derive example analyze base case derived application 
particular consider case oe ab ab ae oeae traces oe ae 
note fresh ab ax rule laws 
furthermore inequality proven substitution oe names fn fag context 
fact get oe ab ae oe ax ae oe ae proof uniqueness canonical forms remains formally unchanged 
existence provably equivalent canonical forms lemma requires extra ingredient derived laws fa bg bg 
accommodate matching initially proving equivalent summation proof proceeds formally unchanged 
mentioned lemmas actual proof completeness remains formally unchanged 
state theorem soundness completeness finite calculus processes related works studied may testing semantics asynchronous variants ccs calculus 
calculi proposed finitary trace interpretation processes complete inequational proof system 
various proposals models asynchronous processes 
main approaches followed purpose 
differ way non blocking output actions modelled 
actions rendered state transformers processes 
asynchronous variants acp csp lotos follow approach introduce explicit buffers correspondence output channels 
outputs non blocking immediately executable 
group place actors foundation 
asynchronous variants calculus ccs follow second approach model output prefix parallel composition past formalisms equipped observational semantics bisimulation failures denotational equational characterizations studied 
notable exception de boer palamidessi collaborators 
hand propose trace model variant failure semantics provide axiomatizations rely state operators explicitly model evolution buffers 
studies deal languages fall group asynchronous formalisms propose set laws help understand proposed semantics offer complete axiomatizations 
languages model outputs means processes creation presents axiomatization 
complete axiomatization strong bisimilarity asynchronous calculus proposed problem axiomatizing weak forgetful variants equivalence left open 
closely related 
variant asynchronous ccs authors complete axiomatization testing semantics appropriate reasoning liveness properties 
finitary model problem extending results asynchronous calculus left open 
amadio castellani sangiorgi 
bisimulations asynchronous calculus 
concur lncs pp springer 
abadi gordon calculus cryptographic protocols spi calculus 
proc 
th acm computer communication security acm press 
agha mason smith talcott 
foundation actor computation 
journal functional programming 
de boer klop palamidessi 
asynchronous communication process algebra 
lics ieee computer society press pp 

de boer kok palamidessi rutten 
failure failures paradigm asynchronous communication 
concur lncs pages springer 
boreale de nicola 
testing equivalence mobile systems 
information computation 
boreale de nicola pugliese 
asynchronous observations processes 
fossacs lncs springer 
boudol 
asynchrony calculus note 
rapport de recherche inria sophia antipolis 
busi gorrieri 
zavattaro 
process algebraic view linda coordination primitives 
technical report ublcs university bologna 
castellani 
testing theories asynchronous languages 
proc 
lncs appear dec 
de nicola hennessy 
testing equivalence processes 
theoretical computers science 
de nicola pugliese 
process algebra linda 
coordination lncs pp springer 
hansen 
bisimulations asynchronous mobile processes 
proc 
symposium language logic computation 
hennessy 
algebraic theory processes 
mit press 
honda tokoro :10.1.1.53.4500
object calculus asynchronous communication 
ecoop lncs pp springer 
jifeng hoare 
theory synchrony asynchrony 
proc 
ifip working conf 
programming concepts methods pp 
milner 
polyadic calculus tutorial 
technical report university edinburgh 
parrow sangiorgi 
algebraic theories name passing calculi 
information computation 
pugliese 
process calculus asynchronous communications 
th italian conference theoretical computer science de santis ed pp world scientific 
tretmans 
formal approach conformance testing 
ph thesis university twente 
