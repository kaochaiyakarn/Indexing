programming interface specification language jive specification design rationale peter muller jorg meyer arnd poetzsch heffter email peter mueller joerg meyer poetzsch hagen de fachbereich informatik hagen hagen report describes programming interface specification language java interactive verification environment jive 
jive system prototype implementation logic programming environment object oriented programming language 
logic programming environments language dependent software development tools support formal specification verification 
summarize properties ideal programming language prototype argue java candidate 
design supported java subset discussed formal definition syntax 
program specifications denoted interface specification language 
report discusses design jive interface specification language presents syntax 
example program illustrates application programming interface specification language 
contents programming language design concerns 
rationale selection java 
specification java subset 
lexical structure 
types values variables 
names 
packages 
classes 
interfaces 
arrays 
blocks statements 
expressions 
interface specification language design decisions 
specification technique 
specification primitives 
tpc formulas vs providing syntax 
choosing theorem prover 
specification 
names 
sorts 
sort checking 
formulas 
class interface specifications 
method specifications 
example keywords svenja keywords 
anja keywords 
definition predefined types methods predefined types 
predefined methods 
chapter java interactive verification environment jive logic programming environment developed research project hagen technische universit munchen stands logic programming environments constructed formal language specifications 
logic programming environments software development tools support formal specification verification programs 
aim generating programming environments formal specifications typical procedural object oriented programming languages 
phase project build prototype called jive subset java 
report gives rationale selection java defines subset jive 
furthermore interface specification language 
general approach approach specification verification builds possible known techniques 
specification technique tiered larch approach cf 
gh 
program specifications consist major parts program independent specification provides mathematical vocabulary definitions data types program dependent part relates implementation universal specifications 
interface specification class consists specification public method class invariant 
method specifications pre postconditions 
class invariants describe properties hold object class state object accessible outside 
verification hoare style programming logic cf 
hoa ph 
logic formalization axiomatic semantics underlying programming language 
correctness program showed translating specification hoare triples proving triples logic 
system architecture design decisions described report motivated tools prototype 
take quick look system architecture logic programming environment 
architecture jive consists major components program verification component pvc verification management component theorem prover component tpc 
www informatik hagen de pi forschung en html project sponsored deutsche forschungsgemeinschaft dfg 
specifications proofs split program dependent program independent parts 
general program dependent parts carried pvc 
pvc provides support editing programs interface specifications proving triples programming logic 
build pvc synthesizer generator tool generating language editing environments cf 
rt 
program independent proof obligations order formulas result certain rule applications programming logic proved tpc 
elaborated theorem provers proof checkers pvs cor isabelle pau purpose 
specification language tpc formalize program independent parts specifications see 
manages proofs program component keeps track remaining proof obligations 
particular decides program completely verified 
overview rest report structured follows chapter provides rationale selection java prototype defines language subset supported jive 
interface specifications called annotations denoted interface specification language 
interface specification language jive chapter 
chapter discusses programming interface specification language example program 
summary contained chapter 
chapter programming language chapter describe demands programming language prototype meet 
argue java choice starting point 
main part chapter defines subset java suitable purpose verification specifies syntax 
design concerns project aims generation logic programming environments procedural object oriented programs 
implies requirements programming language prototype 
programming language object oriented 
essentially reasons procedural languages subsets common object oriented languages 
programming environments object oriented languages general sense allow treatment procedural programming languages 
interesting problems specification verification caused object oriented language features subtyping inheritance dynamic binding 
object oriented languages provide encapsulation 
encapsulation eases verification guarantees absence certain side effects 

language prototype representative large class objectoriented procedural languages containing java eiffel sather oberon modula simula beta ada 
provide language features common object oriented languages class concept strong typing encapsulation subtyping dynamic binding inheritance exception handling 
furthermore features provided way typical language class 

enable stepwise extension prototype features programming language orthogonal 
allows start subset language enhance prototype adding language features progress project 

verification heavily relies elaborated module concept 
modules provide additional level encapsulation eases verification invariants cf 
mph notion module concepts supporting semantically private types 
language prototype provide module concept build 
subsection summarize reasons selection java 
compare java object oriented language criteria 
rationale selection java prototype jive uses java programming language 
java fulfills requirements described 
java modern object oriented language 

java provides important object oriented language features class concept strong typing encapsulation multiple subtyping dynamic binding single inheritance 
features supported way typical language class mentioned 

java language features orthogonal 
exception handling threads monitors package concept arrays omitted subset need semantical changes rest language 
subtyping inheritance closely connected classes inherit direct supertypes 
context regarded disadvantage connecting subtyping inheritance typical relevant language class features supported subset jive anyway 

java provides package concept enables encapsulation types kind friend mechanism classes package 
basis build elaborated module concepts 
requirements java advantages influenced decision 
java modern language 
java fever quite exaggerated causes positive effects project research projects world deal java 
particular nipkow von oheimb formally proved java subset type correct cf 

java commercial software development 
cooperations industrial partners 
immense interest students java eases sourcing parts project diploma theses 

java comes small class library system applied 
extensive evaluation done verifying larger class libraries java algorithm library cf 
proving correctness program components javabeans cf 
ham 

java allows development concurrent distributed programs providing threads monitors remote method invocation 
extending jive concurrent distributed programs possible switching programming language 
course java programming language suitable prototype 
discuss advantages disadvantages candidates 
sather eiffel provide interesting concepts inheritance genericity 
languages fulfill requirements section module concepts 
ruled eiffel sather approach inheritance unusual typical language class aim 
important disadvantages compared java pointer arithmetics enables violation data encapsulation 
weakly typed allows liberal casts 
complex cases unclear semantics 
correct programming logic hardly 
course drawbacks overcome defining appropriate subset language 
subset essentially look java 
ada regarded object oriented extension ada 
object oriented features added combining modifying generalizing constructs ada class concept realized combination types procedures packages 
consequence nearly impossible define small subset ada regarded core object oriented languages 
smalltalk programs purely structured due syntax statements 
complicates verification 
furthermore smalltalk untyped language 
type correctness programs prerequisite verification 
typing properties smalltalk programs proved separately causes additional effort 
beta chosen prototype unusual program structure 
beta generalizes classes methods universal pattern construct 
technique applied patterns results carry languages naturally 
sum practical important object oriented languages java favorite fulfills requirements section provides additional benefits pointed 
due limited time money project handle full java 
define subset java provides important features objectoriented languages regarded kernel language class 
definition subset subsection 
specification java subset java subset jive called svenja small verification enabled java 
java version cf 
gjs 
design concerns design svenja influenced goals 
svenja subset java sense svenja programs easily transformed semantically equivalent java programs 
features svenja semantics corresponding java features 
furthermore syntax svenja close java syntax possible 

svenja provide important object oriented language features class concept strong typing encapsulation subtyping dynamic binding inheritance 

svenja provide main features imperative programming languages recursion iteration basic data types 
svenja small possible goals focus central problems 

reasonable svenja close possible bali cf 

eases cooperation nipkow von oheimb 
notation syntax svenja synthesizer generator notation see 
form production declaration phylum operator name phylum phylum phylum operator name phylum phylum phylum 
operator name phylum phylum phylum context report phylum regarded terminal non terminal grammar 
left hand side phylum production non terminal 
line declaration defines possible right hand side left hand side phylum 
furthermore specifies name constructor called operator builds terms left hand side phylum terms right hand side 
svenja assume terminal symbols identifier defined scanner specification 
enable editing incomplete programs exists placeholder left hand side phylum 
placeholder consists operator parameters 
conventions right hand sides phylum grouped shown 
operator names prefixed op 
declaration starts placeholder production 
operators placeholders denoted op phylum name left hand side phylum 
possible non terminal symbols java lalr grammar cf 
gjs chap 
phylum names 
structure presentation syntax follows structure java language specification gjs 
non terminal names arrangement productions reasonable 
cases results grammar slightly complex developed completely new grammar 
sticking structure java grammar allows extending subset major changes existing parts 
subsections report correspond chapters gjs report correspond sections gjs reasonable 
furthermore adopt segment headings gjs 
lexical structure parts lexical structure programming language belong scanner specifications syntax 
scanner specification svenja 
similar java svenja uses keywords lexical structure literals identifiers 
contrast java svenja identifiers may contain character avoid ambiguities interface specification language see chapter 
identifiers structure identifiers described scanner specification 
production needed introduce terminal identifier syntax 
identifier identifier literals svenja provides kinds literals integer literals boolean literals null literal 
literals floats characters strings primitive types supported svenja see section 
literal types values variables svenja provides types restricted set primitive types int boolean 
type type class interface type 
contrast java svenja support array types 
simplifies data model language 
name ease mapping concrete syntax syntax grammar svenja syntax similar grammar concrete java syntax 
complicated productions avoid ambiguities pointed chapter gjs 
names java uses kinds names simple names qualified names 
qualified names cases denote package names address names packages address fields call static methods 
cases occur svenja packages provided see section 
cases avoided svenja changing syntax field access see sections method invocation see section 
svenja provides simple names 
name identifier productions reflect certain grammar problems described chapter gjs 
packages version jive support modular verification 
svenja provide packages 
design module concept supports modular verification semantical encapsulation current research topics see mph packages supported non terminal cf 
gjs chap 

phylum root grammar technically define transformation introduces predefined types svenja program see section 
synthesizer generator enforces list productions right recursive 
naming convention denote operator tuple production list list op 
transforming svenja files java files java packages important determine field method class accessible class 
java provides access modes public protected private default access 
private class members accessible inside class declared 
addition default access provides access classes package 
protected access allows default access plus access subclasses class public members accessed classes program 
particular access mode allows access inside class subclasses protected mode 
verification heavily relies data encapsulation 
svenja enforce encapsulation fields class 
fields accessible inside class subclasses 
unfortunately mode provided java 
possibilities circumvent absence packages 
classes svenja program considered part package 
public protected default access java equivalent 
particular fields private accessible subclasses completely public 
solution verification complicated 

separate package assumed class svenja program package imports packages program 
solution allows transform svenja program semantically equivalent java program 
ease verification chose way svenja 
protected access provides desired access mode fields 
classes section syntax class declarations declarations class members fields methods constructors static initializers 
modifiers receive lalr grammar modifiers covered separate production cf 
gjs chap 

java different access modifiers public protected private static final native synchronized transient volatile 
svenja provides protected fields methods public static native packages provide kind friend mechanism class members protected default access mode 
methods denote classes methods 
private supported keep number rules programming logic small 
furthermore simplifies context conditions inheritance 
final java state class subtypes 
important aspect modular verification added module concept 
threads supported svenja synchronized volatile omitted 
transient declares fields part persistent state object 
important objects saved persistent storage 
supported svenja 
predefined types svenja assumes existence predefined types classes object operator interface interface 
object root subtyping hierarchy 
operator provides methods unary binary operations see section 
interface default class implement interface see section 
definitions types appendix 
svenja provide packages import clauses types program particular predefined types 
perform type checking signatures fields methods predefined types accessible 
method implementations object operator expressed svenja syntax methods object java native methods operator require java code evaluate unary binary expressions see section 
cases java provides modifier native denote body method implemented language 
svenja native indicates body method replaced java method svenja program transformed java 
native may predefined methods 
modifiers modifier modifiers modifier class declaration svenja simplified version class declarations 
svenja support packages modifier permitted classes 
recall svenja program regarded set java packages containing exactly class 
requires class public 
improve readability modifier public omitted svenja programs 
inserted program transformed java program 
furthermore enforce class declaration extends clause extends object default 
simplify context conditions class implement exactly interface similar bali class implements interface cf 

class needs implement interface say new interface extending introduced implements assume empty default interface interface classes implement interface 
modifiers identifier super interfaces super interfaces field declarations svenja field declarations differ java field declarations aspects 
svenja field declaration declares exactly field 
multiple field declarations split separate declarations 

svenja provide arrays 

static fields supported keep number logical rules small 

fields svenja protected cf 
section 
final transient volatile fields supported see section 

variable initializers included svenja arrays static fields supported 
instance variables initialized usual methods see 
modifier type identifier method declarations declarations methods svenja slightly different java svenja support arrays exception handling productions simpler 
explained access modifiers public protected static native allowed 
static methods required create objects class svenja provide explicit constructors see section 
svenja requires method return result 
methods produce results return dummy value 
void type omitted 
bali method body svenja ends return statement see section 
result expression denoted explicitly syntax method bodies 
modifiers type identifier type block expression production differs syntax chapter gjs problems described chapter java language specification 
static initializers static initializers initialize static fields class 
static fields supported static initializers omitted 
constructor declarations java constructors create initialize new objects concrete classes 
invoked new expression 
simplify syntax logic svenja provide constructors new expression 
alternative ways object creation initialization 
object creation constructors concrete class predefined method newc creates new object 
method properties 
native 
svenja provide new expression object creation expressed svenja 

static 
possible create initial object 
perform initialization fields fixed body looks classes 
initialization done usual methods see 

protected 
due semantics class invariants see section states conjunction invariants living object program hold termination public method held execution cf 
mph details 
particular invariant new object hold newc method public 
general true newc declared public 
object creation outside class handled static methods see 
points lead definition creation method class protected static native newc 
confer appendix specification newc transformation java 
object initialization initialization objects done ways 
protected instance methods 
protected methods affected semantics class invariants see possible call protected methods uninitialized object 
solution allows emulate call super constructor java initialize inherited fields simply call protected initialization method superclass 

public static methods 
necessary allow creation initialization objects class outside subclasses 
public static method required 
avoid problems caused semantics invariants see object creation initialization performed single method 
done calling newc method initializing fields result shown example class protected protected static native newc public static newc return 
solutions allow create initialize objects way expressive flexible java 
usage constructors new expression circumvented svenja avoids treatment special constructor methods new expressions vitally simplifies programming logic 
interfaces svenja interfaces differ java interfaces aspects constant declarations supported svenja 
avoids ambiguities due multiple inheritance interfaces 
furthermore svenja provide variable initializers see section constants initialized 
svenja allow access modifiers interfaces method declarations modifiers discouraged java 
items implicitly public 
identifier arrays current version svenja provide arrays reasons 
arrays typical feature object oriented languages 
interesting aspect arrays context verification detection boundary violations 
obvious done certain logical rules array access 

described dealing arrays requires additional rules programming logic 

arrays require complex data model programming language additional types objects access functions incorporated 

arrays emulated predefined classes need predefined class primitive types types 
classes provide methods create dimensional arrays set get value specified index 
transformation multi dimensional dimensional arrays trivial 
omitting arrays allows focus central aspects object orientation 
blocks statements section syntax svenja statements 
normal abrupt completion statements java statements complete normally abruptly cf 
chapter gjs 
abrupt completion initiated statements break continue return throw including exceptions thrown virtual machine 
programming logic gets simpler programming language allow abrupt completion 
statements supported svenja see section treatment return statements 
abrupt completion statements svenja caused exceptions thrown virtual machine 
discern memory errors exceptions 
situations exceptions second kind occur detected verification cf 
ph 
exceptions thrown correct svenja programs 
memory errors detected verification framework require formalization system program running 
svenja provide means catch exceptions see section exceptions thrown virtual machine lead abnormal program termination 
handle situations programming logic refined partial correctness semantics statements programs abort due memory errors cf 
details 
memory errors affect notion partial correctness 
blocks blocks structure lists statements 
particular define scope local variables 
blocks lead complex binding analysis svenja provides blocks stay compatible java sense syntax svenja extended java larger modifications 
block statement local variable declaration statements local variable declarations svenja modified similar way field declarations see section variable may declared declaration statement variable initializers supported 
svenja local variable assumed initialized 
variables boolean integer types initialized false null respectively 
assumption simplifies data state model svenja guarantees absence non living objects 
svenja programs transformed java assumption cause problems java checks local variable initialized 
assumed initialization svenja overridden anyway 
type statements svenja supports small subset java statements reduce number logical rules 
particular secondary statements statements statements abrupt completion see section statements exception handling omitted 
syntax java statements quite complex 
due called dangling problem 
branch statements optional java branch bound statements certain situations cf 
section gjs example 
svenja requires statement branch statement syntax easier statements branch empty statement default 
svenja support expression statements java provides kinds expression statements assignment svenja supports simple assignment operator assignment operators just abbreviations binary expressions 
keep rule assignments simple multiple assignments allowed 
assignments treated expressions java evaluation expressions change values local variables parameters leads complex logical rules 
assignments treated statements svenja 
method invocation described svenja method returns result cf 
section 
necessary provide expression statement allows drop result method 
furthermore verification gets easier atomic expressions allowed see section 
method invocations occur part compound expressions 
consequence svenja treats method invocations statements requires method invocation form exp meth 
object creation described section object creation performed invocation predefined method 
class instance creation expression 
decrement expressions statements syntactical abbreviations omitted 
assignment method invocation statements introduced statements field read write operations 
operations treated method invocations field access statically bound java 
field access requires logical rules assignments separate statements 
casts allow narrow static type expression 
compound expressions supported svenja casts form exp treated statements 
furthermore logical rules assignment casts similar features treated statements 
assignments regarded special form cast statements cf 

considerations reflected productions statement block conditional statements java provides kinds conditional statements statements switch statements 
described svenja requires statement branch avoid dangling problem 
leads simple syntax 
expression statement statement switch statements provided svenja transformed semantically equivalent nested statements 
iteration statements syntax statement identical java 
expression statement statements statements transformed semantically equivalent statements 
statements provided svenja 
statements abrupt completion support abrupt completion statements see section java provides labeled statements break statements continue statements 
supported svenja 
return statement discussed section 
return statement avoid problem abrupt statement completion return statements permitted inside method bodies 
allow methods return result follow idea bali cf 

bali method exactly return statement method body 
modeled svenja syntax adding result expression method body see section 
explicit return statement 
field read statements java field denoted primary expression identifier super identifier 
field access statically bound syntax abbreviation casting superclasses accessing field superclass cf 
chapter gjs 
syntax supported svenja 
primary identifier field write statements arguments paragraph carry writing field access 
primary identifier expression method invocation statements described section method invocation statements consist method invocation expression left hand side expression result assigned 
identifier primary identifier identifier expression cast statements java cast expressions purposes convert value numeric type similar value numeric type confirm compile time type expression boolean check run time value refers object class compatible specified type cf 
gjs chap 

case needed svenja svenja provides numeric primitive type arrays 
case supported svenja compile time type expressions determined casts 
casts third kind truly needed svenja narrow static type expression 
consider example assume class list method list insert 
subclass list overrides method insert 
java svenja type rules require result type overridden overriding method identical cf 
chapters gjs 
result type insert class list method return objects 
overcome problem result method insert casted 
example shows casts third kind see indispensable svenja 
svenja syntax suffer ambiguity problems described chapter gjs parenthesized expressions provided svenja see section simplify production cast statements 
see section reason casts treated statements 
expression assignment statements reasons pointed section assignments treated statements svenja 
field access handled separate statements see sections assignments local variables parameters 
left hand side assignment statements field read method invocation cast statements local variable parameter 
expression name statements exception handling svenja support exception handling throw statement try statement omitted 
synchronized statement threads provided svenja 
synchronized statement supported 
expressions svenja provides restricted set expressions 
major reasons svenja provides atomic primary expressions 
eases verification simplifies design application logical rules 
restriction may inconvenient programmers java guarantees evaluation order expressions cf 
gjs chap 
java expression automatically split atomic expressions cf 
ph 
java expressions treated statements svenja assignment method invocation see section 
unary binary operations mapped method invocations see section 
primary expressions array creation expressions java provides kinds primary expressions literals expression parenthesized expressions class instance creation field access method invocation array access 
svenja supports literals expression 
class instance creation field access method invocation handled statements see section 
array access omitted arrays provided svenja 
absence non atomic expressions parenthesized expressions 
java names primary expressions 
due ambiguities casts array types parenthesized expressions 
cases occur svenja 
svenja simplified grammar names primary expressions 
primary literal name svenja expression syntax cope operator precedence parse ambiguities contains primary expressions 
expression simply primary expression 
expression primary expressions treated statements svenja class instance creation field access method invocation casts assignment handled statements expressions see section 
corresponding expressions omitted 
unary binary operators section describe handling operators unary minus plus negation multiplicative operators additive operators shift operators relational operators instanceof see equality operators bitwise logical operators conditional operators 
operators handled svenja method invocations 
assume class operator provides static methods perform operations parameters 
expression written svenja operator plus 
see appendix definition class operator 
technique major advantages expression syntax small 
specification assigned operator specifying corresponding method 
eases verification allows simple treatment errors occurring expression evaluation arithmetic overflow 
see ph details 
instanceof operator java treated described second argument type element syntax value passed method 
aspects behavior instanceof modeled defining public method class returns constant representing class name 
type object determined run time 
check object type subtype type instanceof replaced comparing constants consequently svenja provide instanceof expression statement 
remaining expressions array creation access expressions supported svenja provide arrays 
infix postfix decrement expressions abbreviations binary expressions omitted 
conditional operator seen abbreviation statement 

constant expressions expressions evaluated compile time 
switch statements needed svenja 
completes specification svenja 
example program chapter 
technique interfaces interfaces concrete methods 
versions svenja public static field 
chapter interface specification language chapter interface specification language jive called anja annotation language java 
section describes design decisions anja 
syntax anja embedding interface specifications svenja programs specified section 
design decisions design anja influenced major aspects objective verifying svenja programs usage theorem provers jive 
section discuss design decisions anja context 
specification technique want known specification techniques possible 
basically adopt tiered larch technique described chapter 
keep things simple important specification primitives pre postconditions class invariants see section 
verification requires interface specifications declarative 
ease usage hoare style programming logic verification mapping specification primitives hoare triples clear 
confer ph mph detailed description specification technique particular formal meaning specification primitives 
specification primitives jive interface specifications formalized specification primitives preand postconditions methods class invariants 
usually method specifications capture different aspects method behavior functional behavior side effects sharing properties 
enable structured method specifications anja allows denote multiple pre post pairs method 
improve readability common requirements preconditions method specified called requires clause 
furthermore requires clause necessary formalize meaning class invariants 
confer ph details topic 
summary interface specification class interface consists class invariant specification method class 
method specifications consists requires clause set pre post pairs 
comparison larch interface specification language similar larch interface specification languages interesting compare anja larch larch language cf 
lea 
specification primitives anja provided larch 
addition larch contains features supported anja cf 
lb 
larch uses called modifies clauses express objects changed values execution method 
similar clause lists objects destroyed method 
modifies clauses particular drawbacks fit naturally hoare logic 
hardly express sharing properties 
framework invariance properties expressed relating pre method cf 
mph details 

larch history constraints specify properties hold ordered pair visible states program execution 
history constraint specify value age field class person may decreased program execution 
properties expressed anja 
theoretical point view history constraints behave similar class invariants 
techniques applied history constraints 
want focus central aspects version jive 

larch allows specify redundant method specifications additional checking documentation 
anja method specification meaning transformed hoare triple proved 
need discern different kinds pre post pairs 
tpc formulas vs providing syntax recall chapter universal program independent parts specification formalized language theorem prover component tpc 
jive isabelle pvs tpc 
systems provide multi sorted higher order specification language strongly typed cf 
pau osr 
basically alternatives formulas anja denoted 
adopt syntax tpc language 
allows pass formulas tpc syntactical transformations 

special anja syntax 
requires formula declaration transformed syntax tpc 
user switch pvc tpc quite solutions require formula syntax looks similar tpc syntax 
solution follow convention larch denote types programming language types types tpc language called sorts 
allow exchange tpc system easier way syntax adapted anyway 
important difference alternatives treatment sort declarations 
choosing alternative requires provide sort declarations pvc transformed declarations tpc 
alternative allows move sort declarations tpc 
case pvc sort names knowledge sorts 
discuss pros cons solutions 
declaring sorts pvc allows full control sort information 
particular pvc controls order higher order formulas 
decision alternative 
declaring sorts pvc enables full sort checking inside pvc 
hand sort checking get quite complex subsorting 
alternative requires formula passed tpc parsed sort checked 

alternative easier implement sort declarations sort checking provided 
argument particular true elaborated higher order type systems subsorting shall supported 
long term full control sort system certainly desirable jive favorite alternative easier implement 
consequence prototype deal higher order formulas 
cause problems programming logic 
choosing theorem prover basically planning support pvs isabelle theorem prover components 
systems sophisticated proved power research projects practical applications 
context systems particular advantages type system bali proved correct isabelle cf 

build formalization bali soundness proof svenja programming logic 
pvs system pamela verification tool cf 
purpose similar 
particular pvs enhanced functions prove type check single formulas 
feature needed jive see section 
starting point jive uses pvs system group experience system 
decision allows adopt parts pamela system implement communication pvc tpc 
isabelle supported soon time implement interface 
specification section specifies syntax anja 
syntax syntax pvs specification language cf 
osr extension pvs 
version anja supports small subset pvs expressions provide specification syntax see section 
discuss particular restrictions definition supported features 
lexical structure keywords pvs language reserved anja 
ambiguities occur formulas passed pvs 
ease lexical analysis anja requires pvs keywords written upper case characters 
furthermore req pre post inv decl keywords anja see appendix list keywords special symbols 
anja identifiers identical svenja identifiers 
denote symbols unary binary operators assume terminal symbol 
keep syntax specification modular introduce separate productions anja features 
phylum depends syntax pvs language prefixed pvs 
identifier names pvs names identifiers operator symbols 
denote names different theories qualified name 
formal parameters theory instantiated providing list actual parameters square brackets 
sorts pvs specifications strongly typed 
anja provide means denote pvs sorts context quantified formulas 
keep syntax simple sort names 
pvs allows introduce names type expression subsorts function sorts enumeration sorts restrict expressiveness 
sort checking pointed section sort checking performed pvc 
formulas passed pvs parsed sort checked 
done follows assume formula occurs invariant part method specification 
may contain program variables free logical variables names pvs sorts functions variables anja access pvs theories decide pvc name denotes free variable item pvs theory 
pass formula pvs sort information provided 
transform closed form forall sort true 
variables pvc sort information program variables including current scope logical variables declared decl clause current type see section result denotes result current method denotes current object environment 
closed form sort checked pvs 
errors occur correctly sorted sort bool 
may ill sorted free logical variables declared 
errors passed back pvc displayed 
formulas anja supports restricted set pvs expressions 
particular provide tuple expressions record expressions set expressions coercion expressions expressions cases expressions 
omitted feature replace application appropriate function 
anja supports numbers names binary expressions unary expressions expressions function applications binding expressions 
furthermore result denote result method current object environment respectively 
result may occur postconditions methods see section 
result treated pvs name seperate expression valid pvs identifier 
unary binary operators provide flexible notation anja supports pvs operator symbols 
list operator symbols appendix expressions anja expressions consist boolean expression expressions sort branch branch 
elsif supported abbreviation nested expressions 
applications contrast pvs anja directly support higher order applications function determined name expression 
function applications consist name argument list 
binding expressions binding expressions denote quantified formulas 
anja provides universal existential quantification 
contrast pvs lambda abstraction supported 
higher order directly supported anja allow quantify operator symbols 
class interface specifications properties data representations specified invariants 
describe properties hold set classes invariants may classes interfaces 
term type denote classes classes interfaces 
ph invariant formula free variable ranging type invariant belongs invariant identifier formula 
enforced omitting declarations free logical variables invariant sort checked pvs see section 
free logical variables program variables occurring specifications declared provide sorts 
enforce logical variables name purpose type specification variables declared type level 
type declaration contains possibly empty list pvs variable declarations 
productions class interface declarations sections respectively modified incorporate invariant variable declarations 
modifiers identifier super interfaces identifier method specifications method specifications may occur kinds method declarations particular native methods 
described section method specifications consist possibly empty set pre post pairs requires clause 
requires clauses pre postconditions simply pvs formulas 
provide interface specifications syntax method declarations see section modified follows 
modifiers type completes specification anja 
example annotated svenja programs chapter 
chapter example chapter small example program demonstrate usage svenja anja 
program consists interface ilist class alist concrete class list 
ilist describes interface list data structure 
alist implements ilist provide implementations methods declared ilist 
methods alist defines method length returns length list 
class list inherits alist implements ilist providing implementations methods 
brevity omitted methods isempty rest types reveal interesting aspects 
data type types methods specified terms data type 
alist abstraction functions map objects ilist alist list values 
ab ai map boolean int values svenja corresponding pvs values 
pvs definition looks follows datatype empty isempty 
app int 

int rest 
length 
nat paragraphs discuss implementations specifications types mentioned 
place describe specification technique detail 
assume reader familiar ph mph 
interface ilist keep things simple assume function wf expresses wellformedness list representations list acyclic 
keeps invariant discussed types simple wf hold list representation 
variable declaration clause ilist introduces variables denote values types int respectively 
method specified requires clause pre post pair 
requires clause states abstraction implicit parameter current state denoted called empty 
condition met return value abstraction equals element interface ilist inv wf decl int ilist append int req true pre ai post result app int req isempty pre true post ai result class alist methods ilist inherited alist repeated 
implementation method length shows interesting aspects svenja code svenja capable deal subtyping rules java enforce result types corresponding methods super subtype identical languages method rest result type alist ilist 
achieved casts 
absence complex expressions leads longer readable code 
price ease verification 
class alist extends object implements ilist inv wf decl public int length req true pre post ai result length int res boolean isempty res ilist ir ir rest alist alist ir int length res operator plus return res class list list implements ilist singly linked lists 
length list stored explicitly field len 
empty list represented list object length 
brevity omitted method simply returns content field elem 
implementation list demonstrates object creation handled svenja 
static method empty calls implicit static method 
len field initialized new object represent empty list 
requires clauses preconditions defensive programming exception handling cases 
method requires clause asserts list non empty 
additional tests exceptions necessary 
method length overrides inherited method alist 
specification length shows pre post pairs express different aspects method behavior pair specifies functional behavior length return length list second pair states execution length produce side effects 
expressed stating object environments method pre equal 
class list extends alist implements ilist inv wf decl int protected int elem protected list protected int len public static list empty req true pre true post alist result empty list list len return public ilist append int req true pre alist ai post alist result app list res res list res elem res int ll ll len int sum sum operator plus ll res len sum return res public int length req true pre alist post ai result length pre post int len return summary example demonstrates svenja develop usual object oriented programs 
svenja programs easily transformed java tested java compiler 
inconvenience caused restricted expression syntax 
chapter describe idea overcome drawback 
anja provides full pvs expression syntax interface specifications formalized flexible convenient way 
sets pre post pairs allow structure method specifications 
chapter report defined programming language interface specification language jive system 
introduced svenja subset java programming language 
svenja provides typical object oriented language features class concept strong typing encapsulation subtyping dynamic binding inheritance 
interface specification language anja specification language pvs system 
provides means convenient flexible state art interface specifications 
formalization syntax languages generator notation 
example program demonstrated usage svenja anja 
shown languages allow implement specify realistic object oriented programs 
progress project refine extend improve aspects 
svenja anja extended aspects program development svenja convenient complex expressions secondary statements switch statements supported 
larger syntax verification complex jive provide syntactic levels 
user edits programs high level complex syntax 
verification high level program transformed semantically equivalent program features described report 
language convenient programming easy handle verification 
anja provide means specification sorts 
allow perform program verification component 
furthermore transformations implemented map anja specifications pvs isabelle theories 
medium term theorem provers supported 

svenja anja enhanced means compositional programming specification 
semantic module concept added svenja allow semantical encapsulation types cf 
mph discussion 
anja enriched features module specifications module invariants 
extensions allow compose verified program components deduce correctness resulting program correctness components 

svenja anja evaluated find certain language features missing detect possibilities simplification 
evaluation requires actions transformation svenja semantically equivalent java programs implemented enable compiling running svenja programs 
larger programs implemented svenja specified anja 
begun translate parts leda library cf 
nu svenja specify behavior anja 
evaluate specification technique outside world basic data structures applied user interface libraries java awt 
programming language interface specification language build strong basis prototype jive 
allow implement specify realistic object oriented programs 
improvements languages jive system convenient 
bibliography stepanov 
java algorithm library 

available reality sgi com java 
interface pamela pvs 
technical report universitat bremen 
available www informatik uni bremen de bb bb html cor crow owre rushby shankar srivas 
tutorial pvs april 
gh guttag horning 
larch languages tools formal specification 
springer verlag 
gjs gosling joy steele 
java language specification 
addisonwesley reading ma 
ham hamilton 
javabeans 
sun microsystems 
available java sun com beans docs spec html hoa hoare 
axiomatic basis computer programming 
communications acm 
lb leavens baker 
enhancing pre postcondition technique expressive specifications 
submitted 
lea leavens 
overview larch behavioral specifications modules 
kilov william harvey editors specification behavioral semantics object oriented information modeling chapter pages 
kluwer academic publishers boston 
mph muller poetzsch heffter 
developing provably correct programs object oriented components 
gary leavens murali sitaraman editors foundations component systems 
available www cs iastate edu leavens html mph muller poetzsch heffter 
formal specification techniques objectoriented programs 
jarke pohl editors informatik informatik als informatik 
springer verlag 
nu stefan christian uhrig 
leda user manual version 
technical report mpi max planck institut fur informatik june 
nipkow von oheimb 
java ight type safe definitely 
proc 
th acm symp 
principles programming languages 
acm press 
appear 
osr owre shankar rushby 
pvs specification language beta release 
technical report computer science laboratory sri international april 
pau lawrence paulson 
isabelle generic theorem prover 
number lncs 
springer verlag 
ph poetzsch heffter 
specification verification object oriented programs 
phd thesis technische universitat munchen 

poetzsch heffter muller 
logical foundations typed object oriented languages 
submitted 
rt reps teitelbaum 
synthesizer generator 
springer verlag 
appendix keywords chapter summarizes reserved keywords operator symbols svenja anja 
java pvs keywords operator symbols reserved jive reasons languages may extended full java full pvs changing list keywords 
transforming svenja programs java passing anja formulas pvs system require java pvs keywords identifiers svenja anja 
svenja keywords svenja keywords default private throw boolean implements protected throws break double import public transient byte instanceof return try case extends int short void catch final interface static volatile char long super class float native switch const new synchronized continue goto package svenja svenja operators anja keywords anja keywords consist pvs keywords reserved words denote interface specifications 
anja keywords decl inv post pre req anja special symbols pvs keywords containing false lemma subtype andthen conversion forall table array corollary formula library assuming datatype measure theorem assumption function nonempty type theory axiom elsif type true type iff obligation type implies var cases importing challenge endif orelse claim inductive postulate closure exists judgement proposition xor cond exporting lambda recursive conjecture fact law pvs special symbols 
pvs infix operators iff 
implies 
xor orelse andthen pvs unary operators 
appendix definition predefined types methods chapter presents definition predefined svenja types see section describes transformations java types 
omitted interface specifications predefined types change progress 
furthermore give definition object creation method predefined concrete class 
predefined types interface interface interface default 
interface interface transformation packages interface stays unchanged svenja program transformed java 
object class object root subtype hierarchy 
svenja requires class superclass allow object superclass 
allowed classes 
svenja object provides signatures methods java object 
threads dynamic class loading supported svenja omitted corresponding methods 
class object extends object implements interface public native int hashcode public native boolean equals object obj protected native object clone public native string tostring svenja programs transformed java object simply dropped 
operator svenja class operator provides static methods perform unary binary operations see section 
keep things simple shift operators bitwise operators omitted 
class operator extends object implements interface public static native int times int int public static native int div int int public static native int mod int int public static native int plus int int public static native int minus int int public static native boolean int int public static native boolean greater int int public static native boolean int int public static native boolean int int public static native boolean equal int int public static native boolean equal boolean boolean public static native boolean equal object object public static native boolean int int public static native boolean boolean boolean public static native boolean object object public static native boolean boolean boolean public static native boolean condor boolean boolean public static native int minus int public static native boolean boolean transformation svenja programs java operator replaced class declaration assigns implementations native methods svenja 
public class operator implements interface public static int times int int return public static int div int int return public static int mod int int return public static int plus int int return public static int minus int int return public static boolean int int return public static boolean greater int int return public static boolean int int return public static boolean int int return public static boolean equal int int return public static boolean equal boolean boolean return public static boolean equal object object return public static boolean int int return public static boolean boolean boolean return public static boolean object object return public static boolean boolean boolean return public static boolean condor boolean boolean return public static int minus int return public static boolean boolean return predefined methods described section concrete svenja class contains predefined method newc returns new object type method defined follows denotes object environment allocating new object type new yields new object type environment protected static native newc req true pre post result new translation java calls default constructor returns result protected static newc return new 
