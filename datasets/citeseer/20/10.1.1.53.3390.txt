kawa compiling dynamic languages java vm cygnus solutions terrace sunnyvale ca usa interested java portable bytecodes extensive libraries prefer different language especially scripting 
people implemented languages interpreter slow translating java source poor responsiveness eval 
kawa uses interpreter simple expressions non trivial expressions function definitions compiled java bytecodes emitted memory byte array 
saved quickly loaded java classloader 
kawa intended framework supports multiple source languages 
currently supports scheme lexically scoped language lisp family 
kawa dialect scheme implements current scheme standard rs number extensions written efficient objectoriented style 
includes full numeric tower complex numbers exact infinite precision rational arithmetic units 
number extensions provide access java primitives java methods provide convenient access scheme 
java objects scheme values vice versa powerful hybrid java scheme environment 
implementation standardized core javascript construction 
languages including emacs lisp considered 
kawa home page www cygnus com kawa html 

java decent programming language reason java explosion largely due java virtual machine jvm allows programs distributed easily efficiently form portable bytecodes run wide variety architectures web browsers 
advantages largely independent java language number efforts run languages jvm jvm clearly designed optimized java 
especially interested high level dynamic scripting languages project conjunction java 
language implemented top java gives programmers extra linguistic benefits java including libraries portable bytecodes web applets existing efforts improve java implementations tools 
kawa toolkit supports compiling running various languages java virtual machine 
currently scheme fully supported difficult features discussed 
implementation coming time writing usable 
scheme rs simple powerful language 
non pure functional language class functions lexical scoping non lazy evaluation side effects 
dynamic typing usually interactive read evaluate print interface 
dynamic nature scheme run time typing immediate expression evaluation may better match dynamic java environment interpreted bytecodes dynamic loading java name dialect javascript defined ecma standard javascript core language input output browser document interface 
defines dynamic object language prototype inheritance classes 
number new proposed web standards 
information source code available www cygnus com kawa html 
note kawa name unrelated commercial java development environment 

history starting cygnus behalf free software foundation developed implementation scheme suitable general embedding extension language 
jaffar scm interpreter various enhancements initially done tom lord 
got major contract enhance client added features including threads primarily done anthony green 
contract called byte code compiler looked doing job major project 
option considered compiling scheme java bytecodes executing java engine 
disadvantage scheme system exist hand run various technical problems led conclude strategic cygnus 
advantage java solution leveraging tools development done java space plus java strategic long term 
customer agreed java started active development june 
base kawa scheme interpreter written alexander 
needed object oriented scheme interpreter implement dsssl dsssl scheme environment expressing style formatting processing sgml sgml documents 
dsssl subset pure scheme extensions 
kawa simple interpreter far complete 
provided useful starting point original code re written 
kawa released customer net september 
development continued intense pace 
long term goal object oriented environment integrates scheme java languages 

basic implementation strategy basic ways implement programming language java write interpreter java 
parse source internal syntax tree evaluate recursive eval function 
advantage java having garbage collection classes standard java class library easier 
obvious side interpreter solution speed 
interpreter language written java turn interpreted java vm get double interpretation overhead 
write compiler translate language java source code 
need define mapping language constructs equivalent java constructs write program writes parsed program corresponding java constructs 
number implementations take approach including various extended java dialects 
gives single single java vm layer interpretation 
hand efforts people making improving java performance benefit implementation standard java bytecodes 
biggest problem approach inherently batch process poor responsiveness 
consider read eval print loop ability user type expression immediately read evaluated result printed 
evaluating expression requires converting java program writing disk file invoking separate java compiler loading resulting class file running environment response time inherently poor 
hurts exploratory programing ability define update functions fly 
lesser disadvantage java source code quite expressive java bytecodes 
bytecodes close java source useful features available java language goto 
debugging information issue 
alternatively directly generate java bytecode 
write class file saved 
option writing internal byte array immediately loaded class java lang classloader method 
case pass file system entirely yield fast load go solution enables responsive read eval print loop 
solution best worlds 
main problem code needs written 
fortunately kawa done 
discuss compiler give overview run time environment kawa classes implement scheme values 

objects values java primitive types bit int types 
variable type means contains essentially pointers objects class contain objects classes extend inherit named class 
inheritance graph rooted smalltalk means classes inherit distinguished class java lang object just object short 
standard scheme rs fixed set types way creating new types 
run time typing means types declared variable contain values different types different times 
natural type java variable contain scheme value object scheme values implemented class inherits object 
task map scheme type java class 
standard java class write tradeoff 
standard java classes simplifies passing values scheme functions existing java methods 
hand java suitable built classes usually lack functionality needed scheme organized kind class hierarchy smalltalk dylan 
java lacks standard classes corresponding pairs symbols procedures write new classes write new classes existing classes lack functionality 
scheme boolean type standard java type case boolean strictly speaking java lang boolean 
scheme constants mapped static fields constants boolean false boolean true 
hand numbers collections reasonably organized class hierarchies java 
kawa classes discussed sections 

collections kawa rudimentary hierarchy collection classes 
class sequence public int length public object elementat int sequence class includes lists vectors strings 
class extends sequence char value implement fixed length mutable strings array unicode character 
represent scheme strings 
class extends sequence object value implement fixed length mutable general onedimensional array object 
represent scheme vectors 
public class list extends protected list static public list empty new list represent scheme linked lists 
empty list static global value list empty 
nonempty lists implemented pair objects 
public class pair extends sequence public object car public object cdr scheme pairs 
public class extends pair pair includes filename file pair read 
plans include interesting collection classes sequences implemented disk file lazily evaluated sequences hash tables apl style multi dimensional arrays buffers 
ideas implemented earlier experimental language see ftp ftp cygnus com pub 
integrate kawa collections new jdk collections framework 

top level environments class environment environment mapping symbols bindings 
contains bindings user top level 
multiple top level environments environment defined extension existing environment 
feature implement various standard environment arguments passed eval adopted latest scheme standard revision rs 
nested environments implemented support threads fluid bindings presence threads 
environments combined general name table interface include records objects 

symbols symbols represent identifiers need functionality 
scheme needs able convert scheme strings need means global table ensure unique symbol identifier 
symbols immutable accessible internal structure 
scheme symbols java strings 
note java string class implements immutable strings implement scheme strings 
sense implement symbols way scheme symbols similar java strings 
method intern string provides version string provides characters string mapping needed scheme strings 

numbers scheme defines numerical tower numerical types number complex real rational integer 
kawa implements full tower scheme number types sub classes class quantity discussed 
public class complex extends quantity public re public im complex class complex numbers 
subclasses class real numbers general class components arbitrary fields optimized components represented double fields 
public class extends complex public final re return public final im return zero public boolean public class extends double value concrete class double precision bit floatingpoint real numbers 
public class extends public numerator public denominator class exact rational numbers sub classes 
public class extends num den class implements fractions obvious way 
exact real identified fractions 
public class extends int int words concrete class implements integers 
value stored elements words complement form low order bits word 
packages including sun added jdk 
advantages 
complete set operations including gcd lcm logical bit shift operations power repeated squaring division modes common lisp floor ceiling truncate round exact conversion double 
consistency integration complete numerical tower 
specifically consistency integration see 
packages signed magnitude representation kawa uses complement 
easier integration cheap implement logical bit operations 
bits big digit word expected space efficient representation 
importantly compatible mpn routines gnu multi precision library gmp gmp 
mpn routines low level algorithms unsigned pre allocated transcribed java mpn class 
better efficiency desired straight forward replace mpn methods native ones call mpn functions 
integer value fits signed bit int stored words null 
avoids need extra memory allocation words array allows special case common case 
optimization integers range pre allocated 

mixed type arithmetic operations overloaded different definitions depending argument types 
classic examples functions arithmetic needs different algorithms depending argument types 
fixed reasonably small set number types case standard scheme just enumerate possibility 
kawa system meant extensible support adding new number types 
solution straight forward case function negate method overriding virtual method calls dynamically select correct method 
difficult case binary method classic object oriented languages including java support dynamic method selection type argument 
common lisp scheme dialects support dynamic method selection arguments fact problem binary arithmetic operations probably obvious example multi dispatch useful 
java multi dispatch solve problem ways 
smalltalk problems solved coercive generality number class generality number operands lower generality converted class higher generality 
inefficient conversions temporary objects see budd arith limited extent add new kinds number types 
double dispatch ingalls expression implemented sub 
assuming run time class tx ty causes sub method defined tx invoked just 
invokes method defined ty testing subtraction types tx ty 
problem approach difficult add new tz class add methods existing number classes mention operations 
kawa implemented sub 
sub method tx checks ty types knows handle 
subtraction returns result 
tx sub 
invokes ty defined super class ty 
ty super classes gets chance see knows subtract tx object 
advantage scheme flexibility 
knowledge handle binary operation types tx ty tx ty super classes 
easier add new classes having modify existing ones 

quantities dsssl language dsssl dialect scheme process sgml documents 
dsssl quantities addition real integer numbers 
dsssl format documents provides length values multiple meter derived units cm pt point 
dsssl quantity product dimension number integral power length unit meter 
pure number quantity length power zero 
kawa wanted merge scheme number types dsssl number types generalize dsssl quantities support dimensions mass time units kg seconds quantities implemented class quantity 
quantity product unit pure number 
number arbitrary complex number 
public class quantity extends number public unit unit return unit empty public complex number public class extends quantity complex num unit public complex number return num public unit unit return concrete class implements general quantities 
usually don need generality 
public class extends quantity double factor unit public final unit unit return public final complex number return new factor public class unit extends quantity string name optional 
dimensions dims double factor unit product floating point factor primitive units combined dimensions object 
unit name name kg printing parsing literals 
public class extends unit int index primitive unit defined terms unit example meter 
different index identification comparison purposes 
index 
public class dimensions bases short powers dimensions object product ratio 
think data structure maps integer power 
bases array list nonzero power order index 
powers array gives power exponent index bases array 
dimensions objects equal list bases powers 
dimensions objects global hash table equal object 
easy implement addition subtraction public static add unit dims unit dims throw new units mis match double unit factor unit factor double factor factor return new unit unit result addition subtraction unit operand 
easy convert units cm cm kawa represents quantities relative userspecified units representing relative primitive base units automatically print quantities user preferred units 
multiplication division difficult 
actual calculation finding right dimensions multiplying constant factors straight forward 
problem generating new compound unit printing result human friendly format 
obvious right way 
kawa creates represent compound unit obvious simplifications done 
kawa uses heuristics simplify compound units area improved 

procedures scheme procedures class values 
java 
simulate procedure values overriding virtual methods 
class procedure public object object args public object apply public object apply object arg object arg represent scheme procedures sub classes class procedure 
call apply procedure arguments invoke apply method invoke procedure passing single argument apply method apply arguments 
alternatively bundle arguments array method 
arguments 
notice procedure sub classes implement methods extent throwing exception passed wrong number arguments 
utility classes procedure procedure class procedure extends procedure public object object args args length throw new return apply args public object apply throw new public object apply object arg public object apply object arg object arg throw new primitive procedures generally written java subclasses helper classes 
example class car extends procedure return element list 
public object apply object arg return pair arg car user defined scheme procedure compiled class descended procedure 
example variable argument procedure implemented subclass method comprising bytecode compiled scheme procedure body 
primitive user defined procedure calling convention 
nested procedure lexical variable outer procedure inner procedure implemented closure 
kawa implements closure procedure object static link field points inherited environment 
case lexical variable heap allocated lexical variables local java variable slots 
conceptually similar inner classes added jdk class extends procedure public object apply return run environment current public object run environment env top level forms including top level definitions treated nested inside dummy procedure 
dummy procedure 
file loaded result invoking run causes top level actions executed 

overview compilation stages compilation reading compilation stage reads input file string interactive command interpreter 
result scheme forms expressions usually lists 
reading commands interactively single form read reading file string forms read file string case result treated body dummy function 
semantic analysis source form rewritten expression object specifically 
stage handles macro expansion lexical name binding 
optimizations done phase annotating re arranging expressions 
code generation resulting compiled byte coded classes 
done invoking virtual compile method recursively expressions generates instructions bytecode package evaluate expression leave result java operand stack 
ask bytecode package write resulting classes methods 
written file byte arrays memory 
loading compiled bytecodes loaded kawa run time 
case code compiled immediately executed compiled code immediately turned java classes java classloader feature 
print loop works 
instance compiled sub class created run normally produces various side effects 

expressions expression class represents partially processed expressions 
principle independent source language scheme assumptions wired 
class expression public object eval environment public void compile compilation comp target targ eval method evaluates expression environment 
compile method called compiling body procedure 
responsible generating bytecodes evaluate expression leave result result specified target parameter 
usually java evaluation stack go detail 
class extends expression object value public object val value val public object eval environment env return value public void compile compilation comp target target comp value target represents literal self evaluating form quoted form 
class extends expression symbol symbol declaration binding named variable 
symbol source form identifier 
binding non null lexical binding identifier 
class extends expression expression func expression args application procedure func argument list args 
class extends expression outer surrounding scope 
public declaration add decl symbol name create new local variable 
class represents lexical scoping construct 
concrete sub classes binding form lambdaexp 
class lambdaexp extends symbol name optional 
expression body int min args int max args scheme primitive syntax lambda translated lambdaexp represents anonymous procedures 
lambdaexp compiled different class 
invoking eval causes lambdaexp compiled class class loaded instance class created result coerced procedure 
sub classes expression conditional expressions compound expressions assignments syntax error 
semantic analysis translation phase takes top level form body generates top level expression 
done translator keeps track lexical bindings translation state 
class translator public expression rewrite object exp 
public expression string message 
rewrite method converts scheme source form expression 
method called syntax error seen 
prints current source filename line number message 

syntax macros class syntax public expression rewrite object obj translator tr rewrite method translator checks syntactic keywords macros 
car call syntax symbol bound syntax rewrite method called 
example trivial class implements quote class quote extends syntax public expression rewrite object obj translator tr error checking left 
return new pair obj car complicated syntax implements define syntax 
class define syntax extends syntax public expression rewrite object obj translator tr enter new result object contains encoded representation patterns templates syntax rules 
right syntax object 
class extends syntax rules public expression rewrite object obj translator tr object new object int rules match obj return execute template tr return tr matching syntax rule contrast evaluating procedure definition lambda causes new sub class procedure created compiled evaluating define syntax causes new instance created 

interpretation eval people think scheme lisp interpreted languages 
languages compilers 
languages eval command run time takes source program evaluates 
may interactive read eval print interface 
uses traditional interpreter easiest responsive 
high lisp systems traditionally provide compiler interpreter 
duplication expensive terms size development effort testing 
load go capabilities efficiently load compiled program running application simply implement eval compile followed load 
compile java bytecodes create files class format 
standard java method java lang classloader takes byte array laid format class dynamically creates new class existing java run time 
facility applets downloaded network 
kawa uses scheme implement eval works 
classloader takes array file compile load entirely inside kawa run time having go filesystem temporary files traditional compiler batch 
result near instant response 
tradeoff 
doing compile load heavy duty operation compared simply interpreting expression 
creates lot temporary objects 
worse creates temporary classes java environments garbage collect unused classes 
kawa uses compromise strategy 
expression simple interpreted directly expression eval 
compiled 
simple expressions include literals global variable access assignment function application 
implementing eval cases trivial 
expressions define new local bindings lambda expressions forms implement eval 
user types expression wrapped inside dummy function compiled bytecodes immediately executed 
avoid dealing lexical binding evaluator 
represents top level form class extends lambdaexp public object eval module environment env body simple optimization return body eval env object eval env return run env sub class lambdaexp dummy function created wrapping toplevel forms implicit lambda 
eval module method evaluates top level forms 
body simple invokes eval lambdaexp invokes compiler 
result eval run 

code generation compilation object manages classes methods temporary state generated result compiling single top level 
class compilation classes boolean immediate public lambdaexp lexp string name 
public exp 
exp compilation may create objects generates bytecodes class 
generated lambdaexp including top 
boolean immediate true compiling immediate loading false target class files 
method compile lambdaexp 
creates adds compilation classes array generates method objects constructor main method 
method created emits bytecodes set incoming parameters invokes virtual compile method body lambdaexp generates code actual procedure 
compilation constructor gets passes 
compile method lambdaexp gets called lambdas dummy top level calls generate class corresponding lambda emits instructions create new instance generated procedure class pushes java stack 

targets operations java vm leave result vm stack available succeeding operations 
obvious general way compile expression generate bytecode instructions leave result form object stack 
handles cases quite better 
specify target parameter invoking compile method target specifies leave result 
public class target public void compilation comp type public static final target ignore new method supports denominator compile method generate code leave result vm stack invoke responsible moving result actual target 
simplest target 
result expression ignored need evaluate possible side effects 
implementation just emits pop value vm stack 
expressions side effects check target immediately 
saves useless push pop pair 
usual target 
specifies expression leave result vm stack 
normally type result object specify expected type determined 
implementation trivial type result stack sub type expected target type needs done generates code type conversion 
things get interesting come 
public class extends target public label iftrue iffalse compiling test expression conditional 
expression evaluated boolean value result true control transfers iftrue control transfers iffalse 
straight forward generate optimal code nested conditionals including macros inlining functions eq 
tail position 
thing done function 
restricted tail recursion elimination 

bytecode package method classes separate gnu bytecode package intermediate level interface code generation java class files 
essentially independent scheme rest kawa 
class extends type constant pool method methods list methods 
field fields list fields 
public field string name type type int flags create new field 
public method addmethod string name 
create new method 
public void outputstream stream 
public void string filename 
public byte 
class main class bytecode package 
manages list fields list methods constant pool 
utility methods adding new fields methods constant pool entries 
fully built method write contents file 
result format class file 
alternatively class written internal byte array layout class file method 
resulting byte array may classloader define new class immediate execution 
methods implemented top general 
method represented method object 
class method implements type arg types type return type attribute attributes object contains zero attributes 
java class file format quite extensible 
information stored named attributes 
standard attributes application define new ones supposed ignored applications understand 
class file may set top level attributes 
addition field method may attributes 
standard attributes may nested sub attributes 
public class attribute container string name attribute container specifies owns attribute 
attribute name plus methods gets size write interesting large standard attribute occurs method name code 
contains actual bytecode instructions non native method represent 
class extends attribute variable type string name 
public void variable var 
public void int 
public void int lineno 
example level functionality compiles code push integer stack 
selects right instruction big instructions take inline value create constant pool entry push 
method creates new local variable sure debugging information emitted pushes value variable stack 
kawa calls indicate current location corresponds line number 
emitted class file java interpreters printing stack trace 
mainly gnu bytecode generating class files classes read class files classes print readable format 
combination decent java dis assembler 
toolkits creating analyzing class files gnu bytecode written provide lot support code generation having little overhead 
example assemblers represent instruction instruction instance just stores instruction byte array 
linked list instructions may objectoriented easier peep hole optimizations time space overhead compared array bytes huge 
need peephole optimizations sense doubly linked list instructions conjunction 
case want byte array representation input output 

literals scheme quoted form self evaluating form expands 
compiling trivial exercise 
way embed say list literal java code 
create static field top level class different body compiling 
code compiled just needs load value corresponding static field 
tricky part making sure static field gets initialized top level class loaded value quoted form 
basic idea define foo compile class foo extends procedure object static lit public static initializer lit new pair public object apply return lit compiled class foo loaded class class forname foo procedure procedure newinstance foo object result apply kawa compiler generate appropriate new pair expression shown 
class instances may appear quoted form implements compilable interface interface compilable literal compilation comp void emit literal compilation comp creates literal object represents value object 
literal passed emit emits bytecode instructions evaluated cause value equal pushed java evaluation stack 
part protocol may overkill possible combine duplicate constants supports circularly defined constants 
standard scheme support self referential constants common lisp 
see section similarity constants 
possible compilable interface replaced augmented jdk serialization feature 
compiling immediate execution need generate code regenerate literal 
fact want re literal original source form 
problem passing source literal class 
interface 
interface public void object values immediate class compiled top level form implements form 
instance created coerced called 
argument array necessary literal values method implements compiled code causes array literal values saved instance accessed compiled code 

class types declarations java support reflection ability determine examine class object class run time extract fields call methods names specified run time 
kawa scheme implementations supports reflection 
plausible represent type java lang class object java reflective facility 
static pseudo classes represent primitive non object types 
unfortunately reasons kawa needs different representation may need refer classes exist process compiling 
want able specify different high level types represented java type 
example want integer subranges enumerations represented int different kinds function types 
want associate different conversion rules different types represented class 
kawa represents types instances type public class type string signature encoded type name int size public final string getname 
public boolean object obj 
public void 
method tests object member type called compiler emit run time test 
note earlier mentioned extends type 
kawa follows convention rscheme rscheme scheme dialects identifiers form name types 
example scheme vectors members type convention names regular identifiers expect little feature identifier bound typename form java type corresponding type returned 
example evaluates type values java arrays elements java strings 
simple example type values definition standard scheme predicate vector returns true iff argument scheme vector define vector 
instance 
primitive kawa function instance 
implements java instanceof operation type method 
compiled code second operand known compile time compiler uses type method generate better code 
traditional benefits adding types dynamic language include better code generation better error checking convenient way partially document interfaces 
benefits require type inference optional type declarations 
kawa far compilation framework gradually type aware 
hooks support unboxed types compiler potentially raw double having allocate object 
kawa includes record extension proposed rs 
allows new record type specified created run time 
implemented creating new specified fields loading class classloader 
record facility consists number functions executed run time 
people prefer approach declarations easily analysed compiletime 
record facility rejected rs 
declarative general class definition facility planned implemented 

low level java access implementations high level language provide interface functions written lower level language usually kawa foreign function interface lower level langauge targets java 
procedure invokes specified java method 
public class extends method method type type argtypes syntax evaluates call invoke static method named method name class class arg types result type primitive static method class method name return type arg type function called kawa sure convert arguments result scheme types java types 
example primitive static method function converts scheme character represented object java char applies standard java lang character method converts result back scheme character 
normally java reflection features call specified method 
primitive static method directly function position application compiler able inline emit efficient invokestatic bytecode operations 
usual style define standard scheme procedures char define char ch primitive static method ch similar forms primitive virtual method primitive virtual method generate virtual method calls interface calls primitive constructor create initialize new object 
access instance static fields object similar macros 
example get time stamp event primitive get field evt kawa low level operations working java arrays 
primitive operations inlined efficient byte code operations compiler knows procedure called primitive java reflection features 

scheme complications scheme features difficult implement especially directly manipulate call stack 
people think class functions lexical scoping complication straight forward implement closure object 
kawa object sub class procedure includes instance variable surrounding environment 
jdk inner classes feature intentionally quite similar closures 
features really cause problems capture tail call elimination 
sub sections discuss currently implement restricted useful subsets feature briefly discuss planned complicated mechanism handle general cases 

continuations scheme continuations capture current execution state 
implemented copying stack requires non portable native code 
kawa continuations implemented java exceptions prematurely exit throw implement routines threads anyway 
class callcc extends procedure public object apply object arg procedure proc procedure arg continuation cont new continuation try return proc apply cont catch ex ex continuation cont throw ex re throw 
return ex value cont mark invalid procedure implements call current continuation 
creates cont current continuation passes incoming proc 
callcc catches exception means proc invoked continuation 
continuation return value passed continuation re throw stack get matching handler 
method mark invalid marks continuation invalid detect unsupported invocation cont callcc returns 
complete implementation continuations sure stacks moved heap returned time 
class continuation extends procedure public object apply object arg throw new arg continuation actual continuation object passed callcc argument invoked throws contains continuation value returned 
class extends object value continuation continuation public object value continuation cont value value continuation cont exception thrown continuation invoked 

tail calls scheme requires tail calls implemented causing stack growth 
means action procedure function call function activation frame needs discarded new function frame allocated 
case unbounded tail recursion grow stack bounded size iteration looping tail recursion 
making easy suitable procedure calling convention difficult portably java matter implementing efficiently requires low level stack manipulation 
compiler optimizations re write tail calls gotos 
important case self tail calls tail recursion 
kawa rewrites simple goto start procedure prove safe 
specifically optimize scheme standard looping forms named 

re writing tail calls implementing general tail calls continuations require able manipulate procedure call stack 
environments including java vm allow direct stack frames 
problem want translate portable assembly language 
java stack call stack explicitly manage call graph return addresses 
re writing done ml scheme rscheme 
java extra complication function efficient way labels 
simulate code labels switch labels 
overhead regular method calls regular procedure interface discussed earlier probably remain default 
procedures regular calling convention cps continuation passing style calling convention 
rest section explains planned cps calling convention 
public class caller int saved pc represents procedure activation 
caller field points caller frame pc switch label representing location caller 
single global owns generalized call stack 
may multiple threads fact allocated time regular method calls procedure uses cps calling convention 
public class frame int pc object value object run frame null frame step return value frame points currently executing procedure frame pc case label code executed current procedure 
result function left value field 
fields may consider global thread registers ideally implement cps calling convention access machine registers 
frame pc value fields simulate frame pointer register program counter function result register typical computer 
creating initial frame pc call run uses step method execute step function return initial frame final value 
consider simple scheme source file defines functions define define 
get compiled public foo extends void step context fr switch context pc case top level code define new define new return case non tail call fr context fr caller fr saved pc context frame fr return case tail call fr context fr caller caller fr saved pc saved pc context frame fr return case entire code scheme compilation unit compiled large switch statement 
case represents top level actions program defines functions comes code followed omitted code called new foo frame allocated context pc set start body function calls non tail function tail call 
call allocates current returning main loop run method 
regular non tail call saves old current frame new frame return link 
contrast tail call return link new frame old frame return link 
return step old frame part call chain captured callcc garbage collected 
time writing cps calling convention implemented am filling details 
extra overhead side benefits 
compile entire source file single java class convenient oneto correspondence source files binary files example makefiles 
exciting possibility write debugger pure java run step condition break point examine stack optionally continue 

current main current priorities kawa making fully compatible standard rs scheme making support usable 
major tasks rs compatibility rewrite support general continuations tail calls plus redesign macros implemented 
implementation may includes complete lexer finished parser optimization handle binary operators operations implemented demonstrate limited read eval print loop 
objects dynamic mappings names properties implemented framework generalizes objects scheme environments records database records just collections framework unifies lists vectors 
existing implementation lawyers plan integrate standard objects functions expression compilation framework 
implementing requires moving code kawa core 
need general interface plug new parsers pre defined functions data types output formatting 
easier add new languages dialects 
special interest re implementing ideas syntax earlier language 
include line oriented syntax fewer parentheses high level sequence array operations apl 
interest support emacs lisp 
require extensive library implement emacs data types buffers windows addition challenges emacs lisp language different data types name binding rules scheme may way build generation emacs 
preliminary threads support kawa 
provides interface java threads looks somewhat delay delayed expression evaluated new thread 
model similar futures concept miller implicit force 
re implementation core classes environment translator done support threads optionally separate top level environments 
interface graphics primitives needed 
new swing toolkit powerful base old windowing toolkit 
sophisticated scheme code rewriting optimizations inlining 

kawa solid implementation scheme features 
portable environment run java applications 
active development member mailing list number different projects 
people scripting language java packages 
people just prefer scheme exist java 
scheme get wider notice partly basis dsssl dsssl standard style formatting language sgml 
kawa implements number dsssl extensions 
benchmark results state art java implementation flux optimizations planned implemented different feature sets various scheme implementations difficult compare fairly 
kawa potential reasonably fast scheme implementation probably fastest reap benefits current efforts java compilation 
bibliography 
efficiently combining logical contraints functions 
ph thesis department computer science stanford university 
budd arith timothy budd 
generalized arithmetic 
journal object oriented programming february 
guy steele jr 
common lisp language 
second edition digital press prentice hall 
dsssl international standards organization 
document style semantics specification language 
international standard iso iec 
ecma 
language specification 
www ecma ch stand ecma htm 

gcc java implementation 
ieee compcon proceedings february see www cygnus com product 
gmp rn granlund 
gnu multiple precision arithmetic library 
gmp manual available gnu archives 
ingalls daniel ingalls 
simple technique handling multiple polymorphism 
acm sigplan notices november 
james gosling bill joy guy steele 
java language specification 
addison wesley 
tim lindholm frank yellin 
java virtual machine specification 
addisonwesley 
kaffe tim wilkinson 
kaffe free virtual machine run java code 
www kaffe org 
kawa 
kawa java scheme system 
www cygnus com kawa html 
miller james miller 
parallel processing system mit scheme 
ph thesis department electrical engineering computer science mit 
david tarditi peter lee anurag acharya 
assembly required compiling standard ml acm letters programming languages systems 
rs revised report algorithmic language scheme 
richard kelsey william clinger jonathan rees editors 

rscheme donovan paul wilson 
www rscheme org 
sgml international standards organization 
sgml standard generalized markup language iso 
