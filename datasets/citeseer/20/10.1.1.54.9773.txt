atomic broadcast simple message diffusion byzantine agreement cristian ray strong danny dolev ibm research center san jose ca march distributed systems subject random communication delays component failures atomic broadcast implement abstraction synchronous replicated storage distributed storage displays contents correct processor clock time 
presents systematic derivation family atomic broadcast protocols tolerant increasingly general failure classes omission failures timing failures authentication detectable byzantine failures 
protocols arbitrary point point network topologies tolerate number link process failures network partitioning 
proving correctness prove lower bounds show protocols provide cases best possible termination times 
keywords phrases atomic broadcast byzantine agreement computer network distributed system failure classification fault tolerance lower bound real time system reliability replicated data 
cristian university california san diego ibm tj watson research center danny dolev hebrew university random communication delays failures prevent distributed processes having knowledge global system states shared storage provides processes centralized system 
absence main reasons distributed programming difficult 
objective discuss broadcast protocols enable correct processes distributed system attain consistent albeit slightly delayed knowledge system state despite failures random communication delays 
programming distributed processes share consistent views system state similar programming processes centralized system 
idea synchronize processor clocks replicate global system state information physical processors atomic broadcast disseminating global state updates processors correct processors identical views global state identical clock times 
atomic broadcast protocol protocol time constant delta called broadcast termination time possesses properties atomicity correct processor delivers update time clock update initiated processor delivered correct processor time clock order updates delivered correct processors delivered order correct processor termination update broadcast initiated correct processor time clock delivered correct processors time delta clocks 
properties atomic broadcast implement abstraction synchronous replicated storage distributed resilient storage displays clock time contents correct physical processor requires delta time units complete replicated updates 
updates synchronous replicated storage broadcast atomically atomicity property ensures update applied correct processors order property ensures updates applied order correct processors 
replicas initially consistent stay consistent 
termination property ensures update broadcast correctly functioning processor applied correct replicas delta clock time units 
synchronous replicated storage record global state information means processes running correct physical processor perceive time global system state existed delta clock time units earlier 
storage similar shared storage represent single point failure 
synchronous replicated storage simplify programming distributed processes relieves programmer burden coping inconsistency local knowledge states result random communication delays faulty processors links 
relatively straightforward adapt known concurrent programming paradigms shared storage environments distributed environments provide abstraction synchronous replicated storage 
examples adaptations 
highly available system project almaden research center atomic broadcast designed updating replicated system directories reaching agreement failure recovery system components cr gs 
system prototype membership information service directories maintained synchronous replicated storage 
previous atomic broadcast performed byzantine generals framework lsp see sd surveys :10.1.1.12.1697
typical models framework assumed guaranteed communication completely connected network perfectly synchronized processors 
assume communication takes place synchronous rounds information exchange round defined time interval needed arbitrary processor receive process messages sent processors previous round 
contrast perfectly synchronized rounds models considers networks arbitrary topology subject link processor failures 
immediate response message allowed forcing processor wait round 
clocks assumed approximately synchronized consider variety component failure behaviors occur practice tolerated cost required tolerate worst case byzantine failures 
classify failures observable distributed systems nested classes complexity fault tolerant protocol increases size class failures tolerates 
derive new family atomic broadcast protocols ranging fairly simple protocol tolerates omission failures sophisticated protocol tolerates authentication detectable byzantine failures prove correctness protocol family discuss performance 
prove lower bounds termination times atomic broadcast protocols tolerant omission byzantine failures 
objective writing structure allow reader interested technicalities inherent correctness lower bound proofs achieve reasonable understanding protocols reading proofs sections 
failure classification classify failures respect decomposition distributed system processors communications links 
components specified produce output response occurrence certain specified input events service request arrivals passage time 
example link connecting processor processor specified deliver message certain number time units requests processor equipped timer specified output messages adjacent links time units 
component specification prescribes output produced response sequence input events real time interval output occur formal definition see section 
system component correct response inputs consistent specification 
component failure occurs component behave manner specified 
omission failure occurs response sequence inputs component gives specified output 
timing failure occurs component gives specified output early late 
byzantine failure lsp occurs component behave manner specified output occurs output outside real time interval specified output different specified occurs :10.1.1.12.1697
important subclass byzantine failures resulting corruption messages relayed components processors links detectable message authentication protocol 
call failures class authentication detectable byzantine failures cf 
lsp :10.1.1.12.1697
error detecting codes pw public key cryptosystems digital signatures rsa examples authentication techniques ensure unintentional intentional message corruptions detected high probability :10.1.1.40.5588
rest assume existence fixed authentication protocol described 
class failures defined respect protocol 
processor crash link breakdown processor occasionally forward message link occasionally loses messages examples omission failures 
excessive message transmission processing delay due processor network overload example late performance timing failure 
coordinated action taken processor soon timer runs fast talk early timing failure 
message alteration processor link random fault example byzantine failure 
authentication protocol employed enables receiver message detect alteration authentication detectable byzantine failure 
message alteration ingenious authentication protocol fails detect forgery example non authentication detectable byzantine failure 
crash failures proper subclass omission failures crash failure occurs omission give output component systematically omits respond subsequent input events omission failures proper subclass timing failures component suffers omission failure understood having infinite response time timing failures proper subclass authentication detectable byzantine failures messages output corrupted authentication detectable byzantine failures proper subclass class possible failures byzantine failures 
nested nature failure classes defined easy compare power faulttolerant protocols 
protocols implement service atomic broadcast clock synchronization tolerates proper subclass class failures tolerates fault tolerant failure classification chosen complexity greater class failures tolerated proper subclass class failures tolerated larger class failures protocol tolerates expensive protocol observe failure classified component specification 
particular component failure type constituent components lead failure type containing component 
example clock displays time example crash failure 
clock part processor specified associate different timestamps different synchronous replicated storage updates processor may classed experiencing byzantine failure 
decomposition distributed system processors links type component considered part 
considering output behavior decompose messages message correct incorrect 
conventions classify failures unambiguously 
concerned tolerating handling failures experienced sub components clocks directly 
discuss fault tolerance terms survival correct functioning processors meet specifications environment processors links may meet theirs usually contain faulty sub components 
speak tolerating omission failures mean tolerating omission failures part processors links tolerating omission failures part subcomponents timers clocks cause worse behavior part containing processors 
assumptions consider system processes maintain synchronous replicated storage 
processes disseminate updates storage replicas atomic broadcast service implemented distributed processors 
pairs processors communicate pointto point links 
assume links exist pairs processors 
symbol represent communications network processors links 
number processors number links call neighbors processors share link 
synchronous replicated storage manager ask processor atomically broadcast update oe invoking broadcast oe command 
send message containing update adjacent link processor invokes send command 
link assumed contain buffers queueing involved message transmission receipt 
receive message containing update link processor invoke receive command 
output parameters command message received identity link received 
updates received messages delivered higher level synchronous storage managers 
assumptions 

processor names distinct total order processor names 

set processors links experience failures execution atomic broadcast protocol surviving network consisting remaining correct processors remaining correct links connect 
assume connected 
surviving network partitioned disconnected subnetworks protocols longer guarantee atomicity 
alternative view protocols connected components network 

processor access clock 
denote clock processor denote local clock time real time writing time values adopt convention capital letters writing clock times lower case letters real times 
assume clocks correct processors monotone increasing functions real time resolution processor clocks fine separate clock readings yield different values ensure correct processor issues timestamp twice 
simplicity assume lifetime system bounded clocks don wrap assumption necessary 
alternative defined ordering timestamps issued cyclic clocks sufficient prove correctness algorithms assumption faulty processors live longer half wrap time way order relation timestamps implemented system prototype described gs 
assume clocks correct processors approximately synchronized correct processors real time clocks maximum deviation ffl jc gamma ffl linear real time 
diffusion clock synchronization protocols tolerant omission performance authentication detectable byzantine failures satisfy requirements cas survey see sc 

processors run control real time operating system provides multi tasking 
schedule task input parameters local time operating system provides schedule command 
invocation schedule local time effect multiple invocations schedule effect single invocation 

message types protocols transmission processing delays measured correct processor clock bounded constant ffi assumption stated formally follows 
correct processors linked correct link correct processor 
real time invokes send command real time finishes receiving processing gamma ffi ffi upper bound includes time spent message queues buffers time needed transmit message link time needed receive process practice cpu time required processing message processor task negligible compared queueing delays affect transit different processors simplifying assumption message processing time zero 
ffi upper bound accounts imprecisions measuring real time delays result clock drift need periodically adjust clocks keep synchronized 
magnitude constant reflects worst case load maximum number events time unit system specified handle 
note order satisfy assumption correct processor fairly allocate processing time link possible faulty processors swamp network messages messages correct processors get correct processors 
correct faulty processors generate updates rapidly processor link overloaded meet specifications 

component system number send receive update deliver events take place finite amount time finite 
assumption needed argue induction sequences events 
assume fixed upper bound number updates generated processor unit time 
assumption corresponds maximum specified load system handle 
information diffusion consider properly nested failure classes omission failures timing failures authentication detectable byzantine failures 
classes atomic broadcast protocol tolerates faulty processors faulty links arbitrary nonnegative integers 
note assumed maximum number processors may suffer failures run protocol 
number events considered failures faulty processor bounded 
likewise assumed maximum number links may fail run protocol 
number events lost messages considered failures faulty link bounded 
termination time delta protocol computed function failure class tolerated parameters known constants ffi ffl largest diameter surviving communication network possible subnetworks containing processors links diameter longest distance processors 
protocols common communication technique called information diffusion correct processor learns new information propagates information neighbors sending messages correct neighbor know piece information turn propagates information neighbors sending messages 
ensures absence network partitions information diffuses network correct processors 
technique called propagation information characterized relatively abstractly segall se 
concept diffusion flooding distributed systems early seventies usually particular source 
information diffusion communication technique method conveying information processors 
conveyed message sequence bits proposition 
give motivating examples terms proposition learn 
terms defined precisely formal sections dealing correctness proofs 
processor convey neighbor proposition processor initiated atomic broadcast update oe time clock sending message oe containing arguments proposition 
processors learn truth propositions conveyed distributed protocol receiving messages observing passage time local clocks 
example learn proposition initiated broadcast oe time clock processor receive new message oe 
example consider processor specified initiate atomic broadcasts times known processor receives broadcast delta receive broadcast delta learns proposition correct time clock cr 
correctness proof term learn action happen processor particular proposition 
speak known constant known broadcast termination time delta mean constant recorded main storage processor 
specific meanings proposition learn vary protocols failure models 
correctness proofs protocols theorem call diffusion induction principle treats terms primitives 
purposes principle propositions primitive objects fixed set prop learn primitive relation set processor theta prop theta real time expressed informally saying processor learns proposition oe real time 
say message conveys proposition oe processor received time time learns oe say proposition propagates neighbors correct pair neighbors linked correct link real time learns real time learns gamma ffi correct processor 
note ensure proposition propagates sufficient necessary send message conveying ensures learns delta clock time units moment learned learned earlier example receiving message conveying processor 
proposition diffuses correct processors real time learns real time learns gamma dffi largest diameter surviving communication network possible subnetworks containing faulty processors faulty links 
assumptions easily prove diffusion induction principle 
theorem proposition propagates neighbors diffuses proof assume propagates neighbors 
correct processor maximum possible diameter surviving subnetwork say diffuses subnetwork learns real time learns gamma ffi distance 
suffices prove surviving network correct components processors diffuses prove induction distance 
diffusion immediate hypothesis propagates 
suppose diffuses processors 
correct processors distance hypothesis implies existence intermediate correct processor distances smaller learns induction hypothesis time learns gamma ffi 
induction hypothesis time learns gamma ffi 
follows gamma ffi 
call time dffi diffusion time surviving network presence processor failures link failures 
diffusion induction principle infer diffusion propagation proofs protocol correctness 
principle independent choice failure class tolerated definitions propagates diffuses depend definition learn vary depending failure class considered 
principle captures informal reasoning years believe formulation principle novel 
note correctness principle depends bounds clock time measured correct processor simply participants message transmission receipt 
protocol tolerance omission failures message sent protocol carries initiation time timestamp name source processor replicated storage update oe 
atomic broadcast uniquely identified timestamp initiator name assumptions 
messages received processor stored history log local processor delivery local synchronous replicated storage manager 
order property required atomic broadcasts achieved letting processor deliver updates receives order timestamp ordering delivery updates identical timestamps increasing order initiator name ensuring correct processor begins delivery updates timestamp certain received updates timestamp may deliver satisfy atomicity requirement 
note message received omission failure context sent correctly deliverable 
omission failures local time processor certain received copies message timestamped received delivered correct processor ffi dffi ffl 
call clock time delivery deadline updates timestamp intuition deadline follows 
term ffi worst case delay initiation broadcast oe moment correct processor learns broadcast 
corresponds case broadcast source faulty processor path faulty processors forwards just message oe outgoing link messages experiences delay ffi clock time units 
term dffi time sufficient diffuse information broadcast oe correct processor surviving network 
term ensures update accepted delivery correct processor clock advance sender clock accepted correct processor clock sender clock 
assume processors know protocol termination time delta ffi dffi ffl 
keep number messages needed diffusing update finite processor receives message oe relays message neighbors sent message receives oe time 
inserts received messages local history removes easily test newly arrived message seen evaluating test call test vu acceptance test message main drawback vu solution described causes local histories grow arbitrarily 
keep length bounded history garbage collection rule needed 
possible solution remove message oe soon deadline delta delivering oe passes local clock 
simple minded application garbage collection rule sufficient ensuring local histories remain bounded possible copies message oe continue received correct processor delivery deadline delta passed clock 
duplicates pass vu acceptance test inserted history residual duplicates delivered see assumption cause history grow bound 
reader point wonder possible message timestamped arrive correct processor delivery deadline delta passed deadline precisely computed ensure receives delta copy message timestamped deliver 
scenario shows possible 
consider fully connected network processors protocol tolerant omission failure termination time ffi ffl 
consider initiates broadcast update oe local time message oe lost due omission failure oe messages relayed vu rule take ffi clock time units 
ffl ffi possible probabilistic clock synchronization algorithms cri receives message oe local time ffi delivery deadline ffi ffl passed 
prevent residual messages accumulating local histories introduce late message acceptance test 
test discards message oe arrives local time past delivery deadline delta delta vu late message acceptance tests ensure updates broadcast finite number messages local histories stay bounded assumption processors broadcast bounded number updates time unit 
detailed description atomic broadcast protocol figures 
processor runs concurrent tasks start broadcast task initiates atomic broadcast relay task forwards atomic broadcast messages neighbors delivery task delivers broadcast updates synchronous replicated storage layer 
tasks processor access constant type set containing identity links adjacent processor 
tasks processors access termination time constant delta defined earlier 
follows refer line 
task start var time oe update processor link cycle wait broadcast oe clock send myid oe od add oe schedule delivery delta 
start task protocol process triggers broadcast update oe invoking broadcast oe command underlying processor 
activate start task matching wait broadcast entry point oe input 
broadcast oe identified local time oe received identity sending processor obtained invoking function myid 
function returns different processor identifiers invoked distinct processors assumption 
broadcast oe initiated invoking send commands outgoing links 
assume execution command line atomic respect failures processor failure prevent messages sent links 
fact broadcast oe initiated recorded history variable set triples shared broadcast layer tasks var time theta processor theta update 
assume initialized empty set fg processor start 
history updated delivery task scheduled execute input parameter local clock time delta deliver update 
task relay var time oe update processor link cycle receive oe clock delta late message iterate oe vu iterate fig send oe od add oe schedule delivery delta 
relay task protocol relay task uses command receive receive messages formatted oe neighbors 
message received output parameter contains identity incoming link message arrived 
message duplicate message received delivered discarded meaning iterate command skip execution rest loop body new iteration 
message accepted passes late message vu tests relay task 
oe accepted relayed outgoing links inserted history variable delivery task scheduled execute input parameter local time delta deliver received update 
task delivery time var val processor theta update val oe oe hg sort val processor name lexicographically oe val order deliver oe od delete triples element 
delivery task delivery task starts clock time delta deliver updates timestamped increasing order sender identifier delete information broadcasts local history 
proof correctness protocol diffusion induction principle prove correctness protocol denoted proof assumption protocol execution processors suffer omission failures links suffer omission failures 
propositions diffused form processor broadcasts oe local time 
say correct processor learns real time initiates diffusion messages oe receives message oe time 
denote protocol infinite local history obtained removing late message acceptance test local history garbage collection 
lemma processors follow protocol propagates neighbors 
proof assume correct processor learns real time correct neighbor linked correct link sends message oe assumption real time message received correct processor gamma ffi oe history learns inserts message history 
oe history learned earlier real time monotonicity clock learned clock time inequality gamma ffi holds case 
real time learns receiving message oe time neighbor 
time learned gamma gamma ffi argument analogous case show learns ffi clock time units receives message oe sent time learned earlier 
lemma processors follow protocol correct processor inserts message oe history correct processor inserts oe history local time delta proof earliest real time correct processor inserts oe history 
diffusion induction correct processor inserts oe history real time dffi 
ffl follows local time inserts oe history dffi ffl delta consider case case receives message oe time real time omission processor link failures possible messages supposed sent processor received time processor correct received example processor crashed sending link suffers omission failure 
real time processor initiates broadcast update oe correct processor learns real time processing message traversed path hops links sent easy prove induction manner similar illustrated proof diffusion induction principle processor gamma hffi 
hypothesis faulty processors longest possible acyclic path sequence processors links repetition message originating processor traverse accepted correct processor contains hops 
earliest real time correct processor learns follows gamma ffi processor diffusion induction correct processor insert oe history real time gamma dffi processor follows particular ffi dffi 
ffl ffi dffi ffl delta lemma processors follow protocol correct processor inserts message oe history correct processor inserts oe history local time delta history processor remains bounded 
proof prove protocols equivalent sense message oe accepted correct processor follows message accepted 
clearly message inserted history processor inserted set messages pass acceptance tests late message vu included set messages pass vu test 
assume correct processor follows inserts message oe history 
inserts message history start tasks identical 
consider lemma late message test evaluate false oe pass test inserted history followed part lemma follows lemma 
late message acceptance test assumption omission failures occur history correct processor contains local time messages timestamps range gamma delta ffl 
number processors bounded processor broadcast bounded number messages bounded time interval follows total number messages exist point time bounded 
theorem protocol possesses termination atomicity order properties 
proof update oe received start task correct processor local time lemma correct processor adds oe bounded history local time delta examination start relay tasks shows correct processor add oe scheduling delivery task local time delta input lemma implies initiator correct correct processor adds oe history 
lemma implies termination atomicity protocol 
assumption delivery task delivers updates different timestamps timestamp order orders delivery updates timestamp increasing order originator name protocol satisfies order property 
protocol tolerant timing failures construct counter example showing occurrence timing failure lead violation atomicity property 
consider totally connected network processors sender faulty early correct late correct clock ffl time units advance clock clock indicates clock indicates suppose start task interrupted crash message oe sent suppose faulty processor delays forwarding messages oe correct processors way messages sent arrive clock shows delta clock shows delta gamma 
clearly oe delivered message arrives clock shows delta message accepted update oe delivered local time delta atomicity requirement violated 
second protocol tolerance timing failures protocol tolerant timing failures fixed clock time interval independent number faulty processors message unconditionally accepted correct processor 
illustrated counter example creates real time window message late early correct processors time late correct processors 
achieve atomicity presence timing failures ensure correct processor accepts message correct neighbors relays accept neighbor know message source correct 
correct accept information stored tells clock time delay ffl case clock close ffl time units message propagation delay close ffi ffl case clock close ffl time units advance message takes ffi time units 
able evaluate time message spends neighbors store message number hops traversed 
processor reject messages taken longer ffi ffl clock time units hop ffl clock time units hop early 
need lateness test motivated example section 
need earliness test wish maintain property history log correct processor remains bounded 
faulty processor fast clock send updates send earlier real time supposed forcing correct processors keep history logs unbounded amount time 
type faulty behavior may common practice fit definition early timing failure 
formally timeliness acceptance test correct processor accepts message timestamped hop count receives local time ffl ffi ffl 
hypothesis path faulty processors faulty sender correct processor message accepted pass test follows message spend ffi ffl clock time units network accepted correct processor 
moment needs dffi clock time units reach correct processors 
ffl uncertainty clock synchrony termination time second protocol delta ffi ffl dffi ffl 
start task second protocol identical addition hop count messages 
origin hopcount initialized 
task start var time oe update processor link cycle wait broadcast oe clock send myid oe od add oe schedule delivery delta 
start task second protocol addition tests providing tolerance omission failures relay task second protocol contains timeliness tests discussed 
hop count carried messages incremented time message relayed 
delivery task second protocol identical protocol 
task relay var time oe update processor integer link cycle receive oe clock hffl iterate ffi ffl late iterate delta late message iterate oe vu iterate send oe od add oe schedule delivery delta relay task second protocol correctness second protocol propositions diffused second protocol denote proof form diffused protocol processor broadcasts update oe time clock 
say correct processor learns real time initiates broadcast oe receives time message oe passes early hffl late ffi ffl timeliness acceptance tests 
denote protocol infinite local histories obtained removing late message acceptance test local history garbage collection 
lemma correct processors follow protocol propagates neighbors 
proof assume correct processor learns real time correct neighbor linked correct link analyze cases sends message oe line 
want show message receives pass timeliness acceptance tests assumption oe message received real time ffi assumption ffl follows ffi ffl late acceptance test passed early acceptance test passed assumption monotonicity assumption gamma ffl gamma ffl assumption gamma ffl 
consider case assume learns receiving processor message oe passes early late acceptance tests ffl ffi ffl 
correct neighbor linked correct link 
learned investigate interesting case line sends message oe assumption message received real time ffi 
show message passes timeliness acceptance tests assumption ffl follows ffi ffl 
inequality hypothesis ffi ffl follows ffi ffl late acceptance test passed early acceptance test passed assumptions gamma ffl hypothesis ffl implies ffl 
lemma correct processors follow protocol correct processor inserts oe history correct processor inserts oe history local time delta proof earliest real time correct processor inserts oe history 
reasoning similar case proof lemma conclude correct processor inserts oe history local time dffi ffl delta oe message learns 
worst case path faulty processors message passes late acceptance test ffi ffl 
diffusion induction exists real time correct processor learns dffi 
assumption ffl follows ffi ffl dffi ffl 
lemma processors follow protocol correct processor inserts message oe history correct processor inserts oe history local time delta maximum number updates broadcast processor time unit bounded history processor stays bounded 
proof proof similar lemma main difference case timing failures local time histories contain messages timestamps range delta ffl 
theorem second protocol possesses termination atomicity order properties 
proof similar theorem 
second protocol tolerant byzantine failures construct counter example showing byzantine failure occurrence lead violation atomicity property 
consider totally connected system processors sender faulty early correct late correct clock time units advance clock ffl clock indicates clock indicates assume delta ffi ffl 
suppose broadcast oe interrupted crash message sent suppose mistake increments hop count forwards message oe correct processors way messages arrive clock shows delta clock shows delta gamma 
update oe delivered atomicity requirement violated 
tolerance authentication detectable byzantine failures illustrated previous counter example byzantine processor confuse network correct processors forwarding appropriately altered messages behalf correct processors appropriately chosen moments 
way preventing phenomenon authenticate messages exchanged processors broadcast ds lsp messages corrupted byzantine processors recognized discarded correct processors :10.1.1.12.1697
way able handle authentication detectable byzantine failures manner similar way handle timing failures 
ignoring simplicity increase message processing time due authentication set termination time third protocol termination time second protocol delta ffi ffl dffi ffl 
reader warned ffi formula significantly larger corresponding term previous protocol cost authentication processing 
detailed implementation third protocol figures 
assume processor possesses signature function phi string characters generates string characters phi called signature 
processor knows names processors communication network access authentication predicate theta yields true phi 
assume processor receives string part message processor theta true sent string 
authentication predicate fails detect message forgery protocol longer guarantee atomicity presence byzantine failures 
proper selection phi theta functions environment depends cause message corruption 
source message corruption unintentional transmission errors due random noise link hardware malfunction simple signature authentication functions error detecting correcting codes studied pw appropriate 
source message corruption intentional act sabotage elaborate authentication schemes discussed rsa :10.1.1.40.5588
case small non zero probability corrupted message accepted authentic 
implement message authentication procedures sign authenticate new signed message data type 
described pascal language supporting recursive type declaration 
type record case tag relayed timestamp time update update relayed incoming procid processor signature string signed message data type signed message type signed processors structure relayed relayed oe oe timestamp update inserted message source signatures 
procedure sign time oe update tag timestamp update oe procid myid signature phi myid tag oe sign procedure sign procedure invoked originator broadcast oe produce message containing originator signature 
sign procedure invoked processor forwards incoming message signed processors yields new message signature appended list signatures procedure sign tag relayed incoming procid myid signature phi myid tag sign procedure authenticate procedure verifies authenticity incoming message 
assigns boolean output parameter value false alteration original message detected 
alteration original message content detected final value true remaining output parameters oe assigned timestamp original update included message sequence processor names signed message respectively 
identity initiator element sequence denoted number hops number intermediate links traversed message length sequence denoted jsj 
procedure authenticate boolean time oe update sequence processor tag theta tag timestamp update procid signature tag relayed theta tag incoming procid signature false tag timestamp oe update true authenticate incoming oe append procid authenticate procedure change concerning authentication messages structure start task third protocol second protocol 
order handle case faulty processor broadcasts updates timestamp type history variable changed var time theta processor theta update symbol denotes null update update 
specifically processor receives distinct updates broadcast identifier associates null update broadcast 
null update history indication faulty sender 
task start var time oe update link cycle wait broadcast oe clock sign oe send od add oe schedule delivery delta start task third protocol task relay var time oe update processor link boolean sequence processor cycle receive clock authenticate oe false forged message iterate duplicates duplicate signatures iterate jsj ffl iterate jsj ffi ffl late iterate delta late message iterate oe oe oe 
faulty sender iterate oe oe vue iterate replace oe 
add oe schedule delivery delta sign fig send od 
relay task third protocol relay task third protocol works follows 
receipt message message checked authenticity corrupted message discarded sequence signatures processors accepted message examined ensure duplicates duplicate signatures message discarded 
processor signatures authenticated number signatures jsj message trusted hop count determining timeliness message 
confusions illustrated previous counter example occur authentication scheme compromised 
incoming message authentic duplicate signatures timely history variable examined determine message new broadcast 
case history variable updated information sender sent update oe time delivery task scheduled start processing possibly delivering received update local clock time delta received message forwarded 
received update oe recorded received alternate path discarded 
oe second update broadcast identified sender faulty 
fact recorded setting null update 
message forwarded correct processors learn sender failure 
oe associated broadcast identifier associated null update known originator broadcast faulty received update simply discarded 
task delivery time var val processor theta update val oe oe oe sort val processor name lexicographically oe val order deliver oe od delete triples element delivery task third protocol delivery task delivers local time delta updates broadcast correctly time exactly update accepted broadcast initiated clock time update delivered update delivered 
case updates associated broadcasts initiated clock time deleted ensure stays bounded 
correctness third protocol third protocol denoted proof diffuses kinds propositions proposition oe familiar form processor broadcast update oe local time proposition oe oe form oe exist distinct updates oe oe processor initiated broadcast updates timestamp 
correct processor learns oe real time inserts oe history receives message authenticate procedure terminates successfully returning true oe processing results update local history adding oe 

update oe correct processor learns oe oe real time learns oe exist distinct updates oe oe learns oe learns oe correct possible learn broadcast different updates identical timestamps correct processor learns oe oe adds oe receives message authenticate procedure terminates successfully returning true oe processing results action 

denote protocol infinite local history obtained removing late message acceptance test local history garbage collection 
lemma correct processors follow protocol processor correct oe propagates neighbors 
proof analogous lemma 
relies observation sender correct correct processor learns oe correct neighbor learn oe oe oe 
message sends causes insert oe history simply discarded inserted oe history 
lemma correct processors follow protocol oe oe propagates neighbors 
proof assume correct processor learns oe oe real time correct neighbor linked correct link learns oe recall correct processor uses different timestamps different updates lemma oe propagate ffi clock time units 
consider interesting case message received neighbor 
analyze cases learns oe oe learning oe learns oe oe learning oe earlier learned oe oe oe learns oe oe learning oe forwards message signature appended neighbors lines 
learned oe oe oe earlier 
receives real time message conveying oe 
assumption link correct implies message passes acceptance tests received learned oe oe history contains oe oe learns oe oe oe time learns oe oe oe time consider case learns oe oe learning oe learned oe earlier oe oe neighbor sent message conveying oe forwarded message conveying oe forwards message conveying oe learns oe oe 
learned oe forwarded message conveying oe receiving message follows learns oe oe time receives message 
learned oe forwarded message conveying oe neighbors learned oe oe time receipt time learned oe 
case remains analyzed neighbor sent messages conveying oe oe 
learned oe oe oe oe forwards messages conveying oe oe learned oe oe time received messages 
lemma correct processors follow protocol initiator broadcast oe correct correct processor inserts oe local history local time delta proof relies lemma analogous proof lemma omitted 
lemma correct processors follow protocol oe correct processor history contains oe correct processor history contains oe 
time delta clock 
proof necessarily oe history diffusion induction assumption correct inserts oe history dffi ffl delta consider recall learns oe oe equivalent inserts history oe 

earliest real time correct processor learns oe oe 
reasoning analogous proof lemma ffi ffl lemma diffusion induction assumption follows correct processor learns oe oe time ffi ffl dffi ffl clock 
follows clock displays time delta history contains oe 
lemma correct processors follow protocol exists correct processor inserts 
history correct processor 
history local time delta proof suppose processor inserts 
history 
exist updates oe oe oe oe learns oe learning earlier time oe 
note definition oe correct processor learns oe oe 
history 
lemma correct processor oe 
history correct processor oe 
local time delta oe oe correct processor 
local history local time delta lemma processors follow protocol correct processor initiates local time broadcast update oe correct processors insert oe history time delta clock 
correct processor inserts 
history correct processor inserts 
history local time delta maximum number updates broadcast processor time unit bounded history processor stays bounded 
proof proof similar lemma omitted 
theorem third protocol possesses termination atomicity order properties 
proof relies lemma similar theorem omitted 
performance messages absence failures initiator atomic broadcast sends messages neighbors denotes degree number adjacent links 
processor receives message processor sends messages neighbors 
sum node degrees network twice number network links follows atomic broadcast costs messages number links number nodes network 
example atomic broadcast processors arranged dimensional cube requires messages absence failures 
compare message cost algorithms directly round model compare results straightforward conversion 
issues conversion 
issue complete connectivity 
algorithms designed completely connected networks routing scheme simulate complete connectivity 
general messages sent disjoint routes overcome failure intermediate processors 
number component failures tolerated converted protocol may dramatically reduced original 
round protocols depend complete connectivity fourth protocol lsp authentication :10.1.1.12.1697
case message costs may better protocols usually variant diffusion 
illustrative purposes consider round protocol ds designed complete connectivity 
consider straightforward conversion protocol model arbitrary minimal length routing scheme simulate complete logical connectivity processors 
logical messages sent processors implemented sequences hop messages sent neighbors messages sent round redundant 
logical message sent processor non neighbor processor neighbor path selected message routing algorithm message sends forwarded redundant message sends direct consumption 
example processors arranged dimensional cube round logical messages sent processor costs hop messages 
converted round agreement protocol tolerant timing authentication detectable byzantine failures sends absence failures theta messages compared messages needed diffusion protocol 
termination time termination time atomic broadcast depends network topology class failures tolerated 
absence information network topology number processors bounded taken upper bound clock synchronization algorithms provide ffl close dffi investigated cas 
simplicity assume ffl ffi 
omission failures termination time atomic broadcast linear delta ffi bounded gamma ffi 
timing byzantine failures termination time proportional product number processors number processor failures tolerated delta ffi bounded gamma ffi 
numerical example consider case processors arranged arbitrary way form network 
assume link delay bound ffi seconds want tolerate processor failures 
termination time omission failures seconds timing failures seconds 
byzantine failures scale numbers factor reflecting increase ffi due authentication processing 
information network topology available better expression computed network diffusion time ffi note expression corresponds worst case path consisting hops faulty processors followed hops shortest path surviving network correct processors links 
example processors arranged dimensional cube need tolerate link failures approximate termination times omission timing failures cut seconds respectively 
bounded faulty processors adjacent diameter surviving network adjacent diameter faulty processors encountered path correct processor encountered 
straightforward conversions rounds protocols system model require round include worst case time sending message processors extra delay corresponding worst case duration round processor clock round processor clock 
example fourth algorithm lsp terminates rounds diffusion requires termination time ffi ffl clock time units lsp :10.1.1.12.1697
round protocol ds assumes full network connectivity require round lasts dffi ffl clock time units 
tolerate failures ds protocol needs rounds conversion model require dffi ffl clock time units 
termination times equal greater termination time ffi ffl dffi ffl third protocol equality fully connected surviving network 
omission failures occur protocol better termination straightforward conversion rounds protocols fully connected network ffi dffi ffl smaller minimum ffi ffl dffi ffl ffl 
ffl large compared ffi difference dramatic justifications studying tolerance omission failures model 
long conjectured termination times provided algorithms turn optimal 
able prove lower bounds section 
results shown second third algorithms fact provide optimal termination times sdc 
termination times hold execution uniformly simply worst case 
shown possible terminate earlier worst case time addition diffusion pg 
algorithms achieve best worst case time best expected average time 
remain competitive point view simplicity 
closely related problems suggests time complexity attributed algorithms operating model sensitive definition termination time 
results adls po real time required consensus problem readily comparable termination time results models describe exactly phenomena 
better understanding relationship results real time results subject current research 
upper lower bounds coincide omission failures gap remains corresponding upper lower bounds real time required consensus 
lower bounds runs specifications section slightly formal model execution distributed system 
postponed interest readability rest 
formally view distributed system composed processors links 
processors links system described language io automata lt interested input output behavior components model somewhat simplified 
execution distributed system consists sequence events component system 
event pair consisting action real time indicating action completes 
action state transition specific component receipt sending message duration action corresponding passage unit real time 
events component divided sets input output 
processors input events receipt message link receipt update passage unit real time 
links input events receipt message sending processor passage unit real time 
output events processors sending message link delivery update process outside system 
output events links sending messages processors 
output event processor link vice versa occurs execution corresponding input event link processor occurs execution 
executions deemed provide semantics pseudocode algorithms obvious way correct processors execute pseudocode experience output events timing constraints specified assumptions 
correct links correlate input events output events timing constraints specified 
behavior faulty components governed failure class consideration 
brevity term run interchangeable term execution 
assume starting time called real time run 
note messages updates run necessarily infinite includes events corresponding passage units real time 
term local history denote finite prefix sequence events take place component run 
specification relation local histories output events actions specified occur result histories satisfies property specification local history domain latest time associated event set real times associated relation events bounded real time deadline output events supposed occur bounded component satisfies specification run properties hold local history prefix domain output event output event local history prefix domain 
recall component satisfies specification run called correct run 
note assumptions section constrain possible specifications links sub component clocks 
results hold specifications satisfy assumptions 
example sufficient specify correct clock maintain linear envelope synchronization cas ff gamma gamma fi gamma fl real times message delivered link ffi gamma fl fi time units real time sent link 
specification necessary 
time lower bound crash failures generalize example previous section provide lower bound termination time required atomic broadcast algorithm presence omission failures 
prove second lower bound termination time atomic broadcast presence authentication detectable byzantine failures 
lower bound proof proof ds simpler model conversion simple model system model especially completely connected arbitrary networks trivial 
fact leave open characterization networks algorithms provide optimal termination time conjecture include symmetric networks pair nodes automorphism mapping result fix numbers processors links suffer omission failures 
say fpg path source leads acyclic path hops links processors path path communication network define adverse case selection set ae processors links processor positive integers number links sum number processors exists path path originating leading processor network connected contains processor hops away weakly adverse case selection number links sum number processors exists path originating leading processor network connected contains processor hops away intuition adverse case lower bounds proof follows contains processors links crash initiation atomic broadcast processor links crash broadcast path processor contains processors suffer failures broadcast closest correct processor path witness equivalent protocol runs 
say network requires steps adverse case say network allows steps weakly adverse case max largest number steps allowed network set termination time delta omission failure tolerant protocol specifically tailored network xmax ffi ffl prove correctness manner analogous way proved correctness protocol uses general upper bound max theorem communication network requires steps atomic broadcast protocol tolerant processor link omission failures termination time xffi ffl 
proof suppose requires steps adverse case exists protocol achieves atomic broadcast presence processor link omission failures termination time ffi ffl 
times ffi ffl xy loss generality assume deterministic protocol 
randomized restrict attention constructing universe runs executions random choices way processors coins tossed processors heads 
assume loss generality real times messages may sent form discrete countable subset set real times induction set 
suppose set real times requires messages runs dense 
perturb slightly wait instant discrete set speed delivery message received time 
transformation produce runs indistinguishable message receipt history provided runs considered messages delivered faster time closest points discrete set 
assumption number messages may require instant discrete set finite 
set atomic broadcast runs executions protocol initiator starting broadcast update oe update update real time satisfy properties processor clocks run rate real time messages exchanged processors take exactly real clock time units transmission processing component fails real time faulty links failures crash failures recall crash failure component ceases send relay messages prescribed path ff originating set processors fail processors nodes ff failure node situated hops ff occurs real time ky processor situated hops ff crashes time possibly sending messages required time processor situated fewer hops ff sends messages empty processor ff note 
adverse case conditions imply processor failures link failures broadcast oe failures disconnect surviving network see part definition adverse case 
note empty path assumed path originating run processor real time msgs denote sequence pairs kg protocol requires send message processor order sequence order requires messages sent 
run denote partial run time processors links behave denote corresponding partial run time assumed deterministic assume runs msgs msgs 
partial run satisfies conditions define conservative extension unique run component processor link continues behave correctly crashed time processor crashes time time omits send message msgs remains crashed conservative extension time 
say runs output equivalent updates delivered correct processors runs 
define relation witness equivalence transitive closure relation holds runs processor correct distinguish basis message history time clock 
assumption correct runs witness equivalent output equivalent 
prove theorem sufficient show output equivalence runs processor initiates atomic broadcast correctly time processor correct time clock processor crashes initiating atomic broadcast send messages time processor correct time clock 
note real time crash processor run defined time msgs nonempty send message msgs assume processor send update correct time processor crashes time crash may 
output equivalence runs contradicts hypothetical correctness protocol correct correct processors deliver update oe time clocks processor deliver update time clock 
order prove runs witness output equivalent define mutual recursion crash correction operator crash insertion operator type theta path theta processor theta time applied quadruple ff domain operators yields run witness equivalent operators defined way exist paths ff fi real time ff fi 
particular ff path consisting link processor time msgs empty time crashes fi empty path viewed leading 
definition crash correction operator domain set quadruples ff ff path satisfies condition processor ff real time crashes real time kg subsequence msgs send run ff defined follows 
ffl case step add gamma conservative extension resulting partial run 
ffl case 
case ff link delta step add gamma obtain case ff link delta step fi result changing ff lead changes gamma gamma fi 
delta step add gamma obtain gamma delta step crash gamma gamma time crashes gamma fi extension link fi produce path satisfies gamma gamma fi 
ffl step crashes time crashes ff definition crash insertion operator domain set quadruples ff ff path leads processor ff satisfies condition run smallest real time msgs nonempty conservative extension result removing msgs extension ff satisfying condition 
run ff defined follows 
msgs nonempty smallest time kg sequence msgs 
ffl case step conservative extension result removing gammaj 
ffl case step latest time msgs nonempty time msgs nonempty ff 
delta case ff link delta step gammaj result removing gammaj delta case ff link delta step fi extension ff link gammaj gammaj fi 
delta step remove gammaj obtain gammaj delta step crash gammaj gammaj gammaj real time crashes gammaj fi extension fi link leads processor extension gammaj gammaj fi 
runs processor time define relation hold exactly messages sent time 
shorthand useful describing results applying operators 
lemma operators defined 
ff domain ff witness equivalent prefix ff satisfies condition ff domain ff witness equivalent sends messages time crash ff satisfies condition extension ff link satisfies proof prove lemma induction number links ff time note step definition operator changes conditions 
need check conditions sure run produced step member base case induction assume note condition number links ff consider crash correction operator applied ff domain 
case determined step step 
ff satisfies msgs msgs 
assume ff satisfies gamma gamma msgs msgs gamma 
adding gamma change fact partial run satisfies conditions conservative extension produces run note msgs msgs crashes adverse case processor correct gamma hops away distinguish gamma real time xy clock time gamma witness equivalent 
crashes ff satisfies prefix ff leads satisfies induction witness equivalent ff satisfies crash prefix ff leads satisfies note conservative extension partial run fail 
fail step 
second consider crash insertion operator applied ff domain 
time msgs nonempty processor sends messages ff satisfies assume loss generality smallest msgs nonempty 
case determined step ff satisfies msgs msgs 
fi extension ff link processor correct ff domain fi satisfies conservative extension result removing 
msgs msgs 

adverse case witness equivalent argument crash correction operator 
assume fi satisfies gammaj gammaj witness equivalent gammaj gammaj conservative extension result removing gammaj msgs msgs gammaj fi satisfies gammaj gammaj 
adverse case witness equivalent gammaj induction fi satisfies witness equivalent conservative extension partial run crashes crashes assume ff domain induction hypothesis lemma holds operators number links processor argument path argument greater number links ff time argument greater assume number links ff 
case determined steps 
ff satisfies condition witness equivalent assume ff satisfies condition gamma gamma witness equivalent gamma case holds message reaches sends messages condition gamma step result adding gamma msgs msgs 
crashes ff satisfies condition crashes time case ff satisfies condition crash case prefix ff leads satisfies message reaches sends messages processor correct excluding distinguish gamma 
adverse case processor correct 
witness equivalent 
assume case holds 
determined steps 
node ff message msgs fi defined 
processors fi fi satisfies gamma fi extension fi addition link processor crash gamma time msgs gamma nonempty fi satisfies conservative extension result removing msgs gamma gamma 
gamma fi domain induction hypothesis gamma witness equivalent gamma gamma gamma fi fi satisfies condition gamma sends messages gamma processor correct excluding distinguish gamma gamma obtained adding gamma step 
gamma gamma fi fi satisfies gamma sends messages gamma crash 
adverse case processor correct gamma witness equivalent gamma crashes gamma gamma fi 
domain fi longer ff gamma fi step witness equivalent gamma gamma prefix fi satisfies induction hypothesis 
induction witness equivalent prefix fi satisfies crash step prefix fi prefix ff satisfies ff 
domain time crashes case induction hypothesis witness equivalent prefix ff satisfies ff 
assume ff domain previous induction hypothesis 
assume number links ff 
processors crash 
important want crash additional processors execution time msgs nonempty done 
greater done induction hypothesis ff ff 
assume case determined steps 
step latest time msgs nonempty time 
ff domain ff 

induction hypothesis ff witness equivalent sends messages crashes extension ff link satisfies assume witness equivalent gammaj gammaj sends messages gammaj fi satisfies gammaj fi extension ff link leading processor outside extension 
case holds gammaj obtained step removing gammaj message reaches sends messages gammaj gammaj processor excluding correct distinguish gammaj gammaj 
adverse case processor correct runs gammaj witness equivalent gammaj gammaj gammaj path fi defined satisfies gammaj sends messages gammaj case holds gammaj determined steps 
case fi leads gammaj fi domain fi links 
step gammaj gammaj fi 
induction hypothesis gammaj witness equivalent gammaj gammaj gammaj sends messages gammaj fi extension fi link processor extension satisfies gammaj depending crashes gammaj gammaj gammaj sends messages gammaj step gammaj obtained gammaj removing processor excluding correct runs distinguish 

adverse case processor correct runs 
gammaj gammaj witness equivalent gammaj gammaj sends messages gammaj fi extension fi defined satisfies gammaj crash gammaj gammaj gammaj step 
assume crashes gammaj fi defined step 
note fi satisfies gammaj gammaj fi 
domain induction hypothesis gammaj witness equivalent gammaj fi gammaj prefix fi satisfies 
witness equivalent fi satisfies crashes 
induction witness equivalent appropriate extension ff satisfies sends messages completes proof lemma 
lemma suffices prove theorem outlined note condition crash failures proof 
theorem holds crash failures omission failures 
careful disturb order messages required sent theorem holds orderly crash failures failing processor send messages order 
easy show completely connected network nodes requires steps tolerate processor omission failures link failures theorem consistent result ds 
time lower bound authentication detectable byzantine failures move omission failures authentication detectable byzantine failures show protocols best possible case processor hamiltonian network tolerate processor authentication detectable byzantine failures 
hamiltonian network acyclic path containing network nodes 
fully connected network dimensional cube examples hamiltonian networks 
theorem atomic broadcast protocol hamiltonian network processors tolerates authentication detectable byzantine processor failures termination time smaller ffi epsilon 
proof hamiltonian network processors numbered acyclic path 
hypothesized termination time atomic broadcast protocol suppose ffi epsilon 
proof theorem ffi epsilon 
set runs processor initiates atomic broadcast update oe time satisfy properties processor clocks run rate real time processor behaves jz close ffl processors correct assume clocks correct processors run ffl messages sent received take exactly time units run processors correct denote run processors correct processor follows clock correct omits receive send messages processors 
assume loss generality random choices way run processors 
construction adjacent pair runs identical message histories correct processor share 
runs witness output equivalent 
real time atomic broadcast initiated processor clock processor reads broadcast timestamped run processor deliver update 
faulty processors confine information exchange neighbors takes time units information reach information reaches termination time past clock 
run processors ones correct processor delivers oe 
induction witness equivalence shows property holds run correct processor delivers oe 
run processor processor delivers oe contradicting termination property hypothesized protocol hamiltonian node network objective tolerate authentication detectable byzantine failures third protocol achieves best possible termination time 
example theorem fully connected network processors best possible termination time handling authentication detectable byzantine processor failures ffi ffl identical termination time second third protocols 
specified atomic broadcast problem proposed classification failures observable distributed systems investigated protocols atomic broadcast systems bounded transmission delays partition failures proven correctness discussed performance proved lower bound theorems show cases protocols provide best possible termination times 
atomic broadcast simplifies design distributed fault tolerant programs enabling correct processes access global state information synchronous replicated storage 
notion reduces problem distributed programming shared storage programming having single point system failure 
highly available systems prototype synchronous replicated storage store crucial system configuration information remain available despite possibly multiple processor failures 
protocols derived share specification diffusion structure differ classes failures tolerated ranging omission failures authentication detectable byzantine failures 
pedagogical value familiar intricacies achieving byzantine agreement derivation sheds new light continuum exists simple message diffusion protocols complex byzantine agreement protocols 
clearly complexity increases failures tolerated complexity final protocol handles byzantine failures orders magnitude greater initial protocol 
variant protocol uses error correcting codes authenticate messages implemented runs prototype system designed highly available systems project ibm almaden research center gs 
experience accumulated implementation test prototype showed failures observed distributed systems general purpose operating systems vm unix performance late timing failures caused random variations system load 
aware difficulty debugging distributed protocols especially time dependent proved correctness common diffusion induction principle protocols 
believe proof technique applicable distributed protocols information diffusion 
implementation objective protocols realistic system model arbitrary network topology approximately synchronized clocks unreliable communication links previous algorithms achieving agreement rounds model 
abandoning rounds model led better performance obtained straightforward conversion rounds protocol ds 
better performance achieved adopting clock synchronization approach developed cri enables achievement synchronization precisions superior achievable algorithms discussed cas sc 
time protocols invented unaware protocols atomic broadcast designed system models realistic assumed byzantine agreement literature lsp sd :10.1.1.12.1697
protocols atomic broadcast system models similar proposed bj bsd ca cm pg sdc 
protocols proposed far divided classes time oriented protocols providing bounded termination times failures occur broadcast protocols provide bounded termination times failures occur broadcast 
examples protocols class bsd pg sdc 
examples protocols bj ca cm 
protocols potential tolerating performance failures cause network partitioning diffusion protocols tolerate partition failures 
investigated methods detecting reconciling inconsistencies caused partitions systems diffusion atomic broadcast optimistic approaches applications natural compensation actions actions taken processors state inconsistent state processors 
existence classes protocols pose serious dilemma distributed system designers avoid network partitioning massive network redundancy real time operating systems guarantee bounded reaction time events presence failures accept partitioning unavoidable evil example operating systems hard real time abandon requirement system provide bounded reaction times events failures occur 
joe halpern fred schneider mario dale skeen irv traiger referees number useful comments criticisms 
nick littlestone suggesting disjunctive form proposition oe proof theorem 
possible essentially proof technique diffusion induction proving correctness protocols 
adls attiya dwork lynch stockmeyer bounds time reach agreement presence timing uncertainty proceedings acm symposium theory computing pp 

bsd babaoglu stephenson reliable broadcasts communication models tradeoffs lower bounds distributed computing pp 

bj birman joseph reliable communication presence failures acm transactions computer systems vol 
february pp 

cristian correct robust programs ieee transactions software engineering vol 
se pp 

ca carr tandem global update protocol tandem systems review pp 
june 
cas cristian strong clock synchronization presence omission performance faults processor joins th international conference fault tolerant computing vienna austria 
cr cristian agreeing absent synchronous distributed system th international conference fault tolerant computing tokyo japan 
cri cristian probabilistic clock synchronization distributed computing vol 
pp 

cm chang maxemchuk reliable broadcast protocols acm transactions computer systems vol 
pp 

delta system specification powell editor delta project consortium bull sa bp france january 
ds dolev strong authenticated algorithms byzantine agreement siam journal computing vol 
pp 

dolev halpern simons strong fault tolerant clock synchronization proceedings rd annual acm symposium principles distributed computing 
fischer consensus problem unreliable distributed systems proceedings international conference foundations computing theory sweden 
gopal strong toueg cristian early delivery atomic broadcast proc 
th acm symp 
principles distributed computing pp 
quebec city 
gs strong dcf distributed communication fault tolerance proceedings th annual acm symposium principles distributed computing 
lamport time time outs fault tolerant systems acm transactions programming languages systems vol 
pp 

lsp lamport shostak pease byzantine generals problem acm transactions programming languages systems vol :10.1.1.12.1697
pp 
july 
pg garcia molina recovery triple modular redundant database system technical report cs princeton university january 
pw peterson error correction codes nd edition mit press massachusetts 
po consensus presence timing uncertainty omission byzantine failures extended proceedings th annual acm symposium principles distributed computing 
rsa rivest shamir method obtaining digital signatures public key cryptosystems cacm pp :10.1.1.40.5588

se segall distributed network protocols ieee trans 
information theory pp 

sc schneider understanding protocols byzantine clock synchronization technical report cornell university august 
sd strong dolev byzantine agreement proceedings compcon spring 
sdc strong dolev cristian new latency bounds atomic broadcast proceedings th ieee real time systems symposium orlando 
strong skeen cristian handshake protocols th international conference distributed computing pp 
september 
