siggraph orlando july computer graphics proceedings annual conference series fast contact force computation rigid bodies david baraff robotics institute carnegie mellon university pittsburgh pa new algorithm computing contact forces solid objects friction 
algorithm allows mix contact points static dynamic friction 
contrast previous approaches problem computing contact forces transformed optimization problem 
need sophisticated optimization software packages eliminated 
systems friction algorithm proven considerably faster simpler reliable previous approaches problem 
particular implementation algorithm numerical programming quite feasible 

established viability analytical methods simulate rigid body motion contact 
situations involving bilateral constraints commonly referred equality constraints analytical methods require solving systems simultaneous linear equations 
bilateral constraints typically arise representing idealized geometric connections universal joints point surface constraints systems contact unilateral inequality constraints required prevent adjoining bodies 
turn linear equations arising system bilateral constraints augmented reflect unilateral constraints result general inequality constrained nonlinear minimization problem 
analytical techniques systems contact really catch graphics simulation community 
believe perceived practical theoretical complexities analytical techniques systems contact 
goals address concerns particular analytical methods systems contact practically implemented author specialists numerical analysis optimization 
methods simpler reliable faster previous methods systems friction systems friction 
goal extend improve previous algorithms computing contact forces friction 
simple fast algorithm computing contact forces friction 
restriction algorithm frictionless case equivalent algorithm described dantzig attributed dantzig electronic reprint 
permission granted copy part noncommercial provided title copyright notice appear 
electronic reprint fl cmu 
original printed fl acm 
author address may david baraff school computer science carnegie mellon university pa usa 
email baraff cs cmu edu solving linear complementarity problems 
intention reinvent wheel necessary understand dantzig algorithm works frictionless sytems going consider general solution algorithm propose deal friction 
give physical motivation dantzig algorithm discuss properties implementation section 
frictionless systems implementation dantzig algorithm compares favorably large scale sophisticated numerical optimization packages cited previous systems 
particular system unilateral constraints implementation tends require approximately times required solve square linear system size gaussian elimination 
importantly dantzig algorithm extensions systems friction sufficiently simple numerical programming implement true previously cited large scale optimization packages 
interactive systems bilateral constraints common reason moderately complicated interactive simulation collision contact achieved 
strongly believe algorithms interactive simulations contact friction practical 
support claim demonstrating known system interactive simulations involving contact correct model coulomb friction 

background motivation represents attempt compute friction forces analytical setting quadratic programming compute friction forces simplification coulomb friction model 
baraff proposed analytical methods dealing friction forces presents algorithms deal dynamic friction known sliding friction static friction known dry friction 
results dynamic friction comprehensive readily acknowledges method computing contact forces static friction gauss seidel iterative procedure reliable 
method required approximation dimensional systems planar systems resulted anisotropic friction 
results fully exploit earlier discoveries concerning systems dynamic friction static friction 
method computing contact forces dynamic static friction considerably robust previous methods 
method requires approximations dimensional systems simpler faster previous methods 
extremely surprised find implementation method applied frictionless systems large improvement compared large scale optimization software packages terms speed especially siggraph orlando july computer graphics proceedings annual conference series simplicity 
previous simulation systems frictionless contact know heuristic solution methods linear programming quadratic programming algorithms constrained linear squares algorithms 
cases numerical software required sufficiently complicated public domain commercially available software packages required 
problems ffl serious implementations linear programming codes common serious implementations solving linear systems 
serious implementations quadratic programming rarer 
ffl fair amount mathematical coding sophistication required interface numerical software package simulation software 
cases effort required efficient interface prohibitively high 
ffl packages obtained contained large number adjustable parameters numerical tolerances iteration limits uncommon certain contact force computations fail set parameters succeeding problem solvable software package unsolvable different package 
past offline motion simulation reliability vexing tolerable issue simulation fails run alter initial conditions slightly hoping avoid specific configuration caused difficulty modify software prior rerunning simulation 
approach clearly practical interactive setting 
ffl lines difficult isolate numerical problems simulation complexity software packages 
great effort put understanding internals code user faced black box 
desirable black box code bullet proof serious impediment code 
hurdles surprising analytical methods systems contact caught 
taught difficulties encountered sense 
computing contact forces numerical optimization translate specific problem contact force computation general problem numerical optimization 
translation loses specific structure original problem making solution task difficult 
approach take avoid possible abstracting specific problem general problem 
result algorithm solves narrower range problems general purpose optimization software faster reliable considerably easier implement 

contact model section define structure simplest problem deal system frictionless bodies contacting distinct points 
contact point bodies scalar denote relative acceleration bodies normal contact surface 
consider question impact assume relative normal velocity bodies contact zero 
adopt convention positive acceleration indicates bodies breaking contact correspondingly indicates bodies accelerating 
acceleration indicates bodies zero normal acceleration numerical specialists working numerical software capable creating simpler 
automatically assumed software slower comprehensive packages written experts field 
remain contact relative tangential acceleration may nonzero 
prevent interpenetration require contact point 
frictionless systems force acting bodies contact point normal contact surface 
denote magnitude normal force bodies scalar positive indicates repulsive force bodies negative indicates attractive force 
contact forces repulsive necessary condition 
frictionless contact forces conservative add condition contact point 
condition requires zero contact contact remains contact broken zero 
denote vector collection ith element vector collection 
general boldface type denotes matrices vectors ith element vector scalar written regular type 
symbol denotes appropriately sized vector matrix zeros 
vectors linearly related write af symmetric positive semidefinite psd vector column space ax vector 
matrix reflects masses contact geometries bodies reflects external inertial forces system 
instant time known quantities unknown interested solving 
problem determining contact forces problem computing vector satisfying conditions contact point 
call equation normal force conditions 
equation phrase problem determining suitable forms 
constrained nonnegative requirement equivalent requiring cancellation occur 
equation say satisfy conditions af af equation defines known linear complementarity problem lcp 
solution method computing contact forces formulate solve lcp equation 
compute contact forces considering conditions equation quadratic program qp equivalently say vector satisfying equation solution quadratic program min af subject ae af oe phrasing computation qp natural choice 
problem solving qp received attention problem solving lcp 
problems np hard general practically solved psd 
having transformed problem computing contact forces qp variety techniques available solving qp 
unfortunately moving optimization problem minimize af necessarily lose sight original condition contact point 
solving general harder siggraph orlando july computer graphics proceedings annual conference series problem really need 
developing algorithm prefer regard relationship terms separate conditions equation single constraint equation minimization equation 
section describe method solving equation practical implementation 
consider friction section 
frictionless systems section restriction algorithm computing contact forces friction frictionless case 
sketch proof correctness 
extend algorithm section handle static friction dynamic friction section 
description dantzig algorithm solving lcp excellent treatment lcp general 
algorithm outline dantzig algorithm solving lcp related pivoting methods solve linear quadratic programs 
major difference linear quadratic programming algorithms finding solution satisfies constraints problem af trying minimize objective function af 
contrast dantzig algorithm applied problem computing contact forces works follows 
initially contact points ignored set zero algorithm begins computing value satisfies normal force conditions equation worrying conditions holding algorithm computes value satisfies normal force conditions maintaining conditions 
may require modification algorithm continues fashion point conditions contact points satisfied algorithm determines possibly altering conditions hold conditions hold contact points algorithm terminates 
concrete imagine far computed values normal force conditions hold possibly nth contact point 
suppose set zero 
immediately solution satisfies normal conditions contact points 
suppose 
physical intuition tells currently problem nth contact force doing fair share 
increase reach point zero violating normal force conditions contact points 
increasing may change generally need modify variables increase goal seek strength just sufficient cause zero 
emphasize process takes place time interval simulation considering proper value assume specific instant time 
adjustments need increase simple calculate 
order contacts numbered arbitrary imagine current values value 
remember 
simplify bookkeeping employ disjoint index sets nc 
point algorithm kg similarly nc fk nc assumed nc 
algorithm attempt maintain similarly try maintain nc 
say ith contact point clamped nc say ith contact point 
ith contact point currently ignored 
unit increase increase adjust amount set nc wish maintain nc 
wish choose remaining collection defined af denotes collection 
intuitively picture force clamped contact point undergoing variation order maintain force contact remains zero 
modifications sort maintain invariant 
currently elements computing unspecified requires solving linear equations unknowns 
general vary size course algorithm 
point algorithm establishing conditions rth contact contain fewer elements 
need maintain conditions 
increase may find decreased zero 
point may necessary contact removing adding nc cause decrease 
conversely may find nc decreased value zero 
case wish clamp contact moving nc preventing decreasing negative 
process moving various indices nc exactly numerical process known pivoting 
start suitable values computing straightforward 
set nc solve choose smallest scalar increasing causes reach zero index move nc 
reached zero done change index sets nc loop back continue increasing describe process computing step size complete algorithm discuss properties 
pivot step relation vectors af continue example kg nc fk 
need compute determine large multiple add currently 
partition writing ff square symmetric matrices ff scalar need compute 
linear system form ff components need zero require equivalently solve siggraph orlando july computer graphics proceedings annual conference series solving equation compute ready find maximum step size parameter scale 
force ith contact point decreasing 
maximum step take forcing negative similarly nc acceleration decreasing maximum step limited wish exceed zero maximum step limited determine increase causes increase 
causes change index sets nc required change continue increase achieved zero 
pseudo code implementation entire algorithm described pseudo code 
main loop algorithm simply function compute forces nc drive zero function drive zero increases zero 
direction change force computed 
function determines maximum step size constraint responsible limiting nc moved meaning driven zero drive zero returns function drive zero nc nc goto nc nc nc goto implying return function computes 
write acc denote submatrix obtained deleting jth row column similarly acd denotes dth column element deleted vector represents change contact force magnitudes clamped contacts 
transfer reverse process elements removed dth column form acd 
assign element corresponding ith contact 
function set zero acc acd solve transfer return function returns pair maximum step size taken direction index contact point limiting step size function nc return clear algorithm terminates solution yield initially zero prevented decreasing zero termination termination 
step algorithm requiring substantial coding requires forming solving square linear system 
remarkably singular extremely rank deficient simulations submatrices encountered frictionless case singular 
consequence column space termination algorithm quickly sketch algorithm described terminate details supplied appendix examining algorithm critical steps solving computing step size algorithm fail compute 
symmetric psd nonsingular nonsingular exists 
singular submatrices considered algorithm singular long lies column space result system solved 
theoretical result 
actual practice singular possible complete proof somewhat involved 
central idea jth contact point considered represents redundant constraint adding singular negative need call drive zero similarly nc moving singular case tries decrease zero requiring placed essentially nonzero keeping negative having positive allowing remain outside siggraph orlando july computer graphics proceedings annual conference series roundoff errors algorithm may cause index enter resulting matrix singular 
rare occurrence practical problem 
appendix establishes vector column space submatrix arising index set singular equation conditioned easily solved standard factorization methods 
essence assert singular easily solved 
possible solve obtain real question termination depend call drive zero able force zero 
avoid bogged details assume nonsingular specific proofs deferred appendix additionally appendix discusses necessary extensions cover case singular 
singular versus nonsingular cases require slightly different proofs emphasize algorithm remains unchanged algorithm just described works positive definite positive semidefinite important question consider increasing amount increases change equation increase ff theorem shows positive definite ff positive 
increase long positive 
ff shows returns 
algorithm take steps size zero 
order return case nc 
theorems shows happen 
positive 
way reach zero drive zero takes infinite number steps result converging limit equal zero 
possibility ruled theorem appendix shows set clamped contact points repeated call drive zero 
drive zero iterate finite number times reaches zero 
implementation details algorithm just described simple implement requires relatively little code 
complicated part involves forming solving linear system involves straightforward bookkeeping indices nc correctly form distribute components 
important note call involve index set differs previous index set single element 
means linear system differ previous system single row column 
system solved independently example cholesky decomposition large problems efficient incremental approach 
keeping assertion easily implement algorithm describe note initial implementation simply gaussian elimination completely satisfactory 
anticipating developments section bother cholesky factorization performed significantly faster 
gill describe package called incrementally factors sparse matrix form lu lower symmetric psd cholesky factorization ll singular 
simply reliably computed possible way solving triangular upper triangle 
factorization dimension new row column added row column eliminated factorization new matrix recomputed quickly 
unfortunately coding effort large 
authors package kind provide modified version software treats dense matrix computes factorization la longer triangular 
dense case updated factorization obtained time altered 
modified version contains reasonably small amount code 
serious implementation highly recommend incremental factorization routine 
addition trivial algorithm handle standard bilateral constraints 
bilateral constraint introduce pair constrain zero letting positive negative 
constraints initially solve square linear system size compute compute initial values bilateral corresponding zero 
placed algorithm 
ignore index bilateral constraint care negative 
result bilateral stay bilateral zero 
exactly modification algorithm section 

static friction algorithm previous section considered constructive proof exists solution satisfying normal force conditions frictionless system 
algorithm section grew attempt prove conjecture systems static friction dynamic friction possess solutions 
conjecture false systems dynamic friction 
conjecture currently remains unproven 
prove algorithm computing static friction forces terminate constitute proof conjecture 
hand seen algorithm fail algorithm practical range simulations attempted far 
consider situation friction contact point 
friction force point acts tangential contact surface 
denote magnitude friction force ith contact ff magnitude relative acceleration tangent plane af denote magnitude normal force fn magnitude normal acceleration specify tangential acceleration friction force completely dimensional system need specify direction acceleration friction force tangent plane 
simplicity dealing dimensional systems 
contact point unit vector tangent contact surface unique choice sign 
dimensional system treat ff af signed quantities 
friction force magnitude ff denotes friction force ff acceleration magnitude af denotes acceleration af af ff sign friction force tangential acceleration point direction 
static friction occurs relative tangential velocity contact point zero friction called dynamic friction 
section consider static friction 
configuration objects initially rest static friction dynamic friction 
additionally order simulation world force velocity related mv static friction dynamic friction siggraph orlando july computer graphics proceedings annual conference series static friction conditions contact point static friction magnitude vf relative tangential velocity zero 
effect forces system produces af meaning condition vf maintained ff need satisfy fn ff fn scalar denotes coefficient friction contact point 
bother index contact points easily done 
tangential acceleration zero conditions ff demanding jff equal fn ff sign opposite af pattern section write fn ff af satisfy normal force conditions fn fn jff fn af ff af fn jff condition af fn jff forces ff magnitude fn af nonzero 
condition af ff forces af ff opposite sign means friction force opposes tangential acceleration 
call conditions equation static friction conditions specifically noted contact point said satisfy static friction conditions implies satisfaction normal force conditions 
approach taken previous attempts modeling static friction form optimization problem 
define quantity scalar fn jff fn problem min subject ae fn oe ae af ff jff fn oe computing contact forces manner appear practical 
algorithm outline believe better deal problem frictionless case number separate conditions 
consider static friction condition perspective 
state conditions af ff considering goal friction force keep tangential acceleration small possible restriction jff fn accordingly af nonzero insist friction force utmost af zero requiring friction force push hard possible opposite tangential acceleration 
reason find useful characterization essentially characterization employed section motivate development dantzig algorithm 
section assumed normal force conditions initially met contacts began fn 
resulted ann nonnegative immediately solution 
sense fn fault ann negative increased fn remedy situation 
exactly thing compute static friction forces 
suppose contacts system satisfy conditions static friction normal force condition holds nth contact point 
set ff consider ann nc fn static force condition trivially met jff fn happens satisfied static friction conditions jff fn nonzero characterization static friction increase magnitude friction force oppose tangential acceleration possible 
procedure essentially frictionless case 
loss generality assume nth contact point 
gradually increase ff maintaining static friction normal conditions contact points normal condition nth contact point 
increase ff point things happen reach point ff fn reach point 
case static friction conditions met 
maintaining static friction conditions established static friction conditions contact point need maintain 
maintain conditions fn fn index sets nc 
maintain conditions ff af variables introduce sets cf nc nc set cf analogous cf manipulate ff maintain af 
cf fact cf means maintaining af fact means maintaining 
contrast cf nc af ff fn long nc vary ff equal fn af zero move nc cf nc denotes set contacts ff positive upper bound fn conversely nc af ff fn long nc maintain condition ff fn move cf zero 
increasing fn increasing decreasing ff computing corresponding changes ff fn variables maximum possible step size exactly previous section 
frictionless case managed drive zero added static friction driving process stops afd reached zero insert cf process stopped jff fn add nc nc appropriate 
algorithm computing static friction forces dimensions discuss algorithm guaranteed terminate 
algorithm correctness section showed increased acceleration increased response guaranteeing sufficiently large increase achieve 
showed index set repeat forcing particular zero guaranteeing converge negative value 
showed steps size zero occur guaranteeing progress 
static friction show properties 
show start afd increase ff reach point ff fn reach point afd 
obvious 
fn nonzero ff satisfy static friction conditions means increase ff may requiring fn change 
fn increases faster ff ff reach value fn similarly necessarily case increasing ff cause afd increase 
reason relation acceleration variables force variables siggraph orlando july computer graphics proceedings annual conference series linear write af 
ann fn ff 
fn ff af collection variables 
long dynamic friction case symmetric psd 
unit increase ff solve fn ff exactly section 
require fn 
friction forces holds cf require af 
nc setting ff require ff fn maintain ff fn similarly nc require ff fn maintain ff fn side conditions ff fn prevent applying theorem section claiming afd increases ff increases 
fact situations increasing ff cause afd decrease 
holds fn prior working ff may find increasing fn establish normal force conditions may cause causes decrease 
possible drive ff fn infinitely far reaching stopping point 
fortunately 
theorem appendix states frictionless systems increase fn index set repeats 
exactly theorem trivially extended cover static friction 
encounter exactly sets nc cf nc nc driving fn ff variable 
show increasing fn eventually cause increase 
exactly argument shows increasing ff eventually causes afd increase 
theorem problem static friction fn hold initially large increase fn eventually force increase 
proof 
suppose arbitrarily increase fn causing increase 
positive definite light theorem happen side conditions ff fn hold implying nc nc 
index sets nc cf nc nc repeat finitely combinations sets encountered increasing fn means undergo finitely changes sets increasing fn eventually settle state increase fn increasing change occurring index sets 
definition index sets 
avoid change index sets fn sufficiently large step move nc 
logic requires nc fall zero 
yields fn friction forces cf af af ff 
nc af requiring af avoid having move nc cf fn ff fn ff 
yields af ff nc symmetric argument holds yielding af ff nc additionally nc nc af ff nonzero remove side condition ff fn add conditions ff af altering fn ff entitled apply theorem contradicting assumption nonincreasing 
af ff strictly zero 
combining fact fn af ff obtain fn af ff gives nonzero psd contradiction singular 
fn increased bound eventually causing increase 
possibility steps size zero occur running algorithm 
theorems may fail hold side conditions ff fn scenario possible fn decreases zero 
accordingly moved nc 
computing new index set may find ruled frictionless case theorem 
result step size zero taken moved back clearly algorithm settles loop alternately moving nc step size zero time 
rule behavior algorithm static friction 
current sticking point trying prove conjecture systems static friction solutions 
fortunately practical remedy problem 
attempting establish normal force static friction conditions point observe variable alternating nc nc cf nc cf remove nc cf nc nc 
temporarily give trying maintain normal static friction conditions ith contact point 
expense making negative progress sense achieved immediate goal establishing normal friction conditions particular contact point done sacrificing normal static friction conditions previously achieved contacts 
algorithm forced reestablish conditions points time 
contact points long necessarily keep static friction normal force conditions established prove process terminate 
algorithm large variety problems encountered situation algorithm went infinite loop 
speculate situation possible meaning systems static friction solutions requires extremely carefully constructed problem cause algorithm loop possibility necessarily imply fact solution 
third possibility course simply sufficiently exercised simulation system 
algorithm computing static friction forces describe necessary modifications dantzig algorithm handle static friction forces 
modifications increase complexity logical portion algorithm heart numerical code computing remains 
give description necessary modifications procedure algorithm 
modifications compute frictionless forces sets nc cf nc nc initially empty 
main loop continually scans contact point normal static friction conditions met 
points exist algorithm terminates drive zero called establish siggraph orlando july computer graphics proceedings annual conference series conditions 
note establish normal force conditions point establishing static friction conditions 
event algorithm gives contact point normal conditions established fn oscillating nc 
point fn normal conditions reestablished 
give static friction conditions ith contact point ff may nonzero 
discontinuously set ff zero break conditions contact points 
algorithm attempts reestablish static friction conditions drive ff zero simply instructing drive zero increase decrease ff ff 
modifications drive zero function ways index sets change 
limiting constraint returned index force driven moved represents normal force cf nc nc appropriate procedure returns 
moved nc represents normal force cf nc nc appropriate 
attempts move set just came previous step size zero removed index set 
point algorithm temporarily gives maintaining conditions jth contact point 
modifications modifications minor 
driving normal force set fn set ff depending way want drive force 
index sets establish set equations solve nc set fn require cf require af nc nc require ff fn modifications modifications obvious 
member index set compute minimum step size causes need change set 
driving index compute step size causes reach normal force afd ff fn friction force 
minimum step taken constraint responsible limit returned 
dimensional systems assuming system dimensional 
extension dimensions straightforward contact point denote vectors tangent contact surface pairs choosing local coordinate system denote pair tangent vectors 
denote relative tangential acceleration friction force respectively ith contact point 
dimensions coulomb friction law requires friction force partially opposed tangential acceleration optimization approach taken previous enforcing jff fn difficult jff fn nonlinear constraint 
constraint easily dealt algorithm 
place sets nc nc dimensional systems single set dimensions fn ff determining step size ff ff fn fn trivial 
dimensions computing fn fn trivial 
result easy augment move fn easy detect move back cf moves record direction friction force pointing 
long remains require friction force maintain direction entered moves back cf pair may point direction 
initially establish static friction conditions increase assuming moves reaches zero 
done adjust reaches zero moves reversing order considers rotating local coordinate system tangent plane may give rise different solutions method 
consequence condition equation completely specify direction friction tangential acceleration nonzero contact point 

dynamic friction relative tangential velocity contact point nonzero dynamic friction occurs opposed static friction 
regardless resulting tangential acceleration strength friction force satisfies jff fn direction force exactly opposite relative tangential velocity 
ff longer independent variable formulate equation replace occurences ff fn replacement results matrix unsymmetric possibly indefinite 
systems dynamic friction fail solutions contact force magnitudes requiring application impulsive force 
consequence losing symmetry definiteness theorems require symmetric psd fail hold 
remarkably turns fortunate development 
previously baraff algorithm computing friction forces impulses systems dynamic friction static friction intent treat problem nonexistence solution baraff method computing regular impulsive forces systems dynamic friction involved lemke algorithm solving lcp 
noted lemke algorithm terminate encountering unbounded ray 
algorithm just static friction requires absolutely modifications handle dynamic friction manner 
unbounded ray corresponds finding state drive variable fn ff infinity forcing af zero inducing change index sets nc cf nc nc occurs easily detected returns step size 
note theorem tells infinite step occur symmetric psd 
means infinite steps possible dynamic friction system 
algorithm finds solution point current force direction matches definition proposed baraff suitably applying impulsive forces systems dynamic friction 
result unify treatment dynamic static friction single algorithm 
note closing feel theoretical practical concern encountered infinite driving situations unrealistically large 
siggraph orlando july computer graphics proceedings annual conference series 
results method computing contact friction forces reliable fast 
pivoting algorithms example simplex algorithm linear programming worst case problems resulting exponential running times constructed 
empirically algorithm appears require calls drive zero systems friction 
real interest performance algorithm actual practice 
implemented dimensional algorithm static friction interactive setting dimensional algorithm offline simulation system 
frictionless systems solution algorithm compares favorably gaussian elimination partial pivoting 
matrix vector algorithm section takes times longer compute contact forces take solve linear system ax gaussian elimination 
compared best qp methods know algorithm runs times faster problems size 
systems friction comparable solution algorithm compare algorithm 
interactive simulations mechanisms shown figures 
fixed objects colored black 
objects different levels different colors orange purple green collision interaction 
white circles indicate bilateral pointto point constraint 
green circles indicate contact points 
systems simulated robustly consistent framerate hz sgi workstation 
research funded part nsf research initiation award foundation equipment 
michael saunders richard supplying dense version package clarifying technical historical points lcp 
appendix theorems appendix prove theorems necessary show algorithm frictionless contact forces section terminates 
simplicity consider case nonsingular sketch modifications necessary singular 
theorem symmetric positive definite matrix partitioned equation 
satisfies quantity ff positive 
proof 
principal submatrices positive definite ff positive definite submatrix ff positive definite 
applying cholesky factorization write ff dimensions respectively positive scalar 
note invertible invertible equation ff ff ff ff ff equation ff ff ff positive ff positive 
result applies invertible 
case may singular note cholesky factorization obtained may singular 
case exactly column space fact implies column space equation solution 
basic continuity principles shown singular case ff 
theorem call drive zero index set repeated 
proof 
suppose index set repeated call drive zero 
nc remains constant invocation drive zero step driving index added repeated nc repeated 
values time second time encountered denoted respectively 
af af intuition proof simple algorithm increased straight line done 
fact means increasing required change nc 
show happen inherent convexity involved contradicting fact repeated 
specifically nc 
nc vector increased direction nc vector fulfills conditions nc vector ay ith component equal zero encountered chosen 
achieved increasing direction drive zero terminated repeated 
means increasing direction necessary change nc prior reaching value range nc equations satisfied equations involve symmetric psd singular matrix exist arbitrarily small perturbation matrices ffl ffl symmetric positive definite nonsingular 
siggraph orlando july computer graphics proceedings annual conference series linear relations inequalities convexity equations satisfied value 
contradicts assumption set encountered twice call drive zero 
theorem extends algorithm static friction section 
claim index sets nc cf nc nc repeated driving force variable fn ff proof exactly difference extra conditions form ff fn may 
satisfy extra conditions vector satisfy properties 
means algorithm gone directly contradicting fact index sets repeated 
theorems guarantee frictionless algorithm takes steps size zero long system degenerate 
degenerate problem confused singular require algorithm changes index sets nc exactly time example normal forces decreased zero simultaneously 
degeneracy occurs possible number size zero steps taken 
section pages proves frictionless algorithm loop due degeneracy 
proving nondegenerate problem takes steps size zero relatively straightforward 
need show moves nc immediately increases 
result immediately move back step nonzero size 
similarly need show nc moves immediately increases 
theorem nondegenerate problem index moves nc immediately increases 
proof 
loss generality assume kth contact just moved nc 
computed solving system setting partitioned fi fi scalars 
yields wy fiy wy fiy caused decrease zero negative 
moves nc recompute need show new positive 
denote new values computed resolve 
nc set solve obtain equations new fi substituting equations wy fiy fi positive definite positive definite fi positive fi positive 
negative positive conclude 
theorem extends immediately case singular index sets encountered produce singular submatrix theorem nondegenerate problem index moves nc immediately increases 
proof 
proof constructed way proof previous theorem 
baraff 
analytical methods dynamic simulation non penetrating rigid bodies 
computer graphics proc 
siggraph volume pages 
acm july 
baraff 
curved surfaces coherence non penetrating rigid body simulation 
computer graphics proc 
siggraph volume pages 
acm august 
baraff 
issues computing contact forces rigid bodies 
algorithmica 
dantzig 
complementary pivot theory mathematical programming 
linear algebra applications 
pang stone 
linear complementarity problem 
academic press 
gill hammarling murray saunders wright 
user guide fortran package constrained linear squares convex quadratic programming 
technical report sol systems optimization laboratory department operations research stanford university 
gill murray saunders wright 
user guide fortran package quadratic programming 
technical report sol systems optimization laboratory department operations research stanford university 
gill murray saunders wright 
user guide fortran package nonlinear programming 
technical report sol systems optimization laboratory department operations research stanford university 
gill murray saunders wright 
maintaining lu factors general sparse matrix 
linear algebra applications 

numerical simulation time dependent contact friction problems rigid body mechanics 
siam journal scientific statistical computing 

design xmp linear programming library 
acm transactions mathematical software 
murtagh saunders 
minos user guide 
technical report sol systems optimization laboratory department operations research stanford university 
saunders 
personal communication 
september 
siggraph orlando july computer graphics proceedings annual conference series time lapse simulation sequence 
siggraph orlando july computer graphics proceedings annual conference series time lapse simulation sequence double action jack 
