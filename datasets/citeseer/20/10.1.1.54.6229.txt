functional data structures chris okasaki school computer science carnegie mellon university forbes avenue pittsburgh pennsylvania usa mail cs cmu edu efficient data structures studied extensively years 
nowadays programmer needs efficient data structure particular problem simply look number textbooks handbooks 
said ml haskell programmer 
imperative data structures adapted quite easily functional setting 
functional data structures difficult design implement imperative ones 
basic problems 
point view designing implementing efficient data structures functional programming destructive updates assignments staggering handicap tantamount master chef 
destructive updates dangerous misused tremendously effective properly 
certainly functional programmer expects reap substantial benefits giving destructive updates blind potential costs tradeoff 
second difficulty functional data structures expected flexible imperative cousins 
particular update imperative data structure typically accept old version data structure longer available update functional data structure expect old new versions data structure available processing 
data structure supports multiple versions called persistent data structure allows single version time called ephemeral 
functional programming languages curious property data structures automatically persistent 
imperative data structures typically ephemeral persistent data structure required imperative programmers surprised persistent data structure complicated asymptotically efficient ephemeral counterparts 
exercise 
list situations persistence useful imperative programmer 
research supported advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

spite difficulties researchers developed numerous functional data structures asymptotically efficient best imperative solutions problems 
tutorial explore efficient functional implementations common abstractions including fifo queues catenable lists mergeable heaps priority queues 
emphasis developing data structures achieve compromise simplicity efficiency practice 
notation source code standard ml extended primitives lazy evaluation type ff susp val delay unit ff ff susp val force ff susp ff primitives supported implementations standard ml including standard ml new jersey 
notational convenience write delay fn scope extends far right possible 
assume presence small streams library shown 
library far complete containing stream operations 
note cons operation supplied library strict lazy 
fact lazy operations library infix append reverse 
fifo queues stacks queues usually data structures studied computer science students 
typical imperative implementation unbounded stacks linked lists translates naturally functional setting 
typical imperative implementation unbounded queues linked lists uses destructive updates list 
queues simplest example data structure implementation functional setting substantially different implementation imperative setting 
reason functional queues widely studied 
minimal signature queues appears 
main operations snoc adds element rear queue head extracts element tail deletes element signature includes value empty representing empty queue predicate isempty 
practical queue library contain utility functions defined terms primitives 
signature stream sig type ff stream exception empty val empty ff stream val isempty ff stream bool val cons ff theta ff stream ff stream strict cons val head ff stream ff raises empty stream empty val tail ff stream ff stream raises empty stream empty val ff stream theta ff stream ff stream infix append val reverse ff stream ff stream structure stream struct datatype ff nil cons ff theta ff stream withtype ff stream ff susp exception empty val empty nil fun isempty case force nil true false fun cons cons fun head case force nil raise empty cons fun tail case force nil raise empty cons fun case force nil force cons cons fun reverse fun rev nil force rev cons rev force cons rev force empty fig 

small streams library 
signature queue sig type ff queue exception empty val empty ff queue val isempty ff queue bool val snoc ff queue theta ff ff queue val head ff queue ff raises empty queue empty val tail ff queue ff queue raises empty queue empty fig 

signature queues 
partial solution common implementation queues pair lists representing front portion queue representing rear portion queue reverse order 
datatype ff queue queue ff list theta ff list representation element queue head front list element queue head rear list 
locations accessed quickly 
fun snoc queue queue fun head queue fun tail queue queue happens attempt take head tail queue front list empty 
rear list empty queue empty raise exception 
element queue element rear list 
case reverse rear list install result new front list try 
fun head queue raise empty head queue head queue rev head queue fun tail queue raise empty tail queue tail queue rev tail queue queue note recursive calls second clauses head tail fall third clauses rev guaranteed nonempty 
easily optimize calls inlining appropriate code third clauses 
won bother disturbing inefficiency 
common ask head tail queue 
stands result reversing rear list twice 
prevent maintain invariant front list empty entire queue empty 
head operation need reverse rear list 
snoc operation modified obey invariant 
fun snoc queue queue snoc queue queue fun head queue raise empty head queue fun tail queue raise empty tail queue queue rev tail queue queue note wildcards 
know invariant front list empty rear list avoid redundant check wildcard 
somewhat cleaner way write code terms pseudo constructor called smart constructor enforces invariant 
called queue takes place real constructor queue verifies front list empty 
fun queue queue rev queue queue replace queue queue definitions snoc tail 
fun snoc queue queue fun tail queue raise empty tail queue queue note real constructor queue pattern matching 
complete source code implementation 
structure queue queue struct datatype ff queue queue ff list theta ff list invariant null implies null exception empty val empty queue fun isempty queue null fun queue queue rev queue queue fun snoc queue queue fun head queue raise empty head queue fun tail queue raise empty tail queue queue fig 

common efficient implementation queues 
implementation easy analyze traditional techniques amortization 
basic idea save credit snoc operation 
queue number credits equal length rear list credits pay reversing rear list front list empty 
argument see queue operation requires amortized time 
unfortunately traditional analysis techniques amortization developed imperative setting rely hidden assumption data structures ephemeral sequences operations data structures single threaded 
assumption routinely violated functional setting data structures automatically persistent 
section modify implementation queues support persistence efficiently introduce proof technique proving amortized bounds persistent data structures 
exercise 
show implementation queues takes greater amortized time operation constructing non single threaded sequence operations requires greater time execute 
efficient persistent queues queues efficient long single threaded fashion 
applications obey restriction general purpose queue library prefer implementation efficient persistently 
discussed lazy evaluation key integrating amortization persistence 
memoization implicit lazy evaluation allows shared different threads repeated thread 
term threads refers concurrency different paths data flow 
step modifying queues deal persistence streams lists 
simplify operations explicitly track lengths streams 
datatype ff queue queue ff stream theta int theta ff stream theta int note pleasant side effect maintaining length information trivially support constant time size operation 
strengthen invariant guarantee front stream long rear stream 
call balance invariant 
special case balance invariant implies front stream empty rear stream 
rear stream longer front stream perform rotation reversing rear stream appending front stream 
major queue operations fun snoc queue lenf lenr queue lenf cons lenr fun head queue lenf lenr lenf head raise empty fun tail queue lenf lenr lenf queue tail lenf gamma lenr raise empty pseudo constructor queue defined front list changed stream 
rear list remain list simplicity streams 
fun queue lenf lenr lenr lenf queue lenf lenr queue reverse lenf lenr empty complete code implementation appears 
structure queue queue struct datatype ff queue queue ff stream theta int theta ff stream theta int invariant jfj jrj exception empty val empty queue empty empty fun isempty queue lenf lenr lenf fun queue lenf lenr lenr lenf queue lenf lenr queue reverse lenf lenr empty fun snoc queue lenf lenr queue lenf cons lenr fun head queue lenf lenr lenf head raise empty fun tail queue lenf lenr lenf queue tail lenf gamma lenr raise empty fig 

efficient persistent queues 
exercise 
verify implementation queues takes time execute sequence operations exercise 
understand implementation deals efficiently persistence consider example 
queue front rear streams length tail gamma 
queue rotated tail operation reverse suspension created rotation forced tail operation 
reversal takes steps cost amortized sequence 
concerned cost reverse ignore cost append 
choose branch point repeat calculation 
note persistently 
times 
reverse executed 
depends branch point rotation 
suppose rotation 
fact suppose repeated branches single tail 
branches forces reverse suspension force suspension forced memoized 
reverse executed 
memoization crucial memoization reverse re executed time total cost steps operations amortize cost 
large result amortized cost operation memoization gives amortized cost operation 
possible re execute reverse 
simply take branch point just rotation 
tail branch repeats rotation creates new reverse suspension 
new suspension forced tail branch executing reverse 
different suspensions memoization help 
total cost reversals delta operations amortize cost yielding amortized cost operation 
key duplicate duplicate sequence operations amortize cost 
informal argument suggests queues require amortized time operation persistently 
formalize proof debit argument 
suspension allocate debits cover cost forcing suspension 
discharge debits operation 
prove force suspension discharged debits 
proof 
number debits ith node front stream cumulative number debits nodes including ith node 
maintain debit invariant min jf gamma jrj term guarantees debits node front stream discharged delta node may forced instance head operation 
jf gamma jrj term guarantees debits entire queue discharged streams equal length just rotation 
snoc operation cause rotation simply adds new element rear stream increasing jrj decreasing jf gamma jrj 
cause invariant violated node previously equal jf gamma jrj 
restore invariant discharging debit queue decreases subsequent cumulative debit total 
similarly tail operation cause rotation simply removes element front stream 
decreases jf jf gamma jrj importantly decreases index remaining node turn decreases 
discharging debits queue restores invariant 
consider snoc tail causes rotation 
just rotation guaranteed debits queue discharged rotation debits generated rotation 
jf jrj time rotation debits append debits reverse 
append function incremental step time delays rest place debit nodes 
hand reverse function monolithic begun runs completion place debits node node reversed stream 
debits distributed ae distribution violates invariant node node discharging debit node restores invariant 
proof uses debit argument style traditional credit argument 
debit arguments suitable analyzing persistent data structures single credit spent harm discharge debit 
debit arguments allow reason running time thread individually worrying inter thread dependencies 
intuition different threads amortize cost lazy operations separate sequences earlier discussion overlapping sequences earlier discussion 
case separate sequences debit discharged case overlapping sequences debit may discharged 
key force suspension know debits discharged 
memoization guarantees duplicated separate threads paid separately threads 
exercise output restricted deques 
extend queues cons operation adds element front queue rear 
data structure allows elements inserted front rear removed front called output restricted deque 
new operation interact balance invariant 
debit invariant 
exercise min queues 
min list list data structure additionally supports findmin operation returns list 
differs priority queue deletemin operation 
min lists implemented maintaining secondary list rightward minima 
words min list containing elements delta delta delta xn consist list xn secondary list min note min min min min cons implemented fun cons cons xs ys xs min hd ys ys ideas implement min streams style 
may assume elements integers 
careful append reverse operations lazy possible 
min streams implement min queues style 
operation take amortized time 
exercise deques 
double ended queue called deque supports insertion removal elements ends 
adapt implementation queues support deques making symmetric 
currently sources asymmetry 
balance invariant prevents rear stream getting long respect front stream 
deques prevent stream getting long respect 
particular constant maintain invariant jf jrj constraints allows deques size 
second rotations move elements queue front stream deques rotations divide elements equally front rear streams 
ideas implement deques style 
careful rotations lazy possible 
may need extend streams library extra operations 
debit argument prove deques require amortized time operation 
exercise worst case queues 
get queues run worstcase time amortized time systematically schedule execution suspension 
arrange suspension takes time execute force suspension snoc tail operation 
write rotation function entirely incremental doing step reverse step append 
may need extend streams library extra operations 
add new field type ff stream queue points stream node forced 
rewrite pseudo constructor queue force node advance pointer node 
show new stream field length jf gamma jrj 
take advantage fact eliminate length fields representation 
eliminating unnecessary overheads implementation queues asymptotically optimal ask better bounds time operation 
practice tends fairly slow 
reasons 
lazy evaluation slower strict evaluation need create suspensions 
compilers lazy languages recognize fact strictness analysis turn lazy evaluation strict evaluation possible 
lazy evaluation serves algorithmic purpose eliminated strictness analysis 
need lazy evaluation don need 
second implementation uses appends inefficient way 
append operation takes time proportional size left list stream 
maximum efficiency called right associative contexts 
example lists executing xs ys zs takes time proportional executing xs ys zs takes time proportional 
take snapshot front stream moment form delta delta delta reverse reverse delta delta delta reverse general appends left associative contexts results potentially quadratic behavior 
fortunately case streams longer earlier streams total number append steps linear 
append threaten asymptotic bounds implementation significantly increase constant factor 
exercise 
exercise determine overhead associated inefficient appends 
calculate number append steps executed building consuming queue size calls snoc followed calls tail 
repeat calculation assuming rotations performed jrj jf jrj constant implementation faster practice address issues 
replace streams combination ordinary lists short stream suspended lists 
drastically reduces number suspensions element suspended list 
help touched suspension operation arrange touch suspensions occasionally 
second appends short streams 
recall front stream queue form delta delta delta reverse reverse delta delta delta reverse writing rear stream decompose queue parts collection reverse previously reverse stream represent ordinary lists reverse suspended list 
eliminates vast majority suspensions avoids overheads associated lazy evaluation 
represent collection 
see collection accessed fifo order tempting represent queue 
collection small simpler just efficient represent stream 
doing reintroduce lazy evaluation overheads negligible 
new representation datatype ff queue queue ff list theta ff list susp stream theta int theta ff list theta int second integer tracks length integer tracks combined lengths suspended lists old balance invariant served purposes 
kept getting long kept empty 
new representation deal issues separately 
guarantee empty entire queue empty 
empty non empty remove suspended list force install result new second guarantee jrj jf jsj 
long add rev invariants enforced pseudo constructor queue turn calls second pseudo constructor queue 
fun queue lenr isempty queue empty lenr jrj queue force head tail lenr queue queue queue lenr lenr queue queue rev lenr second line queue install directly new reversing 
justified doing know contains single element rev operation called queue simply snoc streams defined fun cons empty general quite slow implement snoc terms append case know short inefficiency tolerable 
define major operations queues follows fun snoc queue lenr queue lenr fun head queue raise empty head queue lenr fun tail queue raise empty tail queue lenr queue gamma lenr complete code implementation shown 
exercise 
prove queue size jmj blog nc 
exercise 
repeat exercise new implementation 
structure queue queue struct datatype ff queue queue ff list theta ff list susp stream theta int theta ff list theta int exception empty val empty queue empty fun isempty queue lenr null fun cons empty fun queue lenr isempty queue empty lenr jrj queue force head tail lenr queue queue queue lenr lenr queue queue rev lenr fun snoc queue lenr queue lenr fun head queue raise empty head queue lenr fun tail queue raise empty tail queue lenr queue gamma lenr fig 

faster implementation queues 
exercise 
debit argument show implementation takes amortized time operation 
hint keep track debits stream nodes debits suspended lists separately 
allow debit stream node require suspended lists fully paid 
bibliographic notes hood melville gries pages proposed implementation queues 
burton proposed similar implementation restriction list non empty queue non empty 
burton combines head tail single operation need restriction support head efficiently 
proposed similar implementation deques 
hood melville gave complicated implementation queues supporting operations worst case time 
hood chuang goldberg extended implementation handle double ended case 
okasaki showed lazy evaluation simplify implementations retaining worst case bounds see exercise 
implementation simplification approach appearing kaplan tarjan proposed implementation functional deques entirely different technique known recursive slowdown 
catenable lists appending lists extremely common operation conceptually 
unfortunately appending lists slow 
instance discussed previous section left associative appends result quadratic behavior 
prevent programmers transform programs remove appends possible instance accumulating parameters 
possible design list data structure supported append known catenation concatenation constant time sacrificing existing constant time operations 
data structure called catenable list 
particular want implementation catenable lists supports operation constant time 
note cons eliminated favor unit operation creates singleton list cons xs simulated unit xs 
similarly snoc xs simulated xs unit data structure supports insertions removals front accurately called catenable output restricted deque 
signature catenable sig type ff cat catenable lists exception empty val empty ff cat val isempty ff cat bool val unit ff ff cat create singleton list val ff cat theta ff cat ff cat infix append val head ff cat ff raises empty list empty val tail ff cat ff cat raises empty list empty fig 

signature catenable lists 
consider simple solution append fast cost slowing head tail 
transform data structure recover efficient head tail operations 
partial solution simplest way append fast constructor datatype datatype ff cat empty unit ff app ff cat theta ff cat type binary leaf trees elements stored leaves left right 
unit simply call appropriate constructors 
head operation written naively fun head empty raise empty head unit head app head moment reflection reveals third clause head incorrect 
example head app empty unit raises exception returning way fix problem handle exception 
head app head handle empty head better solution insist trees formed disallowing occurrences empty beneath app nodes 
enforce having check empty viewed pseudo constructor app 
fun empty empty app naive version head correct inefficient 
particular takes time proportional length left spine path root leftmost leaf 
accept inefficiency 
tail cases 
little choice cases 
fun tail empty raise empty tail unit empty tail app unit fourth case tail app app choices tail app app app tail app tail app app tail app app choice deletes leftmost leaf leaving rest tree intact 
second choice dynamically applies associative rule left spine converting tree long left spine tree long right spine 
versions take amount time second choice drastically reduces cost subsequent operations 
fact successive tail operations choice frequently take quadratic time successive tail operations second choice take linear time see exercise 
second version 
complete code implementation appears 
structure cat catenable struct datatype ff cat empty unit ff app ff cat theta ff cat exception empty val empty empty fun isempty empty true isempty false fun unit unit fun empty empty app fun head empty raise empty head unit head app head fun tail empty raise empty tail unit empty tail app unit tail app app tail app app fig 

catenable lists binary leaf trees 
exercise 
prove executing successive tail operations catenable list size takes time 
hint consider number bad nodes bad node left child descendent left child 
exercise 
relying programmer refrain building app nodes containing empty build requirement type 
datatype ff tree unit ff app ff tree theta ff tree datatype ff cat empty nonempty ff tree modify implementation support new type 
discuss advantages disadvantages approach 
persistent catenable lists data structure efficient circumstances clearly efficient persistently 
example consider building tree long left spine repeatedly head tail tree 
combine lazy evaluation clever representation left spines obtain implementation requires amortized time operation 
consider left spine treated various list operations 
append operation adds new node top left spine head tail operations access leaf bottom left spine 
just operations supported queues 
left spine view binary leaf tree tree left spine binary leaf tree represented recursively element leaf bottom spine queue left spine views corresponding right children nodes spine 
shows binary leaf tree corresponding left spine view 
ae ae ae gamma gamma omega omega jr omega omega delta deltar ar jr gamma gammar omega omega jr ae ae ae delta deltar ar zr fig 

binary leaf tree left spine view 
structure implementing queues datatype left spine views written datatype ff cat empty cat ff theta ff cat queue type independently viewed type multiway tree elements stored node ordered left right preorder 
insist trees formed empty appears child queue cat node 
simply translating operations unit head binary leaf trees left spine views get fun unit cat empty fun empty empty cat cat snoc fun head empty raise empty head cat third clause links trees making second tree child tree 
translation tail function little trickier 
tree cat non empty discards links elements right left 
fun tail empty raise empty tail cat isempty empty defined fun size head head tail code assumes queues support constant time size operator easily rewritten isempty 
code viewed instance standard foldr schema 
provides foldr function rewritten fun foldr op illustrates effect tail operation 
theta theta theta theta theta theta theta theta theta theta theta theta delta delta delta tail theta theta theta theta theta theta theta theta theta theta theta theta fig 

illustration tail operation left spine views 
unit head operations clearly take worst case time 
constant amortized time queues previous section takes amortized time 
tail takes jqj time large 
reduce amortized time need change execute lazily 
alter datatype tree child queue suspended 
datatype ff cat empty cat ff theta ff cat susp queue written fun size force head link force head tail link expects second argument suspended 
fun link cat cat snoc types rewritten suspend second argument 
fun empty empty link complete code implementation appears 
written functor parameterized particular implementation queues 
functor cat structure queue catenable struct datatype ff cat empty cat ff theta ff cat susp queue exception empty val empty empty fun isempty empty true isempty false fun link cat cat snoc fun size force head link force head tail fun unit cat empty fun empty empty link fun head empty raise empty head cat fun tail empty raise empty tail cat isempty empty fig 

catenable lists lazy left spine views 
exercise 
implement cons snoc directly implementation terms unit 
prove tail take amortized time debit argument 
performs aside forcing suspensions show discharging debits tail suffices discharge debits associated suspensions forced 
proof 
number debits ith node tree cumulative number debits nodes including ith node total number debits nodes jtj gamma 
maintain invariants debits 
require number debits node bounded degree node degree 
sum degrees nodes non empty tree size tree implies total number debits tree bounded size tree jtj 
maintain invariant incrementing number debits node increment degree 
second insist bounded linear function particular linear function choose depth depth length path root node invariant called left linear debit invariant 
note left linear debit invariant guarantees debits node discharged time reaches root 
recall root suspended 
time force suspension suspended node new root 
show maintains invariants discharging single debit 
debit created append trivial suspension second argument 
increasing degree node immediately discharge new debit 
assume non empty jt note index depth cumulative debits node unaffected append depth depth nodes increase index increase depth accumulate total debits depth depth gamma 
depth need discharge debits maintain left linear debit invariant 
show tail maintains invariants discharging debits 
tail discarding root link children gamma right left 
partial result linking gamma link outermost suspended assign single debit root gamma 
note degree nodes increases 
assign debit root gamma call suspended call link 
degree node change immediately discharge final debit 
suppose ith node appears know depth consider quantities changes tail 
decreases element discarded 
depth node increases gamma see cumulative debits node increases gamma depth depth gamma gamma gamma gamma depth gamma discharging debits restores invariant total debits 
exercise 
exercise explores conversion functions lists catenable lists 
write function ff list ff cat runs amortized time 
write function flatten ff list list ff cat runs amortized time number empty lists original list 
bibliographic notes hughes investigated implementations catenable lists including ones similar 
support efficient head tail operations supplies single operation converting catenable list ordinary list 
comparable requiring appends precede heads tails 
kaplan tarjan gave functional implementation catenable lists support operations worst case time technique recursive slowdown 
shortly okasaki developed implementation 
implementation simpler kaplan tarjan approach supports operations amortized time worst case time 
heaps queues catenable lists usual imperative implementations translate functional setting 
heaps priority queues standard imperative solutions translate quite nicely 
section consider example leftist heaps 
section consider second example pairing heaps problematical 
gives minimal signature mergeable heaps 
note heaps polymorphic type elements fixed ordering relation elements 
heap data structures support efficient merge operation consider 
heap data structures typically support insert operation catenable lists eliminated operation favor unit operation insert simulated merge unit 
signature ordered sig type type ordered elements val leq theta bool total ordering relation signature heap sig structure elem ordered type heap exception empty val empty heap val isempty heap bool val unit elem heap create singleton heap val merge heap theta heap heap val findmin heap elem raises empty heap empty val deletemin heap heap raises empty heap empty fig 

signature heaps priority queues 
leftist heaps heap ordered tree root subtree contains minimum element subtree 
root heap ordered tree minimum element tree 
define height binary tree length right spine length rightmost path empty node 
leftist heaps heap ordered binary trees satisfy leftist property height left child height right sibling 
note right spine leftist heap shortest path root empty node 
exercise 
prove height leftist heap size log 
leftist heaps represented type datatype heap empty node int theta elem theta heap theta heap integer records length right spine 
unit findmin deletemin operations leftist heaps trivial 
fun unit node empty empty fun findmin empty raise empty findmin node fun deletemin empty raise empty deletemin node merge merge leftist heaps merge right spines way merge ordered lists 
swap children nodes merge path necessary restore leftist property 
swapping performed pseudo constructor node 
fun node empty node empty node empty node empty node node ra node rb ra rb node ra node rb merge may implemented fun merge empty merge empty merge node node elem leq node merge node merge complete code leftist heaps appears 
right spine leftist heap logarithmic height merge traverses right spines arguments merge takes log worst case time 
deletemin calls merge takes log worst case time 
unit findmin run time 
exercise 
implement insert directly unit merge 
exercise 
implement function elem list heap produces leftist heap unordered list elements time 
note naive approach folding insert list takes log time 
exercise weight biased leftist heaps 
weight biased leftist heaps alternative leftist heaps replace leftist property leftist property size left child size right sibling 
prove right spine weight biased leftist heap size length log 
functor leftist structure ordered heap struct structure elem datatype heap empty node int theta elem theta heap theta heap exception empty val empty empty fun isempty empty true isempty false fun node empty node empty node empty node empty node node ra node rb ra rb node ra node rb fun unit node empty empty fun merge empty merge empty merge node node elem leq node merge node merge fun findmin empty raise empty findmin node fun deletemin empty raise empty deletemin node merge fig 

leftist heaps 
modify implementation obtain weight biased leftist heaps 
currently merge operates passes top pass consisting calls merge bottom pass consisting calls node 
modify merge weight biased leftist heaps operate single top pass 
advantages top version merge lazy environment 
concurrent environment 
pairing heaps pairing heaps heap ordered multiway trees defined datatype datatype heap empty node elem theta heap list insist pairing heaps formed empty occur child list node 
unit findmin operations trivial 
fun unit node fun findmin empty raise empty findmin node cs merge operation node larger root leftmost child node smaller root 
fun merge empty merge empty merge node cs node ds elem leq node cs node ds pairing heaps get name deletemin operation 
deletemin discards root merges children passes 
pass merges children pairs left right child second third fourth 
second pass merges remaining trees right left 
coded concisely fun empty rest merge merge rest deletemin simply fun deletemin empty raise empty deletemin node cs cs complete code implementation 
practice pairing heaps fastest imperative priority queues 
pairing heaps simplest priority queues data structure choice applications 
surprisingly tight bounds pairing heaps known 
clearly unit findmin merge run worst case time deletemin take worst case time 
conjectured amortized running time merge deletemin logn respectively true imperative implementation amortized bound clearly false presence persistence 
suppose call deletemin pairing heap node cs 
result simply cs 
suppose merge pairing heaps root roots result node cs 
call deletemin duplicate cs 
cope persistence prevent duplicated 
turn lazy evaluation 
heap list represent children node heap susp 
suspension equal cs 
operates pairs children extend suspension children 
node contain extra heap field contain child 
children functor pairing structure ordered heap struct structure elem datatype heap empty node elem theta heap list exception empty val empty empty fun isempty empty true isempty false fun unit node fun merge empty merge empty merge node cs node ds elem leq node cs node ds fun empty rest merge merge rest fun findmin empty raise empty findmin node cs fun deletemin empty raise empty deletemin node cs cs fig 

pairing heaps 
number children extra field empty 
field number children odd call odd field 
new datatype datatype heap empty node elem theta heap theta heap susp usual unit findmin operations trivial 
fun unit node empty empty fun findmin empty raise empty findmin node previously merge operation simple deletemin operation complex 
situation reversed complexity shifted merge set appropriate suspensions 
deletemin simply fun deletemin empty raise empty deletemin node merge force define merge steps 
step checks empty arguments compares arguments see smaller root 
fun merge empty merge empty merge node node elem leq link link second step embodied link helper function adds new child node 
odd field empty child placed odd field 
fun link node empty node new child paired child odd field added suspension 
words extend suspension cs cs 
observe cs merge merge cs merge merge force cs merge merge force second clause link may written fun link node node empty merge merge force complete code implementation 
deals gracefully persistence implementation pairing heaps relatively slow practice overheads associated lazy evaluation 
entirely lazy language haskell data structures pay overheads regardless gain benefit lazy evaluation implementation competitive 
exercise 
design experiment test implementation really support merge amortized time deletemin logn amortized time non single threaded sequences operations 
bibliographic notes leftist heaps invented crane current form knuth pages 
nez pe na developed functional implementation leftist heaps similar 
fredman sedgewick sleator tarjan introduced pairing heaps conjectured insert merge run amortized time deletemin runs logn amortized time 
stasko vitter proved bounds insert deletemin fact hold variant pairing heaps consider merge operation 
studies shown pairing heaps fastest implementations priority queues practice 
implementations priority queues adapted easily functional setting 
example king okasaki described functional implementations binomial queues 
okasaki functor pairing structure ordered heap struct structure elem datatype heap empty node elem theta heap theta heap susp exception empty val empty empty fun isempty empty true isempty false fun unit node empty empty fun merge empty merge empty merge node node elem leq link link link node empty node link node node empty merge merge force fun findmin empty raise empty findmin node fun deletemin empty raise empty deletemin node merge force fig 

persistent pairing heaps 
modified binomial queues obtain efficient functional implementation supports findmin insert merge worst case time deletemin logn worst case time 
closing remarks efficient functional implementations common abstractions fifo queues catenable lists mergeable heaps 
useful practice particularly applications requiring persistence implementations illustrate techniques functional data structure design 
imperative data structures easily adapted functional languages 
seen example leftist heaps data structure essentially ml pairing heaps easily translated functional language needs non trivial modifications handle persistence efficiently 
remaining data structures fifo queues catenable lists redesigned scratch usual imperative solutions completely unsuitable functional implementations 
functional data structures interest functional programmers 
functional languages provide convenient framework designing persistent data structures 
desired data structures implemented imperative languages 
fact problems catenable lists best known persistent solutions designed exactly way 

stephen adams 
efficient sets balancing act 
journal functional programming october 

gerth st chris okasaki 
optimal purely functional priority queues 
journal functional programming december 
appear 

warren burton 
efficient functional implementation fifo queues 
information processing letters july 

cho sahni 
weight biased leftist trees modified skip lists 
international computing combinatorics conference page june 

chuang benjamin goldberg 
real time deques turing machines purely functional programming 
conference functional programming languages computer architecture pages june 

clark allan crane 
linear lists priority queues balanced binary trees 
phd thesis computer science department stanford university february 
available stan cs 

james driscoll neil daniel sleator robert tarjan 
making data structures persistent 
journal computer system sciences february 

michael fredman robert sedgewick daniel sleator robert tarjan 
pairing heap new form self adjusting heap 
algorithmica 

david gries 
science programming 
texts monographs computer science 
springer verlag new york 

robert hood 
efficient implementation high level programming language constructs 
phd thesis department computer science cornell university august 
cornell tr 

robert hood robert melville 
real time queue operations pure lisp 
information processing letters november 

rob 
symmetric set efficient list operations 
journal functional programming october 

john hughes 
novel representation lists application function reverse 
information processing letters march 

john hughes 
design pretty printing library 
international spring school advanced functional programming techniques volume lncs pages 
springer verlag may 

douglas jones 
empirical comparison priority queue event set implementations 
communications acm april 

haim kaplan robert tarjan 
persistent lists catenation recursive slow 
acm symposium theory computing pages may 

david king 
functional binomial queues 
glasgow workshop functional programming pages september 

donald knuth 
searching sorting volume art computer programming 
addison wesley 

andrew liao 
priority queue applications revisited 
algorithmica 

robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge massachusetts 

bernard moret henry shapiro 
empirical analysis algorithms constructing minimum spanning tree 
workshop algorithms data structures volume lncs pages 
springer verlag august 

chris okasaki 
amortization lazy evaluation persistence lists catenation lazy linking 
ieee symposium foundations computer science pages october 

chris okasaki 
simple efficient purely functional queues deques 
journal functional programming october 

chris okasaki 
role lazy evaluation amortized data structures 
acm sigplan international conference functional programming pages may 

david schmidt 
detecting global variables denotational specifications 
acm transactions programming languages systems april 

john stasko jeffrey vitter 
pairing heaps experiments analysis 
communications acm march 

robert tarjan 
amortized computational complexity 
siam journal algebraic discrete methods april 
article processed macro package llncs style 
