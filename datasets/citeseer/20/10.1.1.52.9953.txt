efficient distance computation non convex objects sean quinlan robotics laboratory computer science department stanford university describes efficient algorithm computing distance non convex objects 
objects modeled union set convex components 
model construct hierarchical bounding representation spheres 
distance objects determined computing distance pairs convex components preexisting techniques 
key efficiency simple search routine uses bounding representation ignore possible pairs components 
efficiency improved accepting relative error returned result 
empirical trials examine performance algorithm 

computing distance objects common problem robotics 
mathematical model objects find point object distance points minimized 
object robot object union obstacles environment information describes close robot collision 
distance computation real time collision avoidance real time path modification optimal path planning 
previous distance computation problem focused convex objects 
describes efficient algorithm pairs line segments 
gilbert bobrow lin canny algorithms find distance convex polyhedra 
algorithms iteratively finds pairs points object distance points monotonically converges minimum 
algorithms rely heavily properties convex objects appears difficult extend directly non convex case 
compute distance non convex objects break object convex components algorithms determine distance components 
distance objects smallest distance pair convex components 
naive implementation examines pairs complexity nm number components objects 
collision detection related distance computation objects collision distance objects zero 
collision detection extensively robotics applications path planning computer graphics physical modeling 
applications collision detection consumes significant percentage execution time research directed finding efficient algorithms 
related approaches efficient collision detection hierarchical models bounding representations 
hierarchical model proposed describes object various levels detail 
collision detection algorithm uses different levels detail reduce number components examined 
similarly bounding representations approximately model object simple primitives rectangles 
efficient algorithms described baraff determine collision occurred bounding representation components original model examined 
efficient algorithm distance computation non convex obstacles 
approach builds research collision detection convex distance computation 
objects described set convex components refer description underlying model 
model build hierarchical bounding representation spheres approximates object 
search routine examines hierarchical bounding representation object determines pairs components compare convex distance algorithm 
experimental results show small fraction possible pairs compared avoiding nm complexity naive implementation 
drastically increase efficiency algorithm propose computing distance objects relative error 
idea applications acceptable partially underestimate distance objects 
limit error reported distance exact distance user specified fraction exact distance magnitude error reduced objects approach incorrectly report collision 
relative error exact distance computation collision detection extremes problem 
user specifies zero relative error compute exact distance 
conversely acceptable relative error approaches percent value returned distance computation meaningless value zero returned objects intersect 
providing continuum extremes enables applications gain benefits distance information efficiency collision detection 
remainder divided sections 
describe bounding representation build underlying model 
examine time build bounding representation discuss done precomputation 
describe search routine determine distance objects 
examine efficiency algorithm results empirical trials 
conclude summary main ideas consequence 

hierarchical bounding representation computing distance objects underlying model objects build hierarchical bounding representation 
version algorithm described assumes underlying model surface representation consisting set convex polygons 
assumption fundamental extending approach representations difficult 
surface representation implies detect collision object completely contains object situations avoided applications 
bounding representation spheres 
sphere simplest geometric solid specified position vector radius 
calculate distance spheres require additions multiplications square root 
primitives ellipsoids may better approximate components underlying model feel simplicity sphere preferred bounding shape 
collision detection algorithm del uses spheres build bounding representation 
bounding representation consists approximately balanced binary tree 
node tree contains single sphere tree properties union leaf spheres completely contains surface object sphere node completely contains spheres descendant leaf nodes 
idea bounding representation follows 
leaf spheres closely approximate surface object 
interior nodes tree represent approximations descendant leaf spheres 
sphere interior node determine lower bound distance descendant leaf nodes object surface 
nodes close root tree represent leaf nodes coarse resolution 
conversely nodes near bottom tree closely approximate shape leaf spheres 
tree represents hierarchical description object 
step building tree cover object surface small spheres 
spheres leaf nodes tree 
underlying model object set convex polygons cover surface cover polygon 
covering convex polygon done process similar scan conversion computer graphics 
regular grid equal sized spheres covers polygon center sphere lying plane polygon 
addition enable search routine determine convex components compare label leaf sphere polygon created 
covering object small spheres divide conquer strategy build interior nodes tree 
set leaf nodes divided approximately equal subsets 
build tree subsets combined single tree creating new node subtrees children 
subtrees built recursively calling algorithm set consists single leaf node 
node sphere contains spheres descendent leaf nodes represents approximation leaves 
children node intended represent slightly accurate approximation leaves 
maximize improvement approximation desire split set leaf nodes subsets bounding sphere subset small 
optimal method splitting set leaf nodes process simple efficient effective 
divide set leaf node subsets compute bounding box aligned object coordinate frame contains centers leaf spheres 
bounding box determining minimum maximum value coordinates leaves position vectors 
select axes bounding box longest divide leaf nodes average value axis discriminant 
resulting subset compact contain approximately equal numbers elements 
dividing set subsets build trees subset recursively invoking algorithm create new node subtrees children 
remains determine bounding sphere contains descendant leaf spheres 
obvious way compute smallest sphere contains set spheres heuristic methods select smaller spheres 
method finds bounding sphere contains spheres children nodes induction descendant leaf nodes 
position size sphere determined optimally uniquely bounding spheres details trivial included 
second method directly considers leaf spheres 
select center bounding sphere examine descendant leaf spheres determine minimum radius required 
selection bounding sphere center done average position centers leaf spheres calculated process dividing leaf spheres 
method works near leaves tree second methods produces better results closer root 

bounding tree object 
attempts illustrate bounding tree generated algorithm 
due difficulty visualizing dimensional objects show analogous dimensional version 
object polygon approximation letter shown 
depicts leaf spheres cover outline object 
resulting bounding tree levels 
shows level shows root tree 

execution time bounding tree expected approximately balanced 
leaf nodes expect interior nodes depth tree logn 
time taken split set nodes time needed form bounding sphere order complexity number leaf nodes descending ith node 
close look execution time algorithm reveals expected execution time nlogn worst case 
worst case execution time reduced nlogn median average partition set 
median classic algorithm simply perform initial sort leaf nodes axes carry additional bookkeeping 
disadvantage algorithms higher constant factor expected execution time 
close analogy drawn relative benefits quicksort worst case performance versus merge sort worst case nlogn quicksort preferred faster expected execution time 
applications building bounding representation performed precomputation step 
objects rigid bodies compute bounding tree object local coordinate frames 
computing distance objects specific positions orientations augment tree corresponding transformation matrix describing positions object respect global coordinate frame 
node search routine node sphere mapped tree transformation matrix 
mapping done node search routine examine small fraction total nodes tree mapping nodes search result lower efficiency 
similar scheme devised object consists rigid bodies 
tree built rigid body precomputation step 
configuration rigid bodies build meta tree leaf node rigid body 
algorithm building meta tree identical algorithm individual rigid body trees 
leaf node corresponds root tree rigid body contains transformation matrix needed map body local coordinate frame global frame 
bounding sphere leaf node bounding sphere root rigid body tree mapped global frame 
fashion construction relatively small tree need done distance computation 
search routine traverses tree manner node mapped global frame needed 

computing distance objects section describe algorithm compute distance objects 
mentioned goal algorithm compute distance user specified relative error aid presentation describe version algorithm error 
compute exact distance objects need find pair points object distance points equal distance pair 
implementation describe object surfaces set convex polygons assume object completely contain object find distance objects finding pair polygons distance polygons equal distance pair 
distance polygons computed convex distance algorithm 
overview algorithm compute distance objects follows 
initially set infinity 
search routine attempts show objects distance apart 
suppose search finds polygons underlying model apart initial value difficult 
polygons intersect know distance objects zero done 
set distance polygons continue search new value eventually search shows objects distance apart objects intersect 
key algorithm able show objects distance apart examining possible pairs polygons 
polygon covered set leaf nodes bounding tree need examine pairs polygons corresponding pair leaf spheres distance apart 
course examine possible pairs leaf spheres gained hierarchical structure bounding tree enables avoid situation 
search routine finds pairs leaf nodes distance apart 
search examines pairs nodes depth manner starting root nodes trees 
distance nodes spheres greater equal current value structure bounding trees know distance sets descendant leaf spheres greater equal ignored 
nodes apart examine children nodes 
cases consider 
nodes interior tree split nodes children recursively search pairs consisting child node split 
deciding node split heuristic splitting node larger associated sphere 
leaf spheres assumed roughly size expect node smaller sphere closely approximate shape underlying surface information surface obtained splitting larger sphere 
subsequent recursive searches examine pair nodes spheres closer 
heuristic aids search quickly lowering value resulting fewer nodes having searched 
case interior node leaf node interior node split 
order subsequent searches 
case leaf spheres distance apart underlying model examined 
leaf sphere labeled polygon covers 
distance polygons computed available distance algorithms convex objects 
case implementation algorithm developed gilbert 
distance polygons new minimum 
distance zero polygons intersect know distance objects zero search need continue 
set new distance continue search 
polygon may covered leaf spheres possible search routine may compute distance pair polygons multiple times 
multiple identical computations unnecessary record pairs polygons examined computing distance polygons check computation previously done 
due large number possible pairs polygons record information hash table 
search routine modified included notion relative error 
modified algorithm user specifies relative error calculate distance ad 
note equal zero equals zero incorrectly report collision 
implement modified algorithm search routine show objects distance apart 
initial value set infinity exact case 
find polygons closer apart set fraction distance 
completing search know objects apart 
addition true distance objects obviously equal distance polygons set shown error meets relative error specification 

empirical trials demonstrate performance distance computation algorithm results empirical trials 
nature algorithm performance depends factors shape objects underlying representation specified relative error distance objects accuracy bounding tree factors depend application distance algorithm difficult general statements performance 
chosen scenario examined performance respect factors 
hopefully results give reasonable impression behavior algorithm 
reported execution times implementation decstation 
scenario experiments performed determining distance chess pieces 
chess pieces king queen rook bishop knight pawn randomly placed dimensional space 
chess piece determine distance union pieces 
represents typical configuration chess pieces 

typical configuration chess pieces 
model pieces designed randy brown publicly available ftp wustl edu 
piece described bounding representation consisting roughly triangles 
pieces non convex detailed features roughly units high 
worth noting naive implementation computing distance chess piece pieces examine possible pairs triangles 
precomputation step built bounding tree chess pieces 
experiments set radius leaf spheres units resulting total leaf nodes 
smaller leaf size increase number nodes accuracy bounding tree 
result increase search time decrease number polygon comparisons 
net effect change depends situation case units reasonable size 
bounding trees pieces built seconds 
objects placed random position orientation 
orientation selected uniform distribution orientations 
position vector selected uniform distribution cube measuring units sides 
point graphs represent average random positions 
performing distance computation built meta tree chess pieces compared current piece 
tree contains leaf nodes time build tree negligible 
graph examines effect varying relative error 
smaller relative errors effectively correspond computing exact distance objects 
cases number comparisons nodes triangles far possible 
relative error increased number comparisons drops dramatically 
approximately orders magnitude improvement relative error specified 
search size percent relative error graph 
search size vs relative error nodes triangles current implementation examine pairs nodes second compute distance triangles second 
relative error average execution time milliseconds 
speculate execution time comparable performance collision detection algorithm advantage obtain considerable distance information 
objects get closer expect search routine examine nodes triangles 
graph depicts relationship relative error 
seen algorithm runs lot slower objects close 
effect average time perform distance computation depends distribution distances application 
note far left points corresponds configurations chess piece intersected pieces 
search size distance objects model units graph 
search size vs distance objects intersection nodes triangles graph examines effect increasing amount detail describe chess pieces 
polygonal model pieces perform experiment assuming leaf spheres bounding representation exactly describe object 
underlying model build bounding trees search routine 
varying radius leaf spheres vary detail description 
seen number nodes searched appears proportional log number leaf spheres 
encouraging detailed model object little affect execution time 
results performed relative error 
unfortunately relationship hold small relative errors 
search size total number leaf nodes graph 
search size vs number leaf nodes 
combination hierarchical bounding representation simple search routine convex distance algorithm appears powerful framework building efficient distance algorithm non convex objects 
notion relative error enables exact distance computation collision detection unified extremes single problem 
accepting reasonable relative error hope achieve performance collision detection algorithm obtaining useful distance information 
efficient distance computation opens possibility modifying applications currently employ collision detection 
distance computation provides information close objects collision possible reason rigorously collision free motion objects 
capability difficult consider question configuration objects collision motion objects may bring contact 

khatib real time obstacle avoidance manipulators mobile robots international journal robotics research pp 
spring 

quinlan khatib elastic bands connecting path planning control proc 
ieee international conference robotics automation atlanta 

bobrow optimal robot plant planning criterion ieee journal robotics automation pp 
august 

fast computation distance line segments information processing letters pp 
august 

gilbert johnson keerthi fast procedure computing distance complex objects threedimensional space ieee journal robotics automation april 

bobrow direct minimization approach obtaining distance convex polyhedra international journal robotics research pp 
june 

lin canny fast incremental distance calculation proc 
ieee international conference robotics automation pp 
april 

latombe robot motion planning kluwer academic publishers boston 

baraff analytical dynamic simulation rigid bodies computer graphics proc 
siggraph pp 
july 

hierarchical object models efficient anti collision algorithms 

baraff rigid body simulation siggraph course notes july 

del serna new representation collision avoidance detection proc 
ieee international conference robotics automation pp 
may 

rogers procedural elements computer graphics mcgraw hill 

aho hopcroft ullman data structures algorithms addison wesley reading 

preparata shamos computational geometry springer verlag new york 
