primal dual methods vertex facet enumeration david bremner department mathematics university washington seattle bremner math washington edu fukuda department mathematics swiss federal institute technology lausanne institute operations research swiss federal institute technology zurich switzerland fukuda math ethz ch institute theoretical computer science swiss federal institute technology zurich switzerland inf ethz ch march convex polytope represented intersection finite set halfspaces convex hull vertices 
transforming halfspace respectively vertex vertex respectively halfspace representation called vertex enumeration respectively facet enumeration 
open question algorithm problems equivalent geometric duality polynomial input size output size 
extend known polynomially solvable classes polytopes looking dual problems 
dual problem vertex facet respectively enumeration problem facet vertex enumeration problem polytope input output simply interchanged 
particular class polytopes fixed algorithm transformation may easier dual 
propose new class algorithms take advantage phenomenon 
loosely speaking primal dual algorithms solution easy direction oracle help solve seemingly hard direction 
polytope bounded intersection finite set halfspaces vertices polytope feasible points lie interior line segment feasible points 
polytope represented intersection non redundant set halfspaces convex hull vertices 
research supported nserc canada fcar qu ebec mcconnell foundation 
problem transforming called vertex enumeration transforming called facet enumeration convex hull algorithm said polynomial time solve instance bounded polynomial size input output 
consider input respectively output size number real rational numbers needed represent input respectively output particular consider dimension constant 
assume single arithmetic operation takes constant amount time 
successively polynomial algorithm kth output generated time polynomial input size equal cardinality output 
clearly successively polynomial algorithm polynomial algorithm 
assume polytope full dimensional contains origin interior conditions vertex enumeration facet enumeration polynomially equivalent existence polynomial algorithm problem implies problem 
polynomial algorithms see known strong assumptions restrict input polytopes simple case vertex enumeration simplicial case facet enumeration 
open exists polynomial algorithm general 
extend known polynomially solvable classes looking dual problems 
dual problem vertex facet respectively enumeration problem facet vertex enumeration problem polytope input output simply interchanged 
particular class polytopes fixed algorithm transformation may easier dual 
tempted explain possible asymmetry observing standard assumption 
dual problems nondegenerate vertex face enumeration problems harder 
generally complexities primal dual problem distinct 
show certain sense primal dual problems complexity 
precisely show theorem successively polynomial algorithm vertex facet respectively enumeration problem hereditary class problems successively polynomial algorithm facet vertex enumeration problem class hereditary class contains subproblems instance class 
propose new class algorithms take advantage phenomenon 
loosely speaking primal dual algorithms solution easy direction oracle help solve seemingly hard direction 
general result relating complexity primal dual problems known polynomial algorithms primal nondegenerate case arrive polynomial algorithm vertex enumeration simplicial polytopes facet enumeration simple polytopes 
show refine algorithm yield algorithm time complexity competitive algorithms known primal nondegenerate case 
published investigation dual nondegenerate case authors aware peter victor klee 
approach easily understood terms vertex enumeration consists intersecting constraints assumption merely simplify discussion 
easily analyze complexity algorithm primal dual framework binary representation model general binary complexity depends associated base algorithm 
discuss assumptions section 
defining hyperplane removing redundant constraints finding vertices lying facet brute force method 
david avis private communication independently observed method extended polytope facets simple nearly simple polytopes 
method klee requires solving linear programs number input halfspaces remove redundant constraints 
approach rely polynomial solvability linear programming interior point known case facet enumeration 
notation start defining notation 
recall respectively nonredundant halfspace respectively vertex description jh jv dimension facets intersection bounding hyperplanes denote vector zeros length ones length respectively 
treat sets points matrices interchangeably convenient rows matrix elements corresponding set 
row column vectors ab denote inner product assume origin interior polytope facet defining inequality written hx vector vector gamma respectively denote set points hx hx hx respectively 
identify halfspace associated inequality hx danger confusion 
denote polyhedron hx similarly mean matrix hx set points mean conv similarly set halfspaces mean 
say valid set points hx valid inequality extensive duality convex polytopes follows 
proper faces convex polytope intersection set facets 
adding improper faces polytope empty set faces form lattice ordered inclusion 
polytopes said combinatorially equivalent face lattices isomorphic dual face lattices anti isomorphic isomorphic direction inclusion reversed 
known see 
proposition conv polytope int xy polytope dual int primal dual algorithms section consider relationship complexity primal problem complexity dual problem vertex facet enumeration 
fix primal problem facet enumeration rest results interpreted terms vertex enumeration 
convenience assume input polytope full dimensional contains origin interior point 
easy see loss generality case facet enumeration case vertex enumeration need solve linear program find interior point 
call family gamma polytopes facet hereditary gamma ae bounded gamma 
main idea summarized theorem 
theorem successively polynomial vertex enumeration algorithm family polytopes successively polynomial facet enumeration algorithm family 
simple polytopes necessarily facet hereditary simple polytope perturbed symbolically lexicographically combinatorially equivalent polytope facet defining halfspaces general position arrangement facet inducing hyperplanes defined polytope simple 
family polytopes facet inducing halfspaces general position obviously facet hereditary 
corollary successively polynomial algorithm facet enumeration simple polytopes vertex enumeration simplicial polytopes 
proof theorem constructive simple algorithm 
algorithm takes input set points subset ae bounded 
show compute set halfspaces 
algorithm cur cur find gamma cur cur endwhile return cur step algorithm maintain invariant conv cur 
algorithm terminates know cur follows cur conv main steps algorithm labeled 
vertex cur nv witness sense vertex facet discovered defining halfspace cuts precondition theorem exists successively polynomial algorithm enumerate vertices cur follows time polynomial jv find jv vertices cur discover cur discover jv vertices vertices witness 
order find facet cutting witness step need solve separating hyperplane problem point convex set 
separating hyperplane problem solved linear program maximize vy subject 
basic optimal solution solution corresponding vertex polar polytope linear program desired separating halfspace 
linear programming algorithms polynomial bit size input known polynomial jv need theorem 
turns halfspace description convex hull union sets solve separating hyperplane problem simpler algorithm 
rest section organized follows 
section discuss implement step solving linear program 
section discuss preprocess eliminate various boundedness full dimensionality assumptions 
taken results sections establish stronger version theorem theorem facet hereditary family polytopes gamma generate vertices facet polytope gamma certify vertices time enumerate facets vertex polytope time nd mnd gamma certain cases dual nondegenerate case considered section may theoretical bound polynomial cases theoretical bound may difficult obtain may experimental evidence certain method heuristic insertion order incremental algorithm efficient vertex enumeration gamma 
case techniques described section obtain efficient method facet enumeration 
worth noting restriction input points convex position 
redundant interior input points effect slow pivot operations tests membership input total number input points including redundant points 
deleting vertices linear programming main tool pivot operation simplex method linear programming 
inequality system hx represented standard dictionary form see follows 
transform inequality equality adding slack variable arrive system linear equations dictionary gamma hx precisely dictionary system obtained solving subset slack original variables row size 
solution feasible particular ho feasible solution 
variables naturally partitioned sets 
variables appearing left hand side dictionary called basic right hand side called 
pivot operation moves dictionaries making variable entering variable basic basic variable leaving variable 
feasible point polytope halfspace description pivot operations find vertex polytope 
ensure pivot decrease objective function 
algorithm oe lemma algorithm thetad time md find proof 
start translating system gammav initial point origin 
final row dictionary add equation objective row 
note construction feasible solution 
start pivot operation choosing variable basic 
depending sign coefficient objective row increase decrease decreasing value change value basic slack variables decrease get closer corresponding hyperplane 
considering ratios coefficients find hyperplanes reached 
moving slack variable right hand side making moving left hand side obtain new dictionary md time see details simplex method 
continue process long variable 
exactly pivots variables basic 
follows corresponding basic feasible solution vertex see 
algorithm part folklore linear programming generalized version discussed 
duality convex polytopes 
lemma dual algorithm thetad ae nd time find 

essentially initialization step gift wrapping algorithm see careful point side final hyperplane started 
illustrates rotation dual pivot operation lemma 
show implement step algorithm linear programming 
basis vertex set rows bv rank obviously find basis polynomial time pivoting algorithms sections basis pivoting valid inequality facet 
oe 
oe oe hx lemma thetad ae basis find gamma time nd 
proof 
inequality hx satisfied equality strict inequality unique vertex lying see 
fl max hv int conv fl 
fl 
constraint valid conv 
lemma follows lemma 
basis vertex wish cut mean outward normals facets meeting place vector mean vector computed time jh jd time 
corollary thetad ae find gamma time nd jh jd 
illustrating proof lemma 
hx hx fl prove useful able find facet conv cuts particular extreme ray direction unboundedness current intermediate polyhedron 
lemma thetad nd time find hr 
proof 
proof similar lemma 
fl max rv int conv fl 
fl 
constraint valid conv delta fl 
lemma nd time compute hr 
preprocessing assumed input polytopes full dimensional contain origin interior point 
polynomially equivalent assuming halfspace vertex description relative interior point point interior point aff relative interior point representation shifted contain origin interior point embedded space dimension nd time elementary matrix operations number input halfspaces points 
finding relative interior point set points requires computation centroid 
hand finding relative interior point intersection set halfspaces requires solving jhj linear programs 
interested algorithms polynomial linear programming algorithms assume relative interior point 
order initialize algorithm need find subset ae intersection bounded 
start showing find subset intersection pointed vertex 
algorithm 
jhj distinct points gamma endwhile return lemma thetad nd time algorithm computes subset ae defines vertex 
proof 
compute parametric representation affine subspace defined intersection hyperplanes far time gaussian elimination 
call algorithm find hyperplane cuts ray previous affine subspace see 
follows dimension decreases iteration 
successive affine subspaces computed algorithm show augment set halfspaces computed algorithm intersection new set bounded 
constructive proof theorem 
version edmonds 
similar ideas occur earlier klee 
lemma oracle thetad bounded polytope time md find ae conv jv 
proof 
sketch 
apply lemma find 
return find point ray gamma 
vv exits intersect constraints minimal face containing recurse point face 
recursively computed set contain convex hull 
duality convex polytopes lemma dual oracle polytope conv ae find time jv jd ae conv jhj 
illustrates application oracle find subset vertices polygon containing interior point convex hull 
equivalent dual interpretation finding set facets imply valid inequality shown 
order understand application lemma note proposition ax polyhedra row convex combination rows lemma lemma find subset intersection bounded 
primal dual oracles 
oracle find set points convex hull contains dual problem finding set facets imply valid constraint 
illustrating proof lemma gamma gamma hx fl lemma thetad time nd compute subset bounded jhj 
proof 
start computing set facet defining halfspaces intersection defines vertex algorithm 
proof similar lemma lemma 
compute mean vector normal vectors see 
fl max gamma hv gamma fl 
note valid ray feasible cut constraint bounded 
applying lemma find set halfspaces ae conv contains vertex jh proposition bounded 
dual nondegenerate case section describe results previous section lead polynomial algorithm facet enumeration simple polytopes 
give refinement algorithm yields algorithm time complexity competitive known algorithms primal nondegenerate case 
discussion know achieve polynomial algorithm facet enumeration particular family polytopes need polynomial algorithm vertex enumeration subset facet defining halfspaces polytope family 
dual simplicity quite guarantee difficult see halfspaces defining simple polytope perturbed general position affecting combinatorial structure polytope 
case dual sub problem solvable number pivoting methods see 
equivalently cleanly lexicographic ratio testing see section pivoting method 
basis subset bounding hyperplanes define vertex pivoting algorithm may visit bases perturbed vertices equivalent vertex notice vertex input simple exactly basis 
follows guarantee find witness find vertices cur bases jv output pivoting algorithm 
case vertex degenerate say ffi facets meet vertex small constant ffi may wait delta gamma ffi ffi delta bases 
course grows quickly function ffi polynomial ffi constant 
rest section assume ease exposition polytope consideration simple 
completely satisfactory perform vertex enumeration scratch verification step succeeding input vertex enumeration algorithm consists adding exactly halfspace previous input 
show avoid duplication effort 
subset cur ae cur bounded starting vertex cur algorithm find starting vertex jh cur jd time 
algorithm standard pivoting algorithm vertex enumeration depth search 
procedure cur finds th neighbour cur 
requires md time accomplish standard simplex pivot 
algorithm dfs cur cur new dfs cur endif endfor check vertex new previously undiscovered depth search simply store discovered vertices standard data structure balanced tree query structure log time 
algorithm subroutine find witnesses algorithm modify algorithm finds new facets side effect 
subset ae starting vertex additional restriction vertex input 
order find vertex vertex input find arbitrary vertex lemma 
vertex vertex input apply find new halfspace cuts repeat 
follows assume halfspaces defining current intermediate polytope stored global dictionary denote set halfspaces cur modify algorithm replacing call call procedure 
addition neighbouring vertex computes halfspace defining known 
suppose vertex current intermediate polytope 
simple halfspaces defining follows halfspace description edge leaving halfspace description edges pivot neighbouring vertex current intermediate polytope 
know adjacent conv cut routine 
simple perturbation necessary cut degenerate vertices trying pivot away 
implemented algorithm 
algorithm cur repeat cur cur cur return lemma mnd preprocessing takes time md md nd number new halfspaces discovered 
proof 
mentioned takes md time 
procedure merges newly discovered halfspace global dictionary 
simple know new halfspace strictly satisfied current vertex follows merge dictionary making slack variable basic 
amounts basis transformation bounding hyperplane done time 
search problem completely static insertions deletions relatively easy achieve query time log preprocessing cost log kd trees 
claim inequality md follows upper bound theorem 
easily verified 
gamma bd bd upper bound theorem bd bd 
log follows log md query time md preprocessing time 
pivot discover vertex discovers facet conv charge time pivots facets discovered 
algorithm cur cur add new halfspaces cur new cur cur endif endfor return cur depth search primal dual algorithm algorithm 
note need additional data structure query step determine newly discovered 
simply mark vertex discovered search 
furthermore simple theorem thetad conv simple compute time 
dual degenerate case algorithm useful moderately dual degenerate polytopes 
standard pivoting algorithm vertex enumeration depth breadth search previously discovered bases stored 
number bases necessarily polynomially bounded dual degenerate case turn reverse search allows enumerate vertices non simple polytope storing bases visited 
rest section organized follows 
section explains reverse search vertex enumeration non simple polytopes lexicographic pivoting 
section shows construct primal dual facet enumeration algorithm analogous algorithm recursion stack depth search replaced memoryless reverse search 
lexicographic reverse search essence reverse search simple case follows 
choose objective function direction optimization unique optimum vertex 
fix arbitrary pivot rule 
vertex polytope unique sequence pivots taken simplex method vertex see 
take union paths optimum vertex forms tree directed root 
easy see simplex pivot reversible fact just exchanges roles leaving entering variable 
perform depth search simplex tree reversing pivots root see 
storage needed backtrack merely pivot optimum vertex 
reverse search cube path simplex method simplex tree induced objective gamma 
corresponding reverse search tree 
number bases bounded small polynomial input size super linear space usage may impractical large problems 
section discuss technique dealing degeneracy reverse search 
essence required method dealing degeneracy simplex method 
method lexicographic pivoting shown equivalent standard symbolic perturbation constant vector system ax see discussion 
words lexicographic lexicographically somewhat ubiquitous remainder abbreviate lex 
order reverse search works non simple case need discuss detail notions dictionaries pivoting section 
start representing polytope system linear equalities variables constrained nonnegative 
polytope defined system inequalities 
convert inequality equality adding slack variable 
solving original variables set gamma slacks eliminating original variables gamma equations slack variables left hand side arrive slack representation geometrically transformation viewed point polyhedron scaled distance bounding hyperplanes 
renaming slack variables may assume slack representation form ax theta gammad thetad ae vector denote vector elements indexed similarly matrix denote subset columns indexed rank jj rank call basis call basis matrix 
suppose ae defines basis basis 
denote rewrite ab xb ac xc rearranging familiar form dictionary xb gamma gamma gamma ac xc solution fi gamma obtained setting variables zero called basic solution 
fi fi called basic feasible solution feasible basis 
feasible basis corresponds basis vertex corresponding polyhedron sense affinely independent set supporting hyperplanes setting specify inequalities satisfied equality 
corresponding vertex simple resulting values xb strictly positive inequality satisfied equality 
rest basis standard linear programming sense set linearly independent columns reserve corresponding set supporting hyperplanes incident vertex equivalently set indices corresponding slack variables 
pivot operation moves feasible bases replacing exactly variable basis 
pivot new basis start choosing variable increase 
fi gamma gamma ac standard simplex ratio test looks basic variable forced zero increasing looks min ik fi ik general non simple case ties minimum ratio 
define theta fi gamma ij ik ik choose variable leave basis find row apply standard ratio test fi break ties applying test successive columns 
intuitively simulates performing standard ratio test perturbed system ax ffl ffl 
perturbation equivalent sequentially perturbing hyperplanes index order successive hyperplane pushed outward smaller amount 
unique choice leaving variable corresponding vertex perturbed polytope simple follows fact gamma non singular 
vector called lexicographically positive lowest indexed nonzero entry positive 
basis called lexicographically positive row lexicographically positive 
basis set corresponding set 
objective vector objective row dictionary defined xb xc substituting xb ba gamma 
gamma ba gamma ac simplex method chooses variable increase positive coefficient cost row gamma ba gamma ac variable increasing increase objective value 
geometrically know increasing slack variable increase resp 
decrease objective function iff inner product objective vector outer normal corresponding halfspace negative resp 
positive 
vertex defines polyhedral cone pc apex containing optimal objective vector gamma pc note original objective vector transforming slack representation 
reinterpreting terms slack representation standard result linear programming see 
proposition cost row positive entry current basic feasible solution optimal 
entering variable chosen positive cost row coefficient leaving variable chosen lexicographic ratio test call resulting pivot lexicographic pivot vector lexicographically greater vector gamma lexicographically positive 
facts known lexicographic pivoting proposition lexicographically positive basis basis arrived lexicographic pivot nonzero objective vector 
lexicographically positive lexicographically greater 
basis called lex optimal lexicographically positive positive entries corresponding cost row 
order perform reverse search unique lex optimal basis 
claim gamma fix unique lex optimal basis choosing objective function gamma equivalent choosing mean outward normals hyperplanes objective direction 
consider equivalent perturbed polytope intuition perturbed vertices corresponding single original vertex contained cone defined lex maximal see 
lemma gamma denote initial basis defined slack representation 
objective vector theta gammad gamma lex positive basis positive entry cost row proof 
cost row gamma lex positive basis distinct fi denote basic part corresponding basic feasible solution 
denote number non identity columns ab fi positive entry cost row fi optimal 
suppose fi 
follows fi theta fi theta gammad gammak gamma fi column ab column gamma theta gamma identity matrix 
theta denote row ab gamma gamma columns ab identity columns vector 
ff theta ff ff column gamma ff vector 
aff know ff lex positivity fact fi theta fi fact gamma columns gamma identity columns follows ff negative entries 
follows element ba gamma negative 
identity column ab ac position follows element ba gamma ac negative element cost row positive 
preceding lemmas see lexicographically positive bases enumerated reverse search unique lex optimal basis 
tells suffices enumerate vertices polytope 
lemma vertex polytope lexicographically positive basis 
proof 
polytope 
arbitrary vertex choose objective function unique optimum 
choose initial lex positive basis 
run simplex method lexicographic pivoting 
finite number bases proposition lexicographic pivoting repeat basis eventually reach basis lexicographic pivoting maintains lex positive basis step basis lex positive 
lexicographic perturbation incremental construction sequentially perturbing halfspaces defining vertex intersecting perturbed halfspaces reverse order algorithm gives schematic version lexicographic reverse search algorithm 
rename variables opt gamma initial vertex routine lexicographic pivot objective function theta gammad gamma variable positive cost coefficient choose lowest index 
returns new index column basis entered 
test determines algorithm opt cur repeat cur edge sibling edge 
opt algorithm implement verification step performing vertex enumeration scratch 
section discuss construct algorithm analogous algorithm performs single vertex enumeration uses reverse search standard depth search 
primal dual reverse search section give modification algorithm computes facet defining halfspaces side effect 
define algorithm call replaced call 
section suppose preprocessing steps initial set facet defining halfspaces bounded vertex input 
turn numbering halfspaces crucial 
number jth halfspace discovered including preprocessing gamma course know algorithm completes prevent ordering indices 
reverse ordering corresponds pushing discovered hyperplanes farther leaving skeleton earlier discovered vertices edges compare halfspaces numbered different insertion order causes intermediate vertices cut 
perturbed vertex cut halfspaces 
modified algorithm considered simulation restricted reverse search algorithm vertex enumeration access subset halfspaces input halfspaces labeled special way 
lexicographic reverse search described previous section works labeling halfspaces show restricted reverse search correctly enumerates vertices need show visits set unrestricted algorithm labeling initial 
ax gammad thetam slack representation polytope 
write slack representation homogeneous form theta gamma gammad thetad suppose step restricted reverse search lowest index halfspace visited including initialization 
restricted reverse search access gamma rows gamma columns 
denote gamma ae denote nc 
define restricted basis matrix gamma gamma rows denote restricted basis matrix ae denote gamma restricted lexicographic ratio test mean lexicographic ratio test applied matrix ae gamma 
way contrast unrestricted lexicographic ratio test basis matrix mean previously defined lexicographic ratio test basis matrix 
observe restricted basis matrix submatrix unrestricted basis matrix property preserved matrix inversion 
denote restricted basis denote unrestricted basis matrix gamma gamma columns slack representation form identity matrix know columns identity columns 
follows matrix reader verify matrix identity 
gamma gamma gammam gamma gamma edges reverse search tree pivots 
referring interpretation lex pivoting perturbation order versions reverse search generate perturbed vertex edge tree generate set pivots 
argue choosing hyperplane leave edge leave perturbed vertex yields hyperplane enter cases perturbed vertex 
lemma polytope ax slack representation ae ax gamma entering variable candidate leaving variable leaving variable chosen lexicographic ratio test identical chosen restricted lexicographic ratio test 
proof 
fi denote gamma ae denote gamma consequence ae fi exactly candidate leaving variable assumptions lemma index ratio tests find minimum 
hand tie minimum ratio test applied fi variable index preferred unrestricted lexicographic ratio test columns gamma index variables ratio 
backtracking edges reverse search tree consist lex pivots lowest indexed variable positive cost coefficient chosen entering variable lowest indexed tight constraint profitably 
previous lemma tells fixed entering variable restricted unrestricted reverse search choose leaving variable 
remains show backtracking pivot optimum choose entering variable 
fixed set halfspaces fixed vector 
direction optimization signs cost vector depend signs fact show slightly stronger objective vector 
respect slack representation involve hyperplanes index analogous definition restricted basis matrix define restricted cost row gamma gamma ac restricted basis matrix ac gamma gamma rows ac lemma objective vector theta gammad gamma cost row restricted cost row identical 
proof 
restricted unrestricted basis matrices respectively 
form objective vector know theta gamma bu gamma ac theta gamma gammam gamma gamma ac gamma ac case edges reverse search tree possible entering variable hyperplane leave tested turn order increasing index 
previous backtracking pivot identical algorithms edge 
reverse search just depth search particular spanning tree visits nodes tree sequence repetition defined ordering edges 
ordering edges node reverse search tree turn determined numbering hyperplanes 
lemma polytope 
subset bounded intersection 

set visited visited halfspace numbering 
proof 
think sequences chains connected pivots 
chain visited 
chain visited 
sequences start starting lex maximum set indices 
suppose sequences identical element suppose ij cases 
edge reverse edge start pivoting fixing entering variable choosing leaving variable lexicographically 
contains variable variable numbered 
denote position entering variable column leave matrix 
position occurred gamma times sequences know choose entering variable 
lemma choose leaving variable 
test depends cost row lemma suppose hand pivot forward pivot 
know lemma invocations choose entering variable apply lemma see choose leaving variable 
theorem thetad denote jh oe denote number lexicographically positive bases 
compute time space 
decide conv simple time nd 
proof total cost finding initial set halfspaces size initial set 
call finds new halfspace total cost calls 
call pivot discovers new halfspace 
discover new halfspaces total cost pivots cost oed calls 
oe forward pivots cost 
step reverse search read number halfspaces satisfied equality current vertex dictionary time 
lower bound theorem simple polytopes simple 
reach degenerate vertex discover facets 
reverse search terminates time compute number facets meeting vertex 
total cost nd 
theorem independent interest problem deciding simple known np complete strong sense 
experimental results order test primal dual reverse search practical value implemented compared performance avis implementation reverse search 
programs written rational arithmetic allows fair comparison 
experiments families polytopes certain simple polytopes show best worst behavior programs products cyclic polytopes degenerate programs 
memory requirements implementation twice input size plus twice output size program stores dictionaries constant vertex dictionary growing halfspace dictionary cur form working copy 
program uses earlier version preprocessing step upper bound nd compared current bound nd 
source code available inf ethz ch pd html 
follows pd implementation primal dual reverse search lrs avis implementation reverse search 
experiments performed digital alphaserver real memory virtual memory 
compares running time programs products simplices 
dimensional polytopes facets vertices 
simple ideal vertex enumeration lrs facet enumeration pd extremely high triangulation complexity bad vertex enumeration pd facet enumeration lrs perturbation vertices algorithms induces triangulation polytope boundary 
plot show times enumerating facets vertices 
expected pd clearly superior lrs facet enumeration polytopes 
facets preprocessing current implementation fact accounts time taken pd examples 
asymmetric example product cyclic polytopes theta theta delta delta delta theta 
polytopes simple simplicial 
known primal dual triangulations superpolynomial experimentally dual triangulations smaller primal ones 
advantageous pd meaning perturbation pd facet enumeration produces bases lrs 
difference reflected relative performance programs 
relation primal dual triangulation sizes number bases computed algorithm theta dimensional polytopes vertices facets shown similar relation running times shown 
running time products simplices theta gamma gamma facet enum 
lrs facet enum 
pd vertex enum 
lrs vertex enum 
pd time cpu seconds triangulation size number bases computed theta 
primal facet enumeration lrs dual facet enumeration pd triangulation size cpu time facet enumeration theta 
lrs pd time cpu seconds alternative approach achieving algorithm polynomial dual nondegenerate case modify method klee 
idea due clarkson reduce row size linear programs maximum number facets meeting vertex 
assume ffi constant ffi solve linear program brute force time polynomial approach inherently quadratic input size entire set input halfspaces enumerate vertices facet 
interesting remove requirement theorem family difficult prove things general polytopes formed subsets halfspace description known polytope 
acknowledgments authors david avis useful discussions topic writing lrs 
anonymous referee careful reading helpful suggestions 
avis 
implementation reverse search vertex enumeration algorithm 
technical report rims kyoto university may 
revised version technical report socs mcgill university school computer science 
avis bremner seidel 
convex hull algorithms 
comput 
geom theory appl apr 
avis fukuda 
pivoting algorithm convex hulls vertex enumeration arrangements polyhedra 
disc 
comput 
geom 

minimum number vertices simple polytope 
israel math 
br 
convex polytopes 
springer verlag 
kapur 
algorithm convex polytopes 
acm 
chv atal 
linear programming 
freeman new york ny 
clarkson 
output sensitive geometric algorithms 
proc 
th ieee symp 

comp 
sci pages 
dyer 
complexity vertex enumeration methods 
math 
oper 
res 
edmonds 
decomposition minkowski 
abstracts th international symposium mathematical programming amsterdam 
fukuda 
analysis backtrack algorithms listing vertices faces convex polyhedron 
comput 
geom theory appl 
klee 
complexity basic problems computational convexity ii 
volume mixed volumes 
schneider weiss editors polytopes convex computational number nato adv 
sci 
inst 
ser 
math 
phys 
sci pages 
kluwer academic dordrecht 

linear programming pages 
prentice hall international series industrial systems engineering 
prentice hall 
klee 
extreme points convex sets completeness scalar field 

mehlhorn 
data structures algorithms multi dimensional searching computational geometry volume eatcs monographs theoretical computer science 
springer verlag heidelberg west germany 
murty 
gravitational method linear programming 

seidel 
output size sensitive algorithms constructive problems computational geometry 
ph thesis dept comput 
sci cornell univ ithaca ny 
technical report tr 
swart 
finding convex hull facet facet 
algorithms 
