encyclopedia electrical electronics engineering john webster ed john wiley sons new york appear approx 

visual programming margaret burnett oregon state university visual programming programming dimension convey semantics 
examples additional dimensions multi dimensional objects spatial relationships time dimension specify semantic relationships 
potentially significant multi dimensional object relationship token just traditional textual programming languages word token collection tokens visual expression 
examples visual expressions visual programming include diagrams free hand sketches icons demonstrations actions performed graphical objects 
programming language semantically significant syntax includes visual expressions programming language visual programming language vpl 
traditional textual programming languages incorporate dimensional syntax devices limited way dimension convey legal linear string language allowing optional line spacing documentation device limited semantics continued previous line dimensions conveys semantics second dimension limited notion spatial relationships expressible dimensional string grammar 
multidimensionality essential difference vpls strictly textual languages 
visual expressions programming environment editing shortcut generate code may may different syntax edit code environment called visual programming environment 
visual programming environments traditional textual languages provide middle ground vpls widely known textual languages 
contrast just years ago strictly textual command line programming environments norm today traditional textual languages predominant kind commercial programming environment 
commercial traditional languages aimed professional programmers programmers textual languages know supported graphical user interface techniques accessibility information visual approaches add 
traditional languages serve conduit transferring vpl research advances practice applying new ideas traditional languages familiar programmers affording gradual migration textual programming techniques visual ones 
vpls usually integrated custom environments remainder article follow convention term mean traditional languages 
history earliest visual programming directions visual approaches traditional programming languages executable flowcharts new visual approaches programming deviated significantly traditional approaches programming demonstrating desired actions screen 
early systems advantages exciting intuitive demonstrated toy programs ran difficult problems attempts extend realistically sized programs 
problems led early visual programming causing believe visual programming inherently unsuited real just academic exercise 
overcome problems visual programming researchers began develop ways visual programming selected parts software development increasing number projects visual programming help 
approach straightforward visual techniques widely incorporated programming environments support textual programming languages replace cumbersome textual specification gui layout support electronic forms software engineering diagrams creating visualizing relationships data structures visually combine textually programmed units build new programs 
successful commercial soon followed early examples microsoft visual basic basic parcplace systems visualworks smalltalk 
group commercial focused primarily large grained programming computer aided software engineering case tools support visual specification example diagrams relationships program modules culminating automatic code generation composition code 
visual programming researchers took different approach worked increase kinds projects suitable visual programming development domain specific visual programming systems 
strategy addition new supported domain increased number projects programming visually 
added benefit followed improved accessibility users able new systems 
developers domain specific vpls providing ways write programs particular problem domain eliminated disadvantages earliest approaches supported working directly communication style particular problem domain visual artifacts icons menus reflecting particular needs problem solving diagrams vocabulary specific domain forced users abandon communication style 
approach quickly produced number successes research marketplace 
today commercial vpls available domains examples include programming laboratory data acquisition national instruments labview programming scientific visualizations advanced visual systems avs programming telephone voice mail behavior research programming graphical simulations games software cocoa 
number software agent generators starting embedded personal computing software allowing macros assist repetitive tasks inferred user manipulations chimera example discussed section 
original challenge devise vpls power generality address variety programming problems ongoing area research 
goal research continue improve ways visual programming 
goal provide kinds improvements general software development available programming domain specific areas 
primarily research stage commercial vpls characteristics needed general purpose programming emerged produce commercial software packages example international prograph 
strategies visual programming employ visual ways communicating programs visual communication devices employed viewed limited vpl 
strategies subset possible vpls 
subset relationship remaining discussion visual programming focus primarily vpls 
vpl strategies common misunderstanding goal visual programming research general vpls particular eliminate text 
fallacy fact vpls include text extent multidimensional context 
goal vpls strive improvements programming language design 
opportunity achieve comes simple fact vpls fewer syntactic restrictions way program expressed computer human affords freedom explore programming mechanisms previously tried possible past 
common specific goals sought vpl research programming accessible particular audience improve correctness people perform programming tasks improve speed people perform programming tasks 
achieve goals common strategies vpls concreteness concreteness opposite abstractness means expressing aspect program particular instances 
example allowing programmer specify aspect semantics specific object value example having system automatically display effects portion program specific object value 
directness directness context direct manipulation usually described feeling directly manipulating object 
cognitive perspective directness computing means small distance goal actions required user achieve goal :10.1.1.22.1477
concreteness vpl example directness allowing programmer manipulate specific object value directly specify semantics describing semantics textually 
explicitness aspect semantics explicit environment directly stated textually visually requirement programmer infer 
example explicitness vpl system explicitly depict dataflow relationships program slice information drawing directed edges related variables 
immediate visual feedback context visual programming immediate visual feedback refers automatic display effects program edits 
tanimoto coined term liveness categorizes immediacy semantic feedback automatically provided process editing program 
tanimoto described levels liveness 
level semantics implied computer feedback program provided programmer 
example level entity relationship diagram documentation 
level programmer obtain semantic feedback portion program provided automatically 
compilers support level liveness minimally interpreters restricted final output values 
level incremental semantic feedback automatically provided programmer performs incremental program edit affected onscreen values automatically 
ensures consistency display state system state trigger system state changes programmer editing 
automatic recalculation feature spreadsheets supports level liveness 
level system responds program edits level events system clock ticks mouse clicks time ensuring data display accurately reflects current state system computations continue evolve 
vpl examples section discuss example vpls demonstrate ways strategies previous section employed 
imperative visual programming demonstration chimera example common way imperative programming supported vpls having programmer demonstrate desired actions 
case chimera programmer user chimera example vpl aimed improving accessibility programming certain kinds tasks 
domain chimera graphical editing 
user works graphical scene may find repetitive editing tasks arise indicate sequence manipulations just performed scene generalized treated macro 
possible history user actions depicted comic strip metaphor see user select panels history indicate objects viewed example parameters graphically edit actions depicted panels desired save sequence edited panels macro 
chimera uses inference determining generalized version macro inference common demonstration languages success depends limited problem domains chimera 
number languages inference example cocoa discussed article 
chimera liveness level provides immediate visual feedback effects program edits 
effects rendered terms effects actual objects program example concreteness 
directness chimera way program semantics specified directly manipulating objects demonstrate desired results 
similar combinations immediate visual feedback concreteness directness demonstration vpls 
programming demonstration chimera 
example user drawn box arrow pointing graph diagram demonstration depicted fact series panels 
set demonstrations generalized macro creating nodes graph semi automatically 
form spreadsheet visual programming forms example vpl follows form paradigm 
paradigm programmer programs creating form specifying contents 
paradigm commonly seen commercial spreadsheets form grid shaped contents specified cells formulas 
forms programs include forms spreadsheets cells cells locked grid 
forms programmer creates program direct manipulation place cells forms defines formula cell flexible combination pointing typing gesturing 
see 
program calculations entirely determined formulas 
formulas combine network way constraints system continuously ensures values displayed screen satisfy constraints 
forms turing complete language 
aim enhance ordinary spreadsheet concepts support advanced functionality needed full featured programming 
supports features graphics animation recursion resorting macros links traditional programming languages 
example forms supports rich extensible collection types allowing attributes type defined formulas instance type value cell referenced just cell 
instance type box specified graphically sketching specification changed necessary stretching box direct manipulation 
immediate visual feedback liveness level provided case 
concreteness fact resulting box immediately seen formulas provided possible directness direct manipulation mechanism specifying box demonstrates specification directly box 
intended audience forms programmers job create applications training emphasized today traditional programming languages 
goal forms reduce number complexity mechanisms required application programming hope greater ease programmers result characteristic traditional languages accompanying increase correctness speed programming 
empirical studies programmers demonstrated greater correctness speed program creation program debugging forms techniques variety alternative techniques 
defining area square spreadsheet cells formulas forms 
graphical types supported class values programmer enter cell square formula sketching square box typing textual specifications box 
dataflow visual programming prograph dataflow vpl aimed professional programmers 
dataflow paradigm currently approach visual programming widely industry 
prograph exemplifies programming levels low level details grouped procedures objects see compositions procedures objects 
dataflow paradigm commonly domain specific composition low level components written way example scientific visualization systems simulation systems heavy visual dataflow programming 
prograph provides strong debugging support making extensive dynamic visualization techniques 
liveness level data values programmer explicitly requests display value time wants see 
runtime stack activity order nodes fire viewed execution programmer changes bit data source code mid execution stack window related views automatically adjust proceed point new version aspect liveness level 
way dataflow paradigm distinguishes paradigms explicitness explicit rendering edges graph dataflow relationships program 
dataflow languages govern control flow dataflow edges sufficient reflect control flow explicitly purely dataflow language 
dataflow programming prograph 
programmer low level primitive operations find right triangle 
prograph allows programmer name compose low level graphs higher level graphs composed higher level graphs 
rule visual programming cocoa known rule vpl programmer specifies rules demonstrating postcondition precondition 
see 
intended programmers children problem domain specification graphical simulations games 
cocoa turing complete language features designed general purpose programming convenient designed accessible children ability program simulations 
way concreteness directness seen cocoa quite similar chimera demonstration way semantics specified 
liveness level different cocoa liveness level level 
level kinds program changes addition new rules affect current display variables child requests program resume running kinds program changes changing appearance object changes automatically propagated display immediately 
listing properties common rule systems hayes roth includes ability explain behavior 
cocoa child open selecting double clicking character participating simulation window containing rules governing character behavior displayed 
execution cycle character rules considered top character list 
indicators rule gray prior rule considered 
rule matching fails indicator rule turns red pattern matching succeeds rule fires indicator turns green 
rule fired character character turn rules character checked cycle 
cocoa wall climber wall climber main window rules window demonstrated 
rule shown graphical precondition left arrow graphical postcondition right arrow 
wall climber just finished rule places position suitable rule 
advanced issues visual programming abstraction challenges visual programming research scaling support larger programs 
greater issue vpls traditional textual languages certainly said exist reasons relating representation language design implementation relative youth area 
example visual mechanisms achieve characteristics explicitness occupy great deal space making harder maintain context 
hard apply straightforward way techniques developed traditional languages doing results complexities vpls tried remove simplify 
developments area abstraction particularly important scalability vpls 
widely supported types abstraction visual textual languages procedural abstraction data abstraction 
particular procedural abstraction shown variety vpls 
key attribute supporting procedural abstraction vpl consistency rest programming vpl 
representative solutions include allowing programmer select name section dataflow graph recall adds node representing subgraph library function nodes dataflow language setting separate spreadsheets recall automatically generalized allow user defined functions form language recording generalizing sequence direct manipulations recall language 
data abstraction slower coming vpls largely difficult find way maintain characteristics concreteness feedback adding support ideas central data abstraction generality information hiding 
support data abstraction emerged number vpls 
example forms new data type defined spreadsheet ordinary cells defining operations methods distinguished cells allow composition complex objects simpler ones definition object appear screen 
cocoa character appearance painted graphical editor demonstration new rule belongs character type manipulated providing roughly functionality operation method 
forms cocoa support limited forms inheritance 
visual programming language specification dimensionality traditional textual languages means relationship possible symbols sentence 
describing textual language bnf necessary specify symbols language relationship implied symbol written grammar 
multidimensionality vpls means relationships possible overlaps touches left universally agreed definition exactly relationships hold may hold simultaneously symbols 
relationships symbols left implicit traditional mechanisms bnf specifying textual languages modification specifying vpls 
different formalisms specification visual languages investigated 
grammar formalisms range early approaches web array grammars shape grammars formalisms positional grammars relation grammars unification grammars attributed multiset grammars types graph grammars 
non grammar formalisms 
grammar approach constraint multiset grammars 
example cmg production taken specification state diagrams tr transition arrow text exists state state midpoint close midpoint radius distance midpoint radius distance endpoint midpoint tr name tr name tr label string 
general production form exists meaning non terminal rewritten multiset sentence contains symbols context attributes symbols satisfy constraint denotes vector attributes values defined vector expression attributes objects production 
example tr tr tr label name name string 
marriott meyer cmg approach derive chomsky taxonomy vpls 
show generality taxonomy dependent roots showed formalisms mapped 
visual programming cognitive theory goals vpls improving humans ability program important consider known cognitive issues relevant programming 
information gleaned field cognitive psychology psychologist thomas green colleagues findings available non psychologists cognitive dimensions set terms describing structure programming language components relate cognitive issues programming :10.1.1.22.1477
table lists dimensions thumb nail description 
relation dimension number empirical studies psychological principles authors carefully point gaps body underlying evidence :10.1.1.22.1477
words framework cognitive dimensions consists small number terms chosen easy non specialists comprehend capturing significant amount psychology hci programming 
abstraction gradient minimum maximum levels abstraction 
fragments encapsulated 
closeness mapping programming games need learned 
consistency language learnt rest inferred 
symbols graphic entities required express meaning 
error proneness design notation induce careless mistakes 
hard mental operations places user needs resort fingers annotation keep track happening 
hidden dependencies dependency overtly indicated directions 
indication perceptual symbolic 
premature commitment programmers decisions information need 
progressive evaluation partially complete program executed obtain feedback am doing 
role expressiveness reader see component program relates 
secondary notation programmers layout color cues convey extra meaning official semantics language 
viscosity effort required perform single change 
visibility part code simultaneously visible assuming large display possible compare parts side side 
code dispersed possible know order read 
table cognitive dimensions 
concrete application cognitive dimensions representation design benchmarks set quantifiable measurements vpl static representation 
benchmarks sorts binary measurements reflecting presence denoted elements static representation measurements extent characteristics denoted vpl static representation number user navigational actions denoted ni required navigate element static representation screen 
benchmarks table 
benchmark name ni aspect representation computation visibility sources dependencies explicitly depicted sources dependencies system dependencies worst case number steps required navigate display dependency information ps visibility representation explicitly show parts program logically fit 
ps program structure worst case number steps required navigate display program structure visibility representation explicitly show element computed 
program logic worst case number steps required program logic visible number sources generality display results possible see results displayed statically program source code 
program logic worst case number steps required display results source code 
sn secondary notation non semantic devices number secondary notational devices available optional naming layout devices semantic impact textual annotations comments static graphical annotations 
sn worst case number steps access secondary notations ag abstraction gradient number sources details abstracted away data details operation details details fine grained portions programs details ni devices 
ag worst case number steps away details ri accessibility related possible display related information side side 
ri information worst case number steps required navigate display related information 
screen maximum number program elements displayed physical screen 
real estate number non semantic intersections physical screen obtaining score closeness specific audience background number answers number questions general form look mechanism intended audience prerequisite background 
table summary representation design benchmarks 
denotes measures characteristics elements denotes measures presence potential elements measure corresponding ni measure 
empirical findings visual programming techniques improve correctness speed programming tasks focused primarily areas program comprehension program creation program debugging 
areas empirical studies done vpls effects program comprehension 
see survey 
results studies mixed reporting findings kinds programs audiences vpls visual notations linked greater comprehension strictly textual languages notations linked greater comprehension 
fewer empirical studies program creation studies produced far consistent results studies comprehension 
reported visual approaches outperforming traditional textual approaches task 
effects visual programming studied debugging fact true classical debuggers feature precursors ideas liveness vpls 
studies statistically significant improvements aspects studied aspects statistical significance visual approaches including immediate feedback superior static non feedback oriented approaches cases 
summary visual programming vpls 
commercially visual programming commonly serve effective conduit gains research vpls quickly transferred industrial practice 
goal visual programming general programming easier humans goal vpls particular better programming language design 
goal timely today supporting hardware software places fewer restrictions elements may part vocabulary programming language 
opportunities arise reduction restrictions received attention far vpl design concreteness directness explicitness immediate visual feedback 
exploiting areas mean radical departures tradition turn requires building blocks abstraction mechanisms important designing scalable vpls 
multidimensionality inherent vpls leads language theoretic issues 
fact vpls intended programming easier humans leads need research human cognitive abilities best served innovations programming language design 
acknowledgments bibliographic notes sources information article specifically referenced additional sources information follows 
material introductory section derived 
see detailed treatment scaling problem visual programming languages 
vpl examples drawn ieee tutorial jointly burnett rebecca walpole capri italy 
discussion vpl specification summarized approaches formal syntax issues formal semantics issues 
discussions cognitive dimensions representation design benchmarks due 
summary empirical studies derived 

baroth hartsough visual programming real world 
burnett goldberg lewis eds visual object oriented programming concepts environments prentice hall englewood cliffs nj manning publications greenwich connecticut ieee los alamitos california 

bottoni costabile levialdi visual conditional attributed rewriting systems visual language specification 
ieee symposium visual languages boulder colorado september 

burnett graphical definitions expanding spreadsheet languages direct manipulation gestures 
acm transactions computer human interaction march 

burnett visual programming 
computer march 

burnett baker carlson yang van zee scaling visual programming languages 
computer march 

chang yu icon purity formal definition icons 
international journal pattern recognition artificial intelligence 

cook burnett boom bug eye view immediate visual feedback programming systems 
empirical studies programmers seventh workshop alexandria virginia oct 

tucci automatic parser generation pictorial languages 
ieee symposium visual languages bergen norway august 

cox giles prograph step programming textual conditioning 
ieee workshop visual languages rome italy oct 

erwig semantics visual languages 
ieee symposium visual languages capri italy september 

green petre usability analysis visual programming environments cognitive dimensions framework 
journal visual languages computing june 

hayes roth rule systems 
communications acm september 

hutchins hollan norman direct manipulation interfaces 
norman draper eds user centered system design new perspectives human computer interaction lawrence erlbaum assoc hillsdale nj 

chimera example graphical editing 
cypher ed watch programming demonstration mit press cambridge mass 

marriott meyer classification visual languages grammar hierarchies 
journal visual languages computing august 

corbett myers evaluating program representation demonstrational visual shell 
empirical studies programmers sixth workshop alexandria virginia january 

nardi small matter programming perspectives user computing mit press cambridge mass 

pandey burnett easier write matrix manipulation programs visually textually 
empirical study 
ieee symposium visual languages bergen norway august 

shneiderman direct manipulation step programming languages 
computer august 

smith cypher spohrer programming agents programming language 
communications acm july 

tanimoto visual language image processing 
journal visual languages computing june 

whitley visual programming languages empirical evidence 
journal visual languages computing february 

wittenburg visual grammars incremental parsing interface languages 
ieee visual languages illinois october 

yang burnett zloof representation design benchmarks design time aid vpl navigable static representations 
journal visual languages computing october december 
