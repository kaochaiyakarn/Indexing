efficient formal design verification data structure algorithms rajeev ranjan adnan aziz robert brayton bernard carl department electrical engg 
computer sc 
motorola md oe university california berkeley wm cannon drive west berkeley ca austin tx describe data structure set bdd algorithms efficient formal design verification 
argue hardware designs translated intermediate hierarchical netlist combinational tables sequential elements internally represented flattened network gates latches akin sis 
establish core computation bdd formal design verification forming image pre image sets states transition relation characterizing design 
step efficient address bdd variable ordering partitioned transition relations clustering don cares redundant latch removal 
techniques studied past 
provide complete integrated set modified algorithms give previous 
report experimental results series industrial examples containing binary valued latches 
supported motorola supported src dc design digital systems different levels verification corresponding major phases design 
phase initial specification high level description language vhdl verilog 
design verification concerned question specified wanted 
second phase synthesizing initial specification circuit implemented 
implementation verification concerned question synthesized specified 
traditional approach design verification simulation understood applied widely design community 
designers comfortable simulation thinking terms input patterns expected output patterns intuitive 
exhaustive simulation feasible moderately sized systems 
simulation serious drawback show absence errors presence errors 
formal design verification process mathematically proving system possesses set properties 
theory approach investigated decades years practical tools begun emerge 
overcomes drawbacks simulation currently limited relatively small designs 
seek improve efficiency verification larger designs verified 
detailed survey various verification methods 
design verification theorem proving usually requires extensive interaction human experts 
language containment lc model checking mc automated approaches verifying properties designs described state transition systems 
lc system properties specified automata 
verification problem equivalent verifying language system contained language properties cospan 
mc properties specified temporal logic model checking applied system specification verify properties 
verification tools manipulate state systems explicitly limited size state space 
real designs consist set interacting components leading problem state explosion 
context implementation verification coudert madre pioneered bdds implicitly manipulate product state space 
bdds extended manipulate transition systems area design verification smv 
describe data structure set algorithms efficient bdd formal design verification 
argue hardware designs mapped deterministic possibly multi valued gates latches 
early stages design process descriptions contain non determinism equivalently viewed coming unconstrained external inputs 
internally represented sis data structure large body bdd techniques developed sis operations sequential equivalence optimization applied 
data structure provides common somewhat familiar software development environment developers wanting write applications 
argue core computation bdd formal design verification forming image pre image set states transition relation characterizing system 
order step efficient possible address ffl variable ordering techniques 
ffl partitioned transition relations keeping components separate avoid large bdd size monolithic transition relation entire system 
ffl clustering grouping parts design reduce number iterations required image inverse image computation 
ffl ordering clustered transition relation efficient image pre image computation 
ffl don cares minimizing bdd 
ffl removal redundant latches 
approaches studied past 
comparisons previous details techniques 
salient feature algorithms completely automatic 
methods interdependent various combinations 
report subset combinations experimental results benchmark set consisting relatively large industrial designs 
algorithms described parameters default user specified 
universal choice settings yield best results examples 
ability set parameters prompt provided experiments possibly lead general purpose robust script novice users 
advanced user exploit core computation routines writing new applications possibly different parameter settings 
structured follows section ctl model checking language containment paradigms described 
introduce state explosion problem motivates need symbolic techniques state enumeration 
section presents data structure represent hardware designs suited formal design verification 
efficient bdd methods image inverse image computations described section 
conclude section commenting implications results indicating directions 
preliminaries image inverse image computations represents boolean set 
definitions pertain finite state system state bits inputs 
definition theta theta transition relation system state bits inputs 
implies state exists transition state input definition theta theta transition relation subset image transition relation set definition theta theta transition relation subset inverse image called pre image transition relation set definition theta theta transition relation set initial states system 
set reachable states system fixed point fa bg fag fbg fbg fag fg fag example illustrating kripke structure 
fs ap fa bg 
edge state indicates states labelled subset aps true state 
path sequence states oe oe delta delta delta oe oe formal design verification section informally describe ctl model checking language containment approaches formal design verification 
cases underlying design characterized kripke structure 
definition kripke structure triple finite set states ae theta transition relation ap labelling function mapping atomic propositions ap sets states 
pictorial representation kripke structure 
ctl model checking paradigm properties expressed formulas inductively defined syntax 
truth formulae interpreted states kripke structures determining truth value formula state structure referred model checking algorithmically performed fixed point calculations 
precise syntax semantics 
example state kripke structure models formula ef exists path state hold 
labelled path result mathematically obtained finding fixed point ex denotes set states satisfy formula set states labelled 
note set states satisfying ex set states reach states step computing inverse image respect transition relation 
similarly ctl formula need perform image computations 
language containment paradigm design identified set generated output traces ld property set acceptable traces lp verification consists checking design behavior acceptable checking ld ae lp turn equivalent checking ld lp empty 
kurshan observed certain classes properties deterministic automata set lp efficiently computable 
simple terms verification consists finding path kripke structure starts initial state leads fair cycle cycle includes state designated subset fair states 
conceptually check may performed finding set states reach fair cycle 
property fails initial state lies want ld lp oe fair cycles 
suppose represents set reachable states 
limit transition relation set reachable states 
algorithm find set states follows 
initialize 

compute fixed point computation gives set states reach states lie cycle 

compute fixed point computation gives set states reach states 



repeat convergence 

fixed point apparent equations core computation verification image inverse image sets states transition relation :10.1.1.1.5124
state explosion designs constructed linking components unspecified inputs assumed take value clock cycle 
synchronous product components defines single kripke structure referred product machine state space product components state spaces 
algorithms directly manipulate states time space complexity exponential size system description 
computational complexity problem known pspace complete 
complexity introduced concurrent interaction popularly referred state explosion problem 
quest heuristic solutions problem constitutes forefront research formal verification 
binary decision diagrams bdds canonical representations boolean functions boolean operations performed efficiently 
furthermore compactly represent wide variety commonly encountered functions 
transition relations sets states represented bdds characteristic functions efficient fixed point computations 
bdds extensively design implementation verification hardware systems non trivial design examples verified bdds 
instances medium sized circuits verified existing bdd techniques 
section provide partial survey state art bdd techniques contributions 
data structure designers typically specify systems high level language supports constructs integer arithmetic multi valued variables array structures 
smv enhanced verilog 
description system contains non determinism typically introduced part design abstracted hiding details 
non determinism comes play modeling behavior environment 
approach non determinism add new unconstrained inputs 
convert arbitrary system description deterministic netlist gates latches 
example consider verilog description xor gate arbitrary delay 
output gate non deterministic model arbitrary delay 
module xor clk inp input clk inp input ready output reg initial clk ready state non deterministically phi inp new unconstrained binary valued variable nd convert description deterministic netlist gates latch 
shown design yields kripke structure bisimilar original design safely place original 
determinization done automatically 
suppose ym non deterministic function xn component variables take binary values 
expressed nondeterministic multi output table illustrated example example 
add unconstrained input table 
corresponding deterministic table follows ready nd inp deterministic netlist gates latches represents functionality non deterministic verilog module xor 
variable nd new primary input system 
number additional external inputs equivalent solving minimum coloring problem undirected graphs 
lemma np complete decide binary variables suffice table 
proof membership np note checking table determinism easy form pairwise intersection cubes input space pair non empty intersection agree corresponding outputs 
new variables assignment guessed resultant table checked polynomial time 
np hardness reduction graph coloring 
fv vn gamma graph positive integer 
suppose dlog ne 
define non deterministic function input space output space 
corresponding table defined input space equation fy kxk kyk gives decimal value binary number represented vector similarly non trivial graph vertex degree corresponding table non deterministic 
adding single multi valued variable input space identify valid coloring graph values taken corresponding input minterm nodes corresponding minterm value distinct color 
fact deciding coloring exists complete finding number variables table binary outputs intractable 
similar argument run reverse demonstrates finding minimum number binary variables needed table easily reduces graph coloring problem heuristics exist complementing graph covering cliques determinization design translated hierarchical netlist deterministic single output gates latches 
internally read netlist flattened graph representation 
nodes graph indicate combinational logic blocks sequential elements latches 
nodes may annotated information original hierarchy certain partitioning clustering applications find useful 
familiar sequential synthesis tool sis immediately see similarity sis representation sequential logic circuits 
chose data structure allows easy access wide range bdd applications written sis variable ordering reachability analysis 
wide acceptance sis framework developing new applications suggests data structure may similar applicability 
approach advantage initial version number variables initially needed build bdds representing system drastically reduced state state primary input variables needed 
functional composition sis derive state output functions currently relational composition needed internal variables non deterministic 
furthermore state function latch specified separately correlation states carried newly created inputs 
expression core computation finding image set states equation image delta state variable latch state function state vector primary input vector 
transition relation th latch definition relation 
section describe evaluate expression efficiently bdds choosing appropriate variable ordering forming product incrementally heuristically chosen permutation clustering sets form smaller set transition relations pursue fact state function relation allows experimentation method proposed 
algorithms section various bdd algorithms efficiently perform core verification computations 
section techniques discussed achieve bdd variable orderings 
section presents clustered transition relations 
approach ordering clusters detailed section 
section describe fast technique removing redundant latches 
illustrate effectiveness algorithms contrast previous approaches set benchmark examples 
perform reachability analysis equation examples table demonstrate effectiveness algorithms image computations 
preliminary experiments indicate algorithms efficient inverse image computations 
report complete set results inverse image computations final version 
examples run dec workstation mbytes memory 
limit seconds cpu time mbytes data size running experiments 
ordering bdd variables mentioned earlier symbolic verification algorithms bdds underlying data structure 
success algorithms depends critically size resulting bdds sensitive variable ordering chosen 
logic function problem finding ordering leads minimum sized bdd function algorithmically intractable 
need apply heuristics 
dynamic reordering scheme bdd package automatically reorders variables minimize total number bdd nodes 
starting heuristic ordering leads better results 
invoking dynamic reordering takes significant amount time parameters useful controlling bdd size improving computational efficiency 
parameter base value total number nodes example latches gates description sbc iscas sequential benchmark snooping bus controller 
cache coherency protocol description hardware implementation distributed multiprocessor 
abstracted byte data link controller manages transmit receive protocol microprocessor serial bus 
contains description bit module 
part commercial chip 
version previous example 
bit modules interacting serial bus protocol 
abstracted version bus interface unit commercial microprocessor 
cache flush controller module commercial microprocessor 
table benchmark examples 
bdd manager reordering starts 
second parameter increment value amount number bdd nodes manager increase successive invocations reordering 
parameters chosen prompt changed dynamically course computation 
results discussion framework provide options ordering heuristics 
experiments chose heuristic shown outperform 
demonstrate effectiveness dynamic ordering initial ordering random heuristic performed experiments 
observe table large examples static ordering leads large bdd sizes 
examples shown table completed static ordering 
smaller bdd sizes case compared case indicate dynamic ordering heuristic initial ordering 
provide ability read manual ordering file 
feature especially useful want variable ordering previously generated heuristic dynamic reordering 
mentioned earlier dynamic reordering computationally expensive bypassing previously generated ordering provides significant computational advantage 
results shown table indicate previously generated ordering achieve speed improvement 
addition provide ability read partial orders heuristically complete obtain initial orderings 
incremental changes design previous ordering adapted updated design 
substantially improve dynamic reordering performance 
clustered transition functions common methods representing transition relation system different cases example case case case jt jrj time jt jrj time jt jrj time case static ordering performed 
case dynamic ordering performed random static ordering 
case static dynamic ordering performed 
number binary latches 
jt shared bdd size transition relation 
jrj bdd size reached set 
time time seconds perform reachability 
space 
table results various ordering heuristics 
example case case sbc case time perform reachability saved ordering file secs 
case table 
case time perform reachability saved ordering file secs table results showing effectiveness saved ordering files 
monolithic transition relation transition relation system represented single bdd conjunction transition relations individual latches 
circuit complexity grows size transition relation usually explodes 
approach infeasible large complex circuits 
partitioned transition relation vector transition relations element vector represents state relation latch 
coudert proposed reducing image computations range computations exploiting property constrain operator range computation performed recursive factoring 
efficiency comes caching intermediate results exploiting disjoint support 
touati suggested similar approach forming product balanced binary tree 
image computation pre image computation carried iteratively transition relations individual latches 
reasoning heuristically number latches system grows computation time increases 
simple extension approaches overcomes shortcomings 
represent transition relation system vector clustered transition relations 
state relation latch computed 
group transition relations clustered form vector clustered transition relations 
idea illustrated 
suppose original vector transition relations corresponding latches image image forming clusters latches take product corresponding transition relations 
clusters delta delta delta latches image computation equivalently written image tc tc 
burch proposed clustered transition relations represent circuits efficiently 
latches grouped form clusters automatic way form clusters 
technique possibly required user expertise circuit structure 
proposed clustering technique approach user specifies limit bdd size individual clusters partition size limit 
state relations latches ordered heuristics section 
state relations latches conjoined order product size surpasses user specified limit 
point current cluster complete stored array 
clustering continues starting latch 
results discussion table shows results clustering bdd size 
observations setting higher limits obviously leads fewer clusters total number bdd nodes taken clusters bigger 
equation observe image computation performed product transition relations clusters sequentially refer sequential iterations 
time taken forming product function number clusters cluster sizes 
results total cpu time convex function partition size limit 
intuitively reasoned follows 
limit yields procedure uses amount space results maximum number clusters equal number latches system implying maximum number sequential iterations 
threshold raised number iterations reduced bdd sizes operands increase 
reduction number iterations offsets increase bdd sizes greater computation complexity 
initially run time reduced cluster size increased 
bdd computation time starts dominate savings due decreased number iterations observe increase runtime 
true examples ones monolithic transition relation big 
ordering clustered transition relations system behavior represented terms clusters transition relations core verification operations image reverse image computation performed iteratively cluster time 
suppose represents examples partition size limit jt time jt time jt time jt time number partitions jt time table 
table results space time trade clustering bdd size approach 
set states represents transition relation th cluster image set transition relations mathematically image theta transition relations moved scope existential quantification depend variables quantified ordering transition relations equation rewritten image gamma gamma gamma gamma delta delta delta coudert proposed recursive image computation 
touati computes image set states exploiting property generalized cofactor converting image computation range computation ia denotes generalized cofactor respect 
range computation performed balanced binary tree leaves correspond terms variables nodes tree appear support nodes existentially quantified 
reported better performance 
burch criticized approach grounds generalized factor may introduce new variables supports terms delays ability quantify variables 
heuristically lead larger bdd size intermediate product terms 
note conjoined product term obtained far introduces new variables corresponding state variables 
heuristically argue number variables getting existentially quantified product term number variables getting introduced product term determine computational efficiency operation 
space requirement efficiency image pre image computations dependent order clusters processed 
ordering scheme partitioned transition relation proposed semantics underlying model 
requires detailed understanding semantics model easily automated 
geist give simple automated way order relations relation consists state function single latch 
primary criterion choose relation ordering maximum number variables quantified new product unique variables belonging partition 
case tie relation maximum support chosen 
approach clusters necessarily consist single latch ordering criteria take account number state variables introduced choosing cluster order 
maximum depth bdd ordering variable partition referred index variable affects performance 
reasoning existentially quantifying variable function computationally expensive depth variable ordering increases 
heuristic heuristic different factors decide ordering partitions 
maintain sets clusters set denotes set clusters ordered 
set initialized empty set 
set contains clusters ordered 
cluster set find parameters described 
ps ns denote set state primary input state variables respectively 
variable denoted represents set support variables denotes cardinality set 
vc tc ps tc number variables existentially quantified tc multiplied product 

wc ps tc number state primary input variables support tc 
xc ps tc number state primary input variables quantified 

yc tc ns number state variables introduced product multiplying tc 
ns tc number state variables introduced product 

mc tc ps maximum bdd index variable quantified support tc 
mc maximum bdd index variable remaining clusters 
order normalize effect parameters form ratios 

wc 

wc xc 

zc 

mc mc 
weights attached factors respectively 
order clusters obtained greedily choosing cluster best cost function value step 
chosen cluster moved set set process repeated sets ordered set empty 
framework weights interactively varied 
performed series experiments find combination weights 
results discussion table compares performance cpu time seconds ordering heuristic heuristics proposed 
specifically report time taken reached state computation 
weights chosen experimentation heuristic 
various heuristics example proposed space sbc table comparison cpu time seconds different cluster ordering heuristics 
results indicate proposed approach outperforms 
improvements achieved 
examples sbc touati heuristic performs marginally better touati approach ran memory 
don cares don care points arise naturally context bdd formal verification 
example consider fixed point computation finding set reached states init define frontier states iteration gamma gamma fg 
coudert observed set states gamma place equation preserving result gamma don care set minimize bdd size frontier states 
similarly transition relations simplified respect set states image computed 
framework provide option don cares arising manner 
conservative approximations states yield don cares 
set clusters fc compute upper bound projection reachable states product space component assignments latches component corresponding states attained environment 
components small approach fails give improvement typically states reached component components large fixed point computation fails 
provide routine computes medium sized clusters approx 
latches considerably smaller full state space cluster 
somewhat surprise corresponding states minimize transition relation component usually led larger bdds conducting experiments 
removing redundant latches basic motivation approach simplify bdd transition relations reached state sets removing variables 
latch redundant replaced wire changing functionality circuit 
replacing latch wire reduces number bdd variables heuristically reduce size bdds containing variables 
briefly describe methods find redundant latches remove 
constant propagation latch inputs tied vdd gnd 
algorithm detect latches propagate constant values term constant propagation 
example shown 
gnd vdd propagation constants latches redundant 
recursive algorithm removing redundant latches latch attach value parameter constant variable status parameter processed unprocessed 

mark latches unprocessed 

exists unprocessed latches pick unprocessed latch 
call function find redundant 

return find redundant 
processed return value constant variable 

mark processed 
tied vdd gnd assign value constant return 

assign value variable 
variable support state function latch corresponds primary input mark latch variable return 
represents wire constant value continue 
find latch state variable call find redundant 

modify state function latch propagating constant value fan ins 

state function constant change value constant 

return value 
algorithm state functions latches contain state variables corresponding redundant latches 
variables considered bdd manipulations 
latch removal retiming retiming rearranges storage elements circuit reduce cycle time reduce number storage elements changing functionality 
retiming reduce number storage elements 
simple example demonstrate shown 
note removing latch re timing 
inputs latches fed combinational logic 
state values latches 
new circuit redundant latch removed 
algorithm removing redundant latch retiming 
sort latches increasing order support size corresponding state functions 

pair latches equal support size suppose denote corresponding state variables outputs latches corresponding state functions 
find factors ix 
remove circuit replace wire illustrated 
results discussion results redundant latch removal techniques various examples shown table 
observe examples jt jrj jt jrj total latches constant latches removed constant propagation latches removed constant propagation latches removed re timing total latches removed redundant latches removed redundant latches removed jt jrj table 
table effects redundant latch removal bdd sizes 
reduction bdd size transition relation 
reduction obtained bdd size reached set 
analysis reset values latches ignored check consistency reset values 
optimization techniques applied reset values latches taken account 
constant propagation approach reset value latch match constant state value takes redundant 
retiming approach reset values latches identical removed 
analysis done easily 
similar approach proposed lin describes algorithm remove maximal set state variables affecting uniqueness reachable states 
problem approach need pre compute set reachable states 
big designs computing reachable states infeasible due size bdd technique redundant latches removed state relations calculated 
size transition relation reached state set reduced need compute 
approach orthogonal lin 
minimizing transition relation approach apply lin method possibly remove latches get reduction bdd size computing set reachable states 
beer mentioned constant elimination technique reduce number inputs memory elements algorithm proposed detect cases 
described data structure series algorithms efficient formal design verification bdd 
data structure represents non deterministic system deterministic netlist gates latches allows efficient manipulation hardware designs 
argued core computation bdd formal verification forming image pre image set states transition relation characterizing system 
step efficient addressed bdd variable ordering partitioned transition relations clustering don cares removal redundant latches 
efficacy algorithms demonstrated set industrial examples ranging size binary latches 
part second generation bdd tool logic synthesis formal design verification model checking language containment 
input enhanced version verilog compiled hierarchical netlist 
read network latches gates 
algorithms described integrated tool aimed users formal design verification developers interested creating applications top efficient core computation routines provided 
bdd techniques look promising include exists cofactor implicitly conjoined invariants 
plan experiment relatively easy data structure proposed implement methods 
certain limitations bdd formal design verification solved techniques described 
example size reached set may large variable ordering 
data structures useful cases 
wide class heuristics coping state explosion orthogonal approaches taken property specific reductions abstractions conservative approximations reached state sets 
believe techniques conveniently developed framework tested compared realistic examples 
gratefully acknowledge supported provided motorola src 
aziz 
cheng kam krishnan ranjan singhal 
wang brayton sangiovanni vincentelli 
bdd environment formal verification 
proc 
design automation conf pages june 
aziz singhal brayton sangiovanni vincentelli 
formula dependent equivalence compositional ctl model checking 
computer aided verification volume lecture notes computer science pages 
springer verlag 
aziz singhal brayton 
verifying interacting finite state machines complexity issues 
technical report ucb erl electronics research lab univ california berkeley ca sept 
aziz brayton 
bdd variable ordering interacting finite state machines 
proc 
design automation conf san ca june 
beer ben david geist 
methodology system practical formal verification reactive hardware 
computer aided verification volume lecture notes computer science pages 
springer verlag 
browne clarke grumberg 
characterizing kripke structures temporal logic 
technical report cmu cs department computer science carnegie mellon university 
bryant 
graph algorithms boolean function manipulation 
ieee trans 
comput aug 
burch clarke long 
representing circuits efficiently symbolic model checking 
proc 
design automation conf june 
burch clarke mcmillan dill 
sequential circuit verification symbolic model checking 
proc 
design automation conf june 

exploiting efficient fsm symbolic traversal transition relation 
proc 
intl 
conf 
computer design pages oct 
chen fujita 
bug identification real chip design symbolic model checking 
proc 
european conf 
design automation paris france feb 
cheng 
compiling verilog automata 
technical report ucb erl electronics research lab univ california berkeley ca may 
cho somenzi 
algorithms approximate fsm traversal 
proc 
design automation conf pages june 
clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm trans 
prog 
lang 
syst 
coudert madre 
unified framework formal verification sequential circuits 
proc 
intl 
conf 
computer aided design pages nov 
dill drexler hu yang 
protocol verification hardware design aid 
proc 
intl 
conf 
computer design pages oct 
emerson 
temporal modal logic 
van leeuwen editor formal models semantics volume handbook theoretical computer science pages 
elsevier science 
emerson lei 
modalities model checking branching time strikes back 
proc 
acm symposium principles programming languages pages 
garey johnson 
computers intractability 
freeman 
geist beer 
efficient model checking automated ordering transition relation partitions 
computer aided verification volume lecture notes computer science pages 
springer verlag 
graf 
verification distributed cache memory abstractions 
computer aided verification volume lecture notes computer science pages 
springer verlag 
gupta 
formal hardware verification methods survey 
formal methods system design pages 
kluwer academic publishers new york 
har el kurshan 
software analytical development communication protocols 
technical journal pages jan 
hu york dill 
new techniques efficient verification implicitly conjoined bdd 
proc 
design automation conf pages june 

jeong somenzi 
extended bdd trading canonicity structure verification algorithms 
proc 
intl 
conf 
computer aided design 

jeong somenzi 
variable ordering fsm traversal 
proc 
intl 
conf 
computer aided design 
lin 
synthesis vlsi design symbolic techniques 
phd thesis university california berkeley electronics research laboratory college engineering university california berkeley ca 
ebeling 
optimal retiming level clocked circuits symmetric clock schedules 
ieee trans 
comput aided design integrated circuits pages sept 
mcmillan 
symbolic model checking 
kluwer academic publishers 

computational theory implementation sequential hardware equivalence 
clarke kurshan editors proc 
workshop computer aided verification volume dimacs series discrete mathematics theoretical computer science pages 
american mathematical society june 

dynamic variable ordering binary decision diagrams 
proc 
intl 
conf 
computer aided design pages nov 
singh moon brayton sangiovanni vincentelli 
sequential circuit design synthesis optimization 
proc 
intl 
conf 
computer design pages oct 
touati lin brayton sangiovanni vincentelli 
implicit state enumeration finite state machines bdd 
proc 
intl 
conf 
computer aided design pages nov 
