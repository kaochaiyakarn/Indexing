calculus mobile agents fournet georges gonthier jean jacques evy luc didier emy inria rocquencourt le chesnay cedex france mail cedric fournet inria fr 
introduce calculus mobile agents give chemical semantics precise definition migration failure failure detection 
various examples written calculus illustrate express remote executions dynamic loading remote resources protocols mobile agents 
give encoding distributed calculus join calculus 
easy match concurrency distribution 
suppose instance want implement concurrent calculus ccs communication channels processes running different physical sites 
locate channels quickly face global consensus problem nearly communication uses interconnection network 
previous introduced join calculus asynchronous variant milner calculus better locality better static scoping rules 
avoids global consensus may implemented realistic distributed environment 
furthermore shown expressive power calculus 
extend join calculus explicit locations primitives mobility 
new calculus distributed join calculus allows express mobile agents moving physical sites 
agents programs core images running processes communication capabilities 
novelty distributed join calculus locations 
intuitively location resides physical site contains group processes 
move atomically location site 
represent mobile agents locations 
agents contain mobile sub agents represented nested locations 
locations move 
reasons organize locations tree 
calculus provides simple model failure 
crash physical site causes permanent failure locations 
generally location halt 
failure location detected running location allowing error recovery 
partly supported esprit basic research action confer 
aim calculus core distributed programming language 
particular operational semantics easily implementable distributed setting failures 
specification atomic reduction steps critical defines balance features realistic concerns 
spirit calculus calculus treats channel names location names class values lexical scopes 
location controls moves move location name received 
provides sound basis static analysis secure mobility 
calculus complete expressing distributed configurations 
absence failure execution processes independent distribution 
location transparency essential design mobiles agents helpful checking properties 
classical examples distribution mobility 
basic example remote procedure call timeouts 
dynamic loading remote applications second example 
java applets download process active communications simply moving location 
third example remote execution local agent dual case 
example combination second third 
client creates agent moves server perform task task completed agent comes back client report result 
take example dub client architecture casa paradigm mobility 
show causal error recovery integrated casa minimal implementation assumptions 
section review related 
section give brief presentation join calculus recall basics reflexive chemical machine framework 
section gradually extend join calculus 
section introduce location model refinement reflexive chemical model set new primitives aimed expressing location management migration 
section give final calculus copes failure recovery discussing various semantical models failure 
parallel develop main example client agent server architecture 
section suggest techniques formal proofs provide encoding distributed calculus join calculus state full abstraction theorem 
give directions 
related migration investigated object oriented languages 
initially distributed systems achieve better load balancing migration evolves language feature emerald objects moved machine attached object carrying attached objects moves 
language level numerous calling conventions call move reflect capabilities migration safety purposes advocated 
languages proposed large scale distributed programming support mobile agent paradigm 
instance obliq encodes migration combination remote cloning aliasing language global distributed scope 
examples applications large grain mobility obliq 
little support provided failure recovery 
functional setting facile provides process mobility site site communication higher order values 
design choices discussed chemical framework 
mobility locality meanings process calculi 
mobility calculus refers communication channel names channels locality tool capture spatial dependencies processes non interleaving semantics 
formal model developed core facile closely related 
calculus authors extend syntax calculus locations 
channels statically located location fail preventing communication channels location status tested language 
due properties calculus observation failures different usual observation encoding calculus calculus proved adequate 
introduce distributed calculus refinement core calculus join calculus 
join calculus specifically designed purpose leads simpler formal developments extensions capture migration failure 
chemical frameworks section introduce key notions syntax semantics distributed calculi briefly join calculus define observational equivalence 
join calculus basic process calculus 
extend introducing locations migration failure 
general setting calculus name passing calculus 
assume infinite set port names arities ports called channels 
lowercase variables foo bar denote elements names obey lexical scoping sent messages 
port names 
introduce values location names integers booleans letters denote values general 
assume names consistently processes respecting arities 
precise recursive sort discipline polyadic calculus 
assume processes sorted 
notations conventions tuple delta delta delta vn rr composition relations transitive closure relation chemical rules operational semantics chemical machine style berry boudol 
cham provides precise convenient way specify reduction modulo equivalence 
conveys intuition implementation schemes implementation costs especially distinguishing local global operations 
usual families chemical rules operate multisets terms called chemical chemical solutions structural rules reversible heating cooling represent syntactical rearrangements terms solution 
reduction rules gamma 
consume specific terms soup replacing terms correspond basic computation steps 
join calculus reflexive chemical machine rcham starting point join calculus described 
join calculus expressive asynchronous calculus 
furthermore calculus closer programming language calculus 
particular seen concurrent extension functional programming 
syntax terms calculus processes definitions def xhevi def jp def def xhevi jj process asynchronous emission message xhevi definition port names parallel composition processes null process 
definition reaction rules connected operator 
rules match join patterns messages trigger guarded processes 
considered extension named functions synchronization obey similar lexical scoping rules formal parameters vn received join patterns bound instance corresponding guarded process 
pairwise distinct 
defined port names recursively bound defining process def main process guarded processes inside definition name fresh regards process solution free 
write substitution name name variable oe arbitrary substitution 
assume implicit ff conversion bound variables avoid clashes 
received variables rv defined variables dv dv free variables fv fv formally defined full calculus 
local chemistry reflexive solution consists parts multiset running processes multiset active rules 
reaction rules define possible reductions processes processes introduce new names reaction rules 
chemical rules str join jp str null str str str def def doe dv oe dv range fresh red oe rv gamma 
oe rv structural rules state associative commutative units str def rule provides reflection static scoping discipline defining process activate reaction rules substituting fresh names defined variables 
conversely rules frozen process long names local process 
single reduction rule red describes active reactions consume join messages soup produce new instance guarded process 
presentation chemical rule assumes implicit context 
words omit parts multisets chemical solutions change effect rule 
instance verbose str def rule pg dv fp oe dv side condition oe dv dv 
gamma fv gamma fv gamma fv def 
example 
simplest process written sends name name examples shall assume existence basic values integers strings instance assuming printing service defined name print write 
program form def print integers order need printer send back message completion 
purpose printer return channel job 
def hi def hi practice sequential control common deserves syntactic sugar continuations implicit language pict 
write def print reply print print print synchronous names written print print remind carry implicit continuation channel definitions fresh names translate ev def join patterns reply def guarded processes caller side introduce bindings sequences nested calls 
reserved name translate top left right xh def xhevi def def xh def def def def hi xh observation choose observational equivalence framework formal basis reasoning processes 
step define reduction relation processes combination heating chemical reduction cooling def fpg gamma 
fp definition notation fpg stands chemical solution contains definitions running process idea observation characterize processes capabilities emit certain names 
testing particular name test name 
define testing predicate follows def 
test succeeds output name test enabled possibly internal reductions took place 
observational congruence largest equivalence relation meets requirements refinement congruence weak bisimulation 
processes holds implication implies equivalence discriminating barbed bisimulation congruence test emission name refer discussion examples proof methods 
definition observational congruence parametric reduction relation context syntax 
refine calculus apply definition yield refined equivalences 
computing locations refine reflexive cham model distributed systems 
partition processes definitions local solutions 
flat model suffices representing local computation different sites global communication 
introduce structure account creation migration local solutions attach location names solutions organize tree nested locations distributed solutions distributed reflexive chemical machine multiset chams write global state solutions separated chemical rules mention solutions left unchanged 
convention local solutions evolve internally rules 
interact new reduction comm xhevi gamma 
xhevi dv rule states message emitted solution port name remotely defined forwarded solution definition 
message consumed red rule 
step decomposition global communication reflects happens run time actual implementations message transport message treatment distinct operations 
consider formed name defined solution 
transport deterministic static point point synchronization done locally receiving site message treatment 
distributed model computation hides details message routing synchronization 
location tree order compute locations view syntactic definitions local chemical solutions location names relate 
set location names denoted letters location names finite strings location names 
running locations local labeled solutions define relation prefix 
multisets labeled solutions labels distinct prefix closed uniquely identified rightmost location name 
conditions ensures solutions ordered relation form tree 
location names class values statically identify location 
port names created locally sent received messages obey lexical scoping discipline 
introduce new locations extend syntax definitions new location constructor def heating direction semantics new construct create current location containing unique definition unique running process precisely new structural rule str loc fdg fpg frozen side condition means solutions form non empty label 
definition contain definitions side condition guarantees syntactically captures subtree 
complete cooling freezing effect locations useful controlling migration 
previous chemical rules apply unchanged explicit labeling solutions 
worth noticing str def applies defined location names introducing fresh locations running processes 
formed reaction rules defining name belong single location 
maintain invariant dilute definitions constrain syntax accordingly multiple definition dv dv contains port names defined example 
simplest example distribution send value remote name 
instance may assume printer running location server print request sent location client print print definition print location solution 
particular client example 
remote procedure call abstraction previous example sends value remote service waits result 
reply computation def rpc reply rpc rpc visible solutions 
contrast rpc local considered part communication library 
elaborate definition rpc handles timeouts def rpc error def reply rpc start rpc error handler message guarantees mutual exclusion normal return remote call timeout error message 
migration ready extend syntax processes new primitive migration new chemical reduction def move gamma 
jhi informally location moves current position tree new position ba just destination solution identified relative name arrives continuation hi trigger computations 
case rule str loc cool location definition side condition frozen forces migrate time 
consequence migration ruled nested migrations parallel confluent 
notation port names primitives go delta deltai 
extend synchronous call convention accordingly go delta 
notice primitives class names sent values messages 
example 
example distribution download code code server la java computation take place local site 
load applet def applet reply applet go reply applet load applet load applet reduces server local copy applet load applet def applet reply applet go reply applet load applet applet reply applet applet assuming applet include go primitive remains attached program behaves fresh copy applet defined location building casa opposite retrieving code sending computation remote server 
client defines request request moves server runs sends result back client def go reply server code remote computation returns tuple basic values 
general result contain arbitrary data allocated computation active data processes internal state 
generic casa server just return pointer data move data code back client location 
illustrate consider agent allocates uses cell new cell creates fresh cell returns methods set updates get access 
def def go set get new cell set computation go reply get server data allocated agent location arrival server 
need pre allocated grows demand computation 
eventually agent client go primitive call 
failure recovery modeling failures litmus test distributed computation formalism 
absence failures locations pragmatic significance semantic importance 
fact come simple failure model calculus spawned join calculus 
section failure model introduce failure management primitives show examples discuss choice failure model 
representing failures marker omega tag failed locations 
denotes omega denote strings omega appears location string failed locations say dead contains omega alive position tag indicates failure triggered 
process syntax failed locations frozen tagged definitions omega general shape location definition 
order preserve scopes structural rules allowed failed locations structural rules unchanged sections obvious generalization str loc failed location syntax 
model failure prohibiting reactions inside failed location 
precisely add side condition red comm move prevents rules messages go delta deltai primitives solution dead label 
note prevent messages locations moving failed location moves unavoidable asynchronous distributed setting 
failure occur named location top solution provides safe haven pervasive definitions behavior integers may put 
need consider equivalences calculus failures static equivalence congruence def xhevi message def definition inert process jp composition migration termination failure detection def local rule inert definition definition sub location omega dead sub location def xhevi message pattern jj join pattern fig 

syntax distributed join calculus dv xhevi def fxg dv def dv dv dv def dv dv def dv dv def dv dv dv def fag dv fv xhevi def fxg fu fv def fv def fv fv fv def def fv fv gamma dv rv xhevi def fu rv def rv rv fv def dv fv gamma rv fv def fv def fv fv fv def fag fv fv fv def fa fv def fv def fa formed conditions scope location variables defined port variables appear join patterns location cf 
fig 

scopes distributed join calculus str join jp str null str str str def def oe dv range fresh str loc fdg fpg frozen red oe rv gamma 
oe rv alive comm xhevi gamma 
xhevi dv alive move gamma 
jhi alive halt gamma omega alive detect gamma 
hi dead alive side conditions str def oe dv instantiates port variables dv distinct fresh names red oe rv substitutes transmitted names received variables rv frozen means solution dead contains omega alive 
fig 

distributed reflexive chemical machine delta delta constructor mobile equivalence congruence full calculus 
notions coincide processes export agents 
primitives failure recovery introduce new primitives delta deltai 
location location permanently inert rule halt triggers hi detects failed parent locations halted rule detect 
note alive side condition rules move comm sufficient prevent output dead location attached rules red halt detect consistency 
conjunction static equivalence primitive allows calculus express site failure patterns prove equivalence top level location move fail executes 
addition encode kill operation def start load applet fail delta deltai primitive provides natural guard error recovery 
example casa secure follows def fail reply error occurs agent returns permanently client fail permanently disabled 
conversely fail triggers server failed hosting agent agent return server new agent created sent server 
anyway assured agent large action completed quite important say action get plane ticket 
true client know server location agent moved intermediate sites reaching server location 
uniqueness property difficult obtain timeouts 
fail delta deltai primitive provides information timeouts 
timeouts easier implement model just silent transitions bisimulation process calculus natural complement fails 
rpc interactions asynchronous side effects little practical uniqueness property simpler timeout preferable fail check 
failure models failure mean 
conservative answer messagepassing setting location fails messages location lost 
hard sensible error recovery weak model impossible issue replacement failed agent running risk having interfere side effects 
assuming messages failed agent lost solve 
unfortunately strong model consistent comm rule asynchronous distributed setting 
require system track delete messages issued failing location 
reasonable requirement failed location respond messages enforced blocking output locations detecting failure having received messages triggered failure detection 
weak asynchronous model easily seen testing equivalent strong asynchronous model simply delay failure required output leave justified stricter simpler model calculus implementing weaker 
models give different interpretations xhi xhi bisimulation congruence 
proofs mobile protocols primary purpose calculus core language expressivity distributed mobile programming 
locations primitives model fallible distributed environments specific contexts calculus 
result observational equivalence relate precisely distributed implementations specification simpler programs contexts failures distribution 
combination usual proof methods developed process calculi provide setting design proof distributed programs realistic assumptions 
section explore setting simple examples internal encoding locations 
equivalence relation observational congruence defined section applied distributed join calculus section 
due lack space proofs omitted 
sample equational laws state garbage collection laws useful simplifying terms proofs resides failed location guarded patterns messages assembled free port names go delta deltai primitives 
second basic laws hold go delta deltai fail delta deltai primitives 
instance fail fail fail fail primitives strictly static analysis local usage yields simplifications location tree 
laws show get rid location reached final destination contain go delta deltai boundary irrelevant def def location empty migrations failure detections name parent name distinguished def def internal encoding translation distributed join calculus features introduced section section simpler join calculus section 
combination encoding join calculus calculus provides alternative definition migration failure usual setting process calculi 
suggests distributed extension unduly add semantic complexity 
basic idea replace location construct definition supports equivalent protocol locality information message call protocol 
done structural translation distributed process simply explicit side conditions 
instance xh ping xh ping checks current location alive returning mimicking comm rule 
interface encoding location consists port names 
stands location value provides internal access current location 
sent encoding location primitives ping fail halt go 
corresponding implementation delta defines primitives top level location def def poll reply poll poll reply alive failed poll get reply get poll reply retry poll def reply poll kill get set poll reply poll def ping repeat alive reply ping def fail repeat failed reply fail def kill def go get set def attempt retry failed alive reply done attempt reply retry attempt repeat attempt get done def def top reply alive top top reply retry top get reply top kill get set def eai 
delta ping fail halt go def xhevi def ping xhevi def fail hi def def go hi def def def def delta delta delta delta translation assume location names pairwise distinct 
omit formal translation syntactic sugar control symbolic constants repeat 
placed arbitrary context encoding exports init message 
context set arbitrary location tree location primitives starts translation location providing valid interface ea 
keep things simple refined sort discipline target calculus port names special sorts local restricted congruence contexts define sends messages names sorts 
particular prevents contexts accessing internal representation protocol 
believe limitation enforced firewall techniques 
theorem encoding delta fully observational congruences distributed join calculus local join calculus ea oe fv local special case contexts simple join calculus discriminating power distributed ones long exchange location names 
condition automatically holds simple processes considered distributed processes meaning simple distributed observation coincide 
sharp contrast calculus locality distributed congruence strictly finer local local processes 
laid groundwork calculus distributed processes mobility failure investigated process calculus techniques proving distributed protocols 
complement specific tools needed weaker equivalences fairness 
order validate approach plan apply distributed join calculus asynchronous protocols unreliable setting security requirements currently experiment design implementation high level programming language founded calculus 
acknowledgments benefited numerous discussions roberto amadio erard boudol damien doligez guillaume benjamin pierce peter sewell david turner 

amadio prasad 
localities failures 
th foundations software technology theoretical computer science conference 
springer verlag 
lncs 

berry boudol 
chemical machine 
theoretical computer science 

bharat cardelli 
migratory applications 
technical report dec src february 

boudol castellani hennessy 
theory processes localities 
formal aspects computing 

cardelli 
language distributed scope 
computing systems jan 

fournet gonthier 
reflexive chemical machine join calculus 
rd acm symposium principles programming languages jan 

mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming 

honda yoshida 
reduction process semantics 
theoretical computer science 

jul object mobility distributed object oriented system 
phd thesis university washington computer science department dec 

leth thomsen 
facile chemistry 
technical report ecrc european computer industry research centre munich may 

milner 
polyadic calculus tutorial 
logic algebra specification 
springer verlag 

pierce sangiorgi 
typing subtyping mobile processes 
mathematical structures computer science 
appear 
summary lics 

pierce turner 
concurrent objects process calculus 
theory practice parallel programming sendai japan apr 
lncs 

sangiorgi 
localities non interleaving semantics calculi mobile processes 
technical report ecs lfcs university edinburgh 
appear tcs 
