systems performance measurement pci pamette laurent moll pole universitaire leonard de vinci la defense france 
laurent moll fr mark shand digital equipment systems research center palo alto california usa 
shand acm org describe reconfigurable board obtain information performance expected particular systems 
goal reconfigurability board interface test system discover maximum bandwidth best latency attainable way reliably achieve figures 
board uses widespread pci bus 
pci sufficiently complex implementations sufficiently varied impossible guess performance obtained specific board specific computer technical characteristics hand 
observe astonishing performance differences identical systems comparable figures small pcs big servers 
performance tests serve demonstrate value reconfigurable bus interface 
board test choose system informed architectural decisions hardware software interface finely tune bus interface get maximum predictable figures running application 
pci pamette reconfigurable computing device uses pci bus connect host processor 
pci pamette follows strongly tradition pam project reconfigurable logic seen coprocessor designed harmony host processor 
applications seek leverage maximum presence modern microprocessor replete powerful graphics fast disk subsystems high speed networking modern workstation high pc 
performance applications depends critically performance host link 
approached pci 
previous experience systems digital simple high performance system expansion bus early enabled members pam project digital paris research laboratory build coprocessors dma performance mb 
pci promises theoretical peak performance mb clear cursory reading pci specification pci far complex bus allows opportunities implementations introduce performance degrading artifacts 
pci confirmed fears developers reporting seeing performance mb pci rapidly achieved total market dominance tier expansion bus pc macintosh workstations high servers pci bus choice performance oriented reconfigurable coprocessors seek standard bus 
apart high graphics current devices mb throughput reconfigurable coprocessors exception 
significant part design effort pci pamette gone understanding pci performance achievable achieve 
outset system exercising measurement seen important applications pci pamette 
reconfigurable technology measure performance understood value 
complexity pci disappointing early performance figures obtained repeating sorts measurements pci compelling 
pci aggressive electrical specification making challenging implement custom chip 
quickly ruled commercial pci interface chip flawed way offer reasonable performance 
case pci pamette bit pci board commercial interface bit 
logic pci pamette implemented entirely fpgas including pci interface reconfigured circuit 
describes collection simple designs implemented pci pamette gather performance figures 
designs sample results provided giving idea sorts results obtainable may vary 
platforms intel pc compatible systems running windows nt alpha workstations servers running digital unix windows nt 
contributions fold ffl measurement bus exercising application domain right show utility reconfigurable computers domain 
application domain added utility applications domains easily reuse pci interfaces developed bus exercising applications 
ffl results architects pci reconfigurable systems 
ffl results help design test conventional fixed circuit pci interfaces represents instance emulation fpgas 
easily reconfigured fpga system easy embed instrumentation circuitry measurement reconfigurable board performing emulation 
section simple application spies pci bus traffic 
fully passive system intrusive monitor full pci transactions system logic analyzer 
section fully programmable pci master slave engine associated section passive spy allows user test maximum bandwidth system operating modes tune parameters application get best system 
setup test prototype boards pci pci bridges 
section describe enhanced open version passive spy adapted specific needs 
offer examples 
section show simple setup tests interrupt latency figures specific machine operating system pair 
figures particularly interesting realtime applications 
simple passive bus spy pci basics pci bus designed versatile adapted servers small pcs 
assumptions device ability sustain continuous transaction number cycles 
observe bus long transaction bit word transmitted cycle followed single byte transaction lasting cycles 
details pci bus help better understand rest article ffl data transfers broken transactions 
transaction initiator target 
host bridge processor pci interface just devices bus 
device responds certain multiple address space assigned individually boot time 
ffl initiator requests transaction gets arbiter sends address command transaction type waits target respond 
data transfer happen direction initiator target target initiator depending command issued 
ffl cycle target initiator declare ready accept deliver data introducing wait cycle 
ffl amount data transferred initiator target decide transaction 
particular target decide retry transaction data transferred temporarily unavailable disconnect transaction data transferred ready pci latency requirements 
ffl pci clock frequency vary dynamically dc mhz 
system keep clock frequency mhz 
calculations measurements assume mhz clock 
bandwidth perspective best case occurs transfer target initiator starts quickly address cycle data words sent cycle long time master stops transaction transferred data wished transfer 
result near optimal bus bandwidth allowing mb bit pci mb bit pci 
maximum length transfer needs limited reduce latency seen bus reality pci performance limited devices exhibit features ffl ready retry frequently pci isa bridges 
ffl long latency address cycle initial data cycle especially true host bridges required read host memory 
ffl send receive data cycle 
ffl transaction small fixed amount data transferred 
devices exchange data features combine result disappointing 
devices bugs configured operate degraded performance modes function correctly performance poor 
systems pci board performance ranges mb systems usually hard get mb designed specifically tuned pci interface 
implementation spy lca lca mhz pci pci pamette lca lca sram sram addr data control mhz simple spy passive spy implemented pci pamette uses straightforward design shown 
pci pamette consists theta matrix fpgas called user area fifth fpga called 
pci pamette xilinx fpgas terms fpga lca interchangeably describing board 
pci interface chip special promiscuous mode pci control signals seen board including interrupts bit pci control signals bits address data bus depending motherboard sent user area multiplexed time bits mhz 
user simple counter counter increments external address lines data sent data lines banks theta ns provide necessary bits mhz bandwidth 
read data just download new configuration containing standard sram reading design analyze results 
spy spy look transactions pci simply prefix code starts transactions write board triggers data collection 
short delay download sram reading design see happened 
simple mode instance watch types lengths transactions issued graphics scsi card 
traffic generation performance analysis pio slave dma engine obtain maximum performance tune pci transactions add traffic generation scheme simple passive spy 
focused kinds transactions ffl programmed input outputs initiated software 
consist reading writing values board 
case host bridge initiator board target 
ffl direct memory accesses dmas initiated board transfer data host memory 
board initiator host bridge target 
generated simple piece code accesses board course slave part board responds requests 
tests interface programmed response slave bit requests depends target address 
choose bit bit transactions directly software bit pci systems course 
dma traffic generated full pci master programmed 
contrary dma engines extensively programmable test pci transaction parameters 
test dma engine pci pamette capable generating transactions attributes ffl full set pci command codes memory legacy os read line read multiple write invalidate 
ffl total amount data transferred 
ffl size bursts engine stops transaction target done 
ffl number idle cycles transactions 
ffl bit requests 
passive spy preceding section generate traffic read full transaction log 
precisely analyze results finding patterns trying tune parameters achieve better performance 
single board performance tests passive spy resources pci interface lca fit pci master target engine spy board 
automated program test characteristics system generating kinds traffic modifying parameters 
shows examples performance measured alpha workstations servers intel pc 
kinds performance figures interesting dma write board writes memory usually impressive 
address data sent direction latency usually small 
memory systems wide asymptotic bandwidths mb mb bit pci reached 
behaviors degrade performance considerably 
older host bridges disconnect transaction double boundaries cases board interface programmed bursts size exactly 
small number idle cycles inserted request bus ensure host bridge ready time burst retry transaction 
host bridges allow pci memory write invalidate command perform long bursts disconnect ordinary memory write commands 
common problems include disconnects wait states inserted th th data word memory system saturated internal buffers host bridge full 
alphastation host bridge disconnects data words reach mb simple pc fx aka 
get mb alphaserver bit pci get mb alphastation bit dma writes marginally faster bit mode 
designers workstation explicit decision mb adequate disk network focused effort support graphics primary bandwidth requirement host pci option dma read pio write 
dma read board reads memory kind transaction resembles dma write involves roundtrip memory system data returned latency initial data large 
high servers alphaserver memory different subsystem pci host bridge latency tens pci cycles bandwidth memory backplane gb pentium pro memory latency averaged cycles values spite fact version pci specification states value greater 
dma read especially critical long bursts amortize cost memory latency 
pci protocol provides different flavors memory read command provide hints target long transaction optimize prefetch subsequent data 
platforms support long bursts essential hints sustain long burst 
platforms systematically disconnecting transactions alphastation reach mb standard long bursting platforms reach mb mb bit pci machines 
pio write processor writes board little optimize pio write performance target side respond quickly accept data cycle 
pio write performance depends mainly ability processor host bridge aggregate writes 
program issue bit writes single machine instruction 
writes sequential region processor host bridge aggregate writes order issue longer burst amortizing overhead starting pci transaction 
alpha intel platforms different respect 
alpha writes aggregated reordered merged processor may delay write cpu cycles hope writes performed nearby locations may aggregated pending write sent chip 
result policy ordering writes explicitly managed platform cpu host bridge dma write dma read pio write pio read alphaserver custom bridge alphastation alphastation alphastation hp xu pentium pro kx digital gl pentium pro fx digital gl pentium fx digital xl server pentium nx figures mb available bit pci performance parenthesis 
maximum sustained bandwidth selected systems 
machine code order significant instance face order dependent side effects writes hardware devices performance fairly high 
intel platforms writes pci board strongly ordered merged aggregated perfectly sequential sent short time period pentium standard loop writing board provoke byte bursts tight assembly code lead byte bursts 
pio performance intel machines usually fairly poor special optimization 
kx aka 
orion workstation pentium pro machines write aggregation completely disabled bugs revisions chipset lead data corruption 
machines best pio write performance mb pio read processor reads board kind transaction usually slow avoided large data transfers 
cases pio reads single memory quantum reads bits intel bits alpha 
exceptions alpha systems cpu 
able support multiple outstanding reads aggregated chip single transaction 
tight loop sequential reads machine generally produces stream byte bursts giving alphaserver instance mb throughput 
imagine improved turns load sequence word byte block word intervening words usually generates byte burst platform allowing reach mb bit mode 
size fits factors numerous full treatment affect pci performance 
instance versions alphaserver mhz cpu mhz cpu data processor cache bit dma read performance degraded bit dma read performance 
alphastation hand presence data processor cache boost performance 
section best figures able achieve 
obviously difficult forecast actual bus bandwidth certain board obtain platform matters get worse include application specific constraints 
pcs usually best avoided large transfers pio writes largely sufficient alpha platforms 
considerations determine major architectural decisions affecting hardware driving software pci pamette applications 
debugging setups combination simple passive spy traffic generator single board performance tester debugger pci interface 
schemes envisaged digital ffl single board spy specific board provided pci bus pci pamette 
generate peer peer traffic exposing board kind transaction emulating behavior conceivable host bridge 
keep long traces dram verify protocol violations occurred 
ffl boards connected flat cable different system different bus spy means communicate results real time 
setup results non intrusive logic analyzer real time highbandwidth link system 
ffl board setup debug special pci devices pci pci bridges 
put board side bridge generate traffic bridge getting trace sides 
setups minor variations basic pci exercising configuration 
exploit reconfigurability boards special feature time stamping implemented matter hours days moderately experienced pci pamette programmer 
application specific bus spy basic design possible extensions simple spy section useful cycle cycle line analysis real time board trace computation useful needs sophisticated design 
low level pci custom version needed needs common front hiding pci complexity form basis variety application specialized measurement applications 
implemented core design receives full pci signals simple spy computes pci transaction compact summary principal characteristics ffl starting address 
ffl transaction type 
ffl number words transferred 
ffl address data latency 
ffl total number wait states 
ffl total length transaction 
ffl transaction terminated 
ffl time stamp transaction 
summary produced front customize spy specific needs adding application specific 
rest resources board remaining programmable logic gates drams daughter board connector pci interface 
implement functions need 
extensions may want add ffl programmable filters 
filtering address allows restrict attention traffic certain device 
getting base address board system get transactions chosen board target 
cooperation chosen board driver get pci mapped address memory buffers board spy dmas initiated board 
ffl real time performance counters 
filtering traffic related specific board maintain running totals various transaction characteristics calculate real time amount data transferred board pci bus loading attributable board average latency average time transactions various histogramming type measures 
example pc real time clock simple application requiring implementation programmable comparator mask spy logs transactions specific device recognized base address 
legacy device fixed address space modern device settable address memory space capture device 
shows filter address hex space corresponds pc realtime clock rtc 
device sits isa bus side pci isa bridge 
log start understand true burden isa transactions carried pci bus 
log comes alphastation running digital unix uses standard pc hardware configuration 
pci cycle deltas right column log confirm rtc logged transactions appear groups intervals approximately pci cycles 
mhz period corresponds ms digital unix rtc configured interrupt hz 
see usual initial data latency reads cycles find observing device pci version compliant 
total transaction lasts cycles single byte transferred 
writes average latency cycles going 
transaction tries write single byte address pci isa disconnects cycles data transferred 
write retried repeat done 
example takes transactions retried total cycles complete 
excellent example bad standard isa devices pci system reliance legacy buses degrade performance levels system 
trans 
addr 

dur 
lat 
delta cycle simple filter address real time clock example memory channel spy memory channel digital high cluster interconnect tightly couple servers high speed link 
hardware component product consists full length pci board machine active hub exchange data boards 
applications standard api send receive data memory channel system 
data transfer model chosen system push model data sent local adapter software data goes hub dispatched targets 
targets adapter sends data dma specific place host memory 
software point view part machine address space mapped memory space part physical memory mapped address spaces machines 
writing certain part memory automatically writes physical memory designated machines 
memory channel provides locking error recovery interrupt mechanisms 
pci pamette non intrusive spy memory channel systems 
dividing address space number fixed regions keeping histograms traffic particular regions memory channel address space identified 
effort pci pamette programmed know page control table kept mc adapters selects destination mapped address local remote page mapped space control information received mc adapter maintain copy pct 
additional information software subsystems disk database failure recovery 
associated pct entry produce real time line histograms subsystem 
physically optimize cluster optimize code client instance guaranteeing pio writes undergo maximum possible aggregation alpha write buffers scarce pci bandwidth better utilized 
advantage approach need instrument software distort true response system need hardware modification mc adapters spy evolve hardware needs customers physical change 
interrupt dispatch latency real time capabilities motivation pci pamette applications execute part host processor part pci pamette need mechanisms synchronize 
allow processor poll state pci pamette signal state latencies measured fractions microsecond 
applications synchronization needed pci pamette applications strong real time requirements 
pci pamette host runs multitasking operating system real time applications mercy operating system scheduler tie processor busy polling high priority process 
pci pamette needs mechanism initiate synchronization processor 
unfortunately dmas perform pci pamette host processor 
interrupts 
interrupt latencies longer far far variable pio latencies 
characterizing latencies essential designing applications meet real time goals 
aspects important average cost handling interrupt determine load placed system interrupt rate maximum interrupt handling latency determine amount buffering needed pci pamette waiting interrupt service 
levels interrupts handled terms specific windows nt interrupt scheme common unix systems ffl interrupt service routine device driver decide board responsible interrupt interrupt lines shareable pci shut small amount processing related interrupt 
isr runs high level priority execute long system stalled running 
ffl deferred procedure call kernel mode lower priority level driver finishes tasks associated interrupt setting new dma 
ffl user mode code called driver blocking call processing done 
interrupt handling standard boards occurs mainly levels 
pci pamette reconfigurable board sought device drivers supporting completely generic want oblige pci pamette application developer write kernel mode non portable code 
control board relegated user mode code direct access board 
particular interrupt signals routed user mode application requested receive 
driver minimum generic actions consist checking source interrupt shutting 
queues request deferred procedure call unblocks user mode thread waiting interrupt 
unfortunately big disadvantage approach time necessary wake user mode thread longer processing interrupt directly kernel mode 
interrupt dispatch time depends operating system scheduling policy maximum locked times 
device drivers time spent hardware priority levels 
setup results design board test interrupt latency fairly simple 
contains free running settable counter triggers interrupt value crosses zero 
mechanism allows record time ffl interrupt triggered 
ffl interrupt service routine started ended 
ffl deferred procedure called started 
microseconds idle loaded histogram time isr pentium pro windows nt microseconds idle loaded histogram time user handler pentium pro windows nt ffl user mode thread unblocked 
important trigger interrupt pseudo randomly free running counter allows measures accurately reflect ensemble system activity 
shows histogram latency hardware interrupt entry point isr interrupts idle loaded system 
shows corresponding data unblocking waiting user mode thread 
axes logarithmic scales times ms truncated 
figures obtained thread maximum priority real time time critical hp xu pentium pro running microsoft windows nt 
tests applied alpha systems running windows nt digital unix 
histograms exhibit sharp peaks 
loaded system cases isr called microseconds user mode thread starts run microseconds 
position peak thread unblocking latency idle system estimate kernel mode cost typical interrupt 
appears microseconds system sup experimentation effective way load windows nt system rapidly drag large window 
port interrupt load second 
tail long 
times isr millisecond times user mode thread excess milliseconds observed pci pamette applications strong real time requirements need budget autonomy platform 
number applications reconfigurable computing platform called pci pamette come general heading system exercising measurement 
results particular focus pci bus 
demonstrated practical techniques measure parameters live systems 
measurements done conventionally logic analyzer course writing authors personally gathered results systems palo alto ca nh maynard ma paris france sydney australia ayr scotland 
author ayr pci pamette attached computer internet 
reconfigurable technology software aspect application traditionally involves direct physical manipulation 
active application specific measurements sections vigorously exploit reconfigurability difficult perform conventional techniques 
interfaces developed modes operating achieve best performance reused applications pci pamette involve measurement pci bus 
data goes little deeper common presentation pci mhz bus peak throughput mb understandable manufacturers reluctant unable accurately characterize performance devices 
pci performance complex issue device treated isolation 
trust results useful designers users pci systems reconfigurable computing community pci performance important issue 
lastly pci pamette served traffic generator emulating pci devices various performance characteristics test debug conventional fixed circuit pci interfaces systems 
owes intellectual debt jean vuillemin founder pam project 
pci pamette didier philippe patrice bertin helped development early prototype 
mark shand pci pamette world wide web www research digital com src pamette 
jean vuillemin patrice bertin philippe didier mark shand touati programmable active memories reconfigurable systems come age ieee transactions vlsi systems april 
mark shand measuring unix kernel performance hardware prl research report aug 
ftp ftp digital com pub dec prl prl rr ps pci local bus specification pci special interest group 
john john murray paul design verification alphastation series workstation digital technical journal volume number special edition 
kaufman experiences st generation memory channel pci network hot interconnects symposium iv stanford university palo alto ca 
custer inside windowsnt microsoft press 
real time systems microsoft windows nt msdn library microsoft june 
