logics type systems een op het van de wiskunde en informatica ter van de van doctor aan de katholieke universiteit nijmegen van het college van het te op september des te uur door jan herman geuvers mei te nijmegen promotor professor dr barendregt logics type systems herman geuvers cover design jean bernard cip den geuvers jan herman logics type systems jan herman geuvers 

nijmegen nijmegen nijmegen 
met lit 
reg 
isbn logica voor de informatica 
iv contents natural deduction systems logic logics extensionality useful variants systems easy conservativity results conservativity logics truth table semantics classical propositional logics algebraic semantics intuitionistic propositional logics kripke semantics intuitionistic propositional logics formulas types formulas types notion la howard completeness embedding comparison embeddings reduction derivations extensions higher orders formulas types notion la de bruijn pure type systems definitions examples pure type systems morphisms cube typed lambda calculi logics pure type systems morphisms pure type systems inconsistent pure type systems meta theory pure type systems specifying notions studied analyzing fij equality pseudoterms list properties pure type systems vi contents cr fij proof cr fij normalizing systems discussion calculus constructions cube typed lambda calculi logic cube meta theory cc intuitions calculus constructions formulas types logics cube formulas types embedding cc formulas types embedding subsystems cc conservativity relations inside cube consistency contexts cc formulas data types cc sn fij cc meta theory cc fij conversion proof sn fij cc obtaining sn fij cc sn fij 
strong normalization fij reduction 
discussion confluence normalization semantical version systems supervisor henk barendregt creating stimulating research environment half years letting find way jungle interesting subjects research 
sharing knowledge am grateful researchers able talk listen 
especially contact reverse alphabetical order benjamin werner marco thomas streicher randy pollack christine paulin mark jan nederhof james mckinna zhaohui luo bart jacobs gardner gilles dowek thierry coquand stefano berardi bert van benthem jutting erik barendsen thorsten altenkirch pleasant fruitful 
earlier stage contact important lectures guided field logic stimulated interest foundational issues 
particular respect contents thesis furthermore manuscript committee consisting rob nederpelt jan willem klop thierry coquand judgement 
special rob nederpelt detailed comments part earlier version james mckinna valuable comments english contents typos 
erik barendsen deserves special knowledge willingness answer technical questions thesis 
pleasant working environment valuable necessary condition result 
people faculty pleasant especially research groups foundations computing science parallelism computational models 
support ups downs thesis 
vii viii contents propositions 
define mapping gamma full sorted order predicate logic higher order proposition logic follows 
rt oe oe example oe px px oe left object variable right propositional variable 
similarly left relation symbol right higher order variable 
fact range mapping gamma small extension second order logic 
mapping gamma sound complete 

fixed point combinator pure type system 
benjamin werner 

system higher order propositional logic prop 
conservative extension second order propositional logic prop 
proof uses fact complete heyting algebras constitute sound complete model prop 
delta set formulas formula prop delta prop 
derivation theta general true normal form theta obtained eliminating cuts derivation delta prop 
typed lambda calculus corresponds facts 
gamma context oe type 
gamma oe gamma nf oe ix contents gamma oe gamma oe surprising purely syntactical proof conservativity prop 
prop 

restriction typed lambda calculus recursive types calculus allows abstractions positive type schemes real restriction 
type oe construct type oe oe oe lambda terms type 
proof corollary barendregt complete part stating fi nf fij nf trivial true contractions create new redexes 

known impossible prove calculus constructions 
polymorphic church numerals 
inconsistent systems gamma statement course provable proof normal form 

pure type system fij conversion defined theta theta theta satisfies church rosser property fij reduction cr fij pure type systems satisfy cr fij 
relation fi domain general founded set typed terms pure type system 
domain term appears type abstraction 
causes problem trying prove confluence fij reduction pure type systems normalizing 
contents xi 
difference income important difference old style research dutch universities top tasks old style research duty follow courses 
demand universities organise courses compensation financial offer 
try keep duties terms courses attend low possible 

experience having deep insight having deep insight 
attained various means second serious study 
xii contents chapter thesis concerned systems logic systems types relations 
systems types understood systems typed lambda calculus fact thesis takes study relation typed lambda calculus logic 
new subject lot research done centered called formulas types embedding logical system typed lambda calculus 
embedding main topic thesis 
describe formulas types embedding howard introduced terminology formulas types howard 
manuscript goes back lot ideas embedding go back especially curry see curry feys note close connection minimal proposition logic combinatory logic 
article howard mainly concerned giving formal explanation intuitionistic connectives 
way attempt formalize brouwer heyting kolmogorov bhk interpretation intuitionistic connectives original kolmogorov heyting book troelstra van dalen 
interpretation connective explained terms means proof sentence built connective 
howard gives formal interpretation proofs connectives terms typed lambda calculus giving interpretation elimination rule logic 
oe rule corresponds abstraction elimination rule application 
ideas howard extended martin lof intuitionistic theory types martin lof martin lof girard extended higher orders girard girard girard 
united heading proof theory 
approach taken research project automath de bruijn de bruijn independently defined kind formulas types embedding logic typed lambda calculus different nature ch 
important different purpose 
difference nature lies fact typed lambda calculus meant represent particular system logic close possible serve framework mathematical reasoning general 
purpose clarify formalize underlying principles mathematicians agree 
sense attempt put stage part mathematics comes logic part mathematician informally aware give definitions 
practical shoot program possibility doing mathematics computer implementing formal system typed lambda calculus 
point difference approaches sharp discussion suggest 
possible approaches system 
interesting part various embeddings formulas interpreted types proofs interpreted terms obviously comes consequence formulas types understand type set weak sense 
proofs class citizens type system 
hand provides world new options possibility formalize meta reasoning reasoning proofs system possibility terms depend proofs function extracts proof existential sentence witnessing object sentence 
hand requires understood notion proof claim terms typed lambda calculus represent proofs statement implicitly contains definition notion proof 
workable approximation notion proof notion derivation specific formal system logic 
formulas types embedding described howard goes order predicate logic natural deduction style extension simply typed lambda calculus 
yields isomorphism level proofs derivations identify derivations differ specific trivial way 
systems described de bruijn provide possibility embed large variety formal logics expect isomorphism level derivations proof terms correspond derivation logic 
systems interpretation proofs terms provide equivalence relation proofs signifying derivations understood equal 
mentioned practical application formulas types embedding possibility doing mathematics computer 
main starting points de bruijn setting automath project 
automath computer mainly proof checker user types proof form term formula supposed proving form type computer checks proof proves formula term type 
research groups enlarged job computer developing interactive theorem provers 
pioneering lcf gordon important lead interactive meta language ml 
language suited implementing typed lambda calculus interactive theorem proving allows user program tactics 
important developments field calculus constructions coquand coquand huet coquand huet extension coq dowek implemented language closely related ml 
want mention edinburgh ecc extended calculus constructions luo implementation ml lego luo pollack cornell system nuprl constable implementation martin lof type theory 
lcf grew system hol gordon classical higher order logic formulas types embedding implements church simple theory types church 
important practical application formulas types embedding particular described howard possibility extract programs proofs 
conforms bhk interpretation connectives proofs constructive mathematics example proof sentence contains construction element holds types interpretation howard proof term contains algorithm form term 
extended higher order logic girard emphasized consequence approach cut elimination logic corresponds evaluation program 
calculus typing terms extracted proofs introduced systems fn 
girard seen rudimentary programming languages 
martin lof contributions idea extracting programs proofs going higher orders adding inductive type forming operator martin lof 
programs proofs notion extended refined lot years notably projet group paris calculus constructions coq coquand huet coquand huet mohring paulin nuprl project cornell constable de logique group paris krivine parigot parigot research group goteborg nordstrom 
crucial feature programs proofs approach proofs preserved formal system algorithmic form 
just wants mathematics computer important sufficient know formula provable 
note case advantage preserve proofs example wants set library mathematics reproducible book form 
thesis mainly concerned formulas types embedding emphasis howard approach 
example ch 
discuss technical details programs proofs notion discuss technical problems arise trying set library mathematics 
reader find detailed description logics subject formulas types interpretation 
logics chosen way easily define collection typed lambda calculi embedding isomorphism derivations logic modulo easy equivalence relation 
discuss approaches formulas types studying examples 
study prove strong normalization confluence reduction relation typed lambda calculi important properties systems 
typed lambda calculi looked thesis instances called pure type systems 
general framework describing typed lambda calculi discussed detail 
meta theory typed lambda calculi proved collection pure type systems 
important issue formulas types embedding completeness level provability isomorphism level derivations really undesirable typed lambda calculus prove sentences logic 
issue discussed detail calculus constructions 
hand embedding complete hand dramatic completeness result sentences specific form 
give short overview chapters 

chapter describes logics generic way order predicate logic higher order predicate logic relates standard presentations logics 
logics minimal sense oe 
propositional variants described 
discuss conservativity relations systems 
interesting result chapter probably proof conservativity higher order propositional logic second order propositional logic classical intuitionistic 
proof intuitionistic case describing semantics terms complete heyting algebras 
far know new result 

chapter discusses formulas types embedding 
distinguish approaches la howard la de bruijn 
give detailed description embedding minimal order predicate logic typed lambda calculus la howard show completeness level derivations 
means embedding constitutes isomorphism derivations logic terms typed lambda calculus 
discuss formulas types embedding la de bruijn automath systems lf harper 

chapter treats notion pure type system 
prove list meta theoretic properties give examples instances pure type systems 
properties prove ones known geuvers nederhof extended pure type systems fij reduction 

chapter give proof confluence fij reduction normalizing pure type systems 
confluence fi reduction quite easy confluence fij reduction remarkably complicated 
confluence fact states consistency type system calculus sense shows different values distinguished system 
importance property lies fact main tools proving decidability equality decidability typing 
formulas types embedding decide term certain type decide proof proves certain formula 

chapter discuss calculus constructions cc fine structure form called cube typed lambda calculi 
study formulas types embedding subsystems higher order predicate logic subsystems cc 
look conservativity respect provability type systems cube 
new result conservativity 
comes corollary fact higher order propositional logic conservative second order propositional logic result proved chapter 
chapter give proof strong normalization fij reduction cc 
strong normalization main tool proving decidability equality decidability typing 
main tool showing consistency type system logic sense types inhabited closed term 
bit precise consistency cc quite easy wants show consistency context cc strong normalization comes 

chapter briefly discuss issues left list open problems may interest study 
reported thesis appeared notably chapters extension geuvers nederhof case includes reduction 
geuvers nederhof considered fi reduction 
chapter appeared slightly different form mistakes geuvers chapters contain reported geuvers geuvers 
ch 
chapter natural deduction systems logic 
chapter want discuss logical systems context curry howard isomorphism 
original howard howard formulas types isomorphism interpretations standard connectives intuitionistic logic 
mainly interested second higher order systems cases connectives coded terms oe shall restrict attention mainly oe 
curry howard isomorphism gives interpretation derivations lambda terms typed lambda calculus derivations natural deduction style 
pointed oe rules correspond abstraction oe elimination rules correspond application 
consequently representation logical systems natural deduction style 
doesn settle question precise formulation system 
interested provability choice formalization logic determined questions provability want tackle 
case interested formal proofs derivations depends heavily formal presentation chosen distinct derivations proposition 
reason choosing gentzen sequent calculus describe formulas types embedding system distinctions derivations due inessential difference bookkeeping 
choice formal system logic determined types interpretations proofs typed lambda calculus want 
natural deduction systems logic ch 

logics issue want stress choice called discharge convention 
issue drawn attention book troelstra van dalen crude discharge convention cdc book comes formulas interpretation 
briefly state problem example minimal implicational propositional logic prop shall describe formats called propa natural deduction style 
example shows choice formalisation logic determined curry howard isomorphism 
fact isomorphism clearly visualizes differences formalizations 

definition 
systems propa formulas elements set form syntax form var form oe form var countable set variables 
derivation rules propa 
rules formulas gamma finite set formulas 
ax gamma gamma oe gamma gamma oe oe gamma gamma oe gamma derivation rules 
formulas 
oe 
oe oe oe formula oe rule said discharged cancelled 
refer single occurrence arbitrary zero derivation rules form deduction trees starting single formula basic form deduction tree 
say gamma derivable derivation tree root open formulas tree gamma 
formula open derivation tree occurs leaf non discharged form 
practice name rule course mentioned explicitly 
sec 
logics system general canonical node derivation tree specific cancelled formula corresponds 
look example derivation 

example 
oe oe oe discharging ambiguously belong second oe rule 
proofs readable ambiguity solved writing number top discharged formula writing number line discharging took place 
case derivation tree fact corresponds different derivation trees 
solve ambiguity called crude discharge convention cdc says oe rule definition open occurrences discharged 
adopt cdc derivation tree canonical discharged oe rule 
view curry howard isomorphism preferable choose discharge convention attaches number discharged rule formula discharged 
reasons soundness completeness curry howard embedding 
example represents proofs oe oe discharged corresponds second oe discharged corresponds oe 
formal logical system cdc term obtained interpretation proof 
troelstra van dalen cdc dropped discussing types isomorphism 
system propa sequent notation familiar typed lambda calculi inconvenient describing curry howard isomorphism 
remarkable kind formalization describing isomorphism 
problem lies partly fact judgements gamma really sequents sense gentzen case gamma ordered sequence set 
adopt example formalism propa see problem 
example 
oe oe oe natural deduction systems logic ch 
application oe rule sort splits assumption copies reading 
impossible recover possible proofs oe oe typed lambda calculus format derivation say version obtained letting succedent correspond right copy second version letting succedent correspond left copy type forced solution motivation logic want avoid 
note replacing oe rule rules oe gamma gamma oe oe gamma gamma oe solve problem unpleasant hand doesn give general solution 
conclude presenting natural deduction way similar propa looking 
original howard howard defects propa appear format natural deduction system uses real sequents form gamma formula gamma finite sequence formulas 
rules order propositional logic call version follows 

definition 
formulas system propa derivation rules 
rules formulas gamma finite sequence formulas gamma delta concatenation gamma delta 
ax gamma gamma oe gamma gamma oe oe gamma delta oe gamma delta weak gamma gamma perm gamma delta gamma delta contr gamma delta gamma delta clear derivation system corresponds lambda term construction terminology howard simply typed lambda calculus 
weakening rule amounts extension context new declaration permutation rule change contexts simply typed lambda calculus kind multisets formulas contraction rule amounts substituting lambda term free variable 
derivations distinct lambda terms corresponding type due structural rules weakening permutation contraction 
view curry howard embedding sec 
logics splitting set derivations equivalence classes 
derivations equivalent mapped image curry howard embedding 
fact embedding takes care computationally interesting part derivation extracts construction derivation sense satisfying formal treatment bhk interpretation proofs constructions 
case just want recover construction proof find unique certain trivial changes proof corresponds construction 
purpose convenient example illustrate 

example 
look derivations oe oe 
oe oe oe oe oe oe oe oe oe oe oe oe oe logical derivations obvious third derivation considered equivalent distinct second derivation 
curry howard embedding apparent correspond corresponds situation derivation complicated lambda term corresponds depends occurrences sequence contracted application contraction rule 
disregarding completeness soundness embedding contraction rule explicit annotating sequent formulas contracted restricting contraction formula occurrences 
discussion may clear strong preference format system annotations fix formula occurrences discharged specific application rule 
natural deduction systems logic ch 

definition 
natural number system nth order predicate logic notation predn defined giving nth order language describing deduction rules nth order system follows 

domains prop specific set basic domains 
brackets associate right prop prop prop denoted prop prop prop domain written domains basic domain domain prop 

order domain ord defined ord ord prop ord pg ord prop pg note ord iff contain prop 
functional domains example order expect higher order part logics 
orders confirms formulas types interpretation studied chapters 
orders defined way th order logic quantify domains order 
fixed positive natural number terms nth order language defined follows 
term element specific domain relation denoted ffl 
ffl countably variables domain ord ffl ffl variable domain ord xffld ffl ffl ffl ffl mn ffl ffl ffl prop variable domain ord xffld ffl prop 
ffl ffl prop ffl prop oe ffl prop 
system pred special case 
addition rules rules sec 
logics ffl countably variables domain ord ffl ffl variable domain ord xffld ffl states arbitrary predicate symbols 
second allows definition predicates abstraction ffl ffl prop 

terms known notion definitional equality fi conversion 
equality denoted 
terms ffl prop called formulas form denotes set formulas 

specific positive natural number describe deduction rules nth order predicate logic natural deduction style allow build derivations 
formulas nth order language 
oe 
oe oe oe xffld xffld ffl conv formula occurrences brackets gamma oe rule discharged superscript oe rule taken countable set indices index uniquely corresponds specific application oe rule allow index 
indexes allows fix formula occurrences discharged specific application oe rule 
rule usual restriction variable may occur free non discharged assumption derivation 
gamma set formulas predn formula predn say derivable gamma predn notation gamma predn derivation root non discharged formulas gamma 
system predicate logic finite order notation pred union predn 
follow usual convention writing number case order system pred write pred 
natural deduction systems logic ch 


choice connectives oe may minimal 
known fact second higher order systems intuitionistic connectives defined terms oe follows 
formulas 
oe oe ff oe ff oe ff oe oe ff oe ff ff oe ffl xffld oe ff oe ff similarly define equality judgement fi equality definitional equality language purely syntactical called leibniz equality ffl prop oe says objects equal satisfy properties 
difficult show symmetric 
difficult check standard logical rules hold 
shall freely symbols 


predn comprehension property satisfied 
prop sequence free variables possibly occurring ffl ffl delta delta delta prop px delta delta delta take ffl ffl 
definition peculiarities want bring spotlight 
allowed countably variables domains order includes example countably variables domain prop 
order logic may natural allow variables domains order slight extension give doesn harm 
conservative extension 
forced possibility forming new predicates abstraction order predicate logic 
unusual second higher order cases feature called comprehension added formulas types embedding complete level proofs 
constants variables 
may strange confirms feature allow variables domains order order logic binary relation represented variable domain prop 
don constants related fact sec 
logics presentation logic introduced similarity type fixes language mainly declaring constants 
described general presentation logic captures similarity type 
paragraph show easy conservativity results justify choice extended systems 

extensionality definitional equality terms fi equality 
objection fij equality properties remain hold 
fact lot sense especially predicates tend view abstraction necessary mechanism comprehension 
ffl prop ffl px describe collection elements domain holds 
related issue extensionality terms domain prop understood predicates subsets element set ffl prop holds 
take set theoretic understanding serious identify predicates extensionally equal oe oe oe obviously formula general provable 
standard models predicates interpreted real sets formula satisfied important extension 
difficulty extensionality form general expressible predn express extensionality domain ord formula predn uses quantification prop 
means shall express extensionality schematic rule 
obvious choice 
oe oe arbitrary terms domain delta delta delta prop stands formula specific marked occurrence reasons discussed presently choice scheme different definition 

definition 
extensionality scheme ext ext oe oe arbitrary terms domain delta delta delta prop stands formula specific marked occurrence 
signifies natural deduction systems logic ch 
usual restriction variables may occur free non discharged assumption derivations oe oe extension system rule ext denoted adding prefix predn extensional nth order predicate logic 
notation 
ffl delta delta delta prop quantification allowed system compress premises rule ext oe oe convenience denoted oe oe usually omitted clear context 

lemma 
extensionality scheme prop admissible predicate propositional logics oe oe provable 
proof 
easy induction structure 
theta course scheme functions arbitrary terms domain delta delta delta definition 
shall working scheme introduce new definition 
note fij 

useful variants systems systems predn definition scheme ext equivalent scheme gave just definition 
reason general scheme lies fact reasons semantics want look slight extensions systems versions scheme equivalent 
extensions come consideration quite naturally notices term language predn subsystem simply typed lambda calculus restricting terms certain order 
interpretation term language tempted take model full simply typed lambda calculus 
interpretation logic describing binary relation sets formulas formulas 
syntactical analogue allow term language full simply typed lambda calculus put order restriction quantifications 
show problem extension establishing conservativity result systems 
sec 
logics 
definition 
logical systems say order full simply typed lambda calculus notation obtained description term language definition 
ffl countably variables domain ffl countably constants domain ffl ffl variable domain xffld ffl ffl ffl ffl mn ffl ffl ffl prop variable domain ord xffld ffl prop 
ffl ffl prop ffl prop oe ffl prop 
cases ord special fixed constant ffl prop prop similarly special fixed constant prop prop prop 
feel useful thing don 
easy restriction define nth order propositional logic nth order predicate logic 

definition 
natural number nth order propositional logic notation propn defined removing definition nth order predicate logic set basic domains 
lemma 
rule ext implies conv fij propositional logic propn fij oe proof 
show gamma 
oe 
cr fij term language fact implies oe 
gamma 
say xffld mx gamma 

ffl 
delta delta delta prop oe xffld mx vice versa conv rule xffld mx oe ext 
theta order predicate propositional logics minimal connective negation 
second order logics case intuitionistic negation defined letting ff oe 
implies specialize prop pred classical variant 
define classical order logic add negation system 
ideological completeness foe classical logic sufficient treatment full classical proposition predicate logic 
intuitionistic case extension just quite minimal 
natural deduction systems logic ch 

definition 
order propositional predicate logic negation notation prop pred defined adding prop pred 

fixed constant ffl prop 
derivation rule classical variants logics defined ways adding rule axiom 
choose rule order case axiom higher order case 

definition 
classical systems proposition predicate logic defined adding 

prop pred adding rule 
systems propn predn adding axiom ff oe ff notation 
classical variants systems denoted subscript example prop pred propn predn extensional variants defined adding scheme ext denoted adding prefix 
just order case faithful translation systems classical higher order logic systems intuitionistic higher order logic 
extends godel translation 
definition give coquand herbelin described generally form called translation typed lambda calculus framework 
intuitionistic logics defined definitions minimal systems prop pred classical variant defined definition 

definition 
godel translation gamma terms defined inductively variable constant pq xffld xffld oe oe xffld xffld mapping extends straightforwardly sets formulas 
sec 
easy conservativity results example higher order systems 
ff ff logically equivalent 
order systems 

oe oe logically equivalent 
convenient logically equivalent 
lemma 
properties gamma terms variable domain 

ffl ffl 

fi fi proof 
easy induction structure terms 
third showing statement step fi reduction applying property 
theta 
theorem 
formula gamma set formulas gamma lc gamma proof 
right left easy fact logically equivalent classical logic 
left right induction derivation lemma 
uses general facts oe oe xffld xffld note rule sound formulas form order ff ff oe ff provable higher order 
theta 
easy conservativity results paragraph contains number syntactic proofs conservativity results 
results relatively easy surprising 
lies precise formulation notions 
show predn see definition conservative predn 
means extension logical language order full simply typed lambda calculus affect provability 
furthermore show order predicate logic function domains conservative system function constants natural deduction systems logic ch 
standard 
system possible define predicates abstraction conservative standard system basic predicates 
proof result outlined 
section give precise proof terms typed lambda calculi formulas types embedding 
order achieve goals give definitions writing pred gammaf pred function domains pred gammaf pred function domains definable predicates 
pred gammaf standard minimal order predicate logic function constants predicate constants 
turn conservativity predn predn 
define mapping predn predn preserves provability 

definition 
mapping gamma predn defined substituting term predn free variables constants domain order fixed closed term dd domain delta delta delta dm prop dd defined dd xm image term predn contain free variables constants domains order furthermore ffl ffl want take fi normal forms long fij normal forms 
recall long form obtained fi normal form doing expansions expands xffld qx fv create fi redex 
defined normalization fi fact expands xffld qx expand xffld qx anymore 
long fij normal form denoted long fij nf 

lemma 
predn ffl ord fi nf long fij nf predn 
proof 
induction structure fi nf respectively structure long fij nf 
treat proof statement fi nf predn 
contains free variables constants domains order fi nf xm pq delta delta delta constant free variable domains dm order domain order ih terms predn fi nf theta 
proposition 

gamma predn fi nf gamma predn fi nf gamma predn long fij nf gamma predn long fij nf sec 
easy conservativity results proof 
induction derivation 
cases easy case rule ext 
say oe oe step proof 
ih long fij nf gamma long fij nf oe long fij nf long fij nf gamma long fij nf oe long fij nf long fij nf gamma long fij nf take fresh variable domain replace 
look term possible substitution term performed 
long fij nf fij fij long fij nf third part ih read long fij nf gamma long fij nf done prove long fij nf gamma long fij nf occurrences long fij nf form zq delta delta delta zq delta delta delta ffl prop 
extensionality level prop lemma oe oe occurrence long fij nf premises satisfied ih 
occurrences long fij nf replaced consecutive applications rule 
obtain long fij nf holds 
theta 
corollary 
predn conservative predn 


proposition corollary remain hold replace pred prop 

corollary 
prop conservative propn prop conservative propn 
natural deduction systems logic ch 
turn issue functional domains define subsystem order predicate logic pred simplest domains functions 
usually domains called order conflicts terminology shall refrain term 

definition 
language system pred gammaf defined follows 

domains prop 
delta delta delta prop basic domains ones predicate domains ones contain prop 

functional domains 
delta delta delta assume functional domain built basic domains 
note 
order domain ord defined done pred 
functional domains order confirms intention pred gammaf quantification functional domains 

countably function constants function domain pred gammaf 
terms language pred gammaf described follows 
ffl countably variables domain ffl function constant domain delta delta delta ffl ffl ffl ffl variable domain ord xffld ffl ffl ffl ffl tq ffl ffl ffl prop variable domain ord xffld ffl prop 
ffl ffl prop ffl prop oe ffl prop 
derivation rules pred gammaf pred quantification restricted domains order 
convenient pred constants functional domains pred gammaf formally subsystem pred 

sec 
easy conservativity results 
proposition 
pred conservative pred gammaf gamma set formulas formula pred gammaf gamma pred gamma pred gammaf proof 
proof cut elimination normalization 
notion discussed section sketch proof 
show gamma set formulas formula pred gammaf gamma pred derivable derivation theta derivation theta obtained theta cut elimination normalization order expressions derivation gamma pred gammaf section discuss typed lambda calculi correspond pred respectively pred gammaf formulas types embedding 
proof proposition seen detailed proof proposition 
theta story usual order system define predicates abstraction want show extension conservative 

definition 
system pred gammaf pred gammaf minus clause ffl variable domain ord xffld ffl term formation rules clause ffl ffl tq ffl replaced ffl delta delta delta prop ffl tq delta delta delta ffl prop 
pred gammaf abstractions 
usual system minimal order predicate logic set terms object language inductively defined variables constants function application set formulas inductively defined basic formulas applying connectives 
basic formulas form delta delta delta terms object language allowing 
conservativity pred gammaf pred gammaf proved normalizing abstractions just normalized relevant abstractions proof conservativity pred pred gammaf 
proposition 
gamma set formula formula pred gammaf gamma pred gammaf nf gamma pred gammaf nf proof 
easy induction derivation 
theta 
corollary 
gamma set formulas formula pred gammaf gamma pred gammaf gamma pred gammaf proof 
fact formula pred gammaf nf 
theta natural deduction systems logic ch 

conservativity logics having justified systems predn relation standard presentations predicate logic want say conservativity relations systems 
gives better understanding logics time results useful discuss conservativity relations systems typed lambda calculus chapter 
paragraph may skipped merely interested typed lambda calculi 
conservativity relations logics collected diagram 
prop 
delta delta delta delta delta prop 
pred 
delta delta delta delta delta pred 
delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta prop delta delta delta delta delta prop pred delta delta delta delta delta pred delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta prop delta delta delta delta delta prop pred delta delta delta delta delta pred delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta prop delta delta delta delta delta delta prop pred delta delta delta delta delta delta pred gamma gamma gamma gamma gamma gamma 
gamma gamma gamma gamma gamma gamma 
prop pred dotted arrow depicts non conservative inclusion ordinary arrow depicts conservative inclusion 
non predicate logic propositional logic follow fact predicate logic right conservative propositional variant left transitivity conservativity fact conservative ae conservative diagram theorem depicted arrows proof 
section small part diagram proved formally 
things prove tower sec 
conservativity logics vertical arrows propositional part 
prove extensional versions systems 
implies conservativity propn prop similarly classical variants 
vertical tower arrows predicate part diagram proved 
believe non conservativity proved looking structure arithmetic logics 
obtains nth order heyting arithmetic left side nth order peano arithmetic right side 
godel second incompleteness theorem says systems prove consistency 
non conservativity established showing th order arithmetic prove consistency nth order arithmetic 
similar method apply systems pred pred respectively pred pred classical variants straightforward pred may minimal due classical logic connectives defined terms oe 
look robinson system arithmetic godel second incompleteness theorem applies 
non conservativity pred pred derived non conservativity pred pred applying version godel double negation translation 
faithful mapping pred respectively pred pred respectively pred 
see section conservativity prop prop pred pred discussed look typed lambda calculus versions systems 
shall describe mappings larger system smaller take account proofs 
conservativity prop prop pred pred immediately follows prop conservative prop pred conservative pred 
non conservativity prop prop easy ff fi ff ff provable prop prop 
derivation prop ff oe fi ff oe fi oe ff ff ff ff oe fi ff ff fi ff oe fi ff ff easily seen ff fi ff ff provable prop noticing closed term type ff fi ff ff simply typed lambda calculus saying exists cut free proof ff fi ff ff prop 
example ff fi ff ff applies showing non conservativity pred pred 
natural deduction systems logic ch 
obvious conservativity classical version logic intuitionistic version holds dotted arrows left right diagram 
note predicate logic conservative propositional version 
easily seen defining mapping gamma formulas predicate logic propositional logic preserves derivability identity propositional logic 
defined follows 

definition 
system predicate logic propositional variant 
mapping gamma defined predicate domains ones form delta delta delta prop just removing basic domains example prop prop prop prop 
gamma form form defined follows 
oe oe delta delta delta prop delta delta delta prop delta delta delta prop map similar definition shows conservativity dependent typed lambda calculus non typed lambda calculi 
easily shown map satisfies requirements 
proof conservativity extensional prop extensional propn semantical methods 
give notion model terms complete heyting algebras sound complete propn 
shall describe kripke semantics propn non extensional 
hoped prove conservativity prop propn semantics 
sound complete model notion propn haven able derive conservativity kripke model propn immediately kripke model prop 
proof conservativity prop propn follows directly proof conservativity prop propn 
just add axiom ffff ff 
describe truth table semantics propn basic semantics classical propositional logics 
shows conservativity prop propn decidability propn 
contrasted intuitionistic versions propositional logic systems sec 
conservativity logics propn extensional undecidable 
consequence prop shown lob conservativity extensional propn prop 

truth table semantics classical propositional logics method deciding validity judgement gamma classical logic truth tables immediately extends second order case letting value ff vary interpretation 
higher orders bit careful 
straightforward thing example value variables domain prop prop vary set functions 
gives model complete extensional compared syntax sense ffl prop prop ff oe gff gff oe ff oe prop prop satisfied 
equality definable leibniz equality 
shall show truth table model complete extensional version logic 
extensionality derivable logics 
example seen fact prop prop oe variable appropriate domain ff ff oe ff oe ff ff ff oe ff prop fact ff ff oe ff oe ff ff ff oe ff satisfy assumption extensionality 
applying godel translation definition obtain ff ff oe ff oe ff ff ff oe ff prop case ff ff oe ff oe ff fi ff ff oe ff clearly case 

definition 
domain define set vd possible values terms domain follows 
prop vd vd vd set functions vd vd interpretation terms values modulo valuation free variables straightforward definitions 
natural deduction systems logic ch 

definition 
valuation maps variables values appropriate set extends immediately interpretation terms follows 
xffld vd pq oe xffld vd denotes valuation expected value closed term depend particular choice values stable fij equality 

definition 
gamma set formulas formula propositional logics define gamma valuations gamma gamma gamma 
say true 
subscripts usually omitted 

proposition soundness 
gamma set formulas formula propn gamma propn gamma proof 
easy induction derivation 
theta 
lemma 
domain values vd definable propn vd closed term domain propn valuation 
proof 
induction structure proof uses fact due extensionality define function cases logic 
example value maps identity function constant functions defined syntax prop ff ff ff ff oe ff 
ff 
oe sec 
conservativity logics general function vd delta delta delta described format fv delta delta delta delta delta delta delta delta delta just go possible input values 
ih know define elements vd translate format term replacing defining element domain delta delta delta prop defined finite generalised conjunction lets vary sequences defining elements theta example defined 
due previous lemma internalize valuation syntax 
done substituting free variable term defines 
introduce notation 
notation 
valuation substitution replaces free variable closed term defines denoted sigma 
example ff prop sigma substitutes ff 
lemma states vd summed closed terms write vd fv closed terms totally arbitrary 
fact proved inside logic 

lemma 
propn ord vd fv delta delta delta proof 
induction structure proving oe oe delta delta delta oe gamma oe proof uses extensionality form provable extensionality axioms 
reason lemma hold domains logic simply domains order formula delta delta delta language propn theta natural deduction systems logic ch 
lemma says things ff ff provable prop shortly digress proves fact illustration proof 
extensionality prop implies axiom 
ff fi ff fi oe ff fi ff ff ff ff ff ff ff ff extensionality ff ff 
version lemma domains order propn strong purposes 

lemma 
propn vd fv delta delta delta proof 
domains order lemma follows immediately previous lemma 
domains order case analysis previous lemma 
really proves oe delta delta delta oe gamma oe sufficient 
give details case domain prop prop prop prove prop ff ff ff oe ff ff ff oe ff ff oe ff ff easily done deriving contradiction ff ff ff ff ff ff ff ff 

theta 
proposition 
propn valuation sigma sigma proof 
simultaneously induction structure normal form 
xffld distinguish subcases ord ord treat subcases 
suppose xffld ord vd say vd fv justified lemma 
ih sigma 
lemma know delta delta delta sec 
conservativity logics case analysis find sigma sigma substitute free sigma 
may conclude sigma xffld suppose ffl ord vd 
say vd fv ih sigma 
lemma know delta delta delta strong case suffices may assume occurrences appear form xq delta delta delta xq delta delta delta ffl prop occurs real function 
shape expand 
case analysis find sigma free sigma conclude sigma xffld theta 
corollary completeness 
propn formula proof 
means proposition sigma valuation necessary case distinctions lemma lemma 
theta 
corollary 
propn decidable 
proof 
immediate previous corollary soundness proposition fact validity formula checked finite part truth table model 
theta 
proposition 
prop conservative propn prop 
conservative propn proof 
fact truth table model model propn theta 
corollary 
propn conservative prop proof 
immediate fact prop prop system 
lemma 
theta natural deduction systems logic ch 

algebraic semantics intuitionistic propositional logics section describe semantics systems intuitionistic propositional logic terms heyting algebras 
known done full order propositional logic giving rise completeness result 
second higher order propositional logic need refine notion heyting algebra allow interpretations universal quantifier 
easily seen complete heyting algebras strong satisfy purpose complete heyting algebras arbitrary meets joins example ffl prop prop interpreted ag 
easy show completeness complete heyting algebras propn lindenbaum algebra defined propn complete heyting algebra 
way suggested theorem troelstra van dalen stating heyting algebra embedded complete heyting algebra oe existing preserved ordering preserved 
embedding constructed proof faithful respect ordering image original heyting algebra 
implies completeness complete heyting algebras respect propn conservativity prop propn 
fact argument gives completeness result systems propn propn language full simply typed lambda calculus 
done things slightly easier effect results 
see 
point know possible conclude conservativity prop propn conservativity prop propn 
conservativity propn prop prop prop system 
obvious extensionality required syntax model notion extensional example carrier set algebra method showing conservativity semantical means quite essential 
conservativity proofs chapter mappings larger system smaller system identity smaller system 
mappings constitute mapping derivations derivations identity derivations smaller system 
case intuitionistic propositional logics method essentially impossible formulas prop cut free derivations go higher hierarchy propositional logics 

definition 
heyting algebra just ha tuple oe lattice element oe binary operation oe sec 
conservativity logics remember lattice binary operations satisfy requirements 
way defining notion lattice saying poset property pair elements upperbound denoted greatest lowerbound denoted 
defining show equivalence definitions lattice 

definition 
complete heyting algebra cha tuple oe complete lattice oe heyting algebra 
mappings ae upperbound greatest lower bound binary operations defined fa bg fa bg 
important feature heyting algebras forced presence binary operation oe satisfy infinitary distributive law fa xg exists 
inclusion holds lattice inclusion show fa xg due properties oe 
important facts 

fact 

complete lattice satisfies infinitary distributive law turned cha defining oe fd cg 
heyting algebra distributive ha satisfies statement show fd cg 
left right easy right left notice fd cg ab fd db cg equal db cg just second easily verified 
ready give algebraic semantics systems propn 
logical system full simply typed lambda calculus see definition 
oe cha 
shall freely natural deduction systems logic ch 
notions definition 
interpretation terms propn higher order function spaces 
gammae mapping associates right function space domain dd dd dd second describes function space 
shall freely speak interpretation propn oe course interpretation includes mapping higher order terms appropriate higher order function space 
definition 
algebraic model propn pair theta theta cha valuation constants theta constant domain dde 

definition 
interpretation propn algebraic model oe gamma defined modulo valuation ae free variables maps variables domain dde 
ae valuation 
gamma ae defined inductively follows 
ae constant ff ae ae ff ff variable ae ae ae xffld ae dde ae oe ae ae oe ae xffld ae ae easily seen gamma ae satisfies usual substitution property interpretations stable fij equality ae ae ae fij ae ae 
definition 
gamma finite set formulas propn formula propn theta algebraic model theta valid gamma notation gamma theta valuations ae ae gammag ae gamma empty say theta valid theta 
sec 
conservativity logics note ae gammag exists gamma finite 
just write gamma ae ae gammag 
definition bit different troelstra van dalen gamma theta defined gamma ae ae notion implies way 
gamma yield consequence relation 
disadvantage notion restrict finite gamma 
easily overcome putting gamma theta finite gamma gamma gamma theta 
definition 
gamma finite set formulas propn formula propn say consequence gamma notation gamma gamma theta algebraic models theta 

proposition soundness 
gamma finite set formulas propn formula propn gamma propn gamma proof 
theta model 
induction derivation gamma show valuations ae gamma ae ae cases difficult 
treat cases rule oe 
oe say derived oe 
ae valuation 
ih gamma ae ae gamma ae oe ae second implies gamma ae ae ae gamma ae ae conclude gamma ae ae 
say gamma gamma finite set non discharged formulas derivation 
ih ae gamma ae ae ae dde gamma ae ae fv gamma 
immediately implies gamma ae ffl ae theta show completeness construct lindenbaum algebra propn ha cha 
construction troelstra van dalen turn cha desired properties 

definition 
define lindenbaum algebra propn define equivalence relation sent propn propn oe oe natural deduction systems logic ch 
denote equivalence class 
defined ha oe sent propn oe oe note oe right logical connectives oe basic defined oe oe ff oe ff oe ff oe oe ff oe ff obviously ha iff propn 
trivially turned model valuation constants mapping associates constant equivalence class 
shall distinguish lindenbaum algebra model 

lemma 
gamma finite set sentences propn sentence propn gamma propn gamma proof 
immediate construction theta 
theorem troelstra van dalen 
ha theta embedded cha theta oe existing preserved reflected 
proof 
theta oe ha 
complete ideal theta just ideal subset ae satisfies properties 


downward closed 
closed existing ae exists 
define theta lattice ideals ordered inclusion 
theta complete lattice satisfies infinitary distributive law theta cha defining oe fk ae jg verify note 
sec 
conservativity logics ffl theta defined ffl theta defined ae set ae ideal ideal containing ffl fi qg holds 
embedding theta theta defined fx ag embedding preserves oe existing preserving ae exists theta 
show show fy xg ae inclusion left right note ae fy ae 
implies ae done ideal 
inclusion right left ae 
done 
embedding reflects ordering ae theta 
corollary completeness 
gamma finite set sentences propn sentence propn gamma gamma propn proof 
theorem embed lindenbaum algebra propn cha cl cha cl turned algebraic model propn valuation constants just embedding equivalence classes constants cl algebraic model cl complete respect logic gamma finite set sentences sentence propn gamma cln gamma gamma propn theta 
corollary conservativity 
prop conservative propn prop 
conservative propn 
natural deduction systems logic ch 
proof 
corollary suffices show conservativity prop propn gamma finite set sentences sentence propn gamma prop gamma gamma propn soundness completeness algebraic models propn conservativity prop 
propn immediate derivation prop 
derivation theta 
corollary 
propn conservative prop 
proof 
fact propn subsystem propn fact prop prop system 
theta 
kripke semantics intuitionistic propositional logics previous section saw algebraic semantics systems propn time semantics systems propn 
paragraph want give kripke semantics systems propn extensionality 
fact starting point research conservativity prop propn 
purpose considered algebraic semantics 
previous paragraph shows works extensional case 
know kripke semantics solving conservativity problem want describe gives complete model notion propn 
convenience describe models semantics propn know problem slight extension 
exposition give owes extensions kripke models higher orders suggested 
basis kripke model partial order practice usually founded tree elements called nodes 
relation fl set nodes set formulas propositional logic certain conditions satisfied 
roughly knowledge grows increasing order satisfied nodes 
adds order quantification logic partial order extended function assigns node set world node monotone 
knowledge world grows 
case sorted logics really different case number monotone functions sorts logic 
second order propositional logic situation different order predicate logic domain quantification set closed formulas sent sent 
higher order propositional logic just treated sorted way domain logic function wd fact just obtained sec 
conservativity logics replacing prop sent see sets quantified model just sets syntactic objects domain 
bit peculiar sets quantifies model subset set syntactic objects corresponding domain shouldn prop sent 
formulas known specific node 
turns right choice conforms kripke semantics higher order predicate logic importantly way get notion model sound complete respect logics 
obvious kind model get construction syntactical 
doesn partial order structure kripke model essential way 
way bit syntactical letting world sent point arbitrary model language propn arbitrary model simply typed lambda calculus 
shall follow possibility hand doesn give lot hand quite obvious definitions 

definition 
domain prop associate set terms just ffl 
example prop sent 
definition trivial want specific easy confuse object language logic language model 

definition 
kripke model propn triple fl partial order fl binary relation elements sentences satisfies fl fi fl fl fl fl oe fl fl fl fl range nodes set formulas domain quantification allowed propn note definition meta language model 


condition relation fl respect connective usually finds fl fl range quantification model grow increasing ordering equivalent second condition definition 
natural deduction systems logic ch 
definitions kripke model van dalen relation fl nodes atomic formulas 
systems considering impredicative method 
interpret formulas close substituting closed terms free variables 
denote substitution assume variables substitutes closed term right domain 

definition 
formula propn gamma set formulas propn 
fl kripke model propn say fl valid gamma notation gamma fl fl 
substitutions fl gamma fl fl gamma obviously means fl gamma 
say valid gamma notation gamma gamma fl fl 
kripke models fl propn 
proposition soundness 
gamma set formulas propn formula propn gamma propn gamma proof 
fl kripke model propn induction derivation gamma propn prove gamma propn gamma fl fl 
rule conv gamma immediately done 
oe say oe 
ih gamma fl substitutions fl gamma fl 
substitution fl gamma fl fl gamma ih fl done 
oe say derived oe ih gamma fl oe gamma fl 
substitution fl gamma ih fl fl fl 
find fl done 
say xffld ih gamma fl 
substitutions fl gamma fl 
occur free gamma know substitutions fl gamma fl 
gamma fl xffld 
sec 
conservativity logics say derived xffld 
ih gamma fl xffld 
substitution fl gamma fl fl fl theta 
proposition completeness 
gamma set sentences propn sentence propn gamma gamma propn proof 
proof contraposition suppose gamma propn construct kripke model fl propn gamma fl 
construction counter model direct generalisation standard construction counter model showing completeness kripke models respect order intuitionistic predicate logic example van dalen 
giving model introduce extra notion delta set sentences write delta closure delta derivability propn model defined follows 
ffl set finite sequences natural numbers ffl concatenation operation ffl define set sentences propn sigma induction length follows 
sigma 
gamma sigma defined consider enumeration sentences sigma consistent define sigma sigma relation fl defined fl sigma sigma verify facts 
fl kripke model propn 
model 
fl gamma 
fl gamma fl 
second follows immediately construction model 
slightly check cases definition 
cases trivial give detailed proofs third fourth case 
natural deduction systems logic ch 
ffl fl oe fl fl fl 
sigma sigma oe sigma fl 
finite sequence 
assumption know sigma sigma 
distinguish cases sigma consistent 
sigma inconsistent trivially sigma sigma oe fl oe 
sigma consistent sigma sigma sigma assumption 
sigma sigma oe fl oe 
ffl fl xffld fl sigma xffld sigma 
assumption know fl constants sigma constants sigma xffld 
theta technically reason get conservativity model notion model propn general model prop technical terms reason model notion syntactical especially clause universal quantifier ordering doesn play role 
chapter formulas types embedding 
called formulas types embedding provides formalization brouwer heyting kolmogorov interpretation proofs constructions 
detailed description howard terminology formulas 
shown order logic types associated formulas lambda terms proofs way correspondence types formulas terms proofs cut elimination logic corresponds reduction term calculus 
view point correct associate tait formulas types notion tait discovery close correspondence cut elimination reduction lambda terms provided half motivation howard 
de bruijn associated types notion automath project founded de bruijn rigorously interpret mathematical structures propositions types objects proofs lambda terms 
wider perspective certainly justifiable speak curry howard de bruijn embedding earliest developments automath took place independent howard 
having said want point essential differences approaches 
example automath systems logic coded system general reduction relation term calculus corresponds cut elimination 
automath systems intended serve logical framework user formal systems desires 
application abstraction conversion serve tools handling basic mathematical manipulations function application function definition substitution 
appropriate systems automath family abstraction application features system interpret logical connectives directly reduc formulas types ch 
tion corresponds cut elimination 
section shall give examples automath systems clarify remarks 
go great detail brouwer heyting kolmogorov bhk interpretation proofs 
troelstra van dalen gives thorough explanation idea 
just discuss connectives oe bhk interpretation 

proof oe method constructing proof proof 

proof method constructing proof proof obvious retrospect lambda calculus provides necessary mechanisms turning informal interpretations formal system 
minimal propositional logic noticed curry feys 
order predicate logic howard give formalisation bhk interpretation typed lambda calculus 
due church known language predicate logic typed lambda calculus 
years led definition various typed lambda calculi incorporate logical language proofs form lambda terms system 
thesis shall see variety systems 
claim give overview possible approaches formulas types embedding 
fact attempt 
example main contributions field martin lof type theory treated 
reasons phd thesis place give detailed technical overview broad field type theory important reason approach martin lof really fit framework logics set previous chapter 
main problems due understanding existential quantifier terms strong sigma type logic martin lof strictly order order remain consistent 
feel forced lack sigma types higher order logics big gap feel strong sigma type right way formalise intuitionistic existential quantifier 
precise mean say sigma types valid mathematical concept sigma understood 
course lot say systems treat shall appropriate places text 

formulas types notion la howard paragraph look interpretation formulas types proofs terms flavour howard interpretation full sec 
formulas types notion la howard order predicate logic 
flavour treatment quite bit different howard pointed previous chapter 
mainly concerned logics oe shall treat full order predicate logic restrict system pred 
order logic just oe quite minimal sufficient general idea sufficiently clear 
formalisation logical language typed lambda calculus manner 
idea presentation probably due de bruijn automath project absolutely sure 

definition 

set functional types pred type described syntax 
type var ty type type var ty countable set type variables 
set predicate types pred type consists expressions oe oe delta delta delta oe prop oe functional types 

object terms language pred form subset set pseudoterms generated syntax 
var ob tt type oe var ob type var ob countable set object variables 
object term certain type assumption specific types functional predicative free variables occur term 
object term type type denoted different object variables types 
part called object context 
rules deriv formulas types ch 
ing typing judgements 
var gamma gamma abs gamma gamma functional app gamma gamma gamma qt oe gamma prop gamma prop gamma oe prop gamma prop gamma prop functional type 
set proof terms subset set generated syntax 
var pr pp pt type var pr set proof variables 
rules generating statements form different proof variables prop sec 
formulas types notion la howard 
part called proof context opposed object context 
axiom gamma delta delta oe gamma delta gamma delta oe oe el gamma delta oe gamma delta gamma delta mn gamma delta gamma delta fv delta functional type el gamma delta gamma gamma delta mt conv gamma delta gamma prop gamma delta fi intention system clear natural deduction proofs pred interpreted typed lambda terms pred 
language pred typed lambda calculus part formalised pred typing judgement obtained derivations 
note functional types correspond domains order ones quantification allowed predicative types correspond domains order 
describing formal correspondence derivations pred proof terms pred give examples 

examples 

deduction px oe px oe px px obtain judgement prop prop oe px notice declaration essential construction proof 
pred explicitly takes care called free logic domains allowed empty 
formulas types ch 

deduction px oe px oe px px qx obtain judgement prop prop oe px needed construction proof declare list meta theoretical properties pred shall 
proof shall encounter complicated typed lambda calculi properties hold prefer prove systems 

fact 
gamma delta derivable pred 
properties 

permutation gamma permutation gamma delta permutation delta gamma delta derivable 

substitution gamma contains gamma gamma delta derivable 

thinning gamma gamma gamma object context delta delta delta proof context gamma delta derivable 

closure subject reduction iif fi gamma delta derivable 

stripping generation gamma delta delta proof variable gamma delta gamma delta type gamma delta gamma delta oe proposition gamma delta mn gamma delta oe gamma delta proof gamma delta mt gamma delta gamma object sec 
formulas types notion la howard deduction pred going associate object context gamma proof term gamma pred 
want faithful deduction pred correspondence deductions pred proof terms pred 
achieve gamma assign types free term variables deduction bound stage 
means variables bound explained 
examples clear declare variable variable occur free premises derivation 
giving translation define operations contexts 

definition 
gamma gamma object context union gamma gamma gamma gamma gamma followed gamma restriction declared contexts say gamma gamma left leave left 
delta delta proof context disjoint union delta delta delta delta delta followed delta restriction declared contexts say delta delta second renamed fresh proof variable example note gamma gamma correct object context delta delta corrects proof contexts gamma delta delta correct proof context gamma 

definition 
term language pred define context gamma gamma pred ffl pred follows 
gamma xd ffl gamma gamma mn gamma gamma gamma oe gamma gamma gamma ffl gamma gamma formulas types ch 
define induction deduction pred object context gamma proof context delta term gamma delta pred deduction 
fact establishes mapping deductions terms 
shall denote deductions capital greek characters sigma theta 
denote explicitly deduction shall format sigma write mean part deduction sigma 
reasons hygiene shall assume deduction bound variables chosen distinct different free ones 

definition 
inductively define mapping gamma deductions pred proof terms pred 
proof term define object context proof context proof term typable 
double horizontal lines right mean judgement defined terms judgement 
gamma 
gamma sigma oe gamma 
gamma delta sigma gamma gamma delta sigma oe sigma oe theta gamma 
gamma delta sigma oe gamma delta theta gamma gamma delta delta sigma theta sigma ffl gamma 
gamma delta sigma gamma delta sigma sigma ffl gamma 
gamma delta sigma gamma gamma gamma delta sigma sigma gamma 
gamma delta sigma gamma prop gamma gamma delta sigma sec 
formulas types notion la howard cases definition rule oe oe need extra clarification oe top deduction signifies specific set occurrences formula leaves deduction tree 
set may empty take union gamma gamma happens oe rule 
add fresh declaration delta 

remove declarations correspond occurrence discharged 

substitute sigma 

declaration delta 
oe fact theta exactly theta induction 
possibly free variables theta renamed 
happens 
consider proof context delta delta especially renaming declared variables delta caused operation 

rename free proof variables theta accordingly obtaining say theta 

apply sigma theta 
practice confusion just write theta 
course intended meaning judgement double lines derivable judgement lines proved theorem 
clear point correspondence occurrences non discharged premise deduction declarations delta 
notation 
sigma deduction pred gamma delta sigma judgement obtain sigma definition write gamma sigma gamma delta sigma delta 
state trivial facts definition 

fact 

sigma deduction pred correspondence occurrences non discharged formulas sigma declarations variables formula delta sigma 
case rule variable occur free proof context delta 
formulas types ch 

theorem 
sigma pred gamma sigma delta sigma sigma derivable pred proof 
induction deduction sigma 
proof follows easily meta theoretical facts pred stated 
theta proof context delta sigma represents precisely non discharged assumptions sigma 
object context gamma sigma declares precisely object variables occur sigma bound 
due conversion rule context gamma sigma minimal respect judgement gamma sigma delta sigma sigma sense may smaller object context gamma gamma delta sigma sigma derivable 
proof statement declared variables gamma sigma occur free delta sigma sigma breaks conversion rule 
counterexample minimality gamma sigma derivation oe oe oe gamma sigma prop delta sigma sigma prop oe conversion rule reason embedding really oneto 
term sigma obtain ignores applications conv deduction sigma easily seen applications conv moved tree sigma freely 
correspondence equivalence classes deductions terms deductions equivalent obtains tree removing applications conv 
shall define equivalence relation precisely 

completeness embedding define mapping back proof terms pred deductions pred 
sec 
formulas types notion la howard 
definition 
proof terms gamma delta define induction structure deduction sigma follows 
gamma delta gamma 
delta gamma delta gamma 
sigma oe gamma delta gamma 
sigma gamma delta mn gamma 
sigma oe sigma gamma delta nt gamma 
sigma ffl case final rule application conv 
vacuous obtained 
definition justified stripping says proposition equal proposition form require 

proposition 
gamma delta pred 
sigma non discharged assumptions sigma declared delta 
sigma gamma sigma gamma delta sigma delta 
proof 
induction structure theta formulas types ch 
precise extent bijective correspondence deductions pred proof terms pred define equivalence relation deductions pred 

definition 
define stripping operation gammai deduction trees labelled finite trees follows 
gamma 
sigma oe gamma 
sigmai sigma oe theta gamma 
sigmai thetai mp sigma ffl gamma 
sigmai ffl sigma ffl gamma 
sigmai sigma gamma 
sigmai remember writing sigma mean part deduction sigma 
mapping hi removes formulas tree sigma leaves 
doing leaves just information reconstruct rule applied form occurrences formula discharged variable abstracted term substituted 

example 
oe oe oe oe gamma 
oe oe mp mp sec 
formulas types notion la howard 
definition 
equivalence relation ch deductions pred defined sigma ch theta sigmai thetai ch equivalence classes denoted gamma ch 
example 
gamma 
fi 
deductions equivalent ch oe oe oe oe oe different oe oe pred trivial variation proof term want 
situation occurs definition fully fixed due choices renamings proof variables 
want consider pairs delta delta proof term equivalence relation pairs delta delta equivalent substitution proof variables proof variables oe oe delta delta oe case call delta delta equivalent modulo renaming proof variables 

proposition 
theta theta deductions pred 

theta ch theta delta theta theta delta theta theta equivalent modulo renaming proof variables 

sigma theta ch theta 
proof 
induction structure thetai theta 
second induction structure theta 
theta obvious consequence proposition proposition 

corollary 
mappings sigma gamma gamma constitute bijection ch equivalence classes deductions pred pairs delta modulo renaming proof variables 
formulas types ch 

comparison embeddings barendregt different embedding logic natural deduction style typed lambda calculus 
system completeness level derivations embedding isomorphism level derivations 
chapter paragraph pointed problem formalization logic sequent formulation natural deduction howard real natural deduction formulation prawitz 
consequence proof terms mapped derivation tree original logic 
embedding described barendregt studied extensively anf fujita case higher order logic 
completeness result stated right theorem saying composition mapping type system logic mapping logic type system constitutes identity level proof terms 
proof terms formula oe oe counter example 
clear remarks feel strong preference embedding described clear correspondence derivation trees proof terms 
note barendregt embedding done steps linearize derivation trees embed typed lambda terms calculus 
calculus pred different pred distinguish proof contexts object contexts 
embedding done steps interpretation derivation trees typed lambda terms pred 
chapter shown system pred calculus pred barendregt 
think way split embedding natural gives better insight 
reduction derivations extensions higher orders known cut elimination pred corresponds normalization fi reduction 
precise defining reduction relation deductions pred 
sec 
formulas types notion la howard 
definition 
reduction relation gamma 
deductions pred defined follows 
sigma oe oe theta gamma 
theta sigma sigma ffl ffl gamma 
sigma definition sigma clear easy check sigma deduction 
reduction relation gamma 
eliminates generally known cut redundancy proof introducing connective immediately eliminating 

proposition 
correspondence reduction steps gamma 
deduction theta pred fi reductions corresponding proof term theta pred 
gamma 
strongly normalizing deductions pred fi reduction strongly normalizing proof terms pred proof 
immediate correspondence equivalence classes deductions proof terms modulo renaming proof variables stated corollary theta howard formulas types embedding discussed full intuitionistic order predicate logic 
pred amounts addition connectives corresponding operators elimination rules 
operators come reduction rules correspond rules cut elimination connectives full order predicate logic 
howard discusses extension heyting arithmetic amounts addition induction operator 
give details extensions 
exposition case pred covers basic difficulties encounters extension straightforward formulas types ch 

interested giving details extension second higher order systems extra connectives induction defined 

definition 
systems pred pred 
defined extending pred way 

pred allow quantification types add possibility quantification predicate types 
distinction functional predicate types meaningful allow formation object terms abstraction predicate types 

pred extend types type var ty prop type type allow quantification abstraction types 
need distinguish functional predicate types may type functional type form delta delta delta type variable predicate type form delta delta delta prop 
connectives defined terms oe pred pred 
definitions 
means closed proof terms correspond elimination rules connectives 
correspondence stronger sense closed terms satisfy part reduction rules correspond cut elimination 
difficult verify just treat cases example 
terms corresponding elimination satisfy part cut elimination rules full predicate logic rules combine elimination rule connective rule connective 
satisfied 
see girard type rules 

examples 
pred 

connective defined ff prop oe ff oe oe ff oe ff combinators elimination 
reasons readability omitted type information 
oe gx oe hx ff prop oe oe ff oe oe ff oe ff ff gh sec 
formulas types notion la howard combinators satisfy reductions 
gh fi gt gh fi ht reductions correspond obvious way rewriting part deduction done immediately elimination 

connective defined ff prop oe ff oe ff combinators elimination 
omitted type information 
oe ffg ff prop oe oe ff oe ff combinators satisfy reduction 
ith fi corresponds rewriting part deduction done immediately elimination 
similar way interpret heyting arithmetic pred starting fixed type objects declared variables object context fact treated constants construct proof term type ind prop oe py oe sy oe px stated course impossible tells objects type just ones built handle relativization 
prop defined prop oe py oe sy oe nt true built nt true numeral 
proof terms zero prop succ nx oe sx nx prop formulas types ch 
define induction follows 
ind prop oe py ny oe sy oe nx oe px ind states induction numerals 
find closed term ind ind satisfies required equality rules 
compare example scheme induction howard 
zero fi sn fi nq sn 
formulas types notion la de bruijn want say de bruijn automath project relation notion formulas types 
presenting things way suggests totally different approaches true 
example automath project different systems introduced quite close systems seen previous section 
reason separating basic underlying ideas want single 
reason section restrict attention mainly system aut probably covers best basic ideas automath want talk 
want introduce aut original format format close typed lambda calculus pred encountered previous section 
reason twofold take lot space explain aut original format 
done quite succesfully van 
second want format close describing typed lambda calculi 
means ignore features inevitable making system feasible man machine interaction inessential discussion formulas types 
definition mechanism automath 
definition aut owes lot discussions van benthem jutting 
fact derivative description aut pure type system 

definition 
aut system deriving judgements form gamma gamma context sequence declarations statements form variable term 
terms taken set pseudoterms var type tt pix sec 
formulas types notion la de bruijn usual notions substitution fi reduction etcetera 
terms singled set derivation rules determine judgements gamma derivable 
derivation rules 
base ctxt gamma type gamma gamma ax gamma gamma type proj gamma gamma gamma pi gamma type type gamma pix type pi gamma gamma type gamma pix pi gamma type gamma type gamma pix type gamma gamma pix type gamma pix app gamma pix gamma gamma mn conv gamma gamma type gamma fi convention writing pix fv 
people familiar automath may notice changed presentation system system 
example original system contain pi expressions places put pi 
feel systems pis natural certainly readily understood people familiar actual developments typed lambda calculi 
real difference versions system formalisation pi recognise read pis 
true extensions formulas types ch 
aut aut qe identification pi really extends system 
familiar kind calculus may wonder system give example 
general purpose system provide logical framework user formal system choice 
situation language formal system declared context fixed 
part context kind signature variables declared act constants 

example 
order predicate logic 
idea interpret domains logic formulas types domain understood type elements formula understood type proofs 
consider context 
gamma type type type type abs pix type pix type pix type pix type cl pix type example abbreviating 
gamma type yq pix type universal quantifier interpreted pi pix define existential quantifier terms universal classically theory natural numbers developed adding gamma type comm pix drawbacks kind interpretation order predicate logic domains logic formulas treated manner types kind things system distinguish formulas domains 
recognised de bruijn especially emphasized drawback relation called sec 
formulas types notion la de bruijn proof irrelevance 
apparent look situations proof terms subexpressions object terms example type pos type sqrt pix pos represents real numbers pos predicate decides number non negative sqrt constructs square root number number non negative 
general may want distinguish different proofs formula obviously want depend fact non negative particular proof represent real number 
clearly way state proof general form formulas terms type equal 
extensions aut considered known name aut splits type type prop 
prop rules type easily variants system handles type prop differently specify different axioms prop context 
drawbacks direct interpretation formulas types 
note system essentially order quantify collection subsets domain 
able write pip type type allowed 
consequence formalise induction general form 
pip type pix px sx piy note fact pix type type system mean system impredicative pix type type type 
reason represent order intuitionistic existential quantifier 
knowing defined terms option declare context elimination rules pix type type type allowed 
overcome drawbacks just mentioned option developed automath community require change system different 
idea formulas types introduce fixed type constant prop representing names formulas kind lifting operator prop type maps name formula type proofs 
difference interpretation may small sight major improvement 
system really framework previous interpretation features type system directly logic pi formulas types ch 
oe quantifiers represented context 
interpretation gives flexibility allowing interpret example second order higher order logic similar way exotic formal systems typed lambda calculus 
give example formalisation done new point view 

example 
order predicate logic 
adapt example gave new interpretation 
gamma prop type prop type prop prop prop prop oe prop prop prop pix type prop prop abs pix prop pix prop pix prop pix prop pix type pip prop piz xp pix type pip prop xp piz cl pix prop oe etcetera stated rules oe 
gamma pix prop oe oe oe intuitionistic existential quantifier defined letting pix type prop prop adding declarations intuitionistic elimination rule 
add induction natural numbers declaring ind pip prop px oe sx py flexibility really enormous advantage system 
noticed researchers edinburgh defined system lf logical framework harper ideas automath 
inspired lf choice representation aut quite close lf 
shall say lf 
want treat example higher order predicate logic pred 
aut 
may noticed previous example domains logic types may undesirable wants allow operations domains allowed types aut 
example cartesian products domains 
case push language logic level lower introducing type names domains dom operator dom type maps name domain type elements 
higher order predicate logic example system approach appropriate 
sec 
formulas types notion la de bruijn 
example 
interpret system pred 
aut introducing context 
gamma dom type dom type dom dom dom prop dom pid dom dd dd type ap pid dom dd de abs pid dom dd de fi pid dom pif dd de pix dd fx pid dom pif dd de pix dd fx gx comp pid dom pif pix dd type oe pid dom dd oe pix oe tx ty oe pix tx ty oe pid dom pip dd piz dd dp pid dom pip dd dp piz dd pushing domains level lower higher order language coded substitution conversion mechanisms system take care substitution ff conversion defined higher order language 
note possibility alternative domains types case example gamma prop type prop type oe prop prop prop pid type prop prop oe pix prop oe tx ty oe pix prop ty oe pid type pip prop piz dp pid type pip prop dp piz etcetera 
exactly context example 


context example represents higher order predicate logic aut 
quantifier declared context applies types applies prop prop prop etcetera 
obviously coding things easier read write 
important advantage approach example formulas types ch 
adequacy interpretation easier prove 
issue received lot attention automath project course relevant extent interpretation logic aut adequate 
sentences provable interpretation aut provable original logic 
interpretation higher order predicate logic example quantifier range type including types form prop 
clearly available logic really show extra feature doesn provide ingenious proof unwanted theorem example 
problem adequacy encodings formal systems taken seriously defined system lf 
see example gardner 
introduce system sketch adequacy proofs system 
general theorem saying specific way encoding formal systems yield adequate interpretation general proof procedure usually job proving adequacy 

definition 
lf harper system deriving judgements form gamma gamma context terms taken set pseudoterms var type kind tt pix definition aut definition 
derivation rules 
ranges ftype 
base ctxt gamma gamma gamma ax gamma gamma type kind proj gamma gamma gamma pi gamma gamma type gamma pix gamma gamma pix gamma pix app gamma pix gamma gamma mn conv gamma gamma gamma fij convention writing pix fv 
sec 
formulas types notion la de bruijn definition ignored feature lf called signatures 
special contexts constants declared 
definition signature part context precise part language formal system fixed gamma 
looking example higher order predicate logic see interpretation example possible lf 
second requires pi abstraction type allowed lf 
apart conversion fact difference lf aut way defined definition 
reads judgements aut form gamma gamma kind systems rules rule pi extra aut 
way prove adequacy interpretation called long fij normal forms 
encountered notion previous chapter 
recall long fij normal form obtained fi normal form doing expansion term fi normal form expands mx fv pix mx fi normal form 
write long fij nf long fij normal form term usefulness definition depends normalization confluence fij reduction lf 
property relatively easy shown harper second surprisingly complicated proved 
define isomorphism fij equivalence classes terms specific type gamma terms corresponding domain higher order predicate logic 
course allowed extend gamma little bit variable declarations dom 
done defining isomorphism long fij normal forms form complete set fij equivalence classes 
example terms type dd correspond terms higher order predicate logic long fij normal forms defining inductive mapping gamma prop oe oe dd ffl abs dd ffl correspondence gamma terms type dom domains obvious 
similar way defines correspondence terms type lf deductions pred establishing way adequacy interpretation 
pointed lf seen subsystem aut modulo small changes 
number rules limited lf powerful interpreting wide variety formal systems 
see harper formulas types ch 
avron gardner examples 
minimal rule weakening power system 
partly due way system 
see example higher order predicate logic context gamma represents formal system established interested judgements form gamma type 
hand reason context gamma normal form 
principles show half rule superfluous need able form pix case pix kind 

definition 
lf split rule rule 
convenience attach label abstraction introduce rule gamma gamma pix type gamma pix gamma gamma pix kind gamma pix system lf rule call lf gamma write gamma judgements lf gamma terms lf distinguish fi reduction fi reduction obvious way gamma 
fi gamma 
fi similarly talk fi normal forms etcetera 
show fi normal form relevant judgement contains judgement contains derived rule 

proposition 

type type lf fi nf contains 
gamma gamma contain gamma gamma proof 
induction derivation gamma details geuvers 
theta 
corollary 
gamma type fi normal form gamma gamma type 
sec 
formulas types notion la de bruijn gamma lf context representing system logic type represents formula logic assume gamma fi normal form 
looking proof lf look terms contain rule totally ignored 
previous proposition says real need pix kind able declare variable 
usually simple form fv 
standard application aut lf certainly logical systems declaration prop type prop type declaration 
practice going forth prop name formula type type proofs inconvenient noticed de bruijn de bruijn 
reasons introduce system aut 
fact family systems obtained adding automath system fourth level 
terms system aut defined definition means add prop new constant language axiom prop type rules prop logic 
set rules allows de bruijn suggests different possibilities 
give extension aut aut system set rules prop minimal interesting 

definition 
define system aut aut extension aut adding aut definition constant prop rules stands type prop 
ax gamma gamma prop type ctxt gamma prop gamma gamma pi gamma prop gamma gamma pix prop gamma gamma pix prop gamma pix example higher order predicate logic done coding type class domains prop class propositions defining oe ffl prop ffl pix domain ffl prop elimination rules obviously satisfied 
see formulas types interpretation pred 
system aut howard sense coding formulas types ch 
rules correspond directly abstractions elimination rules applications 
correspondence formal restricting rules aut showing system obtained way equivalent pred 
discussed previous section 
restriction aut easily defined just remove rules meaning higher order predicate logic 

definition 
system aut hol automath higher order predicate logic defined removing aut rules pi pi 
rules 
stands type prop 
base ctxt gamma gamma gamma ax gamma gamma type ax gamma gamma prop type proj gamma gamma gamma pi gamma type gamma type gamma pix type pi gamma prop gamma gamma pix prop gamma gamma pix gamma pix app gamma pix gamma gamma mn conv gamma gamma prop gamma fi definition anticipated properties restricting conv rule propositions 
prove gamma contains redex gamma prop 
due fact removed rules pi pi system nice property called context separation 
notice ways adding variable context declaring variable prop type case type easily seen 
speak proof variables prop object variables type set variables 
system nice properties 

lemma 
system aut hol 

strengthening gamma gamma fv gamma gamma gamma sec 
formulas types notion la de bruijn 
permutation gamma gamma fv gamma gamma 
gamma type delta delta delta gamma prop type gamma form 

gamma type contains proof variables variables prop gamma 
proof 
proof induction derivations 
theta 
corollary 
aut hol split context gamma disjoint parts gamma gamma gamma containing set variables second third proof variables gamma gamma gamma gamma type gamma type type gamma gamma consequence lemma corollary find aut hol isomorphic system pred 
definition 
isomorphism aut hol pred 
consists rearrangement context suggested corollary replacing set variables names basic domains 
write ffl pix type prop oe piz prop 
reverse direction similar replacements rewritings 

proposition 
denote derivability aut hol denote derivability pred 
domain gamma gamma gamma gamma proposition gamma gamma gamma gamma gamma gamma formulas types ch 
chapter pure type systems 
framework pure type systems ptss provides general large class typed lambda calculi possible derive lot meta theoretic properties generic way 
give list examples systems form pts give detailed study meta theory 
notion pts appears explicitly geuvers nederhof name gts generalised type system describe called cube typed lambda calculi barendregt meta theory 
typed lambda calculi belong class generalised type systems type constructor pi definable equality rule just fi name pure type system suggested thierry coquand widely adopted 
situation typed lambda calculus contains core pts course mean core pts respect essential part gives starting point research 
notion similar pts occurs describes dutch calls generalised system terms types 
implicit berardi berardi describes various examples pure type systems insisting general definition 
inspired notion cube typed lambda calculi see barendregt important step notion pts 
coherent study meta theory geuvers nederhof strongly benefitted suggestions 
main meta theoretic results geuvers nederhof barendregt 
follows give slight extension notion pts equality able study church rosser property cr fij reduction calculus constructions fij conversion rule 
meta theory extended ptss 
pure type systems ch 
known inclusion complicates things quite bit cr fij set pseudoterms false 
describe weak form church rosser property fij turns provable set pseudoterms 
key lemma job cases cr study meta theory ptss fi conversion geuvers nederhof 
important case missing subject reduction sr saying gamma gamma proof done having established proof strengthening gamma gamma fv gamma gamma gamma geuvers nederhof proof rule certain subclass ptss 
general proof ptss van benthem jutting 
proofs cr essential way key lemma doesn suffice 
calculus constructions relatively simple system prove strengthening having rely cr 
situation turns occur generally describe subclass ptss strengthening sr proved having rely cr 
discussed chapter definition lemma 
turn calculus constructions belongs class systems satisfies sr situation complicated clear show sr holds general 
worrying proof church rosser property typed terms certainly require sr proof cr fij deadlock situation 
way suggested proving cr fij reduction lf 
trick add strengthening rule system 
suggested geuvers alternative things stand alternative method possible 
problems vanish addition rule strengthening complicate known meta theory allows prove sr extended pts notion 
system strengthening rule subsystem 
mean prove sr cr fij general system rule strengthening 
proof properties normalizing systems 
general problem remains open 
see study ptss fij conversion rule useful study extension system rule strengthening 
define notions pure type system original fi conversion denoted pts fi fij conversion denoted pts fij fij conversion strengthening rule denoted pts fij sec 
definitions 
definitions pure type systems formal systems deriving judgements form gamma set called pseudoterms set expressions derivation rules select ones typable 
gamma finite sequence called declarations statements form variable 
idea course term type relative typing free variables occur giving precise definition pure type systems define set pseudoterms base set 
dependency usually ignored 

definition 
set set pseudoterms defined var var tt var countable set expressions called variables 
pi bind variables usual notions free variable bound variable 
adopt calculus notation writing fv set free variables usual notions fi reduction generated gamma 
fi denotes substitution done usual care avoid capturing free variables mx gamma 
fv compatible application abstraction pi abstraction 
adopt untyped lambda calculus conventions denoting transitive reflexive closure gamma 
fi fi transitive symmetric closure fi fi similar gamma 
gamma 
fij gamma 
fi gamma 
typing terms done assumption specific types free variables occur term 

definition 

declaration statement form variable 
finite sequence declarations different declarations pure type systems ch 

gamma domain gamma dom gamma set fx dom gamma image gamma notation im gamma 
gamma variable gamma fresh just fresh clear gamma talking dom gamma 

gamma gamma gamma gamma obtained removing gamma declarations dom gamma 

definition 
pure type system fi conversion pts fi set set ae theta set ae theta theta pts denoted fi typed lambda calculus deduction rules 
sort var gamma gamma weak gamma gamma gamma pi gamma gamma gamma pix gamma gamma pix gamma pix app gamma pix gamma gamma mn conv fi gamma gamma gamma fi rules var weak assumed newly declared variable fresh declared gamma 
triple write equality conversion rule conv fi fi equality set pseudoterms elements called sorts elements usually written called axioms elements called rules 
pure type system fij conversion pts fij set set ae theta set ae theta theta denoted fij 
sec 
definitions difference pts fi pts fij fij conversion rule conv fij gamma gamma gamma fij fij equality side condition equality set pseudoterms pure type system fij conversion strengthening pts fij set set ae theta set ae theta theta denoted fij 
difference pts fij pts fij strengthening rule streng gamma gamma gamma gamma fv gamma notion pts subscript arbitrarily refer notions 
see distinction types terms sense types formed terms formed types 
derivation rules select typable terms pseudoterms typable context gamma gamma gamma derivable 
practical reasons definitions 

definition 
pts 

typable gamma gamma gamma derivable 
set typable terms denoted term just term pts clear context 

gamma context gamma context just gamma context ambiguity pseudoterms gamma derivable 
gamma context term typable gamma notation term gamma gamma gamma 
gamma context sort term term gamma notation term gamma gamma 
gamma context sort term element gamma notation elt gamma gamma term 
sort set terms defined term gamma context term gamma set elements defined elt gamma context elt gamma 
pure type systems ch 
practical purpose pts framework properties proved class ptss 
paragraph list prove important ones versions pure type systems pts fi pts fij pts fij order meta theory versions study collection pseudoterms bit detail prove weak form church rosser property fij reduction just handle cases cr fi reduction meta theory pts fi geuvers nederhof 
want give examples type systems fit pts framework say mappings ptss 
framework yields nice tool describing specific class mappings type systems call pts morphisms 
pts morphisms described subset general set mappings pure type systems 

definition 
ptss 
mapping function assigns derivable judgements sequent gamma gamma pseudoterms 
morphism mapping preserves axioms rules pts morphism immediately extends mapping pseudoterms pseudoterms mapping ptss induction structure terms 
mapping preserves substitution fi equality derivability 

lemma 
pts morphism gamma gamma certainly interesting mappings pure type systems don want give pts morphisms priority 
practical interest easy describe share lot desirable properties 
course pure type systems pts morphisms form category products coproducts terminal object system type type referred type type type type type sec 
definitions subclasses ptss special interest systems belonging subclasses share additional nice properties 
known examples pure type systems belong classes 

definition 
pts functional relation partial function relation partial function theta pts injective functional functions injective 
barendregt notion functional called singly sorted notion injective called singly occupied 
van benthem jutting definitions subclasses pure type systems interest 
purposes article find different sets rules generate set derivable judgements easier operational properties 
especially important proving completeness type checking algorithms 
shall say chapter 
want describe subclasses pure type systems defined van benthem jutting importance text 

definition 

pts full 
pts semi full importance notion full pts lies fact second premise rule replaced easier handle 
importance notion semi full clear study church rosser property fij pts fij section want mention subtle variant syntax practical allows prove nice meta property 
idea variables disjoint countable subsets subset sort subset denoted small alterations derivation rules definition 
pure type systems ch 

definition 
syntax pure type systems sorted variables set variables var countable subsets var var weak rule var gamma gamma var weak gamma gamma gamma var turn syntax sorted variables injective pts fi sets term term disjoint similarly elt elt 
importance fact lies possibility defining mapping typed terms pts fi induction structure terms having mention specific context term typed 
distinguish cases sorts specific subterms terms elements 

examples pure type systems morphisms 
cube typed lambda calculi treat called cube typed lambda calculi barendregt barendregt 
cube includes known systems simply typed polymorphically typed lambda calculus 
show representations systems fact requires technical difficult 

definition barendregt 
cube typed lambda calculi consists pts fi having sorts set axiom 
rules system follows 










note systems cube injective functional enjoy nice properties hold subclasses ptss 
convenient think set variables var split set var set var sec 
examples pure type systems morphisms suggested definition 
te type variables referred object variables second constructor variables 
systems known simply typed lambda calculus polymorphically typed lambda calculus due girard system reynolds 
system higher order version known girard system 
presentation systems pts quite different original 
just interested systems general convenient study original presentation 
pts framework convenient systems type dependency feature type 
may contain term 
situation occurs presence rule 
case syntax systems essentially convenient pts format 
system close lf due harper see definition fact lf pts fij variant system 
calculus constructions due coquand 
see coquand huet 
system defined name longo moggi 
usually systems cube picture follows 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma arrow denotes inclusion system 
cube give fine structure calculus constructions largest system cube 
possible understand 
built basic constants allowing kinds dependencies dependency understood possibility specific terms form term specific kind 
example call terms type types terms type kinds means type define term type oe oe oe means kind define term type pure type systems ch 
ff ff piff ff ff 
extensive explanation dependencies barendregt 
pointed pts format practical wants study specific system 
convenient wants compare different systems 
applications studying example strong normalization calculus constructions 
features come handy pts morphisms defined definition 
obviously inclusions inside cube pts morphisms 
proof state correspondence systems original presentation pts format 
define systems different format 

definition 
system 
defined follows 
set kinds syntax constructors 

countably variables ff 
mn 
ff 
oe piff oe 
oe oe 
usual notions bound free variables substitution fi reduction set constructors 
object context sequence declarations oe oe distinct 
gamma object context 
sec 
examples pure type systems morphisms derivation rules 
axiom gamma oe oe gamma gamma oe gamma oe oe el gamma oe gamma oe gamma mn pi gamma oe gamma ff piff oe ff fv gamma pi el gamma piff oe gamma mt oe ff conv gamma oe gamma oe fi define order kind ord just defined order domains predicate logic definition follows 
ord 
ord 
pg define fn restricting set kinds fn formation constructors order system called systems just simply typed lambda calculus referred st just defined systems fn subsystems 
contain system define ptss ae ae delta delta delta ae shall hand quite clear systems look restrict formation kinds certain depth hand definition involved doesn give real insight 
state equivalence 
introduce notation 
gamma context gamma subcontext contains declarations constructor variables gamma subcontext contains declarations object variables lemma 
similar hold systems defined 
pure type systems ch 

lemma 

gamma gamma gamma gamma gamma gamma proof 
immediately induction derivations 
theta kind introduce context type 
denote context gamma free constructor variable gamma contains declaration variable kind similarly gamma contains declaration constructor variable free way gamma denote term constructor variable replaced variable kind gamma 
proposition 

proposition 
gamma gamma 
gamma 
way 
gamma gamma 

gamma gamma proof 
induction derivations structure terms lemma theta shall go details calculus constructions systems cube chapter 

logics pure type systems interesting example ptss berardi defined logical systems ptss 
chapter encountered typed lambda calculi pred definition pred pred 
definition correspond directly logical systems pred pred pred defined 
correspondence verified full detail case pred pred see theorem proposition difficult extend cases 
saw correspondence strong sense correspondence proofs proof terms 
see proposition 
step define ptss correspond systems pred pred pred 
systems looking precisely systems defined berardi 
sec 
examples pure type systems morphisms 
definition berardi 
cube logical typed lambda calculi referred logic cube consists pts fi fprop set type type prop type set type rules systems table 
prop prop prop prop prop prop type prop prop 
type type prop prop prop 
type type prop prop type prop pred set set set type prop prop set prop pred set set set type prop prop set prop type prop pred 
set set set type type set type type prop prop set prop pred 
set set set type type set type type prop prop set prop type prop pure type systems ch 
systems picture follows 
prop 
pred 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma prop pred prop 
pred 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma prop pred arrow denotes inclusion system 
intuition required probably best keep pred extensions mind 
sort prop understood class propositions 
sorts set type form universe domains domains form delta delta delta ff ff variable type set functional types domains form delta delta delta prop type type predicate types 
sort type allows variables type set purpose 
sufficient understand rules pred 
correspond logical rules sense prop prop implication oe set prop quantification functional types set type prop quantification predicate types type systems second higher order proposition logic defined just removing sorts set type note systems prop prop prop 
get way just 
systems pred 
prop 
just added thing cube cube 
formulas types correspondence logical systems encountered definition prop 
corresponds prop pred 
corresponds pred logics order restriction abstraction quantification higher order language available possibility higher order quantification 
sec 
examples pure type systems morphisms immediately obvious see systems built stages 
domains terms proofs 
case object expression contains proof expression domain expression depends term 
case systems pred pred pred 
correspond pred pred respectively pred 
similar way correspond 
going state correspondence explicitly prove 
similar 
state basic property correspondence 
compare proposition lemma 
proposition 
pred 

gamma gamma gamma gamma ffl gamma gamma gamma sound permutation gamma ffl gamma contains declarations form set ffl gamma contains declarations form gamma set type ffl gamma contains declarations form gamma gamma prop ffl set type gamma ffl gamma set type gamma gamma proof 
induction derivation theta similar propositions hold pred pred 
ptss able verify stated correspondences 
noticed barendregt possible describe pts corresponds subsystem pred gammaf pred definition 

definition 
pred gammaf pts prop set fun type type prop type set type set set fun set fun fun set type prop prop set prop idea set contains basic domains pred gammaf fun contains functional domains pred gammaf 
quantification possible types set 
system pred gammaf really subsystem pred morphism maps set fun set 
proposition prove detail formulas types embedding pred gammaf pred gammaf isomorphism 
pure type systems ch 
seen logical systems chapter correspondence pts fi show correspondence steps define typed calculus close possible original logic formalize formulas types embedding la howard 
done detail system pred chapter defined pred formulas types embedding pred pred 
show intermediate typed calculus pts fi want logic correspond 
done detail intermediate systems correspond prop respectively 
prop 
systems pred pred 
pred gammaf corresponding pts fi detailed proof similar proof cases 
depict correspondences picture follows denotes correspondence denotes correspondence verified great detail 
pred pred pred pred pred pred pred 
pred 
pred prop st 
prop prop prop prop 

prop pred gammaf pred gammaf logical systems chapter define corresponding pts fi done times definition hack intuitive meaning don see useful operation 

morphisms pure type systems reason introducing cube logical pure type systems definition formalise embedding logics typed lambda calculi cube especially calculus constructions 
original motive berardi define systems formalise practical 
system higher order predicate logic better understand 
higher order predicate logic 
come speak 
relation pred 
detail 
point just want treat interpretation logics systems barendregt cube defining mapping cube logical systems barendregt cube 
mapping referred formulas types embedding isomorphism feel appropriate terminology transition real logical systems typed lambda calculi 
sec 
examples pure type systems morphisms 
definition 
collapsing mapping logic cube barendregt cube pts morphism prop set type type easy verify corner cube pts morphism system logic cube system barendregt cube 
question arises mapping complete especially respect inhabitation propositions 
nice things doing logic example domains logic propositions treated exactly way 
opens wide range new possibilities possibility define domains represent inductive data types 
hand obvious sound 
shall see broadest sense operation sound collapsing mapping complete narrow sense things bad 
chapter section want give different pure type system corresponds pred 
intuitive pred 
seen direct formulas types formalisation pred fact pred 
reason distinguish functional types predicate types done pred 
see definition 
hand alternative version obtained defining system aut hol pts format 
aut hol defined applying ideas automath systems aut system aut 
pointed correspondence aut hol pred 
proposition 

definition 
typed lambda calculus hopl pts fprop type type prop type type type type type prop prop type prop meaning components system clear intended correspondence pred 
prop sort formulas type sort domains sort type just able introduce variables type type 
variables basic domains logic 
heavy overloading symbols pix stands logical implication oe propositions type prop universal quantification type proposition type prop stands domain types type type 
immediately obvious pure type systems ch 
hopl seen built stages 
domains objects proofs 
case stated proposition hopl equivalent proposition 

proposition 
hopl 
gamma gamma gamma gamma ffl gamma gamma gamma sound permutation gamma ffl gamma contains declarations form type ffl gamma contains declarations form gamma type ffl gamma contains declarations form gamma gamma prop ffl type gamma ffl gamma type gamma gamma proposition states things domains terms type type just built domain variables pi object occur subterms domains hopl 
states terms object language formed object variables abstraction application terms type prop pi don contain proof variables pix prop denotes oe logical implication 
application notion pts morphism fully justify systems hopl pred 
terms prove pred 
hopl sense system 

proposition 
pts morphism pred 
hopl derivability preserving map hopl pred 
ffi id ffi id proof 
take pred 
hopl prop prop set type type type type type hopl pred 
define mapping term hopl ftype term pred 
variable prop prop type set sec 
examples pure type systems morphisms induction structure terms 
pts morphism preserves derivations 
preserves substitution fi equality extends contexts straightforwardly defining sort type appear context hopl 
extend derivable judgements hopl defining gamma gamma type type gamma type gamma set delta delta delta ff ff variable gamma type gamma type delta delta delta prop gamma type type gamma set type pts mapping sense definition 
easy induction proves preserves derivations 
gamma gamma gamma gamma theta feel correspondence pred 
hopl intuitive pred 
pred 
disadvantage presenting higher order predicate logic hopl find second order predicate logic subsystem easy restriction rules rules distinction basic domains domain prop 
hopl doesn allow straightforward syntactical description types embedding higher order predicate logic cc 
pred 
saw definition look system pred 

inconsistent pure type systems inconsistency really property pts depends interpretation different parts 
say pts inconsistent closed types specific sort intended sort formulas inhabited closed term satisfying 
coquand herbelin restriction called logical ptss systems specific sorts prop type prop type axiom type prop rule system functional sorts type prop 
usually obvious sort understood sort formulas just speak inconsistent ptss 
inconsistent ptss seen 
logical pts 
ones 
pure type systems ch 

definition 
system gamma defined follows 
prop type type prop type type type type type type type prop prop type prop system defined extending gamma rule type prop 
girard systems discussed logics 
obtained extending pred 
polymorphic domains system gamma quantification domains polymorphic domains forms system 
typed lambda calculi extensions hopl gamma hopl rule type type polymorphic domains gamma type prop quantification domains 
example gamma domains pia type numerals pia type prop prop 
write formulas pia type pip prop pix px 
difficult see extension higher order predicate logic just quantification domains consistent conservative pred 

theorem 
gamma inconsistent systems term piff prop ff proof 
proof girard 
explanation discussion applications proof type systems coquand 
fact known girard paradox especially application system 
proof gamma coquand 
argument set theoretic models polymorphic lambda calculus 
theta meta theory pure type systems easy see inconsistent system terms normal form 
normalization property hold gamma 
strange system shown fact separate contexts system just hopl systems 


proposition 
gamma gamma gamma gamma ffl gamma gamma gamma sound permutation gamma sec 
meta theory pure type systems ffl gamma contains declarations form type ffl gamma contains declarations form gamma type ffl gamma contains declarations form gamma gamma prop ffl type gamma ffl gamma type gamma gamma chapter shall see little bit careful possible extend higher order logic polymorphic domains consistent system 

meta theory pure type systems section want treat meta theory different notions pure type system 
pts fi results listed treated geuvers nederhof 
lot proofs immediately extended cases pts fij pts fij 
essential problem church rosser property fij reduction hold set pseudoterms 
problematic cr tool proving subject reduction church rosser typable terms system pts fij quite suspect think possibility types fij means expansion reduction path passes set non typable terms 
conversion rule says types inhabitants course want 
having realised problematic absence church rosser property fij reduction course going look solutions 
remarked solutions thesis generality final answer 
fact manage prove general property fij equality practical situations replace cr 
managed prove cr fij welltyped terms restricted class pts fij ones functional normalizing 
proof cr fij system strongly believe holds pts fij normalizing cr fij easily proved 
lack normalization doesn essential 
possible find general proof works pts fij dependency cr fij normalization implies cr essentially higher order property example calculus constructions normalization proof done higher order arithmetic 
feel case non normalizing pts fij proof cr fij pure type systems ch 
done order arithmetic 
having negative comments want stress generality proof especially part analyses fij equality pseudoterms think important contribution general proof cr fij reduction arbitrary pure type systems 

specifying notions studied want fix notions notations studied rest thesis 

definition 
set pseudoterms closed fi reduction 
say satisfies church rosser property fi reduction notation cr fi just satisfies cr fi fi jm fi fi fi say satisfies confluence fi reduction notation con fi just satisfies con fi fi fi fi obviously fi reduction cr fi con fi fij reduction case 

definition 
set pseudoterms closed fi reduction 
say satisfies strong normalization fi reduction notation sn fi just satisfies sn fi infinite fi reduction sequences formulated property positively example saying upperbound length fi reduction sequences starting done bit easier 
proofs strong normalization thesis redone alternative definition 

analyzing fij equality pseudoterms proof church rosser shall relate fij reduction typed terms reductions untyped lambda terms 
properties reduction equality untyped terms obtain results reduction equality define erasure mapping give properties sec 
meta theory pure type systems 
prove called key lemma fij equality enable prove important meta theoretical properties ut uniqueness types sr fi pts fij sr pts fij give proof postponement reduction known property fij reduction postponement reduction prove postponement reduction set pseudoterms argument similar barendregt chapter untyped lambda calculus 
idea mark redexes superscripts inside terms superscript take type abstracted redex 
case convinced fact postponement reduction holds paragraph may skipped 

definition 
set pseudoterms markers defined syntax var var reduction relation fi defined basic steps gamma 
fi gamma 
fi pq induction structure terms compatible application pi abstraction superscript operation 
intended meaning px fi redex pq define mappings erasing superscripts second inserting redex superscript 

definition 

mapping defined erasing superscripts 
mapping defined fresh induction structure term 
easily proved induction structure terms 

lemma 
pure type systems ch 


jm lemma formal justification definition fi reduction shows preserves fi reductions reflects fi reductions 

lemma 

gamma 
fi gamma 
fi 

gamma 
fi fi 

proof 
proof splits cases depending type redex 
required property easily proved case lemma 
proof second imitating reduction 
denotes possible superscript jbj jrj jt fi gamma 
fi 
done 
theta 
lemma 
gamma 
fi fi proof 
say nx 
define 
jp lemma find fi 
lemma find lemma find fi 
done 
theta 
corollary postponement reduction 
fij fi proof 
suffices prove property slight variation lemma fi fi 
property follows immediately lemma 
theta 
theorem 
ae closed fi reduction sn fi sn fij denotes closure proof 
fij postponement infinite fij reduction yields infinite fi reduction postponement fact infinite reductions 
done sn fi 
note effective bound number fi reduction steps normal form compute effective bound number fij reduction steps 
theta sec 
meta theory pure type systems key lemma fij reduction counterexample nederpelt shows tries prove cr fij problem types abstracted variables 
call types domains 

definition 
subterm domain occurs 
concerned pi abstractions 
erasure map removes domains 

definition 
erasure map pi defined induction structure pseudoterms follows 
jxj jsj jx jm pix bj pix jaj jbj jmn jm pi extended extra variable binder pi constants 

known facts cr fij fij reduction continue hold fij reduction pi easily seen viewing pix jaj jbj jbj fixed constant 
jm jm structure apart domains may different 
give definition 

definition 
jm jm respective domains fij equal say domain equal notation proposition relating reduction reduction pi 
proposition 
gamma 
fi jm gamma 
fi jm jm jm similar gamma 
fij pi jm gamma 
fi gamma 
fi jn jq doesn hold general gamma 
variable sort jm pure type systems ch 
proof 
trivial redex erased jm jm redex done pi jm gamma 
jm second trivial erases domains fi redex jm fi redex evaluating find gamma 
fi jn second valid shown oe 
term typed calculus constructions take oe oe oe 
lemma see typed functional normalizing pts fij fij nf jm fij nf 
third corollary general lemma 
theta 
lemma 
jm contains jn proof 
induction number jm contains jm redex point reduction jm note way redex created pi xy gamma 
mx implies innermost jm redex jm jm contains easily done 
suppose jm contains done terms containing take innermost redex jm say jp jx coming px jp contain redex jp jx innermost 
implies px redex apply ih term obtained contracting redex px done 
theta immediate corollary counterexample cr fij 
lemma domain lemma 
subterm fij proof 
psi gamma gamma gamma gamma gamma gamma fi variable occurring free theta sec 
meta theory pure type systems notation obtained replacing domains pi obtained adding domain abstraction 
example 
corollary 
pseudoterms jaj fij jbj fij proof 
jaj fij jbj church rosser jaj fij jbj say jaj fij fij jbj 
take closed fresh variable diagram 
fij immediate consequence lemma 
fij fij fij psi psi gamma gamma gamma fij gamma gamma gamma fij theta 
lemma key lemma 
variable sort 

cp fij fi cq fij length 
pix fij fi pix fij length proof 
prove proof second totally similar 
reasons readability adapt convention capitals pseudoterms small characters elements pi cp case lemma 
cr fij pi find pi jp fij ct jqj fij ct postponement reduction find jqj fi cq ct 
doing fi reductions possible fi reduce redexes overlap fi 
precisely mx gamma 
mn gamma 
reductions cq ct fi reduction step 
length 
find term cq fi cq cq rj pure type systems ch 
cq situation follows 
cp jp jqj fij psi psi gamma gamma gamma fij gamma gamma gamma fi fi ct oeoe cq cq gamma 
follows proposition 
jq fij jp corollary fij done 
theta generalisation key lemma include terms abstraction 
give technical completeness 

lemma general key lemma 
variable sort 

cp fij fi cq qm qm pairwise fij convertible 

pix fij fi piu fij proof 
proof quite similar proof key lemma 
treat case difficult 
properties untyped calculus get picture 
notation denotes denotes cp jp jqj fij psi psi gamma gamma gamma fij gamma gamma gamma fi fi ct oeoe conclude gamma gamma gamma gamma means jp gammar jq gammar just key lemma corollary conclude qm pairwise fij equal done 
theta lemma proved induction length reduction expansion path cp pn suggested werner 
change proof essential way think proof explains idea better 
sec 
meta theory pure type systems 
list properties pure type systems points text essential specific meta theory refer relevant lemmas propositions paragraph may skipped 
arbitrary pts 
explicit pts refer generic system lemma proposition holds specific notion ptss specific subset class ptss explicitly mentioned 
generic case lemma proposition holds notions pts sketched proof works cases 
remarked treat terms modulo ff equivalence example terms different 
fv pix derivable ff conversion 
variables free typable term sense bound declaration context 
variables notion ff conversion call replacement provable shown lemma 

replacement lemma 
gamma gamma context terms fresh variable bound gamma gamma gamma gamma derivation underlying tree underlying tree derivation labelled tree removing derivation names applied rules node 
lemma says names declared variables context really don matter may assume different bound variables 
importance lemma illustrated fact proof induction derivation want handle case rule streng may take variable removed just fresh variable 
lemma implies name removed variable doesn matter 
proof 
induction derivation gamma gamma interesting case rule streng variable removed say gamma gamma gamma gamma gamma gamma fv gamma pure type systems ch 
ih gamma gamma gamma derivable derivation underlying tree arbitrary fresh variable 
ih gamma gamma gamma derivable derivation underlying tree 
done application rule streng remove declaration 
theta basic property especially important handy comes proving meta theory remarked randy pollack 

lemma restricted weakening 
gamma derivable may assume derivation gamma contain applications rule weak form weak gamma gamma gamma variable sort fresh weakening rule applied typings variables sorts 
proof property pts fi pts fij quite straightforward 
give 
pts fij proof complicated 
case property proved corollary general implies thinning lemma 
proof 
pts fi pts fij proof induction derivation 
cases rule weak easy 
case rule weak say weak gamma gamma gamma fresh find ih gamma gamma provable restricted form weakening rule described lemma 
going small alterations derivation tree gamma turn derivation tree gamma restricted weakening rule 
alterations follows go tree place context gamma created 
gamma gamma go places gamma extended gamma 
done var rule restricted weak rule var gamma gamma weak gamma gamma gamma sec 
meta theory pure type systems case change derivation inserting gamma gamma gamma gamma replacing gamma gamma downwards 
second case change derivation inserting gamma gamma gamma gamma gamma replacing gamma gamma downwards 
easy see alterations satisfy requirements 
theta convenient special notation derivability system restricted weak rule lemma 
introduce 
notation 
gamma denotes fact gamma derivable derivation tree weakening rule restricted typings variables sorts weak gamma gamma gamma variable sort fresh consequently talk derivation gamma refer derivation tree restricted weakening rule 

lemma free variables 
gamma gamma 
fv ae fx 

proof 
easy induction length derivation gamma theta 
lemma 
gamma context 
gamma 
gamma 
gamma gamma proof 
easy induction length derivation shows gamma context derivation sequent gamma 
theta pure type systems ch 

thinning lemma 
gamma gamma contexts pseudoterms gamma gamma gamma gamma proof pts fi pts fij straightforward 
due strengthening rule proof quite difficult pts fij comes easy corollary induction loading prove thinning lemma restricted weakening rule 
proof 
pts fi pts fij proof induction derivation 
treat case rule pi rule interest just case rule similar 
say gamma gamma gamma pix gamma gamma 
may assume dom gamma lemma 
ih gamma gamma context 
applying ih second premise find gamma pi rule gamma pix done 
theta 

gamma gamma delta contexts terms 
gamma gamma dom gamma dom delta im gamma im delta gamma delta gamma delta interesting system pts fij consequences thinning restricted weakening hold pts fij pts fi pts fij easy consequence thinning pointed mckinna possible prove thinning substitution proposition proving lemma 
gamma delta ae gamma oe delta ae ae ae arbitrary substitution pseudoterms variables straightforwardly extended mapping delta ae gamma means delta ae ae gamma 
lemma easily proved adapts rule streng follows streng gamma gamma gamma gamma gamma fv gamma rule equivalent streng easily shown lemma 
sec 
meta theory pure type systems restricted weakening proved thing show delta gamma delta statement context 
proof 
pts fij induction derivation gamma treat cases rule var weak pi streng 
case similar pi cases sort app conv easy case weak 
var say gamma gamma gamma gamma delta contexts satisfying requirements lemma 
gamma gamma apply ih gamma obtain delta gamma delta argument similar proof second case lemma show general gamma gamma gamma situation delta gamma delta delta gamma delta may conclude delta gamma delta done 
weak say gamma gamma gamma gamma gamma delta contexts satisfying requirements lemma 
gamma gamma apply ih gamma obtain delta gamma delta done 
pi say gamma gamma gamma pix gamma gamma delta contexts satisfying requirements lemma 
ih delta gamma delta delta gamma delta context 
delta gamma delta gamma apply ih gamma obtain delta gamma delta conclude application pi delta gamma delta pix 
streng say gamma gamma gamma gamma gamma gamma gamma delta contexts satisfying requirements lemma 
ih fact gamma gamma gamma gamma get gamma gamma gamma gamma gamma pure type systems ch 
context 
gamma gamma gamma apply ih obtain delta gamma delta fv delta gamma delta application streng 
theta corollaries find proofs restricted weakening lemma thinning lemma pts fij take delta gamma gamma second take delta 

proposition substitution 
gamma gamma context terms gamma gamma gamma gamma gamma proof 
induction length derivation gamma gamma assuming gamma derivable 
case really interesting rule streng system pts fij treat case rule app attention substitutions 
streng say streng gamma gamma gamma gamma fv delta notation gamma denote context obtains context gamma removing declaration delta tail context gamma gamma relative position declaration right gamma gamma required consequence follows easily applying ih gamma gamma gamma streng 
declaration left streng gamma gamma gamma gamma fv delta ih immediately apply thinning lemma may conclude gamma ih gamma gamma 
note fv apply streng get gamma gamma done 
app say app gamma gamma piy gamma gamma gamma gamma mp sec 
meta theory pure type systems ih app gamma gamma 
may assume fv gamma gamma precise justification assumption may replacement lemma 
fv conclude done 
theta 
stripping lemma 
gamma context terms 
gamma ii gamma var gamma term iii gamma pix gamma gamma pts fi iv gamma gamma gamma pix pix term gamma mn gamma pix gamma terms pts fij iv gamma gamma gamma pix pix gamma gamma gamma mn gamma pix gamma terms context gamma gamma fact case iv strengthened iv pts fij iv holds generally notions pts 
position prove fact proved subject reduction property fi reduction lemma turn uses stripping weaker version lemma 
proof 
pts fi pts fij proof easy gamma may assume derivation tree judgement restricted form weakening rule 
go derivation tree reach point term formed 
doing pass applications conversion rule context gamma remains type replaced convertible 
point term formed distinguish different cases form easily check satisfied 
pts fij proof complicated going derivation tree judgement gamma pass applications streng extend context gamma context gamma proofs iv easy method described going derivation tree reach point term formed works cases 
pure type systems ch 
proof ii apply method arrive context gamma gamma declaration context gamma obtained gamma removing declarations course gamma done 
proof iii apply method arrive context gamma gamma gamma gamma gamma pix domain gamma may larger gamma extra variables occurs free pix may assume different conclude gamma gamma done 
theta 
correctness types lemma 
gamma context terms gamma gamma proof 
proof analysing derivation tree gamma proof induction derivation gamma follow second option gives shortest proof 
cases interest rule app streng 
app gamma pix gamma gamma pn gamma pix ih stripping lemma gamma substitution proposition conclude gamma 
streng gamma gamma gamma gamma ih gamma gamma application streng gamma gamma theta 
uniqueness types lemma 
functional ptss gamma context terms gamma gamma proof 
induction structure term stripping 
case sort pi term functionality 
interesting cases application term pts fij abstraction application 
case covers sec 
meta theory pure type systems interesting cases 
pn find stripping terms contexts gamma gamma gamma gamma gamma pix gamma pix fij fij 
replacement lemma may assume dom gamma gamma dom gamma gamma take delta union gamma gamma delta pix delta pix apply ih conclude pix fij pix key lemma may conclude fij fij done 
theta 
subject reduction lemma beta sr fi 
gamma gamma contexts terms gamma gamma 
fi gamma gamma gamma gamma 
fi gamma gamma proof 
proof pts fij pts fij pts fi proof slightly easier stronger version stripping lemma 
proof statements done simultaneously induction derivation gamma distinguishing cases rule 
proof cases rule app immediate ih 
pi ih ii 
rule app distinguish subcases reduction takes place 
subcase gamma pix gamma gamma mn mn reduction inside immediately done ih 
subcase gamma pix gamma gamma pure type systems ch 

applying stripping premise find gamma gamma pix pix pix gamma gamma stripping gamma gamma applying thinning second premise find gamma key lemma conclude pix pix applying conv get gamma applying substitution proposition get gamma applying correctness types lemma premise find gamma pix gamma pix stripping gamma apply substitution get gamma apply conv conclude gamma variables set dom gamma dom gamma free gamma removed consecutive applications streng obtain gamma done 
sec 
meta theory pure type systems proof ii cases handled easily applying ih 
case rule var weak ih 
theta 
corollary 
gamma fi gamma proof 
immediate correctness types 
theta 
subject reduction lemma eta sr pts fi pts fij 
gamma gamma contexts terms gamma gamma 
gamma gamma gamma gamma 
gamma gamma proof 
prove pts fij proof pts fi slightly simpler follows lines 
uses fact streng derived rule shown 
simultaneously induction derivation gamma treat proof pts fij complicated 
interesting case rule lambda rule situation gamma mx gamma pix gamma mx pix fv 
stripping find gamma piy gamma gamma gamma may conclude pix piy gamma pix applications streng find gamma pix done 
cases proof follows exactly proof sr fi theta 
corollary 
pts fi pts fij gamma gamma pure type systems ch 
proof 
immediate correctness types 
theta 

proving streng derived rule pts fi pts fi gamma gamma context terms gamma gamma fv gamma fi gamma gamma property obviously correct proof general case remarkably complicated requires new notions definitions 
reason proof omit refer van benthem jutting details original source 
idea prove streng derived rule appeared luo system ecc 
author nederhof joint geuvers nederhof give proof functional pts fi 
case situation easier uniqueness types 
shortly repeat proof 
proof 
functional pts fi proof induction derivation gamma gamma distinguishing cases rule 
interesting cases rule app conv treat 
say piy gamma gamma gamma piy gamma gamma piy ih gamma gamma fi gamma gamma subderivation derivation gamma gamma ih gamma gamma correctness types find gamma gamma second case sr fi functionality rule justified formation piy apply pi conclude gamma gamma piy gamma gamma piy 
app say np gamma gamma piy gamma gamma gamma np ih gamma gamma piy gamma gamma fi fi church rosser find term fi corollary gamma gamma piy gamma gamma may conclude gamma gamma np done 
sec 
meta theory pure type systems conv say gamma gamma gamma gamma gamma ih gamma gamma fi fi gamma gamma done 
theta statement weakened bit requiring convertible necessarily reduct 
case conv doesn proof really easier need church rosser functionality case rule bit involved 
slightly get strengthening 

strengthening lemma 
pts fi gamma gamma context terms gamma gamma fv gamma gamma gamma proof 
find fi gamma gamma correctness types possibilities gamma gamma second case immediately done case apply gamma gamma find gamma gamma done application conv 
theta 
strong permutation lemma 
pts fi pts fij gamma gamma context terms fv gamma gamma gamma gamma proof 
thing show gamma gamma legal context gamma gamma 
done thinning 
lemma know gamma pure type systems ch 
strengthening pts fi lemma rule streng pts fij conclude gamma gamma legal context 
lemma thinning derive gamma legal context 
repeat operation applying lemma thinning declarations gamma conclude gamma gamma legal context 
theta weak form permutation lemma holds notions pure type system 
gamma gamma gamma gamma gamma proof proof strong permutation lemma fact doesn need strengthening second assumption statement 
want prove properties syntax sorted variables described definition 
prove lemmas injective pts fi restriction restriction injectivity especially don lemma pts fij shall look matter detail study calculus constructions fij conversion 
lemmas true drop restriction injective systems counterexample geuvers nederhof 

classification lemma injective systems 
sorts term term elt elt proof 
suffices prove 
gamma gamma second suffices prove 
gamma gamma prove statements simultaneously induction structure terms church rosser property sr fi uniqueness types 
proof really difficult bit tricky give quite detail 
sec 
meta theory pure type systems var 
gamma gamma var gamma fi gamma fi furthermore gamma gamma axioms 
injectivity second statement suffices show gamma var gamma gamma gamma fi church rosser sr fi uniqueness types pi abstr 
gamma pix gamma pix gamma gamma time gamma gamma ih theta theta function 
second statement easily done gamma pix gamma pix reduce fixed argument statement 
fact function 
abstr 
statement trivially satisfied fact abstraction term 
second statement suppose gamma gamma pix gamma gamma gamma pix time pix gamma gamma gamma pix 
ih church rosser sr fi uniqueness types applic 
prove second statement gamma mn gamma mn gamma pix gamma gamma fi time gamma pix gamma gamma 
ih injectivity 
church rosser sr fi uniqueness types statement gamma mn gamma mn find argument second statement fixed sort injectivity theta specialize lemma bit noticing lot cases sort elt depends innermost symbol sort variable 
define notion call innermost symbol heart term notation 
pure type systems ch 

definition 
heart defined induction structure terms follows 
var pix mn 
lemma 
injective pts fi rules form 
elt var term var proof 
induction structure part lemma reverse implication uses classification lemma case cases follow straightforward ih restrictions rules axioms 
second part lemma cases follow easily ih restrictions application term case need part lemma 
case detail 
pn say gamma pn gamma piy gamma fi apply part lemma term pn find pn var pn restrictions rules fact find pn var pn done 
theta chapter church rosser property fij reduction 
chapter want treat proof church rosser property fij reduction functional normalizing pure type systems 
restriction functional normalizing systems don mean general property false moment open question strongly believe cr fij holds general pure type systems 
section shall comments proof believe deficits 
giving proof roughly follow geuvers 
fact proof give expanded updated version 
changed order lemmas bit stress properties general ones specific properties functional normalizing ptss 

proof cr fij normalizing systems giving proof want fix terminology highlight properties come handy proofs 
notation 
suppose gamma derivable judgement functional pts 
subterm speak type derivation gamma fact type unique fij equality due uniqueness type property lemma 
introduce notation ty depends gamma dependency usually mentioned explicitly unique fij want fix notion variable free ty 
ty unique fij shall usually interested know find type free 
cr fij ch 
introduce notation ty denote type fv 
note relative gamma 



terms sort type key lemma gives practice specific information pix fij fi pix fij similarly xp delta delta delta fij fi xq delta delta delta fij true abstraction 

typed terms arbitrary pts fij equal sort key lemma gives extra information term fij fi 
easily verified noticing fij fi see proposition typed empty 
list lemmas valid pts just functional normalizing ones 
listed general meta theory pure type systems properties terms equal term normal form systems normalizing properties loose interest 

lemma 
gamma fij nf fij fv types gamma fv types gamma terms gamma variable proof 
proof induction structure sort variable trivial 
pix done induction hypothesis 
suppose application term 
free domains 
note jbj fij jaj nf jaj untyped lambda calculus reductions remove free variables fv jaj 
say leftmost domain occurs free say subterm zr delta delta delta delta delta delta 
ty declared context abstracted inside left implies ty zr delta delta delta 
ty zr delta delta delta piy delta delta delta piy piy fij fv 
apply ih fi nf fv 
fv leftmost domain occurs free 
theta 
proposition 
term fij nf jm fij nf 
sec 
proof cr fij normalizing systems proof 
suppose fij nf jm fij nf 
jm fi nf proposition 
redex jm redex say jn jx left 
fv fv jn occurs free domains follow roughly method proof lemma say leftmost domain free say occurs subterm zr delta delta delta delta delta delta 
ty 
declared context abstracted left abstraction ty convention bound variables different different free ones 
abstracted right ty assumption leftmost domain containing 
implies ty zr delta delta delta fact ty zr delta delta delta piy delta delta delta piy piy find fij fv 
lemma fv leftmost domain occurs free 
jm fij nf 
theta 
lemma 
gamma gamma fij jm jm fi nf equality defined definition corresponding domains fij equal 
proof 
structure apart domains show respective domains pairwise fij equal 
say abstractions 
fij pix pix fij pix pix fij stripping fij compare left right domains say occurs zr delta delta delta occurs zr delta delta delta domains left respectively done induction 
fij fij ty zr delta delta delta ty zr delta delta delta 
implies ty ty fij theta lemma collects results previous lemmas establishing confluence fij equality types normalizing pts fij cr fij ch 

lemma 
gamma gamma fij fij nf proof 
induction structure key lemma 
pix fij pix fij fij induction hypothesis xp delta delta delta xq delta delta delta fij key lemma 
ty xp delta delta delta ty xq delta delta delta xp delta delta delta xq delta delta delta fij nf delta delta delta delta delta delta delta delta delta delta delta delta apply conclude respective domains xp delta delta delta xq delta delta delta fij equal 
induction hypothesis comparing domains xp delta delta delta xq delta delta delta left right conclude respective domains xp delta delta delta xq delta delta delta syntactically equal xp delta delta delta xq delta delta delta theta 
theorem con fij normalizing functional pts fij 
gamma gamma fij fij proof 
define nf nf 
prove done 
sr fi sr find gamma gamma jn jn normal form jn jn respective domains fij equal 
compare respective domains left right 
lemma respective domains syntactically equal theta obviously normalization essential proof 
note restriction pts fij essential pts fij don know prove sr course interested proving cr fij pts fij functional normalizing 
somewhat surprisingly easy pts fij done section show streng derived rule functional normalizing pts fij theorem holds functional normalizing pts fij fact required simple corollary lemma 
proof streng functional normalizing pts fij redoing proof streng pts fi 
lemma 
sec 
proof cr fij normalizing systems property proves strengthening sr interesting give name treat specific feature 
practice holds quite generally functional systems normalizing proof normalization case cc fij point text 

definition 
say pts fij pts fij satisfies fij preservation sorts gamma gamma fij obviously non functional pts satisfy fij preservation sorts uniqueness types doesn hold 
clear strongly believe property hold functional pts comes immediate consequence confluence subject reduction uniqueness types 
corollary lemma interested context functional normalizing pts fij satisfy fij preservation sorts 
reason highlight property special definition twofold specific feature need proof strengthening sr 
second fij preservation sorts quite easily proved systems cc fij 

corollary lemma 
functional normalizing pts fij satisfies fij preservation sorts 
proof 
suppose gamma gamma functional normalizing system streng 
gamma gamma extension system rule streng 
normalize sr fi sr extended system gamma nf gamma nf extended system 
lemma implies nf nf uniqueness types theta trivially corollary holds functional normalizing pts fij 

pts fij satisfies fij preservation sorts gamma gamma fv gamma fij gamma gamma proof 
proof induction derivation gamma gamma distinguishing cases rule 
interesting cases rule app treat 
cases cr fij ch 
say piy gamma gamma gamma gamma piy gamma gamma piy ih gamma gamma fij gamma gamma gamma gamma subderivations ih gamma gamma fij gamma gamma sr fi correctness types find gamma gamma second case fi gamma gamma piy gamma gamma piy piy fij piy case fij preservation sorts gamma gamma piy gamma gamma piy piy fij piy 
app say np gamma gamma piy gamma gamma gamma gamma np ih gamma gamma gamma gamma piy fij fij key lemma find fi piy fij fij corollary gamma gamma piy apply conv fij gamma gamma fij conclude gamma gamma gamma gamma np fij 
theta 
lemma 
pts fij satisfies fij preservation sorts satisfies strengthening gamma gamma fv gamma gamma gamma proof 
find gamma gamma fij correctness types possibilities gamma gamma second case immediately done sr fi fi case gamma gamma applying find gamma gamma fij done fact fi sr fi application conv 
theta sec 
proof cr fij normalizing systems 
corollary fij preservation sorts implies sr 
pts fij satisfies fij preservation sorts satisfies sr proof 
proof exactly lemma proves simultaneously 
gamma gamma 
gamma gamma gamma gamma 
gamma gamma proof uses fact strengthening stated lemma 
theta 

fact fij preservation sorts prove strengthening sr specific property need proof strengthening 
gamma gamma fij case rule 
system satisfies fij preservation sorts property obviously satisfied 
pure type systems satisfy property example semi full ones 
remember pts semi full easy verify mentioned property holds 
consequently semi full pts fij satisfy strengthening semi full pts fij satisfy sr 
theorem con fij normalizing functional pts fij 
gamma gamma fij fij proof 
theorem follows immediately theorem fact functional normalizing pts fij rule streng satisfied follows immediately corollary lemma 
theta cr fij ch 

discussion proved con fij terms fixed context fixed type functional normalizing pts fij immediately implies cr fij term sr fi sr systems 
confluence typed terms different types doesn hold just consider known counterexample 
said typed terms different contexts take fij gamma gamma gamma gamma fij fij 
think van benthem jutting gives analysis typing ptss results extended arbitrary normalizing type systems 
interesting extension non normalizing type systems 
proof relies heavily normalization 
second important con fij term gamma 
conv fij hope get con fij term gamma arbitrary pts fij imitating reduction steps pts fij category pts fij prove general statement lines describe pts fij con fij con fij holds pts fij note saying sr holds semi full pts fij 
definition 
pts fij system theta theta theta full semi full implies satisfies sr 
see 
proposition 

proposition 
satisfies con fij pts fij satisfy con fij proof 
suppose satisfies con fij arbitrary pts fij gamma fij show fij gamma mapping sorts injective set sorts occur gamma full map gamma pts morphism gamma fij due local injectivity gamma reduction paths resp 
faithfully translated back reduction paths resp 
fij theta sec 
discussion restriction normalizing systems need prove normalization fij reduction church rosser property 
may look problematic practice isn 
example calculus constructions strong normalization proof geuvers nederhof system conv fi quite easily adapted proof strong normalization system conv fij 
conjecture general theorem pts fi strongly normalizing pts fij proof cr fij non normalizing systems need complicated shown example system defined definition normalization hold 
extend system replacing conversion rule conv fij rule separation contexts proposition holds 
due property proof cr fij easy 
works follows 
note gamma type contains redexes 

gamma type domains contain redexes 

conclude con fij holds 
note gamma prop domains terms gamma type gamma prop type 

domains con fij holds 

con fij holds gamma prop 
look church rosser property point view compute common reduct see situation really bit complicated untyped lambda calculus 
untyped lambda calculus fij fij common reduct complete developments 
see barendregt 
reduce domains consider residuals fi redex residuals redex complete development set redexes 
untyped case 
unify cr fij ch 
chapter calculus constructions fine structure 
encountered calculus constructions cc example pure type system called 
chapter want study system detail 
done various ways 
say practical meaning system terms logic data types 
want see calculus constructions logic study formulas types embedding higher order predicate logic cc 
defined embedding chapter paragraph embedding system pred 
cc 
convinced fact pred 
pred 
isomorphic systems formulas types analogy shall studying embedding pred 
cc 
paragraph encountered called cube typed lambda calculi gives fine structure cc 
shall study systems cube especially relation formulas embedding 
central question systems formulas types embedding complete 
mainly concerned cube point view logic interesting see extent systems cube conservative 
complicated issues regarding cc treated chapter strong normalization church rosser property fij reduction terms cc 
strong normalization dealt chapter 
discussed church rosser property chapter 
normalization follows techniques developed chapter church rosser property holds fij reduction cc 
calculus constructions ch 

cube typed lambda calculi logic cube recall definitions previous chapters 
remember barendregt cube typed lambda calculi definition consists pts fi 
rules system table 










system 
calculus constructions called pure calculus constructions distinguish variants extensions 
shall refer cc 
systems cube usually follows 

cc gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma arrow denotes inclusion system 
remember defined logic cube definition berardi follows 
consists pts fi having prop set type type prop type set type sec 
cube typed lambda calculi logic cube rules systems table prop prop prop prop prop prop type prop prop 
type type prop prop prop 
type type prop prop type prop pred set set set type prop prop set prop pred set set set type prop prop set prop type prop pred 
set set set type type set type type prop prop set prop pred 
set set set type type set type type prop prop set prop type prop systems picture follows 
prop 
pred 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma prop pred prop 
pred 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma prop pred arrow denotes inclusion system 
calculus constructions ch 
convinced fact formulas types embedding logic corresponding system logic cube fact isomorphism restrict study formulas types embedding systems barendregt cube study collapsing mapping remember defined family pts morphisms logic cube barendregt cube prop set type type 
meta theory cc going studying systems want definitions 
necessary proof strong normalization chapter 
rest chapter assume working system sorted variables cube sets variables var var see definition details sorted variables 

definition 
system cube define sets kinds types constructors objects follows 
kind term type term constr elt obj elt usually clear context case omit 
note type ae constr 
apply lemma conclude kind type constr obj useful defining mappings terms system cube 
related property useful defining mappings lemma allows distinguish cases heart term 
see definition 
cube heart term variable 
lemma derive 
sec 
meta theory cc 
lemma 
typed term cube kind type var constr var obj var barendregt mappings subsets typed terms cube defined specific subset pseudoterms case distinction definition level terms 
notion level close notion heart fact mappings barendregt defined similarly case distinctions heart subterms 
try refrain defining mappings pseudoterms define mappings typed terms possible feel intuitive 
completeness define notion level give main property want 

definition 
cube level natural number defined follows 
var var notion level closely related automath notion degree 
automath numbering reversed 
main property levels 

lemma 
system cube gamma proof 
immediate consequence lemma 
theta important mapping typed terms untyped lambda terms encountered map erases domains types abstraction 
syntactical mapping leaves lot type information importance underlying algorithm term represents 
define mapping erases type information 
calculus constructions ch 

definition 
mapping objects system cube untyped lambda calculus defined follows 
jxj jx jm type jff jm kind jmn jm object jmn jm constructor 

definition 
abstractions typed term cc definition immediately extends pseudoterms cc split classes abstractions follows 

abstraction object type 
ff abstraction object kind 
abstraction constructor type 
ff abstraction constructor kind 
decorate correspondingly speak term define notions fi reduction fi reduction fi reduction fi reduction just restricting reduction redexes appropriate subscript attached arrow superscript denote restricted reductions gamma 
fij etcetera 
want state important properties cc 

theorem 
cc strongly normalizing 
fi reduction sequences starting term cc finite 
proof 
detailed proof chapter 
theta proof normalization coquand proof contained bug remarked jutting 
coquand repaired proof coquand gallier gave different proof strong normalization coquand gallier 
various versions strong normalization proofs cc literature 
higher order variant de method developped girard proving strong normalisation system 
see girard proof system 
idea define kind realisability model propositions interpreted sets lambda terms 
detailed explanation method gallier 
proof strong normalization chapter defining reduction preserving sec 
meta theory cc mapping cc 
sn cc follows sn 
things slightly easier don bother type dependency 
easier handle cc 
complicating matter chapter proof cc conv fij rule 
pts fij cc 
strong normalization system open problem 
clear hard part proof theoretically speaking proof sn cc normalization redexes 
thing observed case 
proof chapter clear problem sn cc reduced problem sn erased terms 
case redexes left 
coquand huet version cc discussed conversion rule restricted performing fi fi reductions 
called restricted calculus constructions 

definition 
restricted calculus constructions system cc conv rule restricted fi 
equality 
show restricted case sn relatively easy simply typed lambda calculus 
recall definitions fi redex fi redex definition fi redex fi redex form ff kind constructor 
fi redex fi redex form type constructor 
write gamma 
fi gamma 
fi corresponding reductions 
show fi 
reduction normalizing 

proposition 
combination fi reduction redexes redexes fi 
reduction normalizing cc 
proof 
proof flavour complexity quite close normalization proof 
assign term cc pair maximum depths fi 
redexes number fi 
redexes maximal depth 
proceed contracting innermost redex maximal depth 
procedure yields fi 
normal form shown induction lexicographical ordering pairs 
giving definition depth remind fact ways new fi redexes created fi reduction 
gamma 
fi xq gamma 
fi pq gamma 
fi possibility time example second 
way existing redexes duplicated fi reduction gamma 
fi calculus constructions ch 
having free occurrence define depth fi fi redex depth rank type rank kind type ff kind defined rank 
rank pix rank type rank piff rank rank kind defined uniqueness types property cc lemma fact kinds fi equal ranks 
normalization procedure contracting time innermost fi 
redex maximal depth 
define term complexity pair maximal depth fi 
redexes number fi 
redexes depth normalization procedure reduces complexity terms lexicographical ordering 
show distinguishing different possibilities creating new redexes mentioned 
duplication redexes happen redexes rank smaller duplication problem 
ffl note case contracted redex fi redex 
second case contracted redex fi redex created redex fi 
redex 
ffl cases contracted redex fi redex depth type part piff rank piff depth new redex rank number redexes depth reduced 
ffl third case contracted redex depth type part piu rank piff depth new redex rank number redexes depth reduced 
uses fact rank kind stable substitution 
theta restricted calculus constructions limited interest possible fi 
normalize perform fi steps obtain fi normal form 
fi reduction create fi redex fi reduction create fi redexes 
example ff 
qy ff gamma 
fi ff importance strong normalisation property lies fact gives handle number proofs proposition 
example sec 
intuitions calculus constructions show closed term type nat fi equal numeral term form 
normalization prove decidability typing 

theorem 
cc context gamma decidable exists term gamma term exists computed effectively 
proof hard depends normalization 
note type checking restricted calculus easier due easy normalization proof 
hints proof coquand huet details coquand especially martin lof 
see harper pollack exposition decidability typing extended version cc describes algorithm computing type 

intuitions calculus constructions remarks impredicative coding data types higher order polymorphic lambda calculus 
feel necessary understanding cc 
purpose doesn matter consider versions called 
pts fi versions called 
details encoding bohm berarducci girard 
just treat examples 

examples 

natural numbers defined type nat piff prop ff ff ff ff find zero ff prop ff ff ff nat ff prop ff ff ff easy define functions iteration nat oe oe oe nat oe nat 
possible define functions primitive recursion bit involved inefficient 

oe type type list oe defined type list oe piff prop ff oe ff ff ff find constructors nil ff prop ff oe ff ff cons list oe ff prop ff oe ff ff ft function head tail defined iteration primitive recursion lists 
calculus constructions ch 

coinductive dat types defined understood greatest fixed points domain inductive data types correspond smallest fixed points 
example treat type streams infinite lists natural numbers 
str nat ff ff nat ff ff ff convenience write hf xi ff nat ff ff ff ff nat ff ff ff projections destructors head str nat nat tail str nat str nat defined head str nat tail str nat nat fik kff possible define function str nat corecursion 
impredicative data types lot structure 
girard shown define type nat recursive functions provably total higher order arithmetic 
idea domains logic 
view higher order proposition logic term calculus construct functions terms 
want predicate logic add possibility defining predicates new domains adding rule kind 
represents type predicates declare variables type 
context 
calculus constructions cc pure type system understanding higher order predicate logic sort universe propositions domains range closed data types 
way see things 
understand just universe propositions refraining understanding propositions domains case type 
understood type predicates proofs 
practical purposes approach doesn fruitful 
example distinguish proofs cut free proofs 
lambda terms fi equal proofs equal cut elimination sec 
intuitions calculus constructions identified provable fi provable 
looking kind applications promising coding logic relatively weak framework automath lf 
possibility restrict conversion rule cc convertible propositions identified 
system described coquand huet 
clear approaches distinction domains objects proofs blurred propositions may contain proofs priori distinction domains propositions 
hand take formulas types approach seriously sense formulas treated way types domains just types putting universe 
mixing formulas domains curry howard embedding higher order predicate logic cc complete 
embedding higher order propositional logic cc refrains understanding propositions domains complete 
want treat examples get flavour system 
examples impredicative coding data types described 
want discuss induction terms type nat see extent nat represents free algebra natural numbers 
treat formulas represent specifications programs 
touches interesting aspects cc higher order constructive logic represent specifications formulas data types 
proof formula constructive content extracted program precisely lambda term typable 
lot subject done paulin shall say little bit paragraph 

example 
know normalization property cc closed term type nat fi equal term form ff ff ff ff fx modulo fi equality closed terms type nat precisely ones formed induction property expressed cc provable inside 
precise define ind nat nat 
nat px sx nat px ind nat provable 
assume ind nat prove type nat free structure generated establish add premises nat sz nat sx sy propositions provable cc 
higher order predicate logic working natural numbers signature hn si assumptions independent calculus constructions ch 
add obtain free algebra natural numbers 
cc 
due specific structure type nat assumptions ind nat nat sz suffice prove freeness nat 
define nat nat ind nat nat sx nat cc 

examples 

abbreviate list nat list 
proposition stating finite list numbers number elements expressed list nat nat stands list list list nat stands nat nat 
nat rxx nat rxy rx sy rmn proof proposition constructs list number proof fact extract program type list nat satisfies specification 

abbreviate str nat str 
proposition infinite stream maximal element expressed str nat nat nat maximum stands nat head maximum stands nat proof formula able extract term type str nat computes maximum stream exists 
means want extract partial function maximum may exist possible cc functions total 
due normalization 
practice problem extracted function produce arbitrary number case maximum 
corresponds fact proof formula maximum take number satisfy maximum 
clear construction proof algorithm depends heavily proof premise 
sec 
formulas types logics cube 
formulas types logics cube curry howard embedding logics typed calculi cube essential distinction hand basic functional domains including definable data types hand predicate domains prop 
basic domains interpreted variables type functional domains implicational formulas definable data types embedding data types system predicate domains interpreted kinds 

logic cube described formulas embedding pts morphism 
fact reason introducing logic cube place 
section study completeness formulas types embedding different systems cube studying pts morphism logic cube cube 
main concern chapter calculus constructions look embedding systems 
fact ways interpreting pred 
cc describe inventor cc aim see coquand coquand huet called canonical embedding higher order predicate logic cc 
holds system longo moggi clear intention system formulas types embedding pred way described mapping setting canonicity partly forced syntax understand embedding semantical point view 
known embedding cc complete sentences provable pred 
provable mapped cc 
shall treat examples sentences 
incompleteness result referred non conservativity cc higher order predicate logic terminology bit ambiguous non conservativity applies system subsystem 
shall correct terminology completeness embedding 
embedding question open reasons believe embedding complete 
explained berardi shall discuss reasons briefly 
embedding pred complete shown independently berardi barendsen geuvers 
shall give proof uses method developped show completeness formulas types embedding full order logic intuitionistic theory types 
completeness embedding quite non trivial result interesting practical point view 
logic pred minimal practical mathematical interest notion negation 
calculus constructions ch 

formulas types embedding cc terms type typable cc context comes pred intuitive meaning higher order predicate logic ff prop ff prop ff px ff prop 
px ff domain proposition pred 
pointed refrain predicate logic view cc higher order propositional logic propositions proofs propositions 
typed lambda calculus corresponding higher order propositional logic prop exactly systems 
understand embedding prop 
cc just look inclusion cc 
kind exotic types understood higher order propositional logic 
example ff ff ff px ff states ff proposition proof ff holds ff holds 
go arbitrary high levels meta reasoning example ff ff ff px px qy piff ff known inclusion cc complete cc conservative 
proved independently paulin berardi give proof paragraph 
quite similar proof conservativity predn propn gave chapter 
pointed formulas types embedding higher order predicate logic cc complete 
want discuss examples sentences provable logic inhabited mapped cc 
time obtains better understanding logical merits cc 
show allows empty domains logic incompleteness quite easy 


cc existential quantifier projection similar martin lof understanding existential quantifier strong sigma type 
see martin lof 
remember piff pix ff ff pred 
cc projection function 
take za sec 
formulas types logics cube provable immediately obtains closed term type applying general second projection strong sigma 
example assumed context say pz provable 
obviously pred 
existential quantifier projection expression formed set prop 

lemma 
pred fv set prop prop px oe oe cc term 
px proof 
pred context doesn contain declaration variable construct term type proof 
cc take px px 
theta empty domains embedding complete independently shown berardi geuvers 
treat counterexamples starting short syntactic 
proofs give counterexample completeness embedding third order predicate logic called third order dependent typed lambda calculus 
terminology cc higher order dependent typed lambda calculus system second order dependent typed lambda calculus 
counterexample empty domains works second order dependent typed lambda calculus known find counterexample allowing empty domains 

proposition 
formulas types embedding higher order predicate logic cc complete 
proof geuvers 
fact fv oe distinguished cc 
pred 
distinguished set prop 
take gamma set prop prop prop pix try find proof fi prop fi 
extensionality assumed context 
supposing easily shows normal form 
cc take type fi sets propositions distinguished 
precisely gamma pix gamma fl fl fi fi fi theta calculus constructions ch 
proof berardi 
define ext piff fi prop ff fi 
ff fi ff fi denotes ff fi fi ff denotes leibniz equality prop ff prop fi prop prop ff fi 
ext extensionality axiom propositions 
denote cc version ext ext ext piff fi ff fi 
ff fi cc axiom unexpected consequences take set nonempty cc ext follows generic properties hold hold vice versa 
construct cc proof ext model model app app ffi id ffi app id implies things term type fixed point 
course higher order predicate logic ext doesn follow function non empty domain fixed point 
look example context heyting arithmetic gamma ha pix sx sy pip piy sy piy term cc gamma ha ext theta 
formulas types embedding subsystems cc formulas types embedding systems left plane cube certainly complete shown chapter embedding isomorphism 
leaves systems right plane 
treat case embedding pred 
believe sec 
formulas types logics cube conservativity proof simply adapting proof pred importantly case real interest systems practical interest just come derivative definition cube fine structure cc 
pred 
corresponds pred defined definition 
systems predn introduced reasons semantics wanted treat 
leaves cases case open second case formulas types embedding complete 
say embedding second order predicate logic 
proofs incompleteness embedding cc proposition pn 
formulas types embedding nth order predicate logic nth order dependent typed lambda calculus incomplete 
allow empty domains logic incompleteness easily shown lemma holds pred 
proof reasons believe embedding pred incomplete allow empty domains logic 
reasons provided berardi suggests proof incompleteness 
understand idea think best look extension pred polymorphic sets 

definition 
system second order predicate logic polymorphic domains pred defined extending system pred rule type set extending pred polymorphic domains 
pred pts fi prop set type type prop type set type set set type set set type prop prop set prop type prop example nat piff set ff ff ff ff basic domain 
similarly definable data types polymorphic lambda calculus definable sets system pred system pred logic sense separation domains terms propositions proofs 
prove proposition similar proposition pred states fact system built stages 

proposition 
pred 
gamma gamma gamma gamma calculus constructions ch 
ffl gamma gamma gamma permutation gamma ffl gamma contains declarations form set ffl gamma contains declarations form gamma set type ffl gamma contains declarations form gamma gamma prop ffl set type gamma ffl gamma set type gamma gamma system pred subsystem pred pts morphism embedding pred 
pred consistent due consistency 
introduced pred system pred argument holds pred readily understood 
straightforward semantics pred arbitrary model polymorphic lambda calculus interpret set part second order predicate logic top giving prop part example tarskian semantics arbitrary model polymorphic lambda calculus lot specific structure may raise question pred conservative pred 
don definite answer reasons believe extension conservative 
idea comes berardi 
look context gamma set describes similarity type logic 
pred similarity type finite model going details models clear take element set set theoretic function space prop set subsets forth yields model 
look model similarity type gamma pred see lot new domains types type set interpretation model 
example domain nat piff set ff ff ff ff 
case empty similarity type nat consistently interpreted element set sz provable pred empty context 
similarity type gamma interpretation nat infinite set impossible gamma finite model pred point prove sz viz 
suppose sz non 
sec 
formulas types logics cube 
fact berardi 
similarity type context gamma set finite model pred finite model pred want stress don know fact syntactically semantically show non conservativity may possible gamma essentially infinite models pred doesn prove pred propositions provable pred gamma 
easily seen pred conservative pred formulas types embedding second order predicate logic incomplete 
want show completeness formulas types embedding order logic pred showing completeness pts morphism pred remarked chapter system pred hand minimal oe hand extra features higher order functions definable predicates belong realm standard order predicate logic called pred gammaf definition 
interested completeness embedding pred gammaf sufficient study mapping shown proposition corollary establish conservativity pred pred gammaf pointed system pred minimal real interest practical mathematics system usually seen logical framework lf aut discussed chapter completeness result extended little bit systems bottom type 
considering formulas types embedding pred pred system defined extended constant type constant term 
extra rule gamma gamma gamma ma system pred interesting full classical order predicate logic subsystem 
precisely faithful embedding classical order predicate logic pred double negation translation 
embedding classical order predicate logic system pred complete due completeness embedding pred give technical details proof completeness pred barendsen geuvers proof appears slightly different form 
proof uses techniques developped show completeness formulas types embedding order predicate logic calculus constructions ch 
martin lof intuitionistic theory types 
different proof result berardi 
proposition holds pred write context gamma pred format gamma gamma gamma ffl gamma gamma gamma permutation gamma ffl gamma contains declarations form set ffl gamma contains declarations form gamma set type ffl gamma contains declarations form gamma gamma prop 
gamma ffl set type gamma ffl gamma set type gamma gamma shall refer gamma set context gamma object context gamma concatenation gamma gamma language context question completeness pred context gamma gamma gamma proposition gamma gamma prop gamma gamma gamma exists term gamma gamma gamma pred assume pred context gamma 
gamma gamma gamma gamma 
gamma empty 
declared sets gamma nonempty 
gamma begins declaration fi prop gamma begins fi 
third fourth clause added convenience shall refer fi prop fi true 
case empty domains logic completeness result hold slightly adapted argument 
second satisfied fact working propositional logic 
clause consequence refer declaration set variable gamma 
set variable choose fixed name may assume set declaration pred context gamma 
sec 
formulas types logics cube 
definition 
gamma gamma language context delta context say delta elementary extension gamma gamma notation gamma gamma delta delta gamma gamma extra declarations delta form oe gamma gamma oe example gamma gamma gamma elementary extension gamma gamma 
define mapping gamma language pred 
definition 
mapping gamma terms terms pred defined follows 
set ii type iii jxj variable type delta delta delta iv jxj variable pix bj jbj pix jaj jbj vi jx jm jaj jbj vii jp jp jp jm definition extends immediately contexts declaration form delta delta delta 
removed 
mapping gamma pred justified proposition 

proposition 
delta deltaj jm jaj proof 
induction derivation delta theta 
fact 
gamma gamma set jh jh 
note identity kind terms 

corollary 
delta gamma gamma say delta gamma gamma delta delta gamma gamma delta jm jaj proof 
immediate fact jh gamma gamma declaration gamma set jx aj type jxj case declaration doesn play role anymore 
theta calculus constructions ch 
means gamma mapping back terms pred change terms originated object language 
define mapping back proof language pred types propositions objects proofs pred 

definition 
delta gamma gamma 
map tr constructors delta defined follows 
tr ff true ff set gamma ii tr ff ff ff delta delta delta prop gamma iii tr jaj tr iv tr qt tr jtj tr pix pix jaj tr tr 
proposition 
delta gamma gamma say delta gamma gamma delta delta pix pix gamma gamma delta tr ja delta delta delta ja prop pred proof 
induction derivation 
note 
jaj contains object variables 
furthermore delta gamma gamma delta jm jaj corollary 
theta 
corollary 
delta gamma gamma say delta gamma gamma delta delta gamma gamma delta tr prop pred 
lemma 
gamma set pred gamma gamma gamma true tr pred precise write tr stead tr identity terms type set 
proof 
immediate definition tr 
theta 
lemma 
delta gamma gamma say delta gamma gamma delta delta delta tr jtj tr fi gamma gamma delta tr tr pred sec 
formulas types logics cube proof 
easily proved induction structure second follows fact tr fi tr justified church rosser property 
theta 
proposition 
language context gamma gamma gamma gamma prop gamma gamma tr note identity type prop skip 
proof 
induction structure 
lemma may assume normal form 
base fft delta delta delta ff variable tr fact jt 
fact 
oe say prop 
tr tr tr 
done ih variable occur free easily constructs required derivation trees 
say pix set 
tr pix pix jaj tr tr 
fact lemma pix jaj tr tr equivalent pix tr done ih 
theta 
definition 
delta gamma gamma say delta gamma gamma delta define context tr delta tr delta gamma gamma deltaj tr delta tr delta defined replacing declaration delta tr 
sure declared variables tr delta different ones deltaj 
proposition 
delta gamma gamma delta tr delta tr pred proof 
induction derivation delta 
var gamma delta case tr true second case tr tr delta 
app say delta pix delta delta mt ih tr delta tr pix pix jaj tr tr tr delta tr 
tr delta jtj jaj corollary 
may conclude tr delta jtj tr jtj tr 
calculus constructions ch 
say delta delta pix delta pix ih tr delta tr 
tr delta tr delta jbj tr tr delta jbj tr pix jbj tr tr tr pix conv immediately done lemma 
theta 
corollary 
embedding pred complete gamma gamma language context gamma gamma prop gamma proof context gamma gamma gamma gamma gamma gamma pred proof 
gamma gamma gamma elementary extension gamma gamma proposition gamma gamma gamma tr gamma tr term declarations gamma form set substitute terms variables 
furthermore tr gamma gamma gamma tr proposition 
replace tr time substituting inside 
variables occur tr 
obtain term gamma gamma gamma applying proposition transform gamma gamma gamma theta 
conservativity relations inside cube want address question conservativity inside cube typed lambda calculi logic cube 
look cube typed lambda calculi situation logic cube similar 
sec 
formulas types logics cube results job resulting picture 
gamma gamma gamma gamma gamma gamma 

gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma arrow denotes conservative inclusion dotted arrow denotes non conservative inclusion 
transitivity conservativity system conservative system system conservative system system conservative system problem fill picture 
draw arrows non adjacent systems collect proposition 

proposition 
systems cube typed lambda calculi conservative 
proof 
suffices prove results 

system lower plane cube conservative proposition 

system right plane cube adjacent system left plane conservative proposition 


conservative 
conservative 
corollary 
fourth consequence corollary saying prop 
conservative prop fact prop 
prop isomorphic respectively formulas types embedding 
see paragraph especially proposition third detail calculus constructions ch 
idea berardi 
idea look context gamma represents arithmetic 
gamma strong second order arithmetic gamma 
strong higher order arithmetic 
godel second incompleteness theorem show derive gamma gamma consistent 
hand 
derive gamma gamma consistent 
non conservativity 
theta prove proposition conservativity systems systems lower plane 
proposition proved slightly different way 

proposition 
system lower plane system cube gamma gamma gamma normal form gamma proof 
induction structure applic 
say xp delta delta delta piy gamma gamma gamma ih gamma gamma xp 
go know fi piy gamma gamma ih gamma gamma xp 
continuing way upto find gamma xp delta delta delta application conversion rule gamma conclude gamma xp delta delta delta abstr 
say gamma 
fi pix normal form 
gamma pix gamma stripping conversion rule 
apply ih conclude gamma done abstraction conversion conclude gamma am theta sec 
formulas types logics cube side condition gamma normal form just added convenience giving proof 
essential may dropped 
prove conservativity right plane left plane 
idea define mapping removes type dependencies 
mapping go system right plane adjacent system left plane identity terms typed left plane 
conservativity 
proof originally independently due paulin berardi 
described mapping 
place program extraction second described collection mappings straightforward generalisation mapping 
give conservativity proof 
mappings related similar mappings define predicate logic proposition logic prove conservativity second 

definition paulin berardi 
system right plane adjacent system left plane 
mapping gamma term term defined follows 
variable pix pix 

side conditions justified classification lemma 
distinguished cases heart level subterms 
see lemma lemma mapping gamma extends straightforwardly contexts 
justifies statement definition mapping gamma goes right plane left plane 

proposition 
paulin berardi system right plane adjacent system left plane cube 
gamma gamma proof 
straightforward induction derivation gamma theta calculus constructions ch 

corollary 
paulin berardi system right plane adjacent system left plane cube conservative proof 
thing check term done easy induction structure theta conservativity relations logic cube definition follows 
arrow denotes conservative extension dotted arrow non conservative extension 
prop 
pred 
gamma gamma gamma gamma gamma gamma 
prop pred prop 
pred 
gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma prop pred 
proposition 
systems logic cube conservative pred 
pred proof 
completely proof cube typed lambda calculi proposition 
theta chapter discussed order predicate logic pred pred gammaf functional domains 
stated conservativity result pred pred gammaf proposition 
chapter saw pred corresponds pred defined system pred gammaf corresponds pred gammaf definition 
conservativity pred pred gammaf easily stated proved terms typed lambda calculi 
sec 
consistency contexts cc pred gammaf pred pts morphism defined set set fun set prop prop type type type type easy verify identity term pred gammaf fun 
compare proposition 

proposition 
gamma context oe prop pred gammaf gamma pred nf gamma pred gammaf nf nf embedding complete respect provability pred conservative pred gammaf proof 
induction derivation 
theta 
consistency contexts cc embedding pred 
cc complete cc proves propositions pred may wonder propositions cc prove pose question differently cc consistent 
case shown quite easily giving point model cc 
see coquand 
type interpreted gg language zf interpretation set model called proof irrelevance model coquand model proofs proposition mapped element 
model implies interpretation proposition piff prop ff interpreted cc doesn prove 
shall model construction precise 
fact model construction 
mapping gamma definition find model cc 
consistency cc follows consistency higher order propositional logic conservativity cc 
proposition 
easy construct model calculus constructions ch 
immediately cc problem solved coquand describing model variant cc 
mapping gamma cc purpose 
constructing model want recall properties 
stated proposition 
set kinds 
terms gamma gamma described second proposition variables subterms propositions constructors gamma kind gamma kind gamma consists just declarations gamma gamma kind 
properties imply build interpretation stages giving meaning kinds types constructors objects 
recall variables sets var object variables var constructor variables 
denoted latin characters greek characters 
general interpretation terms uses valuation valuation ae proof variables 
simple model free value need 
convenience think contexts split gamma containing declarations constructor variables gamma containing declarations object variables 

definition 
valuation satisfies gamma notation gamma ff gamma ff interpretation 
doesn contain free variables 
ii valuation satisfies gamma notation gamma satisfies gamma gamma interpretation empty 
contain free constructor variables 

definition 
gamma define interpretation function gamma term 
sets follows 

types arrow denotes set theoretic function space 

constructors valuation constructor variables gamma ff ff pix ff sec 
consistency contexts cc 
objects interpreted 
denotes set theoretic function 
identify singleton sets fact occur propositions 
induction derivations prove property 

proposition 
gamma valuations gamma realise example gamma piff ff gamma case proposition vacuously satisfied 

corollary 
cc consistent 
proof 
valuations 
valuations satisfy empty context non 
theta may wonder ext piff fi ff fi 
ff fi consistent cc 
case seen proof irrelevance model definition 
interpretation ext model cc prove ext cc inconsistent non 
argument applies show cc classical logic consistent 
define cl piff ff ff cl cl consistent context 
interesting example axiom choice 
ac pip pix xy 
pix px fx applying mapping definition obtain ac 
ac inhabited closed term ac inconsistent cc consistency 
notice cases proof consistency assumption done giving model assumption satisfied ext cl proof irrelevance model ac system 
quite trivial cases possible cc model context gamma consists declarations fi zt variable gamma consistent 
contexts kind called strongly consistent seldin 
calculus constructions ch 

proposition seldin 
strongly consistent contexts cc consistent 
proof 
gamma strongly consistent context suppose gamma consecutively substitute closed terms free variables declared gamma assumed propositions piff ff ff 
works follows gamma gamma fi pi fv fx gamma substitute 
terms substitution gamma done 
zt variable substitute ff ff type 
denote substitution conclude gamma substitution lemma 
gamma consistent consistency cc 
theta techniques described show context consistent sufficient handle interesting examples 
mere proof theoretic reasons example possible show consistency gamma ha defined second proof proposition techniques give order consistency proof higher order arithmetic 
kind contexts handled normalization argument assuming inconsistency gamma ha show proof gamma ha normal form proof 
seldin find detailed proof consistency context represents peano arithmetic system slight extension cc 
coquand shows coquand normalization argument context inf rxx rxy rxz rx fx consistent 
contexts larger consistency proof normalization argument course get involved 
semantics helpful tool showing consistency general show non derivability formula specific set assumptions 
course interesting models establish 
streicher examples technique realisability semantics 
knowing certain context consistent course safely doing proofs 
due incompleteness formulas types embedding understood context suspicion higher order predicate logic may unexpected side effects embedded cc 
furthermore cc greater expressibility higher order predicate logic may put context axioms meaning expressed logic 
example axiom definite descriptions generic statement domains 
described pottinger follows dd ff ff 
ff ffp sec 
consistency contexts cc ff ff ff py ff term type ff ff 
ff ff 
take fixed closed term declare variable context 
assume intended meaning dd pred 
clear 
classical logic axiom definite descriptions unexpected side effect cc 

proposition 
pottinger classical logic definite descriptions yield proof irrelevance cc encountered semantical notion proof irrelevance discussion model 
expressed purely syntactical terms phenomenon propositions proofs 
formalised cc proposition pi ff ff ff course pi holds proof irrelevance model interpretation pi pi doesn imply inconsistency 
intend cc predicate logic clearly undesirable gamma proves pi assumption gamma inconsistent 
see pi useful principle proofs odd principle applied domain objects 
treatment domains propositions level principles proofs propositions unwanted applications domains 
proof proposition pottinger uses adapted form proof coquand coquand showing cc classical logic derivation rule strong version disjoint sum yields proof irrelevance 
state result adding derivation rule adding axiom really amounts rule coquand 
result reynolds polymorphism set theoretic berardi proved cc classical logic stronger form definite descriptions replacing 
implies pi 
see lego examples details 

proposition coquand 
classical logic disjunction property classical proofs implies proof irrelevance cc 
mean disjunction property classical proofs cl context smallest set proofs contains proofs obtained proof proof 
put syntactical terms says injections respectively proposition 
ix jx calculus constructions ch 
holds 
proof irrelevance follows context cl cl ff ff ff 
ix jx py presence cl reverse proved construct proof cl cl ff ff ff implication right left interesting 
coquand proved fact gamma construct ffl proof ff ff gamma proves 

formulas data types cc having seen incompleteness formulas types embedding higher order predicate logic cc shall see distance cc pred 
large comes propositions inductive data types 
follows result berardi shall discuss concerns implications formulas types embedding 
details proofs refer berardi 
point purposes deriving programs proofs doesn sense declare theory context 
uses definable impredicative data types inductive predicates done examples 
place discuss detail topic extracting programs proofs cc refer paulin get flavor treat example 
roughly program extracted proof term obtained mapping gamma defined definition 
suppose proof pil list nat pim nat context ind nat pip nat nat list nat theta nat true true true true trivially provable propositions 
contains computationally irrelevant information real program extracted nat list nat substitutes closed term 
course irrelevant substitute general picture clear proof specification obtain program satisfies specification 
paulin sec 
formulas data types cc shown extract proof logical content proof extracted program satisfies specification 
parts proof computational content don 
extraction proces paulin type divided prop data spec consisting propositions purely logical content second consisting propositions purely content third consisting propositions containing logical content 
view discussion example interesting question cc proves propositions inductive data types higher order predicate logic 
clear precise want negative answer general answer positive 
cc prove ext nat sx nat see second proof proposition ind nat nat sz pix nat sx nat sy nat see example consider strongest version inductive data types called parametric data types berardi 
parametric data type set theoretic terms smallest set closed fixed operators functions type defined parametric data type 
parametric data type implies induction uniqueness properties satisfied 
algebraic terms parametric data type just free initial algebra 
restrict specific class propositions berardi calls propositions functional types 
functional types ones obtained putting arrows parametric data types called logical types class higher order predicate types functional types 
propositions functional types propositions obtained basic propositions usual logical connectives oe logical type 
basic propositions propositions obtained applying inductive predicate right number terms right type class quite big 
inductive predicates minimal subsets closed fixed monotone constructors defined higher order predicate logic higher order quantification predicates 
example nat theta nat nat theta list examples inductive predicates 
berardi defined settheoretic terms translated cc 
berardi denote translation explicitly ambiguities 
main result berardi saying proposition set pos gamma cc term gamma satisfied model provable set theory 
model interpretation propositions cc partial equivalence relations set untyped lambda terms 
model construction berardi go state important facts parametric data type interpretation empty means ind satisfied 
set propositions pos consists propositions calculus constructions ch 
functional types built basic propositions oe parametric data type restriction bound may occur positive place 
nat example bound appears nat 
obvious examples result applies 
berardi shows statement girard normalization theorem saying typable terms system strongly normalizable pos 
form pit pia oft oe nat pit pim nat oe type pseudoterms type types ty parametric data types oft theta ty theta theta nat inductive predicates oft type reduces steps 
see restrictions form propositions serious specification usually form pix pos 
result general restrictions shape gamma gamma may contain assumptions expressed terms long assumptions satisfied valid 
interesting see result discussed rephrased syntactically extending pred 
inductive data types describing formulas types embedding extended higher order predicate logic cc 
extension pred 
defined adding scheme inductive types allowing kind fixed point construction positive type constructors extending pred 
polymorphic domains 
know define inductive data types polymorphic lambda calculus formulas types embedding pred 
cc immediately extends pred 
polymorphic domains want say bit possibility 
pred 
pure type system 
prop set type type prop type set type set set type set type set set type type type prop prop set prop type prop pred 
type set higher order predicate logic built polymorphic lambda calculus stead simple theory types 
note similarity definition 
view description parametric data types section natural leave rule type set system eliminate things piff set ff ff set 
option want leave open 
sec 
formulas data types cc formulas types embedding pred 
cc induced formulas types embedding pred 
cc definition pts morphism 
set type type immediately shows pred 
consistent 
fact mapping shows extensions pred 
rules form fprop set type type consistent 
embedding complete counterexamples pred 
job 
see proof proposition restrict propositions set pos may able prove ind ind dn ind nat nat sz cc proof pred 
ind ind dn ind nat nat sz parametric data types occur 
omit mapping reasons readability 
view proof original result berardi strong feeling adapted completeness formulas types embedding pred 
cc holds 
general original result allow assumptions just stating parametricity data types 
matter interesting investigations may give syntactical handle propositions data types provable cc 
section just system pred open question pred 
conservative pred 
reasons believing pred conservative pred apply pred 
possible non conservativity result affect system pred 
restricted proving kind propositions parametric data types discussed 
calculus constructions ch 
chapter strong normalization fij calculus constructions 
chapter prove strong normalization cc fij conversion rule 
shall denote system cc fij distinguish cc fi original calculus constructions fi conversion 
similarly 
fij 
fij main problems proving sn fij cc fij know term cc fij closed reduction 
know sr holds cc fij lemma doesn immediately imply sr cc fij thing prove sn fij cc fij immediately implies sn fij cc fij set terms subset set terms 
choose prove sr cc fij sn fij cc fij directly 
hand natural hand chapter simple criterion sr hold applies cc fij 
meta theory cc fij conversion section studied meta theory general pure type systems seen properties prove pts fi notions pts fij pts fij fact reasons introducing pts fij place couldn prove sr pts fij introduced pts fij properties unable prove pts fij pts fij classification lemma 
lemma important defining mappings set typable terms easy way shall show lemma hold cc fij syntax sorted variables described definition 
sn fij cc ch 


system cc fij expected properties 

term cc fij fij 
terms form piu cc fij proof 

fij fi key lemma 
situation gamma implies stripping lemma key lemma axiom axioms cc fij easily seen 
suppose piu term cc fij 
gamma piu gamma gamma sort case 
theta 
lemma 
cc fij satisfies fij preservation sorts definition 
terms cc fij gamma gamma contexts cc fij gamma gamma fij proof 
induction structure show term gamma gamma fij gamma done uniqueness types lemma term time type kind 
distinguish cases possible structure ffl gamma piu possible 
ffl type stripping lemma 
ffl piu fi piu things fij gamma 
done induction hypothesis 
ffl 
fij gamma done 
theta 
corollary classification cc fij 
cc fij kind type constr obj sec 
proof sn fij cc proof 
note just proof classification lemma suffices prove statements 
gamma gamma gamma gamma follow immediately lemma uniqueness types 
theta 
corollary 
cc fij satisfies strengthening sr proof 
chapter shown pts fij satisfies fij preservation sorts satisfies strengthening lemma sr corollary 
theta 
proof sn fij cc turn proof strong normalization fij reduction calculus constructions fij conversion general property normalization versions cc want implies sn fi reduction cc fi conversion 
proof give generalisation proof sn fi cc fi geuvers nederhof 
giving proof want see sn fij cc fij follow immediately sn fi cc fi postponement reduction argument 
strongly believe easy combinatorial argument deriving haven able find 
postponement works shown paragraph 
get sn fi cc fi implies sn fij cc fi problem set typable terms cc fij larger set typable terms cc fi example term 
xz typed cc fij cc fi fv 
says prove strong normalization fi reduction cc fij 
proposition 
cc fij sn fi cc fij sn fij proof 
proof follows immediately theorem says sn fi sn fij set pseudoterms closed fi reduction 
note term cc fij closed fi 
sr fi arbitrary ptss second corollary term cc fij term cc fij done 
theta proposition says sufficient study fi reduction prove sn fij cc fij proof sn fi cc fij exactly 
sn fij cc ch 

obtaining sn fij cc sn fij 
define reduction preserving mapping cc fij 
fij mapping geuvers nederhof defined mapping cc fi 
fi prove strong normalization property cc fi problem extension cc fij don meta theory cc fij geuvers nederhof cc fi case 
verify argument go 
original intuition mapping due harper define fij reduction preserving mapping lf prove strong normalization lf 
map gamma seen higher order version map defined harper things get quite bit complicated 
possible restrict map gamma term derive result sn fij sn fij map gamma doesn uniformly terms cc fij define gamma gamma gamma cc fij gamma 
fij show gamma really maps terms cc fij terms 
fij define map types kinds sorts cc types kinds sorts 
fij gamma cc fij gamma 
fij order get feeling mappings gamma give heuristics geuvers nederhof 
idea mappings harper replace redexes type dependency redexes 
follow idea example type gamma cc fij 
gamma cc fij gamma cc fij gamma erase type dependencies gamma 
fij 
gamma 
fij gamma 
fij 
sound 
solved lf 

fixed type variable 
redex obtained type dependency say type constructor object replaced fresh variable 
term typable system type dependency possible redexes preserved abstraction application 
sec 
proof sn fij cc add polymorphism situation gets complicated 
example gamma cc fij piff ff ff gamma cc fij oe gamma cc fij oe oe oe gamma 
fij piff ff ff gamma 
fij oe gamma 
fij oe oe oe sound 
means piff ff ff ff ff oe oe doesn 
application sound 
option piff ff ff piff ff ff oe oe doesn right possible reductions oe preserved 
solution take piff ff ff piff ff ff oe oe oe implies higher order abstraction different interpretation 
example interpretation piff ff ff applied arguments 
solution case ff ff take ff ff general picture course quite bit complicated kinds structure objects 
fij define mapping ae provides type image gamma cc fij gamma 
fij ae type constructor kind 
mapping ae fact just takes usually called order kind terms underlying 
fij kind 
definition follows 

definition 
map ae kind cc fij kind fij defined 
ae 
ae 
ae piff ae ae kind 
ae pix ae type 
note case distinction definition cc fij mapping ae removes type dependencies variables easy properties 
fact typable terms fij kind proved lemma 
fact 
kinds cc fij variable term 
ae ae ae 
fij ae ae 
sn fij cc ch 
want devote attention interpretation types kinds gamma giving definition example gamma cc fij gamma ff cc fij want gamma 
fij pix 
intended interpretation fixed type variable 
leaves possibility take take pix term type term type 
required fixed terms type kind 
fij type 
fij inhabited closed term necessary extend syntax possibility having closed constants types 
complicated system substitute term constant closed type 
turns stay away kind 
solution fixed context 
piff ff 
fij define fixed term type kind give definition reflecting intuitions preservation reductions 
definition 
map kind cc fij constr cc fij term fij inductively defined 
ff ff piff piff ae kind pix pix type ff ff ae kind type mn constructor mn object 
definition cases correct classification cc fij corollary 
range subset term fij stated lemma 
mapping deletes object variables type dependency compatible substitution reduction stated fact 
proofs induction structure terms stripping lemma fact 
fact 
kinds cc fij object variable ff constructor variable constructor object cc fij 
contain free object variables 
ff ff 
gamma 
fi gamma 
fi 
gamma 
gamma 

sec 
proof sn fij cc mapping define mapping contexts cc fij contexts 
fij mapping called defined straightforwardly applying types kinds context 
reason constructor variables split constructor variable object variable replacing ff context ff ae ff ff fresh object variable connected ff 
splitting done pi abstraction constructor variable replaced abstractions 
splitting precise assume injection var 
var var var countable consisting object variables derivations cc fij object variable ff fresh 
notationally don injection write ff ff 
variable ff var fresh variable ff 
definition 
mapping declarations contexts defined follows 

type cc fij object variable 
kind cc fij ff constructor variable ff ff ae ff 
gamma context cc fij gamma context serves image canonical inhabitant canonical kinds 
fij built 
fact left closed 
fij type 
context necessary canonical inhabitant type 
essential construction reduction preserving mapping gamma 

definition 
canonical inhabitants types kinds gamma denoted type kind defined follows 
ii ff kind iii da type 
sn fij cc ch 
note kinds types variables terms note inhabitant independent context typed depends specific choice variables constants relative exposition 
showing soundness gamma cc fij gamma 
fij ae object treat examples application mapping cc fij term 

examples 
examples meant show connection computationally mohring berardi mapping cc fi comes constructors 

piff ff ff ff piff ff ff 
piff ff ff ff 
piff ff ff 
ff ff ff 
ff 
lemma 
term cc fij object gamma cc fij gamma 
fij ae proof 
proof geuvers nederhof cc fi induction derivation 
treat case rule app case rule 
proof omit subscript turnstile clear context working cc fij 
fij 
app say pq gamma piu gamma 
pq constructor distinguish subcases constructor object 
constructor find induction hypothesis gamma ae piu ae ae gamma ae 
app find gamma ae done pq ae ae 
object find induction hypothesis gamma ae piu ae 
done ae ae 
say gamma gamma piu 
distinguish subcases type kind 
type ae piu ae induction hypothesis gamma ae 
substituting find gamma ae 
kind ae ae piu ae ae sec 
proof sn fij cc induction hypothesis gamma ae ae 
substituting find gamma ae ae 
gamma ae ae gamma ae ae ae 
theta 
definition 
map gamma term cc fij term fij defined inductively var ff ff ff var pix type piff ae ff ff kind type ff ff ae ff kind mn object mn constructor assumed fresh object variable 
definition cases classification cc fij corollary 
difficult verify mapping preserves fi reductions stated 
image mapping gamma subset term fij stated lemma 
proof lemma really add proof strong normalization fi cc fi apart quite non trivial verification lot meta theoretical facts cc fij course done chapter extra verify types cc fij fij fij 
cc fi problem easily settled church rosser property lack 
turns easy just redo reduction expansion path get fij removes abstractions redexes 
constructors fij equal objects ff ff fij objects domain may effect fij conversion 
example equality bis really established different manner equality 
ff 
ffx fij ff 
fi fffi ff ffx ff ff fij ff fi 
fffi ff fi 
fffi case images fij equal imagine tricks 
tricks shown lemma 
proof lemma convenient modify mapping sn fij cc ch 
bit mapping erased terms erased terms 
mean erasure gamma removes domains defined definition 
define induction structure terms distinguishing cases heart specific subterms 
notion heart term defined definition 

definition 
consider set obtained set kind cc fij constr cc fij applying erasure mapping gamma closing fij set define mapping induction structure terms follows 
ff ff piff piff ae ff var pix pix var ff ff ff var var mn var mn var definition justified lemma 

fact 
kind cc fij constr cc fij jaj 
lemma 
terms cc fij objects fij fij proof 
immediately 
fij jaj fij jbj jaj fij jbj fij fij standard property gammaj third justified fact just stated step standard property gammaj 
see corollary 
leaves second step 
suppose jaj fij jbj say jaj fij fij jbj 
copy reduction steps jaj jbj image 
precise proof fact verifying properties hold object variable var ff constructor variable ff var 
contain free object variables 
ff ff sec 
proof sn fij cc 
gamma 
fi gamma 
fi 
gamma 
gamma 

theta 
lemma 
gamma cc fij gamma 
fij proof 
induction structure terms geuvers nederhof lemma stripping lemma 
treat cases pi abstraction abstraction 
pi abstr 
say piu note 
induction hypothesis obtain gamma gamma 
distinguish cases type kind 
type gamma gamma substituting applying conclude gamma done 
kind gamma gamma ae substituting ae applying ae conclude gamma ae done 
abstr 
say note stripping lemma fij piu gamma induction hypothesis obtain gamma gamma 
distinguish cases type kind 
type gamma gamma 
types abstraction obtain gamma piu 
easily conclude gamma piu 
done piu fij follows lemma piu fij apply conversion rule obtain proved 
kind gamma gamma ae 
type ae kind abstractions obtain gamma ae piu ae 
easily conclude gamma ae piu ae 
done piu fij follows lemma piu fij 
applic 
say pq gamma piu gamma fij 
induction hypothesis find gamma piu sn fij cc ch 
gamma 
distinguish subcases object constructor 
object type piu piu 
conclude gamma done fact fij lemma 
constructor kind piu piu ae 
conclude gamma done fact fij lemma 
theta 
lemma 
term cc fij var ff var object constructor 

ff ff 
proof 
induction structure fact term ae contain free variables term contain free object variables 
needs easy substitution properties canonical inhabitants types kinds ae ae ff ff ff ae ff ff ae ff theta 
theorem 
term cc fij gamma 
fij fij proof 
induction structure interesting cases reduced fi redex handled distinguishing subcases domain lambda abstraction 
treat cases domain kind 
cases domain type similar easier 
ffl ff kind 
ff ae ff fi ff ff ff sec 
proof sn fij cc ffl ff ff kind 
ff ae ff ffx ff fij theta 
theorem 
fij sn fij cc fij sn fij proof 
infinite fij reduction sequence cc fij yields infinite fij reduction sequence 
fij mapping gamma 
theta bit careful proof positive formulation strong normalization term upperbound length reduction sequences starting show upperbound length fij reductions starting compute upperbound length fij reductions starting 
strong normalization fij reduction 
proof 
fij sn fij done proving fi reduction strongly normalizing combination fi 
reduction strongly normalizing 
show fi reduction strongly normalizing erased terms erasure typed erasure defined different defined totally syntactical fi reduction strongly normalizing 
way avoid need define called de typed sets done example girard 
exposition clearly points proof essentially complex proof theoretical terms 
idea proving strong normalization reducing problem set underlying type free terms applied polymorphic lambda calculus mitchell see scedrov 

proposition 
fij sn fij proof 
consider constructors infinite fij reduction term 
fij due infinite fij reduction subterm constructor 
proof defining fij reduction preserving mapping gamma constructors 
fij objects constructor object defined inductively follows 
sn fij cc ch 
fixed type variable declared context 
reduction preserving mapping gamma constructors ff ff oe oe piff oe oe ff ff ff kind 
fij fixed object type defined inductively fixed variable type context defining gamma context containing declarations constructor variables gamma 
fij gamma extension gamma contexts straightforward 
theta 
lemma 
term fij objects gamma 
fij gamma ii gamma 
fij iii gamma 
fij gamma 
fij jm jm proof 
way number certain form increase reduction step particular form occurs gamma 
free 
look case lemma fi redex form premise check 

ff gamma 
ff constructor contain objects subexpressions certainly contains number reduced 

ff gamma 
fi ff constructor contains number term remains 

definition erasure gammaj removes type information 
fi reduction step inside type object jm jm fi reduction step inside form ff gamma 
ff applying gammaj jn second 
theta sec 
proof sn fij cc 
lemma 
fij sn fij 
proof 
suppose infinite reduction sequence 
gamma 
fij 
gamma 
fij 
gamma 
fij 
fij proposition know objects infinite reduction tail gamma 
fij gamma 
fij gamma 
fij infinite fij 
reduction sequence contains infinitely fij contractions 
lemma possible fij contraction reduces number fij contraction change number infinite fij 
reduction 
fij theta 
proposition 
obj fij sn jm sn proof 
object sn jm holds 
suppose infinite reduction sequence gamma 
fij gamma 
fij gamma 
fij 
fij objects 
fij lemma finitely fij 
contractions performed sequence contains infinitely fij contractions 
apply gammaj obtain infinite fij reduction sequence starting jm lemma 
contradicts sn jm infinite fij reduction sequence starting theta proposition telling check set erasures objects 
fij satisfies sn fij order prove 
fij sn fij done extending known method computability predicates higher order case 
method seen building model 
fij inside untyped lambda calculus types sets strongly normalizing terms interpretation modulo valuation ae assigns untyped terms free variables term type oe untyped term set represented oe 
strong normalization property follows fact take identity valuation ae case interpretation jm strongly normalizing construction model 
sn ae set untyped lambda terms strongly normalizing fij reduction 
reduction fact reduction strongly normalizing set terms strongly normalizing fi reduction 
sn fij cc ch 

definition 
set untyped lambda terms saturated 
ae sn 
sn var 
sn 
note sn saturated saturated sets nonempty 
types 
fij interpreted saturated sets 
requires closure properties set saturated sets proved lemma 
kinds 
fij interpreted set theoretic function spaces kind interpreted set saturated sets 
recall kind fij 
definition 
kind fij set computability predicates cp defined inductively follows 
cp 
fx ae cp ff cp cp interpretation kind intended model cp 

lemma 
set saturated sets closed arbitary intersections function spaces 

set saturated saturated 
saturated fm mn saturated proof 
closure arbitrary intersections easy prove 
closure function spaces saturated sets take lemma 
easy see sn 
variable sn qn sn saturated set 
sn know qn 
qn theta may wonder need saturated sets specific class subsets sn just interpret types set sn 
breaks fact sn sn sn 
example xx sn sn 
sec 
proof sn fij cc 
definition 
gamma context 
fij constructor valuation gamma notation gamma map var cp ff gamma ff cp 
definition 
gamma context 
fij constructor valuation gamma interpretation function gamma gamma gamma constr fij 
cp defined inductively follows 
ff gamma ff gamma gamma gamma ff gamma cp gamma ff oe gamma oe gamma gamma piff oe gamma cp oe gamma ff situations gamma clear context mentioned explicitly 
definition justified stripping lemma lemma states interpretations constructors elements right computability predicate 

lemma 
gamma context 
fij term fij gamma gamma cp proof 
easy induction structure theta 
lemma 
gamma context 
fij gamma constr fij ff var gamma ff ff ii fij proof 
easy induction structure second sufficient prove gamma 
fij easily done induction structure sufficient follows fact church rosser property fij reduction subject reduction fij reduction hold 
fij easy separation contexts 
see proposition 
discussion ends chapter pointed prove cr fij system 
sr 
fij consequence corollary easier ways obtain result 
theta sn fij cc ch 

definition 
gamma context 
fij gamma object valuation gamma respect notation ae gamma map ae var oe gamma ae oe 
definition 
gamma context 
fij ae valuations ae gamma interpretation function gamma gamma ae gamma obj fij 
defined inductively follows 
gamma ae ae gamma ae gamma ae gamma ae object gamma ae gamma ae constructor oe gamma ae gamma ae oe type ff gamma ae gamma ae kind situations gamma clear context mentioned explicitly 
interpretation objects 
fij valuation constructor variables 
previous definition mentioning letting ae arbitrary mapping var put restriction ae hand natural restriction interpretation function hand needed theorem proving 
fact interpretation objects depend interpretation types expressed fact 

fact 
object ae valuation definition vector free variables ae jm ae ae vector obtained consecutively applying ae 
definition 
gamma context object oe type 
fij gamma models type oe notation gamma oe gamma oe ae ae gamma ae oe 
theorem 
gamma context object oe type 
fij gamma oe gamma oe sec 
proof sn fij cc proof 
induction structure prove ae gamma ae oe ae valuations ae gamma 
ffl var gamma fij oe 
ae ae oe done 
ffl type 
gamma oe fij 
ih ae ae ae ae oe ffl ff kind 
gamma ff oe fij piff ih ae ff cp ff ae ae cp ff oe ffl pq object 
gamma gamma fij oe 
ih ae ae ae ae ae oe ffl pq constructor 
gamma piff gamma ff fij oe 
ih ae ae ae ae ae oe induction hypothesis ae cp ff know cp case ae ae ff theta 
theorem 
obj fij sn jm proof 
object 
fij say gamma oe context type gamma oe 
gamma oe previous theorem 
define canonical elements sets cp follows 
sn cp constructor valuation gamma take ff ff gamma ff arbitrary object valuation gamma respect take ae ae ae gamma ae oe implies jm strongly normalising ae jm oe sn 
theta sn fij cc ch 
chapter discussion thesis want remarks points deserve extra attention 
try situation proof sn fij con fij cc fij clear 
middle general lemmas propositions may bit obscure exactly required proofs 
compare pts syntax different formalization pure type systems semantical nature 

confluence normalization 

wants study confluence fij reduction pure type system looking property con fij gamma fij fij con fij consequence cr fij typed terms 
fij reduction expansion path contain terms typable 
fij means equal pseudoterms 
non typable terms cr fij typed terms apply 
proof con fij cc fij thesis done steps 

prove key lemma 

prove sr fi lemma 
relatively easy induction derivations key lemma 

prove sr follows quite easily fact cc fij satisfies fij preservation sorts 
see definition lemma corollary 
prove 
fij con fij easy fact contexts 
fij separated 
see paragraph proof con fij calculus containing 
fij discussion ch 

prove 
fij sn fij hard proof paragraph done showing sufficient prove sn fij erased terms 
proof uses 
fij con fij 
prove cc fij sn fij hard 
done defining reduction preserving mapping cc fij 
fij proof uses 
fij sn fij 
prove cc fij con fij hard requires cc fij wn fij uses cc fij sn fij proof chapter general case 
cc fij suffices prove lemmas proposition theorem 
obviously fourth fifth sixth item compressed prove cc fij sn fij proof fact thesis lines sketched 
issues immediately come 
prove strong normalization need weak normalization usually property just called normalization proof cr fij situations weak normalization suffices 
example prove consistency context 
raises conjecture 

conjecture 
pure type systems wn fi sn fi thing know strong normalization system conv fi implies strong normalization system conv fij 
problem extend conversion rule welltyped terms 
see discussion section intuition says extension affect normalization conjecture 

conjecture 
pure type systems conv fi sn fi conv fij sn fi open problem con fij holds pure type systems 
strongly believe raise conjecture 
motivated proposition 
conjecture 
pure type systems gamma gamma fij fij sec 
semantical version systems questions counter example showing property hold probably interesting proof 
soon proved easy proofs 
reasons believe conjecture false 
shown werner confluence fij reduction conflicts fixed point combinator 
state precisely system conv fij rule 
fixed point combinator term piff ff ff ff oef fij oef oe oe oe 

fact 
werner fixed point combinator con fij cr fij proof general applies ptss sort rule sort rule axiom 
corollary fact con fij 
proof fact sketched section 
corollary 
system fixed point combinator 
known exists fixed point combinator 
conviction con fij holds led believe fixed point combinator 
called looping combinator family combinators type piff ff ff ff oef fi oef 
see example coquand herbelin 

semantical version systems fact confluence property conjecture justifies pure type systems conv fij place 
wants give semantics pure type system wants assign meaning typed terms 
pseudoterms just introduced meta theory easier closely related untyped lambda calculus 
just interested syntax agree point view typed terms meaning 
point view implies typed terms equal path passes non typable terms terms really considered equal 
pseudoterms semantics semantical presentation pure type systems contain conversion rule form discussion ch 

side condition conversion rule stated equality judgement form gamma stead equality condition set pseudoterms 
equality judgement axiomatised way gamma holds reduction expansion path passes set typed terms type gamma 
obviously intended meaning equality conversion rule pure type system gamma type fij case equality established path passes set gamma types 
consider fij equality clear intended meaning actual meaning 
considers fi equality obviously case due cr fi pseudoterms 

definition 
semantical version pure type system rules 
typing rules sort weak var pi app ordinary ptss 
denote semantical version write rules 
conversion rule conv fij gamma gamma gamma judgement gamma generated fi gamma pix gamma gamma gamma pix gamma pix axiom gamma gamma sym gamma gamma trans gamma gamma gamma sec 
semantical version systems pi eq gamma gamma gamma pix pix eq gamma gamma gamma pix gamma pix app eq gamma pix gamma gamma mn conv eq gamma gamma gamma able show equivalence version syntax pure type systems semantical version sense pts fij semantical version holds 
gamma gamma fij gamma method proving showing con fij holds expressed conjecture gamma gamma fij fij focus possible proof equivalence see con fij essential 
implication right left relatively straightforward showing gamma fij pseudoterms gamma obvious rules holds 
second induction derivation gamma implication left right interesting 
implies statement terms typable type context equal fij reduction expansion path typed terms 
impossible imagine prove implication having proved 
obviously way prove proving con fij stresses importance final open problem raised 
discussion ch 
bibliography avron avron honsell mason typed lambda calculus implement formal systems machine report lfcs uk 
barendregt barendregt lambda calculus syntax semantics revised edition 
studies logic foundations mathematics north holland 
barendregt barendregt typed lambda calculi 
handbook logic computer science eds 
oxford univ press 
barendsen barendsen representation logic data types recursive functions typed lambda calculi master thesis university nijmegen netherlands march 
barendsen geuvers barendsen geuvers conservative order predicate logic manuscript faculty mathematics computer science university nijmegen netherlands van benthem jutting van benthem jutting checking landau grundlagen automath system ph thesis eindhoven university technology netherlands 
van benthem jutting van benthem jutting typing pure type systems 
appear information computation 
van benthem jutting van benthem jutting mckinna pollack checking algorithms pure type systems manuscript 
berardi berardi mathematical analysis coquand huet calculus constructions systems barendregt cube 
dept computer science carnegie mellon university dipartimento matematica universita di torino italy 
berardi berardi talk meeting typed lambda calculus edinburgh september 
