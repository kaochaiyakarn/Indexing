randomized dimensional binary search trees duch vladimir castro mart september introduces randomized dimensional binary search trees randomized kd trees variant dimensional binary trees 
data structure allows efficient maintenance multidimensional records sequence insertions deletions fully dynamic 
show types associative queries efficiently supported randomized kd trees 
particular randomized kd tree records answers exact match queries expected log time 
partial match queries answered expected gammaf time attributes specified real valued function 
nearest neighbor queries answered line expected log time 
randomized algorithms guarantee expected time bounds hold irrespective order number insertions deletions 
keywords randomized algorithms multidimensional data structures kd trees associative queries multidimensional dictionaries 
applications computer science geographical information systems gis databases computer graphics require dynamic maintenance set file multidimensional records 
multidimensional record contains ordered tuple values constitute dimensional multidimensional key associated information 
entries dimensional key referred attributes coordinates 
file consisting multidimensional records support dictionary operations insertions new items deletions exact searches associative queries 
associative query specifies certain condition satisfied attributes multidimensional keys requires retrieval records file keys satisfying condition 
examples associative queries intersection queries records lie inside region search space 
nearest neighbor queries record closest query point 
supported esprit ltr project alcom contract cicyt tic ce pb 
departament de inform universitat polit de catalunya barcelona spain 
mail lsi upc es department computer science software engineering university newcastle callaghan australia 
mail cs newcastle edu au exist data structures support associative queries 
data structures offer different tradeoffs type associative queries efficient 
space requirements worst case expected case performance range operations design suitable dynamic maintenance file 
multidimensional binary search trees known dimensional search trees kd trees introduced bentley support conventional dictionary operations frequent associative queries relatively simple algorithms offering reasonable compromises time space requirements 
usual way analyze behavior data structures kd trees means worst case analysis 
situations input sequence forces worstcase performance 
contrast expected case analysis assumes probability distribution input sequence estimates expected time algorithms distribution 
expected case analysis operations kd trees assumption kd tree built successive insertions records dimensional keys independently drawn continuous distribution 
shown equivalent assumption keys uniformly distributed random tuples say kd tree built way randomly built kd tree brevity kd tree random 
random kd trees size expected time insertion deletion exact search record log 
different kinds associative queries supported data structure 
efficient expected case performance operations holds assumption kd tree random 
unfortunately assumption hold 
instance fails keys inserted sorted nearly sorted attributes 
alternation deletions insertions random kd tree destroys randomness tree sense resulting tree longer random kd tree 
happens item file equally deleted 
updates insertions deletions tree may need rebuilt preserve efficient expected performance 
possibility overcome problem poor performance optimized kd trees assuming file records priori 
kd trees perfectly balanced logarithmic performance dictionary operations guaranteed 
insertions deletions performed reorganization tree required 
alternative suitable updates occur rarely records file known advance conditions met practical situations 
approach introduce explicit constraints balancing trees kd trees improved local dynamically balanced kd trees divided kd trees 
update operations check predefined balance criterion remains true insertion deletion element 
balance constraint violated complex reorganization tree performed 
methods yield theoretically efficient searches exact search associative queries updates cases provide worst case guarantees methods sacrifice simplicity standard kd tree update algorithms impractical highly dynamic environments 
third approach consists randomization produce simple robust algorithms sense randomization guarantees efficient expected performance longer depends assumptions input distribution 
randomization successfully applied design dictionaries aragon seidel pugh mart 
approach aragon seidel applied multidimensional data structures mulmuley randomization applied data structures field computational geometry voronoi diagrams instance 
mulmuley support dictionary operations associative queries 
draw ideas mart design randomized kd trees trees built randomized update algorithms guaranteed produce random trees independently order previous insertions deletions actual data 
main idea allow insertions deletions regions kd trees leaves way resulting tree random tree 
consequence expected case performance operation holds irrespective order update operations depends random choices randomized algorithms 
generalization approach aragon seidel case kd trees possible yielding similar algorithms ones similar performances 
randomized dimensional binary search trees randomized kd trees short new type dimensional binary trees support sequence update operations insertions deletions preserving randomness tree demand preprocessing efficiently support exact match associative queries 
brief review kd trees section 
order introduce randomized kd trees section extension kd trees call relaxed kd trees relaxed kd trees provide necessary flexibility attributes examined path tree restricted usual cyclic ordering 
analyze section expected performance partial match nearest neighbor queries random relaxed kd trees 
section define randomized update operations relaxed kd trees prove operations produce random relaxed kd trees 
dimensional search trees multidimensional binary search trees dimensional search trees kd trees generalization binary search trees handle case multidimensional records 
sake simplicity follows identify multidimensional record corresponding multidimensional key refers value th attribute key belongs totally ordered domain element theta theta delta delta delta theta dk multidimensional key may viewed point dimensional space th attribute viewed th coordinate point 
loss generality assume hypercube 
definition kd tree set dimensional records binary tree 
node contains dimensional record associated discriminant kg 

node key discriminant invariant true record left subtree key satisfies record right subtree key satisfies 
root node depth discriminant 
nodes depth discriminant mod 
note definition take account case equality attributes 
usual way handle possibility means collision list 
case node contains addition record associated discriminant list records th attribute equal implementations kd trees 
suggested definition corresponds homogeneous kd trees possible define non homogeneous kd trees 
internal nodes non homogeneous kd trees contain attribute value pointers left right subtrees records stored external nodes known buckets 
observe cases required explicitly store field containing discriminant node implicitly condition definition 
deal homogeneous kd trees minor modifications apply non homogeneous kd trees 
note kd tree binary search tree 
say node contains key discriminant say key compatible tree th attribute different th attribute key assume insertions compatible keys occur kd trees key inserted different key tree see discussion collision lists 
kd tree file incrementally built successive insertions initially empty kd tree follows 
key put single node empty subtrees 
attribute second key compared attribute key root smaller second key recursively inserted empty left subtree recursively inserted empty right subtree 
attribute third key compared attribute key root recursively inserted left right subtree 
subtree empty contained second key compare respective second attributes second third keys proceed 
general inserting key compare key inserted key root subtree level compare mod mod recursively continue insertion left right subtree leaf empty subtree recall assume key compatible tree inserted 
depict tree results insertion keys initially empty tree order listed left part 
shows partition induced tree 
clear points inserted different order yield substantially different tree 
standard model probabilistic analysis kd trees randomly built kd tree random kd tree size built inserting points independently drawn continuous probability distribution defined equivalent assume ux gamma gamma gamma gamma gamma gamma phi phi phi phi tree corresponding partition search space probability th insertion fails leaf random kd tree size leaves 
expected cost single insertion random kd tree log time expected cost building tree log 
cost deleting root random kd tree nodes gamma 
average deletions expected cost log expected depth node deleted logarithmic subtree beneath expected size log 
exact match queries kd tree obviously operate path tree exactly way inserting key find report success reach leaf reporting failure 
require expected log time 
pointed application required exact match queries kd trees treating attributes record lexicographical order unidimensional data structures usually yield better performance 
shown flajolet puech partial match queries efficiently supported random kd trees 
expected time operation random kd trees gamma 
shown friedman bentley finkel nearest neighbor queries supported log time optimized kd trees 
simplified model assumptions analysis simplified model assumptions turns nearest neighbor queries answered expected time log random kd trees 
furthermore theoretical somewhat approximate results strongly supported experiments carried 
relaxed dimensional search trees observe cyclic restriction kd trees condition definition forces update operations laborious located leaves tree reorganization tree required order preserve cyclic assignment discriminants 
shall show quest randomized kd trees require flexibility performing operations places kd trees leaves major reorganization 
purpose mind introduce relaxed dimensional search trees called relaxed kd trees simply kd trees 
kd trees condition definition dropped node explicitly stores discriminant 
sequence discriminants path root leaf arbitrary 
definition kd tree set dimensional records binary tree 
node contains dimensional record associated discriminant kg 

node key discriminant invariant true record right subtree key satisfies record left subtree key satisfies notice tree binary search tree 
kd trees assumed attribute domains continuous sets 
shows relaxed tree results insertion keys initially empty tree 
node contains corresponding key discriminant pair 
shows partition induced relaxed tree 
clear different discriminants chosen keys inserted different order relaxed tree substantially different 
say kd tree size randomly built random built insertions keys independently drawn continuous distribution example uniformly discriminants uniformly independently drawn kg 
random kd trees assumption distribution input implies 
distinct configurations input discriminant sequences equally observe random kd trees assumption 
distinct configurations input sequence 
particular random kd tree nk possible pairs key discriminant equally appear root root fixed left right subtrees independent random kd trees 
obtain distribution shapes random kd trees shapes random binary search trees shapes random kd trees 
distribution random kd trees size nicely characterized terms probability left subtree random kd tree size size independently definition random kd tree 
jt empty 
jt left right subtrees independent random kd trees discriminant root tg nk random kd trees satisfy similar spirit complex recursive characterization discriminants successive levels follow cyclic sequence shall see recursive definition random kd trees analysis partial match associative queries kd trees easier standard kd trees 
parameters internal external path length see definitions depend discriminants expected value random binary search trees random kd trees 
theorem expected internal external path length random kd tree log 
random kd trees perform random kd trees exact match queries insertions 
operations explore path theorem logarithmic length average 
ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae ae ae gamma gamma ux relaxed tree corresponding partition search space 
associative retrieval algorithms associative queries kd trees essentially kd trees expected case performances necessarily instance partial match queries average complexity kd trees kd trees random kd trees path tree known cyclic pattern discriminants random sequence discriminants 
follows analyze average cost performing partial match nearest neighbor queries kd trees 
partial match queries partial match query query attributes key specified 
retrieval consists finding records specified key attributes coincide query 
formally query value specified unspecified partial match algorithm returns subset records file attributes coincide specified attributes returns partial match algorithm kd tree explores tree way 
node examines corresponding discriminant 
discriminant specified query happens probability algorithm recursively follows appropriate subtree depending result comparison attribute key current node attribute query 
probability gamma algorithm recursively follows subtrees 
theorem gives expected performance partial match query random kd tree size theorem expected cost measured number comparisons partial match query attributes specified random kd tree size fin ffi ffi ffi gamma delta gamma fi gamma ffi gamma ffi gamma ffi delta gamma gamma gamma function 
proof 
random kd tree size left subtree right subtree average search cost partial match 
probability gammas discriminant root corresponds unspecified attribute query 
case search visits root continues discriminant root corresponds specified attribute visiting root partial match retrieval continues appropriate subtree 
continue probability size complementary probability 
average search cost satisfies relation gamma gamma assumed random find gamma gamma gamma gamma gamma gamma gamma gamma symmetry obtain recurrence relation gamma gamma gamma continuous master theorem easy derive asymptotic estimate theta ffi ffi gamma gamma 
result obtained standard techniques generating function singularity analysis 
ordinary generating function sequence fc 
find useful define generating function zc 
multiplying equation gives gamma gamma gamma recurrence translates integral equation gamma gamma gamma gamma gamma gamma dt gamma dt derivatives expressing terms gives second order non homogeneous differential equation gamma gamma gamma gamma gamma gamma gamma gamma gamma homogeneous differential equation associated equation gamma divisors 
single singularity integer function single pole 
dominant contribution local expansion form fi gamma ff ff smallest root equation ff ff gamma gamma results ff gamma gamma delta delta gamma 
standard singularity analysis shows fin ffi ffi gammaff gamma constant fi 
expanding ffi taylor series obtain estimate ffi gamma statement theorem 
approach sketched analysis partial match explored 
shown exact solution equation gamma fi fi fi fi gamma ff gamma gamma fi fi fi hypergeometric function ff ff 
study asymptotic behavior get precise order magnitude coefficient main order term magnitude lower order terms 
second term contribution hypergeometric function analytic 
fi fi fi fi gamma gamma gammaff gamma ffi gamma ffi gamma ffi interesting point theorem valid provides meaningful information limiting cases extent 
attribute specified ffi fi 
hand exact match attributes specified case know log 
ffi fi best approximate way say formula fin ffi grows slower function type ffl real positive ffl 
figures plot respectively value exponent ffi average cost partial match queries random kd trees random kd trees excess corresponding exponents respect gamma theta gammas best known upper bound partial match queries 
plot value fi function ratio ae observe expected cost partial match queries random kd trees slightly higher flajolet puech random kd trees 
possible show difference exponent costs extreme values difference smaller 
notice constant fi main order term expected cost partial match queries kd trees independent pattern specified unspecified attributes standard kd trees constant dependent particular pattern query 
nearest neighbor queries request closest record file query record determined distance function usually called dissimilarity function called nearest neighbor query 
generally multidimensional record distance kd tree records nearest neighbor query requires finding points closest order words find points gamma records nearest neighbor query case 
ae 
gamma delta delta gamma gamma ae gamma ae ae standard kd trees gamma gamma gamma gamma ae gamma relaxed kd trees value exponent average cost partial match standard relaxed kd trees 
ae 
ae standard kd trees gamma gamma gamma gamma ae gamma ae relaxed kd trees excess respect gamma ae exponent average cost partial match ae 
fi gamma ffi gammaae ffi gamma ffi value constant fi average cost partial match relaxed kd trees 
nearest neighbor search algorithm kd tree begins calculating distance query root tree giving current nearest neighbor 
search continues left right subtree query record lies left right side root empty subtree reached 
level recursion calculate distance query root current subtree 
new distance smaller previous current nearest neighbor updated 
recursion current nearest neighbor record tree closer query lie region centered radius 
remember geometric terms kd tree induces partition dimensional space file records lies 
region totally included cell partition corresponding search finished point nearest neighbor record cells intersected region explored 
theorem expected cost measured number visited nodes nearest neighbor query random kd tree size log 
proof 
proof similar proof friedman bentley finkel 
required observe assumptions simplified model analysis may applied study nearest neighbor queries kd trees 
particular expected volume cell partition induced random kd tree expected side length cell coordinate case optimized kd trees 
observe explore cell corresponds follow path tree average case analysis nearest neighbor search algorithm depends expected number cells intersected minimum region centered query radius equal distance current nearest neighbor 
number depend size tree average expected cost nearest neighbor queries proportional log 
gamma delta delta gamma log experimental average cost nearest neighbor relaxed kd trees 
experimentally obtain average cost nearest neighbor queries euclidean distance approximately log independent dimension 
experiments consisted building kd trees sizes going records generated trees size generating nearest neighbor queries generated tree 
experiments repeated dimensions significant variation observed dimension 
graph summarizes results experiments 
shows match theoretical predictions average path length log random binary search trees random kd trees nearest neighbor cost basically path stopping leaf exploring bottom small subtree contains leaf 
interesting going obtain experimental results metric distances empirically study variance costs 
preliminary results show euclidean distance value variance approximately log 
randomized kd trees relaxed kd trees shown efficiently support dictionary operations associative queries expected case 
expected performance assumption input sequences keys tree built corresponds random permutation 
possible configurations input sequence equally 
follows guarantee expected performance irrespective assumption input sequence randomized algorithms 
randomized algorithms require node stores size subtree beneath assume keys compatible equivalently probability keys having value th attribute small 
behavior randomized operations depends size sub trees applied 
say kd tree randomized kd tree result sequence update operations performed means randomized algorithms introduced applied initially empty tree 
shall show section tree obtained way random kd tree 
loss generality assume follows randomized algorithms free access source random bits cost generating random number log bits constant 
randomized insertions deletions informally order produce random kd tree properties hold definition 
new inserted key probability root tree root subtrees root forth 
discriminant probability discriminant new node 
insertion kd tree begins generating uniformly random integer say set kg 
step corresponds assignment discriminant new node 
discriminant assigned insertion algorithm proceeds follows 

tree empty tree algorithm insert produces tree root node empty left right subtrees 

tree empty probability key discriminant pair placed root new tree insert root algorithm new tree size 
insert pair recursively left right subtree depending order relation root root left subtree right subtree symbolically 
probability insert insert root 
probability insert insert insert algorithm insert requires possibility inserting pair root subtree kd tree empty insert root gives result tree root node discriminant empty left right subtrees 
empty definition insert root root left subtree consists elements th attribute smaller right subtree contains elements th attribute obtain left right subtrees split algorithm 
deletion record random kd tree consists searching tree key deleted join corresponding left right subtrees 
order keep random kd tree deletion nodes subtrees deleted node probability place deleted node 
achieved join algorithm introduce 
record deleted random kd tree root left subtree right subtree symbolically delete delete delete join observe insertions deletions consist different steps 
step follow path tree order locate place key inserted deleted second step update performed insert root join 
expected cost insertions deletions log insertion root element deletion element occur near leaves average 
words reconstruction step expensive expensive standard kd trees occurs subtrees expected size log 
split join algorithms insertion pair root tree task insert root performs accomplished phases 
tree partitioned respect th attribute produce trees 

contains keys th attribute smaller keys attribute greater respectively 
second trees previous step attached root 
main bulk insert root clearly lies partitioning splitting 
split 
simplify description split see pair functions split split 
split 

split 

practice 

simultaneously computed 
algorithm split works way 
empty tree split returns empty tree 
root left subtree right subtree cases consider 
belongs 
elements th attribute value smaller smaller operation proceeds recursively complete result 
algorithm proceeds recursively th attributes greater 
belongs 
algorithm proceeds recursively attach results splitting 
tree algorithm proceed recursively join trees resulting split symbolically empty split 
split 
split 
split 
split 
join split 
split 
split operation defined analogously 
symbolic equations empty split 
split 
split 
join split 
split 
split 
split 
difficult see split 
split 
compare keys performing partial match attribute th attribute specified 
additional cost join algorithm taken account 
describe algorithm join input pair kd trees discriminant definition algorithm applied th attribute keys smaller th attribute value key pointed order produce random kd trees node node probability root new tree join definition 
sizes respectively join size join algorithm selects probability root root complementary probability root cases consider 
empty empty tree 
empty equal non empty 
non empty trees roots left subtrees right subtrees respectively 
situation selected root sub cases left subtree right subtree result joining keys th attributes greater ja left subtree result joining split 
right subtree result joining split 

analogous symmetrical subcases arise root selected root symbolically non empty ffl probability join join join split 
join split 
ffl probability join join join split 
join split 
observe join algorithm traverses tree similar way partial match algorithm specified attribute additional cost split algorithm 
randomized split join algorithms preserve randomness input see lemma 
words applied random kd trees split join algorithms produce random kd trees 
happens insert delete algorithms applied random kd trees produce random kd trees 
claims explicit lemma theorem theorem 
lemma kd tree 

kd trees produced split 
split 
respectively key compatible random kd tree 

independent random kd trees 
kd tree produced join kd trees keys keys independent random kd trees random kd tree 
proof 
prove parts lemma induction size show split split preserve randomness joint size jaj jbj show join preserves randomness 
observe prove parts lemma size need inductively simultaneously assume statements true size smaller reason mutual recursion split operations join 
empty split 
split 
empty trees part lemma trivially holds basis induction 
empty jaj jbj empty random 
consider case assuming parts lemma true sizes smaller start split process denote size kd tree partitioned 
root denote left right subtrees respectively 
tree 
right subtree tree 
computed applying recursively split split subtree jrj inductive hypothesis 
random independent 
left subtree 
left subtree assumed random random independent independent summary subtrees 
random independent kd trees 

independent 
complete proof case need show key 
discriminant kg probability pair root 
mk size 
root 
phi root psi phi psi nk mk case proved similar way 
consider case case split process recursively applied yielding inductive hypothesis independent random kd trees 



tree 
built attaching trees 

root 
obtained joining trees 

jl jr 
join 
inductive hypothesis random kd tree clearly independent 
furthermore probability key 
discriminant kg pair root 
mk size 
root 
phi root psi phi psi nk gamma gamma mk symmetric case proved similar way 
tackle second part lemma show join preserves randomness 
empty join returns non empty tree pair hypothesis random 
shall consider case jaj jbj 
root left subtree right subtree root left subtree right subtree select pair root recursively join inductive hypothesis result random kd tree 
left subtree random kd tree right subtree join random 
subtrees independent probability root times probability selected root jaj deltak jaj jaj jbj nk reasoning shows lemma true chosen root chosen root need split discriminant process yields inductive hypothesis independent random kd trees 
split 

split 

join recursively applied pairs 

yielding inductive hypothesis random independent kd trees attached root left right subtrees respectively 
probability root jaj jbj nk reason previous case selected root 
chosen root lemma holds reasoning 
theorem random kd tree contains set keys key compatible insert returns random kd tree containing set keys fxg 
proof 
proof induction size empty tree random kd tree insert returns random kd tree root empty subtrees uniformly generated kg 
assume empty theorem true sizes insertion possible results probability root insert complementary probability recursively inserted corresponding left right subtree consider case inserted root consider item probability root insertion kn hypothesis random kd tree 
probability root probability root root kn theta resulting desired probability 
inserted root step insertion proceeds recursively left right subtrees independent random kd trees sizes modified insertion random kd tree inductive hypothesis insertion random kd tree 
random kd tree size 
hand probability root discriminant probability resulting probability expected 
tree hypothesis random kd tree split respect lemma step produces independent random kd trees left right subtrees random kd tree 
theorem random kd tree contains set keys delete produces random kd tree contains set keys 
proof 
key algorithm modify tree random 
suppose case proved induction size tree 
key tree deletion obtain empty tree random kd tree 
assume theorem true sizes key root proceed recursively left right subtrees inductive hypothesis obtain random subtree 
key root tree deletion result joining left right subtrees produce random kd tree lemma 
deletion node probability gamma root 
key discriminant pair phi root psi phi root root psi theta fx root tg phi root root psi theta fx root tg gamma theta gamma gamma theta gamma probability discriminant obtain desired probability 
combining previous theorems obtain important corollary 
corollary result arbitrary sequence insertions deletions starting initially empty tree random kd tree 
final remarks randomized generalization kd trees randomized kd trees inherits simplicity robustness flexibility efficiency standard kd trees guarantees expected performance operations updates associative queries including considered randomized algorithms free assumption order updates insertions deletions performed 
particular expected external path length randomized kd trees log exact match queries answered log time partial match queries keys specified answered gamma time 
expected cost nearest neighbor queries log 
expected cost deletions insertions log 
update operations queries require preprocessing 
randomized kd trees efficient space requiring slightly space standard kd trees randomized kd trees need store node discriminant size subtree beneath 
important point similar results obtained means technique aragon seidel 
approach priority assigned uniformly random record kd tree built usual additional restriction node subtrees elements higher priority node respect called order 
split join algorithms easily modified produce random kd trees priorities random choices sizes subtrees 
alvarez salvador anonymous referees useful comments earlier versions 
technical advice comments analysis partial match 
aragon seidel 
randomized search trees 
algorithmica 
bentley 
multidimensional binary search trees associative retrieval 
communications acm 
culberson 
effect updates binary search trees 
acm sym 
theory computing stoc pages 
lau ph 
flajolet 
analysis kdt trees kd trees improved local 
dehne 
sack santoro editors 
algorithms data structures wads volume lncs pages 
springer verlag 

empirical study insertion deletion binary search trees 
communications acm 
ph 
flajolet odlyzko 
singularity analysis generating functions 
siam discrete mathematics 
ph 
flajolet puech 
partial match retrieval multidimensional data 
journal acm 
friedman bentley finkel 
algorithm finding best matches logarithmic expected time 
acm transactions mathematical software 
graham knuth patashnik 
concrete mathematics 
addison wesley nd edition 
knuth 
art computer programming sorting searching volume 
addison wesley nd edition 

evolution random search trees 
john wiley sons 
mart 
number descendants random search trees 
electronic journal combinatorics 
www combinatorics org 
mart 
partial match queries relaxed multidimensional search trees 
preparation 
mart 
randomized binary search trees 
journal acm 
motwani raghavan 
randomized algorithms 
cambridge university press cambridge usa 
mulmuley 
randomized multidimensional search trees results dynamic sampling 
ieee sym 
foundations computer science focs pages 
mulmuley 
randomized multidimensional search trees lazy balancing dynamic shuffling 
ieee sym 
foundations computer science focs pages 
overmars van leeuwen 
dynamic multi dimensional data structures quad trees 
acta informatica 
pugh 
skip lists probabilistic alternative balanced trees 
communications acm 

improved master theorem divide conquer recurrences 
degano gorrieri marchetti spaccamela editors int 
col automata languages programming icalp volume lncs 
springer verlag 
samet 
design analysis spatial data structures 
addison wesley 
sproull 
refinements nearest neighbor searching dimensional trees 
algorithmica 
van kreveld overmars 
divided trees 
algorithmica 
