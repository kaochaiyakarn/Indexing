event architecture definition language david luckham james vera discusses general requirements architecture definition languages describes syntax semantics subset rapide language designed satisfy requirements 
rapide concurrent event simulation language defining simulating behavior system architectures 
rapide intended modelling architectures concurrent distributed systems hardware software 
order represent behavior distributed systems detail possible rapide designed greatest event modelling producing causal event simulations 
rapide model executed produces simulation shows events model behavior timestamps events caused events events happened independently 
architecture definition features rapide described event patterns interfaces architectures event pattern mappings 
features build causal event models static dynamic architectures illustrated series simple examples software hardware 
give detailed example event pattern mappings define relationship architectures different levels abstraction 
discuss briefly rapide related event languages 
keywords rapide architecture definition languages partially ordered event sets architecture prototyping concurrency simulation formal constraints event patterns causality 
rapide executable architecture definition language 
features day event simulation languages provides new features represent system architecture see lvm 
describe design requirements 
architecture definition features rapide 
semantics described terms causal event executions illustrated series simple examples 
show features model behavior static dynamic architectures 
show mappings relate widely different architectures high level abstraction detailed level 
give brief history rapide current status supporting toolset 
features rapide described papers object oriented features deriving new interface types modules previous ones klm tea concurrent reactive programming constructs tea formal constraints tea 
earlier version rapide project funded darpa onr contract afosr afosr outlined model large scale example open dtp standard architecture standard described 
discussed mappings conjunction formal constraints test conformance systems architectural standards 
current simulation toolset rapide built modelling simulation architectural designs early phases system development testing conformance systems architectural designs 
ii 
features defining architecture widespread belief software engineering go object oriented methods new technology architecture 
technologies corba gro example allow distributed systems interacting modules wired 
architectural plan system needed guide wiring prototype behavior system effort put building modules system components 
architecture rapide executable specification class systems 
level abstraction 
architecture consists interfaces connections constraints 
interfaces specify behavior components system connections define communication components features specified interfaces constraints restrict behavior interfaces connections 
called interface connection architecture lvm communication system components defined connections interfaces 
rapide architecture executed produces causal event history automatically checked constraints 
interface connection architectures built quickly rapide 
main purposes 
build relatively little effort prototype enables study predict behavior effort put building full system 
second define plan framework guide construction system possibly automated synthesis methods 
achieve goals ffl rapide powerful define interface connection architectures executed properties measured ffl system built conform architecture 
requirements adls requirement sufficient power leads general principles satisfied rapide design 
ffi component abstraction interfaces feature rapide component abstraction define facilities provided facilities required component ii component behavior form allowing execution analysis 
interfaces languages ada ada task types package specifications public parts classes entity interfaces vhdl specify signatures provided facilities functions task entries ports 
define features require components define behavior independently module instance 
ffi communication abstraction connections feature rapide defining communication components interfaces components ii define communication form allowing execution analysis 
programming languages interfaces restrict visibility modules communication modules implemented modules 
example communication represented function calls buried classes package bodies ada task entry calls buried task bodies ada 
communication implemented communication abstraction 
hand hardware simulation languages provide communication abstraction static architectures 
vhdl example communication entity interfaces defined structural architectures port maps wire interfaces 
separate configurations associate entity bodies modules interfaces architecture different configurations define different implementations architecture communication defined architecture possible configurations 
similarly static connections fixed number component interfaces expressed verilog tm parameter bindings 
ffi communication integrity interfaces may communicate directly architecture connection interfaces 
requires architecture connections define direct communication pairs interfaces 
possible unconnected interfaces communicate third interface called indirect communication 
ffi dynamicism rapide capable modelling architectures dynamic systems number components connections may vary system executed 
ffi causality time rapide capable expressing casual dependency independency behaviors interfaces connections timing 
requirements forced wealth dynamic distributed systems architecture definition modelling primary issue 
event modelling languages provide simulation timestamps event interleaving 
concurrency expressed simulation results dependence independence behaviors 
current adl model dynamic systems 
ffi hierarchical refinement rapide allow components connections architecture replaced sub architectures form new architectures 
requirement needed allow hierarchical design methodologies currently practiced areas hardware protocols applied architecture modelling 
programming simulation languages support hierachical refinement components generally allowing interface implemented module containing set submodules 
require connections refinable architectures 
ffi relativity rapide provide features interpreting behavior architecture behavior architecture interface 
requirement general complementary hierarchical refinement 
architectures system defined different levels abstraction tend differ widely kinds numbers components types data communicated 
current technology provide means explicitly define relationships architectures 
require rapide provide features relating architectures 
features applications relating architectures different levels abstraction architecture may serve constraint 
illustrate section vii 
conformance architecture system architecture conforms conversely rapide architecture constraint systems 
basic conformance criteria 
decomposition interface architecture unique module corresponding system component implementing interface 

interface conformance component system conform interface 
behavioral constraints part rapide interfaces conformance requirement stronger syntactic interface conformance usually required programming languages 

communication integrity system components communicate directly specified interface connections architecture 
system conform architecture order architecture predict system behavior decide various issues maintaining modifying system see lvm 
test prove system conforms architecture scope 
style guidelines rapide help ensure communication integrity 
guideline requires components access interface constituents communicate mappings discussed allow sophisticated decomposition single interface subsystem components 
components 
helps ensure direct communication components interface connections 
types objects communicated restricted immutable objects prevent communication trojan horses 
iii 
causal event simulation rapide event processing language 
events simply tuples information containing generated event activity done data values time duration semantics rapide defined terms event processing generating events sending events component observing events 
components ability generate events independently 
asynchronous communication modelled connections react events generated components generate events components events reacted cause events generated connection 
causality events modelled reactive behaviors components 
addition synchronous communication modelled connections function calls 
result executing rapide architecture set interfaces connections poset showing dependencies independencies events 
start intuitive examples posets capture semantics communication architectures 
components airplanes control tower 
connections depicted arrows 
intuitive semantics picture airplanes generate radio events containing data cause receive events containing data observed control tower 
architecture defined rapide executed typical resulting poset shown 
events depicted nodes dependencies events directed arcs 
poset shows airplanes generated radio events independently radio caused receive event control tower sfo receive events independent sfo may observe order possibly concurrently 
timestamps information contained events 
variant architecture may require communication control tower pipelined shown 
airplanes connected control tower pipeline connector component orders events receives sequence received tower 
architecture executed resulting posets show additional dependencies due pipeline connector receive events ordered linear dependency sequence 
implies receive events observed sfo dependency order 
semantic differences broadcast pipeline architectures shown clearly posets figures 
trace simulation languages capture event dependencies produce partially ordered set events 
event trace architectures 
iv 
event patterns event patterns expressions defining behaviors components connections mappings architectures 
fundamental representing dynamic architectures 
action defined action name finite list types called signature event action tuple information unique event identifier 
event contains action name data objects signature types certain information component generated component destination event event timestamps dependency history 
tuple notation vn events 
event identifier part tuple notation 
distinct events may tuple 
event patterns simply patterns expressions define sets events dependency timing relationships posets 
syntax pattern basic pattern pattern binary pattern operator pattern pattern iterator operator binary pattern operator print pattern iterator operator binary pattern operator pattern guard placeholder list pattern pattern pattern expression expression binary pattern operator 
printed iterator operator integer expression guard boolean expression basic pattern performer part action part parameter association performer part component expression action part action name type expression action name semantics rapide uses special kinds variable 
called placeholder 
placeholder names distinguish variable names alphabetic character 
placeholders typed declared way ordinary variables similarly build expressions 
differ ordinary variables bound object result pattern matching 
broadcast communication fig 

broadcast architecture 
sfo receive radio sfo receive radio sfo receive radio sfo receive radio event dependencies broadcast connection fig 

broadcast events 
kind special variable iterator 
iterator universal quantifier type 
iterator names distinguish ordinary variables placeholders 
iterators typed declared way ordinary variables 
differ ordinary variables may assigned values 
pattern containing iterator equivalent conjunction instances pattern iterator replaced object type 
iterators important defining fan connection rules see section vi 
process deciding poset matches pattern pipeline communication fig 

pipeline architecture 
sfo receive radio sfo receive radio sfo receive radio sfo receive radio event dependencies pipeline connection fig 

pipeline events 
called pattern matching 
defined formally recursive function arguments pattern finite poset 
pattern finite poset os recursively defined algorithm finding type correct binding placeholder object matches os clauses instance results placeholder replaced occurrences binding basic pattern os composite event pattern built event patterns pattern operation os matches os union matches binding placeholders follows 
dependent os match events match depend events match 
os match matches patterns 
distinct os match events matched distinct events matched 
os match match pattern match pattern case match patterns needed 

independent jj os match events matched dependent events matched vice versa 

os match events matched timestamps rapide clock events matched 
iteration exp op shorthand pattern built exp copies operation op exp zero exactly integer copies op preceding binary operations 

guarded pattern 
os match match boolean expression true os observed component architecture containing pattern see section 
examples simple patterns simple patterns descriptions posets match 
event event parameter 
event event depends event 
event event temporally event 
event parameter greater 
iterator sender receiver sender receiver data connection rule 
send 
receive comments connection rule triggered poset matches left side pattern event sender generates send data 
bound match 
right side restricted pattern executed 
results events receiver object system match receives data discussion patterns interfaces define behaviors architectures define connections 
example pattern may interface define concurrent behavior consisting events generated simultaneously 
patterns ways 

recognize trigger posets particular features 

specify constraints posets constraining behaviors 

generate posets response trigger generating behaviors 
applications general patterns may 
third pattern fully specify poset 
means example posets 
restricted patterns generate behaviors 
interfaces interface defines type components 
provides definition externally visible behavior behavior visible may observed architecture containing components 
interface defines kinds events component observe generate ii functions provides components requires components iii states state transitions iv constraints external behavior 
general components small static values integers large dynamic systems varying state airplanes 
interface types provide component abstraction section ii 
structure interface types syntax structure interfaces outlined 
means list means optional 
standard pascal types boolean string integer array record pointers assumed definition 
called types 
rapide name types pointers 
type declaration type identifier interface expression interface expression interface interface constituent interface procrustes son poseidon greek myth altered size visitors fit facilities 
interface constituent provides object name declaration requires object name declaration action action declaration action action declaration service service declaration behavior declaration list state transition rule constraint pattern constraint list action declaration name name list type name name list type service declaration name expr expr dual interface type name declarations type object function declarations placeholder iterator name declarations state transition rule trigger connection op transition body connection op trigger pattern see section iv boolean expression constraint pattern transition body restricted pattern fig 

outline interface syntax 
features omitted overview 
example interface type declarations type object parameters allowing polymorphic types inherit type declarations refer compiled units 
semantics interfaces interface defines type object called module 
modules conform interface belong type 
interface component architecture module interface type component system conforms architecture 
module corresponds decomposition principle section iib interface 
architecture called parent interface system called instance architecture 
describe interfaces define communication modules conforming system 
interface declares sets provides requires action service constituents 
interface constituents visible parent architecture 
components architecture wired connections section vi interface constituents 
communication interfaces defined connections 
object name declarations declarations objects types integers arrays interface types function types 
module conforming interface provide objects functions named provides constituents 
example components connected call provided functions 
conversely module may call requires functions interface assume connected call provided functions components 
connections required provided functions define synchronous communication 
interface specifies types events modules observe generate declaring respectively actions 
connections parent architecture call actions module interface generating events module observe conversely module call actions generating events parent architecture observe 
architecture connections components actions react events generated component generating events observed components connections define asynchronous communication components 
constituents module interface referred locally module 
conversely module refer interface constituents internal constituents 
visibility rules parameter type restrictions ensure communication integrity section ii systems instances architecture 
modules system communicate connections system architecture 
describe behaviors interfaces execute components interface connection architecture 
interface optionally contains behavior consists set types objects functions transition rules 
objects allowed 
objects declared interface model state 
transition rules model modules type react patterns observed events changing states generating events 
behavior abstraction modules interface type 
interface observes events architecture 
reacts executing transition rules generating events sent components 
interface generate events observe events 
similarly interface observes calls provides functions interface declare functions behavior executed response calls 
interface calls requires functions depends parent architecture connect calls provides functions components 
kinds transition rules behaviors 
operator called pipes operator jj 
called agents 
pipe sequential pattern body specifies behavior single thread control agent specifies behavior arbitrarily threads 
state transition rule parts trigger body 
trigger event pattern expression 
body optional set state assignments followed restricted pattern describes poset 
provides function body treated transition rule triggered function call function calls treated events 
execution semantics transition rules follows 
boolean triggers true process arbitrarily choosing true triggers executing rule body repeated boolean triggers true 
interface observes event set events generated observed 
events queued awaiting observation 
event observed interface 
events queued module waits 
events observed sequential order consistent temporal causal orderings 
observing event may trigger transition rules 
rule triggers subset events far observed triggering match pattern 
set observed events trigger rule earliest time dependency largest chosen 
triggers binding placeholders match pattern applied body instance body ready execution 
set rule body instances ready execution executed order 
guards pattern triggers evaluated interface event generated 
values associated event 
matching pattern guard restricted condition guard pattern matched observed events guard evaluated 
value guard associated event matching pattern taken value guard pattern matched 
executing rule body consists changing state behavior part calling operations objects declared generating unique poset new events defined instance restricted pattern adding poset execution parent architecture 
new events added depend events match trigger depend events triggered rules change state objects referenced executing rule guard trigger parameter expression right side rule 
addition rule pipe generated events depend events generated previous triggering rule 
execution behavior continues evaluating boolean triggers observing events 
schema ordering activities loop boolean triggers true loop choose true triggers called orderly observation principle 
execute rule body select event pattern triggers triggered loop execute trigger rule body loop event may take part triggering rule may take part triggering rules 
constraints specify restrictions behavior interface 
behavior results executing transition rules match pattern constraint 
example constraint specify rules trigger certain orders certain states behavior module corresponding interface instance architecture constrained consistent interface behavior constraints interface behaviors act additional constraints modules conform interface 
services service names group constituents interface note object name 
services provide powerful notation connecting large numbers actions functions section vi 
services specify types complementary connections interface expects parent architecture 
services specify degree types components interface expects connected 
service type interface declares type provides requires functions objects actions services name name appended usual notation name constituent 
example type action name action service type concise notation replication declare arrays service large numbers connections 
service dual type dual dual type contains set constituents names constituents dual roles provides function requires function dual action action dual type service type dual service dual conversely 
dual services type objects usually different types may connected easily complimentary constituents 
name types pointers rapide name types 
interface type corresponding type called name type said base type object interface type corresponding object name type called name rapide modules written various programming languages 
interface type operator defined converts object corresponding name name type operators defined name types equality assignment dereferencing 
equality assignment defined usual 
dereference operator name type defined convert name corresponding object interface type parent architecture section vi may dereference name 
restriction distinguishes name types pointers purpose ensure communication integrity section ii 
example name types section vi 
discussion component abstraction section ii provided interface types include powerful method defining behavior 
single rapide transition rule express reaction concurrent distributed system output pattern define complex poset events various dependencies timing 
generally different modules architectures conform section vi interface 
communication integrity architectures section ii aided style guidelines types parameters actions functions visibility rules modules interfaces 
parameters functions actions types name types 
consequently name component passed receiver dereference start direct communication component parent architecture communicate directly components 
style guidelines enforced rapide compiler 
behaviors non 
matching triggers transition rules events selected time rules trigger executed time arbitrary order 
shared state rules independent events may selected order triggering posets order execution state transitions parameter values events function calls generate non deterministic 
constraints may supported different ways various tools 
example executions checked violations detected runtime checking tools transitions may allowed execute constraint won violated safe execution transition rules proved consistent constraints verification 
complexity interfaces interfaces specify separately synchronous communication function calls asynchronous communication events 
attempts simplify interface design specification mechanism provides requires actions lead users incorrect expectations subtyping interfaces klm semantic equivalences functions actions 
interfaces provide behaviors constraints satisfy component abstraction section ii 
rapide interfaces complex say class public parts package specifications ada 
richer interfaces needed architecture definition go traditional information hiding role interfaces support component abstraction 
examples example automobile controls 
interface provides function return mph function gas return action steering wheel angle action accelerator position action brake pressure action warning status constituents 
comments instruments specified provides functions actions 
component instance interface module type supply bodies reactive rules computing functions 
user call functions requires functions connected architecture obtain return results 
effect output readings asked 
similarly user observe events architecture connects events user 
controls specified actions 
component observe select react events corresponding actions 
user output events containing position pressure angle data output connected architecture actions observed events 
output warning light events appropriate status data assumption parent architecture useful 
different modules architectural designs conform section interface 
example specification concurrent behavior 
behavior jj 
accelerator jj brake high jj warning comments agent transition rule part behavior interface 
triggered boolean condition specifies reaction consisting generation independent events 
events observed object 
event cause events architecture rules 
events generated triggering rule depend events caused events causing local state change 
agent rule impose dependency events generated different rule 
rule abstracts behavior modules albeit drivers wouldn 
example rs service type rs interface action txd transmit data 
action receive data 
action rts request send 
action cts clear send 
action dsr data set ready 
action dcd data carrier detect 
rs type computer interface service rs computer type modem interface service dual rs modem comments rs common interface computers modems 
defines signals generated computer modem modem computer 
rs gamma abstracted interface type actions corresponding signals 
service feature computer interface declares rs gamma services 
modem interface declares dual rs gamma service 
services interfaces express important abstraction modules interfaces 
modules expect connected modules rs gamma services illustrating support component abstraction 
computer modem connected architecture single connection statement shown section vi 
allows architectures potentially large numbers connections written clarity conciseness 
note ambitious interface contain behavior part defining rs gamma 
vi 
architectures interface connection architecture set interfaces set connection rules set constraints 
connection rules define relationships events independently implementation communication abstraction constructs section ii 
connections defined event patterns 
event patterns provide expressive power define static dynamic architectures section ii 
syntax architecture contains declarations types components objects set connection rules set constraints 
semantics optional return type name interface type architecture 
architecture defines module interface type 
return type omitted empty architecture clause architecture name return name declarations connections constraints constraints name declarations components placeholders pascal object function declarations connection basic pattern list basic pattern list basic function pattern function call expression pattern connection op restricted pattern pattern connection op component generation basic function pattern function call expression expression connection op basic pattern list basic pattern basic pattern list basic pattern component generation new name constraints fig 

outline architecture syntax 
interface type triv default 
generally rapide architectures parameterized architecture generators called return modules return type 
order focus connection features omitted parameterization 
rapide architecture construct encapsulates interface connection architecture components interfaces instances architecture components may module interface types 
types components declared declarations section architecture 
static architectures may simply declare components naming object declarations 
hand dynamic architectures may declare interface types components rely creation rules define execution components types created destroyed 
connection part contains connection rules creation rules 
connections define communication components events function calls creation rules define event conditions lead creation new components 
connection rule abbrev connection composed patterns 
patterns separated connection operator jj 
transition rules left pattern connection called trigger 
right side connection called body 
connections wire components architecture follows 
trigger pattern events requires function calls components body pattern events provides function calls components 
connection may wire architecture interface components 
case trigger pattern events provides functions interface body pattern events provides functions components conversely trigger pattern events requires functions components body pattern events requires functions interface 
semantics executing connections follows 
events function calls generated components architecture observed interface architecture 
events selected order consistent dependency temporal orders matched pattern triggers connections 
transition rules matching triggers different connections may take place independently concurrently state shared connections 
essential points event may contribute triggering particular connection rule may trigger different rules ii poset selected events trigger rule earliest dependency order maximal poset 
guards pattern triggers connection rules evaluated event generated observed architecture 
values associated event 
matching guarded condition value guard associated event selected matching value guard 
number guards need evaluated observable event clearly reduced general 
event potential participant matching subset guarded patterns set connection triggers 
compiler optimization 
basic connections 
basic connection connection basic patterns generally lists basic patterns 
consider connection basic patterns 
event matches triggers left pattern basic connection rule top placeholders right pattern bound match ii rule results generating new event tuple instance event received component named tuple iii events equivalent respect dependency time 
equivalence events means events dependency relationship events events timestamps 
mean events equal simply distinguished dependency time 
basic connection lists basic patterns shorthand basic connections 
match left patterns causes triggers generation events pattern right list events generated equivalent triggering event respect dependency time 
basic connections functions 
basic connection defines alias requires function component provides function component call caller callee 
conditions hold basic connection functions correct left pattern match calls requires function right pattern match calls provides function ii provides function subtype requires function 
evaluation call requires function triggers connection 
resulting instance connection right pattern call provides function 
caller execution suspended call provides function executed return object returned caller value triggering requires function call 
guards triggering function call alias requires function vary runtime 
requires function call alias call triggers connection return objects result 
basic connections alias provides requires functions architecture interface provides requires functions components respectively 
basic connections services 
basic connection connect service component dual service component 
connection defines set basic connections pair constituents name services 
bi directional sense basic connections constituent action function name trigger constituent action function name body 
general connections 
semantics general connection op op 
jj follows 
matched define unique poset placeholders bound match 
connection executed 
events instance generated dependencies defined follows event depends events triggering poset ii event depends events defined pattern iii connection operator 
pipe generated events depend events generated previous connection 
result new poset events components events interface 
architecture may constrained patterns constraint section 
sets events generated architecture interfaces connections match constraint patterns 
constraints may example require components particular communication protocol 
discussed section constraints may supported different ways various tools 
conformance interface architecture bound non interface conform interface 
means 
calls provides function names interface result objects return type 
achieve architecture basic connections aliasing provides function names interface provides functions components alternatively declare executable function body name 

poset interface events resulting executing architecture satisfy constraints interface 
events observed interface may trigger connections architecture result eventually events interface generated connections architecture 
events related dependencies time events defining posets interface events 
posets interface events satisfy interface constraints 

interface poset generated architecture super poset poset generated interface behavior superset events identical dependency order common subset 
sense interface behavior section acts constraint architecture interface type 
discussion connection rules provide communication abstraction section ii 
refer constituents functions actions interfaces components independent modules implementing components 
basic connections fundamental 
general connection fact interface expressed succinct notation 
general connection replaced architecture connector component transition rule expresses connection relation events basic connections components connector 
hierarchy section ii provided ability bind architectures interfaces connections conformance criteria 
interfaces connection rules expanded architectures lower level components 
examples example basic connection 
person button connections push button light comments basic connection links pairs events 
event person pushing button triggers rule produces new event denoting button light 
events identical respect dependency time dependencies events timing 
possible distinguish events clock looking causal history 
connection links persons lift buttons strong way actions pushing buttons lighting buttons appear identical time causal history 
example dynamic architecture airplane control center architecture air control sector airplane msg sfo control center connections radio inrange sfo jj 
sfo receive air control sector comments assume interfaces airplane control center defined 
connection defines event communication airplane particular control center depicted section iii 
airplane match generates radio event containing message inrange predicate airplane true state radio event generated sfo receive receive event message 
connection triggers airplane range 
connection rule conditional broadcast airplanes control tower 
defines communication system may varying numbers airplane components 
essentially fan connection 
imposes dependencies pairs radio receive events shown poset section iii 
nodes events directed arcs represent dependency 
poset shows receive events independent 
implies observed control center concurrently 
illustrate posets distinguish different architectures simply change connection rule previous example pipe basic connection 
example pipelining air traffic control 
architecture pipeline control sector airplane msg sfo control center connect radio inrange sfo 
sfo receive pipeline control sector comments changed air control sector architecture radio events observed control center pipe rule 
essentially pipe connect airplanes control center shown 
airplanes communicate sfo single pipe broadcast 
pipe connections order events generate linear dependency sequence 
case generated event sfo receive depends radio event triggered rule previous sfo receive events 
sfo receive events linear dependence chain shown 
means messages received control center dependency order 
semantic differences broadcast pipeline architectures shown clearly posets figures 
example rs connect computers modems computer modem architecture office pc computer mod modem connect pc mod bi directional flow events 
office comments rs gamma example section connecting computer component pc modem component mod office architecture requires single connection rule rs gamma services 
connection expresses set basic connections pairs rs gamma constituents name connection constituent action trigger pattern 
example intelligent network architecture 
intelligent network dynamic architecture works passing names components components 
restrictions name types section ensure network architecture connection rules define pairs components may participate directly data transfer 
types components providers clients brokers 
numbers components type vary example fixed 
providers register broker indicating service provide 
broker stores names providers contained register events actor element jobs perform 
client ask broker provider job calling find provider 
result name provider supplied broker client provider 
client name provider request job 
client dereference name get provider call provider directly 
client communicate request job provider name architecture 
parent architecture module dereference provider name connection rules generate request provider 
interface provider provides function job job parameters return data action register job interface client requires list functions function request job job parameters pn provider return data function find provider job return provider phone eia power power jack line rs service rs dual service fig 

rs connection 
interface broker provides function provider lookup job return provider action register provider job provider behavior store provider job type jobs array job provider job provider function provider lookup job return provider return jobs register provider 
jobs broker client provider components declared network architecture 
direct communication pairs components defined basic connection rules 
broker client provider architecture network ntt broker clients array num clients client providers array num providers provider provider job client provider param parameters connect register ntt register provider find provider ntt provider lookup request job param job param network rule connects provider action register broker action register provider 
fanin rule connecting providers single broker asynchronous actions providers don block 
second rule defines alias call client find provider function call broker provider lookup function return value name provider 
fan rule connecting clients broker 
synchronous function call clients need wait return value 
multiple brokers rule generalized alias call find provider broker result returned names 
third rule aliases call client request job function call job function request job param job param dynamic network architecture name type parameters provider provider provider client client highly dynamic communication cloud register find provider provider lookup fig 

intelligent network 
provider name client supplies 
rule dereferences provider name client call calls provider job function 
rule expresses num clients num connections pairs components 
communication integrity implies rules define direct communication network pairs clients providers broker 
allow draw knowledge modules implementing components 
example connection rules triggered broker know broker initiate communication 
ii providers cause broker register provider events 
iii clients communicate data directly clients providers communicate data directly providers 
iv transfer data provider client caused function call client limited junk mail rule 
properties network communication deduced integrity connection rules section ii subverted passing components pointers components parameters functions actions 
deductions valid component names passed components 
architecture network may dereference names components done third connection rule 
example broker name providers stores communicate directly 
true pointers place names broker dereference pointer provider call provider functions 
ordinary programming language examine implementations components 
vii 
mappings event pattern mappings abbrev mappings define architecture related architecture related interface 
idea define events system correspond events 
cases quite wide difference systems 
example systems different levels abstraction events may correspond just event case hierarchical design 
patterns provide necessary expressive power define kinds mappings 
maps 
map may defined pair interfaces architectures 
syntax map construct 
names names architectures interfaces 
maps may declare local objects semantics 
maps visibility declarations domain architecture range architecture mapping rules trigger events happening top level inside domain generate events top level inside range 
rules mapping semantics transition rules components non basic connections architectures define causal relation triggering events domain events generate range 
map clause map name name name declarations rules map name rule trigger map statement trigger pattern map statement state restricted pattern fig 

map syntax 
example simple microprocessor section gives example rapide architectures simple microprocessor event pattern mapping 
shows complexities real life applications require power event pattern language 
original version example gl consisted architectures vhdl simple bit microprocessor commonly design levels abstraction instruction level register transfer level rtl gate level 
reported results mappings written val vhdl annotation language control complexity vhdl simulation 
gate level simulation small input data sample produced events 
clearly manual inspection amount output difficult error prone small comparison industrial simulations 
val mappings map gate level architecture rtl architecture map rtl architecture instruction level architecture number events mapped simulation reduced 
design errors gate level rtl typically incorrect architecture connections difficult detect level manifest instruction level form missing events 
powerful application event pattern maps design hierarchies lies mapping complex low level simulations behaviors higher level architectures called mapped behavior 
mapped behavior smaller simpler 
benefits ffl manual inspection mapped behavior feasible 
ffl formal constraints generally part high level architectures embody design requirements low level simulations mapped automatically checked high level constraints 
ffl errors mapped behavior traced back low level architecture analyzing trig industry experience related instances large scale gate level simulations indicated design errors microprocessors go undetected analysis simulator output uncovered manufacture far greater cost 
ger patterns map matched producing high level error 
give rapide rtl architecture microprocessor mapping instruction level 
picture rtl architecture picture map patterns rtl events instructions shows timing relationships set rtl events trigger map resulting load event 
rapide global clock values levels design hierarchy 
readings shown horizontally levels 
rtl pattern involves events trigger mapping load instruction 
arcs show timing relations events required trigger events required occur may occur time order 
cl events example device clock events 
cl events defining device clock cycles 
trigger requires particular events occur cycle 
shadow pattern depicts simulation time duration load instruction 
interfaces rtl component types registers buffers controllers logic unit 
state transitions constraints omitted interfaces brevity 
may assume state transitions executable gate level architecture interfaces 
compilation dependencies interfaces expressed clauses 
interfaces derived object oriented features rapide tea 
interface type bit type bit array 
bit type bit array 
bit type bit array 
bit type operations land lor type states ex ex ld st interfaces rtl components 
register logic interface register action din val bit clk val bit ce val bit oe val bit rst val bit action dout val bit action load bit action oe bit register interface output register logic action val bit ce val bit rst val bit oe val bit oe val bit action val bit val bit output register logic clk ir din read write addr dout clr rst run fig 

cpu register level architecture 
output register logic interface output register service output register logic action clk val bit action load bit action oe bit action oe bit output register interface buffer action din val bit oe val bit action dout val bit action output bit buffer interface logic unit action val bit val bit op val bit action val bit action alu bit op operation logic unit output register logic interface controller action op val bit val bit val bit clr val bit run val bit rst val bit clk val bit val bit val bit val bit val bit val bit val bit val bit service reg 
dual output register logic report state changes action state states behavior current state states controller rtl interface architecture 
architecture rtl cpu arch corresponds 
example alu logic unit controller bank output registers 
rapide connections consist bindings rtl interface architecture internal connections components architecture proper 
rtl interface microprocessor see fig 
interface rtl cpu interface action clk val bit rst val bit run val bit clr val bit din val bit ir val bit action dout val bit cl il cl pl ae re de cl rl cl load afa fig 

map register events load instruction 
addr val bit read val bit write val bit rtl cpu interface simplicity parameter profiles patterns sides equivalent wanted parameter values left pattern copied corresponding positions right patterns allow parameter list omitted sides 
convention architecture 
rtl architecture corresponding 
register output register buffer logic unit controller architecture rtl cpu arch rtl cpu interface dob buffer ir acc register array 
output register alu logic unit controller bit integer connect input bindings din din ir ir din clk clk clk clk clk acc clk clk ir clk clr clr run run rst rst architecture connections 
oe dout acc dout din din din din alu dob din alu connection connects service controller service corresponding register register bank 
equivalent basic connections pairs actions 
reg alu acc din acc ce acc oe ir dout alu op 
op 


din 
dob oe oe ir ce ir rst output bindings 
read write dout addr dob dout dout rtl cpu arch connection rules particularly simple eventbased semantics basic connections defining equivalences single events 
guards architecture static 
connection means component generates output event corresponding component receive equivalent dependency time input event 
define equivalences pairs single events 
component interfaces define dependencies input output events state transition rules omitted underlying gate level architectures 
rapide architecture executed response input generate poset events gives dependencies events generated components timestamps rapide global clock see 
vhdl declare connecting wires called signals bind component ports ports vhdl correspond actions rapide wires 
rapide basic connections allow define connecting wires directly 
rapide interface services define connections controller register bank connection rule 
architecture vhdl gen took approximately lines vhdl specify took lines 
errors architecture connections common important develop succinct notation 
give microprocessor instruction level interface showing instructions mapping 
maps finite sets rtl events matching triggers single events instruction level 
expect rtl behavior mapped simpler instruction level behavior 
example trigger uses timing relation events causality 
cpu instruction set 
interface instruction level cpu action load bit integer bit action store bit integer bit action exec bit integer bit op operations instruction level cpu event pattern mapping 
map rtl cpu arch instruction level cpu reg reg reg register bit integer bit bit op operation function val bits return states function val register return integer rules mapping rule defining load instruction 
clk 
ir load ld state clk 
oe 
read output state ld clk 
reg load reg state clk 
load mapping rule defining store instruction 
clk 
ir load st state clk 
reg oe reg dob oe oe bits write state st clk state clk 
store mapping rule defining exec instruction clk 
ir load ex state clk 
reg oe reg reg oe state ex alu alu op clk 
acc load state ex clk 
reg load reg state clk 
exec op defining map important specify trigger rule triggers posets low level events sufficient signify corresponding high level event 
triggers match subset upper lower bound events appropriate posets mapped behavior correct may contain extraneous events 
patterns provide powerful succinct notation specifying sufficient posets 
load rule example specifies rtl events correspond instruction level load event 
clock event parameter indicating rising edge device clock may initiate load behavior 
clock cycle instruction register ir load instruction instruction field indicates load controller transition state 
second clock cycle address enable buffer output particular address value extracted instruction loaded previous cycle processor output read data buffer output data controller transition ld state 
third clock cycle register register bank execute load data output previous cycle controller transition state 
clock cycle completes poset maps load instruction indicates data loaded address register mapping rules define completely set rtl events timing correspond instruction level events 
causality expressed triggers example taken vhdl mapping rules sufficient 
example possible set rtl events correct timing trigger load mapping rule load instruction executed 
viii 
history status rapide rapide evolved sources vhdl event architecture concepts ml mth es type systems tsl lhm event patterns formal constraints concurrent behavior expressed terms patterns events 
evolutionary steps summarized follows 
rapide departs previous event languages adopting partially ordered set events poset execution model place linear traces events 
simulations rapide produce posets 
concept posets described fid mattern mat probably extant database literature studies knowledge feasibility implementing simulation languages produce poset executions check constraint violations done independently rapide project bry msv project ab 
secondly event reactive languages existence ones studied vhdl verilog tm lotos bb csp hoa esterel bcg 
languages simple forms event patterns triggering processes vhdl sensitivity lists disjunctions events lotos basic events predicate guards 
rapide introduced powerful event patterns appropriate specifying posets 
event patterns play basic role features defining reactive behaviors formal constraints 
pattern matching concepts go back unification algorithm resolution theorem proving rob ai languages typified planner prolog cm 
third concepts interface ada package specification vhdl entity interface extended formal annotations prior luc alg extended interface types rapide capability specify concurrent behavior 
earlier languages interfaces types 
interface types inherit types object oriented methods related notion structural subtyping klm 
research done interface design interplay subtyping formedness architectures 
fourth vhdl provided best previous model architecture wiring interfaces totally separated binding interfaces implementations configurations 
structural connections vhdl expressed port maps bind ports component interface instances signals architecture generalized rapide event pattern connection rules 
feature allows dynamic architectures 
event patterns rapide define mappings architectures allowing hierarchical comparative simulation described earlier val gl 
simulation toolset rapide tested industrial examples software hardware architectures moderate complexity 
simulator produces posets 
analysis tools display simulator output graphically automatically check output violations formal constraints allow simulations animated pictures architecture simulated 
input tools constructed allow architectures input various formalisms translated rapide 
eventual goal develop industry scale toolset 
due people collaborated experiments various versions rapide toolset 
especially due john mchugh john munson university north carolina trw members rapide design team john doug bryan walter mann alexandre santoro larry augustin stanford university bergen frank belz holly hildreth trw 
ab tod amon gaetano borriello 
simulator timing behavior 
acm ieee design automation conference june 
ada cambridge mass ada manual june 
ansi iso draft international standard 
alg larry augustin david luckham benoit huh alec 
hardware design simulation val vhdl 
kluwer academic publishers october 
pages 
bb brinksma 
iso specification language lotos 
van eijk editor formal description technique lotos pages 
north holland 
bcg berry gonthier 
synchronous programming reactive systems esterel 
technical report inria paris march 
bry doug bryan 
rapide language tool set overview 
technical note csl tn computer systems lab stanford university february 
cm clocksin mellish 
programming prolog 
springer verlag second edition 
es margaret ellis bjarne stroustrup 
annotated manual 
addison wesley 
fid colin 
timestamps message passing systems preserve partial ordering 
australian computer science communications february 
gen 
automated analysis discrete event simulations event pattern mappings 
phd thesis stanford university april 
stanford university computer systems laboratory technical report 
csl tr 
gl benoit david luckham 
validating discrete event simulations event pattern mappings 
proceedings th design automation conference dac pages anaheim ca june 
ieee computer society press 
gro object management group 
common object request broker architecture specification 
object management group revision edition december 
carl hewitt 
description theoretical analysis planner 
phd thesis mit 
hoa hoare 
communicating sequential processes 
communications acm august 
klm dinesh david luckham john mitchell 
type system prototyping languages 
proc 
st acm symp 
principles programming languages portland 
lhm david luckham david helmbold douglas bryan michael 
task specifying distributed ada systems tsl 
proceedings parle conference parallel architectures languages europe 
lecture notes computer science 
number volume ii parallel languages pages eindhoven netherlands june 
springer verlag 
david luckham john larry augustin james vera doug bryan walter mann 
specification analysis system architecture rapide 
ieee transactions software engineering april 
luc david luckham 
programming specifications anna language specifying ada programs 
texts monographs computer science 
springer verlag october 
david luckham james vera doug bryan larry augustin frank belz 
partial orderings event sets application prototyping concurrent timed systems 
journal systems software june 
lvm david luckham james vera 
concepts system architecture 
submitted communications acm 
mat mattern 
virtual time global states distributed systems 
cosnard editor proceedings parallel distributed algorithms 
elsevier science publishers 
report 
sfb dept computer science university kaiserslautern 
msv sriram sankar james vera 
exploiting locality maintaining potential causality 
proceedings tenth annual acm symposium principles distributed computing pages new york ny august 
acm press 
stanford university computer systems laboratory technical report 
csl tr 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press 
rob robinson 
machine oriented logic resolution principle 
journal acm january 
tea rapide design team 
rapide executable language manual 
program analysis verification group computer systems lab stanford university version edition october 
tea rapide design team 
rapide specification language manual 
program analysis verification group computer systems lab stanford university version edition october 
tea rapide design team 
rapide types manual 
program analysis verification group computer systems lab stanford university version edition october 
tm thomas 
verilog hardware description language 
kluwer academic publishers 
ieee east th street new york ny 
ieee standard vhdl language manual march 
ieee standard 
open apex plaza road reading ax distributed transaction processing peer peer specification december 
snapshot 
