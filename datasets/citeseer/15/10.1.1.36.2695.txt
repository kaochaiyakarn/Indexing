unifying partial evaluation deforestation supercompilation gpc morten heine robert gluck neil jones authors address diku department computer science university copenhagen dk copenhagen denmark mail diku dk diku dk neil diku dk 
study transformation methodologies automatic instances burstall darlington fold unfold framework partial evaluation deforestation supercompilation generalized partial computation gpc 
classify fold unfold transformers information maintain transformation 
introduce positive supercompiler version deforestation including information propagation study classification detail 
study positive supercompilation able show partial evaluation deforestation simple information propagation positive supercompilation information propagation supercompilation gpc information propagation 
amount information propagation significant positive supercompilation gpc supercompilation specialize general pattern matcher fixed pattern obtain efficient output similar knuth morris pratt algorithm 
case partial evaluation deforestation general matcher rewritten achieve 
aim compare certain automatic instances burstall darlington framework 
known basic techniques framework unfolding instantiation definition folding abstraction 
addition applying mechanisms transformers consider maintain information previously encountered terms previously encountered tests partial evaluation discussed length jon replaces calls arguments known specialized calls optimized version account argument known 
offline partial evaluators application burstall darlington transformations guided automatically generated program annotations tell unfold instantiate define fold 
deforestation due wadler wad fer remove intermediate data structures altogether reducing number passes data 
supported austrian science foundation fwf number danish research council 
known partially evaluate 
instance applying deforestation known append function yields defined ws ws vs ws vs ws termination safe extensions deforestation chi sor automatically precomputed annotations tell generalize extract folding takes place ensure termination 
supercompilation powerful technique due turchin tur continuing soviet early achieve effects deforestation partial evaluation 
supercompilation performs driving unfolding propagation information generalization form abstraction enables folding 
decision generalize taken online 
gluck expressed essence driving context traditional tail recursive language manipulating lisp lists glu 
generalized partial computation gpc due futamura fut applied lazy functional language tak similar effects power supercompilation implemented 
remainder organized follows 
section introduce terminology allows discuss quality output transformers 
section introduce positive supercompiler discuss correctness point differences rules compared deforestation 
compare section notion information propagation deforestation positive supercompilation 
observe deforestation algorithm derive efficient knuth morris pratt style pattern matchers positive supercompiler explain 
section extend comparison partial evaluation gpc traditional supercompilation 
section concludes reviews directions research 
test program transformers way test method power see derive certain wellknown efficient programs equivalent naive inefficient programs 
popular tests generate general pattern matcher fixed pattern efficient specialized pattern matcher output knuth morris pratt algorithm knu 
shall call kmp test 
general naively specialized kmp specialized matchers different general pattern matchers literature nested calls 
shall concerned tail recursive 
deny explicitly carries nested version 
definition general tail recursive matcher 
match loop loop ss op os rue loop pp op os alse loop pp ss op os loop pp ss op os op os op alse op ss loop op ss op ss consider naively specialized program matches fixed pattern aab string evaluation match aab proceeds comparing component second third 
point comparison failed process restarted tail strategy optimal string begins 
inefficient restart tail aa known tests aab aa succeed 
kmp style specialized matcher corresponding dfa constructed knuth morris pratt algorithm knu takes information account 
example kmp style specialized matcher aab 
loop aab loop aab alse loop aab ss loop ab ss loop aab ss loop ab alse loop ab ss loop ss loop aab ss loop alse loop ss loop ss loop aab ss comment measuring complexity careful discussing complexity multi input programs especially context program specialization inputs fixed 
example general tail recursive pattern matchers jpj jsj denote length pattern string respectively 
running time program inputs result specializing known pattern transformation algorithm 
specialized kmp style pattern matcher customary say general jpj delta jsj time program transformed jsj time miranda notation lists short notation aab 
shall continue having introduced language slightly different syntax section 
program 
alas true trivial transformations kleene gamma gamma theorem kle 
reason soon jpj fixed jpj delta jsj jsj coefficient proportional jpj 
precise define speedup function jon speedup constant infinitely subject strings delta jpj delta jsj 
trivial specializer gamma gamma theorem easy see essentially running time speedup 
hand non trivial transformers see program satisfies delta jsj subject string independent consequence speedup delta jpj particularly interesting speedup significantly large larger longer patterns 
shall say kmp test passed transformer holds constant delta jsj 
section investigate kmp test deforestation positive supercompilation 
section review explain known results kmp test partial evaluation supercompilation gpc relate results 
positive supercompilation object language 
describe notions convenient formulation positive supercompiler 
define positive supercompiler 
describe relation deforestation defined fer consider correctness positive supercompilation :10.1.1.28.6971
language language extends fer presence conditionals equality tests arbitrary terms :10.1.1.28.6971
definition object language 
variable constructor function call function call conditional function definition patterns 
function definition patterns pm vn patterns constructor usual require left hand sides definitions linear variable occurs 
require variables definition right side left side 
ensure uniqueness reduction require function program definition case definition patterns contain constructor 
semantics reduction variable free term call name realized miranda tur lazy evaluation 
apart fact language order obvious quite common restrictions function definitions may pattern matching argument non nested patterns 
methods exist translating arbitrary patterns restricted form aug 
examples assume simplicity deforestation algorithm positive supercompiler handle multiple pattern matching arguments 
find call unfold shall express positive supercompiler rules rewriting terms 
rewrite rules understood intuitively mimicking actions call byname evaluator extended continue transformation value sufficiently defined transformation time know exactly program rule applied 
applicable rule unique sufficient code generated account run time possibility 
term possibilities exist transformation 
case subcases 
transformation proceed arguments assumption user demand term value printed transformation terminates 
ii call name evaluation forces unique call unfolded branch unique conditional chosen 
instance term adding equality test allow non linear patterns 
formulation positive supercompiler algorithm 
forced unfold call order able decide clause definition choose 
example term forced unfold call able decide branches 
turn forced need decide clause definition apply 
case ii term written identifies function call unfold conditional choose branch surrounding part term 
traditionally redex evaluation context 
intention call ready unfolded evaluation arguments necessary conditional branch chosen terms equality test completely evaluated 
define notions precisely 
definition evaluation context redex observable value 
evaluation contexts reduce left reduce right gamma left right constructor test redex observable value expression denotes result replacing occurrence term variables called ground 
easy verify term observable variable known outermost constructor decomposes uniquely form unique decomposition property 
provides desired way finding function call unfold conditional select branch 
positive supercompiler define positive supercompiler 
positive supercompiler consists elements divided phases 
transformation phase driving folding performed 
postprocessing phase performed 
describe driving folding 
driving 
driving part positive supercompiler 
takes term program written explicitly argument returns new term new program 
notation algorithm 
fig 

positive supercompiler 
definition 
tn tn tn uk uk fv tn tn tn uk uk fv tn uk uk fv fv 
uk fv fv ground ground mgu ground notation 
implicit program argument 
functions denotes right hand side definition function formal parameters definition 
function definition right side corresponding left side pattern contains constructor formal parameters clause pattern contains constructor occurring pattern variables pattern depends 
patterns expression denotes result replacing occurrences corresponding value fv substitution applied just notation mgu denotes general unifier fv exists fail 
convenient define fail symbol denotes evaluation metalanguage transformation 
instance clause result transforming call new function function defined right hand side result transforming fv symbol refers definition object language language definition 
read code generation command 
term transformed call new function new functions collected new program 
variables calls simply variables 
clause variable included folding 
imagine name new function order variables list arguments uniquely determined encountered name argument list generated 
happens function defined fold step performed 
shall assume fold step performed call encountered renaming previously encountered call 
transformation phase functions called exactly residual program unfolded 
deforestation versus positive supercompilation henceforth call deforestation algorithm positive supercompiler actions cast fold unfold framework follows 
clause term transformed call new residual function 
involves define step new function defined instantiation step new function defined patterns unfold step body new function unfolded step fold step right hand side original function replaced call newly defined function 
clauses similar need instantiation step 
say instantiation step trivial regarding variable trivial pattern functions defined patterns 
operation instantiation followed unfolding different branches called driving turchin 
clauses understood unfold steps similar clauses clause understood instantiation step similar clause 
essential difference clause pattern substituted occurrences variable 
pattern substituted occurrence occurrences included parameters transformed call left hand side transformed definition 
take liberty imprecise point 
matter technicality patterns terms clause chosen renamings corresponding patterns bodies clause unifier chosen idempotent possible see sor 
important difference implies propagating information information instantiated 
turn accounts fact able derive kmp style pattern matchers 
easy see algorithms identical effects linear programs 
note distinction clause explicit fer restricted treeless programs right sides linear transformation non linear terms briefly considered fer :10.1.1.28.6971
subsequent examples shall assume extended handle conditional adopting rules leaving substitution rule 
operational semantics efficiency termination issues correctness preservation operational semantics efficiency termination 
output semantically equivalent input 
proof preservation operational semantics reasonable sense sor 
second output efficient input 
rewriting nonlinear right hand side cause function call duplication generally hold appropriate precautions taken 
problem known partial evaluation ses bon jon deforestation wad chi 
essentially principles applied see sor 
third terminate 
algorithm fact terminate 
techniques ensure termination programs studied sor 
kmp test positive supercompiler deforestation section observe derive kmp style pattern matcher 
explain show derive program efficient kmp style pattern matcher 
derived program contain inefficiency 
explain suggest extended produce programs exactly efficient kmp pattern matchers 
pattern matching deforestation result applying deforestation term match aab follows assuming post unfolding example non improved specialized matcher 
loop aab loop aab os alse loop aab ss os loop ab ss os os loop ab os alse loop ab ss os loop ss os os loop os alse loop ss os rue os alse ss loop aab ss ss program improved sense argument removed 
time match fails head string skipped match starts 
pattern matching positive supercompiler draw graph terms encounters applied see 
nodes labelled right column signify transformation terminates term previously encountered signify arcs back nodes labelled respectively left column 
notice instantiation occurrences ss allows information passed effect achieved due fact instantiates occurrence calls unfolded subsequent comparisons calculated 
specifically known string ss moving step right string know comparison head string succeed fact calculated 
program generated example kmp style matcher 
loop aab loop aab alse loop aab ss loop ab ss ss loop ab alse loop ab ss loop ss ss loop alse loop ss rue loop ss ss ss loop aab ss ss loop ab ss ss incidentally shows deforestation partially evaluate 
fig 

applied match aab match aab loop aab aab loop ab ss aab ss aab ss loop ab ss aab ss loop ss aab ss aab ss loop ss aab ss loop ss aab ss aab ss loop ss aab ss true alse aab ss alse aab ss loop aab ss aab ss alse aab ss loop aab ss aab ss loop ab ss aab ss aab ss loop ab ss aab ss disregarding test known false called false branches test loop ab loop desired kmp pattern matcher 
redundant tests affect asymptotic behaviour generated specialized matchers terminology section author proved passes kmp test sor 
major improvement reason unnecessary tests cut graph propagating positive information 
clause propagate information test true true branch certain variables certain values 
propagate information applying unifier term true branch 
false branch propagate negative information test failed 
information restricts values variables take 
nodes graph know respectively information ignored resulting redundant tests program 
positive negative information arise equality test propagate positive information 
reason propagate negative information modeled substitution instantiation express fact equal 
incorporate negation techniques see section obtain exactly kmp pattern matchers kind information 
call function defined patterns viewed test instantiate clause say test propagate resulting information branches 
represent positive information application substitution 
notion negative information arising test 
negative information occurs case implicit explicit constructs 
partial evaluation supercompilation gpc section relate information propagation positive supercompilation deforestation partial evaluation supercompilation gpc 
partial evaluation functional programs partial evaluation jon propagates simple information viz 
values static variables 
partial evaluation specialize programs weaker positive supercompilation supercompilation gpc propagates information obtained predicates pattern matching 
explains result con partial evaluation pass kmp test tail recursive matcher 
binding time improvements 
traditional way improve result partial evaluation modify source programs 
modifications called binding time improvements semantics preserving transformations source program enable partial evaluator propagate information achieve deeper specialization 
consel danvy showed partial evaluators derive specialized kmp matchers insightful rewriting tail recursive matcher con improve binding time separation 
short rewritten matcher encounters mismatch successful comparisons starts comparing pattern gamma long tail pattern gamma successful comparisons return string 
words information propagation added matcher 
rewriting suffices deforestation produce kmp style matchers 
interpretive approach 
shown gluck jrgensen partial evaluators pass kmp test specializing information propagating interpreter respect tail recursive matcher fixed pattern glu 
supercompilation mentioned mechanism ensuring propagation information supercompilation driving 
shall concerned driving described glu language lists data structures 
moment think generalization rewrite interpreter unfolds function call replaces call body called function substitutes actual arguments term interpreted 
alternatively think environment interpreter creates bindings formal parameters actual arguments 
correspondingly imagine environment version basically supercompiler glu driving mechanisms positive supercompiler supercompiler glu identical respect propagation positive information assertions unspecified entities uses substitution environments 
technique environments advantage negative information restrictions represented bindings hold done glu 
technique substitutions possible 
significant difference environments substitution positive information 
applies supercompiler glu positive information propagation tail recursive matcher gets program produces applying full driving mechanism glu positive negative information propagation yields desired optimal program shown glu 
glu gluck turchin showed turchin supercompiler pass kmp test nested general matcher 
gpc gpc extends partial evaluation follows 
conditional equivalent testing predicate holds encountered transformation propagated true branch predicate propagated false branch 
test encountered theorem prover sitting top transformer tests branch possible 
possible branch taken 
gpc powerful transformation method assumes unlimited power theorem self application partial evaluation binding time analysis partial evaluator analysis gives better results environment version gives better separation static dynamic data 
prover 
shown fut information suffices pass kmp test tail recursive matcher 
supercompilation gpc related differ propagation information 
propagates arbitrary predicates requiring theorem prover supercompilation propagates structural predicates assertions restrictions atoms constructors 
takano gpc particular functional language viz 
studied original deforestation wad 
rule particular interest purposes 
case pn case pn fv sets equalities sets predicates manner described general terms fut concretely represent positive information arising pattern matching 
algorithm uses mixture substitution environment representation information 
need negative information language tak construct just functions language clause 
related substitution version case pn case fv pn pn corresponding rule deforestation case pn case pn modulo syntax step rule rule exactly step exactly step allows derivation kmp style pattern matchers mentioned briefly context language case constructs con 
compared transformation methodologies deforestation partial evaluation supercompilation gpc positive supercompilation new 
showed notions information propagation share differences amount information propagated significant transformations achieved methodology 
demonstrated positive supercompiler positive information propagation derive algorithm comparable efficiency matcher generated knuth morris pratt algorithm starting general string matcher fixed pattern 
deforestation partial evaluation achieve 
results strong evidence restrict application techniques developed field particular methodology 
contrary integration agenda 
direct comparison blurred different notations perspectives 
may bring different methodologies closer outlined 
grouped transformers amount information propagation 
classification criterion handling nested calls 
deforestation positive supercompilation turchin supercompiler simulate call name evaluation partial evaluators simulate call byvalue 
strength transformers depend transformers evaluation strategy 
instance known plain partial evaluation eliminate intermediate data call name transformers 
hand call name transformers including deforestation perform partial evaluation 
idea worthy investigation 
steps taken sor clarification needed 
related research includes idea deforestation cps translation call value partial evaluation 
second author occasions noted correspondence supercompilation interpretation logic programs 
correspondence stated quite precisely terms sld trees called process trees sor 
possible payoffs idea include application variety techniques community idea certainly worthy study 
connections supercompilation transformation particular partial evaluation logic programs 
situation functional case partial evaluators prolog derive kmp matchers general prolog matchers similar tail recursive matcher smi 
partial evaluators prolog propagate information unification way similar supercompilation 
possible gains detailed correspondence may significant 
aug augustsson 
compiling lazy pattern matching 
conference functional programming computer architecture 
ed 

jouannaud pp 
lncs springer verlag 
bon bondorf 
self applicable partial evaluation 
ph thesis diku rapport department computer science university copenhagen 
bur burstall darlington 
transformation system developing recursive programs 
journal acm 
vol pp 
chi 
chin 
safe fusion functional expressions ii improvements 
journal functional programming 
appear 
con consel danvy 
partial evaluation pattern matching strings 
information processing letters 
vol pp 
con consel danvy 
tutorial notes partial evaluation 
th acm symposium principles programming languages 
charleston south carolina pp acm press 
fer ferguson wadler :10.1.1.28.6971
deforestation 
glasgow workshop functional programming 
pp 
fut futamura 
generalized partial computation 
partial evaluation mixed computation 
eds 
ershov bjrner jones pp north holland 
glu gluck turchin 
application transition function inversion transformation 
proceedings issac 
pp acm press 
glu gluck 

occam razor metacomputation notion perfect process tree 
static analysis proceedings 
lncs 
pp springer verlag 
glu gluck jrgensen 
generating optimizing specializers 
ieee international conference computer languages 
ieee computer science press appear 
jon jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall international 
kle kleene metamathematics 
van nostrand 
knu knuth morris pratt 
fast pattern matching strings 
siam journal computing 
vol pp 
ses sestoft 
automatic call unfolding partial evaluator 
partial evaluation mixed computation 
eds 
ershov bjrner jones pp north holland 
smi smith 
partial evaluation pattern matching constraint logic programming languages 
acm symposium partial evaluation semantics program manipulation 
ed 
jones hudak pp acm press 
sor 
new means ensuring termination deforestation application logic programming 
workshop global compilation workshop conjunction international logic programming symposium 
vancouver canada october 
sor 
grammar data flow analysis deforestation 
algebra trees programming 
edinburgh scotland april appear 
sor 
turchin supercompiler revisited 
operational theory positive information propagation 
master thesis department computer science university copenhagen 
tak takano 
generalized partial computation lazy functional language 
acm workshop partial evaluation semantics program manipulation 
ed 
jones hudak pp acm press 
tur turchin 
concept supercompiler 
acm toplas 
vol pp 
tur turner 
overview miranda 
research topics functional programming 
ed 
turner addison wesley 
wad wadler 
deforestation transforming programs eliminate trees 
european symposium programming 
proceedings 
lncs 
pp springer verlag 
article processed macro package llncs style 
