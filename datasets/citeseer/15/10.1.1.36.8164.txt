component architecture software communication systems matthias jung ernst biersack institut eurecom route des sophia antipolis france mail eurecom fr proceedings ieee edinburgh scotland examine usefulness component software engineering implementation software communication systems 
architecture allows divide protocol software fully de coupled components plugged visual builder tools rapidly prototype flexible robust application tailored communication protocols 
show feasibility component protocol engineering demonstrating simple transport protocol realized 
discussion advantages impacts concludes 

general purpose transport protocol tcp years protocol choice popular applications telnet ftp problems tcp arose success 
new applications audio video streaming tcp completely unsuited 
belief popularity world wide web new technologies sun jini tm produce number distributed applications specialized diversified communication needs met optimum manner general purpose protocol tcp 
protocol implementation scratch expensive error prone important structure protocols way protocol elements re different contexts adapted special needs application 
additionally protocol implementations prepared change easy extend maintain 
emerged software engineering paradigm called component development cbd java beans tm active tm prominent representatives promises new dimension re usability rapid prototyping software compared simpler object oriented approach 
cbd fosters division software components easily configured plugged visual builder tools mark languages create new applications 
examine component software engineering useful implement network protocols 
rest structured follows 
section outline characteristics component software java beans component model 
section revise functionality typical endto protocol show protocol mapped independent components 
section demonstrate feasibility usefulness component protocol implementation framework prototype java beans 
section reviews related 
summary closes 

component software engineering 
definition souza define component development cbd approach software development artifacts executable code interface specifications architectures business models scaling complete systems small parts built assembling adapting wiring existing components variety configurations 
component usually characterized attributes ffl components largely de coupled independently developed delivered ffl components explicit specified interfaces services provide ffl components explicit specified interfaces services expects components ffl components customized composed components modification code cbd confused object oriented development ood 
stems fact ood seen adapted implementation technique cbd 
contrary object component provides richer range mechanisms higher degree re adaptability usually larger granularity 
component may comprise objects 

java beans component model java beans component model provided sun 
java beans written java programming language profits java portability 
java bean shortly bean java representation component java class object characterized elements ffl property named attribute may affect behaviour appearance bean maximum packet size time value 
ffl event stands possibly asynchronous data generated component window size changed error appeared fired event source delivered event listener 
ffl behaviour bean comprises methods accessible component public methods 
tool configure wire components identify properties events behaviour bean analyzing java code 
java class intends java beans compliant follow certain naming conventions properties identified method names start set get 
details see java beans specification 

visual builder tools components configured wired mark languages popular approach programming environments allow visual specification representation configuration components 
tool commonly referred visual builder tool 
visual builder tool visual implementation visual age java ibm 
build program visually existing beans arranged screen called visual builder window 
beans selected symbol name 
visual builder analyzes selected bean identify properties events methods 
shows properties modified window called property editor 

property configuration screen shot visual age establish event connections beans event source bean selected 
window opens show possible events raised bean 
selection event target bean selected 
window indicates possible behaviour showing accessible methods see 
target method needs parameters event object attached event connection 
possible parameters properties bean visual builder window 
run time time source bean fires specified event method target bean called right parameters 
design process terminated builder tool creates code information specified 
means writes values properties creates methods assemble specified beans creates methods represent event connections 

architecture component protocol structuring 
protocol 
sequence processing steps observed typical protocol 
application gives data protocol instance adds header information data performs computing operations changes internal state 
processing data sent fragmentation 
building event connections screenshot visual age network communication partner incoming message parsed de multiplexed right protocol instance 
message processed header information stripped state information updated payload data delivered attached application 
incoming message may trigger acknowledgment sent protocol instance may create new messages 
message processing may include checksumming checksum verification sequencing re ordering encryption decryption fragmentation state information may include flow control window sizes connection session state buffers information sequence numbers typical protocol functions provision timers handling time outs 
resume identified main tasks protocol ffl provision interfaces application ffl processing messages output direction normally adding header information ffl provision interfaces network ffl de multiplexing incoming messages ffl processing messages input direction normally parsing stripping header information ffl creation new messages 
map protocols components 
main goal flexibility referred possibility build variety protocols existing components 
granularity interface design important issues achieve flexibility 
traditional layered architectures tcp ip follow extremely coarse grained approach 
result layers software blocks high complexity connected simple way layers 
follow fine grained structure allows combine components flexible manner 
components configurable completely partially re usable different contexts 
re usability requires components largely de coupled knowledge type components interact 
important design goal provide autonomy components minimize context knowledge components 
architecture design elements map protocol functionality de coupled components 
discuss approach provides flexibility re usability 

design elements entry component encapsulates message header information sequence number window size data payload 
information represented forms byte array raw data written network object predefined type allow comfortable access processing 
entry type configured visible indicate transformed bytes processing 
entries need configured visible data written network application 
entry type configured indicate filled data processing starts data network application 
entries visible 
general case processing output direction entries visible data payload 
general case processing input direction entries data payload visible 
worker component encapsulates functional step protocol processing checksumming reordering fragmentation 
de couple format message processing worker operates directly entries message 
perform message parsing need know relevant information 
worker defines standard method accept data processed 
contrary classical layer worker provides processing output input direction enhance re usability 
standard data processing interface worker usually defines set properties events public methods communicate components 
order component defines data path thread protocol 
associates protocol graph ordered set workers header data ordered set entries 
main responsibilities 
firstly coordination protocol processing parsing data mapping bytes entries calling workers relevant entries 
secondly decoupling message creation message processing reifying data paths protocol 
instance worker task acknowledge incoming data messages need know data format message creates message processed 
just needs signal event activates order perform necessary steps 
third responsibility provision interfaces application network 
different order types distinguished interfaces application network 
order initialized application data referred acceptance order initialized network data referred reception 
order types parsing data considering entries configured 
order delivers processed data application referred delivery order writes processed data network referred emission 
order types transform entries configured visible byte arrays delivery emission 
orders created orders delivering emitting called internal orders 
emission reception orders specify information multiplexing de multiplexing respectively 
delivery acceptance orders provide application interfaces reading writing respectively 
name orders acceptable output orders orders deliverable input orders 
protocol environment replaces notion protocol stack 
comprising different layers protocol environment integrates protocol functionality particular distributed application needs 
technically environment component provides interface protocol implementors register orders 
initializes deactivates orders provides coordination various components 
anchor typical protocol task message multiplexing mapping messages different sources sink de multiplexing distributing different messages source different sinks 
may comprise protocol de multiplexing protocol type session de multiplexing protocol instance functional de multiplexing message order type 
layered architectures de multiplexing layer defines data path message 
order avoid main units re worker entry components involved de multiplexing concentrate outside protocol environment extra design element called anchor 
environment wants top anchor needs registered 
anchor obtains de multiplexing information various reception orders registering environment puts hash table 
incoming messages de multiplexed directly respective order 
protocol session order de multiplexing performed single hash lookup compromising re usability components 
events key mechanism hide implementation details component component interacts crucial provide re usability flexibility 
architecture provide types standard events 
order creation event signals intention creating new order 
notification event signals intention notifying components change state 
events normally raised worker components combined method parameterized property component 
sink order creation event order type triggers processing new message incoming data message triggers acknowledgment 
sink notification event normally worker incoming acknowledgment signals retransmission buffer space freed 
sap service access point represents access point network corresponding notion service access point iso osi layer model 
idea component de couple protocols dependencies underlying network 
sap implement ethernet access udp socket 
aai application access interface represent access point application 
distinguish read delivery orders write acceptance orders 
overview architecture relations design elements seen 

summary shortly resume architecture provides reusability flexibility perfectly fits component design paradigm 
workers entries application anchor order environment environment environment demultiplex 
architecture componentbased communication system ffl de multiplexing requires knowledge protocol specific information relevant information packet removed processing path message concentrated network anchor 
worker need know worker process message 
ffl parsing messages removed processing path message put orders 
worker need know message relevant information 
obtains relevant information entries 
ffl java beans event mechanism allows combine arbitrary components 
worker need know type workers interacts 
ffl input output processing separated different workers 
enables de couple sender receiver functions 
ffl message data path clearly defined orders 
worker creates new message need know format processing message 
ffl typical operations header fields easily re encapsulated entries sequence numbers 
changing header format changing byte byte sequence number requires just configuration respective property impact part protocol code 
java beans allows components represented icons 
see icons protocol components described 
internal worker data entry environment 
java beans symbols protocol components 
case study better understand approach describe simple example protocol ensures uni directional reliable transfer data 
show protocol structured concept exposed section 
protocol instantiated started connection protocol established connection sender application remote receiver application 
skip connection protocol concentrate data transfer phase 

example protocol connection established sender application writes byte stream form segments byte arrays protocol interface 
segment exceeds predefined length maximum segment length segment fragmented smaller segments 
segments gets sequence number checksum copied buffer written network 
timer maintained oldest segment retransmission buffer 
timer expires oldest segment queue retransmitted selective retransmission strategy 
receiver side sequence number incoming segment selectively acknowledge segment 
negative accumulative 
data duplicate delivered receiver application 
note protocol assure order delivery 
sender side incoming free buffer holding segment sequence number specified acknowledgment restart transmission timer data buffer acknowledged 
identification orders example protocol error control order workers sequencing checksumming checksum buffer emission entries checksum fragmentation order workers acceptance fragmentation entries retransmission order workers emission entries checksum ack input order workers reception entries checksum input data order workers reception acknowledging delivery entries checksum ack output order workers checksumming checksum emission entries checksum concurrent creates new order orders sender orders receiver 
identified orders example protocol error control order size original application data exceed maximum segment size sequence number checksum 
buffered sent network retransmission timer may started segment buffered 
functionality done thread 
corresponding order referred order 
header information needed order sequence number checksum field data payload application 
error control order ends sending data network 
type 
consists workers sequencing worker assigns sequence numbers data comes 
contains counter starts value represented beans property 
second worker calculates checksum arbitrary set data writes value entry representing integer 
third worker called retransmission worker operates sequence number array arbitrary data 
buffers maintains retransmission timer 
expiry timer retransmission worker fires containing sequence number data buffered 
needed entries sequence number checksum value data payload 
data payload marked sequence number checksum value calculated order processed 
entries marked visible written network 
fragmentation order application data exceeds defined maximum segment size fragmented smaller segments 
process fragmentation done thread 
corresponding order referred fragmentation order 
data processed order original application data result number segments size smaller maximum segment size 
fragmentation order processes data application type acceptable 
contains worker fragmentation worker takes array bytes input throws event new segment resulting fragmentation process 
maximum segment size specified configurable beans property fragmentation worker 
entry needed represents array byte variable length 
entry marked filled data order initialized 
need marked visible data delivered emitted 
fragmentation error control done thread different orders fragmentation results pieces data need individual processing sequencing buffering 
retransmission order retransmission timer expires oldest data queue including sequence number checksum data payload read buffer sent network 
operation requires thread order refer retransmission order 
retransmission order type define workers 
just takes sequence number entry checksum entry data payload visible error control order writes network 
input data order packet sent error retransmission order contains predefined de multiplex identifier associate incoming data thread input data order serves deliver data application 
delivery checksum verified check duplicate sequence number acknowledgment requested 
checksum correct data identified duplicate data anymore 
data payload delivered application 
input data order gets data network delivers application deliverable 
type input order 
ack order generated checksum verification worker checks value checksum field corresponds value calculated data 
duplicate check worker assures data delivered application 
checksum duplicate check lead dropping data payload delivered application 
entry fields sequence number checksum value data payload marked 
data entry additionally marked visible delivered application 
ack output order orders mentioned needed acknowledgment handling 
order called ack order sends message network contains sequence number acknowledged data 
ack output order type defines number entry 
checksum verification contains workers 
ack input order order needed called order notifies retransmission buffer segment sequence number acknowledgment deleted buffer 
ack input order type 
comprises workers verify checksum notify retransmission worker 
shows identified orders workers entries defined 
big arrows indicates order creates 
small double sides arrows indicate orders access instances variable ack order accesses retransmission buffer free data error control order wrote 

visual composition process workers entries implemented protocol built writing additional line code 
just select identified order entry worker corresponding symbol put screen 
connect workers entries orders special method implemented order bean allows register workers entries express parameter relationship orders environment 
configure properties workers maximum segment size fragmentation worker entries range sequence numbers visible flags entry orders de multiplex information reception orders specify creates order relationships connecting worker order create fragmentation worker creates error specify relation ship workers state updates entries workers sequence number entry acknowledgment order retransmission worker free retransmission buffer 
depicted screen shot building sender part example protocol 
shows protocol components relationships 

example protocol sender built visual age screen shot visual age running protocols framework initialization environment anchor registration orders entries workers allocation threads filling entries data executing orders transparent visual composer part implemented framework 
scope describe details runtime process framework 

experiences rapid prototyping testing dividing protocols small modules facilitates implementation significantly 
process configuring combining various components working application process minutes 
due guidance visual builder tool generated code robust 
clear structure largely simplifies testing debugging 
re usability protocol components reusable modification code 
entries applied protocol contexts applicability workers limited certain protocol families 
re usability orders rare case re usability complete protocol layers supported framework 
compatibility structuring approach may conflict specifications existing protocols centralized de multiplexing multiple header formats 
intent provide tool rapidly implement test new protocols re implementing existing ones consider compatibility major issue 

related protocol implementation explored field high number papers addressed areas related 
idea give application control protocols uses expressed clark tennenhouse called application level framing alf 
moving protocol code user space step direction 
experiences user space protocol implementations reported 
consequently adopts paradigm alf user space protocol implementation 
idea replacing general purpose protocols application tailored protocols requires ease implementation rapid prototyping new protocols 
protocol frameworks important tool assist protocol implementation providing implementation runtime support 
exist high number protocol frameworks different focus 
prominent kernel residing operating system kernel allows connect protocol layers standard interface 
acceptance object oriented programming paradigm lead number object oriented protocol frameworks 
comprises framework build protocols 
widely differs cited frameworks software engineering technology architectural concept granularity structure imposes 
majority protocol frameworks follow coarse grained layered structuring approaches 
advantages fine grained structuring modularization higher flexibility improved re usability serious performance degradation exposed malley peterson 
adaptive demonstrate higher flexibility fine grained modularity featuring dynamic configuration assembly protocols classified requirements 
bhatti overcomes problems kernel environment implement finegrained fault tolerance multicast applications 
java protocol framework uses fine grained object oriented approach facilitate protocol maintenance modification 
fine grained structuring requirement achieve main goal build maximum number communication software set re usable configurable components 
sense close cited follows fine grained structuring 
widely differs structuring concept programming comfort degree reusability protocol functions 
related structure protocol software goes back early eighties 
layering main conceptual approach structure protocols 
advantage layering reduce complexity communication systems hiding information different layers 
number problems regard layering identified inflexibility inefficiency unexpected side effects 
lot tackles efficiency problems layering 
clark cooper propose carefully break borders allow adjacent layers exchange control information 
clark atkins suggested apply vertical process models protocol software order reduce context switches 
renesse shows techniques header prediction packet filtering message packing significantly improve latency 
mosberger peterson unified optimization mechanisms ilp fbuf packet classifiers abstraction data path implemented dynamic path creation scout operating system 
intend mask performance problems layered architectures replace layering endsystems architecture supports complete re fine grained structuring high flexibility 
idea design element order related definition data path logical channel common sequence instructions complex system 
scout paths apply vertical process model optimize inter layer communication orders structure protocols goal supporting rapid visual prototyping new protocol implementations 
consider protocols structured implemented fast flexible manner considering protocols implemented optimize performance 
don know concerned component programming protocol implementation 
little related component software engineering system design 
kon component programming provide high configurability flexible operating system 
demonstrates usefulness component software engineering development middle ware systems 
concept de multiplexed architectures represented element anchor expressed tennenhouse implemented 

summary goal show component software technology excellent means rapidly implement application tailored protocols fully re usable configurable software components 
proposed structuring approach map protocols components provides fine granularity complete decoupling protocol functions message headers 
implemented runtime system follows structuring approach test run component protocol software 
simple transport protocol showed usefulness power simplicity implementation process 
see visual programming complex software network protocols feasible provides new dimension rapid prototyping programming comfort 
acknowledgment sponsored zt ik siemens munchen germany 
special sergio fruitful discussions helped clarify ideas 
atkins 
experiments sr different upcall program structures 
acm transactions computer systems pages 
bhatti schlichting 
system constructing high level protocols 
symposium pages aug 
biersack 
demultiplexing atm adapter experiments internet protocols user space 
journal high speed networks may 
seidel 
channels 
run time system multimedia protocols 

braun diot 
protocol implementation ilp 
proceedings acm sigcomm pages 
braun diot 
experimental user level implementation tcp 
technical report inria 
clark 
modularity efficiency protocol implementation 
request comments informational rfc internet engineering task force july 
clark 
structuring systems upcalls 
proc 
th acm symposium operating systems principles pages oakland ca december 
clark tennenhouse 
architectural considerations new generation protocols 
proc 
acm sigcomm pages philadelphia pa september 
cooper 
argument soft layering protocols 
technical report mit lcs tr mit may 
programming visualage java version 
number sg 
ibm 
crowcroft wang 
layering harmful ieee network jan 
druschel abbot peterson 
network subsystem design case integrated data path 
published ieee network 
souza francis wills cameron 
objects components frameworks uml catalysis approach 
addison wesley 
edwards muir 
experiences implementing high performance tcp user space 
proceedings acm sigcomm boston ma oct 
edwards 
core jini 
sun microsystems press 
johnson engel 
framework network protocol software 
object oriented programming systems languages applications conference proceedings oopsla 
acm press 
hutchinson peterson 
kernel architecture implementing network protocols 
ieee transactions software engineering jan 
jacobson 
bsd tcp header prediction 
computer communication review apr 
javasoft 
java beans api specification october 
jung biersack 
implementing network protocols java framework rapid prototyping 
proceedings portugal mar 
kon campbell carvalho moore ballesteros 
reflective component operating system rapidly changing environments 
ecoop workshop reflective object oriented programming systems brussels belgium july 
mccanne jacobson 
bsd packet filter new architecture user level packet capture 
winter usenix san diego ca jan 
microsystems 
component software javabeans activex 
white oct 
mogul 
case persistent connection 
proceedings sigcomm pages sep 
mosberger peterson 
making paths explicit scout operating system 
proceedings osdi pages oct 
malley peterson 
dynamic network architecture 
acm transactions computer systems may 
vogt modules building blocks protocol configuration 
proceedings international conference network protocols icnp sept 
braun diot 
architectures solution efficient streams communication stacks 
ieee networks magazine june 
schmidt box suda 
adaptive dynamically assembled protocol transformation integration evaluation environment 
concurrency practice experience june 

middleware toolkit software risc components 
phd thesis university illinois 
sun microsystems 
java virtual machine specification 
technical report 
tennenhouse 
layered multiplexing considered harmful 
rudin williamson editors proc 
ifip workshop protocols high speed networks pages zurich switzerland may 
north holland publ amsterdam netherlands 
thekkath nguyen moy lazowska 
implementing network protocol user level 
ieee acm transaction networking oct 
tschudin 
flexible protocol stacks 
proceedings acm sigcomm zurich switzerland oct 
van renesse 
masking overhead protocol layering 
proceedings acm sigcomm sept 
