functional languages graphical user interfaces review case study rob noble colin runciman coling york ac uk february sight pure functional language straightforward imperative languages 
years going alleviate problems number different approaches 
purpose report twofold firstly shall review problems encountered performing functional language look ways conquered secondly shall look solutions encompass graphical interfaces 
contents subject report structure report review functional program 
advantages functional programming problems functional solutions streams combining functions example calculator pitfalls continuations calculator cps systems history monads equivalence models graphical user interfaces fudgets system 
fudget combinators fudget law list processors layout example fudget application concurrent clean system concurrent clean 
strictness annotations process annotations concurrent clean unique types unq event example program case study fudgets developing fudget application advantages functional language fudget type testing fudgets classes hierarchy inheritance restrictions automatic layout problems naming message streams abstraction concurrent clean concurrent clean escher tile program efficiency missing syntactic sugar windows version compared macintosh version callbacks vs event polling loop global state restrictions dialog items lists id window objects widgets debugging generic functions access state assessing fudgets clean objects model devices objects composition objects address object type checked connections parallel behaviour static dynamic processes 
separation application interface behaviour full power fp update fudgets clean subject report report concerned functional programming graphical user interfaces gui 
historically functional languages viewed slow execute memory hungry 
years begun catch imperative languages terms execution speed memory usage hoped continue see improvement 
graphical user interfaces years considered normal expected computer systems home micros workstations 
benefits functional languages real world possible programmer provide user interface best able 
sight pure functional language straightforward imperative languages 
years going alleviate problems number different approaches 
chapter identify problems look ways solved 
satisfactory solution problems possibilities functional languages applications gui reach 
current solutions perfect alternatives proposed fairly regularly 
solutions number different cases interface functional languages graphical user interfaces usually windows 
attempts simple limited simulations methods imperative languages perform graphical interaction advantages functional languages 
systems emerge attempt approach problem specification graphical interface different angle functional languages better suited 
shall look detail 
current systems interfacing windows windows toolkit little thought mean shift functional imperative borderline window manager 
structure report section shall look problems poses pure functional language see solutions proposed 
illustrate examples weigh relative merits 
brief look graphical user interfaces functional languages look detail systems 
section look critically systems implement example application 
finish chapter listing features environment graphical applications measuring systems 
review advantages functional programming fairly known areas proved troublesome 
chapter shall start history functional languages move graphical interaction 
functional program 
functional program expression evaluated context set definitions definitions functions 
example function definitions add twice program consist expression twice add result program 
functions considered class citizens may passed arguments data type 
function defined certain number arguments arity evaluated arguments result function 
allows functions add takes number adds applies function times arguments normally take return type requires type correct 
value 
pure functional language important expression denotes value change evaluating evaluating expressions 
known referential transparency addition enabling advantages shall look allows functional languages lazy strict evaluation meaning expressions function arguments passed expressions evaluated value necessary 
lazy evaluation permits programmer define infinite data structures knowing evaluated far needed 
combined higher order functions provides powerful abstraction tool 
advantages functional programming simon peyton jones sums advantages functional programming article pj functional programs exceptionally concise absence side effects easier reason imperative counterparts offering interesting opportunities parallel execution 
bold sections indicate main advantages functional programming 
problems functional guess means obtain functional language functions getchar channel 
char channel identifier 
channel keyboard returns character channel 
function clearly referentially transparent identical applications may return different values different points computation 
function cause problems 
suppose function uses getchar read line characters keyboard returning string 
try evaluate elem getchar elem standard function returns true argument element second user enter character line 
arguments evaluated parallel character read middle reading line error occur depending contention keyboard channel handled 
possible circumvent problems enforcing rule example arguments function invoke evaluated left right order 
function uses function considered invoke suffer restriction 
effect propagate large portions program enforcing strict order evaluation losing benefits laziness 
solutions needed method maintains referential transparency 
look number solutions see relative advantages disadvantages 
solutions shall look ffl streams section ffl continuations section ffl systems section ffl history section ffl monads section 
streams lazy evaluation enable take user input argument return program output result 
laziness factor determines expression evaluated needed 
input argument output result consist lists characters streams element character output demanded sequence output driver 
type input char type output char laziness ensures output may interleaved input program batch program requiring user input producing output 
example consider function toupper char 
char takes character lower case letter returns upper case equivalent just returns character 
function interactive program streams uppercase input 
output uppercase map toupper map standard function takes arguments function list 
applies function element list produce new list result 
map 


map map xs map xs example map effect applying toupper character user enters displaying result 
example assuming terminal echoing user input buffering line line uppercase shoe shoe combining functions example simple 
complex interactive programs need higher order combining functions combinators glue basic building blocks uppercase 
combinators described tho 
shall look combinators thompson described 
firstly define slightly different type interactive function accommodate passing information blocks program type inter input 
input output interactive function takes input stream input user initial state type returns remainder input final state type output generated 
remainder input equals input list characters characters function uses start list 
combinator seq combines interactive functions actions describe occur sequence seq inter 
inter 
inter seq input initstate rest input initstate rest useful combinators include alt 
bool 
inter 
inter 
inter takes test function interactive functions acts function test applied state returns true acts second function 
combinator 
bool 
inter 
inter takes test function interactive function produces interactive function operates repeatedly test state evaluates true state returned function fed back function iteration reason input output state types labelled 
function apply apply 

inter apply fn inp val inp fn val takes ordinary interactive function fn turns interactive type input output applies fn state 
example calculator combinators defined create simple calculator 
user enters sum program responds total answer 
repeated user gets bored probably long time point user presses ctrl program finishes 
firstly save space avoid nested brackets define bit syntactic sugar seq may write example mean perform interaction followed interaction 
calculator program shown 
calc sequence followed calc 
function simply passes state integer zero representing initial total held calculator 
function calc followed followed followed choice depending operator read 
plus total passed back calc iteration total displayed continue original calculator zeroed total 
style fairly easy see flow interaction 

possible place debugging function blocks interaction outputs value part state enable programmer see value mid evaluation 
example see value total calc function changed calc debug alt calc calc debug show program changed state passed blocks encompasses information needed calculator type program seq combinator may changed display state block program need changed 
state containing values needed interaction likened global variables imperative program disadvantages hold 
pitfalls programmer needs aware problem described tho tho may occur lazy stream continuations systems models 
example suppose require program prompts user name replies hello rob name user enters 
name 
rob hello rob program written 
symbol represents null type state information passed interactive function 
function splitat takes character string returns strings front occurrence second rest example returned splitat line user input rest user input 
program executed displayed 
name 
hello rob rob streams calculator calc inter calc calc calc inter int calc alt calc calc inter int inter int int int rest rest inter int int int inter int int char rest op op rest int char 
bool inter int char int inter int char show atoi show standard functions convert integers strings vice versa 
input parsing functions return tuple required integer operator text echo screen output remaining user input parsing 
pitfall program prog inter prog ask read say ask inter ask name 
read inter string read splitat say inter string say hello required 
hello part output skipped ahead user input say evaluate hello part result needing user input 
done 
solved problem turning terminal echoing user input requiring program echo user types 
means user input program output appear output stream interleaving input output defined 
example read re written read inter string read splitat notice name returned final state returned output read 
important splitat constructs element result characters argument available character user input echoed return pressed 
thompson tho suggests solution 
wait function definition wait eq 
inter wait guard causes evaluated available final state wait interaction 
eq part type declaration context specifies polymorphic type eq class 
equality function defined type 
example program prog ask read wait say thompson proves traces tho combinators occurs correct sequence 
stoye sto solves problem extending streams model streams requests responses simply streams characters requires character input requested received response 
continuations alternative gluing functions interactive program continuation passing style cps described hm 
fact continuations useful forms functional program just interactive programs describe cps look non interactive example 
consider function add int 
int add num num continuation passing style function add int 
int 

add num cont cont num function takes additional parameter cont function represents rest program 
returning sum num rest program cont argument 
result cps function output generates appended output rest program 
add produce output result just output rest program result cont 
calculator cps cps output function calculator example int 
input 
output 
input 
output total cont inp show total cont inp value returned function total converted string standard function show appended output generated rest program 
calculator cps shown 
notice type calculator streams version 
function calc uses auxiliary function calc parameter start calculator zeroed total 
function calc reads integer user input continuation function adds number running total 
continuation reads operator user input passes operator continuation function passes total continuation displays total passes zeroed total continuation 
sight cps style may difficult understand 
types functions may complicated reveal information passed continuation function 
state consisting multiple parts need packaged tuple required streams combinators 
part separate argument continuation function 
systems system data structure representing state parts operating system relevant systems model function perform takes extra parameter system state returns extra value result system state 
dependency systems passed returned functions program defines order occurs 
systems model output function calculator example look type system string string system 
int 
system show continuations calculator calc input 
output calc calc calc int 
input 
output calc calc calc int 
input 
output calc calc int 
input 
output 
input 
output cont inp cont number rest number rest inp int 
int 
input 
output 
int 
input 
output cont num cont num char 
input 
output 
input 
output cont inp cont op rest op rest inp int 
int 
input 
output 
char 
input 
output cont op case op 
cont 
cont systems calculator calc system 
system calc calc calc int 
system 
system calc sys rest tot sys calc rest calc tot sys calc int 
system 
int system calc num num op op system 
int system num rest num rest system 
int 
int 
int system system 
char system op rest op rest system 
char 
int 
int system op case op 

system contains strings user input program output 
returns user input part unchanged adds total ascii form provided standard function show program output 
systems model looks similar streams model form identical 
systems model differs system type contain information system apart input output stream information relating window graphical terminal 
systems model calculator shown 
easy see order operations occur way systems returned functions parameters functions 
extra system parameters tend clutter program lazy evaluation necessary ensure correct order evaluation correct order interaction 
history fl language uses model similar systems model see bww hd similar system meta language function extra implicit argument returning implicit additional value history 
example function application fn implicit history explicit cause function application written fn history passed function altered history returned 
history represents history operations performed similar role system described 
dependency history functions specified program fl relies evaluation strict left right order ensure occurs desired 
result interactive programs fl cluttered extra history system parameters systems model strict evaluation applies program benefits laziness non parts program lost 
monads monadic model described wad wad jw consists functions represent actions combinators combine actions single action 
value interactive program action probably combination small actions executing program cause action performed 
action may return value way function may return value 
type action io type value returned 
example action function putc outputs character action putc char 
io action functions putc return useful value may return empty tuple null type 
simplest monadic combinators io io 
io 
io performing action results action performed followed action entire action returns value returned action recursive definitions terminate recursion 
corresponding combinators actions return value 
io io 

io 
io performs action returns value passed 
works passes value returned action second action returns value returned second 
io type defined type io world 
data world type world represents state system way system world hidden programmer dealt entirely combinators 
fact world type contains data enforce order occurs 
suitable transformations compiler avoids generating code manipulate world data generate code similar equivalent program 
monadic style calculator shown 
style calculator monad form similar streams continuations versions 
looking actions int 
int 
io int see world mentioned hidden inside action may considered advantage 
unboxed datatypes method calling language functions functional language io forced occur point action evaluated left resulting value action required normal lazy evaluation 
means synchronisation problems mentioned section occur monadic monadic calculator listed show definition 
parsing multi character token integer problem basic form monadic schemes looked function takes characters input stream non digit character reached point rest stream including passed function 
glasgow implementation monadic haskell compiler stream input characters character required read keyboard buffer directly call function function requested deal 
stream input characters pass character function 
possible call function push character back keyboard buffer keyboard buffering effect 
calculator example required keyboard buffering switched total displayed soon user presses pressing return possible 
alternatively world type changed carry lookahead character parsing functions 
real data contained world type compiler optimisations mentioned impossible 
course problems parsing backtracking experienced just imperative programs 
equivalence models hudak show hs streams continuations systems described equivalent expressive power 
may described terms 
streams systems described continuations primitive unavoidable space leak reason streams originally chosen primitive functional programming language haskell continuations provided higher order interpreter functions convert streams 
move monad primitive efficiency operation 
graphical user interfaces look briefly history functional languages graphical user interfaces look detail couple developments 
henderson functional geometry started ball rolling functional languages graphical applications hen 
describes way representing graphical pictures monadic calculator calc io calc calc calc int 
io calc 
op 
case op 
calc 
calc io int see note text int 
int 
io int io char 
case 


int 
io show string 
io foldr map nb 
full definition see note text 
data functions manipulating combining pictures 
applications interactive abstraction structure picture hierarchically 
arya took lead combined functional representations processes hen sto produce functional animation system ary graphical objects described processes may interact user 
number papers describe methods connecting functional language interpreter compiler graphical user interface 
singh describes interface functional language miranda sin 
explains technical method connecting unix sockets connect processes running miranda interpreter window manager look structure application written system 
system support callbacks equivalent program provides useful alternatives 
sinclair similar connecting language lml window system final year project sin 
system dialogue simplified subset client server dialogue communicated functional program window manager 
sinclair developed idea system interface programmed imperative language communicates functional language dialogue sin 
interface perform simple functions need communication functional side application 
erlang language language cml interface exene defining concurrent processes 
languages functional side effects pure functional languages 
papers consider structuring graphical application functional language 
defines combinator combines event processing functions possible events function recursively applied list input events generates list reactions 
defines similar combinator list events program respond changes iteration cater menus popping screen 
runciman fr similarly transaction combinators build applications lml mgr window manager 
currently carried carlsson working fudgets ch system described detail chapter 
van groningen plasmeijer working concurrent clean system avgp described detail chapter 
fudgets clean systems provide alternatives callback functions fudgets system turns callback events messages particular objects clean system functions similar callbacks passed global program state details event 
yale haskell compiler interface windows way monad unk giving access common lisp interface 
applications similar structure imperative equivalents event processing loops reid singh currently working connect haskell widgets rs extensions glasgow haskell allow called directly 
existing widgets 
defined imperative language call budgets resultant saving amount library programming needed 
fudgets system 
fudgets system ch graphical user interface gui toolkit window system written lazy functional language lml 
programmer may write graphical applications haskell lml utilising expressive power functional languages full 
review version fudgets version lml distribution 
toolkit uses idea fudget main abstraction functional equivalent widget imperative windows toolkits windows 
fudget may thought process normally associated object screen button menu communicates fudgets message passing 
fudget type receives messages type sends messages type shows representation fudget 
note message streams marked type messages convey type message stream list see remarks fudget law 
fudget high low events commands fudget type fudget streams high level messages low level messages 
high level messages application program convey pieces information part program integer entered box screen user low level messages take form window events commands event signifying mouse clicked box screen usually manipulated library fudgets 
fudgets hierarchical may combined fudget combining functions combinators form complex fudgets 
library basic fudgets implements host useful screen objects push buttons menus 
library fudgets deal low level messages occur fudget combinators deal routing messages correct fudget 
part fudgets regarded having low level message stream directly connected relevant object screen 
fudget high low 
button events commands low level messages effectively connected directly relevant screen object point onwards fudgets diagrams drawn showing low level stream necessary assumed low level messages routed relevant object screen 
application program consists single fudget governs entire operation 
essential fudgets may combined program defined inside single fudget programmer deal low level events high level events just described 
fudget combinators simplest combinator understand 
similar seq combinator textual described thompson tho 
best described aid diagram see 

remember showing low level stream assuming dealt combinator 
dashed line denotes fudget constructed combination fudgets 
fudget output messages type fudget expects receive 
combinator allow fudgets application connected long stream 

combinator allows fudget send message receive message fudgets sum type sum inl inr see 
inl inr inl inr sum sum 
fudgets combinators seen far may combine fudgets may send messages expressing 

see 
inl inr inl inr sum sum 

combine may receive messages 

see 
inl inr inl inr sum sum 

possible connect output part output fudget back input combinators 
family looping functions 
example applied fudget type sum sum produce fudget type left hand side output type looped back left hand side input see 
fudgets related screen object programmer may define fudgets connect fudgets direct effect screen display 
inl inr inl inr fudget law order combinators implemented need non deterministic merge details see ch fudgets obey rule known fudget law 
states message fudget receives emit item output stream 
restriction severe output stream fudget defined list lists messages fudget may emit message list empty list messages list messages 
list processors messages output kind fudget require fudget receive 
instance may fudget outputs numbers wish fudget receive english word equivalent 

case may define list processor alter messages way 
list processor type takes messages type converts messages type similar ordinary list processing function type 
type caters low level messages transforming high level ones 
list processor may prepended fudget process messages received combinator may appended fudget process messages sent combinator 
lp pre process messages arriving fudget list processor lp lp 
post process messages sent fudget list processor lp 
list processor takes list messages input returns list processed messages output similar form example shown converts strings tokens 
list processor fudget reads type token string token ms rest case start 


rest ms list processor textual commands file fudget performs action token receives 
message streams infinite need case 
layout layout set fudgets screen defined way 
simplest way fudget emit pseudo message defining position screen pair coordinates top left bottom right 
laborious task programmer calculate coordinates set fudgets tool place fudgets directly mouse 
tool currently development ahl 
alternatively fudgets system provides automatic layout mechanism 
programmer may request fudgets placed certain position relative 
layout mechanism place fudgets accordingly layout requests account 
decorated combinators automatic layout instance 
programmer 
syntax 
separation pixels fudgets requests placed 
similarly 
function 
example fudget application looked fair number tools available programmer 
example 
said library provided system 
system currently development final set library fudgets complete considerable number library 
introduce course example 
application program build simple counter 
buttons marked increase decrease number displayed box 
shows picture screen depict application 
buttons box displays number defined fudgets provided library called respectively 
button fudgets emit click message pressed mouse pointer 
integer displaying fudget displays number programmer gives parameter function replaces number integer receives message 
define pre processing function form list processor described go display keep current value state alter button pressed sending new state display fudget 
shows diagram fudgets list processor connected 
program example application shown 
simplified slightly removing function arguments specify automatic layout fonts integer aligned box keyboard shortcuts button 
example application counter count inl click inr click sum click click int fudgets example example fudget application main 

sum click click int count count ms count ms case inl click 
inr click 

chapter look larger application assess strengths weaknesses fudgets system 
concurrent clean system concurrent clean 
concurrent clean lazy functional programming language term graph rewriting pve 
review version clean system 
function definitions graph rewriting rules 
example definition function representing equation int 
int 
line indicates type function 
infix operators functions prefix notation 
nodeid referring graph node 
instance declare calculation done result shared right hand side definition 
note nodeid full counterparts clauses nodeid take parameter constructor left hand side order translate types possible haskell example data isint int 
int isint strictness annotations strictness annotations may function definition indicate function strict certain argument 
argument evaluated function rewrite rule applied 
enables efficient programs written 
strictness annotation consists character may appear type definition function affects reduction order applications function rewrite rule affects particular function application 
process annotations process annotations may added specify parallel reduction graphs 
parallel reduction currently supported macintosh sun implementations irrelevant gui applications 
concurrent clean concurrent clean answer problems pure functional language allow functions side effects controlled manner don cause problems encountered allowing object updated side effects shared parts program graph 
achieved unq type annotation 
unique types type unq annotation example unique state type type unq state 
int guaranteed programmer checked compiler single thread 
unique node accessible root graph path root function application contractum depending type left right hand side re write rule respectively 
example function definition programmer broken rule shared unique state type int 
state int 
function shown compiler cause error function claims return unique type part tuple state value calculated subgraph part graph 
calculating second part tuple returned 
unq unique type annotation declare world structured type containing environments represent state system 
library functions alter environments immediate side effect example output character happens safely unique type world environments guaranteed single thread accurately represents state system times 
unique guarantee possible anomalies occur different views world held separate parts program 
consider example file 
file file 
file part world type represents particular stored file function side effect writing character file 
function returns files correct 
regardless order parts returned tuple evaluated file wrong expects refer file containing old contents added expects old contents added 
reality file referred contain old contents ab ba added depending order parts tuple evaluated 
world type passed function required order interaction defined dependency world values passed functions 
non functions passed world type constrained particular order evaluation maintaining benefits laziness 
world files file file file events 
world type shows structure world type 
files environment provides access files available program 
library provides functions files environment enable files opened closed read written variety ways 
example program put text hello world file named greeting module test import rule start unq world 
unq file start world 
hello world files fopen greeting files files world world operates follows applied world environment passed program yield open files environment new world new world returned maintain uniqueness 
note simple example new world 
opened files environment fopen function open file called greeting writing returning open file environment new files environment maintain uniqueness 
lastly function takes open file returns file containing text hello world return value program 
event part world type state 
contains graphical devices windows menus stream events see 
devices window menu dialog events timer type event concerned manipulating devices files 
events occur mouse button clicked key pressed program defines response events 
response event defined large event handling function mapping event program state response new program state function quickly complex increasing program functionality possible state event combination considered 
concurrent clean system breaks problem parts having function individual screen object 
events automatically routed correct function program state state function returns new program state state 
function alters state library functions effect communicating response devices 
particular set structure devices application program defined complex hierarchical set data types 
event handling functions registered system placing data types 
data types contain options parameters example title text window 
device unique identifying number decided programmer may alter parameters event handler associated device 
allows instance menu selection alter behaviour icon button library function 
devices come groups menus windows dialogs timers 
look briefly 
information see 
menu presents list options user possibly hierarchy list 
option may enabled disabled function called option selected 
window various attributes example title resized drawn application primitive drawing functions draws line 
application provide function called system event occurs requires contents window 
dialog special type window obtain information user 
may contain buttons text entry boxes user defined controls sole purpose enable user set parameters options program 
dialog windows button pressed indicate user finished selection 
objects dialog window may placed explicitly placed relative dialog items 
number predefined dialogs 
file selector dialog enables user choose file scrolling list files directory 
dialog displayed apple symbol macintosh clicked main application window sun computer contains short description application program name 
notice dialog warn user example quit selected altered file saved 
timer may perform certain action time certain interval time passed updating display clock minute 
example program illustrate style application program concurrent clean develop small example screen picture shown 
application consist menus exit shape window 
window display circle square user may choose shape menu 
file menu contain choice quit exit application 
example different chosen demonstrate fudgets system system certain operations easy implement difficult example unfair comparison 
top level program defines global program state device components application module import type unq state 
unq io 
state rule start unq world 
unq world start 
file shape disp extracts list events world type passes initialises devices require application ensures events directed correct devices 
define menus file fileid file able quit able quit shape shape able able able example application shape menu may selected time 
parameter indicates circle option initial selection 
come back event handling function 
window definition follows disp shapes indicates window fixed size scroll bars 
pos initial position top left corner window screen dom rectangle defining size display area window 
function called window contents need displaying screen state 
state ua cur 
cur circle square circle square state 
state 

function attached shape menu items 
state remain unique takes shape id number new state argument converted state sh function int state io 
state io set io 
sh set io io io sh int 
state sh 
sh 
erases old contents window uses window update function redraw window new shape 
sh convert shape id relevant state passing state directly order keep state unique 
quit function id macro definitions quit state state 
state state quit io 
io macro fileid 







macros simple rule functions reduced compile time useful simple values computed compilation take memory reduced form 
chapter look larger application assess strengths weaknesses concurrent clean system 
case study section look fudgets concurrent clean systems 
look relative bad points making general observations 
fudgets developing fudget application fudgets system development application typically goes stages 
programmer knows required program decides appear screen 
shows blocks highest hierarchical level screen objects example application 
objects may composed screen objects 
program objects implemented complex fudgets 
application program similar escher tile pattern program originally written fr described detail section 
arrows indicate messages need sent objects 
choice design board tools connections screen objects application second stage development decide objects combined fudgets 
straightforward fudgets high level message path objects require message paths 
choice 
combine fudgets way multiple message paths object message path fudgets conveys messages tagged indicate original paths intended 
dotted lines show fudgets combined 
key indicates combinators 
id fudget identity simply passes messages receives 
fudget enable choice fudget communicate messages fudgets directly connected 
choice send message md design outputting inl md message mb board outputting inr inl mb message mt tools outputting inr inr mt 
note necessarily way fudgets connected 
choice arbitrary methods may unnecessarily complex 
combination design tools fudgets id fudget may factored function 
sum sum par id id mapf 
tools id choice board id design combining fudgets final stage development implement fudgets 
possible implement completely second stage connections established programmer may know example choice address fudgets connected sending messages 
programmer decides instance message stream required tools design connection process started 
better message connections changed easily 
tile program originally written exercise writing interactive programs functional language choice evaluating ease interactive applications may developed fudgets system 
shows picture application window 
choice tools buttons may pressed indicated shaded surround set form radio group 
may pressed time pressing button causes pop 
selecting tile tiles choice causes tile appear design area rotations reflections tile appear tools section 
clicking points design area left mouse button causes line added design 
similar action right button removes line design 
clicking button design updates current tile rotations reflections new design 
happens mouse clicked board area depends tools currently selected 
rotation reflection selected rotation reflection tile placed board position mouse clicked invisible grid board tiles placed 
rotation reflection tool selected clicking tile board causes rotate reflected 
board remembers rotation reflection placed position button beneath board clicked tiles board change tile design currently displayed tools section keeping orientation reflection 
operations instance clicking update button beneath board take longer complete action 
generally ones effect screen 
main fudgets application implemented sub fudgets master slave fashion 
master fudget fudget controls slave fudget receives sends messages rest program 
slave fudget representing display object kind connected master controlling fudget 
fudget escher tile program arrangement function basic library fudget integer displaying fudget may supplemented fudget 
example push button emits number starting zero increasing time clicked displaying number emit click 
show fudget connections required achieved 
functional definition fudget 
generate recursive fudget function step function describes fudget respond message 
definition fudget list processor messages referred high low constructor indicate type 
advantages functional language advantages functional programming available user system imperative systems 
development escher tile pattern example functional features useful class citizens functions may passed messages just data value 
fudget required manipulate state maintained fudget need receive state message maintain copy state order able change 
send state manipulating function applies function state 
alternative complicated 
send message indicating needs copy state order able change 
sends state message manipulates state sends back 
takes messages total compared message function passing version additionally requires message connection necessary function passing 
usual features functional languages available aid programmer 
function fudget example escher tile program generate recursive fudget function function representing single iteration 
map zip generate list messages replace grid tiles new set tiles 
imperative equivalent complicated 
int click int slave fudget master supplemented fudget connections int click int slave fudget master id int supplemented fudget components definition supplemented fudget int 
master sum click sum int int ms high inr high inl step case display button high inl 
snd step ms int click os os os ns el os nns ell ns nns el ell fudget type fudget type input type left output type right confusing fudget diagrams usually drawn input right output left 
simply drawing diagrams round way fudget combinators assume convention input right output left 
convention chosen match function application 
result application applied 
messages sent 
testing fudgets obeying fudget law fudgets emit list messages receiving messages black hole detected eval zap error occur 
easy thing forget implementing fudget resulting error message point directly cause 
development application useful able test fudgets plugging test rig see operate correctly 
fudgets relatively easy construct required test rig 
example suppose fudget tested emits message containing number indicating number letters word receives message containing word 
fudget tested connecting menu containing words simple construct library fudget input connecting output integer displaying fudget library 
test data may fired fudget selecting words menu display fudget checked see displays correct number 
fudget emits messages containing functions difficult test 
function displayed checking 
debugging wrapper useful 
placed fudget wrapper display messages entering leaving fudget border placed fudget object screen 
problem holds able display types messages easily 
wrapper available displays low level messages window fudget application executed 
classes hierarchy inheritance gui toolkits object oriented properties allowing screen objects grouped classes class inherit properties classes saving programmer duplicating objects common functionality 
whilst developing escher tile application see section fudget required displayed line drawings 
received new drawing message drawing replaced old 
variation fudget performs function outputs message containing button number mouse clicked drawing 
variation outputs message containing displayed drawing mouse clicked 
variations implemented separate fudget 
better solution generic fudget parameter specifies possible functions perform 
restrictions automatic layout automatic layout controlled fudget combinators layout specified point combining fudgets 
means fudgets may placed relative fudgets connected messages 
carlsson suggest ch alternative wrap group fudgets layout filter specifies layout fudgets contains removing layout information point fudget connections global position 
naming message streams ms inl inr inl inr inr rest ms case high tile 
selection selection rest selection sett illegal pattern matching case expression ms inl inr case 

problems naming message streams abstraction way improve way message streams addressed fudget declaration name streams appropriate names 
instance example choice fudget described previous section choice address design tools board fudgets sending message type inl inr inl inr inr 
declaration function implementing choice fudget clear see 
naming input message streams simple 
fudgets generally case expression input message processed patterns case may contain function names constructors 
definition example allowed 
concurrent clean concurrent clean escher tile program part learning evaluation process concurrent clean system escher tile program similar written fudgets system constructed 
shows clean escher tile program action 
user point view program function exactly fudgets version 
layout screen objects issue clean version separate windows design board choice tools areas 
support automatically combining areas single window specifying layout fudgets system 
concurrent clean application typically consists set state transition functions functions support 
transition functions attached events escher tile program pressing particular button called occurence event 
information passed returned function varies type event attached 
event caused window exposed supplies function update area part window exposed program state expects return new program state list drawing commands update screen 
example state 
state ua 
ns pic pic join grid dt dt ns expose event function design window 
extract current tile design program state returning design new unaltered program state 
drawing commands returned consist grid tile design magnified required size 
commands change size pen grid drawn thin lines tile design thick lines interleaved required places commands 
whilst writing program difficult small part program isolation 
mainly global state actions performed part program require effect window example clicking icon window requires drawing rotate window writing functions icon necessary know functions order effect rotation 
possible hide suitable abstraction instance message passing scheme fudgets system mechanisms provided part concurrent clean library 
efficiency able define graph function explicitly indicating exactly sub graphs shared enables finer control graph structure program 
addition strictness annotations function allow programmer produce efficient program 
cases strictness analysis phase compilation compute strictness required 
missing syntactic sugar words page concurrent clean language manual concurrent clean originally designed intermediate language arbitrary eager lazy functional programming languages 
lot syntactic sugar languages haskell missing concurrent clean leaving bitter 
list comprehensions infix operators clauses class system different functions type 
redundant brackets cause error compilation 
syntactic sugar promised final version compiler 
windows version compared macintosh version concurrent clean system originally implemented macintosh computers ported sun running windows 
macintosh computers pull menu bar top screen application visible applications running windows usually windows pop menus accessible possibly different menus available different positions window 
concurrent clean applications windows display small window execution containing dialog displayed apple symbol menubar macintosh clicked button menu heading menu bar 
sub menus accessed clicking mouse menu button required menu heading button 
addition set menus accessible window belonging application hierarchical set menus 
advantage concurrent clean windowing applications immediately portable sun macintosh computers disadvantage style applications sun machines match non concurrent clean applications 
macintosh keeps multiple menu bars applications tidy displaying time top screen switching icon top right screen 
sun running multiple applications result small windows containing menu buttons screen 
callbacks vs event polling loop style programming applications graphical user interfaces event polling loop program requests event os services event going back 
style register event handling functions os called certain events 
systems event polling loop possible events catered polling point functional language common event responses may factored away suitable abstraction 
functions event handlers device callback functions writing applications windows 
advantage registered system forgotten 
disadvantage screen object access information system passes event occurs information related objects 
concurrent clean system global program state state passed event handlers exceptions user defined controls dialog passed dialog state radio buttons check buttons 
global state event handlers exceptions see section passed global program state system state details event occurred 
state associated part program accessible event handler gives flexibility poor localisation 
best define set access functions program state pattern matching function uses part state 
state needs extended functions changed just access functions 
consider example state application allows user enter string keeps track times user changes unq state 
int string access functions unq state 
int unq state 
int unq state 
unq state 
unq state 
string unq state 
string unq state 
unq state ow 
get access functions share part state part returned tuple individual part state unq type 
entire state value returned access functions order keep state unq type 
restrictions dialog items datatype defining dialog contains list dialog items 
dialog items screen objects buttons controls kind 
leaf nodes description interface composed form complex dialog items 
event handler dialog items control user definable screen control group items text button selected time checkboxes number buttons may pressed passed dialog state may alter dialog part 
caused problem trying implement radio group similar drawings text required selecting drawings immediate effect picture window 
rinus plasmeijer concurrent clean development team explains reason done enforce specific behaviour application dialogs 
dialog finished final button pressed 
dialog open effect allowed dialog 
concluding library certain behaviour applications forced 
force kind definitions rigid behaviour 
certain advantages mac way disadvantages give freedom programmer private communication email strange event handler may affect global state state event handler user defined control radio group check group may 
way composing dialog items instance group combined dialog item useful 
possible construct user defined dialog items scratch control type re items defined 
lists id screen object referred id number 
id usually defined macros give meaningful name example macro 




nuisance maintain lists id numbers 
better way referring objects relationship object owning current event example icon clicked event handler close window icon contained 
window objects widgets window device allows windows drawn primitive drawing commands line drawing 
support defining sort widgets predefined screen objects certain behaviour 
obviously programmer suitable function define screen object behaviour response events shouldn part standard library save programmer time applications similar feel 
debugging advantage having global program state possible insert combination window device timer device program purpose displaying program state programmer defined way separate window seconds arbitrary 
similar debugging function suggested streams model page 
aid debugging process trying trace problem occurs midway event processing 
stable states events change event easy view debugging window program goes states processing event middle states easy trap 
generic functions access state general function written say implement group radio buttons suggested buttons needed store information program state necessary declaring instance radio group pass state access functions access state particular instance group 
instance radio group access fixed part global state possible multiple instances group application program 
assessing fudgets clean section look desirable features environment develop applications graphical user interfaces measure fudgets clean systems 
aims follows 
want ffl able build graphical user interfaces functional style functional application programs quickly easily ffl construct interface model closely relates user view 
clicking icon causes particular action performed event occurs mouse enters area screen ffl interface constructed building blocks objects may re similar situations 
library standard objects provided may build complex objects new objects may built scratch ffl objects local state need 
ffl devices appear objects similar library objects internal workings connected computer hardware 
give conformity system interface constructed objects ffl behaviour objects response input objects user device object defined functionally 
definition object deterministic maintain referential transparency 
system objects non deterministic uncertainty order events triggered user outside factors 
look related issues see advantages bring extent fudgets clean systems support 
objects model advantage interface model objects interact may screen representation closely linked model user interface 
ffl fudgets objects capable input output behaviour defined dependent messages input 
restricted way may interconnected 
events messages called fudgets system default hidden fudgets specified aids locality reduces freedom interaction 
fudgets may local state held parameters recursive function defines fudget 
state combines behavioural rendering aspects object 
ffl clean leaf element represents object 
event handler defines behaviour object object state held global state parts behavioural state maintained program state rendering state maintained 
devices objects presenting devices objects similar program library objects relationship way objects interconnected way objects relate user interface 
example object representing icon screen may request mouse object send mouse click messages rectangle screen 
icon subsequently moved removed 
request mouse object change screen position details 
example text entry object claim keyboard object whilst mouse reported pointer text entry rectangle 
ffl fudgets devices represented objects send low level event messages fudgets program receive low level messages sent fudgets 
route event message takes closely tied way fudgets connected operations moving icon position screen making fudget respond mouse events mouse fudget area screen difficult impossible implement 
ffl clean allow new os objects menus windows constructed built data types define devices application 
events triggered devices call preset functions choice determined static structure program set initialisation application program 
composition objects able compose objects easily flexibly enables form complex objects facilitates re common components saves time effort 
ffl fudgets combinators fudgets may composed variety ways form complex fudgets 
ffl clean hierarchy device objects fixed number levels 
example dialog buttons composed form complex dialog items 
address object require objects may combined internal interaction components object invisible outside world provide means breaking function application manageable hierarchical levels 
require locality definition independence specification words want able define general purpose object knowing interfaces surroundings connected 
order object communicate sender refer intended receiver form address 
identify ways specifying address ffl local relative address 
form address object specified relative sending object 
address object left object left need mean object screen left object screen means object expecting message addressed left 
form addressing useful defining general purpose objects decided definition complete 
ffl global absolute address 
kind address takes form unique identifier 
example address object called mouse pointer 
confusion arise object particular identifier intended means communicating message object 
type addressing useful objects communicate os devices mouse pointer general purpose warning box window object 
unique kind meaning word concurrent clean type annotation ffl fudgets limited kind local addressing 
fudget send message fudget connected output receive message fudget connected input 
communications fudget arranged intervening fudgets handled inside fudgets combinators 
programmer arrange connections complicated task difficult modify 
fudgets address os objects form global addressing address application fudgets method 
messages os objects fudgets routed combinators correct fudget equivalent global addressing 
ffl clean event handling functions equivalent global addressing os objects communicating application objects 
application objects global addressing communicate os objects calling library functions object id argument 
application objects communicate leaving messages global state 
direct way awaken receiving object fact message waiting state 
indirect way cause os object application object event handler call event handler 
local addressing simulated program requiring extra effort part programmer 
type checked connections want composition objects statically checked sure objects joined capable engaging common set events 
help proving program complete possibility message sent object response 
prevent object giving wrong response 
ffl fudgets connections fudgets checked see messages type communicated 
message stream fixed type possibly sum type necessary programmer define new sum type required combination message types 
haskell constructor names unique types defined causes problems sum types common element different name 
programmer define sum type types messages sent type subset types required effectively disabling type checking messages 
better system allow set types communicated objects 
haskell existential types provide means aug kon 
ffl clean communications happen global state 
type checking stage compilation check functions replace state type correct part state may accessed checks state intended programmer 
problem partly addressed dialog items granted access dialog state part part state 
parallel behaviour want objects behave conceptually operate parallel 
instance object may updating screen time responding mouse clicks 
brings advantage need concern order evaluation affecting interaction 
ffl fudgets model states fudgets processes operate concurrently reflected definition 
implementation currently support parallel reduction carlsson ch discuss possible method achieving concurrent operation fudgets changing underlying implementation 
syntax fudget definitions combinations specify kind ordering evaluation 
ffl clean concurrent language concurrency implemented architectures gui interface 
global state required event handler called unique type 
single thread state transition complete commence possibilities parallelism interactive functions program 
static dynamic processes 
system static processes number processes determined compiletime system dynamic processes processes created execution program 
system static processes may simulated dynamic system vice versa dynamic system general choice 
ffl fudgets fudget processes determined compile time limited support dynamically creating new fudgets restricted way 
ffl clean new objects menus may created assigned event handling function corresponds process object 
rest program learn new object identifier order interact global program state 
separation application interface behaviour separating interface application bring benefits 
factoring common interface tasks applications reduce workload application programmer whilst providing level device independence abstracting application notion interface away actual hardware 
separate interface may tailored user needs affecting application 
duke harrison dh model separation application interface twolevel model interactors 
model features communicating parts graphical interactor define state application rendering screen 
advantageous application interface separated separately executed task host computer similar way server host windows application 
way interface may changed re linking application code possibility applications running concurrently 
ffl fudgets way separate application interface fudgets object visible concrete fudget rendering fudget application state 
rendition interface defined library bound application compile time linking 
similar master slave technique described page 
restrictive way fudgets may interconnected technique difficult 
ffl clean rendering objects menus buttons built system changed 
small amount scope defining state rendering user defined type dialog item limited retrieving information user dialog 
full power fp able tools abstraction higher order functions laziness definition objects combination objects 
definitions example want able abstraction things generating list drawing primitives definition picture 
object definitions concise clear typical functional definition algorithm 
combining objects example zip list objects list arguments objects connect chain fold list object combining function 
define higher order function takes list type object may selected user forms radio group objects selected time selecting new object previous 
ffl fudgets fudget definitions higher order functions map concat effect generating lists messages example alter drawings set fudgets 
combining fudgets fudget combinator may fold list fudgets instance 
ffl clean event handling functions abstraction get away primitive drawing commands lack direct communication application objects obviates need higher order functions generate messages 
opportunities abstraction outside definitions objects system lacks combinators composing objects 
fudgets clean systems meet ideal requirements respects fall short aspects 
combination locality object definitions fudgets system flexibility communication clean system improvement leave open question interface separation application abstraction event streams os objects 
table summarises aspects listed section fudgets clean objects model fair devices objects events tied object events tied interconnection structure object hierarchy composition objects general restricted inflexible object addressing limited local limited global type checked connections state accessing functions parallel behaviour conceptually interaction sequential static dynamic processes limited separation programmer power fp room improvement update whilst working review case study authors fudgets clean systems improving refining systems 
fudgets construction fudgets stream processors programmed continuation style possibility breaking fudget law 
clean latest developments clean system available allow specifications combined applications may behaviour state windows 
groups communicate non clean applications 
copy pasting applications 
current aimed allowing programmer define devices able raise events execute programs network computers 
ahl ahlberg 
graphical user interface builder fudgets library 
proceedings pmg winter meeting january 
ary arya 
processes functional animation system 
fpca conference proceedings pages 
ibm watson research centre 
aug lennart augustsson 
haskell user manual july 
draft version 
avgp van plasmeijer 
high level specification functional languages 
fifth annual glasgow workshop functional programming ayr th th july july 
armstrong williams virding 
concurrent programming erlang 
prentice hall 
bww backus williams wimmers 
fl language manual 
technical report ibm almaden research centre 
ch carlsson 
fudgets graphical user interface lazy functional language 
proceedings pmg winter meeting january 
dh duke harrison 
interaction objects 
technical report hci group dept computer science university york 

synchronising behaviour functional programs feedback 
information processing letters december 
andrew 
functions dynamic user interfaces 
proceedings conference functional programming languages computer architecture imperial college london pages 
fr runciman 
escher patterning graphical interaction functional style 
pages 
hd hanna neil 
computational logic algebraic approach 
technical report faculty information technology university kent canterbury may 
hen peter henderson 
functional geometry 
conference record acm symposium lisp functional programming pages 
hen peter henderson 
purely functional operating systems 
darlington henderson turner editors functional programming applications 
cambridge university press 
hm hayes 
imperative effects pure functional language 
technical report hewlett packard laboratories memo hpl isc tm august 
hs hudak 
expressiveness purely functional systems 
technical report yale university research report yaleu dcs rr dept computer science december 
jw peyton jones wadler 
imperative functional programming 
proceedings principles programming languages popl 
acm press october 
kon konstantin laufer 
polymorphic type inference data types 
phd thesis department computers science new york university new york city 
donnell 
dialogues basis constructing programming environments 
sigplan notices 
perry 
concurrent object process oriented functional language 
proceedings th australian computer science conference pages 
australian computer science communications january 
issn 
pj peyton jones 
uk research functional programming 
serc bulletin 
peyton jones launchbury 
unboxed values class citizens non strict functional language 
hughes editor functional programming languages computer architecture pages 
springer verlag lecture notes computer science august 
pve plasmeijer van eekelen 
functional programming parallel graph rewriting 
addison wesley 
rs alastair reid singh 
budgets cheap widget combinators progress 
glasgow workshop functional programming ayr july 
university glasgow 
draft proceedings 
sin duncan sinclair 
graphical user interfaces functional languages 
technical report dept computer science university glasgow may 
sin singh 
miranda 
proceedings fourth annual glasgow workshop functional programming th august pages august 
springer verlag 
sin sinclair 
graphical user interfaces haskell 
proceedings fifth annual glasgow workshop functional programming ayr th july pages glasgow 
sto 
implementation functional languages custom hardware 
technical report university cambridge computing laboratory december 
sto stoye 
message functional operating systems 
science computer programming 
tho thompson 
writing interactive programs miranda 
technical report computing lab university kent august 
tho thompson 
interactive functional programs method formal semantics 
technical report computing lab university kent november 
took 
surface interaction separating direct manipulation interfaces applications 
phd thesis dept computer science university york july 
roger took 
active medium conceptual practical architecture direct manipulation pages 
workshops computing 
springer verlag may 
unk author unknown 
yale haskell interface preliminary version 
technical report yale university 
ftp nebula cs yale edu pub haskell papers 
dvi 
marko van eekelen huitema eric smetsers rinus plasmeijer 
concurrent clean language manual 
technical report university nijmegen february 
ftp ftp cs kun nl pub clean clean doc 
wad wadler 
comprehending monads 
proceedings acm conference lisp functional programming pages 
wad wadler 
essence functional programming 
principles programming languages 
acm press 

