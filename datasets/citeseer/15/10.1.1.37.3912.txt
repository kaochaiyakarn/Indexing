proofs concurrent objects computations fill framework galmiche cnrs inria lorraine campus nancy cedex france mail galmiche loria fr 
major approaches model concurrent computations logic 
context aim achieve dioeerent forms programming logic object oriented concurrent ones logical language 
linear logic suited describe computations concurrent state transitions 
propose analyze framework full intuitionistic linear logic fill logical fragment potentialities non management foundation concurrent object oriented programming paradigms proof search computation proofs computations 
exists approaches model concurrent computations logic object oriented programming 
logic programming allows write executable speci cations object oriented programming allows build complex structures possible challenge consists nding approach mixing logical framework various forms high level reasoning 
representation object mechanisms suitable logical language provide clearer semantics 
trying context adequate logic represent specify concurrency interesting non complete challenge 
linear logic ll suited describe concurrent sequential computations state transitions combining constructive character ner control resource management 
recall dioeerent ways model concurrent computations fragments linear logic 
rst formulas types proofs programs paradigms propositions interpreted types proofs programs proof normalization processes computations 
main works devoted term assignment intuitionistic linear logic ill classical ll including proposals concurrent functional programming languages :10.1.1.16.2984:10.1.1.31.8467
second way formulas states proofs computations paradigms connections petri nets linear logic investigated 
correspondence ill petri nets illustrates interest proof proceedings workshop object parallel distributed computation tokyo japan lncs pp springer verlag search methods proving specications synthesizing programs distributed systems 
third complementary way proof search computation paradigm leads works logic programming concurrent logic programming fragments ll 
previous approach proof construction essential need eoecient proof search methods logic consider example specic proof schemas uniform proofs canonical proofs :10.1.1.36.8019
proposals rewriting logic model concurrency theory concurrent objects 
fact main goals 
rst motivate interest fragments ll concurrent object programming example process calculus basic mechanisms logical level 
point leads question logic representing main programming mechanisms interest clear semantics insert new operator dedicated mechanism logic impact proof search 
second main show full intuitionistic linear logic ill adequate logical foundation framework involve object oriented concurrent logic programming previously mentioned paradigms illustrate ability represent non dioeerent levels messages process proof search context concurrent systems specication 
section recall concepts concurrent computations linear logic fragments focusing basic ideas inside computation model multiple processes 
section ill fragment 
intuitionistic linear logic ill includes multiplication disjunction par denoted formalized sequent calculus multiple familiar notation kind parallel process 
section analyze dynamics ill proof search potentialities non concurrent programming 
analysis proofs computations approach consider section dioeerent way proof search computation 
propose new framework ill viewed extension cpl having common features acl 
concurrent computations described terms proof construction process calculus logical representation concepts communication parallel composition 
logical system corresponding calculus obtained applying proof normalization process :10.1.1.36.8019
section illustrate main point compared proposals logical level non operator 
system able important concepts concurrent object programming 
framework allows representation rich mechanisms concurrent object programming described pure logical form exhibit attractive features concurrent programming languages providing mechanisms object oriented concurrent computing inheritance information sharing creation 
section show framework allows model systems dynamically modify state perspective proofs computations illustrate ability represent objects methods similar way frameworks 
complete emphasize interest concurrent object programming consider paradigm extended non deterministic petri nets prove reachability problem states net corresponds provability fragment ill linear logic concurrent computations linear logic ll recognized relevant computation issues especially concurrency state change 
outline main characteristics ll formal system appendix sequent calculus point view ll seen substructural logic contraction weakening rules discarded order assumption spent exactly considered computational resource 
lack rules conjunctions omega times disjunctions par phi plus 
modeling concurrent computations ll analyze operators viewpoint concurrent computation 
omega rule means process connected omega decomposed parallel processes environments dioeerent 
rule means process connected executed alternatively 
ll characterized new implication gammaffi called linear implication gammaffib means obtain consuming modalities allow reintroduce notions weakening contraction ner way 
cut elimination cut rule seen communication process process mind linear logic fragments naturally deal properties concurrent distributed systems logical frameworks represent computational resources communication state transitions concurrent execution 
major approaches model concurrent computation fragments linear logic 
approach formulas types programs paradigms propositions interpreted types proofs programs proof normalization process computation proposals concurrent functional programming languages 
approach formulas states proofs computations connections petri nets linear logic investigated 
investigated dioeerent way context logic programming 
mention works linear logic programming concurrent linear logic programming object representation forum proof search computation programming paradigm 
proposal focuses approaches modeling concurrent computation 
main concepts concurrent programming concurrent programming languages asynchronous communication important massively parallel processing environments programmers need formal frameworks concurrent computation help transform verify prove concurrent programs 
framework computation described terms proof construction ll knowing inference rules formulas ll restricted restricted rules proof power equivalent original rules restricted formulas 
mechanisms concurrent computations mainly described purely logical form 
recall simple points linear logic concurrent programming 
details obtained 
consider computational model multiple processes perform computation communicate asynchronous message passing 
message disappears having read process consumable resource 
natural represent message formula atomic linear logic 
consider processes 
process waiting message behaves reception consumes produces interpreted linear logic implication gammaffib 
process represented formula linear logic 
consumption message process gammaffib represented deduction considered processes messages environment 

interpret connectives classical logic 
example classical logic deduce implies original message process may remain message reception 
point sender communication asynchronous 
fact message synchronous consumed produced 
try interpret connectives ll 
omega means process process time concurrent processes omega represents concurrent computation 
consider time 
obtain consider predicate logic knowing atomic formula interpreted message carrying value predicate communication channel mean fact represents process receives value message 
represents possibility hiding private name 
variants express communication 
example receives message rst argument matching realize generative communication linda 
consider link proofs process reductions 
possible interpret provable sequent result process reduction 
example gammaffi gammaffi provable viewed reduction process 
cases appears possible characterize sequents corresponding process reduction provable ones left rules conjunctive case 
obtain correspondence propose choices concerning limitations rules application 
fill full intuitionistic linear logic full intuitionistic linear logic ill intuitionistic linear logic ill includes multiplication disjunction par 
problems arise interaction par linear implication term assignment system gives interpretation proofs kind non deterministic function 
system enjoy cut elimination property direct result analysis categorical semantics 
proof system soon try incorporate multiplicative disjunction par logic forced consider traditional sequents hypotheses 
ill par denoted dioeerent ll 
formalized sequent calculus multiple comma righthand side turnstile vertical bar familiar notation kind parallel process 
easy give satisfactory account computational meaning proofs term calculus ill give interpretation terms processes 
innovation system introduce considering sequents hypotheses term assignment system term calculus properties circumstances 
rules proof system id gamma delta gamma gamma gamma delta cut gamma gamma delta gamma gamma delta exl gamma delta delta gamma delta delta exr gamma delta gamma delta gamma delta gamma delta gamma gamma omega omega gamma delta gamma delta gamma gamma omega delta delta omega gamma gamma gamma gamma gamma delta delta gamma delta delta gamma delta delta gamma gammaffib delta delta gammaffi gamma delta gamma gammaffib delta gammaffi gamma delta gamma delta gamma phi delta phi gamma delta gamma phi delta phi gamma delta gamma phi delta phi gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta delta gamma delta gamma delta gamma delta gamma delta dl gamma delta gamma delta gamma delta gamma delta proofs programming fill intuitively natural investigate logic model concurrent programming logic 
considering term calculus ill remains give satisfactory account computational meaning give interpretation terms processes 
goal consider logical foundation framework involve objectoriented concurrent logic programming illustrate ability represent non dioeerent levels messages process proof search context concurrent systems specication 
concurrent programming point view consider complementary directions study proof search results ill main paradigms proof search computation proofs computations 
cases proof search management linear logic central approaches concurrency logic concurrent programming 
specialization results proof search fragments ll dedicated ill dynamics proof search fill known linear logic provides natural encodings state transitions systems instance extended petri nets 
main point consists proving equivalence reachability problem nets derivability problem corresponding ll fragment 
classical net denition describe dynamic aspects behavior understandable encoding proof search ill 
example consider token net know place introduce don know nondeterminism place token naturally represent logic 
classical token representation behavior available 
start illustrate dynamics ill informal denition extended petri nets called focusing proof search process 
denition 
place associated literal grammar omega atomic formula 
static structure transitions represented set proper axioms form formal system cut rule 
tokens resources represented expressions grammar tk tk tk tk tk omega tk tk atomic formula 
dynamic aspects net directly appears proof search process ill system 
rst example consists considering transition token produce token means token token know 
fact proof sequent ax ax ajb ax gammaffi dl observe transition res produce token place exists token place token place time 
means token exists places proof represents behavior system including non determinism 
consider specic signicant example illustrate interest logic specify behavior concurrent systems 
study instance philosophers problem case philosophers fork 
philosopher eat ea gets fork left hand hl gives fork philosopher hands hr hl know 
philosopher eats puts fork left right hand side randomly 
problem specic non determinism know fork philosopher gives fork 
net represent problem translation clauses ill proof search model situations 
set transitions proper axioms linear theory lt composed hl ea ea hr hl hr hl hr hl ea ea hl hr hr hr hl 
transitions expressed system including cut rule general form replaced expression clause gammaffiq system cut rule 
fact proof encodes behavior evolution system consider example hr hl formula initialization means fork right hand philosopher left hand philosopher 
non determinism system change dioeerent ways correspond dioeerent proofs sequent hr hl sigma sigma 
help understand happen system behavior fact observe ff philosopher eat fi philosophers take put fork eat fl eat 

proof 
system constraints concrete problem reality 
proof construction actual representation happen system 
build proof pi hr hl sigma sigma step proof construction process 
consider subproofs pi pi dened pi hl gamma ax hr hr hl ax hr delta hl ea ax ea delta ax hl delta cut hr hl gamma hr gamma cut hl hr sigma pi hl ea ax ea sigma ax hl sigma cut obtain pi hr hl hr ax pi hr sigma cut pi hr hl sigma sigma ax corresponds proper axiom theory issued translation ill fact sigma sigma sigma sigma gamma gamma gamma delta delta proof choices 
example gamma hl possible choice choose ea corresponds fourth transition proper axioms 
way xed choices instantiate delta hr delta ea sigma ea choices sigma sigma hl proof possible cut ea fact claim proof encodes process states depending branches proof 
instantiation choice go branch proof 
adapted instantiation evolution system encoded ill look branches proof system terminated fork left hand philosopher fork right hand philosopher philosopher eats philosopher eats 
able recover way leading states adequate branch proof 
fact build proof sequent hr hl ea sigma mind force construction proof branch encoding process leads philosopher eat 
concurrent logic programming language fill consider connection linear logic concurrent programming proof search computation paradigm 
approach computation regarded controlled deduction underlying logic linear logic languages proposed logic programming new concurrent programming languages 
concurrent linear logic programming propose naturally models message passing style asynchronous communication messages processes represented terms linear logic formulas 
important choices design want propose concurrent logic programming language directly results proof search design language automated theorem prover 
point consists concurrency logical framework process calculus formulas considered processes proof search construction process reduction 
fact important point choice logical fragment need time eoecient proof search strategies ability interesting systems 
example logical connectors interpretation process calculus 
recall logical fragment ll general method normalize proofs design proof search strategies :10.1.1.36.8019
purpose need nd compromise ability eoeciency execution framework 
depends syntax formulas chosen express clauses goals degree normalization want knowing want keep non execution 
works proposed adequate frameworks depending linear logical fragments cll ill specic proof forms uniform proofs canonical proofs 
main point proposal consists understanding interpret proof construction process reduction propose adequate calculi purpose 
proposal complementary aspects propose syntactic form formulas sequents interpretation state changes process normalize proofs fragment propose new formulation deductive system 
goals consists choosing ill underlying logic propose approach concurrent object programming logical point view 
interesting idea consists considering formulas processes logical operations algebraic operations processes 
miller proposed possibilities compare interpretation linear sequents process reduction 
reduces translated sequent provable conjunctive interpretation sequent provable disjunctive interpretation 
representation operations processes depends previous choice 
example various works parallel composition represented omega rst interpretation second 
choice interpretation important focus representation communication 
decide represent communication logic 
case represent senders receivers higher order constants send get extra logical 
case communication asynchronous represented proper axiom 
approach authors prefer possible pure logical framework messages specic formulas linear implication gammaffi represents communication having mind connections linear logic concurrent programming 
process language section dene analyze new framework concurrent computation linear logic having operational semantics described terms proof construction 
captures concurrent computation asynchronous communication 
proposals acl provide new insight models asynchronous concurrent computation form logical point view 
dene grammar process messages ill language extension system cpl included intuitionistic linear logic 
due connective able extend grammar messages processes representing non logical level 
grammar dene processes messages strict processes jm omega jp ij jm omega jm jp omega jp jp pj xp manipulate sequents form gamma sigma gamma sigma multisets processes process 
messages considered particular process obtain framework communication asynchronous 
represented atomic formulas formulas composed omega processes messages represented compound formulas sequents ill sequents 
basic concepts rst consider problem communication 
sender form omega message send process activated sending 
classical notation process algebras receiver form notation waited message process receipt 
furthermore sequent provable framework interpreted receipt process receipt 
operations processes represented logic connectives 
omega respectively represent parallel composition alternative choice 
allows generalization variables allows communication value passing allows restriction variables communication channel hiding 
represents recursion operator allows manage recursive de nitions processes mobility processes structure 
constant unit element omega represents termination process represent abort process 

concerning operations processes possible choices similar ones acl represented disjunctive form 
main dioeerence lies hcc connector message times expressing recursive denitions extra logical constants 
frameworks represent dioeerent forms communication 
point point communication actor model express generative communication receivers compete receive message 
instance sequent omega provable message read process 
broadcast communication message read number receivers possible illustrated provable sequent omega message passing variable sharing communication expressed 
details representation 
point arises possible transfer processes communication 
solve extends acl sense processes parametrized processes improve modularity code reuse concurrent programs 
logical system syntax language xed logical fragment fill consider 
having mind interpret proofs terms process reduction apply general method proof normalization study permutability properties inference movements proof :10.1.1.36.8019
starting permutability results full ll specialized rules involved previous sequents id gammaffi omega 
gammaffi omega determinate inference movements proof 
inferences moved proof dl wl gammaffi omega ones moved proof fi omega gammaffi results able normalize proofs knowing computation bottom proof search system 
start consider inferences movements dene new formal system 
gammaffi inferences producing receivers moved inference introducing active formula propose new rules obtained merging inferences 
omega move weakening contraction rules 
obtain new formal system equivalent original 
communication rules gamma qj sigma omega gamma qj sigma sl gamma qj sigma gamma omega qj sigma sr gamma qj sigma gamma qj sigma rl gamma qj sigma gamma sigma rr composition rules gamma qj sigma omega gamma qj sigma parl gamma gamma sigma gamma gamma sigma gamma gamma gamma omega sigma sigma parr gamma gamma sigma gamma gamma qj sigma gamma gamma gamma qj sigma sigma comp gamma qj sigma gamma qj sigma gamma qj sigma gamma qj sigma gamma sigma gamma sigma gamma sigma sigma message selection rule delta gamma delta gamma delta delta gamma gamma process selection rule delta gamma delta gamma delta delta gamma gamma sell gamma jq sigma gamma sigma recurrence restriction generalization rules gamma qj sigma gamma qj sigma gamma qj sigma gamma qj sigma gamma qj sigma gamma qj sigma gamma sigma gamma sigma gamma qj sigma xp gamma qj sigma gamma sigma gamma sigma termination rules gamma qj sigma gamma qj sigma gamma ij sigma gamma sigma brk recall notation receiver sender sender omega receiver mention fact system correct complete linear logic 
theorem 
sequent gamma sigma provable new system provable fill system 
non operator allows introduce non specication process see state process dioeerent choices 
consider sender form corresponds send message consider receiver active receives message way consider receiver active receives message possibilities characterize extension messages grammar compared cpl possibility consists having messages 
fact processes activated dioeerent messages 
interest ill sequents form sigma delta lies non consumable messages force activations particular message delta collect messages consumed instantiate message proof search means message 
fact important point mention proof contains applications rule encodes executions process 

possible logical framework consider operator parallel composition 
case due duality rule omega propose parallel composition rule gamma delta gamma delta gamma gamma delta delta parl sequents form sigma jp jp succedent represents directly parallel composition 
case rule parr necessary 
objects concurrency section illustrate interest framework important concurrent programming concepts mainly focus ones involved concurrent object oriented style programming 
fact framework similar characteristics acl cpl languages completed management 
illustrate interest ill specic approach concurrent object logic programming 
concurrent object oriented style programming emphasize part possibilities represent logical framework objects routines features instance inheritance 
objects classes representation 
consider rst example signi cant object management 
object class polygon represented message atomic formula denoted vertices id list points describing position polygon id attributes represented atomic formula connected omega 
set routines represented process rout parallel composition recursive processes dene dioeerent procedures instance process corresponding translation operation represented formula trans ad id trans id vertices id ad ad vertices id omega ad ad process adds vector vertex want dene class rectangle previous class object new class inherits attributes new proper attributes width length 
new object represented formula vertices id omega width id omega length id 
inherits routines add ones rout parallel composition 
non 
precise illustrate interest ill fact connector underlying logic non concurrent systems 
consider previous example see section dining philosophers described dening behavior philosopher connecting necessary process 
process named fork represented formula phi fork omega hand hand gammaffi eating 
process able specify philosopher consequently eat fork right left hand 
previously mentioned proof construction ill system represent possible cases proof 
property denote philosopher left handed philosopher lh considered particular philosopher able right hand eat 
philosopher inherits attributes message form channel hand activate process named eating 
case add new attribute parallel composition omega connective create new object dened formula lh left omega initial 
case generative point point communication processes competing message 
notice propose syntax guide lines translation linear logic adopting standard programming syntax prefer emphasize logical foundations languages 
messages reception provide acl process represented omega omega mn omega waits messages mn receive messages arbitrary order omega associative commutative 
mechanism multiple messages reception useful synchronization processes 
come back example philosophers build process fork omega hand omega ph initial ph consider partial reception message 
receiver message start computation immediately receiving part message 
mechanism enables exploit concurrency senders receivers 
going back example philosopher lh start eat fork message left arrive 
dynamic restructuring processes computing environments may change programs running 
concurrent process dynamically adjust changes optimal conguration process certain environment may optimal environment 
possibility express dynamic restructuring processes main motivation proposals pi calculus 
acl cpl possible dene process dynamically composes decomposes processes adjust granularity 
main interest proposal programming concepts represented logical level 
synchronization sequencing processes authors illustrated higher order processes particular similar example philosophers 
problem described dening behavior philosopher connecting process 
specic process named seq needed sequencing execution system 
example consider philosopher nished eat gives fork philosopher introduce sequencing behavior description 
viewpoint represent operations processes underlying logic consider sequentiality logical connective consequently adapt extend proposal results obtained 
possible way study non commutative linear logic linear logic extended sequentiality connective 
easily consider connective allows insert sequentiality logical level lead new problems proof search techniques develop 
consider possible extension 
assume existence sequentiality connective denoted dene example philosopher process fork represented fork omega hand hand gammaffi eating finish fork ano omega hand ano hand ano ano represents philosopher philosopher means philosopher eats fork right left hand nished eat gives fork philosopher 
consider process calculus extending including sequentiality compare works higher order processes 
main interest representation process operations pure logical framework main idea inside approach concurrent object logic programming 

point consider equivalence processes framework asynchronous message passing 
start proposal notion interface bisimulation calculus 
section dened representation objects classes naturally concurrent objects framework 
come back proof paradigm looking represent forms objects classes denitions 
proofs computations perspective complete approach object concurrent programming fill proof come back proof computation paradigm 
rst point consists analyze problem state looking able consider system representation state fill sequent 
dynamics goal model language systems dynamically modify state 
logical models object oriented features methods logic clauses rewrite state new 
way forum frameworks combine higher order logic linear logic emphasize representation objects computations perspective 
attempt general notion state ll sequent 
fact represent framework basic concepts proposals 
way rene structure initial sequent form gamma sigma sigma considered current state system set denitions multi set messages pending activities system pick atoms obtain communication rules new state new message 
context objects methods classes represented objects atomic formulas classes universally formulas auxiliary operations expressed atomic formulas 
instance objects atoms form id attrs methods dened id attrs ms omega id head gammaffi id attrs ms omega msg omega msg message 
example representation approach framework proofs perspective consider simulate behavior imperative paradigms 
program executing assignment expressed formula ass assign omega omega gammaffi omega omega 
computation swap values variables proof knowing initially omega omega program swapping assign assign assign ass sigma ass omega omega omega sigma rl ass assign omega omega omega sigma rl ass assign assign omega omega omega sigma rl ass assign assign assign omega omega omega sigma rl form ass forces computation deterministic imposed sequentiality assignments continuations parameter assign 
goal passing dene non deterministic computation dioeerent proofs dioeerent nal states 
forced sequentiality context interpretation proofs computations prove exists sequence transitions initial nal state 
fill extended nets seen previous section dynamics proof search ill denition extended petri net called extension fragment proposal 
consider logical fragment specication logic concurrent processes point view 
section consider equivalence reachability problem net derivability problem ill logical fragment 
reachability relation states sn net represented notion provability sequent linear theory proper axioms clauses encode transitions function associates state net formula linear logic encodes state 
denote function 
theorem 
proof sequent fn linear theory exists net having gamma initial state sn gamma fn nal state reachable proof 
proof sequent fn linear theory lt proceed structural induction considering inference theorem 
completeness net initial state sn state necessary nal sn reachable sequent provable linear theory proof 
induction number transitions 
consists analyzing deeply relationship approach proof computation perspective ill framework 
concluding remarks intuitively appear natural investigate full intuitionistic linear logic ill model concurrent logic programming principally involves representation non 
validate intuition investigated design logical framework logic concurrent object programming ill order grasp non deterministic cases occur concurrent processes 
proposed process calculus ill proof search computation programming paradigm 
new framework computation described terms proof construction extended proposals acl cpl system 
allows non message management represent interesting mechanisms concurrent programming described described pure logical form 
fact exhibits attractive features concurrent programming languages providing mechanisms object oriented concurrent computing 

abramsky 
computational interpretations linear logic 
theoretical computer science 


applications linear logic computation overview 
bulletin igpl 

andreoli pareschi 
logic programming sequent systems linear logic approach 
int 
workshop extensions logic programming lncs pages bingen germany december 

andreoli pareschi 
linear objects logical processes built inheritance 
th conference logic programming mit press pages jerusalem june 

andreoli pareschi 
dynamic programming multiagent programming 
ecoop workshop object concurrent computing lncs pages genova july 
springer verlag 

benton bierman de paiva hyland 
term calculus intuitionistic linear logic 
int 
conference typed lambda calculi applications lncs pages utrecht netherlands march 

martelli 
objects forum 
international logic programming symposium ilps portland oregon december 

galmiche 
canonical proofs linear logic programming frameworks 
workshop proof theoretical extensions logic programming santa margherita ligure italy june 

galmiche 
proof search programming intuitionistic linear logic 
cade workshop proof search type theoretic languages nancy france june 

galmiche perrier 
foundations proof search strategies design linear logic 
logic st petersburg symposium logical foundations computer science lncs pages st petersburg russia july 

galmiche perrier 
proof normalization linear logic 
theoretical computer science 

girard 
linear logic 
theoretical computer science 

harland pym 
resolution fragments classical linear logic 
lpar international conference logic programming automated reasoning lnai pages st petersburg russia july 

hodas miller 
logic programming fragment intuitionistic linear logic 
journal information computation 

honda tokoro 
asynchronous communication semantics 
ecoop workshop object concurrent computing lncs pages genova july 
springer verlag 

hyland de paiva 
full intuitionistic linear logic extended 
annals pure applied logic 


petri nets horn programs linear logic vector games 
int 
symposium theoretical aspects computer software tacs lncs pages sendai japan april 

kobayashi yonezawa 
acl concurrent linear logic programming paradigm 
int 
symposium logic programming pages vancouver october 

kobayashi yonezawa 
asynchronous communication model linear logic 
formal aspects computing 

kobayashi yonezawa 
higher order concurrent linear logic programming 
int 
workshop theory practice parallel programming lncs pages sendai japan november 

kobayashi yonezawa 
type theoretic foundations concurrent objectoriented programming 
acm sigplan conference object oriented programming systems languages applications oopsla pages 

lilius 
high level nets linear logic 
th int 
conference applications theory petri nets lncs pages uk 

lincoln mitchell 
operational aspects linear lambda calculus 
th ieee symposium logic computer science pages santa cruz california 

lincoln saraswat 
higher order linear concurrent constraint programming 
manuscript july 

meseguer 
logical theory concurrent objects 
oopsla ecoop pages ottawa october 
sigplan notices 

meseguer 
rewriting model concurrency 
concur lncs pages amsterdam august 

meseguer marti oliet 
petri nets linear logic 
math 
struct 
comp 
science 

miller 
calculus theory linear logic preliminary results 
workshop extensions logic programming lncs pages 

miller 
multiple meta logic 
th ieee symposium logic computer science pages paris france july 

milner 
functions processes 
math 
struct 
comp 
science 

perrier 
concurrent programming linear logic 
technical report cnrs nancy march 

perrier 
model concurrency linear logic 
conference computer science logic csl paderborn germany 

pym harland 
uniform proof theoretic investigation linear logic programming 
journal logic computation 

retor 
pomset logic non commutative extension classical linear logic 
conference computer science logic csl paderborn germany september 

saraswat 
concurrent constraint programming 
th acm symposium principles programming languages pages san francisco california 


concurrent logic programming uniform linear proofs 
algebraic logic programming alp lncs pages madrid spain 
linear sequent calculus inference system classical linear sequent calculus sequent expression gamma delta gamma delta multisets linear formulae formulae built linear primitives omega phi 
complete presentation system refer 
identity group id gamma delta theta gamma delta theta cut structural group gamma delta gamma delta wl gamma delta gamma delta wr gamma delta gamma delta cl gamma delta gamma delta cr logical group gamma delta omega gamma delta omega gamma delta theta gamma delta theta omega omega gamma delta theta ab gamma delta theta gamma delta gamma delta ab gamma delta gamma delta gamma delta gamma delta gamma delta theta gammaffib gamma delta theta gammaffi gamma delta gamma delta gammaffib gammaffi gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma deltab gamma delta gamma delta gamma delta phi gamma delta phi gamma delta gamma delta phi phi gamma delta gamma delta phi phi gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta xa gamma delta gamma delta gamma delta xa gamma delta xa gamma delta gamma delta gamma delta xa 
