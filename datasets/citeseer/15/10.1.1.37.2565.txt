typed logical variables haskell koen claessen koen cs chalmers se peter cs chalmers se august describe embed simple typed functional logic programming language haskell 
embedding natural extension prolog embedding spivey 
get full static typing need haskell extensions quantified types st monad 
years attempts combine flavours logic functional programming 
known ones programming languages curry escher mercury 
curry escher seen variations haskell logic programming features added 
mercury seen improvement prolog types functional programming features added 
completely new autonomous languages 
defining new programming language drawback developer build new compiler user learn new language 
different approach gained lot popularity couple years embed new language language called host language 
haskell shown extremely suited purpose various areas 
embedding approach obvious advantage 
programs embedded language class citizens host language generated program host language 
aim embed logic programming features haskell 
different approaches taken spivey embed language predicates terms haskell hinze shows describe backtracking efficiently elegantly 
approach combines ideas adds new terms embedded program contrast spivey approach typed 
resulting embedded language limitations 
syntactic drawbacks sense predicate definitions elegantly described haskell prolog special syntax prolog logical variables unification pattern matching 
second real implementations logical programming specialised search strategies 
rest organized follows 
section summary spivey embedding prolog haskell 
section generalize monad 
section show st monad deal user defined datatypes typed setting 
section conclude 
embedding prolog haskell mike spivey embedded traditional logic programming functional framework 
section essentially summary embedding 
logical variables embedding consists datatype term terms type pred predicates unification predicate connectives existential quantifier term term pred pred pred pred term pred pred type term terms possibility uninstantiated variable 
type binary trees var variable unique identifier data term var id atom string nil term term embedding lists simulate backtracking arbitrary choice lots possibilities 
define type backtr case equivalent lists 
thing possible variants search type monads specifically monads zero written mzero plus written 
type pred predicates function takes computation state gives stream new states 
computation state state holds current values logical variables called substitutions stream uninstantiated variables 
type backtr type pred state backtr state type state subst term type subst id term unification predicate uses standard unification function unify term 
term subst 
backtr subst takes terms substitution returns failure represented zero backtracking monad new substitution represented unit term term pred sub vs sub unify sub return sub vs connective maps second predicate results concatenating resulting list lists simply concatenation results pred pred pred st st ae st st st quantifier applies function fresh variable taken state term pred pred sub vs sub vs define success predicate true failure predicate false easily true false pred true st return st false st mzero definitions get standard depth search behaviour prolog 
definitions pred changed get search strategies breadth search shown 
running example get feel embedding give example continue develop course 
example problem go node directed acyclic graph returning path travelled 
prolog standard solution follows 
suppose graph stored database predicate edge meaning edge graph predicate path nodes defined path 
path nodes edge path nodes 
embedding specifically declare logical variables program verbose idea path nodes nodes nil nodes nodes nodes edge path nodes need know define suitable graph example directed acyclic graph nodes edges written prolog edge 
edge 
edge 
edge 
edge 
edge 
edge 
direct translation predicate embedding verbose unreadable edge term term pred edge atom atom atom atom atom atom atom atom atom atom atom atom atom atom embedding program haskell construct boring looking program making translation list representation graph edge predicate edge term term pred edge foldr false atom atom graph graph monad embedding observing reader may noticed types functions defined far fit nicely monadic framework 
precise pred type isomorphic instance backtracking state monad bs newtype bs bs state backtr state type pred bs monad definitions bind ae return zero instance monad bs return bs st return st bs ae bs st st st bs st instance monadplus bs mzero bs st mzero bs bs bs st st st thought see true false correspond ae return mzero respectively 
unification existential quantifier easily defined auxiliary function free computes new unbound variable 
term term pred sub vs sub unify sub return sub vs free bs term free sub vs return sub vs term bs bs free observe return ae mzero right hand side definitions apply backtr monad bs monad 
revising example connectives failure quantifier monadic counterparts ae mplus fail free reprogram example monadic form path term term term pred path nodes nodes nil nodes free nodes nodes free edge path nodes try program problem find suitable path nodes main 
solve path atom atom var xs xs nil xs nil xs nil xs nil solutions functional logic programming monadic computation returns result embedding embedding logic programming language results 
revising example view path predicate nodes arguments returning path 
simplifies definition somewhat path term term bs term path return nil neighbour nodes path return nodes definition uses predicate neighbour gives neighbours argument neighbour term bs term neighbour free edge return try example get main 
solve path atom atom nil solve function small interpreter bs monad displays results prolog style 
nil nil nil solutions freely mix predicate style monadic style functional logic style 
note established full functional logic programming 
example require unification function types able simple poor man version 
argue expressivity provide interesting aspect functional logic programming 
typed logical variables embedding simple functional logic programming language pure functional language 
aim transfer haskell strong typing embedding universal type term terms 
polymorphic state far embedding uses explicit state monad type state holding substitutions 
want different term datatypes time unknown advance term datatypes going problem 
problem solved move haskell extensions available ghc hugs st monad 
st monad capability safely create read update cells arbitrary type 
element embedding dependent certain term datatype unification 
simple solution overload unification operation term datatype represent unification algorithm 
add non determinism st monad form backtracking simply lists anymore 
introduce backtracking monad transformer 
just variant continuation monad transformer allowing multiple answers 
newtype btt ans 
ans ans monad transformer allows lifting actions underlying monad new monad 
operation takes lifted action back underlying monad 
lift monad lift btt lower monad lower btt return definition new monad lp logic programming allowing multiple term datatypes type lp st efficiency purposes hinze backtracking monad transformer believe current definition easier understand 
reading writing lp monad logical variables predicate implemented st monad 
type unify create uninstantiated variables able read write create new lp monad 
reading creating just lifting corresponding functions st monad lp lift ffi lp lift ffi writing simply lift corresponding writing action st monad take care backtracking 
writing value undone backtrack 
lp ref btt ref ref ans ref return ans write new value read old value restore branch backtracking tree done 
logical variables logical variable uninstantiated value kind 
sounds type define variables type var define types example atoms lists data atom vara var atom atom string data list var list nil list note need different constructors variables type define general form free predicate anymore 
declare type class free class free 
free lp note non standard haskell extension multiple parameter type classes functional dependencies 
possible instantiations contain define free predicate types instance free atom free vara liftm instance free list free liftm overloading free extra advantage create free pairs triples instance free free free free liftm free free unification unifying instances term datatype poses problem free simply take solution overload unification 
minimize new datatype declared split unification algorithm parts variables constructors 
introduce type class unify containing operators isvar check term happens variable unify unify terms variables 
class unify 
isvar var unify lp unification operator defined terms operations 
define introduce helper function unifies variable constructor unify var lp ref mb ref case mb ref just just unification algorithm implemented follows 
simplified subtyping language haskell 
exist general polytypic solution problem takes similar approach 
unify lp case isvar isvar just var just var var var true just var var just var var unify deals special cases argument variable hands cases user defined operation unify 
instances unify atoms lists look instance unify atom isvar vara var just var isvar unify atom atom true unify false instance unify unify list isvar var just var isvar unify nil nil true unify bs bs unify false note definitions isvar look identical 
getting lp monad able extract result lp monad define run function simply calls run function st monad 
lp runst lower function depend atom list types type logical variables depend highly contain variable constructor term 
define conversion takes away variables term 
define helper function converts contents variable 
succeeds variable instantiated 
variable lp var lp variable convert var just var convert convert atoms lists 
list conversion function takes parameter conversion functions elements 
atom atom lp atom atom atom return atom vara var variable atom var list lp list lp list list elt nil return nil list elt liftm elt list elt list elt var variable list elt var note result types state type indicate datatypes contain variables 
tempted overload functions clear want convert datatypes variable counter parts 
example haskell perfectly fine list datatype convert list lp list lp list elt nil return list elt liftm elt list elt list elt var variable list elt var similarly convert atoms directly strings 
return example thing need change standard example types predicates 
code exactly section predicates types path atom atom lp list atom neighbour atom lp atom get type error try evaluate predicate path atom atom nil st monad call just fail 
try find paths adapted solve function implemented 
main 
solve path atom atom ae list atom nil nil nil nil solutions main 
solve path atom atom ae list atom solutions succeeded embedding simple typed functional logic language haskell extending language accepted features multiple parameter type classes overlapping instances local universal quantification types st monad 
takes add datatype embedding 
fact datatype contain special constructor variables 
way solving define recursive datatypes explicit fixpoints 
takes away implementing new datatype 
types get lot complicated unmanageable dealing complicated types regular datatypes 
big help polytypic programming tool 
resulting language naive ways 
syntax programs clumsy way write dedicated logic programming language 
solved adding syntactic sugar 
second search strategies fancy ones find implementations logic programming 
implemented embedding breadth searching features possible unify cyclic structures 
require meta level view program indexing prolog implementations 
third common implementations prolog interesting practically useful extensions 
assert retract prolog implementations bb get bb put sicstus prolog handle global variables survive failure 
part embedding today believe hard add 
efficiency aim embedding desirable 
hinze implementation backtracking quite fast unification algorithm implemented probably done better 
example optimizations spirit known union find algorithm 
techniques shown quite useful implementing embeddings domains 
example ongoing unrelated implement embedded language describing state transition diagrams variables arbitary types similar method describe 
want implement proposed improvements extensions 
doing hope find basis nice semantics logic programming known extensions 
investigate embedding practical realistic programs 
koen claessen 
embedded language approach hardware description verification september 
licentiate thesis chalmers university technology gothenburg sweden 
conal 
embedded modeling language approach interactive multimedia animation 
ieee transactions software engineering june 
michael hanus 
integration functions logic programming theory practice 
journal logic programming 
michael hanus 
curry integrated functional logic language february 
current report describing language curry www informatik 
de curry report html 
ralf hinze 
features functional setting axioms implementations 
third fuji int 
symp 
functional logic programming pages april 
ralf hinze 
deriving monad transformers 
technical report iai tr institut fur informatik iii universitat bonn january 
ralf hinze 
polytypic functions nested datatypes 
discrete mathematics theoretical computer science 
paul hudak 
building domain specific embedded languages 
acm computing surveys december 
patrik jansson 
functional polytypic programming 
phd thesis chalmers technology goteborg university june 
patrik jansson johan jeuring 
polytypic unification 
journal functional programming september 
mark jones 
type classes functional dependencies 
th european symposium programming berlin germany 
springer verlag lncs 
john launchbury simon peyton jones 
lazy functional state threads 
proc acm programming languages design implementation orlando 
acm 
john lloyd 
programming integrated functional logic programming language 
journal functional logic programming march 
mercury project homepage 
www cs mu oz au research mercury 
johan 
reactive objects functional programming 
phd thesis dept computer science chalmers university technology 
michael spivey 
embedding prolog haskell 
haskell workshop paris france september 
michael spivey tony hoare 
algebra logic programming 
int 
conf 
logic programming november 
