adaptive data replication algorithm ouri wolfson university illinois chicago nasa goddard space flight center sushil jajodia george mason university fairfax huang university illinois chicago addresses performance distributed database systems 
specifically algorithm dynamic replication object distributed systems 
algorithm adaptive sense changes replication scheme object set processors object replicated changes occur read write pattern object number reads writes issued processor 
algorithm continuously moves replication scheme optimal 
show algorithm combined concurrency control recovery mechanisms distributed database management system 
performance algorithm analyzed theoretically experimentally 
way provide lower bound performance dynamic replication algorithm 
categories subject descriptors database management system transaction processing general terms database management systems additional key words phrases database management systems transaction processing concurrency control 
motivation internet world wide web rapidly moving distributed wholly interconnected information environment 
environment object accessed read written multiple locations may research supported part nsf iri iri iri afosr arpa administered office naval research number 
authors address wolfson department electrical engineering computer science university illinois chicago il nasa goddard space flight center code md email wolfson eecs uic edu 
jajodia department ms george mason university university drive fairfax va phone email jajodia gmu edu 
huang department electrical engineering computer science university illinois chicago il 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission acm 
copy republish requires fee specific permission 
delta ouri wolfson geographically distributed world wide 
example electronic publishing document newspaper article book may coauthored read users distributed fashion 
financial instruments prices read updated world 
image ray read annotated hospitals 
raw data scientific experiment example modified laboratories 
mobile computing communication environments see badrinath imielinski imielinski badrinath identification associated user physical location case today 
location user updated result user mobility read behalf callers 
environments replication objects distributed system crucial implications system performance 
example consider object replication scheme set processors replicated 
worldwide web terminology replication scheme set servers replication scheme determines replicas created processors replicas allocated 
scheme affects performance distributed system reading locally faster costly reading remote processor 
read intensive network widely distributed replication mandated order increase number local reads decrease load central server 
hand update object usually written majority replicas 
case wide distribution slows write increases communication cost 
network narrowly distributed replication mandated 
general optimal replication scheme object depends read write pattern number reads writes issued processor 
presently replication scheme distributed database established static fashion database designed 
replication scheme remains fixed designer manually intervenes change number replicas location 
read write patterns fixed known priori reasonable solution 
read write patterns change dynamically unpredictable ways static replication scheme may lead severe performance problems 
dynamic object allocation propose analyze dynamic replication algorithm called adaptive data replication adr 
adr algorithm changes replication scheme object dynamically read write pattern object changes network 
changes read write pattern may known priori 
algorithm distributed opposed centralized 
centralized algorithm processor periodically transmits relevant information usually statistics predetermined processor turn computes objective function orders change replication scheme 
contrast distributed algorithm processor decisions locally change replication scheme statistics collected locally 
example local change replication scheme processor relinquishes replica indicating neighbors writes object propagated 
change may result comparison number reads adaptive data replication algorithm delta number writes locally collected statistics 
distributed algorithms advantages centralized ones 
respond changes read write pattern timely manner avoid delay involved collection statistics computation decision broadcast 
second overhead lower eliminate extra messages required centralized case 
adr algorithm works read write context see bernstein ceri ozsu valduriez may combined phase locking concurrency control algorithm order ensure copy serializability see bernstein 
read write implies writes execute failure system 
allow writes face failures propose new protocol primary missing writes combined dynamic replication 
earlier version adr algorithm called car announced wolfson jajodia proposed managing distributed database consisting location dependent objects mobile computing badrinath imielinski badrinath imielinski badrinath 
database object represents location user 
read callers user updated user changes location 
user relatively static called frequently location widely distributed network 
user moves frequently called infrequently location narrowly distributed small number copies 
introduce analyze adr algorithm network having logical physical tree structure 
extend algorithm network modeled general graph topology 
extension dynamically changing tree structure network revises processing reads writes take advantage shorter paths may available network tree 
analysis adr algorithm adr algorithm changes replication scheme decrease communication cost 
communication cost replication scheme average number inter processor messages required read write object 
optimizing communication cost objective function reduces load communication network processors cpu cost processing messages 
problem finding optimal replication scheme replication scheme minimum cost read write pattern shown npcomplete see wolfson milo general graph centralized case 
define analyze adr algorithm tree networks 
analysis theoretical experimental 
theoretically show adr algorithm convergent optimal sense 
assume read write pattern processor generally regular 
example hours processor executes reads write second processor executes reads writes second hour period processor executes read write second processor executes reads writes 
show adr algorithm converge optimal replication scheme delta ouri wolfson global read write pattern hours converge optimal replication scheme global read write pattern hours words starting replication scheme adr algorithm converges replication scheme optimal current readwrite pattern convergence occurs number time periods bounded diameter network 
order prove introduce new model analyzing adaptive replication algorithms 
experimentally compare performance adr algorithm performance static replication schemes various randomly generated read write patterns 
show communication cost adr algorithm average lower static replication algorithm 
exact depends read write pattern fixed known priori turn determines optimal static replication scheme selected 
order put proposed algorithm proper perspective devise theoretical lower bound communication cost function 
lower bound cost ideal algorithm complete knowledge read write requests order 
obviously algorithm unrealistic yardstick 
show experimentally average communication cost adr algorithm higher lower bound 
general graph network topologies show regularity assumptions adr algorithm improves communication cost time period converges replication scheme stabilizes 
contrast tree case replication scheme may optimal 
words starting initial replication scheme adr algorithm change reduce communication cost reaches local global optimum 
sense adr algorithm general graph topologies convergent convergent optimal 
organization rest organized follows 
section demonstrate adaptive data replication algorithm 
section discuss various practical issues related implementation adr algorithm distributed systems 
example discuss storage space considerations digital libraries incorporation adr various replica consistency protocols phase locking discrepancy read write unit data replication unit object orientation issues methods complex objects way incorporating priori information read write activity adr algorithm 
section introduce primary missing writes algorithm handles failure recovery dynamic replication environment 
section introduce model analyzing dynamic replication algorithms prove adr algorithm convergent optimal sense explained 
section experimentally compare performance adr algorithm static replication algorithms 
section devise lower bound line algorithm dynamic replication experimentally evaluate adr algorithm line lower bound algorithm yardstick 
section extend adaptive data replication algorithm delta adr algorithm general network topologies prove convergent 
section compare relevant literature section summarize results 
appendix prove main theorems appendix provide pseudo code adr algorithm 

adaptive data replication algorithm section adr algorithm works tree network 
tree represents physical logical communication structure 
metaphorically replication scheme algorithm forms variable size amoeba stays connected times constantly moves center read write activity 
replication scheme expands read activity increases contracts write activity increases 
roughly speaking border processor processor circumference amoeba number reads equals number writes replication scheme remains fixed 
scheme optimal read write pattern network 
adr algorithm services reads writes object 
executed follows 
read object performed closest replica network 
write updates replicas propagated edges subtree contains writer processors replication scheme 
example consider communication network suppose replication scheme consists processors 
phi phi phi gamma gamma gamma computer network processor writes object sends object sends sends simultaneously 
communication cost write total number inter processor messages required 
adr algorithm initial replication scheme consists connected set processors time processors replication scheme denoted connected 
example adr algorithm replicate object processors network 
consider processor neighbor belongs neighbor belong denote neighbor belong sends read write requests originates processor set processors connected induces connected subgraph tree network delta ouri wolfson shortest path goes example consider network 
processor read write requests originate 
processor executing adr algorithm receives priori parameter denoting length time period minutes 
changes replication scheme executed time period processors replication scheme 
need changes determined tests expansion test contraction test switch test 
expansion test executed processor neighbor 
suppose singleton set 
define fringe processor leaf subgraph induced fringe processor executes contraction test 
observe processor neighbor fringe 
executes expansion test fails executes contraction test 
processor neighbors singleton set fpg executes expansion test fails executes switch test 
ready formally define tests 
time period processor neighbor performs test 
expansion test 
neighbor compare integers denoted number reads received time period total number writes received time period neighbor different sends copy object indication save copy local database 
joins practically actual expansion delayed receives read request receives write propagated indication join piggybacked copy object sent order service request 
processor informed expansion expansion test performed comparing counters reads writes 
counters initialized zero time period incremented time period 
expansion test succeeds condition satisfied neighbor 
say expansion test fails succeed 
consider processor fringe processor exactly neighbor processor executes test time period 
contraction test 
compare integers denoted number writes received time period number reads received time period read requests received received neighbor different 
requests permission exit cease keeping copy 
processor exit unconditionally may processors current replication scheme may announce exit leaving empty replication scheme 
contraction test adaptive data replication algorithm delta succeeds keeps replica receives message message request leave say smaller processor identification number leaves exit request granted processor propagate write requests read requests arriving passed processor informed contraction 
suppose processor constitutes replication scheme 
neighbor execute expansion test 
expansion test fails executes test time period 
switch test 
neighbor compare integers denoted number requests received time period number requests received time period 
sends copy object indication new singleton processor replication scheme discards copy 
condition contraction switch test satisfied say test succeeds 
say fails 
practically singleton replication scheme switch delayed receives write processor receives read request switch means simultaneously exits enters summarize algorithm follows 
time period neighbor executes expansion test 
fringe processor executes 
processor neighbor fringe executes expansion test fails executes contraction test 
processor neighbor executes expansion test fails executes switch test 
example 
example demonstrate operation adr algorithm 
consider network 
suppose initial replication scheme consists processor 
suppose processor processor issues reads writes time period processor issues reads writes time period 
suppose requests serviced time period issued 
time period processor neighbor processors executes expansion test 
number reads requested processor number writes requested processors processor enter replication scheme 
number reads requested processor number writes requested processors 
processor enters replication scheme result test 
second time period processors execute tests 
processor performs expansion test processor fails time period 
second processor performs contraction test succeeds processor receives writes processor reads processors 
time processor executes expansion test successfully includes processor replication scheme number reads processor number writes processors delta ouri wolfson 
result tests replication scheme second time period 
starting third time period replication scheme stabilize change 

practical issues section discuss adr algorithm practical considerations incorporation distributed database system applications 
adr distributed algorithm 
consider level global knowledge required processor executing adr algorithm 
note algorithm requires processor knows neighbor fringe processor unique processor knowing requires processor knows identity neighbors remembers neighbor replication scheme 
processor belong replication scheme participate algorithm internal processor replication scheme processor fringe neighbors replica 
processor need know order execute reads writes 
processor current replication scheme satisfies read request locally transmits write request neighbors replication scheme turn propagates write neighbors 
know identity neighbors remember neighbor replication scheme information needed execute adr algorithm 
interestingly processor belong replication scheme search replication scheme order execute reads writes 
processor replication scheme remember processor sent announcement exits indicates direction read write sent turn longer routes request direction executing adr algorithm executing reads writes knowledge network topology necessary knowledge replication scheme necessary 
connectivity replication scheme 
replication scheme connected circumstances 
example suppose communication new york los angles goes chicago accesses object originate new york los angles 
adr algorithm store copy chicago may wasteful 
adr algorithm modified create inactive internal processors chicago pseudo replicas 
pseudo replicas require real storage space 
processor storing pseudo replica install write locally propagates write neighbors replication scheme case replica real 
pseudo replicas satisfy reads 
adr algorithm reads satisfied internal copies reads originating respective internal processor pseudo replica processor reads satisfied real replica 
example point chicago issue read read satisfied real replica 
exit requests handled carefully 
example new york los angles request adaptive data replication algorithm delta exit replication scheme pseudo replica processor chicago requests time case chicago holds real replica real replica object unavailable 
related subject 
multiple objects space limitations 
digital libraries consisting multiple objects storage space considerations may play significant role 
adr context suppose expansion switch test indicate processor keep copy object doesn storage space 
problem addressed ensuring space objects assume moment objects equal size stores objects provide maximum cost benefit 
way maintain benefit value denoted object stored define cases replication scheme singleton fpg fringe processor fringe processor 
case deleted second case difference number reads serviced time period number writes propagated time period 
third case number reads serviced time period writes ignored explained previous discussion item connectivity replication scheme pseudo replica writes propagated 
ordered neighbor store object value computed follows 
order result expansion difference number reads received number writes received order result switch difference number read write requests issued number read write requests received ordered store object storage space compares value minimum benefit value objects stores 
denote object minimum benefit value achieved 
expansion switch order denied 
replaces contracted replication scheme pseudo replica depending fringe processor replication scheme different objects different sizes method adapted multiplying benefit object size elaborate 
copy serializability 
transaction processing system adr algorithm combined phase locking ensure copy serializability 
adr algorithm obeys read write policy may strictly speaking switched processor sake simplicity consider marginal optimization 
numbers represent amount reads expensive writes expensive respectively copy deleted difference numbers positive store copy delta ouri wolfson ous 
care taken meaning changes dynamically replication scheme transaction may different replication scheme transaction 
may possible transaction writes copies replication scheme replication scheme expanding processor write propagated problem handled follows 
processor maintains object 
record indicates replication scheme record indicates neighbors record indicates direction expands contracts switches executes replication scheme change transaction 
transaction modifies directory record object order indicate change 
consider transaction writes replica processor read directory record order determine neighbors write propagated 
read directory record conflicts write directory record executed replication scheme change transaction 
transaction writes object conflicts replication transaction 
consequently concurrency control mechanism ensures serializability transactions static replication environment dynamic environment 
replica consistency protocols 
copy serializability systems ensures replicas object appear consistent times 
dynamic replication adr algorithm combined replica management protocols protocols provide weaker consistency guarantees 
consider example lazy replication protocol proposed ladin 
lazy replication operations described higher semantic level reads writes interleave correctly causal specification replicas necessarily consistent times 
protocol distinguishes update operations eventually performed replicas query operations serviced single replica 
updates propagated replicas background gossip messages 
clearly performance lazy replication protocol benefit dynamic replication changing number replicas direct function ratio queries updates moving replicas closer locations initiate operations 
consider type application application types operations serviced replica serviced replicas 
example transaction processing system ensuring copy serializability application 
updates propagated synchronously asynchronous 
fischer michael proposal type protocol maintains dictionary database type operations 
update operations insert delete query operation list 
principle performance type application improved dynamic replication 
type application may adapted dynamic replication 
adaptation straight forward explained transaction processing systems ensure copy serializability 
adaptation lazy adaptive data replication algorithm delta replication complicated lazy replication uses multipart timestamp component replica number replicas varies dynamically 
time period discuss variant adr algorithm length time period changes rate read write requests 
specifically consider variant tests adr algorithm executed processor read write requests received example expansion test executed assuming neighbor processor receives read write requests 
effect change execute replication scheme changes frequently read write request load heavy frequently load decreases 
furthermore request frequency may differ different parts network tests adr algorithm executed frequently parts network consequently replication scheme adaptation faster parts network execute requests 
effect expansion replication scheme request version adr algorithm 
answer 
consider set processors issued requests expansion decision 
suppose requests issued seconds 
suppose seconds expansion processor set issues number reads writes number reads issued seconds expansion 
words read write pattern see subsection formal definition read write pattern representing set requests issued processors identical expansion 
total communication cost executing requests higher expansion 
words processor set issues set requests second periods expansion total cost requests lower expansion 
furthermore replication schemes differ fact expanded lower cost expanded scheme 
assuming remains read write pattern expansion reduce cost regardless changes occur replication scheme 
expansion clearly affect communication cost requests issued processor effect expansion reduce cost servicing read write requests 
similar claim holds replication scheme change resulting contraction switch test 
problem formal analysis revised adr algorithm hard prove global property form theorem 
reason replication scheme changes expansion contraction switch occur totally asynchronous fashion clocks synchronous 
discrepancy read write unit replication unit 
adr algorithm assumes read write unit identical replication unit 
case data replicated logical units text file data allocated physical units 
example suppose replication unit block data replicated full blocks 
furthermore suppose result read unit transferred processors set tuples 
adr algorithm adapted handle situation follows 
delta ouri wolfson neighbor replication scheme block counters neighbor replication scheme 
write counter reads tuples read counter increases fraction ratio total size tuples read size example suppose read issued processor retrieves tuples block tuples constitute th size read counter increases th value 
similarly writes tuples write counter increases fraction represents total size tuples written 
changes adr algorithm 
time period expansion test compares read counter write counter larger copy joining replication scheme 
words difference adr algorithm counters may incremented fraction integer 
methods 
adr algorithm generalized systems processes issue reads writes objects invoke methods operate objects 
generalization follows 
method invoked processor object consists read write 
data returned method read object parameters passed method written object read write counters incremented accordingly 
tree topology 
adr algorithm works tree network 
tree may represent logical addition physical interconnection 
example logical tree network possibly physical network arbitrary topology management hierarchy processors communication network designated managers form hierarchy 
net mate network management system currently developing see sengupta wolfson employs management hierarchy 
net mate purpose provide software tools detection faults recovery large communication networks 
net mate object may transferred manager superior superior manager read write pattern varies time 
example consider object stores identification overloaded processors 
distributed diagnosis global problem network object read extensively times mainly written 
examples logical interconnections represented tree goodman imielinski badrinath 
complex object distribution 
observe adaptive replication determining complex object distribution 
complex object distribution problem establishing complex object partitioned replicated computer network subobject replicated 
problem important applications computer supported collaborative see grudin 
adr algorithm dynamic complex object distribution follows 
complex object includes subobjects read write treated adaptive replication algorithm read write subobjects 
additionally subobject read written individually read write pattern 
adr algorithm distribution network determined automatically depending adaptive data replication algorithm delta read write pattern read write pattern subobjects 
incorporating priori information read write activity 
stands adr algorithm priori information read write activity 
changes replication scheme improve cost assumption activity time period indicative expected activity time period 
priori information available known processor issues reads write time period processor issues reads write time period processor issues reads writes time period static replication scheme optimize communication cost 
static optimal replication scheme linear time algorithm provided wolfson milo 
may want combine priori read write information dynamic allocation 
example suppose priori information uncertain read write activity time period random variable priori value probability value identical latest time period probability gamma adr algorithm adapted incorporate type uncertain priori information adjusting number reads writes compared test algorithm 
example expansion test processor number read requests er taken ar delta lr delta gamma ar number read requests received processors issued prespecified number reads lr number reads received time period 
similarly number writes processors computed ew aw delta lw delta gamma aw number write requests received processor processors issued prespecified number writes lw number writes received processor time period 
expansion test succeeds er ew 
failure recovery section discuss method adr algorithm handle failures 
may quite methods handling failures depending level consistency required replicas depending assumptions network topology 
specifically method deals failures copy serializable transaction oriented environment may restrictive replicas allowed diverge date version 
similarly method works physical tree network may restrictive logical tree network see section superimposed physical network 
reason failure physical tree implies network partition logical tree network necessarily 
case suppose processor logical tree fails 
denote neighbors neighbors communicate tree reconstructed logically connecting neighbors method section deals restrictive case copy serializable transaction oriented system physical tree network 
assume adr algorithm incorporated transaction processing system concurrency control mechanism phase locking 
delta ouri wolfson read write scheme case failure prevents writing processor reaching replicas writing transaction commit 
fixed number replicas protocol called missing writes bernstein enables writes committed copy serializability ensured type failure including network partition 
missing writes protocol uses read write normal mode operation switches quorum consensus see gifford thomas failure detected 
missing writes protocol uses priori knowledge total number copies order determine partition majority copies partition allowed write object 
static replication environment works number copies varies dynamically partition determine constitutes majority copies 
missing writes protocol dynamic replication 
devised protocol called primary missing write solves problem substituting primary copy protocol quorum consensus 
overview protocol generally speaking protocol works follows 
point time unique processor replication scheme designated primary processor 
normal non failure mode operation uses adr algorithm 
primary processor exits replication scheme object assigns primary role processor requests exit 
case switch primary role switched 
consider failure mode 
assume failures clean detected failed processor process request byzantine failures 
processor communication link fails protocol changes replication scheme object singleton consisting primary processor 
replication scheme may differ object object 
replication scheme remains fixed failures repaired time system switches normal mode 
failure mode transactions partition contains primary processor access primary copy object 
object inaccessible transactions partitions 
failure detected cases 
transaction may able read object reach processor object replicated 
case transaction aborted resumed failure repaired 
second transaction may able propagate write object processor object replicated 
say missing write detected 
missing write detected transaction issues write aborted execution 
processor status bit indicating processor running normal failure mode 
transaction initiation reads status bit runs failure mode normal mode 
normal mode transaction adr algorithm objects accesses failure mode primary copy objects accesses 
status bit regarded database item locked read written 
status bit read transaction written failure recovery transactions discussed adaptive data replication algorithm delta 
conversion failure mode partition converts failure mode missing write detected replicas written object reached 
processor detects missing write call pioneer processor initiates failure transaction performs operations 
notifies processors partition failure mode discard non primary replicas object 
processor replies identification objects primary 
pioneer processor constructs list list objects reachable single processor partition stores object 
pioneer processor sends objects reachable list processors partition 
operations executed atomic transaction 
failure transaction processors partition converted failure mode know objects reachable partition processor stores object 
recovery conversion normal mode processor recovers failure executes recovery transaction performs operations 
checks exist failures tree network 
exist failures recovering processor tells processors failure mode tells processors convert normal mode 
case recovering processor constructs objects reachable list explained previous subsection sends reachable processors 
observe failures exist system reachable objects list updated recovery may reconnect disconnected components increases list objects reachable partition 
concludes description recovery transaction 
observe system converts back normal mode object replication scheme consisting single node primary processor adaptive replication adr algorithm 
recovery failure communication link handled running recovery transaction 
transaction run processors connected recovering link say lower processor identification number 
reliability constraints observe replication scheme consists single processor failure processor results object inaccessible reads writes 
order avoid situation adr algorithm may reliability order check status processors network processor simply send status message neighbors 
processor receives message processor send status message neighbors wait certain period time 
receives replies neighbors response status message sends status message processor receives fail status message receive message time period sends fail status message 
delta ouri wolfson constraint form time copies object 
adr algorithm enforce constraint preventing contraction test resulting singleton set replication scheme done follows 
processor neighbor replica leaf subtree induced replication scheme denies exit request issued incorporation reliability constraints adr independent replica consistency protocol transaction oriented copy serializable systems replica management protocols 

analysis adr algorithm section prove subsection adr algorithm preserves connectivity replication scheme 
subsection introduce formal model analyzing adaptive replication algorithms prove read write pattern object regular adr algorithm converges replication scheme optimal pattern 
connectivity replication scheme network undirected tree 
set represents set processors edge represents bidirectional communication link processors 
consider object replicated processors network 
replication scheme object nonempty set processors object replicated 
theorem 
suppose object replicated adr algorithm 
replication scheme time period connected replication scheme immediately time period connected 
furthermore common processor adjacent singletons 
proof 
definition adr algorithm see processor test successfully executed time period 
expansion test succeeds test maps replication scheme neighbors ig 
easy see case connected scheme common processor contraction test succeeds resulting scheme fig fringe processor single neighbor say exit simultaneously empty 
connected common processor switch test succeeds test maps replication scheme fig neighbor fng 
case connected singleton scheme adjacent processors network issue read write requests object 
set pairs processor network nonnegative called read write pattern 
intuitively represents number reads issued processor represents number writes issued processor replication scheme associated request replication scheme exists request issued 
observe practice adaptive data replication algorithm delta possible time request serviced replication scheme changed 
assume communication cost associated edge network represents cost edge traversal object 
costs symmetric positive pair processors 
cost read issued processor total cost edges shortest path processor associated replication scheme 
intuitively cost read total cost communication links traversed object satisfy read 
obviously associated replication scheme read cost zero 
assume processor issues write object replication scheme associated write 
cost write total cost edges minimum cost subtree contains set fig replication scheme read write pattern replication scheme cost denoted cost defined delta delta intuitively cost represents total cost messages sent order service requests read write pattern assuming replication scheme associated request message transmission object communication link edge 
replication scheme optimal read write pattern minimum replication schemes cost obviously optimality replication scheme implies average cost request minimum 
theorem justifies fact adr algorithm keeps replication scheme connected times 
theorem 
arbitrary read write pattern 
disconnected replication scheme connected replication scheme cost cost ae proof 
suppose graph induced consists separate connected components 
construct follows 
observe processors denote unique path belong obtain add processors path clear cost read request increase associating scheme furthermore cost read request processor decreases zero 
easy see cost write associated scheme equal cost associated scheme cost cost 
graph induced consists separate connected components repeat process time connecting disconnected components obtain connected replication scheme lower equal cost convergence optimal replication scheme show read write pattern regular adr algorithm moves replication scheme optimal reaching adr algorithm stabilizes replication scheme 
quite easy see delta ouri wolfson simple read write patterns 
example suppose starting point time processors quiescent issuing requests suppose issues reads 
clear intuitively adr algorithm stabilize replication scheme stability scheme include cost optimal read write pattern consisting reads 
specifically time processor replication scheme long issues read requests processors quiescent replication scheme change 
processor expand reaches adr algorithm stable 
expansion step take time period define diameter network maximum number edges path convergence optimal replication scheme occur number time periods bounded diameter network 
suppose starting point time processor issues writes 
adr algorithm stabilize replication scheme stability scheme optimal read write pattern consisting writes stability scheme singleton set fig 
specifically time processor replication scheme long issues write requests processors quiescent replication scheme contract consists single processor processor denote processor closest contract consists singleton set fjg switch consists singleton set fig 
cases convergence optimal replication scheme occur number time periods bounded diameter network 
show convergence property holds regular schedule 
schedule set time stamped requests jn read write request processor request originated integer time stamp issued serviced purpose algorithm analysis assume requests executed instantaneously 
read requests time stamp write requests read write request 
consider integer representing number time units period schedule refer requests time period requests second time period example suppose timestamp request 
requests time period requests time stamp higher requests second time period requests time stamp delta informally say schedule regular time period read write pattern 
formally schedule regular processor integers time period processor issues read requests write requests 
regular schedule say processor read write pattern time period 
consider schedule time stamp consider execution adr algorithm 
assume processors execute tests adr algorithm change replication scheme instantaneously 
time adaptive data replication algorithm delta period tests replication scheme changes occur requests time stamp requests time stamp second time period tests replication scheme changes occur requests time stamp requests time stamp implies particular clocks various processors run approximately rate expiration time period necessarily simultaneous occurs pair requests schedule 
say adr algorithm stabilizes qth time period tests processors fail starting qth time period 
replication scheme time period called stability scheme 
recall example section replication scheme stabilizes third time period 
theorem 
diameter tree network suppose schedule regular integer starting connected replication scheme adr algorithm time period stabilizes time periods furthermore stability scheme optimal read write pattern period 
proof 
see appendix 
experimental analysis adr algorithm section report experimental comparison performance adr algorithm static replication 
subsection describe experiments conducted 
subsection compare adr algorithm static replication schemes fixed read write pattern 
readwrite pattern generated poisson processes parameters randomly chosen 
subsection compare adr algorithm static replication scheme 
comparison different randomly generated read write pattern 
subsections consider network subsection considers network topologies 
experiment preliminaries experimental analysis sun workstations interconnected tree network 
communication neighboring processors 
experiment counts number messages algorithm order execute read write pattern 
algorithm adr static replication particular replication scheme 
consider connected replication schemes see theorem 
network consider different replication schemes size different schemes size schemes size schemes size schemes size schemes size schemes size scheme size 
assume processor tree network generates reads writes object independently processors poisson distribution parameters respectively 
time period expected number reads issued expected number writes issued writes 
furthermore assume parameters processor change time 
parameters delta ouri wolfson periods time parameters periods time 
generated processor randomly independently due independence read write patterns regular sense subsection 
hand totally chaotic persist time period processor 
experiments clocks different processors synchronized request issued time period guaranteed serviced time period due communication delays 
words ideal assumptions section hold 
mentioned cost algorithm total cost messages 
message sent neighbors tree distinguish types messages data messages control messages 
data messages messages carry object control messages messages read requests exit replication scheme requests type adr algorithm sent processor relinquishes copy 
experiments assume costs edges tree network identical difference costs data messages costs control messages 
fixed read write pattern subsection consider read write pattern generated certain poisson processes 
parameters processes table 
column table corresponds processor entry column indicates time periods processor generated time period reads writes poisson processes parameters respectively 
example column indicates processor generated average reads writes time period periods generated average reads writes time period periods values entry generated randomly processor generated requests time periods 
observe read write pattern table regular adr algorithm necessarily converge 
table fixed access pattern executed runs adr algorithm poisson processes parameters 
run started different initial replication scheme 
total adaptive data replication algorithm delta number requests generated different runs varied 
total cost different runs varied 
initial replication scheme affect cost adr algorithm significantly 
average adr algorithm data messages control messages order service read write pattern generated poisson processes parameters 
numbers cost adr algorithm computed ratio control message cost data message cost 
chose read write pattern read write patterns computed number data messages number control messages service requests static replication scheme 
computed cost servicing read write pattern optimal static replication scheme cost adr algorithm lower cost 
optimal static replication scheme cost adr algorithm lower cost 
value cost adr algorithm lower cost optimal replication scheme percentage 
discussion 
suppose known advance read write pattern table occurs network 
adr algorithm database administrator save compared optimal pattern static replication scheme 
assume read write pattern table occurs network fact known priori pattern changes day day week week 
case absence dynamic replication algorithm dba select optimal replication scheme may choose arbitrary static scheme 
compared performance adr algorithm arbitrary static replication scheme assuming read write pattern 
results comparison illustrated 
shows cost saving percentage adr algorithm static replication schemes case 
dark bars represent average connected schemes size savings communication cost obtained adr algorithm lighter bars stand standard deviation 
example compared connected replication schemes consisting processors adr algorithm saves average standard deviation 
illustrates communication cost savings 
intermediate value 
adr algorithm average communication cost saving minimum bar charts 
varying read write patterns subsection compare performance adr algorithm connected static replication scheme 
randomly generated read write pattern comparison 
precisely compare adr algorithm see section definition optimal replication scheme 
cost saving percentage algorithm compared algorithm cost algorithm cost delta ouri wolfson size size size size size average saving percentage standard deviation saving size size size fig 

average communication cost savings adr algorithm compared static replication schemes size size size size size size size size size fig 

average communication cost savings adr algorithm compared static replication schemes size specific static replication scheme say started adr algorithm initial replication scheme executed runs run set read write requests generated follows 
processor generates parameters randomly selected randomly selected randomly selected 
time period processor issues reads writes poisson processes parameters respectively 
time periods processor randomly selects set parameters processor continues run new set 
observe contrast previous section different set read write patterns static replication scheme 
run cost comparison executed follows 
execution adr algorithm run recorded requests generated processors computed communication cost counting messages 
computed communication cost static replication scheme request set initial replication scheme adr adaptive data replication algorithm delta algorithm 
comparing obtained cost saving adr algorithm run cost adr algorithm compared different runs computed average cost saving runs obtained adr algorithm 
call average 
computed average replication schemes fixed size 
results calculations 
results 
size size size size size size size size fig 

average communication cost savings adr algorithm compared static replication schemes size varying read write patterns 
size size size size size size size size fig 

average communication cost savings adr algorithm compared static replication schemes size varying read write patterns 
network topologies verify adr algorithm superior static replication network topologies ran additional sets experiments 
network topology generated random fashion initial replication scheme consisted processors 
set experiments read write pattern table network topologies processors 
results experiments summarized 
column table shows tree second column shows number messages adr algorithm third column shows number messages optimal static replication static replication optimal sense subsection replication scheme 
average cost savings adr algorithm 
delta ouri wolfson adr optimal static control data data messages control messages replication scheme tree structure messages fig 

comparison performance adr algorithm versus static optimal replication various network topologies 
read write pattern table 
second set experiments similar number processors network static replication scheme read write pattern randomly generated 
words experiments similar ones described subsection network static replication scheme comparison generated random fashion 
results experiments summarized 
average cost savings adr algorithm 
lower bound dynamic replication algorithms section devise lower bound cost schedule 
lower bound yardstick experimentally evaluate performance adr algorithm 
lower bound 
adr algorithm online sense request new replication scheme determined knowledge subsequent requests 
furthermore new replication scheme determined distributed fashion read write requests may occur concurrently 
section optimal algorithm called lower bound lb 
offline sense input consists schedule priori 
words algorithm new requests 
lb centralized algorithm 
input lb schedule algorithm lb associates replication scheme request total communication cost minimum 
adaptive data replication algorithm delta tree structure scheme data control messages replication control messages data messages static replication scheme adr fig 

comparison performance adr algorithm versus static replication various network topologies 
column shows number processors network network topology 
read write pattern static replication scheme randomly generated 
suppose jn schedule recall pair requests time stamp reads 
configured schedule schedule request mapped associated replication scheme denoted jn rn require requests time stamp associated replication scheme requests issued simultaneously replication scheme time unique 
adaptive replication algorithm ara function maps schedule configured schedule 
convenience assume section schedule sequence requests partial order requests increasing time stamp order 
reads occur simultaneously may appear order sequence 
clear results section affected assumption 
cost configured schedule intuitively cost configured schedule cost read write requests plus cost changing associated replication scheme request 
formally define unit configured schedule transition 
cost transition defined follows 
write cost transition cost write request replication scheme cost write replication scheme defined section 
read write cost transition cost read plus minimum cost writing object processors processors intuitively represents cost executing plus cost moving replication scheme delta ouri wolfson read read cost transition cost read plus minimum cost writing object processors fall processors shortest path connects processors intuitively case slightly complicated previous reason 
object read processors minimize cost copying object cost configured schedule cost request plus cost consecutive transitions configured schedule 
example consider tree network section configured schedule 
cost assuming unit cost edge cost read replication scheme cost read replication scheme cost moving cost read replication scheme cost moving addend represents cost read 
second third represent cost transition 
fourth fifth represent cost second transition 
notice replication scheme contraction move move object zero communication cost 
example tree consider configured schedule 
cost cost read replication scheme cost write replication scheme cost read replication scheme cost moving addend represents cost read 
second addend represents cost transition 
third fourth represent cost second transition 
schedule cost optimal configured schedule minimum cost configured schedules sequence requests different associated replication schemes 
adaptive data replication algorithm delta lower bound algorithm algorithm lb defined input schedule 
configures create cost optimal configured schedule 
intuitively lb write sent processors read 
words write sent set processors read write succeeds precisely algorithm lb works follows 
request read lb associates replication scheme processors read write reads write 
request read lb associates write read executed write succeeds replication scheme fj processors read object write succeeds observe lb adaptive replication algorithm 
example consider tree network schedule configured schedule devised lb follows 

assuming unit cost edge cost configured schedule cost read scheme cost transition cost second transition cost write scheme cost fourth transition cost fifth transition notice read requests schedule local cost zero 
non zero addend third transition 
total cost configured schedule minimum processors read replica written processor minimal cost transmitting object processor processors 
schedule adaptive replication algorithm denote configured schedule obtained theorem 
schedule lb cost optimal 
proof 
subdivide schedule convenient manner 
denote arbitrary schedule consists zero read requests 
denote oe arbitrary schedule consists write followed zero read requests 
rewrite schedule oe oe arbitrary ara rewrite schedule oe delta ouri wolfson oe 
furthermore cost sum cost plus total cost oe see definition cost configured schedule 
consider cost configured schedule devised lb 
suppose 
denote fi lb associates replication scheme reads cost read requests 
furthermore replication scheme change lb 
cost lb 
consider schedules form oe suppose oe jm 
lb associates replication scheme fj requests oe cost reads oe zero cost transitions cost write cost edges oe oe minimum cost subtree network spans fj arbitrary adaptive replication algorithm consider oe 
processors fj read replica written set edges traversed object result requests oe connected subtree network contains set processors fj denote subtree oe oe minimum cost subtree contains fj cost edges oe higher oe experimental comparison adr algorithm vs lower bound run executed section recorded request sequence processor 
merged sequences processors random fashion create input line lower bound algorithm 
input computed line lower bound communication cost lb algorithm compared cost run reported section 
compared performance adr lb algorithms inputs runs 
experiments concluded average adr algorithm incurs communication cost lower bound algorithm standard deviation 
adr algorithm incurs average communication cost lower bound algorithm standard deviation 
remember lb algorithm knows control messages 

dynamic allocation general networks section discuss dynamic data allocation general graph network topology 
observe problem finding static optimal replication scheme np complete network modeled general graph see wolfson milo find efficient convergent optimal dynamic allocation algorithm 
obvious way extend adr algorithm arbitrary network find spanning tree network execute adr algorithm tree 
drawback approach path spanning tree processors necessarily shortest path 
consequently suppose processor issues read request object request propagated tree edges reaches processor replication scheme 
shorter path wasteful send object tree path adaptive data replication algorithm delta transmitted shortest path 
words contrast adr algorithm read request propagation object response proceed different paths 
furthermore expanding replication scheme mean expansion processor replica shortest path modifying adr algorithm shortest path general graph network explained suggests algorithm called adr 
basically algorithm consists tests adr algorithm 
point time spanning tree network replication scheme induces connected subtree 
tree structure changes dynamically time explained 
changing spanning tree 
edges current tree divided subsets edges subtree induced replication scheme rest 
edges subtree induced replication scheme directed sense processor replica tree father 
edges propagate writes received processor replication scheme processors scheme 
important subtree defined connect processors replication scheme order prevent write propagated processor different neighbors increasing communication cost 
may case processors replication scheme interconnected graph cycles adr write propagated processor neighbors received write 
rest tree edges directed edges 
processor outside replication scheme propagate read write requests replication scheme 
unique tree father zero tree sons 
tree father processor shortest path graph replication scheme currently known replication scheme changes changes known servicing read requests see details tree father changes 
sense tree structure changes dynamically 
processor joins replication scheme result expansion test directed edge neighbor replication scheme undirected 
processor relinquishes replica result contraction test tree father single neighbor replication scheme 
replica switches tree father 
processing read write requests 
read request issued processor replica sent tree father propagated edges current tree reaches processor replication scheme 
response object propagated shortest path graph follows 
processor replication scheme case receives request send object determines shortest path goes tree neighbor replica 
propagates request shortest path goes tree neighbor words prefers propagate request processor replication scheme closer service request sending object 
intuitively reason cheaper propagate request object delta ouri wolfson replica services read request sends object shortest path graph 
notice may shortest path processors path choice alternatives nondeterministic 
suppose set possible neighbors propagate read request object processor chooses processor 
say read processing deterministic 
simplicity assume read processing deterministic 
tree father processor replica defined graph neighbor received object 
words receives object graph neighbor tree father object sent shortest path replication scheme processor shortest path replication scheme 
write processor replica propagated replication scheme tree father path 
write received processor replication scheme processed adr propagated tree neighbors received write 
adr algorithm 
point time processor knows neighbors tree general network topology processor replication scheme aware tree neighbors replica 
outset connected replication scheme spanning tree network selected 
expansion contraction switch tests adr algorithm similar adr algorithm 
generalizations tests necessary 
example general network due fact processor cognizant shortest path replication scheme possible processor replication scheme receive read request neighbor respond sending object neighbor case purpose replication scheme expansion matters direction object sent represents current shortest path information direction request received represents outdated shortest path information 
language tests modified account subtlety 
language change generalization revised tests hold tree network 
neighbor processor replication scheme graph tree neighbor replica 
expansion test executed neighbor graph neighbor replica 
expansion test 
neighbor compare integers denoted number times sent object service read requests time period total number write requests issued received neighbor different time period 
sends copy object indication save copy local database 
joins suppose time period processor fringe processor simplifies replication scheme change tests 
network topology processor needs know propagate message processors shortest path graph neighbors transmit message destined processor adaptive data replication algorithm delta exactly graph neighbor executes contraction test cases neighbor neighbor expansion test failed 
contraction test 
compare integers denoted number writes received time period number reads time period issued resulted sending object neighbor 
requests permission exit cease keeping copy 
suppose processor constitutes replication scheme 
expansion test fails executes test time period 
switch test 
neighbor compare integers denoted number times sends receives object time period number times sends receives object neighbor different time period 
sends copy object indication new singleton processor replication scheme discards copy 
example 
example demonstrate operation adr algorithm 
consider network add graph set edges see 
gamma gamma gamma gamma gamma gamma gamma gamma phi phi phi phi phi phi phi fig 

general graph network example suppose 
initial replication scheme 
second suppose processor processor issues reads writes time period processor issues reads writes time period 
third suppose requests serviced time period issued 
additionally assume cost edge initially requests responses processor routed processor note shortest path 
words tree father tree father 
requests responses processor routed processor 
time period processor neighbor processors executes expansion test 
number reads requested delta ouri wolfson processor number writes requested processors processor enter replication scheme 
number reads requested processor number writes requested processors 
processor enter replication scheme result test 
number reads requested processor number writes requested processors 
processor enters replication scheme 
assume request issued processor second time period read 
read received propagated shortest path goes processor replica 
replies sending object directly 
tree father changes 
second time period processors execute tests 
processor performs expansion test processors fails 
processor performs contraction test fails processor receives writes processor reads processors 
time processor executes expansion test processor fails 
contraction test executed processor fails receives write requests processor read requests processors 
starting second time period replication scheme stabilize 
total communication cost time period replication scheme initial replication scheme 
optimal replication scheme total communication cost 
easy see theorem holds adr algorithm algorithm preserves replication scheme connectivity 
show regular read write pattern communication cost requests time period decreases time replication scheme changes 
implies replication scheme stabilize 
words regular read write pattern starting connected replication scheme communication cost decreases time period time period replication scheme change 
point communication cost fixed time period 
stated statement proof theorem definitions assumptions section 
say regular schedule blind writes write issued processor preceded read processor issued time period 
theorem 
suppose integer schedule regular blind writes 
suppose adr algorithm changes replication scheme th time period 
communication cost requests time period lower communication cost requests time period proof 
prove theorem considering expansion contraction switch show changes decreases cost requests time period 
switch clearly case 
expansion 
suppose th time period processor tree father processor replica th time period replication adaptive data replication algorithm delta scheme expanded observe way algorithm operates read issued processor time period serviced processor reads issued time period serviced furthermore writes issued time period processor replication scheme reach notation 
rx set processors reads issue time period serviced sending object wx set processors writes issue time period sent rx set processors reads issue time period serviced wx set processors writes issue time period sent consider expansion affects cost requests 
cost write issued processor wx higher time period time period 
cost read issued processor rx rx lower time period time period 
show rx rx wx wx 
adr algorithm expanded know total number reads issued processors rx higher total number writes issued processors wx 
conclude expansion reduces cost requests time period 
left show rx rx wx wx 
containment suppose processor rx 
means shortest path goes furthermore means tree father path replication scheme goes request issued time period serviced second containment suppose processor wx 
blind writes rx previous containment rx 
way writes processed definition wx wx 
contraction 
suppose th time period processor replication scheme tree neighbor replication scheme processor suppose th time period contracts replication scheme 
notation 
rx set processors reads issue time period serviced wx set processors writes issue time period sent wx set processors writes issue time period sent consider contraction affects cost requests 
cost read issued processor rx higher time period time period 
observe fact contracted implies words processor rx shortest path goes delta ouri wolfson number writes issued processors wx higher number reads issued processors rx 
assume replication scheme time period identical time period processor replica 
easy see cost write issued processor wx increase time period compared time period complete proof contraction reduces cost show cost write processor wx lower time period compared time period wx clearly cost lower contraction 
suppose wx consider write time period cost cost tree father path replication scheme cost tree spanning replication scheme 
observe wx replication scheme time period 
cost write issued time period cost tree father path cost tree spanning replication scheme 
notice difference cost higher tree father path replication scheme changed go read issued time period 
cost lower time period compared time period conjecture performance adr algorithm improved write propagated carries identification processors replication scheme traversed 
words processor replication scheme propagates write tree neighbors appends identification message propagated 
processor replication scheme receives write knows path replication scheme traversed write 
means knows replication scheme tree neighbors replica 
study conjecture scope 

relevant generally main purposes data replication performance reliability 
address performance issue 
existing works replicated data consider problem static replication establishing priori replication scheme optimize performance remain fixed runtime 
called file allocation problem studied extensively literature see foster survey wolfson milo ozsu valduriez problem 
contrast approach taken works static replication assume read write pattern priori 
example wolfson milo shown finding static optimal replication scheme arbitrary network modeled general graph read write pattern np complete problem 
shown problem solved efficiently tree ring topologies 
motivated realization algorithm tree networks lends naturally distribution 
results wolfson milo indicate comparable algorithm distributed adaptive data replication algorithm delta efficient convergent optimal exist general networks 
works quorum consensus agrawal bernstein gifford kumar thomas triantafillou taylor voting coterie agrawal el abbadi adam tewari garcia molina barbara herlihy jajodia paris berman refer performance presence failures 
address issue dynamically adjust read write quorums votes order minimize data accesses case site failures network partition 
approach improve performance replicated database relax serializability requirement 
works quasi copies alonso alonso barbara garcia molina lazy replication ladin ladin ladin bounded ignorance krishnakumar bernstein fall category 
contrast show section adaptive replication algorithms propose combined concurrency control algorithm preserve copy serializability 
works address problem dynamic vs static data replication published awerbuch bartal 
need dynamic replication pointed sheng barbara garcia molina 
algorithms bartal randomized require centralized decision making processor aware requests network 
furthermore assume requests serial reads occur concurrently clear algorithms combined concurrency control mechanism 
summary think bartal algorithms applicable distributed database environment 
awerbuch presents competitive distributed deterministic algorithm dynamic data allocation 
algorithm sketchy manner basically operates follows 
write copy created writing processor copies deleted 
read object replicated shortest path replication scheme reading processor 
algorithm intricate data tracking component enables processor efficiently locate processors replication scheme 
component read write operations 
huang wolfson huang wolfson discussed similar algorithms proven competitive slightly different models 
awerbuch algorithm competitive means exists constant sequence read write requests cost awerbuch algorithm theta cost lower bound offline algorithm 
communication cost awerbuch algorithm may worse lower bound constant factor factor independent number requests awerbuch algorithm case factor log number processors network 
words competitive algorithm provides guarantee performance algorithm worst case input 
worst case input sequence requests point time request worst current configuration replication scheme case 
intuitively reason awerbuch algorithm erases copies delta ouri wolfson writing processor write 
creating updating replicas requires communication worst case request take advantage communication worst case request write read processor farthest replica depending maximizes communication cost current replication scheme 
assume time request maximizes cost 
schedules assume read write pattern processor time period repeated time periods 
words read write pattern time period cases predictable read write pattern immediately preceding time period 
case adr algorithm performs best 
hand competitive algorithm take advantage schedule regularity 
shown regular schedules adr algorithm superior 
example assume initial replication scheme consists set processors consider regular sequence requests time period write processor followed read processor 
communication cost adr algorithm time period cost write cost propagating object processors reads free 
hand awerbuch algorithm time period incurs communication cost deleting copies 
incurs cost propagating read requests 
incurs cost propagating object processors 
cost incurred adr algorithm 
replication scheme oscillates set processors example demonstrates awerbuch algorithm convergent 
suppose example schedule perfectly regular time periods read missing 
clearly case adr algorithm outperforms awerbuch algorithm 
strict regularity schedule necessary superiority adr 
wolfson jajodia proposed earlier version adr algorithm called car 
contrast adr algorithm car processor examines replication scheme may change result read write request 
increases overhead adaptive replication 
report experimental performance analysis devise protocol handle failures extend analysis weighted communication links extend adr algorithm networks modeled general graphs new contributions compared wolfson jajodia 

purpose adaptive replication algorithms improve performance distributed systems adjusting replication scheme object number copies object location current access pattern network 
proposed adaptive data replication adr algorithm executed distributively processors tree network 
execution adr algorithm integrated processing reads writes object 
discussed various issues related incorporation adr algorithm adaptive data replication algorithm delta distributed systems 
specifically proposed method coping storage space limitations various processors network discussed incorporation adr various replica consistency protocols phase locking discussed method adjusting adr algorithm consider priori information read write activity network 
addressed issues failure recovery adaptive replication 
particular showed methods handling failures recovery static replication necessarily carry dynamic case 
proposed mechanism write activity may continue failures occur network 
analyzed theoretically experimentally communication cost adr algorithm average number messages necessary servicing read write request 
theoretical analysis algorithm performed new model introduced 
showed steady state adr converges replication scheme optimal regardless initial scheme 
convergence occurs number time periods example time period may minute bounded diameter network 
experimental results showed 
fixed randomly generated read write pattern communication cost adr algorithm lower optimal static replication scheme 
optimal replication scheme read write pattern fixed known priori 
read write pattern known priori varies time communication cost adr algorithm lower static replication 
compared performance adr algorithm ideal unrealistic algorithm knows read write requests 
words adr algorithm online sense adjust replication scheme knowledge past read write requests ones 
optimal way adjusting replication scheme clearly depends requests ideally processor writes object send write processors read object 
lower bound obtained offline algorithm 
devised lower bound algorithm experimentally compared performance adr algorithm 
experiments shown average adr algorithm incurs communication cost times lower bound algorithm 
extended adr algorithm operate network topology modeled general graph 
shown steady state starting initial replication scheme adr algorithm change scheme time period long improve performance 
possible replication scheme stabilize communication cost final replication scheme low initial 
acknowledgments wish jeff ullman moti yung helpful discussions 
referees valuable suggestions 
narayanan steady state read write pattern object regular processor performs reads writes time period 
regular read write pattern may known priori furthermore may change time day day 
delta ouri wolfson raj developing software run experiments 
adam tewari 
regeneration virtual copies distributed computing systems 
ieee trans 
softw 
eng 
june 
agrawal bernstein 
nonblocking quorum consensus protocol replicated data 
ieee trans 
parall 
distrib 
syst 
april 
agrawal el abbadi 
tree quorum protocol efficient approach managing replicated data 
proceedings sixteenth international conference large databases 
alonso barbara garcia molina 
quasi copies efficient data sharing information retrieval systems 
proceedings edbt lncs 
springer verlag 
alonso barbara garcia molina 
data caching issues information retrieval system 
acm trans 
database syst 

awerbuch bartal fiat 
optimally competitive distributed file allocation 
fifth annual acm stoc victoria canada pp 

badrinath imielinski 
replication mobility 
proceedings second workshop management replicated data ii monterey ca pp 

badrinath imielinski 
locating personal communication networks 
proceedings workshop networking personal communication applications 
barbara garcia molina 
case controlled inconsistency replicated data 
proceedings ieee workshop replicated data 
barbara garcia molina 
replicated data management mobile environments new sun manuscript 
bartal fiat rabani 
competitive algorithms distributed data management 
fourth annual acm stoc victoria canada 
bernstein hadzilacos goodman 
concurrency control recovery database systems 
addison wesley 
ceri 
distributed database principles systems 
mcgraw hill 
foster 
comparative models file assignment problem 
acm comput 
surv 

sengupta wolfson yemini 
design network management system 
proceedings second international symposium integrated network management washington sengupta wolfson yemini 
network management environment 
ieee network fischer michael 
sacrificing serializability attain high availability data unreliable network 
acm principles database systems pp 

garcia molina barbara 
assign votes distributed system 
acm 
sheng 
dynamic file migration distributed computer systems 
commun 
acm 
gifford 
weighted voting replicated data 
proceedings seventh acm symposium operation system principles pp 

goodman 
trends cellular cordless communications 
ieee communications magazine 
grudin 
special section computer supported cooperative 
commun 
acm 
herlihy 
dynamic quorum adjustments partitioned data 
acm trans 
database syst 

adaptive data replication algorithm delta huang wolfson 
competitive dynamic data replication algorithm 
ieee proceedings ninth international conference data engineering pp 

huang wolfson 
dynamic allocation distributed system mobile computers 
ieee proceedings tenth international conference data engineering pp 

matthews stephens yesha 
minimizing message complexity partially replicated databases hypercube networks 
tech 
rep tr cs july dept computer science university maryland baltimore county 
imielinski badrinath 
querying highly mobile distributed environments 
proceedings eighteenth international conference large databases pp 

jajodia 
dynamic voting algorithms maintaining consistency replicated database 
acm trans 
database syst 
june 
krishnakumar bernstein 
bounded ignorance replicated systems 
proceedings acm principles database systems 
kumar 
hierarchical quorum consensus new algorithm managing replicated data 
ieee trans 
comput 
september 
ladin liskov shrira 
technique constructing highly available distributed services 
algorithmica 
ladin liskov shrira 
lazy replication exploiting semantics distributed services 
proceedings workshop management replicated data pp 

ladin liskov shrira ghemawat 
providing high availability lazy replication 
acm trans 
comput 
syst 
november 
ozsu valduriez 
principles distributed database systems 
prenticehall 
paris 
voting variable number copies 
fault tolerant computing symposium pp 

sengupta schwartz wolfson yemini 
model network management 
ieee network operations management symposium san diego ca pp 

berman 
voting optimal static pessimistic scheme managing replicated data 
ieee trans 
parall 
distrib 
syst 
january 
thomas 
majority consensus approach concurrency control multiple copy database 
acm trans 
database syst 
june 
triantafillou taylor 
multiple replica classes improve performance distributed systems 
proceedings eleventh international conference distributed computing systems pp 

wolfson jajodia 
distributed algorithms adaptive replication data 
acm principles database systems san diego ca pp 

wolfson milo 
multicast policy relationship replicated data placement 
acm trans 
database syst 

wolfson sengupta yemini 
managing communication networks monitoring databases 
ieee trans 
softw 
eng 
september 
appendix proof theorem proof proceeds stages corresponds subsection 
stage prove adr algorithm stabilizes 
second stage prove stabilization occurs time periods diameter tree network 
third stage show stability scheme optimal read write pattern time period 
appendix assume regular schedule read write pattern delta ouri wolfson time period order prove theorem prove lemmas 
proofs lemmas notations 
adjacent processors tree network suppose edge removed 
denote connected component containing connected component 
denote number requests reads writes issued nw number writes issued nr number reads issued 
adr algorithm stabilizes lemma 
consider processors replication scheme adr algorithm different time periods respectively 
processor unique path replication scheme adr algorithm time period proof 
proof follows easily theorem 
lemma 
switch test succeeds subsequently expansion test succeed 
proof 
suppose time period object switched processor processor 
switch test executed expansion test neighbors including fails derive nr nw 
subtracting second inequality obtain nw nr 
expansion test fail 
show expansion test neighbor fail 
clearly nr nr tree subgraph tree 
similarly nw nw 
combining inequalities second inequality paragraph derive nr nw 
inequality implies expansion test fail 
lemma 
processor exits replication scheme result contraction test reenter replication scheme result expansion test 
proof 
suppose time period fringe processor single neighbor nw nr 
deleted contraction test 
assume way contradiction time period told processor join replication scheme result expansion test executed consider time happens time replication scheme result expansion test 
nr nw 
lemma time periods result switch test 
replication scheme time periods lemma know path go cycle tree network 
inequalities contradict 
need result proof theorem mention processor exit replication scheme result contraction test reenter result switch test 
adaptive data replication algorithm delta lemma 
processor exits replication scheme result switch test reenter replication scheme 
proof 
suppose object switched time period 

lemma singleton replication scheme expand switch neighbor stabilize 
inequality obtained replication scheme switch tree network edge path connects switched replication scheme lemma follows 
lemma 
adr algorithm stabilize finite number time periods 
proof 
lemmas indicate processor exits replication scheme reenter exit contraction test reentry switch test 
successful switch test lemma subsequent change replication scheme occur switch test 
lemma processor exit replication scheme 
processor exit twice replication scheme contraction switch 
consequently time period starting processor exits replication scheme 
starting replication scheme expand 
number processors finite adr algorithm stabilize finite number time periods 
adr algorithm stabilizes time periods proofs lemmas denote replication scheme time period denote replication scheme resulting tests executed th time period denote stability scheme 
length path processors number communication links tree network length denoted jqj 
distance processors denoted dist length path 
lemma 
singleton singleton 
proof 
suppose fxg 
prove lemma cases 
gamma singleton gamma singleton 
suppose gamma singleton gamma fzg 
replication scheme stabilizes fxg 
lemma singleton 
second suppose gamma singleton 
gamma definition adr algorithm processor successfully expand contract replication scheme time period 
suppose arbitrary neighbor gamma contracted replication scheme time period reenter replication scheme result expansion test lemma 
expansion fails time period 
suppose gamma time period expansion fails gamma expansion failed time delta ouri wolfson period expansion test executed processor fails singleton replication scheme fxg switch stabilize 
lemma 
suppose rw singleton suppose time period gamma fringe processor single neighbor gamma exits replication scheme contraction test 
max dist 
processor belonging replication scheme time period distance away 
proof 
show 
assume way contradiction 
rw singleton processor enter replication scheme result switch test time period gamma lemma processor entered replication scheme time th time period result expansion test executed nr nw 
inequality implies contraction test executed processor time period fails 
contradicts fact exits contraction test 
prove equality max dist induction consider case exits replication scheme time period 
fringe processor neighbor set consists equality holds 
fig 

suppose equality holds 
consider case suppose dist max dist 
fringe processor time period neighbors farther away singleton replication scheme exist unique neighbor path connects dist dist gamma see 
executes successful contraction test time period nr nw 
subtree nr nr 
similarly nw nw 
inequalities combined imply nr nw 
fringe processor contracts replication scheme time period 
adaptive data replication algorithm delta previous paragraph conclude max dist max dist gamma 
starting second time period non singleton replication scheme processor exits replication scheme gamma time periods 
induction hypothesis obtain gamma max max dist 
pair connected replication schemes denote dist length shortest path dist min dist 
suppose longest path processor processor jp dist max dist 
lemma 
singleton fjg singleton time periods adr algorithm stabilizes 
proof 
suppose time period replication scheme gamma singleton 
words rw singleton gamma 
gamma fkg 
singleton 
claim 
longest path processor 
proof prove claim way contradiction 
suppose lemma replication scheme switches starting time period replication scheme moves step time period reaches total dist time periods lemmas replication scheme diverge path come back 
fsg 
denote closest processor see 
possible fig 

draw contradiction cases 
case 
demonstrate processor farther away contradicting definition path connected processors including path connecting belong time period replication scheme singleton time lemma replication scheme time periods furthermore processor exit replication scheme contraction test time period obtain nr nw 
time period switch test succeeds obtain 
subtracting inequality second obtain nw nr 
inequality implies fringe processor replication scheme contraction delta ouri wolfson test succeed 
know exit replication scheme time periods 
fringe 
furthermore observe time period processor path exits replication scheme time period remember path 
fringe processor dist time periods 
implies fringe processor dist time periods 
exist processor dist dist see 
clearly dist dist dist dist dist dist 
inequalities obtain dist dist 
fig 

case ii 
consider 
lemma processor replication scheme enters scheme 
way defined join replication scheme result expansion test executed nr nw 
time period switch test succeeds 
subtracting inequality second obtain nw nr 
time period expansion test switch test succeeded 
contradiction 
claim 
dist max dist dist 
proof prove claim cases 
cases claim 
case 
show dist max dist way contradiction 
suppose exists processor dist dist 
definition easily see suppose neighbor path path go farther away contradiction selection go see 
processors exit replication scheme exits 
fringe processor contracts 
adaptive data replication algorithm delta fig 

lemma way defined execute successful contraction test time period nr nw 
lemma starting time period replication scheme consists single processor starts move step time period 
time period replication scheme switches switch implies inequalities 
nr nw expansion test fails switch test succeeds 
subtracting inequality second obtain nw nr 
contradicts inequality obtained previous paragraph 
dist max dist 
lemma conclude neighbor exits replication scheme dist time periods dist 
case ii 
know claim dist max dist proves part claim 
denote closest processor denote neighbor path situation 
fig 

definition enter replication scheme expansion test executed processor claim gamma fk xg 
reasons gamma singleton includes neighbors time period expansion test fail lemma expansion test succeeded include neighbors 
delta ouri wolfson gamma fkg contracts replication scheme time period gamma lemma conclude gamma dist 
claim adr algorithm takes dist time periods shrink singleton replication scheme fkg 
lemmas time period replication scheme starts move fkg fjg reaches fjg dist time periods 
stabilizes 
observe dist dist claim 
words adr algorithm stabilizes time periods 
obviously length longest path tree 
lemma 
singleton time periods adr algorithm stabilizes 
proof 
order prove lemma state claims 
claim 
singleton proof follows easily lemma 
claim 
processor dist 
proof follows easily lemma 
claim 
exists processor 
furthermore remember length path 
proof claim processor enters replication scheme dist time periods 
suppose neighbor path connects processors subtree 
claim proces fig 

sor fringe processor contract replication scheme 
suppose time period processor fringe processor neighbor replication scheme suppose time period processor executes successful contraction test 
easy see different see 
lemma processor reenter replication scheme stability scheme subtree 

lemma derive max dist 
dist 
path goes dist rw lemma claim 
exists processor proof suppose processor closest suppose neighbor path see 
lemma processors subtree contract max dist adaptive data replication algorithm delta fig 

time periods 
definition know max dist 
exits replication scheme time period lemma re enters 
claim know expansion contraction tests may succeed 
claim processor stability scheme replication scheme time period dist 
lemma processor exit replication scheme 
clearly definition dist processors enter replication scheme time periods exit 
subset claims processor stability scheme lemma 
fig singleton time periods adr algorithm stabilizes 
proof 
time period test succeeds switch test succeeds expansion test succeeds 
prove lemma cases 
case test succeeds 
time period algorithm stabilizes lemma follows trivially 
case ii replication scheme switches 
lemma successful expansion tests possible successful tests switch tests 
unique path connecting tree lemma algorithm move replication scheme time periods stabilize 
obviously diameter tree length longest path tree 
case iii replication scheme expands 
replication scheme second time period singleton 
lemmas starting second time period time periods algorithm stabilizes 
example shows read write patterns stabilization take time periods 
consider network processors initial replication scheme fig 
read write pattern issues read write issues reads writes time period 
replication expand time period 
time period processor contract replication scheme stabilize fjg 
delta ouri wolfson stability scheme optimal read write pattern lemma 
suppose connected replication scheme 
suppose neighbor processor adjacent cost fig gamma cost nw gamma nr delta proof 
consider cost requests subtrees changes adding processor scheme see 
cost fig 

reads subtree change write subtree cost propagating requests costly nw delta 
consider requests subtree 
read cost accessing copy read access copy cost writes change 
requests costly nr delta 
lemmas assume stability scheme singleton analyze special case singleton stability scheme 
lemma 
suppose neighbor processor adjacent nw nr proof 
singleton exists fringe processor connected processors lie path belong suppose neighbor path see 
obviously nr nr nw nw 
fig 

stability scheme contraction test fringe processor fail 
nw nr 
inequalities imply nw nr 
adaptive data replication algorithm delta lemma 
suppose connected replication scheme 
suppose processor path links adjacent cost cost fkg 
proof 
assume path links gamma gamma gamma gamma processors path see 
obviously nr nr nw nw 
fig 

lemma nw nr 
combining inequalities obtain nw nr 
inequality lemma easily see cost cost fkg 
lemma indicates connected replication scheme contains fringe processors connected replication scheme contains processors lemma 
suppose different connected replication schemes 
suppose subset 
exist fringe processor subtree network induced proof straightforward 
lemma 
suppose connected replication scheme 
cost cost 
proof 
prove lemma induction number processors np lemma follows trivially 
suppose lemma holds contains gamma processors 
consider case contains processors 
lemma know exists fringe processor suppose closest processor path gamma gamma gamma gamma see 
fig 

delta ouri wolfson fig 

show cost cost fjg lemma follow induction hypothesis 
stability scheme contraction test fail 
nr nw 
obviously nr nr nw nw 
inequalities obtain nr nw 
inequality lemma cost cost fjg 
lemma 
suppose connected replication scheme ae cost cost 
proof 
prove lemma induction number processors nf suppose lemma holds connected replication scheme consists gamma processors 
assume consists processors 
lemma exists fringe processor suppose closest processor path gamma gamma gamma gamma see 
stability scheme expansion test fail nr nw 
obviously nr nr nw nw 
inequalities nr nw 
inequality lemma conclude cost cost 
obviously connected replication scheme nf contains gamma processors 
induction hypothesis conclude cost cost 
lemma follows inequalities 
lemma 
suppose arbitrary connected replication scheme 
cost cost 
proof 
prove lemma cases case 
lemma cost cost lemma cost cost 
case ii 
exists unique path links tree network 
suppose gamma gamma gamma gamma gamma path processors belong denote set processors path applying lemma times obtain cost cost 
connected replication scheme 
proof case know cost cost 
adaptive data replication algorithm delta lemma 
suppose adjacent processors tree network 
cost fig gamma cost fjg gamma delta 
proof 
obvious lemmas assume stability scheme singleton fkg 
lemma 
suppose connected replication scheme cost cost 
proof 
prove lemma induction number processors singleton lemma follows trivially 
suppose lemma holds set connected processors gamma processors 
consider case processors 
lemma exist fringe processor say suppose path gamma gamma gamma gamma stability scheme expansion test failed nr nw 
obviously nr nr nw nw 
inequalities imply nr nw 
inequality lemma obtain cost cost fpg 
connected replication scheme gamma processors 
induction hypothesis obtain cost cost 
lemma follows inequalities 
lemma 
suppose connected replication scheme cost cost 
proof 
prove lemma induction number processors consider singleton replication scheme fig suppose path gamma gamma gamma gamma stability scheme switch test fail 
obviously 
inequalities imply 
inequality lemma conclude cost fig cost fqg 
technique repeatedly path show cost fig cost fqg cost fjg cost fkg 
suppose lemma holds connected replication scheme gamma processors 
assume processors 
suppose closest processor path gamma gamma gamma gamma lemma know exists fringe processor fig 
suppose processor path gamma gamma gamma connected processor belong path overlaps path path linking concatenation gamma gamma gamma gamma gamma gamma gamma see 
stability scheme expansion test failed nr nw 
obviously nr nr nw nw 
inequalities imply nr nw 
inequality lemma conclude cost cost fpg 
connected replication scheme delta ouri wolfson fig 

gamma processors 
induction hypothesis cost cost 
cost cost 
proof theorem 
lemma lemmas conclude schedule regular adr algorithm stabilize time periods 
denote stability scheme suppose arbitrary replication scheme 
theorem suffices show cost cost connected replication scheme replication scheme inequality follows lemmas 
appendix pseudo code adr algorithm code uses variables req id req request type 
request types read write time slice expires exit join switch 
id processor identification request submitted 
time slice expires request executed processors replication scheme 
requests executed processors network 
processor network maintains directory record nb drt neighbors 
neighbor nb nb drt object replicated processor path goes nb 
nb replica clearly nb drt 
replica nb drt exactly neighbor nb 
adr algorithm uses directory information routing read write requests replicated object 
processor replica object maintains counters sumw nb nb counts total number reads performed requests issued locally neighbor sumw counts total number writes performed nb counts total number reads submitted neighbor nb nb counts total number writes propagated neighbor nb 
void adr req id switch req case id read request break case id write request break adaptive data replication algorithm delta case id scheme change request time expired break case id exit request break case id join request break case id switch request break default fprintf stderr parameter err adr 
break void id procedure called read request issued locally id id message neighbor received indicating neighbor wants read object case id neighbor id 
replica object retrieve object local database send object processor id id id nb neighbor nb submitted read local replica find neighbor nb nb drt submit read request nb wait reply getting object send processor id void id replica object update local replica sumw id id write issued neighbor nb nb drt propagate write nb write propagated find neighbor nb nb id id nb neighbor nb nb drt nb nb delta ouri wolfson propagate write nb local replica find neighbor nb nb drt submit write request nb void id am singleton replication scheme local replica object nb drt neighbors expansion expansion expansion test failed switch am processor local replica object nb drt neighbor nb expansion am processor am processor replica object nb drt exactly neighbor nb contraction am processor contraction sumw reset counters neighbor nb nb nb int expansion procedure returns expansion test succeeds neighbor joins replication scheme procedure call returns int succeed neighbor nb nb drt nb sumw nb send join message nb replica object message processed procedure nb drt succeed return succeed adaptive data replication algorithm delta int switch procedure returns switch test succeeds singleton replication scheme switches neighbor returns int succeed succeed exists unmarked neighbor nb nb nb sumw send nb message join singleton scheme replica object message processed procedure nb drt delete local replica deallocate counters succeed mark nb return succeed int contraction procedure called processor 
observe pair processors constitute replication scheme may call procedure time contraction 
special care needs taken prevent contraction find neighbor nb nb drt nb send exit message nb wait response response may exit delete local replica deallocate counters exit request nb received id nb id delete local replica deallocate counters send message nb saying may exit send message nb saying may exit nb drt response may exit nb drt void id procedure called exit message received neighbor id 
processor request delta ouri wolfson executing contraction test time 
send message neighbor id saying may exit id drt void id procedure called join message received neighbor id save object local database allocate counters initialize void id procedure called join singleton scheme message received neighbor id save object local database id drt allocate counters initialize 
