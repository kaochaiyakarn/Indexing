job shop scheduling local search vaessens aarts lenstra 
eindhoven university technology department mathematics computing science box mb eindhoven email win tue nl 
philips research laboratories box ja eindhoven email aarts prl philips nl 
cwi box gb amsterdam survey solution methods job shop scheduling problem emphasis local search 
deterministic randomized local search methods proposed neighborhoods discussed 
compare computational performance various methods terms effectiveness efficiency standard set problem instances 
key words job shop scheduling local search iterative improvement shifting bottleneck heuristic simulated annealing taboo search variable depth search genetic algorithms constraint satisfaction 
job shop scheduling problem set jobs set machines 
machine handle job time 
job consists chain operations needs processed uninterrupted time period length machine 
purpose find schedule allocation operations time intervals machines minimum length 
problem difficult solve optimality 
example relatively small instance jobs machines operations due fisher thompson remained unsolved 
solution methods proposed ranging simple fast dispatching rules sophisticated branch bound algorithms 
survey algorithms job shop scheduling problem emphasis local search 
decade different types local search algorithms job shop scheduling developed proved effective 
structured follows 
section models job shop scheduling problem 
section complexity problem methods solution reviewed 
section introduces local search section discusses representations neighborhoods problem 
sections describe constructive iterative algorithms local search respectively section describes techniques 
section contains computational results section gives concluding remarks 
job shop scheduling problem job shop scheduling problem formally defined follows 
set operations set machines set jobs 
operation processing time unique machine requires processing unique job belongs 
binary relation defined represents precedences operations performed induces total ordering operations belonging job precedences exist operations different jobs 
furthermore 
schedule function operation defines start time 
schedule feasible length schedule max earliest time operations completed 
problem find optimal schedule feasible schedule minimum length 
feasible schedule left justified operation start earlier changing processing order machine 
active operation start earlier delaying operation 
note optimal schedule active active schedule left justified 
instance problem represented means disjunctive graph vertices represent operations arcs represent precedences operations edges ffv wg represent machine capacity constraints 
vertex weight equal processing time 
orientation function omega theta omega gamma fv wg fv wg write omega gamma omega gamma partial orientation orientation complete orientation orientation omega feasible digraph omega gamma acyclic 
represents machine machine ordering order processes operations 
feasible schedule uniquely determines feasible complete orientation denoted omega conversely feasible complete orientation omega gamma unique left justified feasible schedule denoted omega omega equals length longest path digraph excluding length omega equals length longest path digraph 
finding optimal left justified schedule equivalent finding feasible complete orientation minimizes longest path length corresponding digraph 
search schedule restricted set active schedules 
feasible complete orientation omega gamma clear sight omega active activeness depends sizes processing times left 
reason considers larger set left justified schedules 
complexity algorithms give brief review results computational complexity job shop scheduling lower bounds enumeration schemes branch bound methods approximative approaches yield upper bounds optimum 
techniques type proceed local search discussed rest 
complexity special cases problem solved polynomial time immediate generalizations np hard 
results summarized table denotes number operations jth job 
note due result np hard find job shop schedule shorter times optimum 
table complexity job shop scheduling solvable polynomial time np hard strong sense length length jackson lenstra rinnooy kan brucker lenstra rinnooy kan akers brucker williamson hall lenstra shmoys lower bounds optimization algorithms problem employ form tree search 
node tree usually characterized partial orientation omega subset ae question compute lower bound length feasible schedule corresponding completion omega gamma subsequent authors obtained lower bound simply disregarding computing longest path length digraph omega gamma 
florian obtained stronger single machine bound relaxing capacity constraints machines 
machine propose solve job shop scheduling problem disjunctive graph omega gamma ffv wg 
single machine problem arcs omega gamma define release delivery times operations precedence constraints 
lenstra rinnooy kan pointed lower bounds appear special cases bound 
example relaxing capacity constraint gives bound allowing preemption gives bound current branch bound codes 
bound np hard compute fairly efficiently strengthened carlier pinson compute larger release delivery times ere er es observe arcs define delays precedence related operations balas lenstra vazacopoulos develop algorithm computing bound subject delayed precedences 
fisher lenstra rinnooy kan investigated surrogate duality relaxations machine capacity constraints precedence constraints operations job weighted aggregated single constraint 
balas described attempt obtain bounds polyhedral techniques 
applegate cook review valid inequalities studied gave new ones 
computational performance surrogate duality polyhedral bounds reported disappointing view achieved hard problems 
enumeration schemes traditional enumeration scheme due thompson generates active schedules constructing front back 
node machine earliest possible completion time unscheduled operation achieved determined unscheduled operations start earlier point time machine selected turn 
branch bound algorithms flexible enumeration schemes 
carlier pinson applegate cook branch selecting single edge orienting ways 
brucker follow grabowski block approach 
authors apply preemptive single machine bound host elimination rules 
details refer literature 
celebrated theta instance fisher thompson easy reach methods theta instances current limit 
main deficiency existing optimization algorithms job shop scheduling weakness lower bounds 
situation brighter respect finding upper bounds 
upper bounds upper bounds optimum usually obtained generating schedule computing length 
obvious step apply dispatch rule schedule operations priority function 
haupt surveys rules 
tend exhibit erratic behavior procedure proposed dell trubian safer alternatives 
step try improve schedule sort local search 
entirely different approach taken steinitz vector sum theorem develops polynomial time algorithms finding upper bound absolute error independent number jobs 
shmoys stein wein improve results 
local search local search employs idea solution may improved making small changes 
solutions changed better better solutions 
need notions 
set feasible solutions 
functions defined cost function mapping ir cases closely related function optimized 
neighborhood function mapping defines solution neighborhood solution called neighbor roughly speaking execution local search algorithm defines walk solution visited neighbor previously visited 
solution called local minimum respect neighborhood function 
basic algorithm find local minimum called iterative improvement 
starting initial feasible solution neighborhood searched solution lower cost 
solution algorithm continued local minimum 
quality local minimum depends initial solution neighborhood function method searching neighborhoods 
initial solution may obtained generating randomly applying heuristic rule 
choice neighborhood difficult 
clear trade small large neighborhoods number neighbors larger probability finding neighbor may higher looking takes time 
alternatives searching neighborhood may take neighbor lower cost improvement take best neighbor entire neighborhood best improvement take best sample neighbors provided improving 
problem remains 
local optima obtained may poor quality 
variants iterative improvement proposed 
main variants divided threshold algorithms taboo search algorithms search algorithms genetic algorithms 
threshold algorithms neighbor solution new current solution cost difference current solution neighbor certain threshold 
distinguishes kinds threshold algorithms 
classical iterative improvement thresholds true improvements accepted 
threshold accepting thresholds nonnegative 
large algorithm execution gradually decrease 
general rules determine appropriate thresholds lacking 
simulated annealing thresholds positive stochastic 
values equal gammat ln control parameter called temperature value gradually decreases course algorithm execution cooling schedule drawn uniform distribution 
time neighbor compared current solution drawn 
certain mild conditions simulated annealing guaranteed find optimal solution asymptotically 
taboo search selects subset permissible neighbors current solution solution minimum cost 
basic taboo search neighbor permissible taboo list satisfies certain aspiration criterion 
taboo list recalculated iteration 
implicitly defined terms forbidden moves current solution neighbor 
aspiration criterion expresses possibilities overrule taboo status neighbor 
variable depth search starts initial solution generates sequence subsequent neighbors making relatively small changes 
sequence solution selected serve initial solution sequence 
time sequence extended set neighbor chosen restricted sort taboo list list may defined implicitly terms forbidden moves 
time new sequence started list emptied 
genetic algorithms extended notion neighborhood function 
function mapping defines tuple set neighboring solutions 
solution called iteration set solutions called population 
population subsets size consisting parents selected subset called offspring determined operations called recombination mutation 
set current population combined reduced new population selecting subset solutions 
various solution methods combine local search constructive enumerative iterative techniques 
hybrid algorithms job shop scheduling dealt 
encounter constructive rules apply local search partial solutions combinations local search partial enumeration backtracking nested forms local search 
case local search applied levels different neighborhoods search explore different regions solution space 
solution representations neighborhood functions crucial ingredient local search algorithm definition neighborhood function combination solution representation 
basic representations neighborhood functions introduced job shop scheduling problem 
threshold taboo search algorithms left justified active schedules represented 
done specifying start times operations equivalently corresponding machine orderings operations 
representations especially combination genetic algorithms 
able define neighborhood functions need extra notions 
instance operation jp js denote immediate predecessor successor precedence relation provided exist 
feasible schedule operation mp ms denote immediate predecessor successor orientation omega provided exist 
schedule clear context delete subscript furthermore jp denotes jp jp provided exists similar notation js mp ms operations adjacent 
block maximal sequence size consisting adjacent operations processed machine belong longest path 
operation block internal operation block 
neighborhood functions proposed literature 
defined schedule corresponding orientation omega omega changed feasible orientation omega omega corresponding neighbor way neighbors schedule left justified 
properties helpful obtaining reasonable neighborhood functions 

feasible orientation reversing oriented edge longest path corresponding digraph results feasible orientation 

reversing oriented edge feasible orientation omega longest path results feasible orientation omega omega long omega 
feasible orientation omega gamma reversing oriented edge internal operations block results feasible schedule long omega 
feasible orientation omega gamma operations block longest path internal operation 
reversing results feasible schedule long omega true case operations block longest path internal 
view properties simplest neighborhood functions reversal exactly edge orientation 
van laarhoven aarts lenstra propose neighborhood function obtains neighbor interchanging adjacent operations block 
matsuo suh sullivan neighborhood function interchanges involving internal operations 
nowicki smutnicki neighborhood function excluding interchange operations block second internal interchange operations block internal 
schedule block blocks size neighbor note schedules optimal 
dell trubian propose neighborhood functions may reverse edge 
neighborhood function obtains operations ms longest path neighboring orientation permuting mp permuting ms interchanged feasible orientation results 
neighborhood function excludes solutions ms internal 
neighborhood function considers blocks size neighbor obtained positioning operation immediately front operations block provided resulting orientation feasible moved left right long orientation remains feasible 
neighborhood functions adjacent interchanges swaps balas vazacopoulos propose neighborhood function uses jumps 
precisely considers operations machine occurs prior longest path 
neighbor obtained inserting immediately immediately sufficient conditions derived new schedules feasible 
mp ms longest path improve current schedule disregarded 
adams balas propose neighborhood function may completely change machine ordering 
machine operation longest path neighbor obtained replacing orientation feasible orientation 
neighborhood functions obtain neighbor changing machine orderings time 
relatively small modifications neighborhood function matsuo suh sullivan edges simultaneously 
neighbor obtained interchanging adjacent operations ms block internal addition interchanging jp mp jp interchanging js ms js 
interchanges executed certain additional conditions satisfied see details 
aarts van laarhoven lenstra variant 
applegate cook propose neighborhood function drastically changes orientation 
neighborhood contains feasible orientations obtained simultaneously replacing orientation gamma machines feasible orientation 
small number depending storer wu completely different representations schedules 
modified version thompson algorithm see section 
suppose certain point earliest possible completion time unscheduled operation equal achieved operation earliest possible start time machine 
unscheduled operations start ffi gamma candidates position 
ffi priori chosen experiments ffi approaches active schedules generated ffi gives called non delay schedules 
representations defined 
representation represents schedule modified processing times operations 
modified thompson algorithm shortest processing time rule selection rule uniquely determines feasible orientation omega gamma omega computed original processing times corresponding schedule 
neighborhood function obtains neighbor increasing processing times amounts time independently drawn uniform distribution gamma 
priori chosen experiments 
representation represents schedule dividing scheduling horizon time windows experiments assigning set dispatch rules window 
modified thompson algorithm determines schedule applying dispatch rule corresponding window 
neighborhood function changes dispatch rule window schedule 
genetic algorithms types representations natural algorithms artificial string representations 
type representation yamada nakano propose function schedules determines neighbor thompson algorithm 
algorithm choose operations takes small ffl operation probability gamma ffl operation probability gamma ffl random operation available operations probability ffl 
aarts van laarhoven lenstra propose function schedules determines neighbor repeating step times choose random arc change reversing arc provided belongs longest path type representation encodes schedule orientation string finite usually binary alphabet 
representations facilitate application functions involving operations crossover mutation see goldberg pp 
gamma number drawbacks 
schedule orientation may representatives 
conversely string represent schedule may nontrivial calculate corresponding schedule 
attempts circumvent difficulties functions operate strings meaningful effect context underlying problem 
consider genetic algorithms string representations detail 
constructive algorithms local search section discuss shifting bottleneck procedure variants 
algorithms construct complete schedule apply local search partial schedules way 
partial schedule characterized partial orientation omega subset length defined longest path length digraph omega gamma 
basic idea algorithms described follows 
algorithm goes stages 
stage orients edges operations specific machine 
way stage edges related machines oriented edges related machines oriented 
furthermore stage current partial schedule 
usually done applying iterative best improvement neighborhood function revises orientation machine scheduled 
orienting edges related machine optimal way requires solution single machine problem partial schedule defines release delivery times delayed precedence constraints 
algorithms discussed mainly differ order machines considered implementation iterative best improvement single machine algorithm 
original shifting bottleneck procedure sb adams balas orients stage edges related bottleneck machine 
unscheduled machine solution value corresponding single machine problem maximum delays precedence related operations taken account 
scheduling machine iterative best improvement applied cycles 
cycle scheduled machine reconsidered 
cycle handles machines order sequenced 
cycle completed machines reordered decreasing solution values single machine problems cycle 
machines scheduled cycles continue long improvements 
furthermore phase iterative best improvement orientations machines operations longest path deleted machines rescheduled 
applegate cook algorithm 
main difference stage iterative improvement cycles continue improvement 
ere er es take delays operations account 
develop heuristic single machine problem delayed precedences incorporate shifting bottleneck variant 
balas lenstra vazacopoulos optimization algorithm problem delayed precedences determine bottleneck machine procedure sb 
local search strategy differs adams balas minor details instance number cycles limited 
scheduling new machine apply iterative improvement delete orientations non critical machines reschedule machines 
extended procedure sb takes best solution sb variant sb reverses order procedures reschedule non critical machines apply regular iterative improvement 
balas vazacopoulos propose different procedure sb gls 
partial schedules applying variable depth search algorithm gls see section limited number iterations jump neighborhood function shifting bottleneck procedure variants incorporated algorithms 
employ form partial enumeration 
dorndorf pesch embed variant genetic algorithm see section 
adams balas develop algorithm pe sb applies sb nodes partial enumeration tree 
node corresponds subset machines scheduled certain way 
descendants machine scheduled 
schedule obtained solving single machine problem release delivery times defined parent node applying iterative improvement sb 
descendants created machines highest solution values single machine problem 
penalty function limit size tree 
details branching rule penalty function search strategy refer reader original 
applegate cook develop algorithm bottle employs partial enumeration different way 
bottle applies shifting bottleneck variant described long machine left unscheduled 
machines branches selecting remaining unscheduled machine turn 
values tested 
iterative algorithms local search algorithms section start feasible schedules manipulate attempt find better schedules 
naturally divided threshold algorithms taboo search algorithms variable depth search algorithms genetic algorithms 
threshold algorithms basic threshold algorithms iterative improvement threshold accepting simulated annealing 
consider closely related variants 
stated schedule represented ordinary way starting times orientation 
iterative improvement simplest threshold algorithm 
aarts van laarhoven lenstra test iterative improvement neighborhood functions obtain fair comparison algorithms apply multi start strategy run algorithm randomly generated start solutions limit total running time reached take best solution individual runs 
algorithm shuffle applegate cook uses neighborhood function iteration schedule small number heuristically selected machines remains fixed schedule remaining machines optimally revised branch bound algorithm edge finder 
initial solution take result bottle 
storer wu propose variant iterative improvement called ps representation neighborhood function solution fixed number neighbors experiments determined best new solution 
test standard iterative improvement algorithm called representation neighborhood function neighbors generated randomly algorithm stops fixed number iterations experiments 
threshold accepting implemented aarts van laarhoven lenstra algorithm ta uses neighborhood function threshold values determined empirically 
simulated annealing tested authors 
van laarhoven aarts lenstra neighborhood function aarts van laarhoven lenstra algorithm sa algorithm sa 
matsuo suh sullivan controlled search simulated annealing algorithm bi level variant incorporates standard iterative improvement 
schedule neighbor selected neighborhood function accepted rejected simulated annealing criterion 
case subjected iterative improvement resulting local optimum improves accepted new solution 
method differs implementations simulated annealing acceptance probability schedule inferior current schedule independent difference schedule length 
taboo search algorithms taboo search algorithm ts taillard uses neighborhood function arc reversed interchange machine successor put taboo list 
iterations new length taboo list randomly selected range 
length neighbor estimated way estimate exact operations involved longest path lower bound 
permissible neighbors schedule minimum estimated length selected new schedule 
algorithm ts barnes chambers uses taboo list fixed length 
permissible moves exist list emptied 
length neighbor calculated exactly estimated 
start solution obtained best active non delay schedules obtained applying dispatch rules 
algorithm ts dell trubian uses union neighborhoods generated items taboo list forbidden arcs 
depending type neighbor items list 
length list depends fact current schedule shorter previous best 
furthermore minimal maximal allowable lengths list changed number iterations 
neighbors taboo satisfy aspiration criterion random neighbor chosen schedule 
start solution obtained procedure called applies list scheduling simultaneously schedule 
nowicki smutnicki algorithm ts combines taboo search backtracking scheme 
taboo search part algorithm neighborhood function variant allows arcs single longest path 
items taboo list forbidden arcs 
length list fixed 
permissible neighbor exists done 
neighbor consequence taboo new schedule 
oldest items list removed non taboo neighbor chosen 
start solution obtained generating active schedule shortest processing time rule insertion algorithm 
backtracking scheme forces taboo search restart promising situations encountered 
suppose certain point new best schedule 
set feasible arc reversals new taboo list including inverse reversal needed obtain reversal iteration 
jr triple frg stored list 
list maximum length full oldest triple deleted new stored 
time taboo search algorithm stops reaching maximum number iterations improving best schedule backtracking scheme initiates new round taboo search starting schedule set reversals taboo list stored triple 
set reversals element triple deleted list replaced triple reversal iteration excluded 
note new round new triples added list 
variable depth search algorithms balas vazacopoulos guided local search algorithm gls neighborhood function differs standard variable depth search sense trees sequences 
node tree corresponds orientation child node neighbor parent 
number children parent restricted decreasing function level tree 
children selected estimates lengths associated schedules 
node obtained inserting operation just relative order remains fixed orientation descendants 
parts orientation fixed ensure orientation occurs node tree 
size tree kept small limiting number children fixing parts orientations bounding depth tree logarithmic function number operations 
nodes tree smallest length chosen root node tree provided smaller length root current tree 
node chosen differs certain number root node smaller length chosen higher probability 
start solution generated randomized dispatch rule 
balas vazacopoulos propose variants call iterated reiterated guided local search 
starting solution generated sb gls see section repeats reoptimization cycles improvement 
cycles removes orientation machine applies gls limited number trees adds removed machine applies gls complete schedule limited number trees 
starts solution obtained repeats cycles type remove orientations mc randomly chosen machines apply gls limited number trees add removed machines applying sb gls see section apply 
genetic algorithms genetic algorithm ga yamada nakano determines chosen pair schedules current population schedules selected population best schedule chosen best unselected chosen 
aarts van laarhoven lenstra propose genetic algorithm incorporates iterative improvement 
iteration population solutions locally optimal respect algorithm ga ii algorithm ga ii 
population doubled size applying randomly selected pairs schedules population 
subjected iterative improvement extended population local optima reduced original size choosing best schedules 
iteration started 
start solutions generated randomly iterative improvement applied genetic algorithm started 
davis falkenauer della croce string represents machine preference list defines preferable ordering operations 
list schedule calculated 
davis falkenauer restrict non delay schedules della croce able represent schedules 
falkenauer della croce linear order crossover function 
see original papers details 
nakano yamada consider problem instances exactly operation job machine pair 
machine pair jobs represent order machine executes jobs bit 
schedule represented string mn gamma bits 
string may represent feasible orientation propose method finding feasible string close infeasible 
obtained cutting strings point exchanging left parts 
dorndorf pesch propose priority rule genetic algorithm ga uses thompson algorithm 
string gamma dispatch rule resolves conflicts ith iteration algorithm 
obtained cutting strings point exchanging left parts 
authors propose second genetic algorithm called ga sb uses shifting bottleneck procedure see section 
solution represented sequence machines 
corresponding schedule generated variant sb time select unoriented machine chooses unoriented machine sequence 
function cycle crossover see 
contrast sb reoptimization applied machines left unscheduled 
techniques constraint satisfaction constraint satisfaction algorithms consider decision variant job shop scheduling problem deadline exist feasible schedule meeting deadline 
algorithms type apply tree search construct schedule assigning start times operations 
consistency checking process removes inconsistent start times assigned operations 
appears partial schedule completed feasible dead encountered procedure undo assignments 
variable value ordering heuristics determine selection operation start time 
algorithm stops feasible schedule meeting deadline proved exist 
note possible establish lower bounds optimum technique 
sadeh developed algorithm type performance poor 
nuijten aarts designed new variable value orderings extensive consistency checking techniques 
restart search dead occurs randomize selection operation start time 
randomized constraint satisfaction algorithm rcs performs quite 
pesch tetzlaff describe consistency checking process test partial orientation extended feasible complete orientation deadline 
order find reasonable orientations edges create instance deleting jobs 
subinstance solved optimality branch bound algorithm brucker slightly increase resulting optimal solution value obtain deadline subinstance apply consistency checking identify edges oriented way 
oriented edges way aggregated original instance occur cycle 
restricted original instance solved optimality branch bound 
neural networks foo takefuji describe solution approach deterministic neural network model symmetrically interconnected network introduced hopfield tank job shop scheduling problem represented dimensional matrix neurons 
zhou cherkassky baldwin olson develop neural network algorithm uses linear cost function quadratic 
operation neuron network number interconnections linear number operations 
algorithm improves results foo takefuji terms solution quality network complexity 
altogether applications neural networks job shop scheduling problem initial stage reported computational results poor 
computational results computational merits job shop scheduling algorithms measured performance notorious theta instance ft fisher thompson applegate cook instances lawrence la la la la la la la pose difficult computational challenge 
included available computational results instances addition relatively easy instances la la remaining theta instances lawrence la la la 
thirteen instances exactly operation job machine pair 
tables computational results algorithms discussed sections far available 
results taken literature exception results algorithms applegate cook obtained codes 
tables give individual results thirteen instances table aggregates results table contains results algorithms tested instance ft 
schedule lengths printed roman computation times measured cpu seconds printed italic blank spaces denote results available 
tables values lb ub best known lower upper bounds optimal schedule lengths 
instances la la ran edge finder algorithm applegate cook prove optimality best known solution values 
lower bound la reported nuijten best upper bounds obtained algorithms tables la carlier pinson la running shuffle algorithm applegate cook solution yamada nakano la due applegate cook note instances solved optimality 
included algorithms superscript followed number indicates schedule lengths reported best ones obtained runs algorithm computation time total time runs 
superscript indicates schedule lengths means runs case computation time average runs 
superscript refers single run 
algorithm instance computed relative error percentage schedule length reported lb 
table presents algorithm mean standard deviation relative errors 
note ub mean relative error 
table gives algorithm total computation time computer computer independent total computation time 
values computed normalization coefficients dongarra interpreted care accuracy digits 
shows algorithm mean relative error computer independent total computation time 
note time axis logarithmic scale 
shifting bottleneck procedure sb adams balas fast gives poor results 
variants sb sb balas lenstra vazacopoulos take delayed precedences account effective 
worthwhile combine straight shifting bottleneck procedure form partial enumeration clear results obtained algorithm pe sb adams balas bottle bottle applegate cook 
note values bottle differ reported original enumeration scheme described implemented different scheme 
algorithm balas vazacopoulos entirely different category 
apparently performance shifting bottleneck procedure significantly enhanced search fine grained neighborhood function partial schedules 
threshold algorithms best results obtained simulated annealing algorithm aarts van laarhoven lenstra iterative improvement algorithm shuffle applegate cook regarding iterative improvement aarts van laarhoven lenstra report multi start algorithm inferior threshold accepting simulated annealing 
applegate cook shuffle algorithm works due neighborhood function allows major changes schedule 
outcomes bottle start solutions 
number machines fix chosen edge finder rapidly fill remainder schedule 
set ft la la la la la instances 
results values reported shuffle 
carried time consuming runs ft la la la la la la la la la 
outcomes reported shuffle expensive 
storer wu give computational results variants iterative improvement 
results instance ft poor 
search strategy neighborhood function powerful 
threshold accepting algorithm ta aarts van laarhoven lenstra table results instances algorithm ft la la la la la lb ub shifting bottleneck sb sb sb sb gls pe sb bottle bottle bottle threshold algorithms shuffle shuffle ta sa sa sa sa sa sa ii taboo search ts ts ts ts ts ts variable depth search gls genetic algorithms ga ii ga ii ga ii ga ga ga ga sb ga sb constraint satisfaction rcs schedule length roman computation time seconds italic table results instances algorithm la la la la la la la lb ub shifting bottleneck sb sb sb sb gls pe sb bottle bottle bottle threshold algorithms shuffle shuffle ta sa sa sa sa sa sa ii taboo search ts ts ts ts ts ts variable depth search gls genetic algorithms ga ii ga ii ga ii ga ga ga ga sb ga sb constraint satisfaction rcs schedule length roman computation time seconds italic table summary results standard computer mean deviation total independent algorithm authors relative computation computer total error relative time computation error time lb ub shifting bottleneck sb adams vax sb balas sparc sb balas sparc sb gls balas vazacopoulos sparc pe sb adams vax bottle applegate cook sparc elc bottle applegate cook sparc elc bottle applegate cook sparc elc threshold algorithms shuffle applegate cook sparc elc shuffle applegate cook sparc elc ta aarts vax sa aarts vax sa aarts vax sa aarts vax sa van laarhoven vax sa van laarhoven vax sa ii matsuo vax taboo search ts taillard ts barnes chambers ibm rs ts dell trubian pc ts dell trubian pc ts nowicki smutnicki dx ts nowicki smutnicki dx variable depth search gls balas vazacopoulos sparc balas vazacopoulos sparc balas vazacopoulos sparc genetic algorithms ga ii aarts vax ga ii aarts vax ga ii aarts vax ga della croce pc ga della croce pc ga dorndorf pesch dec ga sb dorndorf pesch dec ga sb dorndorf pesch dec constraint satisfaction rcs nuijten aarts sparc elc relative error percents computation time seconds italic computer independent computation times rough estimates rsb rsb rsb sb rsb gls bottle bottle shuffle shuffle rta sa sa rsa sa rsa rsa ii rts rts rts ts ts ii ii sb ga sb ub sec relation mean relative error computer independent total computation time table miscellaneous results ft algorithm authors length time computer threshold algorithms ps storer storer genetic algorithms ga yamada nakano sparc ga nakano yamada schedule length roman computation time seconds italic competes simulated annealing algorithm case simulated annealing finds optimal schedule 
threshold accepting outperformed simulated annealing 
instances table belong category 
simulated annealing algorithm sa van laarhoven aarts lenstra produces reasonable results 
results quality obtained algorithms sa sa aarts van laarhoven lenstra standard cooling schedule extremely slow cooling schedule sa gives results 
compute mean standard deviation relative errors cooling schedule estimated values missing entries 
remarkable standard cooling schedule behaves similarly neighborhood functions sa sa 
results obtained bi level variant sa ii matsuo suh sullivan comparison approximative approaches simulated annealing may require large running times yields consistently solutions modest amount human implementation effort relatively little insight combinatorial structure problem type consideration 
advent taboo search changed picture 
methods type produce excellent solutions reasonable times benefits come expense nontrivial amount testing tuning 
data available taillard algorithm ts perform extremely 
results obtained algorithm ts barnes chambers dell trubian algorithm ts obtained better results apparently complicated neighborhood function effective 
algorithm ts nowicki smutnicki applies taboo search traces way back promising rejected changes current champions job shop scheduling 
thirteen instances achieves mean relative error best result runs 
ts variable depth search algorithm gls balas vazacopoulos combines conceptual elegance computational excellence 
gls achieves mean relative error best result runs needs time ts 
iterated reiterated variants apply various reoptimization cycles partial complete solutions perform better 
best results reported far obtained single run achieves mean relative error finds optimum eleven thirteen instances 
genetic algorithms results instances available 
result ft 
yamada nakano schedule length times trials 
tested algorithm ga job machine instances outcomes average best known upper bounds 
results obtained aarts van laarhoven lenstra strong 
algorithm ga ii neighborhood function performs slightly better ga ii 
genetic algorithms string representations results obtained della croce algorithm ga published della croce nakano yamada algorithm ga poor 
algorithm ga dorndorf pesch worse 
algorithm ga sb incorporates shifting bottleneck variant produces reasonable results 
values reported runs population sizes 
constraint satisfaction algorithm nuijten aarts produces results needs lot time 
pesch tetzlaff set test instances contains problems set 
theta instances best parameter settings give significantly better solutions algorithm pe sb amount time 
neural network approaches computational results available allow proper comparison techniques 
review local search algorithms discussed survey cover broad range straightforward involved approaches 
general best results obtained taboo search variable depth search 
reiterated guided local search algorithm balas vazacopoulos outperforms methods terms solution quality 
algorithm nowicki smutnicki combines taboo search backtracking close second needs time 
shifting bottleneck algorithm balas vazacopoulos partial schedules variable depth search effective fast alternative 
shifting bottleneck variants competitive anymore 
job shop scheduling simulated annealing attractive 
yield solutions time concern 
genetic algorithms perform poorly 
neighborhood function applied combination schedule representation chosen generate meaningful changes hard find improvements 
kind local search embedded second level computational results reasonable 
constraint satisfaction promising technique needs investigation 
early assessment neural networks job shop scheduling 
word caution order regarding validity 
col lected compared computational results reported set benchmark instances 
problems just borderline reach optimization algorithms 
experiments larger instances required improve insights performance various local search family 
preview considerable room improving local search approaches job shop scheduling problem 
shown existing algorithms achieves average error seconds total computation time 
observed approaches operate levels instance schedule construction partial enumeration local search big changes top level local search smaller changes bottom level 
hybrid approaches need systematic investigation 
interesting design level approach neighborhoods smaller size bottom 
flexibility local search results reported provide promising basis application local search general scheduling problems 
example practical interest multiprocessor job shop production stage set parallel machines single 
finding schedule involves assignment sequencing decisions 
difficult problem effective solution methods exist 
applying local search large instances scheduling problems requires design data structures allow fast incremental computations example longest paths 
johnson shown sophisticated data structures play important role application local search large traveling salesman problems 
survey predominantly computational nature 
related theoretical questions complexity local search 
central concept respect pls completeness neighborhood functions defined section define pls problem may pls complete 
complexity issues regarding parallel execution local search 
example neighborhood functions may possible verify local optimality polylog parallel time 
grateful david applegate bill cook making codes available 
colleagues providing information computational commenting earlier draft 
research partially supported human capital mobility project erb ct 

aarts van laarhoven lenstra 
computational study local search algorithms job shop scheduling orsa journal computing 

adams balas 
shifting bottleneck procedure job shop scheduling management science 

akers 
graphical approach production scheduling problems operations research 

applegate cook 
computational study job shop scheduling problem orsa journal computing 

baker 
su 
sequencing due dates early start times minimize maximum tardiness naval research logistics quarterly 

balas 
machine sequencing disjunctive graphs implicit enumeration algorithm operations research 

balas 
facial structure scheduling polyhedra mathematical programming study 

balas lenstra vazacopoulos 
machine problem delayed precedence constraints job shop scheduling management science 

balas vazacopoulos 
guided local search shifting bottleneck job shop scheduling management science research report graduate school industrial administration carnegie mellon university pittsburgh pennsylvania 

barnes chambers 
solving job shop scheduling problem tabu search iie transactions 

florian 
sequencing earliest starts due dates application computing bounds fmax problem naval research logistics quarterly 

brucker 
efficient algorithm job shop problem jobs computing 

brucker 
branch bound algorithm job shop scheduling problem discrete applied mathematics 

carlier 
machine sequencing problem european journal operational research 

carlier pinson 
algorithm solving job shop problem management science 

carlier pinson 
practical jackson preemptive schedule solving job shop problem annals operations research 

carlier pinson 
adjustments heads tails job shop problem european journal operational research 


approach traveling salesman problem journal optimization theory applications 

davis 
job shop scheduling genetic algorithms proceedings international conference genetic algorithms applications grefenstette ed carnegie mellon university pittsburgh pennsylvania 

ere er es 
modified shifting bottleneck procedure job shop scheduling international journal production research 

della croce 
solving real world project scheduling problem genetic algorithm belgian journal operations research statistics computer science 

della croce 
genetic algorithm job shop problem computers operations research 

dell trubian 
applying tabu search job shop scheduling problem annals operations research 

dongarra 
performance various computers standard linear equations software report cs computer science department university tennessee knoxville tennessee 

dorndorf pesch 
evolution learning job shop scheduling environment computers operations research 

dueck 
threshold accepting general purpose optimization algorithm journal computational physics 

falkenauer 
genetic algorithm job shop proceedings ieee conference robotics automation los alamitos california 

fisher lenstra rinnooy kan 
surrogate duality relaxation job shop scheduling discrete applied mathematics 

fisher thompson 
probabilistic learning combinations local jobshop scheduling rules muth thompson eds industrial scheduling prentice hall englewood cliffs new jersey 

foo takefuji 
stochastic neural networks solving job shop scheduling part 
problem representation ieee international conference neural networks ieee san diego section ieee tab neural network committee san diego california 

foo takefuji 
stochastic neural networks solving job shop scheduling part 
architecture simulations ieee international conference neural networks ieee san diego section ieee tab neural network committee san diego california 

thompson 
algorithms solving production scheduling problems operations research 

glover 
tabu search part orsa journal computing 

glover 
tabu search part ii orsa journal computing 

glover taillard de werra 
user guide tabu search annals operations research 

goldberg 
genetic algorithms search optimization machine learning addison wesley reading massachusetts 

haupt 
survey priority rule scheduling spektrum 


efficient optimal algorithm machines jobshop schedule length problem mathematics operations research 

holland 
adaptation natural artificial systems university michigan press ann arbor michigan 

hopfield tank 
neural computation decisions optimization problems biological cybernetics 

jackson 
extension johnson results job lot scheduling naval research logistics quarterly 

johnson 
data structures traveling salesmen swat nd scandinavian workshop algorithm theory gilbert karlsson eds springer berlin 

johnson papadimitriou yannakakis 
easy local search journal computer system sciences 

kirkpatrick gelatt jr vecchi 
optimization simulated annealing science 

lenstra rinnooy kan 
minimizing maximum lateness machine computational experience applications statistica 

lenstra rinnooy kan 
job shop scheduling implicit enumeration management science 

lawrence 
resource constrained project scheduling experimental investigation heuristic scheduling techniques supplement graduate school industrial administration carnegie mellon university pittsburgh pennsylvania 

lenstra rinnooy kan 
computational complexity discrete optimization problems annals discrete mathematics 

lenstra rinnooy kan brucker 
complexity machine scheduling problems annals discrete mathematics 

lin kernighan 
effective heuristic algorithm problem operations research 

matsuo suh sullivan 
controlled search simulated annealing method general jobshop scheduling problem working graduate school business university texas austin 

mcmahon florian 
scheduling ready times due dates minimize maximum lateness operations research 

nakano yamada 
conventional genetic algorithm job shop problems proceedings fourth international conference genetic algorithms belew booker eds san diego california 


das der und mit logischen mathematica 

nowicki smutnicki 
fast taboo search algorithm job shop problem management science appear 

nuijten aarts 
computational study constraint satisfaction job shop scheduling european journal operational research appear 

nuijten 
post newsgroup sci op research january 

pesch tetzlaff 
constraint propagation scheduling job shops informs journal computing appear 

roy 
les probl emes avec constraints note ds bis sema 

sadeh 
look ahead techniques micro opportunistic job shop scheduling phd thesis school computer science carnegie mellon university pittsburgh pennsylvania 


geometric methods scheduling theory survey discrete applied mathematics 

shmoys stein wein 
improved approximation algorithms shop scheduling problems siam journal computing 


complexity shop scheduling problems jobs european journal operational research 

storer wu 
new search spaces sequencing problems application job shop scheduling management science 

taillard 
parallel taboo search techniques job shop scheduling problem orsa journal computing 


building decision support system operation scheduling large industrial department preliminary algorithmic study internal report department mathematics informatics university udine italy 

van laarhoven aarts lenstra 
job shop scheduling simulated annealing operations research 

williamson hall lenstra shmoys 
short shop schedules operations research appear 

yamada nakano 
genetic algorithm applicable large scale jobshop problems parallel problem solving nature manner manderick eds north holland amsterdam 

yamada nakano 
job shop scheduling simulated annealing combined deterministic local search proceedings metaheuristics international conference osman kelly eds hilton breckenridge colorado 

zhou cherkassky baldwin olson 
neural network approach job shop scheduling ieee transactions neural networks 

