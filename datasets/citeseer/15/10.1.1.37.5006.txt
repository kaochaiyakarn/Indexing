building domain specific embedded languages paul hudak department computer science yale university june believed long time abstraction important factor writing software 
programming language researchers design software engineers trained variety abstraction mechanisms data types higher order functions monads continuations modules classes objects particular languages support mechanisms 
important point mechanisms fairly general example algorithmic strategies computational structures implemented functional object oriented abstraction techniques 
generality ask ideal abstraction particular application opinion programming language designed precisely application person quickly effectively develop complete software system 
general capture precisely semantics application domain 
opinion domain specific language ultimate abstraction 
know difficult designing implementing languages pretty sure won get right time evolve experience difficulties associated evolution 
fact notion domain specific language practical 

position outline techniques believe lead effective methodology 
begins assumption really don want build programming language scratch 
better inherit infrastructure language tailoring special ways domain interest yielding domain specific embedded language 
building base concentrate semantical issues viz 
interpreter language 
interestingly ll see abstraction kicks leta level abstraction techniques build interpreters easy understand highly modular straightforward evolve 
remainder describe results functional language haskell build 
haskell features particularly suitable languages 
hand features don exist language knowledge things easier done 
domain specific semantics surprisingly straightforward design specific applications 
done haskell domains parser generation graphics animation simulation music composition geometric region analysis geometric regions represented functions type region point 
bool test point membership region point 
region 
bool suitable definitions circle outside circle radius 
region creates region radius outside region 
region logical negation region region 
region 
region intersection regions define function generate annulus annulus radius 
radius 
region annulus outside circle circle example naval application name 
domain geometric region analysis came experiment conducted jointly arpa onr naval surface warfare center 
documented experiment see car demonstrates viability approach evolvability 
different versions system developed capturing advanced notions target system priori knowledge changes required 
modularity afforded non trivial changes quite easy incorporate 
resulting notation easy design easy reason 
domain semantics captured concisely possible non programmers understand code 
experiment completely unfamiliar haskell able grasp concepts immediately expressed disbelief code executable 
highlight code give reader feel simplicity clarity 
approach highly amenable formal methods reasons mentioned 
key point reason directly domain semantics semantics programming language 
experiment straightforwardly proved properties difficult prove competing designs 
modular monadic interpreters haskell thought higher order algebraic structure class value look feel syntax 
sense just notation semantics captured interpreter 
permits opportunity modular design turn facilitating evolution system changes domain semantics cases inevitable 
design truly modular interpreters elusive goal programming language community years 
particular design interpreter different language features isolated individualized interpretations building block manner 
building blocks assembled yield languages majority individual language features 
progress moggi steele mog ste esp laid groundwork effort producing truly callcc arithmetic ops function calls assignments continuations lambda pure lambda calculus continuations store environment modular construction kernel callcc update err inenv rdenv error reporting modular monadic interpreter structure modular interpreter non trivial language basing modular compiler construction technology lh lia 
monads wad structure design critical 
approach means language features added long initial design involve fundamental changes interpreter functionality 
example built series languages interpreters small calculator language just numbers simple order language variables higher order language calling conventions language errors exceptions suggested 
level new language features added semantics altering previous code 
possible approach capture domain specific semantics domain specific optimizations 
optimizations done incrementally independently core semantics 
implement traditional compiler optimizations lh lia techniques domain specific optimizations 
conventional interpreter maps say term environment store answer 
contrast monadic interpreter maps terms computations details environment store hidden computation 
specifically interp term 
interpm value interpm value interpreter monad final answers 
interpreter modular components term type value type monad configurable 
illustrate initially wish interpreter small number expression language fill definitions follows type value int bottom type term type interpm errort id line declares answer domain union integers bottom 
second line defines terms syntax arithmetic operations 
final line defines interpreter monad transformation identify monad id monad transformer errort accounts possibility errors case arithmetic exceptions 
point interpreter behaves calculator standard interpreter program input standard answer operator monitor specification monitoring interpreter monitoring information system diagram run 
run 
error divide wish add function calls extend value domain function types add syntax function calls term type apply monad transformer envt env introduce environment env 
type value int function bottom type term type interpm envt env errort id test run run 
run 
error unbound variable add features conditionals lazy evaluation letrec declarations nondeterminism continuations tracing profiling assignment interpreter 
new value domain boolean needed extend value type add new semantic feature store continuation apply corresponding monad transformer 
instrumentation despite importance software development language tools debuggers profilers tracers performance monitors traditionally treated ad hoc ways 
believe disciplined approach designing tools benefit software development process 
methodology tool generation shares previous identified goals highly modular domain specific evolvable 
scheme tools layered system affecting changes additions easily accomplished 
tool specified framework automatically combined corresponding standard semantics yield composite semantics incorporates behaviors 
flow diagram methodology shows compositional nature 
scheme semantics debugger specification profiler specification scheme debugging profiling semantics composing monitors system functionality meta interpreter monitor program input answer specializing interpreter monitor 
meta instrumented interpreter program input answer specializing instrumented interpreter program safra shapiro meta instrumented program input answer pe pe partial evaluation optimization levels partial evaluation 
order corresponding modular interpreters practical sense program transformation partial evaluation technology improve performance 
example partial evaluation optimize composed interpreters described previously ways specializing tool generator respect tool specification automatically yields concrete tool interpreter instrumented tool actions specializing tool previous step respect source program produces instrumented program program embedded code perform tool actions 
provides useful viewpoint levels optimization 
existing partial evaluation techniques painful 
feel user friendly techniques needed 
particular contrast fully automated approach semi automated approach advantages automatic approaches matured years give confidence need meet goals 
second think important user better explicit control transformation process 
reasoning behavior fully automated systems difficult gets worse sophistication automation increases 
car 
prototyping demonstration problem hiper joint prototyping demonstration project 
ccb report naval surface warfare center august 
modified october changes specified described addendum prototyping demonstration problem hiper joint prototyping demonstration project november 
carlson hudak jones 
experiment haskell prototype geometric region servers navy command control 
research report department computer science yale university november 
esp david espinosa 
modular denotational semantics 
unpublished manuscript december 
lee blum kanellakis crisp 
hiper joint prototyping demonstration project february 
unpublished pages 
lh sheng liang paul hudak 
modular denotational semantics compiler construction 
european symposium programming april 
sheng liang paul hudak mark jones 
monad transformers modular interpreters 
proceedings nd acm symposium principles programming languages pages new york january 
acm press 
lia sheng liang 
modular monadic semantics compilation 
phd thesis yale university department computer science november 
mog moggi 
computational lambda calculus monads 
proceedings symposium logic computer science 
ieee june 
peyton jones wadler 
imperative functional programming 
proceedings th symposium principles programming languages 
acm january 
appear 
ste guy steele jr building interpreters composing monads 
conference record popl st acm sigplan sigact symposium principles programming languages portland oregon pages new york january 
acm press 
wad wadler 
comprehending monads 
proceedings symposium lisp functional programming pages nice france june 
acm 

