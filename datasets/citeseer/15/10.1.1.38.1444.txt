type dependencies logic programs aci unification michael codish department mathematics computer science ben gurion university pob beer israel 
cs bgu ac il february presents new notion typing logic programs generalizes notion directional types 
generation type dependencies logic program fully automatic respect domain types 
analysis method novel combination program abstraction aci unification shown correct optimal 
type dependencies obtained abstracting programs replacing concrete terms types evaluating meaning programs standard semantics logic programs enhanced aci unification 
approach generic standard semantics 
method theoretically clean easy implement general purpose tools 
proposed domain types condensing means analyses carried top bottom frameworks loss precision analyses 
proposed method fully implemented bottom approach experimental results promising 
keywords aci unification type analysis logic programs foremost impediments providing efficient implementations logic programming languages absence notions types modes research supported israel science foundation administered israel academy sciences humanities israel ministry science arts ec israel collaboration activity isc il 
languages 
acknowledging state affairs literature rich contributions common aim providing adequate type mode information aid compilers overcoming obstacle see example 
growing interest notion directional types logic programs combine types modes 
directional types originally considered proven useful applications proving termination programs controlling execution programs delay mechanism 
directional types declarative aspect operational aspect prescribing types predicates program intended ways predicates called 
directional types associate input output assertions predicate program 
input assertion describes calls predicate 
output assertion describes success patterns predicate assumption called specified corresponding input assertion 
focuses specification data descriptions capture information types type dependencies characterize set possible directed types program generalize notion directional types 
key idea express dependencies types predicates arguments similar way groundness dependencies expressed os domain 
type dependencies mentioned reminiscent implication types 
typical example consider directed type known append relation specifies result concatenating lists elements type list elements type type append list list gamma 
list type dependency append relation specify dependencies arguments call pattern 
example list list gamma 
list appending lists type gives list elements types list gamma 
list list partitioning list type gives lists type 
example come back example illustrate propose express type dependencies sort 
framework interpretation provides basis semantic approach dataflow analysis 
program analysis viewed nonstandard semantics defined domain data descriptions 
semantics constructed replacing operations suitable concrete semantics corresponding operations defined data descriptions 
program analyses defined providing finitely computable interpretations preserve interesting aspects program behavior 
formal justification program analyses reduced proving conditions relation data data descriptions elementary operations defined data descriptions 
new domain inference type dependencies 
types domain associative commutative idempotent terms aci short 
analysis type dependencies propose abstraction replaces concrete program terms types 
meaning programs involving type expressions formalized enhancing standard semantics logic programs aci unification 
consequence type inference reduced evaluating meaning program 
additional proof theory special inference rules special inference procedures required 
justification program analysis follows formalizing correspondence concrete terms type expressions showing aci unification type expressions mimics correctly concrete unification terms 
combination program abstraction aci enhanced concrete evaluation results promising technique theoretically clean easy implement general purpose tools 
idea obtaining static analyses program abstraction derived ideas applied variety contexts 
unique approach combination simple syntax directed program abstraction standard equality theory type expressions 
pay special attention role variables programs semantics 
turns similar case classic semantics logic programs reason introducing variables underlying herbrand base program analyses facilitates efficient evaluation concise representation 
type analysis facilitates specification parametric types type dependencies 
sense follow approach described authors propose clear intuitive type analysis logic programs parametric types 
rest organized follows section provides preliminary definitions clarifies notation 
sections introduce domain symbolic types operations aci unification 
bottom polymorphic analysis abstraction semantics examples described section 
section summarizes provides 
extended version inspired earlier :10.1.1.38.1444
preliminaries syntax assume familiarity standard definitions notation logic programs described 
set function symbols sigma variables sigma denote set terms constructed symbols sigma variables substitutions mappings sigma defined usual 
assume order language fixed set predicate symbols pi fixed signature sigma countable set variables set atoms constructed predicate symbols pi terms sigma denoted bv elements bv sets atoms called interpretations 
syntactic objects terms atoms interpretations viewed modulo renaming variables 
assume standard ordering terms syntactic objects 
denote general general unifier denoted mgu exists 
syntactic object set equivalence classes objects denote hc 
representatives elements renamed apart 
semantics semantic type analysis described generic independent particular top bottom concrete semantic definition 
examples bottom approach abstractions semantics described nonground version standard minimal model semantics logic programs 
semantics program set possibly non ground atoms characterizes declarative operational properties program 
particular ground instances semantics gives precisely minimal model computed answer substitutions initial goal determined solving potentially infinite set atoms semantics semantics evaluated fixed point immediate consequence operator tp bv 
bv similar standard minimum herbrand model semantics 
case underlying domain involves possibly non ground atoms set bv tp fi fi fi fi fi bn ha ani mgu hb ha basis designing program analyses semantics proven particularly useful see example 
due fact hand captures declarative operational properties hand mathematical simplicity definition 
important advantage non ground semantics meaning program fragment determined symbols contains considering entire underlying alphabet 
example consider append relation append ys ys 
append xs ys zs append xs ys zs 
standard meaning program depends underlying alphabet assumed determined symbols occuring program context 
context program involving digits minimal model contain facts form append context characters contain elements form append 
consequently meaning program module reconsidered change underlying alphabet discourse 
contrast minimal model semantics typical element semantics append program universally quantified atom form append advantages non ground semantics tangible cases wish compute program meanings case semantic program analysis 
unification pair terms syntactic objects associated unification problem decide exists substitution unifies consider unification problem 
problem deciding terms unifiable presence equality theory example function symbol commutative terms unifiable fx 

ag 
course concerned unification algorithms compute unifiers exist 
standard unification logic programs syntactic assumes empty equality theory 
concerned aci unification instance unification presence equality theory associative commutative idempotent 
formally fixed signature omega gamma countable set variables equality theory omega theta omega unification consists solving equations free algebra omega purpose consider substitutions instantiation ordering defined usual iff exists substitution ffi empty equality theory write unifier terms substitution set unifiers denoted ue 
complete set cue unifiers satisfies conditions ffl cue ue ffl ue exists cue 
minimal complete set ue unifiers complete set satisfying additional condition ffl ue implies minimal complete set unifiers may exist may finite 
depends equality theory example syntactic unification problem empty theory unitary minimal complete set exists cardinality 
aci unification minimal complete set exists finitary 
underlying decision problem aci unification general np complete 
algorithms aci unification described literature compute complete set aci unifiers general minimal 
efficiency applications unifiers set close minimal practice 
interpretation semantic program analysis assume standard framework interpretation defined terms galois insertions 
galois insertion quadruple va ff vb fl 
va vb compete lattices concrete domains respectively 
ff fl monotonic functions called abstraction concretization functions respectively 
va fl ff ff fl domain symbolic types section presents step step construction domain symbolic types similar construction concrete domain 
syntactic objects terms atoms substitutions interpretations 
formalize relation concrete interpretations terms galois insertion provided definition suitable functions abstraction concretization 
syntax define order language terms vocabulary pi sigma ff shares predicate symbols variables concrete domain 
set sigma ff includes binary set constructor phi collection monomorphic polymorphic description symbols 
monomorphic symbols constants nat char atom polymorphic symbols unary list tree 
intuitively description symbols represent sets function symbols corresponding concrete alphabet sigma 
example description symbol list defined represent cons symbol concrete alphabet description constant nat represent symbols 
elements term algebra sigma ff associated equality theory aci induced axioms phi phi phi phi associativity phi phi commutativity phi idempotence giving phi flavor set constructor 
example expressions phi phi phi phi phi phi phi phi equivalent respect theory equation 
say term polymorphic involves unary function symbols monomorphic 
type abstraction relation concrete terms specified abstraction function ff sigma sigma sigma ff associates concrete function symbol corresponding description symbol sigma ff partitioning set concrete function symbols 
addition function sigma 
associates function symbol sigma set designated argument positions subset ng 
type term determined ff sigma description types subterms 
intuitively ff sigma description specifies designated set recursive argument positions type term determined traversing recursive paths specified collecting descriptions functions symbols encountered specified ff sigma 
function symbol associated monomorphic description symbol encountered non recursive arguments ignored 
function symbol associated polymorphic description symbol encountered types non recursive arguments introduced argument corresponding unary description symbol 
ff sigma define abstraction function type relating concrete terms 
type sigma sigma ff type variable ff sigma phi type tn ff sigma constant phi ff sigma type phi phi type tn ff sigma unary say type definition monomorphic involves monomorphic description symbols 
type definition polymorphic 
consider monomorphic type definition example 
example assume definitions ff sigma ff sigma cons list cons ff sigma nat ff sigma nil list nil ff sigma nat substituting definitions equation gives equation term abstraction type variable nat nat phi type list list phi type xs xjxs consider symbolic types terms type list phi type list phi list phi type list type list phi type list phi list phi type list type jx list phi type list phi type type nat phi type nat observe type proper closed list list type open ended list list phi variable type 
observe type natural number nat 
consider types strangely constructed terms type js list phi type list phi nat type nat phi type nat phi list notion types distinguish terms may considered erroneous definition 
term nat phi list indicates type error occurred 
distinguishing types kinds concrete terms type unification remains syntactic efficient 
types sort occur analysis correct programs 
readability may equate terms special type description error 
example illustrates type abstraction polymorphic description symbols involved 
case type expressions abstraction capture primary types secondary types expressing information list characters list 
example consider definition polymorphic type abstraction derived equation suitable definitions ff sigma example definition provides polymorphic types lists binary trees capturing information types terms non recursive positions data structures 
note symbol list unary polymorphic 
definition includes abstraction formally ff sigma induce partition sigma 
examples adhere policy function symbols specially mentioned mapped special descriptive constant 
numbers num abstraction natural numbers successor notation equation 
type variable num number nil list type phi type xs xjxs void void tree type phi tree consider type abstraction terms type list type phi type list num phi list type phi type list num phi list num phi nil list num phi nil type list type phi list type phi nil list phi list phi nil type xjy list phi type tree void void tree num phi type void phi type void tree num phi void list abstracted list num phi nil describes recursive structure constructed cons recursion terminates non recursive arguments numbers 
type expression describes list numbers 
similarly case monomorphic type abstraction instantiated terms instantiated types 
instance types list num phi nil list phi list phi nil respectively 
note applying substitution fx 
num 
list phi list phi nil gives type expression list num phi nil 
note type open ended recursive data structure xjy general corresponding closed structure 
notation equation abstraction empty list empty tree cumbersome equation monomorphic types 
harder read polymorphic types 
alternative consider empty structure nil list 
denotes empty type see example :10.1.1.38.1444:10.1.1.38.1444
case additional axioms introduced underlying equality theory phi phi phi sigma ff 
types easier read complicates unification algorithm introduces semantics terms providing information types 
symbolic types apparent term represents type concrete term 
domain symbolic types upsilon sigma ff image sigma function type upsilon phi type fi fi sigma psi example assume definition function type identity concrete constants ff sigma 
case terms phi phi valid syntactic objects sigma ff exist concrete term type phi type phi atoms entities form pi upsilon 
denote ff set atoms modulo equivalence provided equation 
abuse notation write aci atom substitutions substitutions upsilon 
substitution resemble concrete ones standard operations defined usual 
example application substitution symbolic type defined usual replacing occurrences variable type 
composition substitutions defined usual applying second substitution symbolic types range 
refer substitutions aci substitutions terms range substitutions respect aci equivalence 
terms atoms associated ordering concrete syntactic objects 
say term general term denoted exists substitution aci 
words ordering terms aci 
aci 
ordering extends usual syntactic objects tuples atoms 
domain domain type analysis formalized domain sets atoms suitable notion ordering equivalence 
consider lower power domain hoare power domain ordering defined corresponding equivalence relation induces partial order ff elements domain subsets ff modulo equivalence equation called interpretations 
abuse notation denote ff ff 
partial order provides basis relating interpretations downward closed sets called interpretations 
set atoms downward closed implies denote minimal downward closed set containing equation provides ff member ff equivalent downward closed set 
domain fact lower power domain partially ordered set inclusion 
observation trivially implies lemma lemma ff complete lattice 
proof 
set downward closed sets elements ff downward closed lub glb theorem establishes case monomorphic type abstraction domain finite 
result establish termination monomorphic type analyses viewed chains domain 
theorem sigma ff contains polymorphic description symbols ff finite 
proof 
elements ff sets equivalence classes atoms aci suffices prove predicate symbol number associated equivalence classes atoms aci finite 
prove equivalence class atoms constructed representative number variables bounded gamma 
assume atom gamma distinct variables 
variables occuring exactly arguments consider atom delta fx 

zg 
construction easy see delta fz 
phi equivalence class gamma 
atom constructed exists equivalent atom variables occuring distinct subsets argument positions atom gamma variables 
relation concrete domains formalized lifting type abstraction equation atoms syntactic constructs tuples atoms clauses case abstraction denoted oe obtained application type separately term construct 
particular atoms oe bv ff oe type type galois insertion obtained lifting oe introduce abstraction function ff interpretations defining corresponding concretization function standard way ff bv 
ff fl ff 
bv ff phi oe fi fi psi fl phi fi fi ff psi theorem bv ff ff fli galois insertion 
proof 
ffl ff fl monotonic immediately definitions 
ffl bv fl ff phi fi fi ff ff psi phi fi fi ff ff psi ffl ff ff fl ff gamma phi fi fi ff psi delta phi ff fi fi ff psi downwards closed 
say atom type description concrete atom denoted fl fg equivalently oe similarly say interpretation type description concrete interpretation fl equivalently ff example illustrates concept type description example assume monomorphic type abstraction lists natural numbers equation 
illustrate notion type description providing groups concrete interpretations table summarizing relation list nat list phi nat list nat xjy example assume monomorphic type abstraction equation consider append relation example 
interpretation phi append list append list list phi psi type description semantics append program 
type description minimal herbrand model append consists ground instances semantics 
observe atoms append list list list instance describe atom form append equal concatenation lists note describes atoms minimal model append intended semantics append append 
types atoms append list nat nat append list nat list phi nat instances atoms presence counterintuitive atoms minimal model append overlooked correct approximation minimal model describe 
example characterizes set atoms described interpretation turn result polymorphic analysis append program 
example assume polymorphic type abstraction equation 
interpretation ae append nil append list phi nil list phi oe describes polymorphic types append relation 
atom approximates cases appending empty list 
case second third argument append types 
expression list phi nil second atom denotes right recursive structure cons constructors object type left argument position terminated constructor 
consider instances second atom 
nil corresponding atom append list phi nil nil list phi nil describes situation list elements type appended empty list 
result list elements type 
list phi nil corresponding atom append list phi nil list phi nil list phi list phi nil describes situation list elements type appended list elements type result list elements types note list phi list phi nil describes exactly 
aci axioms allow cons constructors left type left type order 
operations types concept aci unification plays central role type analysis 
section describes main contributions demonstrating aci unification provides correct optimal unification algorithm type analysis 
described section aci unification instance general notion unification 
aci unification terms consists finding substitution satisfying aci underlying decision problem deciding terms aci unifiable np complete 
interesting note restricted aci unification problem monomorphic types time decidable 
algorithm simpler implementation illustrated appendix monomorphic types may exponentially general unifiers pair terms considered program analysis 
experimental evaluation described indicates symbolic type analysis aci unification feasible reality correctly designed exhibit exponential behaviour 
correctness aci unification correctness aci unification unification algorithm symbolic types follows monotonicity type abstraction respect ordering terms symbolic types 
lemma concrete term substitution type type delta fx 
type dom proof 
denote fx 
type dom proof induction depth depth constant variable 
constant variable domain type type type lemma holds 
assume dom 
case type variable type definition induction step assume lemma holds terms depth equal consider term depth 
distinguish cases 
ff sigma constant type ff sigma phi type ff sigma phi type ff sigma phi type type 
ff sigma unary function symbol type ff sigma phi type phi phi type ff sigma phi type phi phi type type result monotonicity type abstraction straightforward lemma 
theorem concrete terms type type proof 
straightforward lemma implies exists substitution 
example consider terms jv example corresponding notion types 
observe type list type list type list phi note ordering types preserve ordering original terms 
type type type type delta fv 
listg type 
type reflects fact open ended list strictly general closed lists corollary pair atoms tuples atoms oe oe result establishes correctness aci unification respect type domain 
theorem proves correctness application aci substitution symbolic type mimics application concrete substitution concrete term 
theorem aci unification correct unification concrete atoms atoms mgu 
exists unifier 

bv oe 
proof 
consider tuples hh hh arbitrary concrete atom 
observe hh hh hh hh corollary oe hh oe hh hoe oe hh oe hh hoe unifier oe hh oe hh oe hh common aci instance hoe hoe complete set hoe hoe contains unifier oe hh hoe separating tuples oe oe oe claim theorem follows observing hoe hoe corresponds complete set aci unifiers 
corollary correctness unification tuples theorem holds tuples concrete atoms tuples atoms proof 
straightforward 
optimality aci unification consider atoms sets concrete atoms described phi fi fi psi phi fi fi psi equivalently fl fl 
note common instances downward closed 
ci aci complete set common aci instances atoms set obtained application members equivalently set complete sense common instance instance element ci aci 
theorem implies ci aci approximates set demonstrate approximation precise set ci aci approximates atoms theorem aci unification optimal unification atoms sets concrete atoms approximated respectively 
approximation ci aci precise 
proof 
demonstrate atoms approximated ci aci 
assume contradiction exists atom ci aci 
possible common instance implying contradiction conclude ci aci approximate atom aci unification provides optimal unification algorithm type analysis ci aci approximates unifiers pairs concrete atoms described respectively theorems provide result generalizing correctness optimality aci unification types theorem atoms 
fl ci aci fl fl proof 
theorem set fl ci aci contains elements fl fl theorem contains elements 
aci unification algorithm algorithm aci unification implementation simplification general algorithm described 
advantage algorithm allows lazy generation solutions easily implemented declarative languages prolog advantage built backtracking 
algorithm unifies tuples aci terms solving systems aci equations 
algorithm published algorithms general aci unification computes complete necessary minimal set unifiers 
course minimal complete set unifiers obtained second phase choosing general unifiers computed set 
far know direct phase efficient computation minimal complete set aci unifiers considered open problem 
example complete set aci unifiers computed implementation unification phi phi consist unifiers 
phi phi fa 
phi 
phi 
phi fa 
phi 

phi fa 
phi 

xg fa 

phi 
phi fa 


xg fa 

phi 
xg fa 


xg complete set unifiers minimal 
general case set unifiers computed unification algorithm may contain redundant unifiers 
case study abstracting semantics section illustrates construction bottom type analyzer abstraction semantics defined equation operations aci unification 
demonstrate bottom type analysis provides precise description non ground minimal model program information approximate answers arbitrary initial goals 
straightforward obtain information call patterns magic sets described example 
symbolic types condensing jacobs prove topdown bottom goal dependent goal independent analyses guaranteed equally precise involve unification algorithm idempotent commutative upper bound function additive 
interesting note definitions satisfy properties trivially domain condensing terminology 
idempotence means performing unification algorithm twice give information 
words unification algorithm information type descriptions shot 
commutativity means order solve aci equations influence precision result 
words unification algorithm confluent 
additivity means precision lost domain performing upper bound operations 
case idempotence trivial substitutions substitutions formal sense unifiers idempotent substitutions 
commutativity trivial reader notice semantics appropriate underlying domain symbolic types downwards closed 
true choose semantics simply commonly known 
minimal set general unifiers unique depend order equations solved 
note unification algorithm computes complete minimal set unifiers potentially solving equations different orders result different complete sets 
domain downwards closed complete set unifiers gives set downwards closed instances minimal set general unifiers 
upper bound operation domain trivially additive defined set union 
fl fl fl 
abstracting semantics straightforward involves replacing concrete operations definition equation corresponding operations 
type analysis program obtained fixed point resulting immediate consequence operator tp ff 
ff tp oe fi fi fi fi fi fi hb ff ff hoe oe hb ff ff theorem implies fixpoint operator exists computed iterated evaluation 
theorem tp monotonic continuous 
proof 
monotonicity straightforward 
show tp continuous 
chain totally ordered set interpretations 
prove tp tp 
immediate monotonicity 
ff tp 
exists clause atoms ff ff unifier hoe oe hb ff ff ff oe 
exist interpretations ff ff max phi psi ff tp tp tp 
corollary fixpoint tp exists lfp 
proof 
knaster tarski theorem 
prove fixed point tp correctly approximates atoms contained fixed point tp theorem safety bv tp ff tp proof 
assume atom ff ff 
clause atoms renamed apart unifier mgu hb hb ff oe 
ff contains atoms oe oe renamed apart 
theorem corollary exists unifier hoe oe hoe oe oe approximates ff oe 
ff tp ff equivalently tp ff tp 
theorem partial correctness lfp lfp 
proof 
induction prove tp trivial basis induction step provided theorem 
claim theorem follows corollary 
termination monomorphic analysis termination straightforward consequence finiteness domain 
contrast polymorphic type analysis defined guaranteed terminate 
implementation reasonable results obtained simple depth abstraction 
theorem termination lfp finitely computable monomorphic type abstraction 
proof 
immediate theorem corollary 
example illustrates non termination polymorphic type analysis 
example consider program 

model program consists atoms form 
corresponding polymorphic type expressions abstraction equation model num list num phi nil list list num phi nil phi nil expressions correspond infinite sequence types number list numbers list lists numbers depth abstraction applied approximate atoms 
depth atom maximal depth symbolic types arguments reflects number levels polymorphism 
value determined user may depend precision requirements available computational resources 
clear growth number possible types number aci unifiers type expressions grow exponentially 
practical reasons levels polymorphism types sufficient 
compilation convenient view type analysis approach consisting phases program abstracted choice types 
result program call set logic program reflecting fact terms may viewed flat sets specified phi constructor 
analysis performed second stage operator similar equation parameterized program oe ff fi fi fi fi fi fi ff ff ff ff hb hb ff ff hb approach referred compilation clearly equivalent interpretation described 
lfp oe lfp 
meaning program easily evaluated simple prolog meta interpreter similar described 
main difference interpreter enhanced replacing standard unification aci unification 
simple prolog interpreter symbolic types appendix appendix contains code implementing aci unification algorithm monomorphic types 
complete implementation monomorphic type analyzer goal dependent goal independent analyses available ftp ftp cs bgu ac il pub people codish monotypes tar gz 
examples examples illustrate bottom analysis monomorphic types equation compilation 
result analysis goal independent representation type dependencies program 
result analysis atom describing input types call pattern derive description output types corresponding success patterns 
semantics characterizes answers arbitrary goals semantics approximates answers arbitrary goals 
formal justification described 
similar proofs os domain 
addition answers success patterns call patterns approximated applying suitable program transformation magic sets 
detailed description approach application os domain 
example consider append program left monomorphic type abstraction right append ys ys 
append list ys ys append xs ys zs append list ys list append xs ys zs 
append xs ys zs 
describe step step evaluation fixed point operator equation program 
iteration obtain clause oe phi append list psi second iteration renaming fact unified body second clause producing binding phi xs 
list 
zs 
psi obtain oe ae append list append list list phi oe iteration generates atom append list phi list list phi list phi equivalent append list list phi fixed point 
atoms queried describe success patterns various initial goals 
instance append list list 
append list 
list list list call append arguments lists answered substitution binds third argument list 
call append third argument list answered substitution binds arguments lists 
example consider concrete program specifying inorder relation binary tree left monomorphic type abstraction right clauses example inorder void 
inorder tree list 
inorder tree inorder tree phil inorder il inorder ir inorder il inorder ir append il ir 
append il list 
analysis inorder program produces atoms lfp oe inorder tree list append list append list list phi result analysis indicates query inorder argument binary tree answered substitution binds second argument list 
goal dependent type analysis inorder obtained bottom semantics applied result magic sets transformation program 
denote result transformation program respect goal 
result analysis magic sets initial goal form inorder tree results set atoms lfp oe call inorder tree call append list list answer inorder tree list answer append list list list indicating calls inorder computations form initial call predicate append program concatenate lists 
example illustrates polymorphic type analysis abstraction equation 
example taken authors argue types program computed precisely type systems maintain dependency information 
exactly strong point domain handle example successfully 
example consider task binary tree nodes labeled natural numbers compute binary tree structure node labeled maximal number prolog program solves task pass constructing binary tree nodes labeled variable max unifying max maximal number input tree tree tree max max 
void void 
tree max tree max newl newr max maxl newl max maxr newr max maxl maxr 
max max max max max 
max max bottom semantics program computed analyzer void void tree num phi void tree num phi void void num void tree num phi void num tree phi void tree num phi void num num tree num phi void max num num num num max num num num assume prolog built ins suitable definitions programs 
example num num num num 
analysis captures correctly precisely fact arguments bound binary trees numbers success 
interesting observe different call patterns computation starting call type tree num phi void 
assuming initial call form tree num phi void evaluation strategy left right fist call form tree num phi void 
recursive calls form tree num phi void void 
answers call patterns obtained solving elements equation tree num 
num tree num 
tree num 
num tree num num tree num 
void 
num void 
example consider result polymorphic type dependency analysis append relation described example 
ae append nil append list phi nil list phi oe interesting observe directional types expressed 
call append arguments lists type append list list 
list 
call append arguments lists type type append list list 
list 
call append third argument list type append list 
list list nil list list nil 
implementation implementation described type analysis principle simple prolog interpreter described appendix additional optimizations introduced actual prototype analysis semi naive interpreter described 
goal dependent analysis interpreter induced magic sets described alternative applying magic sets transformation 
implementation small consisting lines prolog code 
addition prolog implementation experimented implementation tabled resolution implemented xsb described 
experimental evaluation technique indicates spite fact basic underlying unification algorithm np complete analyses usually quite fast 
appears actual terms unified program analyses tend small having general unifiers 
collection small medium sized benchmarks obtained reasonable timings 
described :10.1.1.38.1444
presents new notion typing logic programs generalizes notion directional types 
assume particular notion types provided user automatically infer type dependencies program respect definition 
analysis method novel combination program abstraction aci unification shown correct optimal 
type dependencies obtained abstracting programs replacing concrete terms types evaluating meaning programs standard semantics logic programs enhanced aci unification 
approach generic standard semantics 
domain symbolic types shown condensing means precision lost performing bottom goal independent analysis 
similar approach aci unification applied sharing analysis logic programs 
complete description types sharing analyses 
acknowledgment benefited discussions comments colleagues bart collaborated earlier influenced helped get benchmarks working fast 
sagonas helped port implementation xsb benchmarks faster 
giorgio levi insisted check domain symbolic types condensing 
robert constable saumya debray john gallagher roberto giacobazzi useful comments earlier version 
appendix aci unification procedure code aci unification implements unification monomorphic types 
algorithm restricted optimized expressions containing constants variables 
algorithm relies notion unification graph corresponding unification problem 
definition terms corresponding sets constitutes constants variables respectively 
unification graph corresponding aci unification bipartite graph iff unifiable example illustrates unification graphs corresponding aci unification phi phi left phi phi right 
gamma gamma gamma gamma gamma gamma gamma gamma unification graphs phi phi phi phi algorithm unification monomorphic types starts construction graph corresponding unification 
marks edge general common instance stages algorithm incrementally chooses subsets edges subgraphs disconnected nodes 
subset edges exists unification fails 
success stage algorithm converts subgraph unifier types follows 
node corresponding variable equation phi phi constructed labels edges adjacent note common variable nodes correspond variable 
unifier set substitutions 
phi phi see unifies observing composed set labels edges example consider corresponding graph unification phi phi left 
mark edge graph general instances corresponding nodes described 
graph obtain gamma gamma gamma gamma note edge marked general common instance modulo renaming 
construct unifier considering edges unification graph binding variables expressions sets labels corresponding adjacent edges 
produce unifier phi 
phi 
phi psi unifier computed algorithm case obtained considering edges 
phi 

psi note subsumed 
unification polymorphic types performed technique 
phase solving equations constructed subgraph extended handle polymorphic constitutes 
similarly general case concrete unification polymorphic constitutes principal functor unified recursively aci unification arguments 
unify monomorphic types assumed flat sorted lists constitutes 
complete set solutions obtained backtracking code 
library quintus similar manipulating sets ordered list representation required 
ground ground 
axb axb table graph 
throw away pairs non unifiable terms nonexistent edges graph 
axb 
axb 
compute set edges covering nodes graph 
backtrack predicate generates solutions 





convert list edges vi vj vm vn 
graph representation vm vn vr vs 
table graph 
table graph 
table graph vs 
cont cont table graph vs cont 
try unify node set nodes linked 

var 


xs xs 
appendix simple prolog interpreter symbolic types meaning program easily evaluated simple prolog meta interpreter similar described 
main difference interpreter enhanced replacing standard unification 
evaluator depicted similar 
main difference standard unification replaced aci unification predicate unify normal form terms maintained predicate canonical variance test newly computed atoms degenerates syntactic variance check 
clause program represented fact form abs clause added clauses 
initially fact true known 
new facts derived iteration predicate tp asserted program semantic variants 
evaluation initiated query iterate tp leaves result analysis prolog database set facts form fact atom 
iterate tp tp 
iterate tp retract database changed iterate tp 
tp abs clause prove canonical hs cond assert fact hs fail 
prove bs fact bx unify bx prove bs 
prove fact bx unify bx 
cond assert database 
cond assert assert cond assert database changed 
database clause true variant 
fact true 
goal independent evaluator tp aiken lakshman 
directional type checking logic programs 
le charlier pages 
apt 
logic programming 
van leeuwen editor handbook theoretical computer science volume formal models semantics pages 
elsevier amsterdam mit press cambridge 
apt 
declarative programming prolog 
miller editor logic programming proceedings international symposium pages vancouver canada 
mit press 
baader siekmann 
unification theory 
hogger gabbay robinson editors handbook logic artificial intelligence logic programming volume pages 
oxford science publications 
giacobazzi levi 
application constraint propagation data flow analysis 
proc ninth ieee conference ai applications pages orlando fl 
ieee computer society press 
bancilhon maier sagiv ullman 
magic sets strange ways implement logic programs 
proceedings acm symposium principles database systems pages 
giacobazzi 
bottom polymorphic type inference logic programming 
science computer programming december 
levi martelli 
semantics approach theory applications 
journal logic programming 
appear 

directional types logic programming 
phd thesis linkoping university sweden 
ma nski 
aspects directional types 
sterling editor proceedings twelfth international conference logic programming japan 
mit press 
lakshman reddy 
framework directionality proving termination logic programs 
apt editor proceedings joint international conference symposium logic programming pages washington usa november 
mit press 
codish 
efficient goal directed bottom evaluation logic programs 
technical report ben gurion university january 
ftp ftp cs bgu ac il pub people codish ps gz 
codish dams 
bottom interpretation logic programs 
theoretical computer science february 
codish 
deriving polymorphic type dependencies logic programs multiple incarnation prop 
le charlier pages 
codish 
analyzing logic programs prop logic programs magic wand 
journal logic programming december 
codish sagonas 
general purpose semantic analysis xsb 
technical report ben gurion university january 
ftp ftp cs bgu ac il pub people codish ps 
codish :10.1.1.38.1444
type dependencies logic programs aci unification 
proc 
fourth israel symposium theory computing systems pages 
ieee computer society press 
codish 
algebraic approach sharing analysis logic programs 
van hentenryck editor proceedings fourth international static analysis symposium volume lncs pages 
springer verlag sep 
fil 
interpretation logic programs domain groundness sharing freeness analysis 
hudak jones editors proceedings acm sigplan symposium partial evaluation semantics program manipulation pepm number sigplan notices pages 
available technical report dip 
di matematica universit di padova italy 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc fourth acm symp 
principles programming languages pages 
acm press january 
falaschi levi martelli palamidessi 
declarative modeling operational behavior logic languages 
theoretical computer science 
falaschi levi martelli palamidessi 
model theoretic reconstruction operational semantics logic programs 
information computation 
fruhwirth 
type inference program transformation partial evaluation 
abramson rogers editors meta programming logic programming pages 
mit press 
fruhwirth shapiro 
logic programs types logic programs 
albert meyer editor proceedings th annual ieee symposium logic computer science pages amsterdam netherlands july 
ieee computer society press 
gallagher de waal 
fast precise regular approximation logic programs 
van hentenryck pages 
isbn 
giacobazzi debray levi 
generalized semantics constraint logic programs 
proceedings international conference fifth generation computer systems pages icot japan june 
acm association computing machinery 
gunter scott 
semantic domains 
van leeuwen editor handbook theoretical computer science volume formal models semantics chapter pages 
north holland new york 
hermenegildo warren debray 
global flow analysis practical compilation tool 
journal logic programming august 
jacobs 
static analysis logic programs independent parallelism 
journal logic programming 
kapur narendran 
complexity unification problems associative commutative operators 
journal automated reasoning october 
kifer wu 
order theory types polymorphism logic programming 
ieee symposium logic computer science 

logic program analysis set logic programs 
master thesis ben gurion university israel 
le charlier editor 
st international symposium static analysis volume lncs namur belgium september 
springer verlag 
lincoln christian 
adventures associative commutative unification 
journal symbolic computation 
appears unification edited claude kirchner academic pages 
lloyd 
foundations logic programming 
springer verlag berlin 
second edition 
marriott sndergaard 
precise efficient groundness analysis logic programs 
acm letters programming languages systems march 
pedreschi 
proof method run time properties prolog programs 
van hentenryck pages 
isbn 
frank pfenning editor 
types logic programming cambridge massachusetts 
mit press 
reddy 
inference polymorphic types logic programming 
lusk overbeek editors proc 
north american conf 
logic programming pages 
mit press cambridge mass 
nguyen 
integrating modes subtypes prolog type checker 
apt editor proceedings joint international conference symposium logic programming pages washington usa 
mit press 
stickel 
unification algorithm associative commutative functions 
journal acm april 
tarski 
lattice theoretical fixpoint theorem applications 
pacific math 
pascal van hentenryck editor 
proceedings eleventh international conference logic programming santa margherita ligure italy 
mit press 
isbn 
xu warren 
type inference system prolog 
robert kowalski kenneth bowen editors proceedings fifth international conference symposium logic programming pages 
alp ieee mit press 

