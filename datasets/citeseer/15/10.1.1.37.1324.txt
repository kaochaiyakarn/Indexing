conte udo relat de es 
contents report sole responsibility author 
minimization binary automata tomasz kowaltowski cl audio lucchesi jorge stolfi relat dcc de minimization binary automata tomasz kowaltowski cl audio lucchesi jorge stolfi finite automata represent large vocabularies natural languages quite sparse sense vast majority states transitions lead rejecting state 
suggests representation automaton state small list transitions entering non rejecting states 
possible factor parts lists saving space 
depending order transitions appear lists degree saving varies 
leads problem minimizing representations 
problem interesting theoretical point view quite useful practical point view experimental results indicate 
applications involving finite automata applications finite automata represent sets words 
uses compiler construction automata model implement efficient lexical analysers 
departamento de ciencia da ao universidade de campinas campinas sp 
mail lucchesi dcc unicamp br 
authors listed alphabetical order 
research partially supported brazilian national council scientific technological development cnpq 
kowaltowski lucchesi stolfi gross perrin liang appel jacobson examples finite automata computational linguistics 
lucchesi kowaltowski finite automata represent large natural language vocabularies applications spelling checkers multilanguage dictionaries thesauri minimal perfect hashing 
particular efficient spelling checker adviser portuguese language implemented vocabulary consisted approximately words finite automaton kbytes memory spelling checker process words minute standard ibm compatible personal computer 
technique unix program spell finite automata implement spelling checkers languages 
companion show application debugging natural language vocabularies 
deal question minimizing certain type automata called binary automata represent finite automata 
said know algorithm solving problem brute force 
section formalize notion binary automata 
section algorithm binary automaton reduction successful experiments 
experiments involved different vocabularies languages 
section give brief description programming environment tools experimental results 
binary automata vocabulary nonnull finite set words finite alphabet sigma 
sigma ffi minimum deterministic finite automaton accepts vocabulary usual denotes set states set final states initial state ffi theta sigma transition function 
order avoid technicalities assume loss generality sigma gamma minimization binary automata sigma 
assumption just state accepting state denoted observe finiteness implies just rejecting state denoted state gamma exists word sigma ffi ffi letter sigma fq depicts minimum finite automaton accepts vocabulary fa ai ao ei em oi osg minimum finite automaton rejecting state omitted accepts language fa ai ao ei em oi osg 
naive representation ffi matrix having jqj lines sigmaj columns ffi sigma considering large vocabulary natural language approach practical 
example automaton portuguese language vocabulary contains kowaltowski lucchesi stolfi states uses alphabet roughly letters 
experience shows automaton natural language vocabulary sparse sense vast majority states letters sigma ffi words vast majority entries matrix equal entries equal called useful 
case portuguese language example half lines just useful entry roughly lines entries 
sparseness leads naturally representation state corresponding line say useful transitions represented list pairs describes useful entry line shows representation automaton 
way reasoning leads naturally considering element list state automaton device pointer element list failure transition 
call device binary automata 
point important recall finite automata just accepting state transitions enter rejecting state list needed binary automaton may represented data structure function delta evaluates ffi theta sigma sigma 
way ensure ffi defined require exists partial order satisfying property fq oe vocabulary accepted defined usual fw sigma ffi denotes initial state binary automata appear quite literature 
famous occurrence known pattern matching algorithm knuth morris pratt 
point important observe finiteness optimality imply acyclic minimization binary automata representation lists automaton shown 
kowaltowski lucchesi stolfi type state record case final boolean true false letter state state record state function delta state letter state nil delta nil final delta nil delta delta delta data structure represent binary automata corresponding implementation transition function ffi minimization binary automata sense sigma ffi directed circuit underlying directed graph loops entering rejecting state equivalently concept topological sorting partial order state set sigma ffi equality follows corresponding binary automaton satisfies set states partial order fq oe oe property quite convenient may extend total order represent binary automata vectors delta delta delta rejecting state state state represented entry vector entry triple sigma theta theta strictly smaller shows vector representation binary automaton 
binary automata may yield memory savings greater expects 
states identical 
fact leads smaller equivalent binary automaton shown 
observe may permute states list state just pointer entering state 
interchange yields smaller automaton depicted 
illustrates binary automaton equivalent having minimum number states 
shows optimum binary automaton language 
problem minimizing binary automaton theoretical practical interest 
section practical results indicate significant savings size binary automata representing natural languages 
results obtained algorithm called fold described section 
kowaltowski lucchesi stolfi vectorial representation binary automaton shown inf 
minimization binary automata smaller binary automaton equivalent 
kowaltowski lucchesi stolfi smaller binary automaton equivalent 
minimization binary automata minimum binary automaton equivalent 
kowaltowski lucchesi stolfi optimum binary automaton equivalent 
minimization binary automata suspect problem deciding binary automaton minimum np complete 
proof np completeness 
algorithm fold tried algorithms decrease size binary automata 
fold successful 
implementation fold represents binary automata vectors explained section 
convenient describe data structure 
fold works iteratively 
iteration binary automaton produces new binary automaton equivalent iteration automaton optimize 
automaton obtained iteration fewer states algorithm enters new iteration playing role states algorithm stops 
describe iteration need introduce concepts notation 
state fq proper satisfies conditions initial state ii state fq iii fq example proper states states 
state pair set denoted defined follows fq fq iteration fold visits proper state tries permute elements list transitions order decrease number states 
proper states visited increasing order partial kowaltowski lucchesi stolfi order example fold visit proper states order 
describe constitutes visit proper state see 
step determine set fr visited oe fq element chosen maximum 
list transitions emerging state ordered way leave order transitions state listed ensuring list shared list remains order remaining transitions 
transitions selected time 
selection criterium frequency transitions pair sets states ft proper visited pairs having highest frequency selected 
new state created letter success transition failure transition 
fold updates assigning new state just created 
selection process continues 
new version intuitively reason initially choosing maximize find largest factor new automaton 
reason selecting pair np having highest frequency pair sets states increase probability finding new factors iterations 
automaton compression mentioned earlier automaton represented vector associates state triple sigma theta theta order save disk space automaton stored compressed format coding triple variable number bits described 
minimization binary automata function visit state state fr proper visited fq mark visited choose maximum ft proper visited gj choose maximum new state visit visit proper state kowaltowski lucchesi stolfi triple coded 
triple coded sequentially starting triple state proceeding maximum state 
coding done dlog bits number characters occurring dictionary 
special symbol coded zero 
state gamma 
large percentage states roughly half gamma 
need code remaining cases distinguish gamma gamma means extra bit 
case gamma coded gamma gamma 
likewise state gamma 
large percentage states roughly gamma 
extra bits distinguish possibilities case gamma 
case gamma coded gamma gamma 
necessary code done precisely bits gamma 
experimental results environment programming tools chose language modula implement environment 
main reasons simplicity language object oriented programming paradigm availability unix workstations 
environment consists set modules provide basic abstractions 
important ones described companion 
program fold contains lines slow automaton large complexity quadratic size automaton example ran week sparc station automaton representing huge english vocabulary words 
minimization binary automata vocabulary minimum automaton vocabulary words letters states transitions portuguese french italian english hebrew english english russian dutch norwegian german swedish characteristics vocabularies experiments 
experimental results tried fold automata representing large vocabulary 
resulting savings varied vocabulary vocabulary minimum case swedish vocabulary maximum case portuguese vocabulary 
represented automata compressed form 
case savings obtained folding varied case german vocabulary case portuguese vocabulary 
interesting observe relation compression achieved folding process ratio letters transition 
higher ratios portuguese french italian kowaltowski lucchesi stolfi uncompressed compressed unfolded folded unfolded folded vocabulary size size size size portuguese french italian english hebrew english english russian dutch norwegian german swedish note column ratio sizes folded compressed automaton sizes unfolded uncompressed automata 
experimental results fold automata sizes bytes 
minimization binary automata vocabularies finds compression rates range vocabularies lower ratios russian norwegian swedish vocabularies finds compression rates range 
know explain dutch german vocabularies follow rule medium range ratios low range compression rates 
worth mentioning relatively constant compression rate obtained compounding fold compression technique described section 
emphasize vocabularies differ significantly completeness 
languages inflected forms included vocabulary quite complete 
differences numbers justified quality vocabularies intrinsic differences languages 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
appel jacobson 
world fastest scrabble program 
communications acm may 
bentley 
spelling checker 
communications acm 
gross perrin editors 
electronic dictionaries automata computational linguistics volume lecture notes computer science 
springer verlag berlin 
knuth morris pratt 
fast pattern matching strings 
siam journal computing 
kowaltowski lucchesi stolfi kowaltowski lucchesi stolfi 
application finite automata debugging natural language vocabularies 
relat 
liang 
word hy tion com pu ter 
phd thesis stanford university stanford ca 
lucchesi kowaltowski 
applications finite automata representing large vocabularies 
software practice experience 
mcilroy 
development spelling list 
ieee trans 
comm 
nelson editor 
system programming modula 
prentice hall 
relat applications finite automata representing large vocabularies lucchesi kowaltowski point set pattern matching dimensions de lee irrelevance edge orientations acyclic directed disjoint paths problem lucchesi note primitives manipulation general subdivisions computation voronoi diagrams transversal theorem bipartite graphs lucchesi younger implementing integrity control active databases medeiros andrade new experimental results bipartite matching maintaining integrity constraints versions database medeiros clique complete graphs lucchesi mello examples informal rigorous correctness proofs tree traversing algorithms kowaltowski debugging aids statechart systems elias browsing querying object oriented databases de oliveira de relat transforming statecharts reactive systems antonio figueiredo hans hierarchical ring protocol efficient scheme reading replicated data das ricardo de matching algorithms bipartite graphs herbert baier cl audio lucchesi lexbfs algorithm proper interval graph recognition de figueiredo jo ao de mello de 
nelson 
machado 
aes ao de um de de uma interface neto ariadne carvalho de interfaces de lucena hans introspection projection reasoning agents jacques wainer ao de de com ao carlos antonio costa paulo icio de ao de em um para ao de por paulo cesar nelson castro machado implementation structure rm osi iso transaction processing application contexts fl de silva roberto mauro madeira boole conditions possible experience reasoning uncertainty pierre hansen brigitte jaumard marcus poggi de ao modelling geographic information systems object oriented framework claudia medeiros barros silva managing time object oriented databases lincoln oliveira claudia medeiros extended hierarchical quorum consensus control replicated data traditional voting logical structures das ricardo de oliveira ll object oriented library language manual tomasz kowaltowski para ao de em sistemas de de lopes de oliveira aes rule application gis case study claudia medeiros aes ao com vhdl carlos kruger cortes reflections statecharts capture humancomputer interface behaviour de lucena hans applications finite automata debugging natural language vocabularies tomasz kowaltowski cl audio leonardo lucchesi jorge stolfi minimization binary automata tomasz kowaltowski cl audio leonardo lucchesi jorge stolfi departamento de ciencia da ao postal universidade de campinas campinas sp dcc unicamp br 
