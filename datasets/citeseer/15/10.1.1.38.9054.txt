jaws framework high performance web servers james hu cs wustl edu douglas schmidt schmidt cs wustl edu department computer science washington university st louis mo developers communication software face challenges 
communication software contains inherent complexities fault detection recovery accidental complexities continuous re rediscovery re invention key concepts components 
meeting challenges requires thorough understanding object oriented application frameworks patterns 
illustrates applied frameworks patterns communication software develop high performance web server called jaws 
jaws object oriented framework supports configuration various web server strategies thread pool concurrency model asynchronous lru caching vs 
thread request concurrency model synchronous lfu caching 
jaws framework strategies customized systematically measured independently collaboratively determine best strategy profiles 
profiles jaws statically dynamically adapt behavior deploy effective strategies software hardware platform workload 
jaws adaptive software features powerful application framework constructing highperformance web servers 
past years volume traffic world wide web web grown dramatically 
traffic increases due largely proliferation inexpensive ubiquitous web browsers ncsa mosaic netscape navigator internet explorer 
likewise web protocols browsers increasingly applied specialized computationally expensive tasks image processing servers described possible funds siemens ag eastman kodak nsf research ncr 
siemens kodak database search engines altavista lexis nexis 
keep pace increasing demand essential develop high performance web servers 
developers face remarkably rich set design strategies configuring optimizing web servers 
instance developers select wide range concurrency models thread request vs thread pool dispatching models synchronous vs asynchronous dispatching file caching models lru vs lfu protocol processing models vs 
single configuration optimal hardware software platform workloads 
existence alternative strategies ensures web servers tailored users needs 
navigating design optimization strategies tedious error prone 
guidance design optimization strategies apply developers face task engineering web servers ground resulting ad hoc solutions 
systems hard maintain customize tune engineering effort spent just trying get system operational 
definitions frequently refer terms oo class library framework pattern component 
terms refer tools build reusable software systems 
oo class collection software object provide reusable functionality user calls object methods 
framework reusable semi complete application specialized produce custom applications 
pattern represents recurring solution software development problem particular context 
component refers object 
oo class libraries frameworks collections components reified instantiation specialization 
pattern component reified codification 
overview illustrates produce flexible efficient web servers oo application frameworks design patterns 
patterns frameworks applied synergistically improve efficiency flexibility web servers 
patterns capture designs software architectures high performance adaptive web servers systematic comprehensible format 
frameworks capture concrete designs algorithms implementations web servers particular programming language java 
contrast oo class libraries provide raw materials necessary build applications guidance put pieces 
focuses patterns framework components develop high performance web server called jaws 
jaws web server framework types servers built 
jaws framework developed ace framework 
ace framework reifies key patterns domain communication software 
framework patterns jaws ace representative solutions applied successfully communication systems ranging telecommunication system management enterprise medical imaging real time avionics 
organized follows section presents overview patterns frameworks motivates need type communication software framework provided jaws section illustrates patterns components applied develop high performance web servers section compares performance jaws high speed atm networks high performance web servers section presents concluding remarks 
applying patterns frameworks web servers increasing demand high performance web servers provide services content growing number internet intranet users 
developers web servers strive build fast scalable configurable systems 
task difficult care taken avoid common traps pitfalls include tedious error prone low level programming details lack portability wide range design alternatives 
section presents road map hazards 
describe patterns frameworks applied avoid hazards allowing developers leverage design code reuse 
common pitfalls developing web server software developers web servers confront recurring challenges largely independent specific application requirements 
instance communication software web servers perform various tasks related connection establishment service initialization event demultiplexing event handler dispatching interprocess communication memory management file caching static dynamic component configuration concurrency synchronization persistence 
web servers tasks implemented ad hoc manner low level native os application programming interfaces apis win posix written unfortunately native os apis effective way develop web servers types communication middleware applications 
common pitfalls associated native os apis excessive low level details building web servers native os apis requires developers intimate knowledge low level os details 
developers carefully track error codes returned system call handle os specific problems server 
details divert attention broader strategic issues semantics program structure 
example unix developers wait system call distinguish return errors due child processes errors signal interrupts 
case wait reissued 
continuous rediscovery incompatible higher level programming abstractions common remedy excessive level detail os apis define higher level programming abstractions 
instance web servers create file cache avoid accessing filesystem client request 
types abstractions rediscovered reinvented independently developer project 
ad hoc process hampers productivity creates incompatible components readily reusable projects large software organizations 
high potential errors programming low level os apis tedious error prone due lack 
example web servers programmed socket api 
endpoints communication socket api represented untyped handles 
increases potential subtle programming mistakes run time errors 
lack portability low level os apis notoriously non portable releases os 
stance implementations socket api win platforms subtly different unix platforms 
implementations different versions windows nt possess incompatible bugs cause sporadic failures performing nonblocking connections 
steep learning curve due excessive level detail effort required master os level apis high 
instance hard learn program posix asynchronous correctly 
harder learn write portable application asynchronous mechanisms differ widely os platforms 
inability handle increasing complexity os apis define basic interfaces mechanisms process thread management interprocess communication file systems memory management 
basic interfaces scale gracefully applications grow size complexity 
instance typical unix process allows backlog pending connections 
number inadequate heavily accessed web servers handle hundreds simultaneous clients 
overcoming web server pitfalls patterns frameworks software reuse widely touted method reducing development effort 
reuse leverages domain knowledge prior effort experienced developers 
applied effectively reuse avoid re creating re validating common solutions recurring application requirements software design challenges 
java java lang net net common examples applying reusable oo class libraries communication software 
class libraries effectively support component reuse small scope overly constrained 
particular class libraries capture canonical control flow collaboration families related software components 
developers apply class library reuse re invent re implement software architecture new application 
powerful way overcome pitfalls described identify patterns underlie proven web servers reify patterns object oriented application frameworks 
patterns frameworks help alleviate continual re discovery re invention key web server concepts components capturing solutions common software development problems 
benefits patterns web servers patterns document structure participants common web server micro architectures 
instance reactor active object patterns widely web server dispatching concurrency strategies respectively 
patterns generalizations object structures proven useful build flexible efficient web servers 
traditionally types patterns locked heads expert developers buried deep source code 
allowing valuable information reside locations risky expensive 
instance insights experienced web server designers lost time documented 
likewise substantial effort may necessary reverse engineer patterns existing source code 
capturing documenting web server patterns explicitly essential preserve design information developers enhance maintain existing software 
knowledge domain specific patterns helps guide design decisions developers building new servers domains 
benefits frameworks web servers knowledge patterns helps reduce development effort maintenance costs 
reuse patterns sufficient create flexible efficient web server software 
patterns enable reuse design architecture knowledge abstractions documented patterns directly yield reusable code 
essential augment study patterns creation application frameworks 
frameworks help developers avoid costly re invention standard web server components implementing common design patterns factoring common implementation roles 
relationship frameworks patterns reuse techniques frameworks provide reusable software components applications integrating sets classes defining standard ways instances classes collaborate 
general components self contained usually depend functionality provided components framework 
collection components forms partial implementation application skeleton 
skeleton customized inheriting instantiating reusable components framework 
scope reuse web server framework significantly larger traditional function libraries oo class libraries components 
particular jaws framework described section tailored wide range web server tasks 
tasks include service initialization error handling flow control event processing file caching concurrency control prototype pipelining 
important recognize tasks reusable types communication software 
general frameworks patterns enhance reuse techniques class libraries components ways 
frameworks define semi complete applications embody domain specific object structures functionality class libraries provide relatively small granularity reuse 
instance classes typically low level relatively independent general purpose components strings complex numbers arrays bit sets 
invocations selections event loop oo design application specific logic reactor adapter state active object singleton strategy database adts math networking graphics gui design patterns class libraries class library component architecture contrast components framework collaborate provide customizable architectural skeleton family related applications 
complete applications composed inheriting instantiating framework components 
shown frameworks reduce amount application specific code domain specific processing factored generic framework components 
active object singleton adapter state reactor math adts graphics loop gui oo design invocations callbacks database event networking logic application specific application framework component architecture frameworks active exhibit inversion control run time class library components generally behave passively 
particular class library components perform processing borrowing thread control application objects self directed 
application objects self directed application developers largely responsible deciding combine components classes form complete system 
instance code manage event loop determine flow control reusable application specific components generally rewritten new application 
typical structure dynamics applications built class libraries components illustrated 
illustrates design patterns help guide design implementation class library components 
note existence class libraries providing tools solve particular tasks establishing network connection offer explicit guidance system design 
particular software developers solely responsible identifying applying patterns designing applications 
contrast class libraries components framework active 
particular manage canonical flow control application event dispatching patterns reactor observer 
callback driven runtime architecture framework shown 
illustrates key characteristic framework inversion control run time 
design enables canonical application processing steps customized event handler objects invoked framework reactive dispatching mechanism 
events occur framework dispatcher reacts invoking hook methods pre registered handler objects perform applicationspecific processing events 
inversion control allows framework application determine set application specific methods invoke response external events connections data arriving sockets 
result framework reifies integrated set patterns pre applied collaborating components 
design reduces burden software developers 
practice frameworks class libraries components complementary technologies 
frameworks utilize class libraries components internally simplify development framework 
instance portions jaws framework string vector containers provided standard template library manage connection maps search structures 
addition applicationspecific callbacks invoked framework event handlers frequently class library components perform basic tasks string processing file management numerical analysis 
illustrate oo patterns frameworks applied successfully develop flexible efficient communication software remainder examines structure performance jaws framework 
jaws adaptive web server benefits applying frameworks patterns communication software best illustrated example 
section describes structure functionality jaws 
jaws high performance adaptive web server implements protocol 
platform independent application framework types communication servers built 
overview jaws framework illustrates major structural components design patterns comprise jaws adaptive web server jaws framework 
jaws designed allow various web cached virtual filesystem expander framework strategy strategy concurrency protocol pipeline framework framework tilde home 
event dispatcher acceptor asynchronous completion token reactor proactor pipes filters state singleton handler protocol protocol filter strategy service configurator active object service configurator state strategy architectural overview jaws framework server strategies customized response environmental factors 
factors include static factors support kernel level threading asynchronous os number available cpus dynamic factors web traffic patterns workload characteristics 
jaws structured framework frameworks 
jaws framework contains components frameworks event dispatcher concurrency strategy strategy protocol pipeline protocol handlers cached virtual filesystem 
framework structured set collaborating objects implemented components ace 
collaborations jaws components frameworks guided family patterns listed borders 
outline key frameworks components patterns jaws 
detailed description patterns applied jaws design shown section 
event dispatcher component responsible coordinating jaws concurrency strategy strategy 
passive establishment connections web clients follows acceptor pattern :10.1.1.40.8396
new incoming requests serviced concurrency strategy 
events processed dispatched protocol handler parameterized strategy 
ability dynamically bind particular concurrency strategy strategy range alternatives follows strategy pattern 
concurrency strategy framework implements concurrency mechanisms single threaded thread thread pool selected adaptively run time state pattern pre determined initialization time 
service configurator pattern configure particular concurrency strategy web server run time 
concurrency involves multiple threads strategy creates protocol handlers follow active object pattern 
strategy framework implements various mechanisms asynchronous synchronous reactive multiple mechanisms simultaneously 
asynchronous implemented proactor asynchronous completion token patterns :10.1.1.41.1032
reactive accomplished reactor pattern 
reactive utilizes memento pattern capture externalize state request restored time 
protocol handler framework allows system developers apply jaws framework variety web system applications 
protocol handler parameterized concurrency strategy strategy 
strategies remain opaque protocol handler adapter pattern 
jaws component implements parsing handling request methods 
abstraction allows protocols incorporated easily jaws 
add new protocol developers simply write new protocol handler implementation configured jaws framework 
protocol pipeline framework allows filter operations incorporated easily data processed protocol handler 
integration achieved employing adapter pattern 
pipelines follow pipes filters pattern input processing 
pipeline components linked dynamically run time service configurator pattern 
cached virtual filesystem component improves web server performance reducing overhead filesystem accesses 
various caching strategies lru lfu hinted structured selected strategy pattern 
allows different caching strategies profiled effectiveness enables optimal strategies configured statically dynamically 
cache web server instantiated singleton pattern 
tilde expander component cache component uses perfect hash table maps abbreviated user login names schmidt user home directories home cs faculty schmidt 
personal web pages stored user home directories user directories reside common root component substantially reduces disk overhead required access system user information file passwd 
virtue service configurator pattern tilde expander unlinked relinked dynamically server new user added system example 
overview design patterns jaws jaws architecture diagram illustrates jaws structured structured particular way 
understand jaws contains frameworks components concurrency strategy strategy protocol handler event dispatcher requires deeper understanding design patterns underlying domain communication software general web servers particular 
illustrates strategic tactical patterns related jaws 
patterns summarized 
strategic patterns patterns strategic software architecture web servers 
widely impacts level interactions large number components system 
patterns widely guide architecture types communication software 
notifies acceptor accept peer acceptor protocol handler create activate protocol handler peer stream open concurrency event dispatcher task structure acceptor pattern jaws acceptor pattern pattern decouples passive connection establishment service performed connection established :10.1.1.40.8396
jaws uses acceptor pattern adaptively change concurrency strategies independently connection management strategy 
illustrates structure acceptor pattern context jaws 
acceptor factory 
creates accepts activates new protocol handler event dispatcher notifies connection arrived client 
reactor pattern pattern decouples synchronous event demultiplexing event handler notification dispatching logic server applications service performed response events 
jaws uses reactor pattern process multiple synchronous events multiple sources events polling event sources blocking indefinitely single source events 
illustrates structure reactor pattern context jaws 
timer queue schedule timer cancel timer expire timers reactive io inputoutput inputoutput handler protocol pipeline reactor reactive io handler handle input handle output io handle initiation dispatcher handle events register handler remove handler synchronous io asynchronous io send file recv file send data recv data handle structure reactor pattern jaws jaws reactive io handler objects register initiation dispatcher events input output connections established requests 
initiation dispatcher invokes handle input notification hook method reactive io handler objects associated events occur 
reactor pattern single threaded web server concurrency model section 
proactor pattern pattern pattern decouples asynchronous event demultiplexing event handler completion dispatching logic server applications service performed response events 
jaws uses proactor pattern perform server specific processing parsing headers request asynchronously processing events 
illustrates structure proactor pattern context jaws 
jaws proactive io handler objects register completion singleton pipes filters acceptor service configurator adapter state service configurator service configurator state strategy memento reactor adapter proactor service configurator active object concurrency strategy framework protocol pipeline strategy framework strategy framework cached virtual filesystem framework design patterns jaws framework op open expire timers timer queue io handle cancel timer schedule timer proactor completion dispatcher handle events register handler remove handler send file recv file send data recv data proactive io handler handle read file handle write file handle synchronous io reactive io inputoutput inputoutput handler protocol pipeline asynchronous io structure proactor pattern jaws dispatcher events receipt delivery files connections established requests 
primary difference reactor proactor patterns proactive io handler defines completion hooks reactive io handler defines initiation hooks 
asynchronously invoked operations recv file send file complete completion dispatcher invokes appropriate completion hook method proactive io handler objects 
proactor pattern asynchronous variant thread pool section 
active object pattern pattern decouples method invocation method execution allowing methods run concurrently 
jaws uses active object pattern execute client requests concurrently separate threads control 
illustrates structure active object pattern context jaws 
snmp request dispatch resource representation protocol pipeline ftp request aq remove dispatch request scheduler aq insert protocol handler request snmp request ftp request activation queue insert remove method object structure active object pattern jaws protocol handler issues requests scheduler transforms request method request method objects stored activation queue 
scheduler runs separate thread client dequeues method objects transforms back method calls perform specified protocol 
active object pattern thread request thread pool thread session concurrency models described section 
service configurator pattern pattern decouples implementation individual components system time configured system 
jaws uses service configurator pattern dynamically optimize control reconfigure behavior web server strategies installation time run time 
illustrates structure service configurator pattern context protocol pipeline filters caching strategies 
service repository services lru strategy lfu strategy protocol pipeline filter repository cache strategy repository service init fini suspend resume info protocol handler 
filter read request parse request log request dll cache strategy 
structure service configurator pattern jaws depicts service configurator dynamically manage dlls dynamically linked libraries 
allows framework dynamically configure different implementations server strategies run time 
filter repository cache strategy repository inherit functionality service repository 
likewise strategy implementations parse request lru strategy borrow interfaces service component pattern managed dynamically repository 
tactical patterns web servers utilize tactical patterns ubiquitous domain independent strategic patterns described 
tactical patterns jaws strategy pattern pattern defines family algorithms encapsulates interchangeable 
jaws uses pattern extensively selectively configure different cache replacement strategies affecting core software architecture web server 
adapter pattern pattern transforms interface client 
jaws uses pattern strategy framework uniformly encapsulate operations synchronous asynchronous reactive operations 
state pattern pattern defines composite object behavior depends state 
event dispatcher component jaws uses state pattern seamlessly support different concurrency strategies synchronous asynchronous singleton pattern pattern ensures class instance provides global point access 
jaws uses singleton ensure copy cached virtual filesystem exists web server process 
contrast strategic patterns described earlier tactical pattern relatively localized impact software design 
instance singleton tactical pattern consolidate certain globally accessible resources web server 
pattern domain independent widely applicable problem addresses impact web server software architecture pervasively strategic patterns active object reactor 
thorough understanding tactical patterns essential implement highly flexible software resilient changes application requirements platform characteristics 
remainder section discusses structure jaws frameworks concurrency protocol pipelining file caching 
framework describe key design challenges outline range alternatives solution strategies 
explain jaws framework structured support configuration alternative strategy profiles 
concurrency strategies design challenges concurrency strategies impact design performance web system significantly 
empirical studies existing web servers including apache zeus netscape java web server indicate large portion non related web server overhead due web server concurrency strategy 
key overheads include synchronization thread process creation context switching 
choosing efficient concurrency strategy crucial achieve high performance 
alternative solution strategies selecting right concurrency strategy nontrivial 
factors influencing decision static dynamic 
static factors determined priori 
factors include hardware configuration number processors amount memory speed network connection os platform availability threads asynchronous web server case database interfacing image server html server 
dynamic factors detectable measurable conditions occur execution system 
factors include machine load number simultaneous requests dynamic memory server workload 
existing web servers wide range concurrency strategies reflecting numerous factors involved 
strategies include single threaded concurrency process concurrency apache zeus multi threaded concurrency jaws 
strategy offers positive negative benefits analyzed evaluated context static dynamic factors 
tradeoffs summarized 
thread request model handles request client separate thread control 
request arrives new thread created process request 
design allows thread understood synchronous mechanisms read write requested file 
illustrates model context jaws framework 
acceptor thread iterates waiting connection creating protocol handler spawning new thread handler continue processing connection 
advantage thread request simplicity ability exploit parallelism multi processor platforms 
chief drawback lack scalability number running threads may grow bound exhausting available memory cpu resources 
thread request adequate lightly loaded servers low latency 
may unsuitable servers accessed frequently perform time consuming tasks 
task thread request acceptor event dispatcher protocol handler spawns create notifies protocol handler protocol handler protocol handler thread request strategy jaws thread session session series requests client server 
thread session requests submitted connection client separate thread web server process 
model amortizes thread creation connection establishment costs multiple requests 
thread session resource intensive request spawn separate thread request 
vulnerable unbounded resource consumption number clients grows 
thread session requires client server support concept re established connection multiple requests 
example web client web server compliant thread session 
client server supports thread session degrades thread request 
thread pool model group threads web server initialization 
thread pool retrieves task job queue 
thread processing job removed pool 
finishing task thread returned pool 
illustrated job retrieved completion acceptor 
completes thread creates protocol handler lends thread control handler process connection 
thread pool lower overhead thread request cost thread creation amortized 
number resources pool consume bounded pool size fixed 
pool small depleted 
causes new incoming requests dropped wait indefinitely 
furthermore pool large resource consumption may better thread request 
protocol handler protocol handler protocol handler complete create protocol handler event dispatcher thread pool notifies acceptor task thread pool strategy jaws single threaded model connections requests handled thread control 
simple implementations single threaded servers process requests iteratively 
usually inadequate high volume produc tion servers subsequent requests blocked reached creating unacceptable delays 
sophisticated single threaded implementations attempt process multiple requests concurrently asynchronous reactive described section 
single threaded concurrency strategies perform better multi threaded solutions uni processor machines support asynchronous 
jaws framework orthogonal concurrency framework consider single threaded concurrency strategy special case thread pool pool size 
experiments demonstrate choice concurrency event dispatching strategies significantly affect performance web servers experience varying load conditions 
particular single server strategy provides optimal performance cases 
server framework provide degrees freedom 
static adaptivity framework allow web server developers select concurrency strategy best meets static requirements system 
example multi processor machine may suited multi threaded concurrency uni processor machine 

dynamic adaptivity framework allow concurrency strategy adapt dynamically current server conditions achieve optimal performance presence dynamic server load conditions 
instance order accommodate unanticipated load usage may necessary increase number available threads thread pool 
jaws concurrency strategy framework discussed single concurrency strategy performs optimally conditions 
platforms effective available concurrency strategies 
address issues jaws concurrency strategy framework supports static dynamic adaptivity respect concurrency event dispatching strategies 
illustrates oo design jaws concurrency strategy framework 
event dispatcher concurrency objects interact state pattern 
illustrated server changed connection thread pool successive calls server dispatch allowing different concurrency mechanisms take effect 
thread connection strategy abstraction thread request thread session strategies discussed 
concurrency mechanism task 
depending choice concurrency task may represent single active acceptor accept event dispatcher dispatch server server dispatch concurrency dispatch task thread pool dispatch dispatch thread connection task activate task accept task handler acceptor accept acceptor open protocol handler task accept activate deque svc structure concurrency strategy framework object collection active objects 
behavior concurrency object follows acceptor pattern 
architecture enables server developer integrate alternate concurrency strategies 
aid strategy profile server dynamically choose different strategies run time achieve optimal performance 
strategies design challenges key challenge web server developers devise efficient data retrieval delivery strategies collectively referred issues surrounding efficient quite challenging 
system developer resolve arrange multiple operations utilize concurrency available hardware software platform 
instance high performance web server simultaneously transfer files network concurrently parsing newly obtained incoming requests clients 
certain types operations different requirements 
example web transaction involving monetary fund transfer may need run synchronously conclude user continue 
conversely web accesses static information cgi search engine queries may run asynchronously cancelled time 
resolving various requirements led different strategies performing alternative solution strategies indicated various factors influence strategy choose 
web servers designed different strategies including synchronous reactive asynchronous relative benefits strategies discussed 
synchronous strategy synchronous describes model interaction web server process kernel 
model kernel return thread control server requested operation completes completes partially fails 
shows synchronous usually performs small file transfers windows nt high speed atm networks 
synchronous known unix server programmers arguably easiest 
disadvantages model 
combined singlethreaded concurrency strategy possible perform multiple synchronous operations simultaneously 
second multiple threads processes possible request block indefinitely 
finite resources socket handles file descriptors may exhausted making server unresponsive 
reactive strategy early versions unix provided synchronous exclusively 
system unix introduced non blocking avoid blocking problem 
non blocking requires web server poll kernel discover input available 
reactive alleviates blocking problems synchronous resorting polling 
model web server uses os event demultiplexing system call select unix win determine socket handles perform call returns server perform returned handles server reacts multiple events occurring separate handles 
reactive widely event driven applications windows codified reactor design pattern 
reactive carefully encapsulated technique error prone due complexity managing multiple handles 
reactive may effective multiple cpus 
asynchronous strategy asynchronous simplifies de multiplexing multiple events threads control blocking web server 
web server initiates operation kernel runs operation asynchronously completion server processes requests 
instance transmitfile operation windows nt transfer entire file server client asynchronously 
advantage asynchronous web server need block requests complete asynchronously 
allows server scale efficiently operations high latency large file transfers 
disadvantage asynchronous available os platforms particularly unix 
addition writing asynchronous programs complicated writing synchronous programs 
jaws strategy framework empirical studies systematically subjected different server strategies various load conditions 
results reveal strategy behaves differently different load conditions 
furthermore single strategy performed optimally load conditions 
jaws strategy framework addresses issue allowing strategy adapt dynamically run time server conditions 
furthermore new os provides custom mechanism asynchronous scatter gather potentially provide better performance jaws strategy framework easily adapted 
send file fh proactor io send file index html send file fh reactor write fh synchronous io receive file receive data send data send file asynchronous io send data receive file receive data send file proactor reactive io receive file send data receive data send file reactor inputoutput handler io error complete receive file send data send file receive data inputoutput fh receive file send data receive data send file io perform request svc handle structure strategy framework illustrates structure strategy framework provided jaws 
perform request filter derives protocol pipeline explained section 
example perform request issues request inputoutput handler 
inputoutput handler delegates requests inputoutput object 
jaws framework provides synchronous asynchronous reactive io component implementations derived inputoutput 
strategy issues requests appropriate mechanism 
instance synchronous io component utilizes traditional blocking read write system calls asynchronous io performs requests proactor pattern reactive io utilizes reactor pattern 
inputoutput component created respect stream associated acceptor task component described section 
file operations performed respect handle component described section 
example send file operation sends file represented handle stream returned acceptor 
protocol pipeline strategies design challenges early web servers ncsa original httpd performed little file processing 
simply retrieved requested file transfered contents requester 
modern web servers perform data processing file retrieval 
instance protocol determine various file characteristics file type text image audio video file encoding compression types file size date modification 
information returned requesters header 
cgi web servers able perform wider variety tasks 
include search engines map generation interfacing database systems secure commercial financial transactions 
limitation cgi server spawn new process extend server functionality 
typical request requiring cgi spawn process handle causing server behave process request server performance inhibitor 
challenge highperformance web server framework allow developers extend server functionality resorting cgi processes 
alternative solution strategies web servers conceptually process transform stream data stages 
example stages processing request organized sequence tasks 
tasks involve reading request parsing request parsing request header information performing request logging request 
sequence forms pipeline tasks manipulate incoming request shown 
tasks performed process requests fixed structure 
illustrates static pipeline configuration 
static configurations useful server extensions requested perform limited number processing operations 
operations relatively known priori pre fabricated directly execution server 
examples static processing operations include marshalling data data demultiplexing custom web protocol layers parse request parse headers perform request log request connection user agent host accept accept accept keep alive net image gif image jpeg date thu oct gmt server jaws content length content type text html homepage welcome 
ok modified wed oct 
get home html connection keep alive user agent host net accept image gif image jpeg net oct get home html get users public html home html read request pipeline tasks perform requests compiling applet code 
incorporating static pipelines server possible extend server functionality resorting spawning external processes 
apache web server provides type extensibility allowing modules encapsulate static processing dynamically linked web server 
situations may arise require pipeline operations configured dynamically 
occur web server extensions involve arbitrary processing pipeline configurations number essentially unlimited 
happen large number intermediary pipeline components arranged arbitrary sequences 
operations data known execution program dynamic construction pipeline components provides economical solution 
examples dynamic pipelines may useful including advanced search engines search engines may construct data filters dynamically depending provided query string 
instance query performance requesting web pages containing word performance word implemented pipeline positive match component coupled negative match component 
image servers image servers may construct filters dynamically depending operations requested user 
example user may request image cropped scaled rotated dithered 
adaptive web content web content dynamically delivered dependent characteristics user 
example personal digital assistant pda receive web content overviews smaller images workstation receive full multimedia enriched pages 
likewise home computer user may choose block certain types content 
existing solutions allow server developers enhance web server functionality dynamically application specific generic 
example netscape focuses entirely integrating web servers existing database applications 
conversely java web servers sun java server jigsaw allow arbitrary server extensibility java applications capable dynamically executing arbitrary java code 
problem provide dynamically configurable pipeline operations left resolved server developers 
developers left custom engineer solutions benefits application framework design patterns 
structuring server process data logical stages known pipes filters pattern 
pattern helps developers recognize organize components processing pipeline provide framework doing 
task adapting custom server efficiently adopt new protocol features may costly difficult result high maintenance code 
jaws protocol pipeline strategy framework preceding discussion motivated need developers extend server functionality resorting external processes 
described pipes filters pattern applied create static dynamic information processing pipelines 
jaws protocol pipeline framework designed simplify effort required program pipelines 
accomplished providing task skeletons pipeline components 
developer completes pipeline component logic component composed components create pipeline 
completed components stored repository accessible server running 
enables server framework dynamically create pipelines necessary web server executes 
provides illustration structure framework 
depicts protocol handler utilizes protocol pipeline process incoming requests 
filter component derives protocol pipeline serves task skeleton pipeline component 
pipeline implementors derive filter create pipeline components 
svc method pipeline component log filter svc perform filter svc parse request svc parse filter svc parse log request svc log perform request svc perform parse headers svc parse io receive data filter svc component svc read request svc pipe component io protocol pipeline svc inputoutput handler protocol handler structure protocol pipeline framework calls parent svc retrieves data processed performs component specific logic data 
parent invokes svc method preceding component 
composition components causes chain calls pulling data pipeline 
chain ends component responsible retrieving raw input derives directly protocol pipeline abstraction 
file caching strategies design challenges results show accessing filesystem significant source overhead web servers 
distributed applications benefit caching web servers exception 
surprising research web server performance focuses file caching achieve better performance 
cache storage medium provides efficient retrieval medium desired information normally located 
case web server cache resides server main memory 
memory limited resource files reside cache temporarily 
issues surrounding optimal cache performance driven quantity information stored cache duration long information stay cache 
alternative solution strategies quantity duration strongly influenced size allocated cache 
memory scarce may undesirable cache large files caching smaller files give better average performance 
memory available caching larger files may feasible 
lru caching cache replacement strategy assumes requests cached files temporal locality requested file soon requested 
act inserting new file cached requires removal file file removed 
strategy relevant web systems serve content temporal properties daily news reports stock quotes 
frequently lfu caching cache replacement strategy assumes files requested frequently requested form temporal locality 
cache files frequently replaced cache 
strategy relevant web systems relatively static content lexis nexis databases historical fact 
hinted caching form caching proposed 
strategy stems analysis web page retrieval patterns indicate web pages spatial locality 
user browsing web page browse links page 
hinted caching related pre fetching suggests protocol altered allow statistical information links hints sent back requester 
modification allows client decide pages pre fetch 
statistical information allow server determine pages pre cache 
structured caching refers caches knowledge data cached 
html pages structured caching refers storing cached files support hierarchical browsing single web page 
cache takes advantage structure web page determine relevant portions transmitted client top level view page 
potentially speed web access clients limited bandwidth main memory pdas 
structured caching related tree structures databases minimize number disk accesses required retrieve data query 
jaws cached virtual filesystem framework solutions described strategies implementing file cache 
employing fixed caching strategy provide optimal performance 
jaws cached virtual filesystem framework addresses issue ways 
allows cache replacement algorithms cache strategy easily integrated framework 
furthermore utilizing strategy profiles algorithms strategies dynamically selected order optimize performance changing server load conditions 
illustrates components jaws collaborate cached virtual filesystem open file fo fh open file lru strategy insert lfu strategy insert replace replace frequently ht find fetch remove create finish rw lock cache strategy insert inputoutput receive file send file filename fh handle handle name size open fo cache handle name size object hashtable structure cached virtual filesystem 
inputoutput object instantiates handle file interactions reading writing conducted 
handle object managed component 
object maintains information shared handles base address memory mapped file 
component heart cached virtual filesystem framework 
manages objects hashing follows state pattern choosing cache strategy fulfill file request 
cache strategy component utilizes strategy pattern allow different cache replacement algorithms lru lfu interchangeable 
jaws framework revisited section motivated need frameworks patterns build high performance web servers 
jaws example frameworks patterns enable programmers avoid common pitfalls developing web server software 
patterns frameworks support reuse integrated components design abstractions 
section described jaws framework architected strategies provides 
articulate organization jaws design outlined strategic tactical design patterns largest impact jaws framework 
acceptor reactor proactor active object service configurator patterns significant strategic patterns 
strategy adapter state singleton patterns influential tactical patterns jaws 
patterns chosen provide scaffolding jaws architecture 
patterns described necessary collaborating entities took form smaller components 
major components framework concurrency strategy io strategy protocol pipeline cached virtual filesystem frameworks constructed integrated skeleton application 
developers skeleton construct specialized web server software systems customizing certain sub components framework filters cache strategies 
shows patterns components jaws framework integrated 
jaws framework promotes construction high performance web servers ways 
provides pre configured concurrency dispatching models file cache offering standard cache replacement strategies framework implementing protocol pipelines 
second patterns jaws framework help decouple web server strategies implementation details configuration time 
decoupling enables new strategies integrated easily jaws 
jaws designed allow server alter behavior statically dynamically 
instance appropriate strategy profile jaws accommodate different conditions may occur run time execution web server 
applying extensible strategies components dynamic adaptation jaws simplifies development configuration high performance web servers 
web server benchmarking testbed empirical results section described patterns framework components enable jaws adapt statically dynamically environment 
flexibility beneficial success web server ultimately depends meets performance demands internet corporate intranets 
satisfying demands requires thorough understanding key factors affect web server performance 
section describes performance results obtained systematically applying different load conditions different configurations jaws 
results illustrate single configuration performs optimally load conditions 
demonstrates need flexible frameworks jaws reconfigured achieve optimal performance changing load conditions 
hardware testbed hardware testbed shown 
testbed start request lifecycle atm switch pro plus pro plus requests web client web server benchmarking testbed overview sists micron pro plus workstations 
pro mb ram equipped processors 
client machine clock speed mhz server machine runs mhz 
addition pro eni mf atm card efficient networks driven orca driver software 
workstations connected atm network running fore systems asx bx maximum bandwidth mbps 
due limitations lan emulation mode peak bandwidth testbed approximately mbps 
software request generator webstone benchmarking software collect client server side metrics 
metrics included average server throughput average client latency 
webstone standard benchmarking utility capable generating load requests simulate typical web server file access patterns 
experiments webstone generate loads gather statistics particular file sizes order determine impacts different concurrency event dispatching strategies 
file access pattern tests shown table 
table represents actual load conditions popular servers study file access patterns conducted protocol handler acceptor filter event dispatcher parse headers concurrency task protocol pipeline service configurator log request state adapter adapter perform request inputoutput inputoutput handler parse request state handle pipes filters service configurator active object acceptor service configurator strategy singleton reactor service configurator memento proactor strategy framework concurrency strategy framework protocol pipeline strategy framework cached virtual filesystem framework thread connection thread pool read request object lru strategy lfu strategy hashtable cache strategy synchronous io asynchronous io reactive io jaws web server framework document size frequency bytes kbytes kbytes mbytes table file access patterns spec 
experimental results results compare performance different adaptations jaws web server 
discuss effect different event dispatching models throughput latency 
experiment adaptations jaws 

synchronous thread request adaptation jaws configured spawn new thread handle incoming request utilize synchronous 
synchronous thread pool jaws configured pre spawn thread pool handle incoming requests utilizing synchronous 
asynchronous thread pool configuration jaws configured pre spawn thread pool handle incoming requests utilizing transmitfile asynchronous transmitfile custom win function sends file data network connection synchronously asynchronously 
throughput defined average number bits received second client 
high resolution timer throughput measurement started client benchmarking software sent request 
high resolution timer stops just connection closed client 
number bits received includes html headers sent server 
latency defined average amount delay milliseconds seen client time sends request time completely receives file 
measures long user wait sending get request web server content begins arrive client 
timer latency measurement started just client benchmarking software sends request stops just client finishes receiving requested file server 
graphs shown throughput latency represent different file sizes experiment bytes mbytes factors 
files sizes represent spectrum files sizes benchmarked experiments order discover impact file size performance 
throughput comparisons figures demonstrate variance throughput size requested file server hit rate ically increased 
expected throughput connection generally degrades connections second increases 
stems growing number simultaneous connections maintained decreases throughput connection 
shown throughput thread degrade rapidly smaller files connection load increases 
contrast throughput synchronous thread pool implementation degrade gracefully 
reason difference thread request incurs higher thread creation overhead new thread spawned get request 
contrast thread creation overhead thread pool strategy amortized pre spawning threads server begins execution 
results figures illustrate transmitfile performs extremely poorly small files kbytes 
experiments indicate performance transmitfile depends directly number simultaneous requests 
believe heavy server loads high hit rates transmitfile forced wait kernel services incoming requests 
creates high number simultaneous connections degrading server performance 
size file grows transmitfile rapidly outperforms synchronous dispatching models 
instance heavy loads mbyte file shown outperforms closest model nearly 
transmitfile optimized take advantage windows nt kernel features reducing number data copies context switches 
latency comparisons figures demonstrate variance latency performance size requested file server hit rate increase 
expected connections second increases latency generally increases 
reflects additional load placed server reduces ability service new client requests 
transmitfile performs extremely poorly small files 
file size grows latency rapidly improves relative synchronous dispatching light loads 
summary benchmark results illustrated results section significant variance throughput latency depending concurrency event dispatching mechanisms 
small files synchronous thread pool strategy provides better performance 
moderate loads synchronous event dispatching model provides slightly better latency asynchronous model 
heavy loads large file transfers asynchronous model transmitfile provides better quality service 
windows nt optimal web server adapt event dispatching file model depending server workload distribution file requests 
concurrent clients thread request thread pool transmitfile concurrent clients thread request thread pool transmitfile experiment results byte file concurrent clients thread request thread pool transmitfile concurrent clients thread request thread pool transmitfile experiment results file concurrent clients thread request thread pool transmitfile concurrent clients thread request thread pool transmitfile experiment results file concurrent clients thread request thread pool transmitfile concurrent clients thread request thread pool transmitfile experiment results file concurrent clients thread request thread pool transmitfile concurrent clients thread request thread pool transmitfile experiment results file summary techniques optimizing web servers research possible improve server performance superior server design similar observation 
undeniable hard coded server uses fixed concurrency caching strategies provide excellent performance flexible server framework jaws necessarily correlate poor performance 
section summarizes significant determinants web server performance 
observations studies existing web server designs implementation strategies experience tuning jaws 
studies reveal primary targets optimizations develop high performance web servers 
lightweight concurrency process concurrency mechanisms yield poor performance seen 
multi processor systems process concurrency mechanism perform especially number processes equal number processors 
case processor run web server process context switching overhead minimized 
general processes pre forked avoid overhead dynamic process creation 
preferable lightweight concurrency mechanisms posix threads minimize context switching overhead 
processes dynamic thread creation overhead avoided pre spawning threads pool server start 
specialized os features times os vendors provide specialized programming interfaces may give better performance 
example windows nt provides transmitfile function uses windows nt virtual memory cache manager retrieve file data 
transmitfile allows data prepended appended file data respectively 
particularly suited web servers typically send header data requested file 
data client sent single system call minimizes mode switching overhead 
usually interfaces benchmarked carefully standard apis understand conditions special interface give better performance 
case transmitfile empirical data indicate asynchronous form transmitfile efficient mechanism transferring large files sockets windows nt shown section 
request lifecycle system call overhead request lifecycle web server defined sequence instructions executed server receives request client sends requested file 
time taken execute request lifecycle directly impacts latency observed clients 
important minimize system call overhead processing path 
describes various places web servers overhead reduced 
ffl reducing synchronization dealing concurrency synchronization needed serialize access shared resources cached virtual filesystem synchronization penalizes performance 
important minimize number locks acquired released request lifecycle 
shown servers average lower number lock operations request perform better servers perform high number lock operations 
cases acquiring releasing locks result preemption 
thread reads request attempts acquire lock preempted may wait relatively long time dispatched 
increases latency incurred web client 
ffl caching files web server perform file caching sources overhead incurred 
overhead open system call 
second accumulated overhead iterative read write system calls access filesystem file small retrieved saved single call 
caching effectively performed memory mapped files available forms unix windows nt 
ffl gather write unix systems system call allows multiple buffers written device single system call 
useful web servers typical server response contains number header lines addition requested file 
gather write header lines need concatenated single buffer sent avoiding unnecessary data copying 
ffl pre computing responses typical requests result server sending back header contains success code mime type file requested text plain 
responses part expected case pre computed 
file enters cache corresponding response stored file 
request arrives header directly available cache 
logging overhead web servers support features allow administrators log number hits various pages serve 
logging done estimate load server various times day 
commonly performed commercial reasons web sites base advertising rates page hit frequencies 
logging requests produces significant overhead reasons ffl filesystem access heavily loaded web server significant number calls stresses filesystem underlying hardware 
writing data log files increases stress contributes lower performance 
keeping log files files separate filesystems possible separate physical devices limit overhead 
ffl synchronization overhead typical web server multiple active threads processes serving requests 
threads processes required log requests common shared log file access log file needs synchronized thread process write shared log file time 
synchronization introduces additional overhead detrimental performance 
overhead reduced keeping multiple independent log files 
memory buffers stored storage eliminate locking contention 
ffl reverse hostname lookups ip address client available web server locally 
hostname typically useful information log file 
ip address client needs converted corresponding host name 
typically done reverse dns lookups 
lookups involve network costly 
avoided completed asynchronously threads asynchronous 
ffl ident lookups ident protocol allows web server obtain user name connection 
typically involves setting new tcp ip connection user machine involves round trip delay 
ident lookup performed connection active performed lazily 
achieve high performance lookups avoided possible 
transport layer optimizations transport layer options configured improve web server performance high speed networks ffl listen backlog tcp implementations buffer incoming connections kernel resident listen queue servers dequeue servicing accept 
tcp listen queue exceeds backlog parameter listen call new connections refused tcp 
volume incoming connections expected high capacity kernel queue increased giving higher backlog parameter may require modifications os kernel 
ffl socket send buffers associated socket send buffer holds data sent server transmitted network 
high performance set highest permissible limit large buffers 
solaris limit 
ffl nagle algorithm rfc tcp ip implementations implement nagle algorithm avoid congestion 
result data getting delayed network layer sent network 
applications windows disable algorithm solaris supports tcp delay socket option disabling algorithm improve latency forcing network layer send packets soon possible 
concluding remarks computing power network bandwidth increased dramatically past decade complexity involved developing communication software 
particular design implementation high performance web server software expensive error prone 
cost effort stems continual rediscovery fundamental design patterns framework components 
growing heterogeneity hardware architectures diversity os network platforms hard build correct portable efficient web servers scratch 
building high performance web server requires understanding performance impact subsystem server concurrency event dispatching server request processing filesystem access data transfer 
efficiently implementing integrating subsystems requires developers meet various design challenges navigate alternative solutions 
understanding tradeoffs alternatives essential providing optimal performance 
effort required develop ad hoc designs cost effective requirements inevitably change 
examples performance may prove inadequate additional functionality may required software may need ported different architecture 
object oriented application frameworks design patterns help reduce cost improve quality software leveraging proven software designs implementations produce reusable components customized meet new application requirements 
jaws framework described demonstrates development high performance web servers simplified unified 
key success jaws ability capture common communication software design patterns consolidate patterns flexible framework components efficiently encapsulate enhance low level os mechanisms concurrency event demultiplexing dynamic configuration file caching 
benchmarking results serve illustrate effectiveness frameworks develop high performance applications 
brings light flexible software performance 
source code documentation jaws available www cs wustl edu schmidt ace html 
hu pyarali schmidt measuring impact event dispatching concurrency models web server performance high speed networks proceedings nd global internet conference ieee november 
pyarali harrison schmidt design performance object oriented framework highperformance electronic medical imaging usenix computing systems vol 
november december 
hu schmidt principles developing measuring high performance web servers atm proceeedings infocom march april 
johnson frameworks patterns components communications acm vol 
oct 
gamma helm johnson vlissides design patterns elements reusable object oriented software 
reading ma addison wesley 
schmidt suda object oriented framework dynamically configuring extensible distributed communication systems iee bcs distributed systems engineering journal special issue configurable distributed systems vol 
pp 
december 
schmidt applying design patterns frameworks develop object oriented communication software handbook programming languages ed macmillan computer publishing 
schmidt family design patterns applicationlevel gateways theory practice object systems special issue patterns pattern languages vol 

harrison levine schmidt design performance real time corba event service proceedings oopsla atlanta ga acm october 
schmidt applying patterns develop extensible maintainable orb middleware communications acm appear 
mckusick bostic karels quarterman design implementation bsd operating system 
addison wesley 
information technology portable operating system interface posix part system application program interface api language 
stevens unix network programming second edition 
englewood cliffs nj prentice hall 
schmidt reactor object behavioral pattern concurrent event demultiplexing event handler dispatching pattern languages program design coplien schmidt eds pp 
reading ma addisonwesley 
schmidt active object object behavioral pattern concurrent programming pattern languages program design coplien vlissides eds reading ma addison wesley 
schmidt experience design patterns develop object oriented communication software communications acm special issue object oriented experiences vol 
october 
stepanov lee standard template library tech 
rep hpl hewlett packard laboratories april 
schmidt ace object oriented framework developing distributed applications proceedings th usenix technical conference cambridge massachusetts usenix association april 
schmidt acceptor connector design patterns initializing communication services pattern languages program design martin buschmann riehle eds reading ma addison wesley :10.1.1.40.8396
jain schmidt service configurator pattern dynamic configuration services proceedings rd conference object oriented technologies systems usenix june 
harrison pyarali schmidt jordan proactor object behavioral pattern dispatching asynchronous event handlers th pattern languages programming conference washington university technical report wucs september 
pyarali harrison schmidt asynchronous completion token object behavioral pattern efficient asynchronous event handling pattern languages program design martin buschmann riehle eds reading ma addison wesley :10.1.1.41.1032
buschmann meunier rohnert stal pattern oriented software architecture system patterns 
wiley sons 
schmidt perfect hash function generator proceedings nd conference san francisco california pp 
usenix april 
jain schmidt service configurator pattern dynamic configuration reconfiguration communication services rd pattern languages programming conference washington university technical report wucs february 
berners lee fielding frystyk hypertext transfer protocol informational rfc network working group may 
available www org 
fielding gettys mogul frystyk berners lee hypertext transfer protocol standards track rfc network working group january 
available www org 
schmidt cranor half sync half async architectural pattern efficient structured concurrent pattern languages program design coplien vlissides eds reading ma addison wesley 
mogul hinted caching web proceedings seventh sigops european workshop systems support worldwide applications 
williams abrams abdulla fox removal policies network caches world wide web documents proceedings sigcomm stanford ca pp 
acm august 
markatos main memory caching web documents proceedings fifth international world wide web conference may 
gene trent mark sake webstone generation server benchmarking 
silicon graphics whitepaper february 
available www sgi com 
carlton explanation specweb benchmark 
standard performance evaluation whitepaper 
available www org 
nielsen gettys baird smith prud hommeaux lie lilley network performance effects css png appear proceedings acm sigcomm 
johns identification protocol network information center rfc feb 

