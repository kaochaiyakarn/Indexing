monads effects nick benton john hughes eugenio moggi september tension language design simple semantics hand rich possibilities side effects exception handling 
monads large step reconciling alternatives 
proposed moggi way structuring semantic descriptions adopted wadler structure haskell programs offer general technique delimiting scope effects reconciling referential transparency imperative operations programming language 
monads solve long standing problems adding pointers assignment inter language working exception handling haskell compromising purely functional semantics 
course introduce monads effects related notions exemplify applications programming haskell compilation mlj 
course typed metalanguages monads related categorical notions describe refined introducing effects 
contents monads computational types monads related notions 
metalanguages computational types syntactic sugar alternative presentations 
categorical definitions metalanguage 
metalanguages denotational semantics computational types structuring 
cbn translation haskell 
algol translation 
cbv translation sml 
incremental approach monad transformers 
monad transformer se adding side effects 
monad transformer ex adding exceptions 
monad transformer adding complexity 
monad transformer con adding continuations 
monads haskell implementing monads haskell 
monad class overloading return bind 
applying monads input output killer application 
imperative algorithms 
domain specific embedded languages 
monad transformers haskell monads dsls discussion 
exercises monads easy exercises 
moderate exercises 
difficult exercises 
intermediate languages compilation compilation transformation 
intermediate languages 
typed intermediate languages 
ml compiler intermediate language 
type effect systems 
basic idea 
precise effect systems 
subtyping 
effect polymorphism 
regions 
monads effect systems 
mil lite monads mlj 
types terms 
analysis 
operational semantics 
transforming mil lite 
semantics effects 
effect independent equivalences 
effect dependent equivalences 
effect masking monadic encapsulation 
curry howard correspondence monads monads computational types monads called triples considered category theory ct relatively late late 
monads comonads dual monads closely related adjunctions probably pervasive notion ct connection monads adjunctions established independently kleisli eilenberg moore sixties 
monads adjunctions arise contexts algebraic theories 
ct monads man bw bor 
surprising monads arise applications ct computer science cs 
monads giving denotational semantics programming languages specifically way modeling computational types mog 
interpret programming language category distinguish object values type object ta computations type take denotations programs type elements ta 
particular identify type object values type obtain object computations type applying unary type constructor call notion computation abstracts away type values computations may produce 
example give notions computation category sets 
ffl partiality ta 
diverging computation ffl nondeterminism ta fin set finite subsets ffl side effects ta thetas set states set stores set input output sequences ffl exceptions ta set exceptions ffl continuations ta set results ffl interactive input ta set characters 
explicitly ta set branching trees finite branches labelled leaves ffl interactive output ta thetax thetaa iso 
examples category cpos denotational semantics various programming languages examples instances single sorted algebraic theory th ta jt th carrier free th algebra th consider combinations examples ffl ta thetas ta thetas capture imperative programs exceptions ffl ta fin act thetax captures parallel programs interacting set act actions fact ta set finite synchronization trees strong bisimulation ffl ta fin thetas captures parallel imperative programs shared memory 
wad advocates similar idea mimic impure programs pure functional language 
haskell community gone long way exploiting approach reconcile advantages pure functional programming flexibility imperative styles programming 
analogies computational types effect systems gl observed wad formal relations established see wad 
denotation semantics programming languages informal notions modeled monads instance collection types database languages collection classes object oriented languages man 
important distinguish mathematical notion monad refinements informal notions computational collection types defined examples 
fact informal notions modeled better degree approximation considering monads additional properties additional structures 
considering refinements case natural requirement modeling computational types appropriate modeling collection types instance ffl natural programming languages express divergent computations generally support recursive definitions programs computational types come equipped constant ta divergent computation fix point combinator ta ta ta 
ffl natural collection finite number elements empty collection ta way merging collections binary operation ta ta ta 
equivalent definitions monad happens adjunctions 
man gives definitions monad triple called monoid form usually adopted ct books extension form intuitive clone form takes composition kleisli category basic 
consider triples monoid extension form 
notation assume knowledge basic notions category theory category functor natural transformation 
cases familiarity universal constructions products sums exponentials adjunction assumed 
notation ffl category write jcj set class objects hom set morphisms ffi composition id identity ffl means functor oe means oe natural transformation ffl oe means right adjoint left adjoint 
definition kleisli triple triple extension form kleisli triple category triple jcj jcj ja ta jcj ta tb tb equations hold ffl id ta ffl ja tb ffl tb tc 
kleisli triples intuitive justification terms computational types ffl ja inclusion values computations ja gamma 
ta ffl extension function values computations function computations computations evaluates computation applies resulting value gamma 
tb ta gamma 
tb order justify axioms kleisli triple introduce category morphisms correspond programs 
proceed analogy categorical semantics terms types interpreted objects terms type parameter free variable type interpreted morphisms denotation programs type supposed elements tb programs type parameter type ought interpreted morphisms codomain tb domain alternatives ta depending parameters type identified values computations type choose alternative entails second 
computations type values type ta 
take tb 
remains define composition identities show satisfy unit associativity axioms categories 
definition kleisli category kleisli triple kleisli category defined follows ffl objects ffl set morphisms tb ffl identity ja ta ffl followed tc 
natural take ja identity category maps parameter viewed computation 
similarly composition simple explanation terms intuitive meaning fact gamma 
tb gamma 
tc gamma 
tc followed parameter program evaluates program feed resulting value parameter point give simple justification axioms kleisli triples equivalent unit associativity axioms say category ffl tb ffl ja tb ffl tb tc td 
example go examples computational types example show part suitable kleisli triples 
ffl partiality ta ja inclusion 
tb ffl nondeterminism ta fin ja singleton map 
fag tb ta ff xjx cg ffl side effects ta thetas ja map 
tb ta ffl exceptions ta ja injection map 
inl tb inr inr inl ffl continuations ta ja map 
tb ta ffl interactive input ta ja maps tree consisting leaf labelled tb ta tree obtained replacing leaves labelled tree ffl interactive output ta thetax ja map 
ffl tb concatenation followed exercise define kleisli triples category cpos similar example ensure computational type ta element 
difficult cpos kleisli triple nondeterminism powerdomain construction 
exercise modeling programming language choice category 
instance impossible find monad category sets support recursive definitions programs category cpos similar categories 
aspects programming languages orthogonal computational types recursive polymorphic types models category sets categories cpos realizability models 
wants model level language notion static dynamic categories particularly appropriate ffl category ccc defined follows object pair jcj static dynamic part morphism pair thetaa static part result depends static part input 
ffl category fam ccc small limits defined follows object family ji set jcj morphism fam ji jj pair index family morphisms define kleisli triples categories fam similar example simpler assume category sets 
notice level language static dynamic computations don 
monads related notions section contains definitions facts essential subsequent developments 
establish equivalence kleisli triples monads 
definition monad triple monoid form monad triple functor id natural transformations diagrams commute ta ta ta oe ta id ta psi gamma gamma gamma gamma gamma id ta ta ta ta proposition bijection kleisli triples monads 
proof kleisli triple corresponding monad extension function endofunctor jb id ta conversely monad corresponding kleisli triple restriction functor objects tb 
definition eilenberg moore category monad category defined follows ffl objects algebras morphisms ff ta ta ja ta id ta ff ff ff ff called carrier algebra ff ffl morphism ff fi ff ta fi tb morphism ta tf tb ta ff fi identity composition adjunction oe induces monad kleisli categories prove converse monad induced adjunction 
kleisli category identified full sub category consisting free algebras 
proposition monad adjunctions oe oe induce full faithful functor phi phi proof action functors objects follows ff ta delta fa delta ta delta ta delta delta ta 
definition monad morphism monads monad morphism second natural transformation oe ja ta oe oe ta oe ta oe equivalent definition monad morphism terms kleisli triples family morphisms oe ta jcj ffl ja oe ffl oe oe oe tb write mon category monads monad morphisms 
general notion monad morphism require monads category 
monad morphisms allow view algebras algebras underlying carrier precisely proposition bijective correspondence monad morphisms oe functors proof action objects ff delta oe ff ta oe defined follows oe delta ta tj fil uses layering place monad morphism oe ta notions equivalent particular oe metalanguages computational types quite inconvenient directly specific category specific monad 
mathematical logic provides simple solution away specific models fix language define interpretation language model find formal system language capture desired properties models 
formal system sound forget models formal system 
formal system complete lost far concerned properties expressible language valid models 
formal systems proved sound complete certain class categories ffl sorted equational logic corresponds categories finite products ffl simply typed calculus corresponds cartesian closed categories ccc ffl intuitionistic higher order logic corresponds elementary toposes 
ensure soundness classes models formal systems cope possibility empty carriers 
mathematical logic assume carriers inhabited 
categorical logic branch ct devoted mainly establishing links formal systems classes categorical structures 
giving complete formal system say add computational types favorite formal system instance higher order calculus calculus dependent types logical framework 
assumption formal system include sorted equational logic rules systems linear calculus 
specifically assume formal system judgments ffl gamma gamma formed context ffl gamma type formed type context gamma ffl gamma formed term type context gamma ffl gamma oe prop oe formed proposition context gamma ffl gamma oe formed proposition oe context gamma true rules part formal system derivable ffl gamma type gamma dv gamma gamma gamma gamma ffl gamma gamma gamma prop says equation formed ffl weak gamma gamma oe gamma oe dv gamma sub gamma gamma oe gamma oe ffl gamma gamma gamma gamma gamma gamma gamma cong gamma oe prop gamma gamma oe gamma oe complex formal systems may require forms judgment equality types contexts sorts type line pure type systems 
categorical interpretation typed calculi including dependent types described pit jac 
rules adding computational types ffl gamma type gamma type lift gamma gamma gamma gamma gamma fv program computation simply returns value evaluates binds result evaluates calculi dependent types side condition fv rule automatically satisfied 
ignore side conditions 
ffl 
gamma gamma gamma rule expresses congruence binder 
ffl assoc gamma gamma gamma gamma rules says matters order evaluation parentheses 
ffl fi gamma gamma gamma gamma gamma rules say eliminate trivial computations form mog describes interpretation computational types simply typed calculus establishes soundness completeness results mog extends results logical systems including evaluation modalities proposed pitts 
interpreting computational types monads parameterized monads 
parameterization directly related form type dependency allowed typed calculus consideration 
need consider parametrized forms categorical notions understood fact categorical logic peculiarity computational types 
rule syntax semantics type type lift gamma gamma gamma gamma gamma gamma gamma gamma theta gamma id gamma gamma simple interpretation computational types sketch categorical interpretation category finite products simply typed metalanguage computational types see mog details 
general pattern interpreting simply typed calculus lawvere functorial semantics goes follows ffl context gamma type type interpreted objects abuse notation indicate objects gamma respectively ffl term gamma interpreted morphism gamma ffl formed equational gamma true iff gamma morphisms gives relevant clauses interpretation 
notice interpreting needs parameterized extension operation maps thetaa tb thetat tb 
syntactic sugar alternative presentations define convenient derived notation instance ffl iterated defined induction jej jxj follows delta delta haskell notation inspired monad comprehension see wad extends iterated allowing pattern matching local definitions higher order calculus type term constructors replaced constants ffl constant kind ffl ffl ffl kind types ffl replaced polymorphic constants unit ffl tx ffl ty tx ty unit delta ffl delta ffl ty tx way rule 
follows rule abstraction equational rules replaced equational axioms premises fi replaced ffl ty ty polymorphic constant unit corresponds natural transformation higher order calculus define polymorphic constants map ffl tx ty lat ffl tx corresponding action functor morphisms natural transformation ffl map delta ffl tx ffl lat delta ffl axiomatization primitive polymorphic constants unit amounts definition triple extension form envisage alternative axiomatization corresponding triple monoid form takes primitive polymorphic constants map unit lat categorical definitions metalanguage main point introducing metalanguage provide alternative directly models categories 
particular expect categorical notions related monads algebra monad morphisms reformulated axiomatically metalanguage computational types 
definition eilenberg moore algebras ff ta algebra iff ffl ff ffl ff ff ff algebra morphism ff ta fi tb iff ffl ta ff fi fx consider metalanguages computational types corresponding different monads category 
particular define monad morphisms metalanguage computational types definition monad morphisms polymorphic constant oe ffl monad morphism iff ffl ffl oe ffl ffl tx ty oe oe oe metalanguages denotational semantics translation language provides simple general way give semantics language terms available semantics second 
denotational semantics quite common define semantics programming language pl translating typed metalanguage ml 
idea old denotational semantics see sco main issue viable technique capable dealing complex programming languages 
specific metalanguages discuss main advantages semantics translation ffl reuse ml translating programming languages 
pl transl ml interp phi phi phi phi phi transl implicitly assuming defining translation pl ml simpler directly defining interpretation pl case worth putting effort study ml 
fact certain properties ml established reasoning principles computational adequacy usually easy transfer pl translation 
ffl choose ml certain criteria usually met programming languages metalanguage built orthogonal concepts simpler study contrary programming languages introduce syntactic sugar benefit programmers ml may equipped logic formalizing reasoning principles translating specification languages ml may chosen internal language class categories ccc specific semantic category category sets cpos 
ffl ml hiding details semantic categories see gor 
instance ml internal language class categories intended interpretation translation ml induce variety interpretations pl transl ml phi phi phi phi phi interp interp cn ml intended interpretation may difficult semantic category directly 
starting point metalanguage build top fairly standard typed calculus controversial issues ffl metalanguage equipped logic ranging equational logic higher order predicate logic 
ffl metalanguage programming language operational semantics 
discuss metalanguages computational types help structuring translation pl ml auxiliary notation see mos mog pl transl ml sigma transl ml incrementally defining auxiliary notation see cm mog lh fil pl transl ml sigma transl transl ml sigma transl ml solutions proposed closely related general techniques algebraic specifications datatype stepwise refinement hierarchical specifications 
computational types structuring typical problem denotational operational semantics programming language extended semantics may need extensively redefined 
instance extending pure functional language side effects exceptions redefine operational denotational semantics time considered different extension 
problem remains semantics translation typed lambda calculus keep redefining translation 
mos problem identified clearly stressed auxiliary notation may help making semantic definitions reusable 
mog identifies monads important structuring device denotational semantics operational semantics 
basic idea unary type constructor called notion computation terms type thought programs computes values type interpretation fixed varies computational features programming language consideration 
identifies operations specifying order evaluation basic properties common notions computation 
suggests translate programming language pl metalanguage ml sigma computational types signature sigma gives additional operations properties 
summary monadic approach denotational semantics consists steps programming language pl ffl identify suitable metalanguage ml sigma hides interpretation sigma interface hides implementation datatype ffl define translation pl ml sigma ffl construct model ml sigma translation metalanguage ml computational types 
suitable choice sigma find simple translation pl ml sigma usually redefined extended pl extended time keep translation ml sigma ml fairly manageable 
exemplify computational types consider programming languages viewed calculi constants define translations metalanguage ml sigma computational types suitable choice sigma indicate possible interpretation computational types sigma 
type int int theta thetat exp cbn translation haskell cbn translation haskell consider simple fragment haskell corresponding typed calculus ignore issues type inference terms explicit type information int type integers functional type theta product type variable numerals integer addition conditional local definition recursive definition abstraction application pairing projection type system haskell derives judgments form gamma saying term type typing context gamma 
denotational semantics interested interpreting wellformed terms programs rejected type checker allowed run want define translation mapping formed terms gamma pl programming language formed terms gamma ml metalanguage computational types 
precisely define translation induction types raw terms called cbn translation see 
fx ji mg pl formed term haskell show fx ji mg ml formed term metalanguage computational types 
signature sigma defining cbn translation haskell consists ffl ffl tx tx fix point combinator ffl signature datatype integers 
key feature cbn translation variables programming languages translated variables ranging computational types 
important feature translation types basically guides combination operational considerations translation terms 
exercise extend haskell polymorphism second order calculus ffl ffl problem extend cbn translation polymorphic types 
overcome problem assume computational types commutes polymorphism map iso ffl ffl ffl realizability models monads lifting satisfy property isomorphism identity 
algol translation cbn languages including algol pcf allow computational effects base types 
computational types play limited role structuring denotational semantics languages worth compare translation languages haskell 
consider idealized algol fixed set locations 
syntactically extension simple haskell base types loc integer locations int integer expressions cmd commands 
algol languages location identified pair consisting expression acceptor loc int int cmd 
type algol loc int cmd theta exp algol location contents location skip null assignment commands sequential composition commands algol translation see defined induction types raw terms fx ji mg pl formed term algol show fx ji mg ml formed term metalanguage computational types 
algol translation violate key principle translation program computational type 
algol valid programs expected terms base type algol translation maps base types computational types 
generally observe algol translation maps algol types carriers algebras 
algebras strong monads closed arbitrary products exponentials precisely thetaa carrier algebra carrier algebra exercise prove facts metalanguage 
algebra structure translation types defining translation terms extend fix point combinator computational types algebras ffl gamma gamma ff gamma delta ff ff type algol type loc int int cmd theta theta exp algol exp get skip set algol translation ffl gamma ff gamma delta ff ff ff algol translation suggests put emphasis algebras 
lev proposed metalanguage monads classes types value types interpreted objects computation types interpreted objects signature sigma defining algol translation consists ffl ffl tx tx haskell translation ffl signature datatype integers haskell translation ffl type loc locations fixed set constants loc operations get loc int set loc int get store integer location 
algol expressions commands different computational effects expressions read state commands modify state 
consider monads sr state reading computations se thetas computations side effects monad morphism sr se cbv translation sml consider simple fragment sml integer locations 
syntactically language minor variation idealized algol precisely cmd replaced unit skip sequential composition commands removed definable recursive definitions restricted functional types 
loc int unit theta type loc loc int int unit theta theta exp get set cbv translation sml cbv translation see defined induction types raw terms fx ji mg pl formed term sml show fx ji mg ml formed term metalanguage computational types 
signature sigma defining cbv translation defining algol translation 
exercise far said interpret metalanguages target various translations 
propose interpretations metalanguages category cpos choose monad interpreting computational types explain symbols signature sigma interpreted 
exercise translations considered far allow validate equational laws programming languages deriving translation equational laws metalanguage 
say fi functional types 
fv valid haskell algol sml 
valid suggest weaker equational laws validate 
exercise indicates careful transfer reasoning principle calculus functional languages 
exercise consider haskell integer locations extend cbn translation accordingly 
signature sigma 
exercise sml create new locations construct ref consider extension sml extend cbv translation accordingly 
signature sigma monad category cpos 
exercise consider sml locations type extend cbv translation accordingly 
signature sigma may find convenient assume metalanguage includes higher order calculus 
difficult find monads able interpret metalanguage 
incremental approach monad transformers monadic approach denotational semantics caveat 
programming language pl complex signature sigma identified monadic approach get fairly large translation ml sigma ml may quite complicated 
alleviate problem adopting incremental approach defining translation ml sigma ml 
basic idea adapt setting techniques modularization facilities advocated formal software development particular desired translation ml sigma ml corresponds implementation datatype language 
incremental approach desired implementation obtained sequence steps step constructs implementation complex datatype implementation simpler datatype 
haskell constructor classes extend sml modules provide convenient setting incremental approach see type inference mechanism allows concise readable definitions type checking detects errors 
missing ability express validate equational properties require extra features typical logical frameworks see mog 
approach viable need collection self contained parameterized polymorphic modules features ffl polymorphic signature sigma wide range signatures module take implementation sigma construct implementation sigma sigma new sigma new fixed ffl parametric construction signature sigma new may depend parameters fixed signature sigma par polymorphic requirement easily satisfied implement sigma new changing implementation sigma case software development 
constructions interested persistent involve re implementation computational types consequently sigma 
translations need consider form ml sigma par sigma sigma new ml sigma par sigma sigma new new symbols defined sigma old symbols redefined sigma par parameters construction unaffected 
general decomposed ffl translation new ml sigma par sigma new ml sigma par defining new symbols sigma new redefining computational types ffl translations op ml sigma op ml sigma par sigma op redefining old symbol op isolation consistently redefinition computational types possible type symbol may sigma 
fil proposed flexible approach uses metalanguages monads step introduces new monad new operations defined term pre existing ones changing meaning old symbols 
considering definitional extensions translations form ml sigma old sigma new ml sigma old identity ml sigma old 
filinski approach translations new op possible ad hoc definitions 
fact filinski introduces new monad introduces operations called monadic reflection reification reflect ffl reify ffl establish bijection implementation type pre existing language 
define operations related moving back forth implementation done case operations defined datatype 
semantically monad transformer function function mapping monads category monads 
interested monad transformers adding computational effects require monad monad morphism ft case functor mon natural transformation id mon syntactically monad transformer translation ml sigma par ml sigma par identity ml sigma par 
words express new monad terms old monad parameters specified sigma par 
sequel describe higher order calculus monad transformers corresponding addition new computational effect precisely define ffl new monad monad morphism ffl operations computations associated new computational effect ffl operation op ffl 
extending computations pre existing operation op ffl 
tx tx computations 
monad transformer se adding side effects ffl signature sigma par parameters states ffl ffl signature sigma new new operations lookup update upd ffl definition new monad monad morphism delta thetas delta delta delta definition new operations delta upd delta extension old operation op delta op thetas operations upd fit format op 
operation op tb define operation op ffl 
tx tx right format op delta op monad transformer ex adding exceptions ffl signature sigma par parameters exceptions ffl ffl signature sigma new new operations raise raise ffl handle handle ffl ffl definition new monad monad morphism delta delta inl delta case inr delta inl definition new operations raise delta inr handle delta case inl extension old operation op delta op case definition op particularly simple show definition works extending general type operations 
monad transformer adding complexity ffl signature sigma par parameters monoid ffl infix notation prove monad add axioms saying monoid ffl signature sigma new new operations cost tick ffl definition new monad monad morphism delta thetam delta delta delta definition new operations tick delta extension old operation op delta op thetam monad transformer con adding continuations ffl signature sigma par parameters results ffl ffl signature sigma new new operations abort abort ffl call cc callcc ffl ffl definition new monad monad morphism delta tr tr delta delta delta definition new operations abort delta callcc delta extension old operation op delta op operation callcc fit specified format old operation way massage format 
monad transformers con extend functor mon 
exercise monad transformer prove monad 
assume monad equational axioms higher order calculus sums products including axioms 
exercise monad transformer define fix point combinator new computational types ffl fix point combinator old computational types ffl tx tx cases derived fix point combinator carriers algebras 
exercise define monad transformer sr state readers delta tx sigma new define monad morphism sr se exercise check monad transformers commutes isomorphism 
instance se ex commute precisely gets ffl se ex thetas adding side effects exceptions ffl ex se thetas adding exceptions side effects exercise monad transformer identify equational laws new operations specified sigma new show laws validated translation 
instance se validates equations upd upd upd upd upd upd ffl monads haskell far focussed applications monads denotational semantics wadler influential papers early part toolkit haskell programmers day day basis 
monads proven useful practice language includes extensions specifically programming easy 
sections see monads represented haskell look applications try explain impact 
implementing monads haskell representation monads haskell kleisli triple formulation recall definition kleisli triple category triple jcj jcj ja ta jcj ta tb tb equations hold 
haskell corresponds parameterised type called return called 
suggest types return 



haskell type variables types polymorphic 
notice consider curried function arguments types 
practice convenient reverse arguments give type 


metalanguage notation conveniently expressed 

haskell notation 
intuitively binds result mind usually pronounce bind 
example monad partiality represented built haskell type data just defines parameterised type elements just element type representing successful computation representing failure 
monad operators implemented return just case just 

failure represented failure example application division function operates possibly failing integers defined divide int 
int 
int divide 

failure return div try unfolding calls definition understand gain clarity monadic operators brings 
example second example show implement monad side effects haskell 
time need define new type state represent computations producing side effect state type haskell provides ways define types type state 
newtype state state 
data state state 
alternative declares type synonym state respect equivalent type 

cause problems monads represented functions difficult tell just type monad talking 
second alternative declares state new type different isomorphic 

elements new type written state distinguish functions 
need tag elements name type convenient name 
third alternative declares state new type elements form state contrast newtype state constructor lazy state different values 
data declarations create lifted sum product types sum trivial lifted 
state isomorphic 
extra element values type costly manipulate result 
choose second alternative 
monad operations easy define return state 
state state 
state state manipulated state state 

state state 
monad class overloading return bind haskell programmers different monads awkward return different names 
avoid overloading names monad 
overloading haskell supported class system overloaded names introduced defining class containing 
class essentially signature different implementation type 
monad operations part class monad definition haskell standard prelude class monad return 



class parameter ranges parameterised types read declaration parameterised type monad supports implementations return types 
implementations operations provided making corresponding instance declaration example instance monad return just case just 

corresponds definition monad earlier 
monad side effects write instance monad state return state 
state state 
state notice defined type state parameters monad class requires type parameter haskell allows create type need partially applying state type parameter types parameters curried 
chose order parameters definition state mind 
monadic operators applied type determines implementation invoked 
careful state new type 
great advantage overloading monad operators enables write code works monad 
example define function combines monadic computations producing integers computation sum 

return definition specific particular monad function just just just state monad 
type assigned reflects monad 
int 
int 
int type inference produces general type arithmetic overloaded gloss 
monad called context restricts types may substituted specialised really useful derive useful higherorder function generalising 
haskell standard monad library provides number functions liftm monad 



liftm monad 





sequence monad 

programming monads greatly eased library 
exercise give definition sequence 
intention computation list executed turn list results 
haskell provides syntactic sugar monadic programs readable notation 
example definition equivalently written return notation defined 

applying rules definition rewrites form 
notation simply shorthand bind programs recognisable especially beginners 
example example monadic programming consider problem decorating leaves tree unique numbers 
shall parameterised tree type data tree leaf bin tree tree define function unique tree 
tree int numbers leaves upwards left right order 
example unique bin bin leaf leaf leaf bin bin leaf leaf leaf intuitively think integer state incremented time leaf encountered shall state monad define function unique tree 
state int tree int define function increment state tick state int int tick return definition unique straightforward unique leaf tick return leaf unique bin liftm bin unique unique notice liftm apply argument function bin results labelling subtrees result notational overhead monad small 
define unique invoke monadic function supply initial state unique unique state snd instructive rewrite unique function directly monad explicit state passing recursive definition significantly creates opportunities errors monadic code completely avoids 
applying monads far shown monads represented haskell language supports 
monads 
prevalent haskell programs 
section try answer questions 
input output killer application historically input output awkward handle purely functional languages 
applies foreign function calls way guarantee function written example side effects calling directly haskell program risk compromising haskell purely functional semantics 
clear input output modelled purely functional way just consider program function state universe run state universe 
possibility write program way function depending external state take universe parameter function modifying return new universe part result 
example program copy file written copy string 
string 
universe 
universe copy universe contents readfile universe universe contents universe universe program purely functional semantics easy implement 
course really maintain copies universe time functions implemented writing new contents filestore 
programmer accidentally deliberately returns universe universe final result program purely functional semantics correctly implemented 
approach followed clean linear type system guarantee programmer manipulates universes correctly bs 
having seen monads probably wish simplify program state monad manage universe 
defining type io state universe altering types primitives slightly readfile string 
io string string 
string 
io rewrite file copying program copy string 
string 
io copy contents readfile contents looks imperative program task program purely functional efficiently implementable quite safe write output file destructively 
risk programmer define inappropriate operations io type snapshot io universe snapshot state univ 
univ univ solution just io type jw 
change semantics programs remains purely functional guarantee long primitive operations io type treat universe proper single threaded way operations implemented imperative languages haskell program uses 
io monad introduced haskell possible write haskell programs input output call foreign functions directly purely functional semantics 
programs look ordinary programs imperative language 
previously needed achieve similar effects worthy description 
reader may wondering excitement possible write ordinary imperative programs languages long time including functional languages ml scheme special writing haskell 
things ffl input output combined cleanly features haskell particular higherorder functions polymorphism lazy evaluation 
ml example combines input output ability mix lazy evaluation cleanly unique haskell monads copy example shows lead simpler programs possible 
main difference read write entire contents file operation byte imperative program probably 
may wasteful space lazy evaluation characters input file read memory needed writing output 
space requirements small constant just byte byte imperative program 
ffl input output combined purely functional semantics 
ml example expression may potentially side effects transformations re order computations invalid effect analysis establish computations side effect free 
haskell expression side effects denote commands effects potential cause side effects evident expression type 
evaluation order changed freely monadic computations reordered monad laws permit 
imperative algorithms algorithms expressed purely functional style complexity imperative forms 
efficient algorithms depend critically destructive updates 
examples include union find algorithm graph algorithms implementation arrays constant time access modification 
monads haskell express algorithms complexity imperative language 
monads easy 
just io monad enables write programs purely functional semantics give imperative implementation state transformer monad st allows write purely functional programs update state destructively lj semantically type st isomorphic state 
state state function typed locations contents 
implementation state exists updated destructively place 
operations provided create read write typed 
st 
st 

st type containing value type operations provided create manipulate arrays 
reason introducing different monad st just providing operations io monad destructive updates variables program externally visible side effects 
encapsulate imperative effects new primitive runst st 
semantically creates new state runs argument discards final state returning result 
corresponding function implementable way discard final universe 
implementation runst states represented just collection stored heap cost involved creating new 
runst write pure non monadic functions implementation uses imperative features internally 
example depth search algorithm graphs uses destructively updated marks identify previously visited nodes avoid traversing 
simplicity represent graph nodes integers graphs type type graph array int int io monad part haskell current standard st monad 
implementation provides form description hugs modules st 
graph array indexed integers nodes elements list successors corresponding node 
record nodes visited updateable array boolean marks program depth search algorithm follows dfs ns runst marks bounds false dfs ns marks dfs marks return dfs ns marks visited marks visited dfs ns marks marks true ns dfs ns marks return ns function dfs returns list nodes reachable list roots depth order example dfs array type depth search function dfs graph 
int 
int pure non monadic function freely mixed non monadic code 
imperative features combine interestingly lazy evaluation 
example output list produced lazily traversal runs far produce elements demanded 
possible code return ns produce result ns known 
recursive call dfs need performed value ns needed efficiently dfs incomplete traversals search node satisfying example head filter dfs roots safe knowledge traversal node 
king launchbury shown lazy depth search function express wide variety graph algorithms elegantly efficiently kl 
st monad raises interesting typing issues 
note operations implemented haskell types inefficiently 
problem represent indexed collection values arbitrary types tried represent states functions contents example contents type 
purely functional implementation need dependent types allow type contents depend 
st monad gives haskell programmer indirect access dependent types applications require dependent types programmed terms st secondly prevent created state hard assign sensible meaning result 
done giving st type hugs provides variations st monad lazy behaviour 
programmer chooses importing st 
additional parameter may think state identifier st type computations state producing types parameterised state identifier types operations 
st 
st 

st types guarantee st computations manipulate lying state 
type runst 
supposed create new state run argument give type runst st 
applicable st computation including manipulate states 
prevent runst rank polymorphic type runst forall st 
hugs extended rank polymorphism just possible 
type ensures argument runst safely run state particular new runst creates 
example expression runst typed 
type st int runst produce result type int scope extend type result 
example expression runst return runst argument inner runst polymorphic depends state identifier outer 
inclusion st monad assignments haskell raises interesting question just purely functional language 
answer assignment funny type 
domain specific embedded languages early days functional programming combinator libraries define succinct notations programs particular domains bur 
combinator libraries different applications section shall focus studied area parsing 
library writing parsers typically defines type parser parsers values type combinators constructing invoking parsers 
include satisfy char 
bool 
parser char construct parser accepts single character satisfying predicate parser 
parser 
parser construct parser accepts input operands parse parser 
string 
invoke parser input 
parsing library include combinators run parsers sequence build parsers invoke functions compute results 
wadler realised provided declaring parser type monad wad 
combinators defined terms basic ones combinator accepting particular character literal char 
parser char literal satisfy combinator repetition parser 
parser liftm return parses list number ps 
library parsing programs written succinctly 
example function evaluate arithmetic expressions involving addition multiplication eval string 
int eval expr expr term literal expr return term term closed literal term return closed closed literal expr literal return numeral numeral ds satisfy return read ds choice combinators code parser closely resembles grammar parses years different view combinator libraries popular think defining domain specific language dsl constructions combinators library hud 
view little parsing library defines programming language special constructions accept symbol express alternatives 
time functional programmer designs combinator library say designs domain specific programming language integrated haskell 
useful perspective encourages programmers produce modular design clean separation semantics dsl program uses mixing combinators raw semantics willy 
monads appear programming language semantics hardly surprising appear combinator libraries 
return implementation parsing library section discussion monad transformers 
monad transformers haskell haskell programmer heavy combinators need implement large number monads 
perfectly possible define new type implement return scratch saves labour construct monads systematically possible 
monad transformers section offer attractive way doing liang hudak jones point 
recall definition monad transformer function function mapping monads category monads 
interested monad transformers adding computational effects require monad monad morphism ft represent monad transformers haskell types parameterised monad parameterised type result type types kind 
example partiality monad transformer represented type newtype maybet maybet definition maybet monad demonstrate implementing return instance monad 
monad maybet return maybet return just maybet maybet case 
return just 
maybet practice resemblance little close real parsers arithmetic expressions left recursive lexical analyser written avoid expensive backtracking 
hand real parsing libraries provide combinators handle features parsers succinct 
see hm description 
notice important haskell lazy evaluation recursive definitions sense 
definition monad transformer monad morphism maybet possible transform computations type 
need define monad morphisms different monad transformers haskell overloading introduce class monad transformers class monad monad 
lift 
monad transformer monad applied lift monad morphism maybet instance class instance monad 
maybet lift maybet return just purpose maybet transformer enable computations fail shall introduce operations cause handle failures 
expect types failure maybet handle maybet 
maybet 
maybet expect combine maybet monad transformers monad want apply operations may form long involves maybet transformer ought able 
overload operations define class monads class monad 
failure handle 

course monads form maybet instances class see 
case instance declaration instance monad 
maybet failure maybet return maybet handle maybet maybet case 
just 
return just need way run elements type 
define monad 
maybet 
maybet case just 
return step outside haskell multiple parameter class extension supported hugs implementations 
parameter class permit definition monad transformers place additional requirements argument monad 
usually standard haskell class monadplus operations mzero mplus case context names failure handle natural 
purpose 
leave undefined run erroneous computation converting explicitly represented error real haskell 
seen elements monad transformer haskell 
summarise ffl define type represent transformer say parameters monad 
ffl declare monad assumption ffl declare instance class defining computations lifted ffl define class trans monads containing operations purpose support 
ffl declare instance showing support 
ffl define function run computations producing computations result 
general may need additional parameters example state transformer probably want supply initial state 
carry program define monad transformers ffl state transformers represented newtype statet statet 
supporting operations class class monad 
statemonad 

ffl environment readers represented newtype envt envt 
supporting operations class class monad 
env 
env inenv env 

rdenv env rdenv reads current value environment inenv runs argument environment 
ffl continuations represented class declaration uses mark jones functional dependencies supported hugs declare type monad state determined type monad 
words monad different states different types 
strictly necessary making dependency explicit enables type checker infer type state helps avoid hard understand error messages ambiguous typings 
newtype contt ans contt 
ans 
ans supporting operations class class monad 
callcc 


callcc calls passing function called terminates call callcc immediately argument final result 
steps remain monad transformers practice 
firstly monad transformers transform monad define monad start 
start monad natural vanilla monad computational features identity monad newtype id id implementations return monad just add remove id tag 
secondly far instances class form maybet instances class statemonad form statet 
combine monads course expect features resulting monad 
example construct monad statet maybet id expect able failure handle type 
way give instance declarations define lift operations monad 
example lift failure handling state monads follows instance 
statet failure lift failure statet handle statet statet 
handle certainly requires instance declarations pair monad transformers unfortunately solution 
payoff need define monad construct quickly composing monad transformers automatically inherit collection useful operations 
example implement parsing library section combining state transformation failure 
shall parser state input parsed running parser consume part running parsers sequence parse successive parts input 
attempting run parser may succeed fail wish handle failures trying different parser 
define suitable monad type parser statet string maybet id computations run turns operator called earlier just handle satisfy simply defined satisfy 
bool 
parser satisfy case 
failure xs 
xs return failure 
monads dsls discussion clear monads successful programming imperative algorithms haskell offer really satisfactory solution 
widely adopted designers combinator libraries 

analogy combinator library domain specific language monads structure denotational semantics surprising combinator libraries 
mean 
designer combinator library choice need follow monadic path chosen 
overwhelming practical benefits flow monads combinator library design particular 
monads offer significant advantages key areas 
firstly offer design principle follow 
designer wants capture particular functionality library unsure exactly interface provide reasonably confident monadic interface choice 
monad interface tried tested know allows library user great flexibility 
contrast early parsing libraries example non monadic interfaces parsers awkward write 
secondly monads guide implementation library 
library designer choose appropriate type combinators task eased type monad 
monad types constructed systematically seen section parts library operate 
collection monad transformers substantial parts library come free just little left implement composing representation parsers monad transformers 
thirdly benefits libraries share part interfaces 
users learn new library quickly monadic part interface familiar 
common interface reasonable define generic monadic functions liftm monadic library 
helps users need learn liftm greatly eases task implementors find functionality want provide comes free course widespread monads haskell extended syntactic sugar support library completely separate interface impractical support special syntax 
taken compelling reasons library designer choose monads possible 
exercises monads section contains practical exercises intended solved hugs computer 
readers familiar haskell monads seeing time exercises divided different levels difficulty 
choose right 
hugs interpreter started command hugs flag informs hugs extensions haskell allowed needed exercises 
hugs started prompts command expression evaluate command lists commands available 
hugs placing definitions file loading file interpreter command typing expressions evaluate 
obtain information defined name command discover names scope followed regular expression matching names interested 
try type definitions response interpreter prompt understood 
easy exercises choose exercises previously unfamiliar monads haskell 
exercise write function dir io string returns list file names current directory 
obtain running ls placing output file read 
need import module system defines function system execute shell commands place import system line file 
string split constituent words standard function words print values testing standard function print 
exercise write function string 
string removes duplicate elements list strings intention return list strings argument order occurrence 
easy write inefficient version keeps list strings seen far hash table internally string input compared 
choice hash function particularly important exercise 
produce result list lazily 
test running interact lines echo line type occurrence 
need haskell lists written enclosing elements square brackets separated commas cons operator 
import module create hash table read write 
beware haskell layout rule insists expression column interprets appearing column start new expression 
exercise implementation maybet transformer implementations statet envt contt transformers sketched 
complete 
contt quite difficult want leave 
exercise define maybet type newtype maybet maybet defined newtype maybet maybet 
exercise defined type parsers type parser statet string maybet id combined state transformation failure way round 
type parser maybet statet string id define instance statemonad maybet investigate behaviour examples combining failure handling side effects monads 
difference behaviour 
moderate exercises choose exercises comfortable haskell seen monads 
exercise implement monad built st monad provides updateable typed supports failure failure handling 
fails handle variables values entering handler entered 
add operator commit property updates commit survive subsequent failure 
exercise different way handle failures type newtype ans 
ans 
ans 
ans 
ans similar monad continuations computations continuations take extra argument value return case failure 
failure occurs argument returned directly normal continuation invoked 
instance class monad define 
failure handling programs great deal space failure handlers retain data longer needed successful execution 
branch progressed sufficiently far know failure handler longer relevant 
example parsers usually combine parsers quite different constructions parser succeeds parsing tokens know second possibly succeed 
define operator cut ans discards failure handler memory occupies reclaimed 
cut parsing library 
difficult exercises give get teeth 
exercise implement domain specific language concurrent programming monad process typed channels chan operations chan process chan send chan 

process recv chan 
process create channels send receive messages synchronously fork process 
process start new concurrent task forall process 
run process 
analogy st monad state thread identifier guarantee channels created call 
need write type explicitly hugs infer rank types 
exercise prolog provides called logical variables values referred set 
define type lvar monad logic terms st supporting operations logic lvar lvar 
lvar 

logic state thread identifier 
intention lvar written exactly value may read creation write lazy evaluation 
note monadic type 
course value written lvar depend 
hint need 
st 
st solve exercise 
binds result produced computation 
exercise applications useful dump state program file send network program restarted state machine 
define monad operation dump stops execution converts representation state program form saved file 
result running computation indicate dumping occurred provide dumped state 
state dumped computation resume restart state represents 
note dump times execution able restart point 
need choose representation states include type value computation 
avoid typing problems convert values strings storage show 
able instance class monad implementations return sufficiently polymorphic values converted strings 
unfortunate just choose names purposes exercise 
intermediate languages compilation seen monads may structure denotational semantics languages implicit computational effects may express control computational effects languages haskell implicit effect possibility non termination 
turn monads practical compilation languages ml implicit side effects 
material refers mlj benton kennedy russell standard ml compiler intermediate language mil monadic intermediate language bk 
compilation transformation surprise ideas useful structuring semantics turn useful structuring internals compilers implementing rules deriving program sense compilers semantics 
absence sophisticated static analyses compilers functional languages typically translating user program intermediate form performing sequence rewrites intermediate representation translating lower level code backend 
rewrites intended preserve semantics observable behaviour user program whilst improving efficiency final program terms execution speed dynamic memory usage code size 
rewriting rules compiler observational equivalences applied locally independently surrounding context instances observational congruence relation 
course hard part compiler decide applying particular semantic equation improvement 
intermediate languages reasons having intermediate language just doing rewriting syntax tree source program include 
complexity 
source languages tend sophisticated syntactic forms nested patterns list comprehensions convenient programmer translated simpler core language leaving fewer cases optimizer code generator deal 

level 
optimizing transformations involve choices expressed source language lower level abstraction 
words involve distinctions implementation details source language 
example ffl functions ml take single argument want pass package single tuple 
simple elegant programmer don want compiled code pass pointer fresh heap allocated tuple just pass couple arguments stack registers 
mil intermediate languages ml includes tuples multiple arguments transforms instances 
ffl mil includes datastructures holes uninitialized values 
express transformation turns non tail calls tail calls linear typing rules prevent holes dereferenced filled min 
course levels abstraction source target languages common compilers different intermediate languages different phases 
notes shall concerned complexity realistic source languages expressing low level implementation details intermediate languages 
interested slightly nebulous idea intermediate language may uniform expressive explicit source 
important transformations involve concepts essentially lower level level abstraction source language impossible express implement directly source language syntax 
equational theory simplified core source language may messy ill suited optimization rewriting 
complex rewriting system conditional rewrites depending various kinds contextual information achieve result translating intermediate language better behaved equational theory 
typically case cleaner intermediate language explicit aspects behaviour implicit source language 
examples ffl intermediate languages introduce explicit names intermediate value 
names useful building various auxiliary datastructures easy example share subexpressions 
trivial case val don want simplify equivalent allocates identical pairs 
particularly way get better result allow eliminations applied variables atomic constants translation original program intermediate form val val rewrites val val encompassing intermediate datatype ensure input output phase satisfy particular additional constraints 
intermediate representations larger corresponding source 
val probably wanted 
ffl mil contains unusual exception handling construct sml handle construct unable express commuting conversion style rewrites wished perform bk 
ffl compilers higher order languages continuation passing style cps lambdacalculus intermediate language see example app kkr 
translations call value cbv call name cbn source languages cps 
program cps sound apply full unrestricted fi rules say restricted fi rules valid cbv lambda calculus 
plotkin shows seminal plo fi cps terms prove strictly equivalences translated terms fi corresponding terms 
compiler cbv language translates cps uses fij perform transformations just uses fi source syntax 
cps transformed terms evaluation order easier compile low level imperative code backend allow tail call elimination expressed naturally particularly natural language contains call cc sophisticated control operators 
flanagan argue compiling cbv lambda calculus cps unnecessarily complicated indirect technique 
translation introduces lots new abstractions new essentially trivial administrative redexes 
generate code identify administrative redexes real cps compilers treat abstractions introduced translation process differently originating original program effectively undo cps translation backend having performed transformations 
show effect obtained calculus reductions reach normal form 
reductions introduced sf defined terms evaluation contexts 
things normal forms name intermediate values apply eliminations variables values 
example reduction gamma 
delta evaluation context 
flanagan observe non cps direct style compilers perform reductions ad hoc manner suggest doing working normal forms uniform leads faster code 
typed intermediate languages big decision designing intermediate language typed 
source language strong static types compilers discard types checked untyped intermediate language 
typed intermediate languages popular compilers fashionable area mobile code security 
examples typed compiler intermediate languages include flint sha ghc intermediate language jon mil 
advantages keeping type information intermediate language include ffl types increasingly basis static analyses optimizing transformations representation choices 
type optimization range sophisticated type systems static analyses exploitation fact static types source language provide valuable information foolish ignore recompute 
example fact languages pointers objects different types alias allow transformations 
mlj compiler uses simple type information share representations single java class implement different ml closures 
ffl type information generating backend code example interfacing garbage collector allocating registers 
ffl type checking intermediate representation way finding compiler bugs 
ffl particularly natural language allows types reflected values 
ffl clearly right thing target language typed 
case mlj java bytecode typed compilers targetting typed assembly language mwcg 
disadvantages ffl keeping type information maintaining transformations expensive space time 
ffl type system complex non standard restricting compiler typable terms prohibit transformations 
packaging functions values free variables trivial point view typing 
ml compiler intermediate language researchers suggested moggi computational metalanguage ml mog mog useful basis typed intermediate language 
benton ben proposed computational metalanguage way expressing optimizations may performed result strictness analysis compilers cbn languages 
earlier expressing strictness analysis largely terms somewhat informal notion changes evaluation strategy fixed syntax 
elegant reason changes translation source language language fixed operational semantics 
case pure cbn source language pcf plo directly source source translation express strictness transformations 
adding strict construct typing rule gamma gamma gamma really significant advantage 
author persistently refers ml computational lambda calculus moggi invented name different calculus computational types 
doesn caused terrible confusion aware 
evaluates weak head normal form whnf substituting allows express basic strictness optimizations replacing application known strict 
half story able perform optimizations fact certain expressions example known bound values whnf need represented thunks re evaluated 
capture kind information benton suggested variant computational metalanguage expression value type whnf computation type ta potentially unevaluated expressions terminate yield values type default translation call name expression type intermediate language expression type type ta tb computation producing function computations computations 
expression denoting strict function called strict contexts contrast translated intermediate language term type tb computation producing function values computations 
exercise standard denotational semantics pcf ccc pointed cpos continuous maps int 
function space interpreted 
semantics adequate cbn operational semantics notion observation termination closed terms ground type 
natural give semantics pcf strict construct just defining ae ae ae ae 
ae fact semantics longer adequate 

modify semantics fix problem 
modified semantics semantics original language 
authors addressed problem expressing strictness transformations varying translation source language continuation passing style bm dh 
strands brought nice danvy hatcliff hd showed various cps transforms factored translations computational metalanguage administrative reductions cps flanagan reductions corresponded applying fi reduction commuting conversions see section associated computation type constructor computational metalanguage 
danvy hatcliff suggest computational metalanguage attractive compiler intermediate language 
peyton jones proposed intermediate language computational metalanguage common framework compiling call value call name languages 
barthe bht add computational types pure type systems pts obtain monadic versions family higher order typed lambda calculi 
calculus constructions advocate calculi compiler intermediate languages languages combine polymorphic type module systems side effects 
type effect systems referred previous section concerns behaved intermediate language normal forms cps ml perform sound rewriting programs written languages impure features 
intermediate languages kind separation type system language syntax pure values impure potentially side effecting computations 
separation fairly crude reasons wanting infer compile time safe approximation just side effects may happen result evaluating particular expression 
kind effect analysis really applicable cbv languages cbn languages usually allow side effects non termination 
historically effect analyses higher order languages developed avoid type soundness problem occurs polymorphism combined naively updateable 
see problem consider illegal sml program val ref fn 
fn true obvious extension hindley milner type inference rules cover creation dereferencing assignment program type check 
fn type ff ff 
ref fn type ff ff ref 
generalization gives type scheme ff ff ff ref 
specialization type int int ref meaning assignment typechecks 
specialization type bool bool ref 
type bool bool application type checks 
clear program really type error try increment boolean 
get problem gifford lucassen jouvelot talpin gl tj developed type effect systems 
idea refined type system infers type possible effects expression may restrict polymorphic generalization type variables appear side effecting expressions 
example infer expression ref fn creates new cell type ff ff 
prevents type generalized rule assignment causes ff unified int application true fails typecheck 
noted passing number different ways avoiding type loophole 
example tofte imperative type discipline tof imperative type variables old version standard ml definition whilst leroy weis proposed scheme tracking dangerous type variables appearing free types expressions stored lw 
key motivation allow polymorphic generalization possible happen rule whilst keeping type system sound 
expensive unpredictable inference systems direct impact user programs typecheck idea 
wright published study case static analyses precise information uncomputable settle approximations 
case means overestimating possible side effects expression 
depending order inference algorithm works application alternatively cause ff unified bool error discovered assignment 
example giving type error messages hard 
wri indicating nearly existing sml code typecheck run identically modulo little expansion polymorphic generalization simply restricted source expressions syntactic values trivially side effect free 
simple restriction adopted revised sml definition research fancy type systems impure polymorphic languages essentially ceased 
reasons wanting automatic effect inference 
obvious detailed effect information allows compilers perform aggressive optimizations 
applications include various kinds verification tool assist programmer check security policies example 
sml seemingly trivial rewrite dead code elimination val gamma 
fv generally valid evaluation doesn diverge perform update state throw exception valid reads cells allocates new ones 
basic idea different type effect systems literature share common core 
book contains things fair amount effect systems notes 
traditional type system infers judgements form xn types 
type effect system infers judgements form xn says typing context expression type effect 
effect drawn set elements denote sets actual effects may occur runtime words abstractions runtime effects just types abstractions runtime values 
exactly depends runtime effects possible language precise wishes analysis 
simplest non trivial effect system simply take elements usually written denoting effect pure just meaning possibly effect 
effect systems shall see little refined 
thing form type effect judgement effect appears right turnstile left 
considering cbv languages means runtime free variables bound values effect 
effect system impure cbn language thing pairs types effects context 
variables bound values associated type effect rule gamma personally frequently find current value restriction annoying 
example datatype endo val fun id id fails get polymorphic type whilst local fun id val id ok reader thinks silly example programmers write code quite mistaken 
immediately unused bindings may common original source frequently created result rewrites 
mixture cbn side effects unpredictable haskell allow experts unsafeperformio operation 
aware type effect system cbn language 
second point needs algebra just set operations combining effects defined 
consider effectful version rule simple strict non polymorphic non computational expression gamma gamma gamma effect compound expression 
dynamically evaluated possibly performing side effect set denoted assuming evaluation terminated value evaluated possibly perform sideeffect set denoted combine depends accuracy willing pay static analysis 
care relative ordering side effects take elements denote sets sequences regular languages basic set effects language concatenation gamma delta gamma combine rule 
commonly away relative sequencing multiplicity effects just consider sets basic effects 
case natural combining operation rule union operation 
conditional expression natural rule gamma bool gamma gamma gamma delta tracking sequencing multiplicity effect rule just course 
main interesting feature type effect systems form rules abstraction application types dependent effects function space constructor annotated latent effect rule abstraction looks gamma gamma abstraction value immediate effect effect applied seen rule application gamma gamma gamma delta delta effect evaluating application separate effects occurs function evaluated occurs argument evaluated occurs body function evaluated 
effect systems sets sequences combining operation application rule just 
final thing need add minimal skeleton effect system way weaken effects 
collection effects analysis natural partial order relation defined means denotes larger set possible runtime side effects 
typically just subset relation sets primitive effects 
simplest rule add usable system rule gamma gamma effect systems literature include binary operation formal syntax effect annotations considered modulo unit associativity commutativity idempotence 
simple effect systems unnecessarily concrete easy avoid effect variables substitution 
exercise define toy simply typed cbv functional language integers booleans pairs functions recursion fixed collection global mutable integer variables 
give operational denotational semantics 
give type effect system language tracks global variables may read written evaluation expression effect pair sets global variable names 
formulate prove soundness result analysis 
closed terms language require rule typable 
precise effect systems great things static analyses tweak analysis system accurate 
number natural popular ways improve precision hopelessly weak simple types approach effect analysis sketched previous section 
subtyping bidirectional flow information type systems analyses simply constrain types equal frequently leads undesirable loss precision 
example consider effect analysis silly ml program forget polymorphism moment fun fun pure fun impure print side effect val pure impure pure typed isolation best type pure unit unit impure get unit unit assuming constant print type string unit 
fact get passed function means having types including latent effects identical 
applying rule body pure deriving type unit unit pure impure 
ends type inferred expression obvious able deduce accurate type unit unit 
fact argument type impure function type way back definition pure 
peyton jones phenomenon apt name poisoning problem 
solution extend notion allow general subtyping 
replace rule gamma gamma partial order types defined rules theta theta corollary unsolvability halting problem known full employment theorem compiler writers 
note contravariance function space constructor argument type 
subtyping rule get type effect expect silly example 
definitions pure impure different types apply subtyping rule writing unit gamma pure pure gamma pure pure coerce pure passed match required argument type whilst accurate type inferred point definition type expression 
effect polymorphism approach poisoning problem introduce ml style polymorphism level effects largely orthogonal polymorphism level types 
allow effects contain effect variables allow context bind identifiers type schemes quantify effect variables 
consider program fun run fun pure fun impure print poison fun run impure run pure case subtyping deriving type effect unit program side effect 
effect polymorphism express fact dependency effect call run latent effect function passed 
definition run gets type scheme unit unit unit instantiated application pure application impure executed 
lets deduce type effect unit program 
regions influential ideas come type effect systems regions static abstractions sets dynamically allocated run time locations 
earlier exercise designing effect system track mutable storage language fixed set global locations obvious choices precisely tracks effects records simply expression read write unspecified locations records set just locations read written 
clearly second precise enable transformations 
example evaluation expression effect read locations moved evaluation expression effect write locations set locations possibly read disjoint set locations possibly written 
real programming language possible exception ones designed compiled silicon allows statically fixed set mutable locations unbounded number new may allocated dynamically runtime static effect system clearly name advance 
simple approach just having big abstraction locations store tracking reading writing takes place sound precise 
languages existing type system gives natural way partition runtime set mutable locations disjoint sets 
ml language int ref bool ref aliased may obtain useful increase precision indexing read write allocation effects types 
ignoring polymorphism take wr typeg note types effects mutually recursive 
better 
imagine language quite distinct types say red ones blue ones say sort creating accessing 
clearly red blue alias refine effect types system track colours involved store effects perform transformations example commuting expression write blue integer reads red integer 
simplest form idea region inference take typing derivation monochrome program find way colouring type appearing derivation subject preserving validity derivation example function expecting red argument applied blue 
clear aim different colours possible 
colours conventionally called regions imagine dynamically locations colour allocated particular region heap 
static concepts type effect region 
treated relation polymorphically 
type effect discipline described talpin jouvelot tj polymorphic components indexes effects regions types 
interesting thing regions extend inference system rule effect smaller effect assumption 
consider example fun val ref simple effect system assign type effect int fal rdg int reasonable functional value takes integers integers latent effect allocating reading 
fact latent effect completely unobservable uses storage completely private 
case easy see observationally equivalent completely pure successor function alternatively think runtime location unique allocation site code locations allocation site share colour think region set static program points 
satisfactory view sophisticated systems allow allocated program point different regions depending dynamic contextual information functions appear call chain 
fun means provided going effect information respects observational equivalence soundly just forget latent effect infer type int int 
regions help 
simple type region effect derivation looks delta delta delta gamma int int gamma int ref int ref ae fal ae delta delta delta gamma int int ref ae int ae gamma int ref int fal ae rd ae gamma fn ref int fal ae rd ae int ae region 
valid derivation choice ae particular pick ae distinct region appearing gamma 
means body function effect involving imported surrounding context 
furthermore type function body simply int rest program result call function dependency produce 
considerations motivate effect masking rule gamma gamma ae ae wr ae ae gamma ae ag rule just typing abstraction derivation allow type having observable latent effect 
soundness effect masking rule far obvious trivial prove 
semantics local state higher order languages subtle literature type systems inferring enforcing encapsulation side effects contains number unsound systems incorrect proofs 
powerful idea 
remarkable uses region analysis tofte talpin static memory management tt assign region annotated types non base value just mutable intermediate language new lexically scoped regions introduced explicitly letregion ae construct 
typed annotated program language value allocated region ae referenced letregion block introducing ae 
region heap may safely reclaimed exiting block 
technique successfully applied version ml kit compiler runtime garbage collector 
programs scheme leads dramatic reductions runtime space usage compared traditional garbage collection results worse 
combining techniques possible requires care region memory management reclaims memory referenced may pointers accessible gc root 
gc needs avoid dangling pointers 
case justifying optimising transformations inferring generous polymorphic types case static analysis tool helps programmer reason say memory usage 
monads effect systems section describes type effect analyses terms monads computational metalanguage 
obvious anybody got writing serious 
icfp wadler published wad showing equivalence mild variant effect system talpin jouvelot tj version computational metalanguage computation type constructor indexed effects 
conference benton kennedy russell described mlj compiler intermediate language mil similar effect refined version computational metalanguage 
tolmach proposed intermediate representation hierarchy monadic types compiling ml transformation tol 
basic observation places computation type constructor appears call value translation lambda calculus ml correspond precisely places effect annotations appear type effect systems 
effect systems put function arrow right hand side whilst cbv translation adds function arrow right hand side 
wadler started cbv lambda calculus value polymorphic type region effect system tracking store effects effect masking 
showed moggi cbv translation language version metalanguage computation type constructor annotated set effects monadic rule unions sets preserves typing gamma eff gamma mon int int defined instrumented operational semantics languages prove subject reduction type soundness results style wright felleisen wf 
instrumented operational semantics records evaluation expression state value new state trace side effects occur evaluation part definition type soundness expression static effect effect occuring dynamic trace evaluation contained 
tolmach intermediate language monads 
identity monad pure terminating computations 
lifting monad model potential non termination 
monad exceptions non termination 
st monad combines lifting exceptions possibility performing output 
linearly ordered explicit monad morphisms coerce computations monad type larger 
tolmach gives denotational semantics intermediate language cpos presents number useful transformation laws validated semantics 
mil lite monads mlj mil lite simplified fragment mil intermediate language mlj compiler 
introduced benton kennedy bk basis proving soundness effect optimizing transformations performed mlj 
compared effect systems literature mil performs fairly crude effect analysis doesn regions effect polymorphism masking 
mil lite simplifies full language omitting type polymorphism higher type recursive types various lower level features 
mil lite far trivial combining higher order functions recursion exceptions dynamically allocated state effect indexed computation types subtyping 
types terms mil lite compiler intermediate language give operational semantics derive equational theory couple design differences moggi equational metalanguage 
types stratified value types ranged computation types ranged fl need computations computations 
second difference distinction computations values syntactic expressions value types normal forms 
elegant assign value types wider collection pure expressions just normal form 
way wadler effect annotated monadic language leads naturally stratified operational semantics relation defining reduction expressions value type normal form defining possibly side effecting semantics computations 
countable set exception names mil lite types defined unit int theta fl fl ag write bool unit unit 
function types restricted values computations shall need interpret cbv source language 
effects detect possible failure terminate reading writing allocating new cell raising particular exception inclusion sets effects induces subtyping relation int theta theta fl fl fl fl reflexivity transitivity consequences rules 
forms typing judgment gamma values gamma fl computations cases gamma finite map term variables value types source language cbv 
assume countable set locations 
typing rules shown satisfy usual weakening strengthening substitution lemmas 
range value computation terms oe range value computation types 
terms unsurprising novel construct try catch fe en mn gamma gamma int gamma unit gamma gamma gamma gamma gamma gamma theta gamma gamma rec gamma gamma gamma fl gamma gamma fl gamma gamma val gamma gamma gamma gamma try catch gamma raise feg gamma theta gamma gamma gamma flg gamma case fl gamma int gamma ref fag gamma gamma frg int gamma gamma int gamma fwg unit gamma int gamma int gamma int gamma int gamma int gamma bool gamma fl gamma fl fl fl typing rules mil lite def rec fv omega def rec false def true def def case fv def try catch fg def def fv handle def try catch val set 

def val assert def val omega assert 

def assert assert val syntactic sugar read evaluate expression successful bind result evaluate exception raised evaluate exception handler handler applicable pass exception 
full discussion reasons adopting try handle construct may bk observe nicely generalises handle moggi monadic illustrated syntactic sugar defined 
ease presentation handlers treated set exception appears 
range sets write denote handler removed exists 
map notation example writing term handler writing dom fe hg 
write gamma fl mean gamma fl 
analysis way mil lite typing rules express simple effects analysis fairly clear features may deserve comment 
rule incorporates extremely useful termination test obvious rule insist prevent getting natural derived typing rule cause undesirable non termination effects appear particularly curried recursive functions 
just traditional effect systems subtyping increases accuracy analysis compared just uses simple types 
possible variants rules 
example stronger try rule effects handlers required effects handlers corresponding exceptions occurring unioned effect expression 
exercise give examples validate claim rule gives better results obvious version 
mil lite contain recursive types higher type sigma val sigma sigma raise sigma sigma sigma sigma sigma sigma sigma true sigma sigma false sigma sigma sigma sigma sigma 
sigma ref sigma 
sigma sigma sigma case sigma sigma rec sigma sigma rec sigma sigma sigma sigma sigma sigma try catch sigma sigma sigma sigma sigma sigma try catch sigma sigma sigma sigma try catch sigma dom evaluation relation mil lite proving correctness significantly difficult 
devise candidate rules constructs 
re quite obvious ones 
operational semantics operational semantics mil lite big step evaluation relation sigma sigma ranges value terms exception identifiers sigma states def fin write sigma sigma sigma sigma set location names occuring sigma delta states sigma delta states defined sigma delta delta defined sigma 
lemma type soundness bmc dom sigma sigma sigma bv dom sigma dom sigma 
easy show evaluation unaffected irrelevant locations renaming lemma dom sigma bmc dom sigma dom sigma oe bijection sigma sigma sigma sigma ffi oe gamma oe sigma sigma ffi oe gamma oe obvious definition action renaming expressions 
bk reformulate operational semantics terms inductively defined termination predicate convenient proving number technical results observational equivalence 
material directly related monads effects omitted account characterisation mil lite contextual equivalence noted don know 
definition write say ciu approximates type fl fl sigma states dom sigma bm nc sigma try catch sigma try catch write val val cf 
moggi mono condition 
write oe say ciu equivalent type oe oe oe 
lemma ciu equivalence coincides contextual equivalence 
transforming mil lite semantics effects want effect information expressed mil lite types justify optimizing transformations 
initial inclination prove correctness transformations denotational semantics 
giving denotational semantics mil lite surprisingly tricky really multiple computational types presence dynamically allocated 
stark thesis sta examines equivalence minimal language dynamically generated names considerable detail give functor category semantics language higher order functions integer 
mil lite complex stark language requiring functor category cpos sets indexed monads 
worst resulting semantics turns far fully fails validate elementary transformations wished perform 
decided prove correctness transformations operational techniques 
operational semantics prove soundness effect analyses involves instrumenting semantics trace computational effects way proving typed programs don go wrong modified semantics 
approach perfectly correct notion correctness meaning effect annotations quite intensional closely tied formal system infer 
wanted prove soundness analysis justify observational equivalences uninstrumented semantics tried characterise meaning effect annotated types properties terms closed observational equivalence uninstrumented semantics 
give simple example difference approaches weak effect system mil lite assign term effect contain evaluation term really perform write operation 
region analysis may infer effect detect term writes private locations 
property really want justify equations extensional evaluating term contents locations allocated evaluation indistinguishable start 
decision instrumented semantics largely taste post hoc justification 
places mlj libraries manually annotate bindings smaller effect types inferred analysis typically rewrites dead code example initialisation lookup tables floating point libraries 
bindings extensional properties associated type force correctness result optimizations extends easily manually annotated expressions 
capture intended meaning oe type oe mil lite set closed terms type pass collection tests tests oe states theta ctxt oe theta ctxt oe ctxt oe set closed contexts finite number holes type oe 
formally oe def oe sigma delta delta tests oe bm dom sigma sigma sigma define tests oe inductively shown 
definitions appear complex value types amount familiar looking logical predicate lemma ffl int fn zg lg unit ffl theta ffl fl ff fl fl ffl fin lemma oe oe oe oe 
prove operational version admissibility predicate associated type 
follows standard compactness evaluation unwinding result proved termination induction omit details 
prove fundamental theorem logical predicate theorem oe oe 
explained meaning logical predicate value types worth commenting little definitions tests intention extent tests set computations type definitely effect passing tests tests easily seen equivalent diverging state passing tests tests means throwing exception state 
tests concerning store effects little subtle 
hard see tests expresses observably writing store 
similarly tests tests 
observably reading store running computation different initial states seeing results distinguished subsequent continuation 
surprising definition probably tests extent intended computations observably allocate new storage locations 
include example computation allocates returns function uses keep count times called reveals counter returns different results value 
definition tests say store extension captures computations evaluations equivalent initial states yield indistinguishable results 
choice meaning doesn allocate guided optimising transformations wished able perform deep understanding exactly means allocate observably retrospect quite reasonable 
tests int def fg tests def fg tests unit def fg tests theta def sigma delta delta sigma delta delta tests tests def sigma case delta gammai omega case delta gammai omega gamma sigma delta delta tests tests fl def sigma delta delta sigma delta delta tests fl tests def sigma delta set sigma delta set sigma sigma delta delta tests sigma tests tests def sigma delta val sigma tests def sigma try delta catch try delta catch int fl int fl sigma states dom sigmag tests def sigma sigma delta try delta catch assert sigma delta raise sigma delta try delta catch assert sigma 
delta raise assert sigma 
delta sigma delta sigma delta states dom delta dom sigma flg sigma delta handle omega set sigma delta handle omega gamma sigma sigma states tests def sigma delta delta handle sigma states flg tests def sigma delta set sigma delta delta val sigma states flg sigma def 
dom sigma sigma delta def set sigma delta val handle val assert sigma delta set sigma delta val handle val assert sigma delta set sigma definition tests oe fi theta gamma gamma gamma val theta fi gamma gamma fl gamma val fl fi 
gamma gamma gamma rec rec fi gamma gamma fl gamma fl gamma case fl theta gamma theta gamma val val theta gamma gamma case val val val 
gamma fl gamma rec fl gamma fl gamma val fl cc gamma gamma gamma gamma cc gamma gamma gamma gamma case fin case fin ng fi gamma fl gamma fl gamma fl gamma try raise catch fl gamma gamma gamma gamma try catch raise try catch effect independent equivalences gamma int gamma gamma ref fag gamma gamma int int gamma val frg gamma int gamma int gamma gamma ref ref ref ref fag gamma gamma int gamma int gamma fr wg effect independent equivalences effect independent equivalences presents typed observational congruences correspond identities equational theory computational lambda calculus presents equivalences involve local side effecting behaviour 
directed variants useful transformations fact performed mlj duplication terms cc avoided introducing abstraction 
equations derived recourse logical predicate making strong notion equivalence called kleene equivalence easily shown contained ciu equivalence 
terms kleene equivalent initial state syntactically identical results values accessible locations store mason talcott call strong isomorphism mt 
beta equivalences commuting conversions equivalences derived directly kleene equivalences 
derivation eta equivalences involves deriving number extensionality properties ciu equivalence similar techniques pit 
effect dependent equivalences come set equivalences dependent effect information shown 
notice equations respectively subsume local equivalences 
equivalences proved considering evaluation side arbitrary ciu context logical predicate show evaluation terminates evaluation side context 
effect masking monadic encapsulation seen hard recast simple effect systems monadic framework 
monadic equivalent effect masking 
answer encapsulation side effects provided runst haskell full connection established 
haskell allows monadic computations purely local state encapsulated values pure types making trick type variables similar discard gamma gamma gamma fr ag copy gamma gamma gamma val fr ag fw ag swap gamma gamma gamma gamma fr fa fr dead try gamma gamma gamma gamma try catch try catch effect dependent equivalences regions effect systems 
briefly state monad st parameterized type state dummy type variable syntax datatype st 
idea parameters types inferred computations states interfere unified computation assigned type parametrically polymorphic state encapsulated 
expressed runst combinator rank polymorphic type runst st don think anybody believes unsound certainly hard prove correct suspicious initial state fed computation comes 
early attempts prove soundness subject reduction known incorrect ls 
sabry succeeded defining cbv language monadic encapsulation relating language effect masking proving type soundness ss 
moggi addressed problem mp defining slightly different form monadic encapsulation bogus type parameter proving type soundness result language stateful operations strict 
proving soundness monadic encapsulation cbn language lazy state far am aware open problem 
curry howard correspondence monads section provides little optional background logical reading computational metalanguage explains term commuting conversion 
readers familiarity called curry howard correspondence isomorphism aka propositions types analogy 
relates types certain typed lambda calculi propositions intuitionistic logics typed terms context natural deduction proofs propositions assumptions reduction proof normalization 
basic example correspondence relates simply typed lambda calculus function pair disjoint union types propositional logic implication conjunction disjunction glt 
whilst may true realistic programming language corresponds accurately plausibly called logic presence general recursion logic proof theory provide helpful insights design programming languages intermediate languages 
partly proof theorists developed number taxonomies criteria behavedness proof rules turn transferable design language syntax 
computational metalanguage provides nice example applicability proof theoretic ideas see details 
reads type rules elimination computation type constructor logically ends intuitionistic modal logic dubbed cl logic slightly unusual kind possibility modality pi 
natural deduction form gamma gamma pia pi gamma pia gamma pib gamma pib pi interestingly hilbert style presentation logic discovered mendler call lax logic context hardware verification fm considered curry cur 
logical perspective basic equations computational metalanguage arise inevitable consequences form elimination rules imposed separately 
way fi rule computation type constructor arises natural deduction presentation logic fairly straightforward basic step normalization removal detours caused immediate elimination logical connective delta delta delta pi pia delta delta delta delta delta delta pib pi pib gamma 
delta delta delta delta delta delta delta delta delta delta delta delta pib gamma gamma val ta gamma tb gamma val tb gamma 
gamma tb natural deduction systems give rise secondary form normalisation step necessary ensure normal deductions satisfy subformula property example 
occur system contains elimination rules minor premiss girard calls parasitic formula refers necessity extra reduction shame natural deduction glt 
general rule want able commute rule derivation minor premiss past rule move application rule elimination past elimination rule derivation minor premiss 
important cases moving eliminations introductions 
transformations called commuting conversions 
elimination rule disjunction coproducts logic gives rise commuting conversions elimination pi modality cl logic 
restriction form pi rule modal means rule gives rise commuting conversion ffl deduction form delta delta delta pia delta delta delta pib pi pib delta delta delta pic pi pic commutes delta delta delta pia delta delta delta pib delta delta delta pic pi pic pi pic terms computational metalanguage commuting conversion induces associativity rule gamma ta gamma tb gamma tb gamma tc gamma tc gamma 
gamma ta gamma tb gamma tc gamma tc gamma tc commuting conversions generally optimizing right code expose computationally significant fi reductions 
important compilation compilers functional languages perform 
mlj unusually dogmatic performing reach call cc normal form turns particularly generate code 
danvy hatcliff observe hd closely related working normal forms logical proof theoretic notion older precisely defined pattern 
paul taylor package diagrams 
app appel 
compiling continuations 
cambridge university press 
benton bierman de paiva 
computational types logical perspective 
journal functional programming march 
preliminary version appeared technical report university cambridge computer laboratory may 
ben benton 
strictness analysis lazy functional programs 
phd thesis computer laboratory university cambridge december 
bht barthe hatcliff thiemann 
monadic type systems pure type systems impure settings 
proceedings second workshop stanford university palo alto ca 
december electronic notes theoretical computer science 
elsevier february 
bk benton kennedy 
monads effects transformations 
third international workshop higher order operational techniques semantics paris volume electronic notes theoretical computer science 
elsevier september 
bk benton kennedy 
exceptional syntax 
submitted 
benton kennedy russell 
compiling standard ml java bytecodes 
rd acm sigplan conference functional programming september 
bm burn le metayer 
proving correctness compiler optimisations global program analysis 
technical report doc department computing imperial college london 
buneman naqvi tannen wong 
principles programming complex objects collection types 
theoretical computer science 
bor borceux 
handbook categorial algebra 
cambridge university press 
bs erik barendsen smetsers 
uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science pages 
bur burge 
recursive programming techniques 
addison wesley publishing reading mass 
bw barr wells 
toposes triples theories 
springer 
cm moggi 
syntactic approach modularity denotational semantics 
ctcs 
cwi tech 
report 
cur curry 
elimination theorem modality 
journal symbolic logic january 
dh danvy hatcliff 
cps transformation strictness analysis 
acm letters programming languages systems 
fil filinski 
representing layered monads 
popl 
acm press 
fm mendler 
intuitionistic modal logic applications formal verification hardware 
proceedings computer science logic volume lecture notes computer science 
springer verlag 
flanagan sabry duba felleisen 
essence compiling continuations 
proceedings conference programming language design implementation 
acm 
gifford jouvelot lucassen sheldon 
fx manual 
technical report mit lcs tr mit laboratory computer science 
gl gifford lucassen 
integrating functional imperative programming 
acm conference lisp functional programming 
acm press 
glt 
girard lafont taylor 
proofs types 
number cambridge tracts theoretical computer science 
cambridge university press 
gor gordon 
denotational description programming languages 
springer 
hd hatcliff danvy 
generic account continuation passing styles 
proceedings st annual symposium principles programming languages 
acm january 
hm graham hutton erik meijer 
monadic parsing haskell 
journal functional programming july 
hud hudak 
modular domain specific languages tools 
fifth international conference software reuse pages victoria canada june 
jac bart jacobs 
categorical logic type theory 
number studies logic foundations mathematics 
north holland 
simon peyton jones john hughes editors lennart augustsson dave barton brian boutel warren burton joseph fasel kevin hammond ralf hinze paul hudak thomas johnsson mark jones john launchbury erik meijer john peterson alastair reid colin runciman philip wadler 
report programming language haskell non strict purely functional language 
available haskell org february 
peyton jones launchbury shields tolmach 
bridging gulf common intermediate language ml haskell 
proceedings popl 
acm 
jon peyton jones 
compiling haskell program transformation report 
proceedings european symposium programming sweden number lecture notes computer science 
springerverlag january 
mark jones alastair reid yale haskell group oregon graduate institute science technology 
hugs user manual 
available haskell org hugs 
jw simon peyton jones philip wadler 
imperative functional programming 
th symposium principles programming languages charlotte north carolina january 
acm press 
kkr kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction sigplan notices pages 
kl king launchbury 
structuring depth search algorithms haskell 
conf 
record nd symp 
principles programming languages pages san francisco california 
acm 
lev levy 
call push value subsuming paradigm extended 
typed lambda calculi applications volume lncs 
springer 
lh liang hudak 
modular denotational semantics compiler construction 
esop volume lncs 
springer 
liang hudak jones 
monad transformers modular interpreters 
popl 
acm press 
lj launchbury peyton jones 
lazy functional state threads 
proceedings sigplan conference programming language design implementation pldi june 
ls launchbury sabry 
monadic state axiomatisation type safety 
proceedings international conference functional programming 
acm 
lw leroy weis 
polymorphic type inference assignment 
acm conference principles programming languages 
acm 
man manes 
algebraic theories 
graduate texts mathematics 
springer 
man manes 
implementing collection classes monads 
mathematical structures computer science 
min minamide 
functional data structures hole 
proceedings rd symposium principles programming languages 
minamide morrisett harper 
typed closure conversion 
conference record rd annual acm sigplan sigact symposium principles programming languages st petersburg florida 
acm january 
mog moggi 
computational lambda calculus monads 
proceedings th annual symposium logic computer science ca pages 
mog moggi 
notions computation monads 
information computation 
mog moggi 
semantics evaluation logic 
fundamenta informaticae 
mog moggi 
metalanguages applications 
semantics logics computation volume publications newton institute 
cambridge university press 
mos mosses 
denotational semantics 
van leeuwen editor handbook theoretical computer science chapter 
mit press 
mos mosses 
action semantics 
number cambridge tracts theoretical computer science 
cambridge university press 
mp moggi 
monadic encapsulation effects revised approach 
proceedings third international workshop higher order operational techniques semantics electronic notes theoretical computer science 
elsevier september 
mt mason talcott 
equivalences functional languages effects 
journal functional programming 
mwcg morrisett walker crary glew 
system typed assembly language 
acm transactions programming languages systems may 
nielson hankin 
principles program analysis 
springerverlag 
pit pitts 
operationally theories program equivalence 
dybjer pitts editors semantics logics computation publications newton institute pages 
cambridge university press 
pit pitts 
categorical logic 
abramsky gabbay maibaum editors handbook logic computer science volume 
oxford university press 
plo plotkin 
call name call value lambda calculus 
theoretical computer science pages 
plo plotkin 
lcf considered programming language 
theoretical computer science 
sco scott 
type theoretic alternative cuch iswim 
theoretical computer science 
sf sabry felleisen 
reasoning programs continuation passing style 
lisp symbolic computation 
sha shao 
overview flint ml compiler 
proceedings acm workshop types compilation amsterdam 
acm june 
ss sabry 
monadic encapsulation ml 
proceedings international conference functional programming 
acm 
sta stark 
names higher order functions 
phd thesis computer laboratory university cambridge 
tj 
talpin jouvelot 
type effect discipline 
information computation june 
revised lics 
tof tofte 
operational semantics polymorphic type inference 
phd thesis department computer science university edinburgh 
tol tolmach 
optimizing ml hierarchy monadic types 
proceedings workshop types compilation kyoto march 
tt tofte 
talpin 
region memory management 
information computation february 
wad wadler 
comprehending monads 
mathematical structures computer science 
wad wadler 
marriage effects monads 
international conference functional programming 
acm press 
wf wright felleisen 
syntactic approach type soundness 
information computation november 
wri wright 
simple imperative polymorphism 
lisp symbolic computation 

