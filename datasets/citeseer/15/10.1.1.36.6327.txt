submitted forthcoming lncs mobile agent security november protecting mobile agents malicious hosts tomas sander christian tschudin international computer science institute center street berkeley ca usa icsi berkeley edu 
key element mobile code distributed system security mechanisms available protect host potentially hostile actions code fragment execution mobile code tampering attempts executing host 
techniques problem developed 
second problem harder general belief computation privacy mobile code provided tamper resistant hardware 
furthermore agent keep secret secret key generate digital signatures 
error reasoning arguments supporting beliefs going point 
describe software approaches providing computation privacy mobile code important case mobile code fragment computes algebraic circuit polynomial 
describe approach mobile agent digitally sign output securely 
program actively protect execution environment tries divert intended execution malicious goal 
little thought problem impossible solve leads infinite recourse 
assessment routine detect wrong execution code tampering data try counter subject diversion 
mobile code applications specifically mobile software agents designed run potentially arbitrary computers problem primordial importance 
strong guarantees computation integrity privacy mobile programs remain vulnerable hijacking 
consider example scenario 
customized mobile air fare agent sent order visit turn servers airlines query databases finding suitable flight best offer determined book flight 
simple profitable attack tamper agent state code forgets visited servers erroneously selects offering malicious server airline 
attack rise prices threshold internally agent applicable steal agent electronic money processing 
problematic scenario mobile agent wants book flight therefor wants digitally sign order problem agent carry user private key computation key 
simple example exposes fundamental problems executing mobile code untrusted environment mobile agent protect tampering malicious host 
code execution integrity ii mobile agent conceal program wants executed 
code privacy iii mobile agent remotely sign document disclosing user private key 
computing secrets public problems mentioned shopping agent scenario alleviated state art cryptographic algorithms specially managed trusted servers disappear tamper resistant hardware relied 
true self defense mobile agents malicious hosts possible exists nucleus pure software operations computation integrity privacy mathematically proven 
question challenge mobile code carry cryptographic primitives code executed inside untrusted computing environments run autonomously interactions originating site 
firmly believe cases fully software cryptographic solutions exist protecting mobile agents malicious hosts 
belief contradicts folklore saying host execute possession agent code agent host full mercy 
section discuss problems cleartext programs sketch approach effectively hide computations malicious host 
section describes depth approach computing encrypted functions give section possible solutions homomorphic encryption schemes composition techniques 
solution signature problem relies technique proposed section 
section concludes 
protection mobile agents malicious hosts appealing feature mobile agent technology user delegate task net agent autonomously roams locates information computes intermediate results triggers remote actions way long interaction originator 
cryptographic solutions securing execution mobile agents conform requirement introduce interactive protocols involving originator agent 
goal want reach agent able execute security sensitive computations untrusted execution environment 
discussing feasibility solutions briefly review techniques proposed order alleviate threats mobile code 
detection tampering vs prevention effective approach securing mobile agents consists letting circulate trusted execution environments 
setting trusted network nodes encrypting agents sent node node authenticating host agents transports authenticating agents enters host highly agent encounters malicious host 
severely hurts concept open agent system new servers join system new needs show 
relies trust model effective means approach exclude possibility host trusted behaves maliciously 
detection tampering concentrates longlived interests host may joins mobile agent network threatening bar host business restrict security measures detecting tampering posteriori 
tampering observed forward information rating agencies maintain records server trustworthiness social control 
alternatively attempt legal steps recover possible losses claims 
cryptographic techniques proposed direction require host extra order proof executed specific mobile agent 
possible add dummy data items agents offered potential objects tamper returning agent may checked see items modified clearly approach lacks necessary cryptographic strength required serve proof court room 
general detection approaches ineffective attacks culprit may identified existing anymore fraud detected 
step protecting mobile agent malicious hosts tampering difficult expensive 
code obfuscation example proposes agent program difficult manipulate 
major problem provably effective techniques applied remains arms race new masquerade technique immediately paralleled countermeasures see example case java byte code 
approach protect application protecting individual agents composed see discussion approach 
specific task may split mobile agents collaborate different computation platforms secret sharing schemes 
platforms may trusted mobile agent computing base originator trusts 
execution platform complimentary agent chosen random threat collusion attack may 
solutions required despite possible attacks mobile agents may countered techniques described remain cases need provably secure prevention 
example detection tampering inappropriate money amount money involved low justify legal actions law enforcement difficult 
remote digital signing contracts virtually impossible user private key user possibility proof order 
wants exclude certain types actions user wants delegate mobile agent clearly cases prevention tampering privacy guarantees mandatory 
concentrate positive solutions problem providing provably strong protection individual mobile agents tampering attacks 
general belief vulnerability mobile agents widespread belief mobile agent community entity executes program fully control execution entity may potentially fully understand program eventually change way wants 
linking execution program trusted safe haven way mobile agent security sensitive operations 
view expressed places literature 
chess example writes impossible prevent agent tampering trusted hardware available 
hardware malicious host modify manipulate agent 
alluded impossible keep agent private itinerary known advance 
belief restated rigorous arguments verify statement 
intuitive arguments strongly support view 
points certainly apply mobile agent program cleartext data read changed 
cleartext programs manipulated 
cleartext messages originator faked 
important point intrinsic reason programs executed cleartext form sense communicate party understanding computer execute understanding 
claim folklore mobile agent vulnerability wrong tacitly assumes mobile agent consists cleartext data cleartext programs 
possibility executing encrypted programs give examples encrypt functions executing entity learn substantial briefly review consequences 
nice observation execute encrypted programs decrypting automatically code privacy code integrity sense specific tampering possible 
attacks malicious host reduced actions surface mobile agent denial service random modifications program output replay attacks 
solution protection mobile code susceptible new attacks possible non mobile program environment 
attacker run program fully controllable setting arbitrarily collect sufficient data recover essential information program encrypted 
realizing cryptographic primitives hosts biggest challenge question useful cryptographic primitives realized mobile code 
fact sufficiently powerful cryptographic services run distrusted places envisage fully mobile agent software environments trusted 
keep secrets take care replication increased redundancy perform mobile agents disclose content told verified authorization course 
section cryptographic primitive mobile agent implement secure way digital signing 
computing encrypted functions general term program previous sections differentiate function program implements 
goal encrypt functions transformation implemented programs 
resulting program consist cleartext instructions processor interpreter understands 
processor able understand program function 
closely related goal computing encrypted function cef problem computing encrypted data ced 
starting point discuss section limits solutions proposed far explore structural constraints encrypting functions imposed desired non mobile agents 
identify important class functions polynomials rational functions 
computing encrypted data problem computing encrypted data ced described abadi feigenbaum way bob algorithm compute function willing compute alice 
alice wants compute private input want reveal bob 
furthermore alice learn substantial algorithm bob computing proposed solution yields highly interactive protocol problem model boolean circuits allows alice encrypt input data way bob compute getting know cleartext abadi feigenbaum point relation ced computing encrypted functions clear description distinction data circuits unnecessary 
ability hide circuit hide private data simply hardwiring circuit 
conversely protocols ability hide data hide circuit detour run protocol take circuit universal circuit encoding circuit wants hide input 
assume alice wants function executed bob 
letting bob algorithm universal circuit encrypt boolean circuit computing input data bob universal circuit 
principally possible compute encrypted functions abadi feigenbaum solution interactive requires rounds message exchanges alice bob 
number communication rounds related depth boolean circuit represents universal circuit may quite large 
needed amount contradicts spirit mobile agents able perform computation autonomous way 
important drawback reduction cef ced infeasible 
true boolean function circuit realized substituting universal boolean function certain variables specifying function function universal class boolean functions ff bg necessarily log 
get exponential blowup universal boolean functions means principally correct approach computationally infeasible 
seemingly difference hiding data hiding circuits 
infeasibility reduction suggests cef may harder ced 
show important instance algebraic circuits opposite case significantly weaken conditions encryption function 
non interactive computing encrypted functions requirements mobile agents mind state problem want solve alice algorithm compute function bob input willing compute alice wants bob learn substantial bob need interact alice computation 
protocol non interactive computing encrypted functions 
letting alice bob way described assume function transformed encrypted function 
encryption hides function may may contain encryption output data 
notation stand program implements function depicts protocol alice send bob program plain function program encrypted function 
bob learns program apply input result computation return alice 
simple protocol non interactive computing encrypted functions looks alice encrypts 
alice creates program implements 
alice sends bob 
alice bob fig 

computing encrypted functions 
bob executes 
bob sends alice 
alice decrypts obtains 
computing encrypted functions composition simple way achieving code privacy consists alice diverting function 
bob asked compute systematically modified function results exclusively alice 
describe easy example 
assume alice wants evaluate linear map bob input bob computer 
want reveal bob picks random invertible matrix computes sa 
sends bob bob computes bx sends back alice 
alice computes gamma obtains result ax having disclosed bob 
example cef encryption function realized efficiently 
encryption matrix output computation alice decrypt result sent back bob 
matrix example generalized encrypt polynomial composing function assume rational function quotient polynomials rational function alice able invert efficiently ffi security method difficulty decomposing resulting decomposition problem multivariate rational function known decomposable find ffi interestingly results hardness decomposing rational functions 
polynomial time algorithm decomposing multivariate rational functions known 
furthermore ways construct rational functions easy invert proposed shamir different context 
depth analysis composition approach remains carried 
shows interesting candidates doing cef exist 
encrypting polynomials rational functions challenge find encryption schemes arbitrary functions 
approach identify specific function classes find encrypting transformations 
interesting class polynomials rational functions 
current stage leave open cef approach applicable arbitrary functions claim achieved complete solution case polynomials 
restricted setting polynomials rational functions prove positive results falsify general belief mobile code vulnerability non trivial cases 
rational functions represent rich important class functions 
studying hope find principles apply broader class functions 
relation general programs boolean circuits algebraic circuits 
fundamental limits set functions computed encrypted form 
goal map cleartext program encrypted program pe alice recover pe unknown input bob 
encrypted program just data stream executable program 
ordinary data encryption techniques applied 
furthermore want cleartext program encrypted form compatible 
mathematical analogue algebraic structure domain set number operations relations mathematical analogue compatible transformations homomorphisms compatible operations relations 
assume example group 
homomorphism 
map 
programs usually build small set building blocks instructions programming language provides 
need computational analogue homomorphisms respects building blocks 
processing data homomorphic functions studied 
section focus algebraic homomorphic encryption schemes maps algebraic structures study rings compliant compatibility constraint 
programs represented algebraic circuits polynomials 
cryptographic viewpoint mathematical compatibility requirement homomorphisms may strong 
recall map transform cleartext program encrypted program hard invert adversary 
mathematical homomorphisms available encryption functions easy invert suited way encryption functions 
consider example ring functions additively homomorphic linear functions cx turn totally insecure 
required compatibility considerably weaker computational framework mathematical framework requiring map groups computational purposes sufficient efficiently computed 
exponentiation pz example map 
algebraic circuits relate boolean circuits 
known reasonable conditions algebraic circuit finite fields simulated efficiently boolean circuits 
converse wide open cf 
discussion issues 
shifting turing machine model boolean circuits restriction language recognized deterministic turing machine polynomial time recognized uniform boolean circuits polynomial size 
may programs efficiently simulated algebraic circuits feasible boolean circuits 
interesting derive methods evaluating encrypted boolean circuits non interactively conceding information original circuit may revealed 
requirement hide information boolean circuit strong leads universal boolean circuits identified computationally infeasible 
applications hide partial information boolean circuit allows circumvent universal construction 
homomorphic encryption schemes structural requirements encryption functions map function 
start investigation looking systems enable computations encrypted data 
feigenbaum merritt asked question encryption function xy easy compute 
encryption functions rings having property stated called algebraic homomorphic encryption schemes 
ability serve encryption schemes non interactive computing encrypted data encrypted functions depends homomorphic properties specific homomorphic encryption scheme hes 
definition 
rings 
call encryption function additively homomorphic efficient algorithm plus compute reveal multiplicatively homomorphic efficient algorithm mult compute xy reveal mixed multiplicatively homomorphic efficient algorithm mixed mult compute xy reveal algebraically homomorphic additively multiplicatively homomorphic 
homomorphic schemes computing encrypted data feigenbaum merritt wonder exist algebraic homomorphic encryption schemes 
reason proposition 
algebraic homomorphic way trapdoor functions allow non interactive ced evaluation polynomials resp 
algebraic circuits 
proof 
assume algebraic additively multiplicatively homomorphic polynomial evaluated encrypted value 
protocol bob computes knowing 
alice computes private input 
alice sends function algorithms plus mult value bob 
bob writes program implements way coefficient replaced multiplication evaluation call mult addition evaluation call plus 
program bob computes 
bob sends back alice 
alice decrypts computes gamma obtains 
run value fact returns plus mult ab 
algorithms plus mult dependent bob form mobile code 
homomorphic schemes computing encrypted polynomials line algebraic homomorphic trapdoor functions hiding function data 
proposition 
algebraic homomorphic way trapdoor function allows non interactive cef polynomials resp 
algebraic circuits 
proof 
similar case ced encryption function encrypt coefficients time alice performs encryption alice creates program sends bob sending bob necessary compute input value feeding program imagine included program plus mult procedures 
bob simply runs fully selfcontained program pe input returns alice program output 

limits applicability due information leakage protocol property reveals non zero coefficients cleartext polynomial bob compute compare coefficients provided alice 
partial information polynomial leaked comparing coefficients encrypted polynomial adversary gets know coefficients cleartext polynomial equal different 
classes polynomials coefficients belong small subset scheme deterministic public key cryptosystem vulnerable low entropy attacks adversary computes table encrypted values expected coefficients decrypts looking coefficients table 
probabilistic encryption schemes secure type attack 
probabilistic encryption schemes family polynomials safely encrypted protocol 
family rsa encryption functions example vulnerable protocol non zero exponent look 
encrypted polynomial rsa function polynomially bounded number monomials adversary find secret key exhaustive search 
unfortunately secure general algebraic homomorphic encryption scheme known far 
desirable find hes perform cef proposition 
additively mixed multiplicatively homomorphic encryption scheme 
alice needs publish plus mixed mult realize cef proof 
alice creates program implements way coefficient replaced monomials evaluated input stored list list produced calling mixed mult coefficients elements added calling plus 
alice sends program bob 
bob runs private input obtains bob sends result back alice 
alice decrypts result applying gamma obtains 

case needs necessarily way function anymore needs disclosed alice plus mixed mult sufficient 
weakening requirements encryption scheme easier come scheme 
hand protection disclosure weak adversary gets know may compute arbitrary applying mixed mult pair 
nz cryptosystems seen useful cef encryption functions additively mixed multiplicatively homomorphic 
simple important observation nz cryptosystems property additively homomorphic implies second 
possible describe encryption schemes realize computing encrypted polynomials 
section discuss hes ring nz 
lemma 
additive homomorphic encryption function nz mixed multiplicative homomorphic 
proof 
construct algorithm mixed mult plus mixed mult xy 
assume log compute list log repeated addition plus 
obtain xy add 
corollary 
additively homomorphic encryption scheme nz 
mz allows cef polynomials 
proof 
combine proposition lemma 
algebraic schemes additively homomorphic schemes enable compute directly 
examples naccache stern public key ferrer privacy homomorphism 
cef 
naccache stern approach computationally infeasible guarantee correctness results polynomial calls plus general needed perform cef require system parameter chosen exponentially large 
ferrer privacy homomorphism mixed multiplicatively homomorphic 
encryption function published order perform cef 
security scheme processing encrypted data relies secrecy propose scheme problems 
scheme exponentiation exponentiation map gamma pz 
prime generator pz theta additively homomorphic function plus simple multiplication 
recover solve discrete logarithm problem believed hard 
alice chooses prime discrete log problem easy solve gamma small prime factors algorithm computing discrete logarithms efficiently 
chooses generator pz theta keeps secret 
alice corollary realize cef 

security scheme relies secrecy additively homomorphic encryption scheme discrete logarithms shortcoming published developed lipton sander 
scheme furthermore probabilistic significantly reduces information leakage original polynomial 
preliminary non interactive computing encrypted functions challenge cryptography 
theoretical results related cef produced vicinity computing encrypted data findings impractical respect computational feasibility 
approach studying algebraic homomorphic encryption schemes hes yields surprisingly simple scheme cef 
changing conditions looking polynomials boolean circuits obtained feasible non interactive solution 
advanced scrutiny show conditions scheme secure 
keep looking hopefully secure additively homomorphic encryption schemes 
offline digital signing malicious host agent carry keep secret 
answer certainly secret data agent long remains encrypted 
important point agent secret public compute digital signature order form disclosing secret needed 
section introduce concept digital signatures possible realization allows mobile agent effectively produce digital signature inside remote possibly malicious host host able deduce agent secret reuse signature routine arbitrary documents 
making digital signatures assume moment way conceal function produces digital signature cef approach 
problem real signature routine kept secret encrypted operational routine abused sign arbitrary documents simply signing process worthless 
need way glue signature routine function produces output signed 
practically useful remotely signed document look 
output producing routine example add document prefix saying digitally signed order form valid single airline ticket issued specific date costing certain amount dollars 
intention cast general purpose signing routine task specific information enforced part signed document 
give outline idea sign output function securely rational function 
rational function alice produce digital signature arbitrary message furthermore want message result rational function applied input data need function alice publishes order check validity digital signature regarded valid signature letting mobile agent create signatures alice computes dense representation signed ffi sends signed bob evaluates signed 
valid output algorithm pair signed 
applying verification function user check message valid output function bob wants pretend message valid output function construct 
security method lies inability construct unfortunately attacks scheme left decomposition attack rational functions ffi determine interpolation attack function public 
adversary produce list pairs 
rational function feasible reconstruct interpolation techniques 
observe function high degree size ffi dense representation explode 
described interpolation attack fact realistic threat secrecy 
interpolation attack ii adversary produce pairs obtains output function rational function reconstructed 
inversion attack bob able find preimage produce valid signature computing signed 
interpolation attack applies signature scheme low degree rational functions signing routine 
shamir introduced signature schemes signature routine rational functions interesting idea overcome difficulty going 
secure scheme attacks switch multivariate context notation bijective function components rational functions ring field 
called map 
ii inverse function ffi ffi id 
iii function output alice wants signed 
iv assume rational functions known public 
functions users alice obtain signing routines mobile programs 
ready describe modified scheme works public key public key signature verification function 
observe alice publish 
construction signed program alice chooses random rational function constructs map signed components signed ffi ffi alice computes dense representation signed sends functions signed bob 
execution signed program bob computes signed 
signed output program 
verification signature compute signature briefly describe modifications yield scheme strengthened attacks mentioned 
key point adversary know functions 
adversary know left decomposition attack obtain th component signed harder 
ii adversary know compute input output pairs interpolation iii adversary know compute input output pairs interpolation described second interpolation attack 
iv adversary able invert scheme broken 
adversary know know compute preimages 
note invert rational function adversary solve multivariate system algebraic equations 
problem known hard 
adversary able invert simple choices ways construct functions easy invert described shamir 
schemes proposed successfully attacked coppersmith stern 
expect ways construct secure maps concepts algebraic geometry maps extensively studied 
claim general solution main problem mobile agent protection produced evidences code partially protected malicious host 
identified special class functions polynomials rational functions encryption schemes lead non trivial example cryptographically hiding function executed non interactive protocol 
described approach hide digital signatures prevents signing procedure abused signing arbitrary documents 
thorough analysis security properties schemes remains done hope represent step fully software mobile code protection 
expect interesting surprising results field called mobile cryptography 

abadi feigenbaum 
secure circuit evaluation 
journal cryptology 

chess grosof harrison levine 
agents mobile computing 
technical report rc ibm march 

don coppersmith jacques stern serge 
attacks permutation signature schemes 
douglas stinson editor proceedings crypto number lncs pages 

dave dyer 
java decompilers compared 
www javaworld com javaworld jw jw decompilers html june 

feigenbaum merritt 
open questions talk abstracts summary discussions 
dimacs series discrete mathematics theoretical computer science 

josep ferrer 
new privacy homomorphism applications 
information processing letters 

don libes 
obfuscated mysteries 
wiley 

richard lipton tomas sander 
additively homomorphic scheme introduce partial trapdoor discrete log november 
preparation 

catherine meadows 
detecting attacks mobile agents 
proceedings darpa workshop foundations secure mobile code monterey ca usa march 

david naccache jacques stern 
new public key cryptosystem 
advances cryptology eurocrypt lncs pages 

franco preparata 
generation near optimal universal boolean functions 
journal computer system sciences 

ronald rivest len adleman michael 
data banks privacy homomorphisms 
demillo dobkin jones lipton editors foundations secure computation pages 
academic press 

adi shamir 
efficient signature schemes permutations 
douglas stinson editor proceedings crypto number lncs pages 

sriram 
java applet obfuscator 
www org html july 

giovanni vigna 
protecting mobile agents tracing 
proceedings third ecoop workshop mobile object systems jyv june 

joachim von zur gathen 
boolean circuits versus arithmetic circuits 
information computation 

ingo wegener 
complexity boolean functions 
teubner 

bennet yee 
mobile agents 
proceedings darpa workshop foundations secure mobile code monterey ca usa march 

richard 
rational function decomposition 
proceedings international symposium symbolic algebraic computation pages 
acm press july 
