european symposium programming april 
modular denotational semantics compiler construction sheng liang paul hudak yale university department computer science new haven ct sheng cs yale edu 
show benefits applying modular monadic semantics compiler construction 
modular monadic semantics allows define language rich set features reusable building blocks program transformation equational reasoning improve code 
compared denotational semantics reasoning monadic style offers added benefits highly modularized proofs widely applicable results 
demonstrate axiomatization environments prove correctness known compilation technique 
monadic approach facilitates generating code various target languages different sets built features 
propose modular semantics allows language designers add remove programming language features causing global changes existing specification derive compilation scheme semantic descriptions prove correctness program transformation compilation strategies generate code various target languages different built features 
goals similar action semantics related efforts example wand lee appel jim kelsey hudak :10.1.1.33.5381
existing approaches completely satisfactory achieving goals 
example long recognized traditional denotational semantics suitable compiler generation number crucial reasons lack modularity extensibility :10.1.1.33.5381
take advantage new development programming language theory monadic approach structured denotational semantics achieves high level modularity extensibility 
source language consider variety features including call name call byvalue versions functions arithmetic operations cbn cbv functions callcc class continuations ref deref imperative features supported advanced research project agency office naval research arpa order contract 
callcc arithmetic ops function calls assignments continuations lambda pure lambda calculus continuations store environment modular construction kernel callcc update err inenv rdenv error reporting fig 

organization modular monadic semantics modular monadic semantics organized 
language designers specify semantic modules set kernel level operations 
expression example interpreted low level primitive operation update 
known practice base programming language semantics kernel language novelty approach lies primitive operations organized 
framework depending support upper layers need set primitive operations put modular way abstraction mechanism called monad transformers 
monad transformers provide power needed represent notion programming language features allow access low level semantic details 
fact monad transformers defined higher order functions monadic semantics structured version denotational semantics conventional reasoning methods fi substitution apply 
investigate interpreter modular monadic semantics turned compiler 
section define compositional high level semantics source language guarantees unfold recursive calls evaluator avoid overhead dispatching syntax tree 
section show monad laws axioms optimize intermediate code 
demonstrate reasoning powers monad transformers section generalize wand proof correctness known technique overcome overhead dynamic variable lookups transforming variables source language variables meta language 
section discuss utilize modularity provided monad transformers target different languages 
contributions semantics directed compiler generation applying monad laws program transformation presenting monadic style axiomatization environments demonstrating reasoning monadic style enables better structure proofs obtain general results denotational semantics advantage monad transformer properties example naturality liftings utilize target language features 
results traditional denotational semantics style augmented haskell type declaration syntax express monads type constructors 
denotation semantics notation succinct real programming language haskell 
prior knowledge monads assumed 
modular monadic semantics section results earlier modular interpreters define modular semantics source language 
high level monadic semantics traditional denotational say term environment continuation answer 
contrast monadic semantics maps terms computations details environment store hidden 
specifically semantic evaluation function type term compute value value denotes result computation 
type constructor compute called monad 
abstracts away details computation exposing result type 
define monads formally note compute comes equipped basic operations compute 
compute compute return compute usually write infix form 
intuitively computation computes binds result computes return trivial computation simply returns result 
standard semantics value domain sum basic values functions 
functions map computations computations type fun compute value compute value type value int bool addr fun generality allows model call name call value 
standard semantics arithmetic expressions follows return value err type error return int int value primitive monadic combinator semantic function directly supported underlying monad compute err string compute report type errors 
clarity omit domain injection projection type checking 
just returns number injected value domain result trivial computation 
evaluate evaluate turn sum results 
denotational semantics interpretations arithmetic expressions slightly different depending passing environment write direct continuationpassing styles 
contrast monadic semantics arithmetic expressions stays matter details computation continuations environments states captured underlying monad 
function abstractions applications need access environment env maps variable names computations primitive monadic combinators retrieve current environment perform computation environment respectively type env name compute value rdenv compute env inenv env compute value compute value standard semantics functions follows rdenv ae ae rdenv ae return inenv ae rdenv ae inenv ae return difference call value call name clear reduces argument invoking function packages argument current environment form closure 
simplify presentation somewhat assume imperative features defined primitive monad combinator update store store compute store suitably chosen store 
read store identity function change store passing state transformer 
update returns entire state properly defined store manipulating functions guarantee store duplicated see example 
kernel level function callcc value compute value compute value compute value semantics callcc function expecting function argument current continuation passed callcc return callcc high level monadic semantics somewhat resembles action semantics uses return thread computations 
primitive monadic combinators operations powerful model various kinds control flows error handling function calls callcc sequential languages 
action semantics effort give high level view source language semantics 
require semantics specified terms monadic combinators compositional arguments recursive calls substructures argument received left hand side 
theoretical point view inductive proofs program structures possible 
practice guarantees syntax tree recursively unfold calls interpreter effectively removing run time dispatch syntax tree 
constructing compute monad clear monad compute needs support primitive monad combinators err string compute rdenv compute env inenv env compute value compute value update store store compute store callcc value compute value compute value compute value follow traditional denotational semantics approach time set domains implement functions 
major drawback monolithic approach add source language features functions may redefined 
sake modularity start simple monad add features 
simplest monad identity monad 
captures function application type id return id id monad transformer takes monad returns new monad added features 
example statet adds state monad type statet continuation type contt return contt ka contt callcc ka environment type envt return envt ae envt ae cae rdenv ae ae inenv ae ae ae errors type error ok error string type errort error return errort errort case ok kx error msg error msg err fig 

monad transformers return statet return statet see monad transformers apply statet identity monad id type statet id id 
return statet id return id statet id id note statet id standard state monad example wadler 
newly introduced state accessible statet introduces update applies state returns old state update statet update return gives definitions monad transformers including errors errort continuations contt environments envt 
construct compute applying series monad transformers base monad id type compute envt env contt answer statet store errort id env store answer type environment store answer respectively 
monad transformer function lift embeds computation monad 
functions err update rdenv easily lifted lift err lift delta update lift delta update rdenv lift liftings callcc inenv definitions lift monad transformer listed table callcc inenv ae lift envt ae ae ka ae ae ae cae ae contt ans statet ae cs errort ok ae map ok fig 

liftings issue remains addressed 
update function introduced statet compute contains features added monad transformers 
general problem lifting operations monad transformers 
gives brief summary useful liftings see detailed description 
example compute monad update ok introduced statet 
compute constructed update ae 
summary monad transformers allow easily construct monads certain set primitive monadic combinators defined higher order functions 
monad laws transform programs monadic semantics previous section unfolding calls semantic function transform source level programs monadic style code 
example transformed rdenv ae return inenv ae rdenv ae ae return return return return section formally introduce monads laws show laws simplify program 
monads monad laws definition 
monad type constructor operations 
return satisfying laws return left unit return right unit associativity intuitively left right unit laws say trivial computations skipped certain contexts associativity law captures basic property sequencing usually take granted programming languages 
verify equational reasoning example return id id satisfy laws envt contt transform monads monads 
applying monad laws program transformation monad laws useful transforming optimizing monadic style intermediate programs 
example compiler translates expression return return return apply left unit law twice reduce return course optimized return 
application monad law usually corresponds number fi reductions 
monad laws allow perform fi reductions right places avoid corresponding actual computations source program final reduction example turn may lead non termination 
knowledge environment handling operations inenv rdenv monad laws simplify example section rdenv ae inenv ae rdenv ae ae return return simplify look laws operations satisfy 
environment axioms axiomatize environment manipulating functions follows definition 
monad environment monad operations rdenv inenv satisfy axioms inenv ae delta return return unit inenv ae inenv ae inenv ae distribution inenv ae rdenv return ae cancellation inenv ae inenv ae inenv ae overriding intuitively trivial computation depend environment unit law environment stays sequence computations distribution law environment change set read intervening computations cancellation law inner environment outer overriding law 
proposition 
monads supporting rdenv inenv constructed monad transformers errort envt statet contt environment monads 
monad laws environment axioms verified equational reasoning 
equipped environment axioms transform example monadic code rdenv ae return return note explicit environment accesses disappeared 
metalanguage environment directly support function calls 
exactly partial evaluators achieve transform interpreters compilers 
true computation original expression left unreduced 
traditional denotational harder distinguish redexes introduced compilation process computations source program 
example safely reduce intermediate code return return return return fi return left unit general unrestricted fi reduction arbitrary source programs result unwanted compile time exceptions monad laws reason computations successfully transformed away explicit environment example arbitrary source programs 
turns prove general result monad laws environment axioms 
follow wand define natural semantics translates source language variables lexical variables meta language prove equivalent standard semantics 
natural semantics adopt wand definition natural semantics different kahn notion functional sub language 
source language variable name assume corresponding variable name meta language 
definition 
natural semantics uses environment meta language variables source language follows vm return return source level constructs callcc explicitly deal environment natural semantics standard semantics 
correspondence natural standard semantics theorem variation wand guarantees safe implement function calls source language meta language environment 
theorem 
program source language standard semantics environment monad natural semantics monad ae mapping source language variable names inenv ae emphasize modularity provided framework prove theorem functional sub language extend result complete language 
means natural semantics implicitly passing environment 
theorem stated strictly correspond wand result 
fortunately naturality liftings see earlier details guarantees adding removing feature affect computations particular feature 
theorem holds remove explicit environment support underlying monad natural semantics 
section addresses detail 
proof functional sub language establish theorem functional sub language induction structure programs composed variables lambda abstractions function applications 
full proof appendix 
basic technique wand addition basic rules lambda calculus fi reduction monad laws environment axioms 
proof possible source language meta language lexically scoped 
source language supported dynamically scoped functions return rdenv ae inenv ae caller site environment function body theorem fail hold 
extension complete language consider source language construct callcc 
proving theorem axioms environment monads cases analyzed need proved 
verify monad supporting continuations environment monad induction hypothesis holds callcc 
stated proposition proved come monad transformers 
easily proved callcc explicitly deal environment exactly natural semantics standard semantics 
addition trivial computation see definition section 
induction hypothesis holds unit axiom environment monads 
similarly extend theorem cover features 
benefits reasoning monadic style modular proofs denotational semantics adding feature may change structure entire semantics forcing redo induction case syntax 
example wand pointed change semantics continuation prove theorem modifying proofs accordingly 
modular monadic semantics hand offers highly modularized proofs general results 
particularly applicable real programming languages usually carry large set features undergo constantly evolving designs 
axiomatization programming language features denotational semantics captures computation piece syntax tree coupled environment store hand view computations entities set equations 
semantic algebras action semantics monads provide axiomatic view denotational semantics 
environment axioms provide answer question constitutes environment 
investigating useful axioms programming language features exceptions continuations 
targeting monadic code general efficient target language built features monadic combinators defined higher order functions 
seen explicit environment absorbed meta language 
section addresses question features store continuation 
view target language having built monad supporting set primitive monadic combinators 
example table lists correspondence certain ml constructs primitive monadic combinators primitive monadic operators ml construct return val update ref callcc callcc err raise err ml cells support single threaded states 
easy verify monad laws satisfied context 
example ml construct associative assuming unwanted name occur val val val val recall section compute monad constructed type compute envt env contt answer statet store errort id substitute base monad id built ml monad call ml type compute envt env contt answer statet store errort ml note compute supports sets continuation state error handling functions 
monadic code choose ml built ones implemented higher order functions 
addition liftings construct satisfy called naturality liftings adding deleting monad transformer change result programs operations 
monad transformers compute suffices run target program compute type compute ml directly utilizes efficient ml built features 
transformation possible ml strictly richer set features source language 
source language requires version state example purpose debugging corresponding state monad transformer remain ensure state threaded correctly computations 
target source language environment continuation transformers kept 
monad set primitive monadic combinators expose features embedded target language 
clear directly supported target language needs compiled explicitly 
process trivial impossible working traditional denotational semantics 
various features clutter hard determine safe remove certain interpretation overhead achieve 
earlier shown order monad transformers particular cases involving contt resulting semantics 
practice need sure discard monad transformers resulting change ordering unwanted effects semantics 
related early efforts semantics directed compiler generation traditional denotational semantics 
mosses semantics specification programming language semantics efficient compilers generated 
action semantics related approach lee successfully generate efficient compilers :10.1.1.33.5381
action semantics easy construct extend understand implement note comments mosses page foundations action semantics firm theory reasoning actions programs weak needs development 
situation marked contrast denotational semantics theory strong severe pragmatic difficulties hinder application realistic programming languages 
action semantics provided inspiration essentially attempts formulate actions denotational 
monad transformers roughly correspond facets action semantics issues concurrency power approach 
moggi monads monad transformers structure denotational semantics 
wadler popularized moggi ideas functional programming community monads functional programs particular interpreters 
built monad modular interpreters turn follows series earlier steele jones duponcheel espinosa 
moggi raised issue reasoning monadic framework 
wadler listed statemonad laws 
hudak suggested amore general framework mutable data types reason states 
meijer combined standard initial algebra semantics approach aspects action semantics derive compilers denotational semantics :10.1.1.17.268
interesting area research combine nice algebraic properties meijer framework modularity offered 
application partial evaluation automatically generate compilers interpreters 
partial evaluator successfully applied action interpreter similar results achieved monadic interpreters 
staging transformations proposed scherlis class general program transformation techniques separating computation stages 
monad transformers stages somewhat explicit separating compile time features environment run time features 
researchers including kelsey hudak appel jim built efficient compilers higher order source language continuation passing style cps 
suitability monadic form intermediate form observed researchers including example sabry felleisen hatcliff danvy 
continue explore direction order generate machine level code monadic intermediate form 
shown monadic framework provides support highlevel extensible specifications program transformations reasoning computations code generation various target languages 
monadic style proofs better structured easier extend 
modular monadic semantics allows axiomatized formulation known programming languages features environments 
believe modular monadic semantics particularly suitable compiler construction 
anonymous referees useful suggestions zhong shao satish pai dan rabin pepm proposed syntactic approach modularity denotational semantics 
anonymous referees helpful comments earlier version ross paterson tim sheard john launchbury ideas discussions 

andrew appel trevor jim 
continuation passing closure passing style 
acm symposium principles programming languages pages january 

anders bondorf jens palsberg 
compiling actions partial evaluation 
fpca conference functional programming computer architecture copenhagen denmark pages new york june 
acm press 

brown watt 
actress action semantics directed compiler generator 
proceedings th international conference compiler construction edinburgh pages 
springer verlag 
lecture notes computer science 

pietro eugenio moggi 
syntactic approach modularity denotational semantics 
category theory computer science 

cl ement jo elle despeyroux thierry despeyroux gilles kahn 
simple applicative language mini ml 
proceedings acm symposium lisp functional programming pages 

olivier danvy urgen 
compiling monads 
technical report cis kansas state university december 

david espinosa 
modular denotational semantics 
unpublished manuscript december 

john hatcliff olivier danvy 
generic account continuation passing styles 
st acm symposium principles programming languages popl portland oregon pages new york january 
acm press 

paul hudak 
mutable datatypes 
research report yaleu dcs rr yale university department computer science december 

paul hudak simon peyton jones philip wadler 
report programming language haskell non strict purely functional language version 
technical report yaleu dcs rr yale university department computer science march 
acm sigplan notices vol 
may 

mark jones luc duponcheel 
composing monads 
research report yaleu dcs rr yale university department computer science new haven connecticut december 

neil jones peter sestoft harald sndergaard 
mix self applicable partial evaluator experiments compiler generation 
lisp symbolic computation 

ulrik william scherlis 
compilers staging transformations 
proceedings thirteenth acm symposium principles programming languages st petersburg florida pages 

richard kelsey paul hudak 
realistic compilation program transformation 
acm symposium principles programming languages pages january 

david king philip wadler 
combining monads 
john launchbury patrick sansom editors functional programming glasgow pages new york 
springer verlag 

peter lee 
realistic compiler generation 
foundations computing 
mit press 

sheng liang paul hudak mark jones 
monad transformers modular interpreters 
nd acm symposium principles programming languages popl san francisco california new york january 
acm press 

erik meijer 
advice proving compiler correct improving compiler 
submitted journal functional programming 

eugenio moggi 
view programming languages 
technical report ecs lfcs laboratory foundations computer science university edinburgh edinburgh scotland 

peter mosses 
basic semantic algebra 
gilles kahn david macqueen gordon plotkin editors semantics data types international symposium pages 
springer verlag june 
lncs 

peter mosses 
action semantics volume cambridge tracts theoretical computer science 
cambridge university press 

amr sabry matthias felleisen 
reasoning programs continuationpassing style 
proceedings acm conference lisp functional programming pages 
acm press june 

guy steele jr building interpreters composing monads 
conference record popl st acm sigplan sigact symposium principles programming languages portland oregon pages new york january 
acm press 

joseph stoy 
denotational semantics scott strachey approach programming language theory 
mit press 

philip wadler 
essence functional programming 
conference record nineteenth annual acm symposium principles programming languages albuquerque new mexico pages january 

philip wadler 

proceedings acm conference lisp functional programming 

mitchell wand 
semantic prototyping system 
sigplan notices acm symposium compiler construction 

mitchell wand 
short proof lexical addressing algorithm 
information processing letters june 
proof theorem main theorem proved induction structure programs case inenv ae inenv ae rdenv ae return inenv ae inenv ae rdenv ae inenv ae return inenv ae dist return ae ae return inenv ae cancel unit return inenv ae left unit return inenv ae ff renaming return ind hypo 
cases similarly proved 

