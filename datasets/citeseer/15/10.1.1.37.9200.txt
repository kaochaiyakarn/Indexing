heap compression binary haskell malcolm wallace colin runciman dept computer science university york uk coling cs york ac uk new facilities haskell described compression data values memory new scheme binary facilities individually combined binary representations values 
heap compression memory valuable enables programs run smaller machines conversely allows programs store data amount memory 
binary valuable file storage retrieval heap data structures smooth painless 
combination heap compression binary allows data transfer fast space efficient 
facilities described implemented variant nhc compiler 
example applications demonstrated performance results space speed 
data representation implementors lazy functional languages tend internal representation data uniform graphs heap cells 
value atomic occupying unit space structured components occupies unit space turn atomic value pointer structured value 
reasons memory model 
functional programming systems little distinction values expressions memory cell capable representing form 
functions may polymorphic useful unit memory space able hold value expression type matter simple complex 
various occasions internal representation inconvenient 
static data 
programs large quantity essentially static data import table compiler dictionary natural language processing system 
standard representation data somewhat bulky 
reasons standard representation apply data fully evaluated early computation contains expressions type fully known remaining polymorphism 
situation compact representation allow data stored 
care overhead garbage collection reduced 

secondary storage 
programs perform output intention able retrieve information secondary storage input operation 
instance applications save user configuration preferences runs compilers generate interface files read back compilation separate modules 
haskell standard mechanism allows program data transferred textual representation 
requires expensive translation output input stages 
convenient able binary data representation memory files cheap bulk transfer 
standard graph representation lend approach 

foreign language interfaces 
haskell programmer may occasionally wish call routine written instance perform system call 
data holding semantic information frequently represented differently language passing 
ability define common representation convenient 

embedded systems 
device control related programs high level view certain data structures control monitoring 
stage structures mapped narrow individual machine registers 

communication 
form dynamic transmission data processes network machine hindered rely shared memory model textual representations 
show programmer control data representation little compromise high level abstraction facilities functional languages attractive 
provide means internal representation program data specified fine grained binary level 
type value determine represented sequence bits 
functions defined transfer value standard graph representation compressed bit sequences 
conversion functions form methods type class 
small set primitive operators definition conversion functions monad sequencing 
instances compression type class derived automatically compiler 
programmer define custom instances 
extension library provided allowing values transferred functional program rest world compact binary form 
examples underlying facilities described implemented nhc version 
leave question data representations foreign language interfaces embedded systems control interesting lines 
see earlier embedded systems 
motivation funded canon research centre europe developing complex software new ranges products 
functional languages attractive reasons programmer productivity ease rapid prototyping maintainability emerging software 
benefits bring product market quickly considerable commercial advantage 
issues concern 
saving memory space final product 
achieving fast efficient 
interfacing product modules written 
running software embedded product 
communication multiple processes 
important issue commercial perspective probably saving memory leads direct saving mass production costs 
sets scene compressing heap data performing binary outlined common theme underlies issues data representation 
declarative solution representation problem potential address challenges software engineering arena 
class types bit vector representations recap data functional language system usually represented linked graph structure link terminal node typically occupies machine word 
possible type information values squeeze representation smaller sequence bits 
types compression type admits just different values value type represented log bits 
clear applied enumerated type nullary constructors 
observation applies structured types 
haskell structured data value type consists ary constructor followed sequence values belongs type gamma structured value represented binary form vector bits 
portion vector identifies constructor remainder vector sequence values represented binary form 
data type constructor different values type may occupy different amounts memory 
precise details bit vector representation differ type type obvious mechanism ad hoc polymorphism type classes 
class compress compress io bin expand bin type bin type implemented extension haskell runtime system 
notice compress function uses monad expand function 
monad primarily enforce correct sequence operations compression 
compress strict argument 
objects compressed lazily idea save space lazy compress easily retain closure containing original full sized value day compressed version 
reason expansion operation remain pure lazy 
known components compressed value needed computation sense enforce strictness sequencing monad 
discuss arrangement section 
implementation issues order able write instances compress introduce primitives 
int int io bin int bin int bin intuition writes integer value bit vector width returning pointer vector 
conversely reads integer value width bits vector returning value pointer remainder bit vector value just read 
bit vectors stored 
purposes convenient store vectors heap separate area memory garbage collected 
creating bit vector area memory treated sequential file internal state determining writing value 
operation glue bit vectors 
explicit sequence operations performed compression ensures vectors placed 
polymorphic return types ensure type inference system regard simple pointers correctly typed 
class system ensures type safety selecting correct instances compress expand values involved particular computation 
small example truth trees shows datatype binary trees booleans instance definitions needed order compress example tree standard graph representation nhc boolean occupies word branch occupies words leaf occupies word 
total space needed represent worst words best assuming maximal sharing words 
implementations gofer words branch bringing total words 
bit packing scheme bit sufficient distinguish branches leaves bit distinguishes true false 
total compressed occupies exactly bits 
better order magnitude saving compression ratio depending word size extent sharing 
clearly example best case due high compressibility booleans shall obtain worthwhile compression ratios realistic applications see section 
derived explicit instances tedious write explicit compress instance definitions datatype program 
compression scheme described regular modified nhc compiler generate instances compress automatically datatypes deriving clause example data tree branch tree tree leaf bool deriving compress programmer free try aggressive compression algorithms defining custom instances compress class 
experimented alternative coding schemes knowledge expected frequency values great advantage 
example written haskell program takes simple value frequency table type generates haskell module containing appropriate instance declarations huffman compression 
experience specific applications huffman coding roughly double compression ratio 
fruitful avenues compression especially character strings 
data tree branch tree tree leaf bool instance compress bool compress expand fst instance compress tree compress leaf compress return compress branch compress compress return expand case leaf expand expand expand branch tree branch branch branch leaf true branch leaf false leaf true branch leaf false leaf true leaf false compression truth trees 
full bit vector 
limitations compressible types seen compress function strict 
means compression really suitable data largely static may computed remains constant useful rest program run 
examples applications noted compiler import table natural language dictionary configuration options gui 
limitations representation scheme outlined 

compression sharing original structure lost lined copy site sharing 
inevitable purpose compression flatten links graph structure keeping terminal values sequence 
result restriction cyclic infinite structures compressed 

heap representation functions compressed code segment address reduced size 
certainly possible compress code expanding needed 
just time dynamic compilation showing results area see instance wakeling 
main idea function code generated compact bytecode representation 
expanded runtime fly compiler native code stored temporarily heap 
heap full native code thrown away 
bytecode compiled required 
example application dictionary types realistic illustration value runtime data chosen small significant part nhc haskell compiler useful stand tool 
compiling module contains import declarations nhc reads interface file imported module 
interface file contains type declarations instance declarations function names annotated type 
declarations needed type inference importing module 
interface files stored textual format issue shall return section parsed internal tree structure representing types 
normal circumstances type data retained type checking phase compilation discarded 
re interface parser writing browser type information 
interface files read stored hashed lookup structure 
user enters function names interactive command line tool reports types functions 
simple database application database contains recursively structured information pure text 
data structure database simple indexed binary tree type outlined 
addition standard tree operations version embedded monad called ensures updated tree built program continues way avoiding build permits mapped function monad instance compress 
entries tree buckets function name type pairs 
simple hash function name produce index tree 
names collide index store entries bucket 
choosing appropriately sized tree average bucket size small bucket efficiently represented just list 
data leaf fork int int returns th entry tree int applies function leaf tree int io io applies monadic function leaf tree returning result monad index tree operations 
introducing compression appropriate level introduce compression lookup structure buckets entries whilst index structure relatively small accessed frequently buckets individually relatively large accessed infrequently 
equally choice compress individual entries buckets 
gives outline main program 
omit datatype definitions requests derived instances strings pairs type declaration trees 
program builds performs lookup 
differs compression program definition monadic function single application expand shown bold type 
results test type browsing tool supplying input interface file standard prelude requesting type prelude functions 
compare speeds 
compressed version inevitably slower access rate standard version 
compare memory space finding compressed version compact standard version expected 
time compression takes read file parse build index tree retrieve display entries turn 
gives rate discounting initialisation time entries returned second total computation time 
int decl io string decl string decl io bin string decl compress main hi inp inp inp pt pt cpt browse cpt browse cpt putstr type browser getline inp mapm putstrln snd map select cpt words inp select cpt filter fst expand hash cpt type browser tool compression takes seconds read file parse build initial index tree 
takes seconds compress entries new tree followed seconds retrieve display entries turn 
gives rate discounting initialisation time entries returned second total computation time 
space compression parsing stage uses peak kb followed constant usage kb heap memory lookup stage 
compression parsing stage uses peak kb followed constant usage kb heap memory lookup stage kb heap bit vectors totalling kb 
example application compression ratio greater 
studied applications demonstrate broadly similar compression ratio 
issues raised example main problem program stands compression achieved lookup worthwhile space profile dominated requirement large initial heap data compressed 
large proportion time space computation devoted initial parsing text file 
compression stage accounts significant part time compensated subsequent reduction space usage 
wonder kb space needed parsing data structure turns need kb excessive due poor choice parser combinators 
parser combinators common components nhc designed space efficiency 
possible solution space problem rework program structure greater laziness compress parse having essentially separate passes data 
solution addresses time problem space problem store compressed data directly binary file 
text file parsed compressed subsequent uses avoid stage load binary representation directly 
section describes added binary file haskell manner analogous compression 
class types binary convenient able perform directly heap memory order store data structures file different run program transmit values processes 
linked graph model heap tricky implement 
form flattening required value amenable storage transmission 
current standard haskell mechanism transferring data conversion textual format show read classes 
having benefit readability approach inefficient 
implementations read class rare programmers frequently write custom parsers haskell data 
seen slow memory hungry 
scheme heap data compression offers alternative flattening operation follows uniform pattern textual classes derived automatically datatype restrictions noted earlier section 
binary library ideas efficient parsing printing text 
programmer view define type class values transmitted binary format 
class put io get io type type analogous ordinary text file handle specific binary files 
compress expand put get operations return results monad dealing true note get take pointer value argument 
reads values file sequentially starting current position recorded state monad 
instances class written primitives int int io int io int intuition writes integer value field width bits current position file denoted conversely reads integer value width bits current position file returning just value implicitly updating file pointer 
explicit sequence operations performed output input ensures components value placed file read back order 
various auxiliary functions needed complete library operations open close binary files 
just mirror existing operations textual library 
io io implementation buffering buffering required binary files complicated textual files 
textual assumes value transferred number bytes minimum buffering unit byte 
binary possible transfer single bit time 
approach taken prototype implementation layer second buffer top standard buffers 
second layer consists single byte file output accumulates bits full time flushed ordinary byte oriented system input receives byte ordinary system drained bit bit haskell program 
implemented mechanism haskell module 
truth trees revisited recall binary trees booleans section 
instance definitions binary bit en instance bool put get return instance tree put leaf put put branch put put get case get return leaf get get return branch binary instances truth trees 
coding compression shown 
derived automatically compiler 
bit transfer memory files broad similarity compress classes 
binary representation produced interpreted memory file 
aims developing binary identity representation increase efficiency transfer 
situation described far permits values standard graph heap representation put files retrieved 
compressed representation wanted memory file value pass standard representation suffering process similar translations 
need instance class memory compressed bin types special primitives implement bulk transfer binary values 
instance bin put get scheme hidden difficulty 
bulk transfer efficient size value known 
size known transfer remain interpretive bin values variable size 
fortunately oversight easy correct cost little overhead space 
introduce new type sized binary values extend compress class subclass simply attaches size information compressed values see 
newtype sb int bin class bin io compress bv bv return sb bv sb bv expand bv instance put sb bv put bv get get bv return sb bv sized binary values efficient bulk instances need written default definitions class declaration sufficient 
new instance types implement bulk transfer correctly placing reading size binary value immediately value 
note size need attached outermost structure value internal structure value may comprise compressed components stored sizes 
extra space needed storing size information reduce cancel benefit compression applied values modest size 
intention program attach sizes larger compressed values involved bulk larger complex compressed value valuable transfer bulk smaller proportion space taken size information 
serious space cost associated bulk transfer bits 
problem potential misalignment values 
imagine file pointer set bit memory compression pointer set bit immediately transfer takes place 
possible fix alignment byte byte transfer detrimental efficiency 
alternative insist sized binary values exactly aligned byte boundary 
average solution costs bits value extra bits needed pad value byte boundary 
minor cost compared paid store sizes 
practice byte alignment easy implement 
extension random access file radical way avoid remaining costs bulk memory storage large data structures compute data structure held entirely compressed form file 
common technique database world 
main requirement available need random access files compressed data 
achieve extension binary class class io io intuition new operations returns pointer start location value uses pointer find value 
values new type refer specifically file 
implementation level contain byte offset start file bit offset referenced byte 
programmer file pointers sensibly correct files 
difficult issue permissible read write random access binary file 
possibility intermixed read write access complicate implementation buffering 
moment disallow possibility point principle keep things simple 
type dictionary revisited return type browser tool section illustrate facilities binary new versions tool file direct binary transfer memory version type tool textual parsing take long time compression took similar amount time 
eliminate stages computation storing compressed data structure file program runs 
shows additions original program order store entire data structure file reload subsequent runs 
layered compression point worth noting example type value stored file 
bin string decl main hi inp inp inp pt pt cpt cpt db dat db put db db return db dat db get db db cpt browse cpt direct binary transfer memory 
entries leaves index tree compressed index tree compressed 
happens compressed value compressed virtue residing value 
bit vector simply copied line modification 
outer value expanded inner compressed values simply remain compressed form true type signature 
example stages compression stages expansion 
result tree branch structure heap leaves compressed entries 
indexed binary files far indexed data structure containing compressed entries loaded way memory 
illustrate compressed entries indexing structure may stored files 
intention store data entries file file pointers data file different index file 
index file flat containing just sequence file pointers 
lookup proceeds follows apply hash function string key giving integer read th entry index file value pointer data file retrieve true compressed entry 
similar mechanism previous systems example library database routines 
shows version program indexed files 
gloss issue file pointer arithmetic easy program tedious read 
pointer arithmetic needed simply allow th value compressed size read index file starting th bit 
string decl io bv bv fp put fp main pt browse browse putstr type browser getline inp mapm select mapm putstrln snd words inp select hash fp fp return filter fst indexed binary files 
results test new versions type browsing tool supply input interface file standard prelude request types prelude functions 
time reading entire structure binary file memory takes read file perform stage decompression retrieve display entries turn 
gives rate discounting initialisation time entries returned second total computation time 
index structure stored read files takes read text parse build initial index tree write new files retrieve display entries turn 
gives rate discounting initialisation time entries returned second total computation time 
initial time space kb data 
set queries set queries text heap text bits bits text table time space costs different versions type dictionary program type function prelude requested 
index structure kept precomputed files takes prepare reading retrieve display entries turn 
gives rate discounting initialisation time entries returned second total computation time 
space entire structure read binary file memory initial parsing stage 
memory usage peaks kb heap averages kb heap plus constant kb heap bit vectors 
index structure kept precomputed files parsing stage 
memory usage peaks kb heap averages kb heap 
bit vectors memory 
files occupy kb data bytes index 
complete comparison earlier versions tool shown table 
seen clearly initial done store data structure binary file quicker read binary file re parse textual equivalent 
access individual entries slower interpretation deferred moment expansion 
complete traversal compressed structure takes time original version tool took parse text file traverse lookup structure 
related hbc compiler library defines class native conversions 
methods convert value list bytes textual differences compression class data representation byte oriented bit oriented byte vectors untyped monadic sequencing control evaluation order conversion 
intended native class probably foreign language interfaces data transmission processes file system network 
scheme permits flexible style data compression addition applications 
johan jeuring working polytypic scheme data compression 
close correspondence polytypic programming type classes 
jansson jeuring language system polyp provide facilities 
method separates value structure content compressing structural component similar manner scheme relying standard textual methods compress content 
structure content represented entirely distinct segments final bit sequence contrast method retains close connection 
terms truth tree example structure branches leaves tree written binary sequence padded byte boundary followed binary representation list booleans drawn order traversal tree 
method primarily directed transmission structured values network scheme encompasses compression intended improve single program space performance 
course wide literature compression algorithms see example comprehensive survey hirschberg 
declarative approach bit level data representation opens new application areas functional languages 
implemented mechanisms types computation demonstrated examples 
computing large data structure held compressed form memory 

storage retrieval large data structure binary file full representation memory 

computing large data structure held compressed form memory bulk storage retrieval binary file 

computing large indexed data structure held entirely files memory 
compression scheme derived automatically datatypes standard pattern gives significant space savings 
leaves programmer free try aggressive compression algorithms defining custom instances compress class 
suggest typically heap compression considered programmer program complete profiled identify correct space faults 
profile reveals large amount data occupying heap data really needed opportunity compress taken 
compression binary improve performance haskell compilers 
recall type browser tool initially reads machine generated interface files produced nhc 
profiling significant portion time taken separately compile module spent reading interface files imported modules 
interface files stored binary files textually conjecture compiler run consistently faster 
human readability short fast program translate binary format text provided 
applications benefit ability manipulate values compact binary representations particularly desirable hold large amount information main memory 
examples include databases natural language processing image processing 
uses bit vector representations time explore include description machine registers embedded systems control marshalling data foreign language interfaces 
valid criticism compression class uses monad description binary representations somewhat imperative 
possibility declarative description representations deserves investigation 
description basic combinators juxtaposition placing bit vectors side side alignment padding trimming 
difficulty treatment strictness force compression values 
second criticism compression binary classes instances hand written define functions conversion directions 
opens possibility errors value created operation correctly read back 
operations sense inverses 
facility define single description binary representation provided conversion operations derived 
raises issue convergence classes 
binary compression similar default representations 
possibility error introduced custom instances written hand may fail match 
extent operations merged single class regarding heap bit vector memory just special sort file 
closest exists classes compress important difference expand pure function monad 
distant possibility data compression expansion applied parts heap automatically 
scheme programmer judiciously select data structures apply compression expansion functions textually memory management system able identify long lived portions heap transparently compress garbage collection allowing re expansion lazily need 
due canon research centre europe wholly funded 
huffman 
method construction minimum redundancy codes 
proc 
ire 
jansson jeuring 
polyp polytypic programming language extension 
proc 
th acm symp 
principles programming languages popl pages paris january 
acm press 
jeuring 
polytypic data compression 
preparation 
jones 
implementation gofer functional programming system 
technical report department computer science yale university may 
hirschberg 
data compression 
acm computing surveys september 

garbage collection memory efficiency lazy functional languages 
phd thesis department computer science chalmers university technology sweden 

highlights nhc space efficient haskell compiler 
proc 
th intl 
conf 
functional programming languages computer architecture fpca pages la jolla june 
acm press 
runciman 
virtual terminal 
runciman wakeling editors applications functional programming pages 
ucl press 
runciman 
heap profiling space efficiency 
launchbury meijer sheard editors nd intl 
school advanced functional programming pages wa august 
springer lncs vol 

dix 
efficient binary transfer pointer structures 
software practice experience 
wakeling 
throw away compiler lazy functional language 
takeichi ida editors fuji intl 
workshop functional logic programming pages japan july 
world scientific 
wallace 
functional programming embedded systems 
thesis department computer science university york january 
wallace runciman 
lambdas functional programming embedded architecture 
proc 
th intl 
conf 
functional programming languages computer architecture fpca pages la jolla june 
acm press 

