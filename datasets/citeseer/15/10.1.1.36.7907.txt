normalizing incomplete databases leonid libkin bell laboratories mountain avenue murray hill nj usa mail libkin research att com databases incomplete presence disjunctive information due conflicts partial knowledge reasons 
queries databases ask questions various possibilities encoded stored data stored data 
normalization mechanism asking queries lw exponential space complexity 
main goal develop general theory answering queries incomplete databases disjunctive information design practical algorithms query evaluation 
define semantics databases prove normalization theorems set bag complex objects 
theorems provide programming primitives needs order obtain list possibilities encoded complex object disjunctions 
study ways making query evaluation faster space efficient 
partial normalization allows disregard disjunctions affect query 
design new normalization algorithm produces objects represented incomplete database 
linear space complexity allows speed classes queries 
algorithms implemented existing dbpl 
experimental results demonstrate substantial improvement standard algorithms space time 
information stored databases usually incomplete 
typical sources partiality null values il disjunctive information occurs primarily areas design planning noticed inv inv 
may arise due conflicts occur different databases merged 
number approaches querying databases disjunctions known literature 
idea trees develop new object oriented data model ad hoc query facility exploited inv inv 
query complexity model analyzed 
functional query language databases disjunctions designed lw implemented gl 
papers kinds queries distinguished structural queries ask questions data stored database conceptual queries ask questions data encoded information database 
illustrate difference structural conceptual queries consider example incomplete design borrowed gl see 
theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta phi phi phi phi design incomplete design vertical horizontal lines represent subparts included design sloping lines represent possible choices 
example design consists parts consists structural queries ask structure object 
example expensive choice subparts examples structural queries 
conceptual queries ask questions possible completed designs 
example completed designs completed design costs reliability examples conceptual queries 
distinguish ordinary sets collections disjunctive possibilities call sets see inv lw rou 
hi denote 
example design represented set fa bg set ha set hw ki 
note sets distinct representations 
respect structural queries sets behave sets respect conceptual queries set denotes elements 
example structurally element set conceptually integer equals 
mechanism answering conceptual queries complex objects sets called normalization lw 
roughly speaking provides small number programming primitives repeatedly applied object create set lists possibilities encoded completed designs 
set called normal form conceptual queries simply structural queries normal forms 
normalization lw provides solid theoretical foundation developing languages conceptual queries formulated 
led development prototype gl 
theoretical problems addressed order develop practical methods answering conceptual queries 
ffl sets considered inv inv lw rou practical languages bags multisets 
past years approaches design bag languages proposed 
approaches agree constitutes basic set bag operations alb gm lw lw 
believe normalization mechanism extended bags 
ffl normalization may cause exponential blowup size objects 
objects size size normal forms bounded roughly delta lw 
need better normalization tools 
possibility normalize partially 
disjunctions affect conceptual query asked need unfold disjunctions 
problem partial normalization addressed literature 
ffl normalization lw requires normal form created conceptual queries asked 
exponential space complexity 
alternatively may want produce normal form elements completed designs making space usage linear 
main goal address shortcomings normalization process 
outcome shall better tools querying databases disjunctive information better understanding structure 
main contributions listed 

rigorously define normal forms conceptual semantics objects sets prove normalization theorems giving small number operations construct normal forms 
set bag semantics 

prove partial normalization result tells normalization process need completed order answer conceptual query 
give restriction types objects done 

design linear space algorithm produces elements normal form suggest new programming primitive 
primitive allows express number important queries including class existential conceptual queries uniform fashion 

consider interaction disjunctive information traditional forms partial information represented orders objects prove normalization partial normalization theorems setting 

implement new space efficient algorithm system querying databases disjunctions gl 
compare standard algorithm demonstrate substantial improvement 
show new programming primitive heuristics answer conceptual queries approximately normalization process expensive 
organization 
define structural semantics normal forms section 
normalization theorems sets bags partial normalization theorem proved section 
normalization algorithm programming primitive section 
normalization presence partial information studied section 
experimental results section 

approach disjunctive information form partial information confused disjunctive deductive databases lmr 
differences approaches see inv inv 
semantics normal forms mentioned objects sets treated structural conceptual levels 
consequently different semantics objects 
treats sets collections takes account set denotes elements 
state precisely define types objects 
type systems interest dealing sets multisets bags st theta ftg hti bt theta hsi ranges collection base types integers booleans theta product type elements pairs type type values set type ftg finite sets elements type values fjtjg hti finite bags sets values type respectively 
fin stands finite powerset family finite bags assuming domain base type define structural semantics types follows ffl ffl theta theta ffl ftg hti fin ffl fjtjg object type type system st called set complex object 
object type bt called bag complex object 
object containing sets called 
need translations st bt set bag objects 
type st define bag bt replacing set brackets bag brackets 
type set defined bag brackets replaced set brackets 
object st type define bag type bag replacing set bag elements multiplicities equal 
example bag fj jg fj jg 
conversely bt type set type set defined replacing bag set containing elements bag duplicates eliminated 
example jg fj set ff gg 
noted bag set st type set bag bt type bag set object necessarily case set bag bag object define conceptual semantics called normal form need notion skeleton type 
skeleton sk type defined type formed removing set brackets sk sk theta sk theta sk sk ftg sk fjtjg jg sk hti sk 
define binary relation objects meaning intuitively conceptual representation 
example design iff completed design 
ffl base type iff ffl iff ffl fjx jg fjx xn jg iff exists permutation oe ng oe ffl fx fx iff exists partition xn fx ffl hx iff 
recall set denotes elements 
note set clause ask permutation elements fx xng satisfy oe may fx set 
need partitions 
definition 
object normal form nf defined set hx xn objects note normal form finite 
lemma type type sk 
particular object type normal form nf type words normal form object lists possibilities encoded disjunctions object 
normal form entry regular complex object sets 
normalization theorems general idea normalization theorems give list operations repeatedly applied object normal form produced 
list lw go aspects 
clearly distinguish set bag semantics 
second prove partial normalization result viewed normalization intermediate types 
standard normalization theorems find unique representation object type type partial normalization result finds representation type guarantee uniqueness restrictions types imposed 
need language express operations normalizing objects 
adopt framework lw turn finds origins ab bbn 
operators general types 
recall briefly semantics general set operators 
ffi composition functions pair formation 
second projections 
returns unique element special base type unit eq equality test id identity cond conditional 
set operations function represents constant fg forms singletons fxg takes union sets flattens sets sets ff gg map applies elements set ae pair ae operators sets exactly operators sets prefix added 
operators bags similar sets additive union adds multiplicities 
flattening bags additive bn jg bn ff ff provide interaction sets sets bags sets 
assume fx xn fjy yn jg hx hy family choice functions ng general operators ffi theta theta theta unit eq theta bool id bool cond operators sets unit ftg ae theta ftg fs theta tg ftg theta ftg ftg ftg map fsg ftg ftg operators bags unit fjtjg ae theta fjtjg theta fjtjg theta fjtjg fjtjg fjtjg map fjtjg fjtjg operators sets khi unit hti ae theta hti hs theta ti hti theta hti hti hti map hsi hti hti interaction ff ff operators nrl nrl ff hfx ng fi ff njg fi main difference definitions duplicates removed sets bags 
example ff fh ig evaluates hf gi ff ijg equal jg fj jg fj jg fj 
definition see lw 
language nrl type system st includes general operators set operators set operators ff 
language nrl type system bt includes general operators bag operators set operators ff 
normalizing types define rewrite rules types theta hti hs theta ti hsi theta hs theta ti hti define rewrite system str st types rules line 
rewrite system btr bt types defined top rules 
notation gamma gamma 
rewrites zero steps 
recall dj normal form rewrite system term rewritten 
proposition see lw str btr terminating church rosser rewrite systems 
consequently type unique normal form calculated type involves sets 
normalizing complex objects suggested lw assign functions language rewrite rules rewriting associated definable function type goal assignment obtain function type produces normal forms objects type subsection explain bags 
subsection deals sets 
recall result lw explain normalization process sets interacts duplicate elimination 
subsection consider case target type sk intermediate type gamma gamma 
gamma gamma 
find types object type unique representation type process finding representation called partial normalization 
normalizing bag complex objects associate functions rewrite rules ae theta hti hs theta ti ae hsi theta hs theta ti hti ff ae map ae ffi pairwith argument 
lw define function app rewrite strategy rewrites assume type position derivation tree applying rewrite rule associated function yields type define function app showing action rewrite rules objects induction structure ffl root derivation app ffl theta app app ffi ffl theta app app ffi ffl app jg map app ffl app ht map app 
rewrite strategy gamma 
gamma 
fn gamma 
rewrite rule associated function applied position extend app app app app gamma pn fn ffi 
theorem normalization bags bag object type rewrite strategy gamma gamma 
holds app nf normalizing set complex objects normalization theorem set objects proved lw details explained 
give statement follows immediately theorem 
rewriting types st 
bag mean rewriting bag bag bt types 
note gamma gamma 
str bag gamma gamma 
bag btr 
theorem normalization sets set object rewrite strategy gamma gamma 
holds app bag bag bag bag set nf words turn bag object apply bag app obtain object nf set note statement theorem different fact stronger normalization theorem lw stated app bag bag bag bag set depend choice defined normal forms result application rewriting question arises possible construct normal form bag semantics 
answer question negative 
see define app set objects way defined app map map map sets ff ff 
proposition exist set objects type rewriting gamma gamma 
app normal form main reason impossible express normalization means app nrl duplicate elimination commute normalization 
nf set generally different nf set nf bag set nf 
admit proposition contradicts claim lw normalization add expressiveness nrl 
enhance nrl add expressive power nrl 
partial normalization suppose conceptual query asks question possibilities encoded disjunctions take account disjunctions object 
complete normalization process answer query 
query answered having object type object type gamma gamma 
find representation type answer 
section explain partial normalization performed 
notice possible 
take hhh iii type 
hh ii map hh ii different objects type 
theorem says essentially exclude situations 
consider bags result sets readily obtained just theorem obtained theorem 
need criterion check type rewritten 
problem easy check oe mean obtained removing set brackets fewer disjunctions 
define new relation types rules 
theta theta fjtjg oe hsi proposition rules sound complete gamma gamma 
gamma gamma 
iff rule introduces new variable suggesting proof search strategy 
think leads exponential time algorithms verifying 
somewhat resembles situation cut rule sequent calculus 
eliminated cost hyperexponential blow proof length cf 
gir 
fortunately phenomenon observed rewrite system 
proposition exists linear time complexity algorithm types returns true gamma gamma 
false 
say type type subtype form 
define concept rewriting types 
intuitively rewritings resolve ambiguities arising subtypes form 
formally distinct types gamma gamma 
rewriting gamma 
gamma 
gamma 
gamma types gamma 
step gamma gamma 
position rewrite rule applied obtain rewriting gamma gamma 
rewriting written gamma gamma 
step rewriting satisfies properties gamma 
type type 

subtypes form closer root obtained applying rule gamma 
hvi newly created subtype 
definition resolves ambiguities arising subtypes form 
property says need introduced absolutely necessary second property dictates avoid introducing subtype done close root possible gotten rid step rewriting 
give example theta theta si theta si theta sii theta si rewriting achieves result doing theta theta double set subtype avoided 
proposition types gamma gamma 
exists rewriting gamma gamma 
proposition formulate partial normalization theorem 
theorem partial normalization types gamma gamma 
rewritings gamma gamma 
object type holds app app theorem tells object type unambiguous representation type representation obtained applying rewrite strategy rewrites may wonder restricting rewritings rewritings really necessary conditions rewritings necessary 
proposition shows proposition possible find types object type rewritings violate second property rewritings app app 
normalization algorithms primitives course trivial normalization algorithm general normalization theorems 
bag complex objects 
ffl object nf hxi 
ffl type theta nf nf nf involve sets nf ae nf involves sets nf ae nf involves sets 
ffl fjx xn jg nf ff nf jg 
algorithm calculate normal form follows theorem 
readily adapted set complex objects 
problem algorithm exponential space complexity shown lw 
creates normal form conceptual queries asked 
believe reasonable design new evaluation strategy produces elements normal form 
space usage linear addition conceptual queries evaluated faster 
example existential query normal form satisfiability verified newly produced entry 
condition satisfied evaluation stops producing elements normal form 
type type sk bool want find element nf satisfies cheap reliable design able element 
query shown section precisely 
note straightforward normalization algorithm evaluation true requires exponential space normal form produced 
evaluation strategy going essentially depth search tree underlying complex object 
strategy set bag complex objects sets bags translated lists give order evaluation 
evaluation strategy shall suggest new flexible normalization primitives 
create special data structure called annotated complex objects represent trees 
basically annotation gives choice element contains local conditions telling possibilities encoded object exhausted 
object type new annotated type initial translation 
annotated object get entry normal form 
heart algorithm lies procedure takes annotated object produces 
enables list normal form entries sequentially 
translate sets bags lists assuming ordering 
matter ordering chosen algorithm produce normal form entries 
order produced depend translation additional optimizations 
follows algorithm complex objects 
algorithm bag complex objects obtained repeating verbatim replacing set bag 
denote type lists type 
definition annotated complex objects 
type kind possible values base product set set 
type produce annotated type follows ffl theta base type 
ffl theta theta bool theta theta ffl ftg theta bool theta ffl hti theta bool theta theta bool boolean value translation set true entries encoded object looked 
sets boolean component inside lists indicating element currently choice set 
algorithms entry list true boolean component 
define functions initial produces initial annotation object pick sk produces element normal form annotation bool returns true iff possibilities encoded argument exhausted 
definitions initial pick 
void mean special object indicate process going normal form 
give simplified version pick void propagated top level 
propagation done detect inconsistencies encoded empty sets 
function returns true 
annotated object define function reset disregards annotation object restores initial 
definition verbatim repeats initial omitted 
recursive algorithm 
brackets lists 
list xn oi stands gamma denotes xn may empty 
notation consing appending 
puts new head list appends produce algorithm lists elements normal form object calculating norm cond init update acc init ao initial ao cond pick ao acc update pick ao acc ao ao ao return pick ao acc algorithm norm ao initial repeat print pick ao ao ao ao theorem object algorithm prints elements nf 
linear space complexity 
duplicate elimination done algorithm produce unnecessary copies 
corollary object sets pairwise disjoint 
algorithm prints entry nf exactly 
correctness result suggests adding new flexible normalization primitives nrl 
propose called norm 
cond sk bool update sk theta sk theta bool theta init norm cond init update semantics algorithm 
intuitively output value accumulated acc cond break loop condition satisfied indicates possibilities looked forms output 
number functions defined norm consider just 
definition type sk bool norm false false normalize norm false hi initial base type 
initial true initial initial 
initial fx xng true initial initial xn 
initial hx xn true initial true initial false initial xn false 
initial hi false 
pick pick pick pick void pick xn pick xn void pick xn pick void true 
pick void definitions initial pick base pair true false true reset set false true xn true xn reset set false false true false true xn true true algorithm corollary object normal form entry satisfying false normal form entries satisfying true normalize normal form 
note useful evaluation existential queries 
entry satisfies stops returns entry producing normal form entries 
contrast standard algorithm requires exponential space evaluate queries true true needs linear time space evaluated 
application new evaluation strategy possible run normalization time get best entry normal form obtained time 
helpful approximate solution satisfactory 
space efficient evaluation recursive queries normalization 
show somewhat surprising application normalization algorithm deals algorithmic expressive power query languages 
recall algebra ab nested relational algebra general set operators plus powerset operator 
nested relational algebra express recursive queries transitive closure tc lw express tc producing possible relations set nodes selecting contain transitive 
course way computing tc uses exponential space 
remarkable result sp says matter write expression compute tc exponential space 
contrived restriction natural evaluation strategy 
restriction dropped possible devise evaluation strategy computes tc polynomial space shown ah 
proved lw ff essentially expressive power powerset operator 
view nrl extension 
explain norm compute tc space efficiently language 
expressed nrl 
fb theta bg nonempty binary relation 
define nr map map set nodes nr 
pr map fg pair nodes set pr contains element gi 
rc ft theta tg theta ft theta tg ft theta tg compute relational composition done language contains relational algebra sublanguage 
type theta edge 
define rc tc norm ffi 
proposition tc evaluates true tc evaluates false 
consequently tc computed polynomial space norm proposition regarded counterpart result ah saying tc evaluated polynomial space special evaluation strategy 
space efficient strategy normalization achieve result 
objects partial information antichain semantics antichain semantics defined lib lw ideas bjo lib objects partial information 
key idea notion partiality conveyed orderings meaning informative ordering usually base types 
example null value ni information informative integer boolean 
pairs iff explained lw orderings wellknown semantics concurrency gun sets sets respectively orderings suggests new semantics object denote object informative 
allows elimination redundancies comparable elements iff maxx iff minx maxx minx sets maximal minimal elements maxx minx elements pairwise incomparable 
sets called antichains 
fin family antichains poset define structural antichain semantics 
consider set objects 
ffl ffl theta theta ffl ftg fin ffl hti fin follows claims object type exists semantically equivalent object ffi defined rules ffl ffi base type 
ffl ffi ffi ffi ffl fx xng ffi maxfx ffi ffi ffl hx xn ffi ffi ffi consequently operation nrl define new operation takes returns ffi known see lib lw ff isomorphism operations possible define app applies rewrite strategy gamma gamma 
exactly way defined app index 
results state normalization theorem antichain semantics partial normalization theorem 
theorem object type involves sets 
rewriting gamma gamma 
holds app nf ffi theorem types gamma gamma 
rewritings gamma gamma 
app app experimental results basic normalization algorithm new space efficient normalization algorithm implemented system sml gl database programming language built top standard ml new jersey hmt 
ran number compare speed basic algorithm new algorithm described 
test objects chose objects known cause exponential blow size normal form lw 
addition objects suited sml duplicate elimination algorithm gl compare speed standard algorithms sets bags 
table column shows approximately number normal form 
entries relatively small 
second gl describes version sml primitive norm available 
column shows running time standard algorithm sets duplicates eliminated 
third column running time standard algorithm bags 
column running time new algorithm 
note compare time space 
despite space efficiency new algorithm compute exponentially entries 
reasons figures column better winning time due running garbage collections 
entries time time time min sec sec min sec sec hr sec sec days min sec sec delta done memory min sec delta done min sec delta done min sec considered application normalization algorithm select normal form entry best criterion normal form large possible run algorithm time returning best entry far 
examples entries normal form going takes days value optimal running algorithm seconds value optimal minutes 
studied various techniques normalizing databases disjunctive information represented sets 
problem particularly important areas application design planning merging databases 
queries databases ask questions possibilities encoded database information stored 
rigorously defined concept normalization set bag semantics 
explained normal forms list possibilities encoded incomplete object calculated 
limited number operations needed calculation normal forms sequence applied irrelevant set bag semantics 
normal forms size exponential size objects need better tools answering conceptual queries 
demonstrated 
partial sgi challenge xl mhz processors gigabyte ram 
normalization allows answer queries normalizing completely 
designed new space efficient normalization algorithm 
immediate practical benefits results 
new space efficient algorithm implemented sml system querying databases disjunctions 
addition space efficient faster standard algorithm allows control process normalization 
normalization techniques applicable practical problems computer automated design 
rick hull tomasz imielinski kumar claim lw normalization way answer conceptual queries 
am grateful peter buneman gunter jon riecke val tannen limsoon wong comments help criticism anthony careful reading manuscript 
ab abiteboul beeri power languages manipulation complex objects proc 
int 
workshop theory applications nested relations complex objects darmstadt 
ah abiteboul hillebrand 
space usage functional query languages 
lncs proc 
icdt pages 
abiteboul kanellakis grahne 
representation querying sets possible worlds 
tcs 
alb albert 
algebraic properties bag data types 
vldb pages 
bbn breazu tannen buneman naqvi 
structural recursion query language 
proc 
dbpl pages 
breazu tannen buneman wong 
naturally embedded query languages 
lncs proc 
icdt pages 
bdw buneman davidson semantics complex objects approximate answers jcss 
bjo buneman jung ohori powerdomains generalize relational databases tcs 
dj dershowitz 

rewrite systems 
handbook theoretical computer science north holland pages 
gir 
girard 
proofs types cambridge 
gm grumbach milo 
tractable algebras bags 
pods pages 
gun gunter 
semantics programming languages 
mit press 
gl gunter libkin 
sml functional database programming language disjunctive information applications 
lncs proc 
dexa pages 
hmt harper milner tofte 
definition standard ml mit press 
il imielinski 
incomplete information relational databases 
acm 
inv imielinski naqvi 
incomplete objects data model design planning applications 
sigmod pages 
inv imielinski naqvi 
querying design planning databases 
lncs dood pages 
springer verlag 
imielinski van der meyden 
complexity tailored design new methodology database design 
appear jcss 
extended pods 
lib libkin relational algebra complex objects partial information lncs pages 
lib libkin elementary proof upper lower powerdomain constructions commute bulletin eatcs 
lib libkin 
approximation databases 
lncs proc 
icdt pages 
lw libkin wong 
semantic representations query languages sets 
pods pages 
lw libkin wong 
properties query languages bags 
dbpl springer verlag pages 
lw libkin wong 
new techniques studying set languages bag languages aggregate functions 
pods pages 
lmr lobo minker rajasekar 
foundations disjunctive logic programming 
mit press 
rou rounds situation theoretic aspects databases proc 
conf 
situation theory applications csli vol 
pages 
sp suciu paredaens 
algorithm complex object algebra powerset needs exponential space compute transitive closure 
pods pages 

