standard fixpoint iteration java bytecode verification qian kestrel institute avenue palo alto ca usa 
java bytecode verification forms basis java internet security needs rigorous description 
important aspect bytecode verification check java virtual machine jvm program statically typed 
far formal specifications proposed define static means 
takes step presents chaotic fixpoint iteration represents family fixpoint computation strategies compute type jvm program finite number iteration steps 
transfer function iteration monotone choose follow example non standard fixpoint theorem requires transfer functions increasing monotone case bigger element fixpoint 
resulting type artificial top element jvm program statically typed 
iteration standard close sun informal specification commercial bytecode verifiers 
java virtual machine jvm stack computing machine 
java methods usually compiled jvm methods consist jvm instructions 
execution operand stack set registers called local variables created method invocation destroyed method execution completes 
stack entries local variables uniformly called memory locations 
hold data object values primitive types 
object point objects stored heap 
consider object objects heap 
jvm method may dynamically loaded network guarantee contains bugs hostile intentions break host system 
sun jvm specification requires prior execution bytecode verification performed prove newly loaded jvm method statically typed 
informally statically assign types memory locations program points jvm method instructions store data note different types assigned memory location different program points 
memory locations correct assigned types method typed assignment types legal assignment method 
informally describes determine jvm program welltyped 
lacks formal semantics 
static typedness important aspect java internet security number formal specifications proposed define :10.1.1.52.8631
takes step presents standard chaotic fixpoint iteration see represents family standard fixpoint computation strategies see compute type jvm program finite number iteration steps 
iteration close commercial bytecode verifiers derive implementation 
addition serve part comprehensive relatively realistic formal model java internet 
definitely contributes understanding jvm particular jvm subroutines 
transfer functions chaotic iteration defined set typing rules derived formal specification 
advantage proofs properties respect formal specification simpler 
unfortunately apply standard fixpoint theorems transfer functions iteration monotone see section required theorem cf 
survey 
nonmonotonicity property stems requirements instructions jvm subroutines 
avoid problem choose follow example non standard fixpoint theorem requires transfer functions increasing monotone case bigger element fixpoint 
proof transfer functions satisfy restricted monotonicity condition trivial see transfer functions compute sharpest type information local perspective 
chaotic iteration yields type jvm program finite number iteration steps 
type artificial top element jvm program statically typed respect typing rules transfer functions defined 
number simplifying assumptions jvm programs bytecode verification 
believe discard assumptions extend formalism full bytecode verification entire jvm affecting main results 
organized follows 
section recalls chaotic iteration related concepts corresponding standard fixpoint theorem 
proves non standard fixpoint theorem 
section introduces jvm instructions informally discusses assignments types 
section illustrates non monotone transfer function informally explains transfer function monotone case bigger element fixpoint 
section formally introduces notations particular defines types memory locations 
typing rules formal specification section 
chaotic iteration described section 
formal properties proved section 
section discusses related 
section concludes 
current extended revised version 
chaotic iteration fixpoint theorems partially ordered set poset hd vi consists set partial order 
sequence delta delta delta elements called increasing simply chain delta delta delta 
called strictly increasing delta delta delta 
poset finite height contains infinite strictly increasing chain 
function called monotone implies 
functions said commute element called fixpoint function fixpoint called fixpoint fixpoints consider finite set functions form element called common fixpoint fixpoint function set 
hd vi poset bottom element 

finite set monotone functions 
chaotic iteration produces infinite sequences form delta delta delta gamma delta delta delta 
functions called transfer functions chaotic iteration 
chaotic iteration called fair finite function finite 
intuitively progress possible fair chaotic iteration applies function infinitely times making progress 
fixpoint theorem special case standard 
theorem 
hd vi poset finite height bottom 
finite set monotone functions pairwise commute 
fixpoint exists particular fair chaotic iteration transfer functions produce fixpoint finite number iteration steps 
proof 
iteration produces chains bottom element functions monotone pairwise commute 
second produced chain contains fixpoint finite number iteration fair poset finite height 
discussion applies countable set fixpoint bottom element functions monotone 
unfortunately see fixpoint theorem restrictive applied transfer functions arise monotone 
introduce non standard 
function called increasing monotonicity imply 
consider set consisting elements function satisfying monotone increasing 
converse hold 
consider set elements function satisfying increasing monotone 
function called monotone fixpoint fixpoint monotone function obviously monotone fixpoint converse necessarily hold 
consider set elements functions element fixpoint function monotone fixpoint monotone 
requiring transfer functions increasing monotone pairwise commuting monotone obtain nonstandard fixpoint theorem proof direct theorem 
theorem 
hd vi poset finite height bottom 
finite set functions increasing monotone fixpoint 
fixpoint exists poset 
particular fair chaotic iteration transfer functions reach fixpoint finite number iteration steps 
proof 
iteration produces chains 
second proof theorem produced chain reaches fixpoint finite number element monotonicity fixpoint fixpoint 
proof concrete chaotic iteration follow example proof theorem 
convenience perform proof directly applying theorem 
note theorem suffices require elements chains produced chaotic iteration starting increasing monotone fixpoint 
require monotonicity fixpoint elements 
bytecode consider classes interfaces 
furthermore consider primitive type int 
denote type int 
consider methods return results return type void 
method body sequence instructions 
position instruction called address 
consider instructions 
aload pushes object address local variable stack 
iload pushes value type local variable stack 
astore pops object address top stack stack stores local variable istore pops value type top stack stack stores local variable ifnull jumps address top stack element null 
header method instruction sets empty stack allocates memory local variables stores object actual arguments local variables 
return terminates current method 
jsr pushes address stack jumps address ret jumps address stored local variable jsr ret may realize subroutines 
jsr instruction pushes address return address stack jumps subroutine astore instruction subroutine stores return address stack local variable ret instruction returns subroutine return address stored local variable general subroutine need ret instruction ret instruction may return indirect caller subroutine call stack 
jsr ret typically implement clauses java programs 
allow multiple ret instructions subroutine requires subroutine ret instruction 
method void signature argument method type limit locals method local variables 
store object local variable actual argument local variable 
create empty stack 
jsr push address stack jump address 
aload copy object local variable stack astore move top object stack local variable jsr push address stack jump address 
return return 
astore move return address stack local variable 
jsr push address stack jump address 
astore move return address stack local variable 
ret return address stored local variable 
jvm program gives jvm method describes meaning 
note instruction jsr addresses calls subroutine instruction astore address stores return address local variable 
subroutine contains instruction jsr address calls subroutine 
subroutine instruction ret address completes subroutines returns return address stored local variable 
types memory locations legal assignment memory types memory locations method 
moment consider compute assignment 
general method zero legal assignments 
write types local variables column vt types stack entries column st local variables numbered left right 
intuitively assigned types instruction indicate types data memory locations may hold prior execution instruction 
assignment contains extensions subroutine call stacks column sr discuss section 
column succ part assignment 
contains static successors address 
helpful illustration assigned types address related static successors 
code vt st sr succ method void limit locals jsr aload astore jsr return return astore fg jsr astore fg ret types method assume method declared class name types recall stands int 
type type possible data 
bytecode verification treats memory location type unusable memory location may hold data instruction type correct way type type values return addresses subroutine returns 
similarly type type value return address subroutine returns 
return address type associated subroutine 
return address types different subroutines distinct represent disjoint sets return addresses 
consider return address types memory locations may hold return addresses 
types build semilattice partial ordering defined hpi 
check assigned types indicate types data memory locations may hold prior execution instruction see example local variables address assigned types respectively hold object actual argument respectively run time 
local variables address assigned type contain undefined data 
local variables address assigned types bigger equal addresses stack address assigned type 
coincides execution instruction jsr addresses pushes return addresses stack jumps address 
process assigning types memory locations instruction ret address complex due special requirements ret instruction 
requirement static successors instruction depend type assigned local variable 
instruction ret address type local variable successors return addresses subroutine addresses 
second requirement return addresses subroutine inner subroutines usable outside subroutine 
achieve assign type memory locations containing return addresses 
example subroutine types local variables address replaced type addresses 
third requirement local variable modified subroutine content calling site subroutine remain usable call completes 
ensure things local variable modified subroutine type return address bigger equal corresponding calling site independent ret instruction subroutine type return address bigger equal ret instruction subroutine independent corresponding calling site 
full jvm stack manipulation instructions pop handle memory locations type consider 
example local variable modified subroutine 
type local variable return address chosen type calling site type return address chosen type calling site 
requirements imply need record called subroutines modified local variables 
introduce concept subroutine records 
subroutine records column sr roughly speaking subroutine record list pairs elements pairs form subroutine call stack second element pair set local variables directly modified corresponding subroutine 
subroutine record ret instruction compute set local variables modified directly indirectly subroutine 
example subroutine record address records subroutines called local variable directly modified subroutine local variable subroutine 
set local variables modified subroutine union 
words know local variables modified subroutine 
note local variables modified astore istore instruction required put subroutine record 
slightly different requires variables accessed aload iload ret instruction need put subroutine records 
subroutine record designed list close current implementation jdk 
general treatment subroutine record directed acyclic graph see 
problem explanation solution section show transfer function ret instruction monotone 
informally explain solution 
method illustration assume method declared class informally explain data flow analysis assign types subroutine records 
define relation tuples types subroutine records individual addresses lifting componentwise relation types defined previous section subset relation sets modified local variables 
introduce artificial bottom element element set tuples 
define relation types subroutine records assigned addresses method componentwise lifting relation tuples types subroutine records individual addresses 
assignment fp 
address method void argument method type limit locals method local variables 
store object local variable actual argument local variable 
create empty stack 
aload copy object local variable stack 
ifnull top stack element null jump address 
aload copy object local variable stack 
astore move top object stack local variable 
jsr push address stack jump address 
return return 
astore move top object stack local variable 
aload copy object local variable stack 
ifnull top stack element null jump 
iload copy integer local variable stack 
istore move top integer stack local variable 
ret return address stored local variable 
example bottom element just introduced 
gives iteration steps iteration 
iteration starts assignment follows step numbers 
step increases previously obtained assignment successor addresses upper bound new computed 
concretely step produces assignment inspecting method head 
types assigned local variables address local variable hold object local variable actual parameter local variable undefined value run time 
addition stack subroutine record address empty 
step address produces assignment successor address address stack address hold object run time 
ifnull instruction address successor addresses 
step updates assignments addresses 
step chaotic iteration chooses continue address 
instruction jsr push address stack address type subroutine step produces stack containing single type subroutine record containing initial assignment fg 
subroutine record means far local variables modified subroutine 
instruction astore address move top element stack local variable step address produces subroutine record address recording local variable modified subroutine 
code oe step vt st sr method void limit locals aload ifnull aload astore jsr return astore fg aload ifnull iload istore ret assignment method iteration proceeds similar way 
note instruction ifnull address static successor addresses 
step produces assignment successor address 
step iteration chooses continue address address 
instruction address astore step assigns type local variable address local variable hold integer object common type type non monotone transfer function write oe assignment obtained 
chaotic iteration may choose continue address 
instruction address istore step causes addition local variable set modified local variables produces assignment address shown write oe resulting assignment 
clearly oe oe holds 
code oe vt st sr delta delta delta delta delta delta oe delta delta delta istore ret assignment method consider continuations iteration address assignment oe oe illustrates results oe oe assignment oe record address local variable modified subroutine result oe type local variable address comes address 
assignment oe records address local variable modified subroutine result oe type local variable address comes address 
oe oe oe oe transfer function ret instruction non monotone 
oe oe code vt st sr vt st sr 
delta delta delta oe delta delta delta delta delta delta oe delta delta delta jsr return 
delta delta delta oe delta delta delta delta delta delta oe delta delta delta ret non monotone transfer function method clear non monotonicity property stems fact addition new local variable set modified local variables may cause re computation type local variable 
problem lies fact type obtained re computation comes different place previous type local variable 
intuitive explanation solution problem non monotonicity unsolved problem 
option design new algorithm non monotonicity disappears 
prove algorithm works spite nonmonotonicity 
approach design algorithm phases phase compute modified local variables 
second assign types sets modified local variables 
phases need examine program order compute complete set modified local variables needs know static execution paths 
disadvantage approach resulting algorithm may inefficient 
disadvantage differ significantly commercial bytecode verifiers directly provide hints qualities 
freund mitchell follows direction 
see section discussion 
follows second approach 
disadvantage proofs non standard 
advantage chaotic iteration simple natural close commercial bytecode verifiers 
see section discussion 
informally explain proof example proof theorem 
proof easy 
non trivial task prove monotonicity fixpoint 
complication lies treatment jsr ret instructions 
method consider types local variable addresses illustrated 
assume assignment oe record local variable modified local variable address 
assume iteration produces assignment oe oe similar way produces oe oe adds local variable modified local variable computes new type lub local variable address 
assume assignment oe legal assignment method satisfies oe oe explain oe oe code vt oe vt oe vt oe 
jsr return lub 
ret intuitive explanation solution note computing upper bound lub standard dataflow analysis compute sharpest type information type type lub sharpest type information 
choosing lub ensures property 
need prove big lub oe oe order show lub need show lub proof straightforward oe surely records local variable modified local variable address 
proof due existence static execution path address address local variable modified 
path exist assignment oe record local variable modified local variable address produced 
looking see local variable modified path addresses 
assignment oe legal method consideration applying chaotic iteration change 
particular transfer functions applied program point path assignment oe change 
means types local variable oe path increases remains unchanged 
means recall preliminaries rest notation ff denote sequence ff delta delta delta ff notation delta delta deltag denote set 
fff 
ff ff ff holds denote finite mapping 
define dom 
ff def fff ng 
mapping element ff dom ff denote result mapping ff 
note expression ff represents application predefined apply function order terms ff 
ff 
ff denote mapping equal maps ff ff set jw denote mapping obtained restricting domain dom list ff special mapping fn 
ff ng 
define size ff def ff ff def ff ff 
formalizing specification chose constraint solving framework order order sorted algebra consists collection sets called sorts subset relation sorts functions predicates sorts cf 

function uniquely determined name 
predicate uniquely determined name argument sorts 
set variables sort 
variables may occur terms logical formulas placeholders terms 
confuse variables algebra local variables jvm programs 
terms built functions variables sorted 
term sort automatically term 
term sort 
logical formulas built order predicate logic predicates terms usual logical constants connectives quantifiers sorted 
set logical formulas represents conjunction empty set represents true 
fv denote set free variables term logical formula term logical formula closed fv 
closed logical formula semantically represents statement relation order order sorted algebra evaluates true false 
simplicity omit explicit definitions sorts standard functions predicates 
substitution mapping fxn 
ng variable closed term sort delta delta delta oe range substitutions 
applying substitution oe term logical formula yields result oe defined usual free occurrences dom oe replaced oe bound variables oe automatically renamed avoid bound variable capture 
constraint logical formula 
constraint satisfied substitution oe oe closed oe evaluates true order order sorted algebra 
methods types rest assume arbitrary fixed environment consisting fixed finite set classes fixed subclass relation 
range classes 
consider arbitrary fixed method described mth 
notation stands name class method declared number arguments method types arguments method class primitive type notation stands number local variables method notation mth stands possibly empty list instructions method body 
range addresses method body mth size mth usually stands subroutine 
range indices local variables simplicity assume method body mth contains syntactic errors 
types memory locations forms hpi define partial order holds 


direct indirect subclass define join operation usual way 
types form join semilattice 
worth emphasizing join semilattice finite height subclass relation finite set classes finite height 
construct sorts composite types 
type lists vt st index sets xs fxn subroutine records sr xs program point types types ae vt st sr method types types sr fp 
ae size mth usually vt types local variables st types entries stack 
type assignment types subroutine record individual program points 
type complete assignment types subroutine records entire method 
define partial order lists types partial order subroutine records follows delta delta delta xs xs xs xs delta delta delta define partial order types ae ae conditions holds ae ae ae vt st sr ae vt st sr vt vt st st sr sr define join operation types standard way 
types form join semilattice finite height 
define partial order types oe oe conditions holds oe oe oe size mth oe oe element introduced easy formulation chaotic iteration 
definition fp 
size mth introduce abbreviation def fp 
size mth define join operation types standard way 
types form join semilattice finite height 
convenience extend partial orders defined types composite types partial order substitutions follows oe oe dom oe dom oe dom oe holds oe oe sort sort types sorts composite types oe oe typing rules form typing rules typing rules variables table 
variables vt st sr phi elements vt st hpi sr oe note omitted formal definition sorts subsort relation simplicity 
defined example sort variable supersort variable sort variables vt st list sort element sort supersort sort variable typing rule form ar cr sr ar cr sr sets logical formulas 
intuitively set ar determines address application set cr constrains type determined address set sr constrains types successor determined address 
definition 
typing rule notations qr def fv ar gamma phig def fv cr sr gamma phig qr rule induces constraint qr ar sr see phi common variable occurring typing rules standing type method body mth 
phi free variable constraints induced typing rules 
note sets cr sr play role constraint induced typing rule 
see play different roles definition transfer functions 
typing rules define set constraints variable phi types method body mth 
definition 
type oe called legal oe constraint set qr ar sr typing rule rg satisfied substitution phi 
oeg 
method body may zero legal types 
definition 
method body called typed legal type 
concrete typing rules section gives concrete typing rules 
order discuss instances typing rules method declared class single argument type local variables 
assume description rules typing rule rule set ar implicitly contains condition phi rules set cr implicitly contains condition size mth 
size mth phi delta delta delta delta delta delta mth aload phi vt st sr vt phi vt st sr mth iload phi vt st sr vt phi vt st sr mth astore phi vt st sr phi vt 
st ad mvs fx sr mth istore phi vt st sr phi vt 
st ad mvs fx sr mth ifnull phi vt st sr phi vt st sr phi vt st sr group typing rules gives group typing rules 
rule induces constraints types address information contained header method 
type address satisfies rule 
rule straightforward point condition vt implicitly forces local variable type form hpi instantiated forms 
example rule satisfied address fp 


vt 
st 
sr 
rule similar rule 
rules auxiliary function extend set modified local variables subroutine non empty subroutine record function returns empty subroutine record input subroutine record empty 
ad mvs xs xs def ae gamma xs gamma xs xs rule satisfied address fp 

vt 
st 

sr 
fg ad mvs fg 
note rules rules require addition modified variables 
rule straightforward 
note rule return instruction necessary return instruction introduces explicit constraints 
rules allow type address return instruction 
mth jsr phi vt st sr called sr phi vt st hsi sr fg mth ret phi vt st sr vt hsi mth ret phi vt st sr vt hsi mth jsr phi vt st sr called sr size mth phi vt 
filter vt sbs sr mvs sr filter st sbs sr ad mvs mvs sr sr bef sr second group typing rules contains remaining typing rules 
rule jsr instruction 
auxiliary predicate called defined called xs intuitively condition called sr ensures subroutines called recursively 
condition phi vt st hs sr fg says subroutine top element stack able hold return address 
addition puts initial entry fg subroutine record 
rule satisfied address fp 

sr 
delta delta deltag address fp 

sr 
delta delta deltag 
rule ret instruction 
ensures local variable type hs subroutine type satisfies rule address fp 

vt 
delta delta deltag vt 
rule set determines address ret instruction occurs address corresponding jsr instruction occurs 
predicate called sr ensures applications auxiliary functions defined 
set rule uses auxiliary functions 
auxiliary function ad mvs defined 
auxiliary functions defined follows 
note due existence predicate called sr set need consider definitions subroutine record xs subroutine sbs xs def fs delta delta delta ng mvs xs def xs delta delta delta xs sr bef xs def gamma xs gamma intuitively function sbs xs computes set subroutines called subroutine including subroutine call record xs 
function mvs xs computes set variables modified subroutine inner subroutines subroutine call record xs 
function sr bef xs computes prefix subroutine record xs subroutine exclusive 
define auxiliary filter functions arbitrary type type list set ss subroutines follows filter ss def ae hsi ss filter ss def filter ss function filter ss changes type type return address type subroutine set ss 
function filter ss element type list 
functions rule ensure return addresses unusable subroutine returns 
rule term vt 
filter vt sbs sr mvs sr represents types local variables local variable modified subroutine subroutine call record sr type vt type depending vt return address type subroutine sbs sr type vt 
term filter st sbs sr represents type list obtained type list st return address types subroutines sbs sr changed type term ad mvs mvs sr sr bef sr subroutine call record obtained prefix subroutine call record sr subroutine local variables modified subroutine recorded modified caller subroutine subroutine rule satisfied address fp 



sr 
fp 



sr 
sbs sr mvs sr sr bef sr 
successor filter vt sbs sr filter st sbs sr ad mvs mvs sr sr bef sr note specification requires local variables modified astore istore put subroutine records 
requires local variables accessed astore istore aload iload ret put subroutine records 
chaotic iteration bytecode verification section propose chaotic iteration compute legal types 
transfer functions iteration derived typing rules previous section 
technical reasons design generic transfer function instantiated concrete transfer function typing rule 
generic transfer function takes substitution oe argument contains type oe phi image variable phi cases information address oe variable indicating typing rule applied 
definition 
consider typing rule substitution oe 
rule called applicable oe dom oe fv ar phig oe holds 
rule called pre satisfied oe dom oe fv ar cr phig oe oe hold 
rule called satisfied oe pre satisfied oe oe holds 
rule said fail oe applicable oe substitutions oe oe ar phig oe oe holds 
intuitively applicability indicates typing rule address 
pre satisfaction indicates addition applicability checking type address successful 
satisfaction means addition pre satisfaction checking types successor addresses address successful 
concept failure captures reason chaotic iteration fail 
informally distinguish situations typing rule applicable impact input 
fact typing rule pre satisfied satisfied indicates input type small successor addresses choose bigger type 
typing rule applicable pre satisfied strictly bigger types pre satisfy typing rule 
case chaotic iteration fails 
generic transfer function defined procedure oe 
steps procedure roughly capture cases 
particular second case corresponds production type oe phi oe 
oe phi oe phi wb sr type bigger equal oe phi satisfy predicates sr see caller procedure secures oe phi note terms oe oe defined fv ar cr phig fv sr gives chaotic iteration 
repeatedly calls procedure oe compute sequence intermediate types oe oe delta delta delta 
prove iteration terminates yields result legal type method body method body legal types yields type method body legal types 
procedure oe 
rule applicable oe return oe phi 
substitution oe oe phig oe rule pre satisfied oe return type oe phi oe 
oe phi oe phi wb sr 
return type generic transfer function iteration 
oe def 
oe exist typing rule substitution oe dom oe fv ar phig oe phi oe oe oe oe def oe od 
return oe chaotic iteration examples extreme case assume mth empty list 
distinct types bottom element fg top element notations definition 
straightforward see typing rules set ar satisfied substitution variables qr constraints induced typing rules trivially satisfied 
legal type 
easy see iteration yields assume mth consists return instruction address 
easy see typing rules rule set ar satisfied substitution variables qr constraints induced typing rules rule trivially satisfied 
examining rule hard see legal types 
delta delta delta delta delta delta 
note 
iteration yields 
describes execution iteration yields legal type 
row contains type intermediate type produced sequence 
type may updated times 
simplicity write types changed type 
column step contains numbers indicating order calls transfer functions oe column rule contains typing rules corresponding called transfer functions column succ contains static successor addresses address 
code vt st sr step rule succ method void limit locals jsr aload astore jsr return returns astore fg jsr astore fg ret compute type example step uses transfer function corresponding rule compute type type address 
step uses transfer function corresponding rule checking applicability pre satisfaction respect previous type address computes update address 
recall typing rule rule set ar implicitly contains constraint phi 
iteration starts application transfer function corresponding rule method body non empty 
worth noticing steps transfer function corresponding rule address subroutine record sr mvs sr sbs sr sr bef sr 
step produces local variables address local variables type address mvs sr sbs sr local variables types address mvs sr 
note local variable address type address 
step produces address principle local variable type address 
iteration legal types section focuses relationship iteration legal mtypes 
formally establish legal type fixpoint procedure lemma 
consider arbitrary typing rule substitution oe dom oe fv ar phig oe phi legal type 
oe oe phi 
proof 
rule applicable oe definition procedure oe oe phi 
assume rule applicable oe 
oe holds 
oe phi legal type definition constraint qr ar sr satisfied phi 
oe phi means substitution oe dom oe qr phig oe ar phig oe oe oe sr hold 
rule pre satisfied oe definition procedure oe oe phi oe 
oe phi oe phi wb sr oe sr holds oe phi oe oe phi oe oe phi hold phi wb sr oe oe phi oe phi 
formally state iteration correct respect typing rules 
theorem 
correctness iteration terminates type oe type oe legal type 
proof 
consider arbitrary typing rule qr def fv ar gamma phig def fv cr sr gamma phig qr 
need prove constraint qr ar sr satisfied phi 
oeg 
doing assume substitution oe dom oe fv ar phig oe phi oe oe holds 
applicable oe 
oe result iteration oe oe 
definition procedure oe substitution oe oe ar phig oe rule pre satisfied oe dom oe qr phig oe holds oe oe phi oe 
oe phi oe phi wb sr choose arbitrary phi wb oe oe oe phi oe 
oe phi oe phi oe oe phi oe phi oe 
oe phi oe 
phi arbitrary oe sr holds 
rule oe arbitrarily chosen assertion theorem holds 
termination iteration types section mainly focuses operational properties iteration 
recall theorem requires conditions poset finite height bottom element 
transfer functions increasing 
transfer functions monotone fixpoint 
iteration fair 
join semilattice types poset 
condition trivially holds 
fairness conditions easy 
discussed section 
monotonicity fixpoint easy prove 
preparations sections 
section formally addresses monotonicity fixpoint 
section contains results types 
termination prove procedure increasing 
lemma 
typing rule substitution oe dom oe fv ar phig oe phi oe 
proof 
notations 
case rule applicable oe oe oe phi case substitution oe oe ar phig oe rule pre satisfied oe oe oe phi oe 
oe phi oe phi wb sr oe phi oe phi oe oe phi oe phi oe 
cases oe phi oe 
property prove termination chaotic iteration 
theorem 
termination iteration terminating 
proof 
consider arbitrary sequence oe oe delta delta delta intermediate types produced iteration lemma oe oe sequence strictly increasing 
semilattice types finite height iteration process finite number iteration steps 
easy check auxiliary functions predicates introduced terminating 
iteration terminating 
basic properties formalize observation typing rule applicable pre satisfied substitution substitution determined part 
lemma 
typing rule applicable pre satisfied substitutions oe oe hold rule rule oe oe oe phi oe phi 
rule rule rule rule oe oe oe phi oe phi oe oe 
rule rule oe oe oe phi oe phi oe oe oe oe 
properties remain hold replace oe oe oe oe oe phi oe phi oe phi oe phi 
proof 
follows directly definitions individual typing rules 
examining typing rule observe rule rule satisfaction set ar quite independent substitution phi 
rule satisfaction set dependent substitution phi related satisfaction sets rules respectively 
formally formulate lemma 
lemma 
assume typing rule applicable substitution oe oe substitution oe oe oe phi properties hold 
rule rule rule applicable oe 
rule rule rule applicable oe rule fails substitution oe oe phi oe phi 

rule fails oe rule fails oe proof 

follows easily definition individual typing rule 
note property need condition oe phi oe phi 

oe oe oe phi dom oe fv phig oe phi oe oe oe oe oe oe oe oe oe 
rule applicable oe oe phi oe phi assume rule applicable oe need consider cases oe phi oe vt st sr oe phi oe phi oe phi case rule fails substitution oe oe phi oe oe oe 
oe phi oe vt st sr oe vt oe hs oe vt oe hs oe vt oe vt rule fails substitution oe oe phi oe phi oe oe 
oe phi oe vt st sr oe phi oe phi oe phi case rule fails substitution oe oe phi oe phi oe oe 
called oe oe sr oe vt oe vt called oe oe sr hold 

prove case rule 
cases analogous trivial 
oe oe oe phi dom oe fv phig oe oe oe oe oe oe 
rule fails oe oe phi substitution oe dom oe dom oe st sr sg oe jf phi oe oe phi oe vt st sr oe vt oe hs 
assume substitution oe dom oe dom oe st sr sg oe jf phi oe need prove oe phi oe vt st sr oe vt oe hs 
oe phi oe vt st sr oe phi oe phi oe phi oe phi oe vt st sr 
oe phi oe vt st sr oe vt oe hs oe phi oe phi oe vt oe hs 
useful property rules may fail substitution containing legal type 
lemma 
oe legal type rules fail substitution oe oe phi oe 
proof 
definitions straightforward check rule fails substitution oe oe phi oe type legal type 
reachability introduce relation reach oe means address static successor address respect type oe 
intuitively relation builds control graph dataflow analysis 
relation depends mtype oe enabling control graph automatically change current type computed dataflow analysis 
definition 
type oe oe addresses define relation reach oe holds typing rule rule substitution oe rule applicable oe oe phi oe oe variable rule oe phi wb sr formally type necessary definition way rule determines successor depends type 
rule determines oe successor oe jsr instruction address oe calls subroutine oe type oe records local variable oe address oe type oe hs 
reachability preserved increase defining type rule fails substitution containing increased type 
lemma 
reach oe holds addresses type oe reach oe holds type oe oe oe rule fails substitution oe oe phi oe proof 
definition reach oe typing rule substitution oe conditions definition satisfied 
typing rules rule easy construct substitution oe oe oe oe phi oe conditions definition satisfied 
reach oe 
rule arguments proof lemma reach oe rule fails substitution oe oe phi oe start formalize informal explanation section 
state lemma identifies static execution path corresponding subroutine ret instruction 
lemma 
assume iteration produces intermediate type oe assume address mth ret oe vt sr vt hsi addresses delta delta delta pn mth jsr delta delta delta reach oe delta delta delta oe sr sr called sr 
proof 
transfer function corresponding rule extend subroutine record introduce type hsi intermediate type transfer function corresponding rule remove pairs subroutine record vt hsi definition iteration addresses delta delta delta pn mth jsr pn mth jsr delta delta delta oe delta delta delta oe hn foe reach oe oe sr delta delta delta sr observing typing rules get called sr delta delta delta lemma oe oe delta delta delta delta delta delta oe sr called sr 
assume iteration produces intermediate type oe hn applying transfer function address pn update type address pn oe hn oe oe sr sr oe sr sr observing typing rule may possibly step called sr called sr 
lemma implies checking condition called sr practically redundant transfer function corresponding rule 
section observed local variable modified static execution path subroutine certain conditions legal type records type local variable increases remains unchanged path 
formally state observation 
notations vt vt lemma correspond notations 
lemma 
oe legal type delta delta delta pn addresses hold local variables subroutine reach oe delta delta delta mth jsr mth pn ret oe vt st sr delta delta delta called sr delta delta delta vt hsi mvs sr vt vt 
proof 
induction prove vt vt assertion holds trivially 
assume assertion holds examining typing rule induces reach oe distinguish cases 
rule rule oe legal type observing possible typing rule straightforward see vt vt 
induction assumption vt vt 
rule rule mth ret local variable oe legal type rule vt hs subroutine reach oe delta delta delta mth jsr called sr delta delta delta observing typing rules particular rules mth jsr note oe legal type rule ensures oe legal type definition rule vt vt vt vt 
induction assumption vt vt 
ready formalize key point section notations vt vt lemma correspond notations 
lemma 
addresses oe intermediate type produced iteration oe legal type oe oe mth ret mth jsr oe vt sr vt hsi oe vt oe vt mvs sr vt vt 
proof 
lemma addresses delta delta delta pn mth jsr pn reach oe delta delta delta delta delta delta oe sr sr called sr 
note possible oe legal type oe oe reach oe delta delta delta lemmas reach oe delta delta delta structure rule reach oe 
def def delta delta delta 
oe legal type lemma oe vt sr delta delta delta vt sr note vt vt current lemma assumes oe vt 
oe def vt sr sr vt def vt reality impossible subroutine needs astore instruction store returning address local variable point formally relevant proof 
oe oe oe sr 
considering result obtained applying lemma called sr delta delta delta 
oe oe called sr delta delta delta 
lemma vt vt 
monotonicity fixpoint prove procedure typing rule rule monotone 
lemma 
typing rules rule substitutions oe oe dom oe dom oe fv ar phig oe oe oe phi oe oe 
proof 
rule applicable oe oe oe phi 
lemma oe phi oe 
oe oe oe oe 
assume rule applicable oe rule rule lemma rule applicable oe substitutions oe rule pre satisfied oe oe ar phig oe oe oe phi oe 
oe phi oe phi wb sr 
examine typing rules easy see oe oe implies oe oe phi wb sr oe oe 
substitution oe oe oe defined oe oe oe 
substitution oe lemma oe oe substitution oe 
case oe oe prove procedure rule monotone fixpoint 
lemma 
assume oe intermediate type produced iteration oe legal type oe oe oe oe substitutions dom oe dom oe fv phig oe oe oe phi oe oe phi oe oe oe 
proof 
rule applicable oe proof similar lemma 
assume rule applicable oe lemma rule applicable oe rule fails substitution oe oe phi oe oe legal type rule applicable oe note fv fv rule pre satisfied oe pre satisfied oe oe legal type rule pre satisfied oe oe oe oe phi oe 
oe phi oe phi wb 
known oe oe phi implies oe oe need prove oe oe phi notations definition rule additional notations oe oe vt oe vt st oe st sr oe sr vt st sr oe phi oe vt oe vt st oe st sr oe sr vt st sr oe phi oe oe vt vt st st sr sr vt vt st st sr sr define follows def vt 
filter vt sbs sr mvs sr def filter st sbs sr def ad mvs mvs sr sr bef sr oe phi 
need prove order prove prove need distinguish cases note sr sr mvs sr mvs sr 
mvs sr vt 
vt vt 
mvs sr mvs sr vt filter vt sbs sr mvs sr oe phi oe phi oe phi intermediate mtypes iteration produces oe phi legal type lemma vt vt 
vt vt vt vt 
vt trivially holds vt vt vt mvs sr filter vt sbs sr distinguish vt hs ffl assume case 
vt vt vt vt 
sbs sr sbs sr 
ffl assume case 
vt hs vt vt vt 
vt hs vt vt 
proof similar case mvs sr 
sr sr mvs sr mvs sr sr bef sr sr bef sr 
holds 
put lemmas legal type intermediate types produced iteration smaller equal legal type 
lemma 
assume legal type oe 
iteration produces sequence intermediate types oe oe delta delta delta oe oe holds delta delta delta 
proof 
initially oe oe holds trivially 
assume oe oe iteration produces oe definition iteration oe oe typing rule substitution oe dom oe fv ar phig oe phi oe lemma oe oe rule substitution oe dom oe fv ar phig oe phi oe 
rule rule lemmas oe oe oe oe 
rule rule lemma oe oe oe oe 
legal types theorem 
legal types method body mth typed iteration computes legal types 
proof 
method body mth statically typed legal type 
theorem iteration terminating 
lemma iteration terminate type oe oe oe legal type method body mth 
clearly oe theorems oe type mth 
corollary 

iteration yields type method body mth typed 

iteration yields type method body mth typed 
proof 
follows directly theorems 
related sun jdk implementation interesting see sun bytecode verifier jdk treats subroutines 
essentially sun bytecode verifier implements quite similar subroutine records defined 
main difference subroutine records merged sun bytecode verifier computes greatest common prefix lists called subroutines subroutine records resulting subroutine record 
means merging subroutine records may cause subroutine calls removed subroutine record merging point call removed subroutine allowed 
point implies subroutines may recursively called 
may argue special feature desirable clearly conform page 
specification definition relation subroutine records section implies merging subroutine records different lists subroutine calls leads bytecode verification error 
subroutines may removed merging process condition rule ensures subroutines may recursively called 
perspective specification closer 
difference iteration roughly captures essence sun bytecode verifier jdk dealing subroutines 
worth pointing needed specification easily adapted model special feature sun bytecode verifier 
formal specification bytecode verification chaotic iteration described simplified version typing rules 
proves soundness typing rules respect operational semantics solves completely different problem current 
noteworthy formalize chaotic iteration typing rules proofs direct 
stata abadi proposed clean typing system subroutines provided lengthy proofs soundness system clarified key semantic issues subroutines 
freund mitchell extended stata abadi system considering object initialization :10.1.1.52.8631
approach implicitly follows spirit dataflow analysis 
typing rules roughly correspond rules 
system level special rules organize application rules individual instructions regard rules directly constraints 
instruction level typing rules rules guess usage local variables subroutine jsr instruction information basis type inference subroutine 
additional needed implement guess step verification algorithm 
typing rules guess 
implementation close rules shown current 
similar freund mitchell design verification algorithm formal specifications 
implement guess step mentioned algorithm pre computes execution paths set modified local variables subroutine 
tradition pre computation computes modified local variables jsr instruction ret instruction 
pre computation heavily relies restriction subroutines may recursively called 
phase main phase dataflow analysis described standard monotone chaotic iteration 
general way breaking dependence main dataflow analysis computation modified local variables important contribution full understanding jvm subroutines 
potential problems approach multiple phase algorithm farther away commercial bytecode verifiers lead efficient implementation single phase 
approach heavily relies restriction subroutines may recursively called unclear easily approach adapted model special feature sun bytecode verifier mentioned 
addition little concerned assumptions particular assumption dead code jvm programs 
problem ret instruction may introduce dead code returns outer subroutine call 
see code inner subroutine directly returns caller subroutine causes astore instruction address dead code 
obviously dead code contribute set modified local variables algorithm directly address case 
extending algorithm consider possible 
question extension complicate matters 
hagiya original typing system subroutines provided extremely simple soundness proof 
introduce special types indicating local variables hold values outer subroutines recording variables modified 
introduce special types indicating position subroutine subroutine call stack verb ret instruction returns 
addition approach heavily relies restriction subroutines may jsr call subroutine astore store return address jsr call nested subroutine astore modify local variable ret return outer subroutine dead code introduced ret instruction called recursively 
idea quite different standard approach studies needed understand possible consequences full jvm 
particular unclear approach easily adapted model special feature sun verifier mentioned 
hagiya informally outlined verification algorithm corresponding specification formal description formal proofs 
difficult compare algorithm formal basis 
goldberg directly dataflow analysis specify bytecode verification successfully formalized way integrate aspects class loading bytecode verification 
specifications regarded verification algorithm 
consider subroutines encounter problem considered 
approach complementary 
successfully formalized bytecode verification qian approach proved soundness theorem prover isabelle hol 
mechanical proofs advantages proofs reliable mechanically repeated small changes parts specification 
shows formal tools model real life programming languages 
jones independently specified semantics jvm instructions functional language haskell 
specifications executable programs 
part regarded verification algorithm 
approach composition jvm instructions corresponds composition functional programs specifications particularly flexible changing extending jvm instruction set 
soundness specification explained established indirectly known semantic foundations haskell difficult understand people unfamiliar foundations 
identified non monotonicity property explicitly considered operational properties verification algorithms done 
investigations needed see verification algorithms properties similar proved 
callahan constructed typing system polymorphic recursion continuations similar general setting typed bly language compared bytecode verification 
reveals return addresses directly typed continuations analyze subroutine instruction belongs 
shows disallowing recursion return address types prevent return address 
unfortunately bytecode verification corresponds problem generating type information typing system decidability problem general doubtful 
restrictions needed decidable 
restriction disallow return address types nested certain depth 
bertelsen formalized jvm instructions state transitions 
cohen described formal semantics subset jvm runtime checks assure type safe execution 
papers considered bytecode verification 
borger schulte quite comprehensive high level definition jvm similar style derived bytecode verifier high level definition 
considered properties bytecode verifier discussed current fixpoint theorems chaotic fixpoint iteration fixpoint theorems taken forms re proved times literature see survey 
applications fixpoint theorems dataflow analysis see abstraction interpretation see 
perspectives chaotic iteration substantially new 
result current non trivial relies choice special form fixpoint theorem application theorem special properties jvm instructions 
aware literature directly applying theorem 
closest 
presents fixpoint theorem theorem requirement monotonicity fixpoint replaced delay monotonicity 
poset hd vi set functions called delay monotone elements implies sequence possibly identical functions delta delta delta fm delta delta delta delta delta delta fm 
fact conditions theorem imply delay monotonicity conditions theorem imply monotonicity 
prove statement consider chaotic iteration yields fixpoint starting element 
sequence delta delta delta fm delta delta delta fm fixpoint 
delta delta delta fm 
monotonicity fixpoint delta delta delta fm 
delay monotone 
prove statement consider fixpoint delay monotone delta delta delta fm sequence delta delta delta fm fixpoint delta delta delta fm monotone fixpoint 
control structure chaotic iteration simple natural standard 
chaotic iteration rely special strategy visit program points formally models core existing bytecode verifiers standard fixpoint computation 
proved chaotic iteration compute sharpest type information input jvm programs 
input program welltyped iteration computes type iteration yields artificial top element semilattice 
number commercial bytecode verifiers 
expected bytecode verifiers produced near connection building different versions jvm various application areas database systems embedded systems existing commercial verifiers know standard fixed point computation 
fact chaotic iteration computes sharpest type information suggests theoretically possible bytecode verifiers accept set typed jvm programs 
words jvm program determined typed verifier server host determined typed possibly different verifier client host 
result clearly increases confidence availability services provided mobile code network equipped different bytecode verifiers 
currently specware system formally specify bytecode verification synthesize verification algorithm specification 
synthesized verification algorithm directly corresponds current practical reasons synthesizing concrete transfer functions individual instructions generic procedure research partially supported darpa contract 
allen goldberg alessandro coglio intensive discussions related issues lindsay comments 
sophia drossopoulou comments early version phillip robert callahan explaining related 

bertelsen 
semantics java byte code 
www dina dk 

borger schulte 
modular design java virtual machine architecture 
draft 

coglio goldberg qian 
provably correct implementation jvm bytecode verifier 
proc 
oopsla workshop formal underpinnings java 

cohen 
defensive java virtual machine specification 
technical report computational logic 

cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th acm symp 
principles programming languages pages 

cousot cousot 
constructive versions tarski fixed point theorems 
pacific journal mathematics 

freund mitchell 
type system object initialization java bytecode language 
proc 
conf 
object oriented programming systems languages applications pages 
acm press 

freund mitchell 
specification verification java bytecode subroutines exceptions 
technical report computer science department stanford university 

knoop luttgen steffen 
non monotone iterations resolve second order effects 
proc 
th int 
conf 
compiler construction pages 
springer verlag lncs 

goldberg 
specification java loading bytecode verification 
proc 
th acm conference computer communications security 

hagiya 
new method dataflow analysis java virtual machine subroutines 
proc 
static analysis symposium 
springerverlag lncs 

jones 
functions java bytecode 
proc 
oopsla workshop formal underpinnings java 

kildall 
unified approach global program optimization 
proc 
acm symp 
principles programming languages 


lassez nguyen 
fixed point theorems semantics folk tale 
information processing letters 

lindholm yellin 
java tm virtual machine specification 
addisonwesley 

morrisett crary glew walker 
stack typed assembly language 
acm workshop types compilation march 

morrisett walker crary glew 
system typed assembly language 
proc 
nd acm symp 
principles programming languages pages 

muchnick 
advanced compiler design implementation 
morgan kaufmann 

callahan 
private communication 
march 

callahan 
simple comprehensive type system java bytecode subroutines 
proc 
th acm symp 
principles programming languages pages 


proving soundness java bytecode verifier specification isabelle hol 
proc 
conf 
tools algorithms construction analysis systems tacas 

qian 
formal specification java tm virtual machine instructions objects methods subroutines 
alves foss editor formal syntax semantics java tm springer verlag lncs 

qian 
types memory locations java tm bytecode 
proc 
workshop th 
object oriented languages fool 

smolka nutt goguen meseguer 
order sorted equational computation 
ait kaci nivat editors resolution equations algebraic structures volume pages 
academic press 

stata abadi 
type system java bytecode subroutines 
proc 
th acm symp 
principles programming languages 


compositional account java virtual machine 
proc 
th acm symp 
principles programming languages pages 

