implementing model checker lego yu zhaohui luo department computer science university durham south road durham dh le uk 
interactive theorem proving gives general approach modelling verification hardware software systems requires significant human efforts deal tedious proofs 
practical need automatic tools model checkers deal tedious proofs 
formalise verification system ccs imperative language lego verify finite infinite problems 
model checker implemented generate lego proof terms finite models automatically 
people lego verify general problem throw finite sub problems verified 
hand integration extends power model checking verify complicated infinite models 
interactive theorem proving gives general approach modelling verification hardware software systems requires significant human efforts deal tedious proofs 
simple model processes mutual exclusion problem fairly complicated verify 
hand model checking automatic limited certain problems simple finite state processes limitation partially overcame deal complicated problems improving efficiency bdd techniques 
theorem proving model checking complementary techniques schools trying combine strength approaches theorem provers reduce divide problems ones checked model checkers 
wolper kurshan mcmillan extended model checking able inductive step invariant capture inductive hypothesis 
joyce seger hol theorem prover verify formulas contain uninterpreted constants lemmas voss model checker give interpretation 
kurshan lamport proved multiplier bit multiplier verified cospan model checker bit multiplier composed bit multipliers verified tlp theorem prover 
principle approaches divide problem separated sub problems different tools solve individual problems 
works pencils early attempts combining theorem proving model checking 
email address yu zhaohui durham ac uk integration systems tight 
muller nipkow hol theorem prover reduce alternating bit protocol expressed automata finite state verified model checker 
pvs proof checker includes model checker decision procedure possibility combining theorem proving model checking smooth tight way 
correctness model checkers big concern computer softwares contain bugs 
output model checkers including model checker pvs correct system true 
people choose believe true pure act faith 
hand proofs type theory theorem provers lego alf coq nuprl proof terms terms principle justified different proof checkers people confidence formal proofs 
proof terms provide common interface different tools easily integrate various tools complete complicated proofs 
implement model checker lego producing proof terms 
major contributions model checker automatic generation proof terms enhance efficiency verification general theorem prover lego 
calculus communicating system ccs message passing concurrent language model systems propositional calculus express system properties 
ccs propositional calculus formalised lego finite infinite state systems 
model checker independent program takes syntax ccs propositional calculus lego returns string proof term syntax lego 
integrate proof term proof terms complete larger proof 
system deal temporal logics giving abbreviations calculus 
furthermore domain model changed imperative languages 
system structure shown fig 

system successfully verified finite state processes automatically clock vending machine process mutual exclusion 
infinite state problems verified process mutual exclusion problem reducing model finite state model 
lego prove model preserves property original model verify model 
verified finite examples imperative language peterson algorithm dining philosophers problem 
section simple ccs propositional calculus 
formalisation lego section 
implementation model checker discussed section 
section presents example process token ring network 
section discuss extension imperative programming language 
section 
model ccs logic calculus lego model checker lego formulas lego proof terms oe gamma gamma gamma gamma gamma gamma psi gamma gamma gamma gamma gamma gamma fig 

system structure model logic ccs calculus communicating system recall essential information pure ccs involve value passing refer details 
act set actions consisting internal action base actions complement actions property process expressions defined grammar 
il ff jp pnl rec ff ranges actions range processes subset base actions complement actions relabelling function act act operational semantics labelled transition system processes states actions labels 
transition relations transition rules terms structure process expressions 
ff ff ff ff ff ff ff jp ff jp ff jp ff jp jp jp pnl nl ff ff rec ff rec ff ff call pair ff immediate derivative ff action ff derivative calculus kozen propositional modal calculus expressive power subsuming modal temporal logics ltl ctl 
take negation free version modal calculus winskel construction tagging fixed points sets states 
assertions constructed grammar phi phi psi phi psi hki phi phi phi called tag subset states ranges set assertion variables ranges subsets labels 
gammak abbreviate universal set labels tag free fixed points phi phi special cases empty tags 
set states labelled transition system semantics assertions phi ae induction structure phi follows 
ae ae phi psi ae phi ae psi ae phi psi ae phi ae psi ae hki phi ae fs sj ff ff phi ae phi ae fs sj ff ff implies phi ae phi ae fs sj phi ae pg phi ae fs sj phi ae implies pg map ae evaluation function assigns assertion variable subset ae phi evaluation ae agrees ae ae phi ae satisfaction state assertion phi defined phi iff phi ae ae 
inference rules operators expressed follows 
nu base phi nu unfold phi fsg phi phi mu base phi mu unfold phi fsg phi phi phi means state satisfies property phi operators simplify proof terms define functions succ filter 
succ generates list successor label state pairs state 
filter slist filters states satisfying modality slist output succ 
prove lemma dia lemma box follows 
lemma dia phi hki phi filter succ lemma box phi sn phi phi fs filter succ formalisation lego syntax semantics ccs calculus formalised means inductive data types lego subsections 
describing formalisation give brief lego 
details lego referred 
lego lego interactive proof development system designed implemented randy pollack edinburgh 
implements related type systems edinburgh logical framework calculus constructions extended calculus constructions 
lego powerful tool interactive proof development natural deduction style supports refinement proof basic operation definitional mechanism introduce definitional abbreviations 
system design lego emphasises removing tedious aspects interactive proofs 
universe polymorphism allows users omit universe levels ecc write type type lego allows users specify new inductive data type computational theories supports computational type theory 
general applications lego moment formalise system reason properties verification proof checkers 
inductive command lego simplify declaration inductive types relations automatically constructing basic lego syntax high level presentation 
syntax follows 
inductive 
tm mm constructors cons 
consn ln options 
options 
mean optional sub commands 
command declares mutually recursive datatype 
tm constructors cons 
consn corresponding types 
ln 
ccs lists represent sets natural numbers introduce base names actions variables processes base nat var nat 
define types actions processes follows 
inductive set type constructors base base comp base inductive act set type constructors tau act act act inductive process set type constructors nil process dot act process process cho process process process par process process process hide process list process ren process base base process var var process rec process process natural way express rec constructor rec process process process 
lego allow sort expressions general introduce paradoxes 
de bruijn indexes deal variable binding 
transition relation defined inductive relation constructors definition corresponding rules 
instance constructor rule dot ff ff dot act process trans dot means act derivative constructor rule ff ff act process trans 
trans cho means act derivative derivative 
detail definition transition relation lego syntax appendix 
calculus formalise label sets operators data type modality 
modality constructors modal correspond positive operator negative operator respectively 
precise lego definition follows 
inductive modality set type constructors modal list label modality list label modality tag list state inductive form set type constructors var form orf form form form andf form form form dia modality form form box modality form form tag form form tag form form de bruijn indexes deal binding operators 
semantics inference rules semantics defined function takes calculus formula evaluation mapping arguments returns predicate state 
function lego defined constructing proof function type 
lego proof scripts easy readable construction calculus semantics equation expressions understandable 
detailed construction appendix 
formalisation syntax semantics able prove rules lemmas nu base nu unfold mu unfold lemma box lemma dia lego 
embedding deep embedding shallow embedding 
model checker verify finite infinite problems formalisation 
tedious trivial proof steps expect model checking prove parts proofs automatically 
subsection describe structure 
implementation subsection 
structure file contains definition finite model specification formula produce proof term lego put lego proof processes model satisfies specification 
model satisfy specification simply produces error message 
rules follows means proof term inl inr pair box phi pn sn phi lemma box prove state list phi fs filter succ prove state list state mem ind 
mem ind pn mem nil dia lemma dia filter succ nu nu base phi phi fsg phi nu unfold phi mu phi fsg phi mu unfold phi inr inl pair exists mem ind membership induction rule member nil rule element member empty set 
implementation implemented separate program ml appendix 
explain implementation dia mu operators omitted 
assume want find proof term find proof term proof term find pair 
dia assume want find proof term lemma dia filter succ try find proof term states filter succ 
exists lemma dia 
mu assume want find proof term phi check 
try find proof term phi fsg phi 
find mu unfold 
example applications find finite state model original model 
bisimulation equivalence preserves properties model model original 
bisimilarity proved lego prove finitestate model 
take simple token ring network example explain approach 
assume workstations ring network fig 

workstation wants enter critical section hold token passes ring 
workstation holds token merely pass token 
workstation enters critical section exit critical section keep token 
model expressed ccs follows pass enter exit pass ring ji ji processes idle workstation workstation holds token 
find model ring abst ring abst enter exit ring abst ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe ae oe exit oe enter pass gamma gamma gamma gamma gamma gamma gamma gamma gamma psi pass critical section fig 

token ring network workstations ring 
bisimulation ring abst ring exit ring abst exit ji ji result prove ring abst various properties mutual exclusion deadlock freedom 
prove lego ring ring abst lemma phi gamma 
phi proof term ring abst phi generated integrated lego complete proof 
simple imperative concurrent language system extended simple imperative concurrent language verify finite state examples 
subsection describe syntax semantics imperative language 
example subsection 
syntax semantics consider concurrent program sequential processes progress time interleaved execution sequences atomic statements 
underlying set global variables shared processes inter process communication synchronisation 
define labels primitive statements boolean expressions sequential processes lists statements programs lists processes 
syntax language described follows ranges boolean expressions ne ranges natural number expressions wait signal semaphore statements 

primitive statements primitive ne skip wait wait signal 
processes statement primitive process process process process statement list program process list 
labels label primitive define state pair consisting program memory memory table containing current values variables denoted list variable value pair 
shall denote value evaluation memory denote changing value memory operational semantics language defined labelled transition system follows 
gamma 
skip skip gamma 
true wait wait gamma 
wait wait gamma 
gamma signal signal gamma 
true gamma 
false gamma 
true gamma 
false gamma 
gamma 
kp gamma 
pkp gamma 
kp gamma 
kp example solution mutual exclusion problem semaphore example 
individual sequential process follows 
critical skip true wait critical signal program process ro 
initial value semaphore init 
mutual exclusion property defined calculus states initial state program perform wait enter critical section program perform wait performs signal 
calculus formula follow 
wait wait signal phi gamma phi prove theorems 
init ro init ro 
second author direct lego formalisation prove properties harder 
theorem proving type theory produces true false proof term term 
integrate various proof generators interactive automatic ones produce proof terms 
matter complicated proof generators correctness proofs assured simple proof checking algorithm 
showed verify concurrent programs lego combining interactive theorem proving model checking 
approach generalised temporal logic model checker smv 
proof terms difference model checkers hol pvs domain languages 
automata ccs imperative language natural express software program 
difference embedding deep embedding shallow embedding prove correctness model checking rules 
proof infinite part semantics 
simplify proof significantly part proof solve difficult 
stirling developed sound complete tableau proof system local model checking infinite state spaces 
expected formalise proof system lego help verification infinite problems 
generates proof terms lego syntax depends formalisation concurrent languages ccs lego 
formalisation changed model checker changed 
design interface calculus succ function takes state returns list successor states change calculus part change concurrent languages 
way implemented simple imperative language formalisation calculus 
expected model checker accept inductive definition lego directly model checker accept concurrent languages 
moment size generated proof term quite big efficient needs lot memory 
enhance efficiency need develop pre proved lemmas abbreviations done near 

augustsson th 
coquand nordstrom 
short description logical framework 
huet plotkin editors preliminary proc 
logical frameworks 

julian colin stirling 
local model checking state spaces 
theoretical computer science 

glenn bruns 
algebraic abstraction process preorders 
technical report department computer science university edinburgh 

burch clarke mcmillan dill hwang 
symbolic model checking states 
information computation june 

clarke grumberg 
look ltl model checking 
dill editor proc 
th conference computer aided verification volume lecture notes computer science pages stanford ca june 
springer verlag 

constable implementing mathematics nuprl proof development system 
hall 

th 
coquand huet 
calculus constructions 
information computation 

de bruijn 
calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 

math 

dowek coq proof user guide version 
cnrs ens lyon 

emerson lei 
efficient model checking fragments propositional mu calculus 
proceedings th symposium principles programming languages pages new orleans la january 
association computing machinery 

urban engberg peter leslie lamport 
mechanical verification concurrent systems tla 
probst editors computer aided verification volume lecture notes computer science pages 
springer verlag 

harper honsell plotkin 
framework defining logics 
journal acm 
preliminary version lics 

jeffrey joyce carl johan seger 
linking bdd symbolic evaluation interactive theorem proving 
proceedings th design automation conference 
association computing machinery 

kurshan lamport 
verification multiplier bits 
courcoubetis editor computer aided verification volume lecture notes computer science pages greece june july 
springer verlag 

robert kurshan 
computer aided verification coordinating processes automata theoretic approach 
princeton university press princeton new jersey 

kurshan mcmillan 
structural induction theorem processes 
th acm symposium principles distributed computing pages edmonton canada august 

luo 
computation reasoning type theory computer science 
international series monographs computer science 
oxford university press 

luo pollack 
lego proof development system user manual 
lfcs report ecs lfcs department computer science university edinburgh 

magnusson 
new implementation alf 
informal proceedings workshop logical frameworks 

kenneth mcmillan 
symbolic model checking 
kluwer academic publishers boston ma 

milner 
communication concurrency 
prentice hall 

olaf muller tobias nipkow 
combining model checking deduction automata 
tools algorithms construction analysis systems volume lecture notes computer science pages 
springerverlag 

owre rushby shankar 
pvs prototype verification system 
deepak kapur editor th international conference deduction cade volume lecture notes artificial intelligence pages saratoga ny june 
springer verlag 

randy pollack 
incremental changes lego may 
available ftp lego distribution 

robert pollack 
verified typechecker 
dezani ciancaglini plotkin editors proceedings second international conference typed lambda calculi applications volume lecture notes computer science edinburgh 
springer verlag 

rajan shankar srivas 
integration model checking automated proof checking 
computer aided verification proc 
th int 
conference volume lecture notes computer science pages li ege belgium july 
springer verlag 

glynn winskel 
note model checking modal calculus 
ausiello dezani ciancaglini ronchi della rocca editors proceedings icalp volume lecture notes computer science pages 
springer verlag 

wolper 
verifying properties large sets processes network invariants 
sifakis editor international workshop automatic verification methods finite state systems volume lecture notes computer science pages grenoble france june 
springer verlag 
appendix transition relation calculus inductive trans act process process prop relation constructors dot act process trans dot act process trans 
trans cho chor act process trans 
trans cho parl act process trans 
trans par par parr act process trans 
trans par par tau base process trans base act trans comp act 
trans tau par par tau base process trans comp act trans base act 
trans tau par par hide process list trans act 
orelse 
trans act hide hide ren act process base base trans 
trans rename ren ren process list trans tau 
trans tau hide hide rec act process trans subst rec 
trans rec appendix semantics calculus sem form 

state pred sem sem orf sem sem sem andf sem sem sem dia modal state ex label ex state member trans sem sem dia state ex label ex state member trans sem sem box modal state label state member trans sem sem box state label state member trans sem sem state ex state pred subset sem change union sem state state pred sem change minus subset appendix model checking algorithm fun check phi case phi var gamma 
error phi phi gamma 
return inl check phi inr check phi phi phi gamma 
return pair check phi check phi hki phi gamma 
exists state xs filter succ check phi provable return lemma dia state str state member filter modality str succ state str sem form form str phi pair prove member xs check phi error phi gamma 
return lemma modality str state str state checklist filter succ phi phi gamma 
return nu base prove member return nu form str phi check phi phi phi gamma 
error return mu form str phi check phi phi fun checklist xs case xs gamma 
return member nil state member nil sem form form str ys gamma 
return member cons state str str ys mem ind checklist ys eq state str eq subst state sem form form str check fun prove member case gamma 
error xs gamma 
member member tail prove member xs succ function type state list label state takes state returns list successor states corresponding labels filter function takes list label state pairs returns list states corresponding labels satisfy modality str functions convert type value corresponding string lego syntax 
article processed macro package llncs style 
