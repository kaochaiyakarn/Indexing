tutorial lava hardware description verification system koen claessen koen cs chalmers se mary sheeran ms cs chalmers se april contents getting started circuit 
lava interpreter 
second circuit 
generating vhdl 
exercises 
bigger circuits recursion lists 
connection patterns 
arithmetic 
compilation 
exercises 
verification simple properties 
quantification 
general properties 
helping verification 
exercises 
sequential circuits delay component 
multiple delays 
counters 
sequentialization 
variations 
exercises 
sequential verification sequential safety properties 
sequential logic 
verification 
induction 
induction depth 
induction restricted states 
exercises 
time transformations timing issues 
slowing 
speeding 
exercises 
connection patterns connection patterns revisited 
tree shaped circuits 
describing butterfly circuits 
bitonic merger 
exercises 
synthesizing lava circuits state machines 
behavioral descriptions 
exercises 
types signals circuits 
connection patterns 
overloading 
quick guide lava command 
logical gates 
arithmetical gates 
generic gates 
module patterns 
module arithmetic 
module 
interpretations 
errors 
answers bibliography index chapter lava experimental tool hardware design verification 
lava describe circuits simple functional hardware description language 
descriptions short sweet suffer verbosity standard hardware description languages hdls vhdl verilog 
hand express things large expressive complicated languages 
example express low level details timing 
express nicely ways circuits built sub circuits 
lava facilitates description connection patterns easily reusable 
kinds circuits example signal processing exactly want 
lava provides different ways analysing circuit descriptions 
simulate circuits just standard hdls symbolic methods generate input analysis tools automatic theorem provers model checkers 
methods generate structural vhdl lava circuit descriptions 
aim tutorial gently introduce new style circuit design analysis means examples 
lava chalmers platform experiments formal verification hardware 
note older version lava circuit descriptions bit complicated 
singh hand uses lava real industrial design projects xilinx main suppliers field programmable gate arrays fpgas 
particular lava great success development fpga cores filters bezier curve drawing circuits customer applications digital signal processing high speed networks high performance graphics applications 
lava really consists simple hardware description language embedded powerful functional programming language haskell 
seen domain specific language embedded general purpose programming language 
describe circuits writing haskell programs lava system consists set haskell modules give user various facilities 
embedded language quite similar lustre synchronous dataflow language 
idea functional programming language describe hardware proposed early eighties quite lot area 
intention building lava system singh provide tool demonstrates feasibility doing circuit design analysis functional language 
main idea lava single circuit description analysed variety different ways giving different interpretations components connection patterns 
simplest interpretations gives ordinary simulation 

allow symbolic concrete data flow circuit way collect information circuit various different ways 
example run circuit symbolic data produce expressions outputs indicate output related inputs 
useful developing implementation 
expressions get large humans interpret 
hook external analysis tools automatic theorem provers help analyse circuits 
hook external theorem provers haskell proof scripting language 
turns convenient 
similarly hook external tools vhdl cad tools haskell scripting language 
way view lava system tool linking controlling tools unified way 
haskell construct circuit descriptions control tools process descriptions 
user sees language having usual cad world 
tutorial introduces style circuit description lava means simple examples 
emphasises way lava combinators capture common interconnection patterns 
shows important interpretations circuit analysis methods simulation generation vhdl code generation logical formulas input theorem provers 
working tutorial understand describe analyse simple combinational sequential circuits lava 
hope quick sections back tutorial help get started 
chapter getting started chapter describe describe simple circuits lava system run interpreter 
circuit circuit description start text editor choice create text file called hs example 
lava file names extension hs 
going define called half adder see 
half adder component example implementation binary adder 
takes input bits adds 
result sum carry bit 
half adder usually realized xor gate 
define half adder halfadd lava 
import lava halfadd sum carry sum xor carry import module called lava defines number operations build circuits 
notably contains definitions gates xor 
appendix contains list predefined operations 
note order definitions matter 
circuit components act parallel just put way 
sum carry xor half adder 
lava interpreter development collection circuits mainly lava interpreter 
haskell interpreter hugs 
command lava 
lava lava 
prelude 
interpreter load different modules circuit definitions type commands want execute 
type half adder definition file hs load interpreter command prelude 
hs reading file hs 
hs main 
things circuit simulating 
simulation done lava operation simulate 
takes arguments circuit simulate case halfadd input circuit case pair bits 
main 
simulate halfadd low low low low main 
simulate halfadd high high low high changes file circuit definitions type reload command interpreter main 

main 
xor sum carryout ha ha carryin full adder 
changes updated 
want exit interpreter command 
main 
leaving hugs second circuit guessed 
second circuit going full adder see component fulladd consists half adders 
define add definition file hs 
fulladd carryin sum carryout sum carry halfadd sum carry halfadd carryin sum carryout xor carry carry note just half adder circuit input 
input consists pair bit pair bits 
represented input triple bits shall see particular choice 
simulate circuit simulate operation previous section 
inputs get bigger typing different test inputs interpreter lot 
avoid describe number test cases file hs test simulate halfadd low low test simulate fulladd low high low test simulate fulladd high low high perform tests interpreter 
main 
test low high main 
test high low want simulate circuit input time operation 
takes circuit list sample inputs parameter 
lists denoted square brackets 
main 
halfadd low low low high high low low low high low high low special list called domain contains values certain input shape 
main 
halfadd domain low low high low high low low high input shapes example inputs containing numbers 
finite domain list associated 
generating vhdl lava circuit description generate vhdl operation 
takes arguments name vhdl definition string circuit 
main 
fulladd fulladd writing file fulladd 
done 
vhdl file generated assume definitions gates 
lava distribution provides definitions file lava auxiliary lava 
load file vhdl working library compile 
normally vhdl generator gives names inputs outputs automatically 
want give names input operation 
main 
fulladd fulladd var carryin var var writing file fulladd 
done 
lastly want give names outputs operations 
main 
fulladd fulladd var carryin var var var sum var carryout writing file fulladd 
done 
see result operation 
entity architecture fulladd structural port fulladd clock clk bit signal bit inputs signal bit carryin bit signal bit bit bit cw entity port map clk outputs entity port map clk carryin sum sum bit cw entity xor port map clk carryout bit cw entity xor port map clk carryin entity xor port map clk carryout entity fulladd structural vhdl code full adder fulladd 
exercises define circuits swap copy 
swap gets pair inputs outputs swapped order 
copy gets input outputs twice pair 
behave main 
swap low high low low high low high low low low low high main 
copy low high low low high high define bit sorter 
takes input pair bits outputs bits lowest left hand side highest right hand side 
define circuit inputs output high 
hint input consisting wires written 
define simulate multiplexer lava 
multiplexer circuit input pair signal pair 
output equal signal low signal high 
full adders bit binary adder 
simulate design generate vhdl code 
suppose designing digital watch 
come handy circuit takes bit binary number displays digital digit segment display 
circuit interface see digital display 

hint start making table entries 
see parts display light number 
chapter bigger circuits chapter describe complicated circuits recursion connection patterns 
see numbers lava 
recursion lists bit adder takes pair inputs 
part carry bit second part binary number represented list bits 
bit adder add bit binary number resulting binary number carry 
define bit adder lava recursion list bits 
cases 
list empty denoted add 
list element split list parts denoted 
case half adder add carry recursively add resulting carry rest binary number 
carryin carryin carryin sum sums carryout sum carry halfadd carryin sums carryout carry complicated circuit circuit adder takes carry pair binary numbers adds 
called binary adder 
recursive structure doing simultaneous recursion binary numbers 
adder carryin carryin circ circ serial composition circ circ 
carryin carryout circuit processing input carry 
adder carryin bs sum sums carryout sum carry fulladd carryin sums carryout adder carry bs connection patterns looking circuit definitions previous section see lot common 
gates different structure similar 
lava capture common structures connection patterns 
connection patterns higher order circuits circuits build circuits circuits 
common connection pattern serial composition serial circuits see 
circuit parametrized circuits circ circ 
means serial circ circ circuit feeds input circ connects output input circ results output serial circ circ circ circ interesting connection patterns appear look recursive circuit structures 
example half adder circuit definition plug circuit 
result consists row smaller circuits see 
carryin carryout pattern row connecting instances define row connection pattern 
row circ carryin carryin row circ carryin bs carryout carry circ carryin bs carryout row circ carry definition need recursion anymore define circuits specific pattern 
alternative definitions adder carry row halfadd carry adder carry row fulladd carry doing circuit descriptions shorter 
somebody knows pattern row defined easier understand circuit definition 
convenient able mix different styles descriptions 
note reason chose input fulladd particular form wanted row 
convention easier circuits predefined connection patterns 
shorter definitions circuits row halfadd adder row fulladd note type adder slightly different adder see exercise 
arithmetic lava deal low level wire types bits gates xor wire types gates 
types integers 
integers operations corresponding gates integers 
list gates appendix simple circuit arithmetical gates called 
takes number input pair bit number output 
bit pair corresponds value binary digit number resulting number input number divided 
num bit num digit num bit int bit digit num idiv num circuit converts number bit transforming low number high 
arithmetical circuit build circuit converts number binary number list bits 
circuit takes parameter corresponding size list produce input number needs converted 
converter int bin converts integer binary number 
extra parameter specifies number bits binary number 
note parameters circuits different inputs int bin really circuit int bin define circuit recursion size binary number 
int bin num int bin num bit bits bit num num bits int bin num arithmetical gates include plus times example simulations circuits main 
simulate high main 
simulate int bin high high high compilation soon start writing bigger circuits need arise compile 
far interpreter little bit slow larger projects 
compiling done running lava command option 
specify want compiled program 
making definition function main file working 
example want simulate adder define main print simulate adder high high low low high run lava compiler invoking lava lava compiling 
compiler produced executable program called run saying high low high control compilation process see appendix 
exercises define bit called takes bit binary number input subtracts bit binary number 
define binary adder called adder take carry bit throws away resulting carry 
difference adder adder 
hint look types inputs 
define circuit bin int converts bit vector integer 
define circuit zipp takes pair list inputs produces list pairs grouped 
main 
simulate zipp low high low high high low low high high high low low define circuit inverse zipp 
define circuit pair takes list input produces list pairs neighbours grouped 
main 
simulate pair low high low high high low low high low high high low define circuit inverse pair 
define connection pattern called par turns circuits input having output circuit pair inputs having pair outputs 
define recursion binary multiplier 
recursive structure looking definition row define connection pattern called column carries right part input left part output 
define column terms row 
define connection pattern called grid puts number copies circuits matrix 
left parts inputs carried left right right parts inputs outputs carried top bottom 
hint think grid row columns column rows 
think useful circuit grid connection pattern 
looking recursive definition adder define simple 
subtract smaller numbers bigger numbers 
connection patterns described chapter non recursive description 
define circuit takes inputs activate signal pair signals output pair signals 
activate signal high order input pair swapped stays 
swap 
define comparator circuit takes binary numbers equal length tells left equal right 
implement binary sorter 
takes input binary numbers equal length outputs correct order 
chapter verification chapter describe define properties circuits formally verify properties theorem prover 
simple properties main kind properties circuits deal lava called safety properties 
properties defined way state condition true equivalently false 
example property checks outputs half adder true 
ok sum carry halfadd ok nand sum carry note property looks pretty normal circuit definition fact actual verification question property circuit yield true matter input answer question lava operation verify 
main 
verify proving 
valid 
process works way 
just generate vhdl circuit description generate logical formula representing circuit 
logical formula external theorem prover prove disprove validity formula 
result taken back lava 
example formulate full adder care order arguments produce result 
property general called commutativity 
ok fulladd fulladd ok 
note interested exact shape output full adders just give name output case 
thing notice general equality 
circuit equal 
quantification commutativity property true full adders general binary adders 
state property bs ok adder bs adder bs ok 
note adder adder defined exercise answer page 
problem property holds circuit sizes verify specific sizes 
hard verify properties automatically sizes 
verifying sizes pick specific size verify property 
define new property explicit size input want verify property 
forall list 
forall list bs 
bs property means lists size called lists size called bs property adder commutative holds bs input 
verify property verify 
course size 
main 
verify proving 
valid 
main 
verify proving 
valid 
main 
verify proving 
valid 
general properties general properties properties parametrized circuits 
defined just connection patterns 
general property poses question circuits equivalent 
circ circ ok circ circ ok 
property checks circuit commutative 
circ bs ok circ bs circ bs ok 
course circuits uses instantiate properties right shape type 
helping verification formulas generate quite hard 
case larger formula harder verify 
necessary help prover bit 
way doing split large proof number smaller ones 
prove parts new proof assume parts proved true 
lava verifying just question list questions 
example verify circuits output prove pin pin go 
define equality 
ys low xs low xs ys eq eqs eq equal eqs xs ys note comparison fails lists length 
check binary adder commutative say bs adder bs adder bs forall list 
forall list bs 
bs defined property poses list questions theorem prover prove 
lava 
verify proving pin 
valid 
proving pin 
valid 
proving pin 
valid 
proving pin 
valid 
proving pin 
valid 
result valid 
note proof pin assume pin holds exercises take look bit sorter defined exercise 
verify correct properties need true left part output smaller right part output output circuit contains bits input possibly different order 
state properties separately verify verify 
properties easy verify simulating inputs domain 
properties chapter 
verify testing inputs 
think easy verify properties 
check various adders previous chapter commutative sizes bits 
happens try prove commutative 
check defined previous chapter really 
formulate property definition subtraction 
sure mess sizes binary numbers 
define general property states circuit associative 
operator ffi associative holds ffi ffi ffi ffi 
adders associative 
verify carry save adder defined previous chapter equivalent binary adder 
careful formulate property inputs shape 
prove adder choice holds gamma gamma extra condition hold 
express 
haskell proceed want verify property sizes say 
chapter sequential circuits chapter describe deal sequential circuits lava 
sequential circuits lava synchronous circuits means global clock affecting delay components circuit 
delay component new component sequential circuits delay component 
circuit parameter initial output delay input output clock cycle 
example simple circuit called edge checks input changed respect previous input 
uses delay component remember previous input 
edge inp change inp delay low inp change xor inp inp simulate sequential circuit operation 
needs circuit list inputs 
list inputs interpreted different inputs clock tick 
main 
edge high low low high high high low high sequential circuit called toggle 
internal state outputs takes input 
input high changes state 
stays 
toggle change delay low xor change see definition dependent definition dependent 
loop circuit 
loops allowed combinational circuits meaning circuits unclear 
sequential circuits essential implement interesting behavior 
simulating toggle gives main 
toggle high low low high high high high low multiple delays seen delay signal time instant refer signal previous value 
want delay signal multiple time instances 
defining parametrized circuit called delayn 
parameters number delays init initial values delays 
recursion define circuit 
delayn init inp inp delayn init inp delay init rest rest delayn init inp useful sequential circuit implement delayn called puls 
inputs output parameter output normally low th th th clock tick outputs high 
implement circuit creating gamma delay components row initialized low ended delay component initialized high 
puls delayn low delay high note need loop back 
implementation optimal sense uses delay components see exercise 
simulating puls gives main 
puls low low high low low high low counters bit counter circuit outputs bit binary number clock tick starting increasing clock tick 
implement keeping internal state binary number 
circuit takes parameter indicates number bits inputs 
counter number number delay number number carryout high number function creates list zeros denoting initial value 
note delay component works bits example pairs bits lists case 
simulating counter gives main 
counter low low low high low low low high low variant circuit counter takes input indicates number increase 
case want desired increase take effect immediately output number delay 
number number delay number number carryout number simulating gives main 
high low high high low low high low low low high low sequentialization chapter seen combinational binary adder 
input takes bit binary numbers adds 
large circuit get quite large means takes circuit area consumes power need lower clock frequency properly 
regularity circuit small version circuit needs clock cycles compute result 
apply technique binary adder obtain sequential adder 
takes new digit binary numbers clock cycle 
called bit serial 
implement storing carry internal state current carry circuit previous carry 
sum carryin delay low carryout sum carryout fulladd carryin simulating gives main 
high low high high low high high low low find sequential circuits structure define sequential connection pattern called builds row circuits just row interprets row time 
circ inp carryin delay zero carryout carryout circ carryin inp worth noting generic delay zero component 
structure exactly sequential adder 
recalling definition binary adder terms row repeat implement sequential adder terms adder row fulladd combinational fulladd sequential way connection pattern define combinational circuit helps define sequential version circuit 
variations sequential row connection pattern useful certainly 
implement sequential adder add infinitely big binary numbers 
addition ends start adding new numbers 
handy connection pattern called takes extra input reset 
reset high internal carry state reset zero 
circ reset inp carryin delay zero carry carry mux reset carryout zero carryout circ carryin inp standard multiplexer component mux chooses left right component input pair depending incoming signal low high respectively 
define sequential adder follows fulladd case internal carry state reset periodically th th clock tick 
create third sequential row variation takes parameter indicates reset period 
circ inp reset puls circ reset inp define sequential adder adding bit numbers follows fulladd exercises define circuit takes input output 
output high number high inputs far 
simulate circuit lava generate vhdl 
implement flipflop circuit takes inputs set reset output 
circuit keeps internal state set high set high set low reset high 
internal state output 
may decide inputs high 
implement clocked delay component 
parameter initial state extra input clk 
clk high output changes state state changes current input 
define circuit called input output 
output high long input stays high 
input drops low output stays low forever 
define different circuits output high th clock tick happens th th th 
delay elements circuit delay elements second 
possible define circuit bit level delay elements 
define puls generator puls parameter generates puls th clock tick 
design minimal number delay components 
define counter 
counter gets pair inputs 
left input high counts 
right input high counts 
state stays 
define counter 
counter inputs bit number output 
initially output starts increments clock tick output returns 
connect display exercise counter 
define synchronizer inputs go go output go 
output true go go high past high go 
example simulation main 
synchronize low high high low high high high low low low low high low high high low low high define circuit called parameter list values inputs output 
circuit outputs elements parameter list clock tick repeatedly 
example simulation main 
low low high low low high low low high chapter sequential verification chapter describe verify properties sequential circuits 
restrict sequential safety properties 
sequential safety properties take look define properties sequential circuits 
principle techniques combinational circuits 
take look examples 
compare sequential adders section 
inp ok inp inp ok 
example composition edge toggle section gives identity circuit 
means input output 
inp ok mid toggle inp edge mid ok 
inp properties describe way called sequential safety properties 
recall safety properties properties described circuit output true false property hold 
examples properties safety properties example liveness properties 
assert certain condition hold point example 
sequential logic apart techniques define combinational properties special techniques apply define sequential properties 
ffl want refer values signals different time instances delay get access previous values 
careful initial value choose delay 
ffl want certain property true certain condition holds necessarily hold time logical implication 
implication implemented lava gate impl binary operator 
example 
suppose want define property toggle circuit input high current output different previous output 
way define lava inp ok toggle inp delay low change xor ok inp 
change compute output toggle 
delay component get access previous output 
define situation change outputs differ 
say input high outputs differ 
verification defining properties formally verify 
verification sequential property means prove property holds times 
lava induction time 
works follows 
firstly base case proving property holds time instance 
looking just time instance involve time techniques combinational case 
inductive step 
want prove property holds time holds time 
follows create arbitrary time instance filling states circuits fresh variables 
run circuit state obtaining output new state values 
assert output true run circuit new state values 
need prove new output true 
proving base case inductive step proved property 
happens lava main 
verify proving base 
valid 
proving step 
valid 
result valid 
lava 
verify proving base 
valid 
proving step 
valid 
result valid 
give detailed explanation induction section 
induction perform induction lava property convert logical formula relating input inp old state variables old output ok new state variables new 
signal level delay component circuit property introduce state variable 
translation introduce special input called init true time instance 
translated property logical formula form init inp old new ok formula usually called transition relation 
simple way prove output ok true try proving init inp old new ok ok unfortunately method property true run circuit true possible configuration state variables 
induction 
prove base case ok true time instance 
case know variable init true prove true inp new ok ok usually easy initially know values state variables 
prove induction step ok true time true time 
looking time instances property 
init inp true false inp ok oe ok note connect different time instances reuse state variables new states time instance old states second time instance 
note false value init second time instance know initial time instance 
true value ok time may assume induction hypothesis holds 
proven formulas know ok true time instances 
basic notion induction 
induction depth unfortunately method induction mentioned previous section complete 
means properties true proven simple induction 
example consider toggle circuit section puls circuit section 
want verify circuits exactly opposite toggle high input puls period 
ok toggle high puls ok inv 
proven normal induction puls circuit delay components row look time instances time 
look time instances induction proof 
introduce concept induction depth means base init ok ok ok base case induction depth case proves steps okay step case may assume sequence steps went okay order prove th step okay 
concrete formula base case see true inp ok false inp ok false inp ok ok ok ok note trick reusing state variables consecutive times line time instances 
concrete formula step case see init inp true false inp true false inp true false inp ok ok depth prove formulas proved ok holds time instance 
note choose back normal induction 
happens verify prop toggle vs puls lava main 
verify prover base 
valid 
prover step 
falsifiable 
prover base 
valid 
ok true true true inductive step induction depth prover step 
valid 
result valid 
verifier realizes induction depth step go increases induction depth automatically 
keep increasing depth base case turns false manages prove base case step case 
want specify specific depth induction operation takes extra list verify options 
main 
depth prover base 
valid 
prover step 
valid 
result valid 
operation verify just short hand depth increasing 
option depth specify induction depth 
increasing means keep increasing depth proves property 
induction restricted states unfortunately induction depth complete method 
means exists true exists property proven induction depth example property check periodic sequential adder period equivalent adder reset second clock tick 
ab ok sum ab delay low inv sum ab ok sum 
sum verifying property results infinite loop main 
verify prover base 
valid 
prover step 
falsifiable 
prover base 
valid 
prover step 
falsifiable 
problem exist lot state variable configurations occur run circuit logically possible 
cases called unreachable states mess induction proof 
assuming property want prove true large number consecutive running steps induction step ensure reachable state 
reason running unreachable states circles steps increasing help 
strengthen induction step saying states visit formula distinct 
way ensure running circles 
new formula inductive step init inp true false inp true false inp true false inp ok gamma ok method proving formulas prove ok holds time instances 
complete method 
means property holds prove induction depth restricted states 
induction restricted states lava option main 
increasing proving base 
valid 
proving step 
falsifiable 
proving base 
valid 
proving step 
valid 
result valid 
needed induction depth property 
note option increasing verification stopped depth 
exercises simulation sequential verification 
verify edge circuit circuit exercise opposite outputs fed inputs 
verify different implementations puls generator period exercise equivalent 
induction depth needed 
verify obvious relationship puls circuit puls circuit exercise different values induction depth needed 
verify part counter defined equivalent counter section 
different values define verify property input toggle twice row current output output steps ago 
consider general property long holds hold 
define property 
hint circuit 
show doing induction depth amounts normal induction 
show doing induction depth sound proven base case inductive step really proven property holds 
show doing induction depth restricted states sound 
may fact exercise holds 
show doing induction depth restricted states complete 
chapter time transformations chapter see techniques compare circuits operate different clock rates 
timing issues far comparing circuits assumed consumed inputs produced outputs rate 
take look example case comparing sequential adder combinational adder 
sequential adder see takes pair bits clock tick outputs sum remembers carry clock cycle 
carry reset th clock tick 
defined fulladd combinational adder see takes bit binary numbers produces sum bit binary number clock tick 
define abs sum sum carryout row fulladd low abs sum seq adder sequential adder 

adder com sum sum combinational adder 
parallel parallel serial sum serial puls adder com slowed combinational adder 
convenience away carry 
basic methods comparing circuits 
method involves slowing combinational adder takes clock ticks calculate sum 
pairs bits time takes gotten outputs sums 
circuits operate rate compared conventional methods 
second method involves speeding sequential adder computes results clock tick 
pair bits time takes pairs bits produces sums clock cycle 
slowing technique describe slows combinational circuit 
computing clock tick force take clock ticks 
transforming circuit circuit looks just sequential version takes input produces output time see 
inputs come wait clock ticks full input available circuit 
done serial parallel converter see 
implement component follows low low low serial parallel converter 
low low low low load parallel serial converter 
inp inp inp inp rest inp delay zero inp rest inp take care outputs 
clock tick combinational circuit produces outputs sense th th clock tick right input 
need add component outputs spreads outputs important clock ticks clock ticks 
done parallel serial converter see 
implement component follows load inp mux load low inp load inp load prev delay low mux load prev inp put components new sequential adder ab sum abs ab sums abs load puls sum load sums load input parallel serial converter puls period take look sequential adder adds binary numbers 
clock input ab ab ab ab ab ab ab ab ab output see results delayed gamma clock ticks 
course result computed th th clock tick 
compare original sequential adder slow output gamma delay components 
property ab ok expl new old combinational circuit explicit states old new expl expl expl time transformed sequential circuit sum ab sum delayn low sum sum ab ok sum 
sum unfortunately way specifying property introduces lot extra logic extra state 
verification kind properties hard 
particular induction methods need extremely high induction depth 
section see simpler direct method specifying retiming properties 
speeding technique retiming works follows 
slowing combinational circuit speed sequential circuit 
unfortunately done adding retiming components circuit 
transform circuit circuit 
done built lava operation called 
idea state sequential circuit explicit turning sequential circuit combinational circuit expl takes old state extra input new state extra output see 
step create column expl thread states carry 
step state implicit adding delay components loop back see 
implemented lava primitive operation 
new adder sequential adder time transformation abs sums sums abs length abs function length computes length list know period sequential adder requires 
property comparing different adders looks follows abs ok sum abs sum abs ok sum 
sum property list input need explicit length list forall list abs 
abs verifying induction easy needs induction depth exercises consider circuit high low verify circuit toggle behaves twice slow circuit input high 
slowing speeding 
goes wrong try slowing method comparing sequential circuits operate different rate 
see exercise 
hint happens state circuit slowed 
speeding method comparing sequential circuits operate different rate 
design property connection pattern verifies circuits operate different rates equivalent 
may decide method choose 
find method fix problem exercise 
hint clocked delays see exercise 
chapter connection patterns chapter review standard connection patterns consider problem describing tree shaped circuits butterfly circuits 
common circuit structures digital signal processing 
connection patterns revisited earlier chapter saw serial connection pattern connects circuits series 
convenient infix version write serial see 
note serial composition associative want compose list circuits 
call compose 
compose inp inp compose circ inp circ inp compose note written definition different style serial connection pattern 
compose inp inp compose circ inp circ compose inp go drop circuit inputs inp side definitions 
identity circuit just returns input written id definite change style emphasis connection patterns 
compose id compose circ circ compose styles equally choice really just matter taste 
fact quite convenient able mix styles choosing 
compose easily connection pattern called composes copies circuit sequence 
circ compose replicate circ main 
circuit adds integer input 
saw par connection pattern par takes pair inputs passing second combining results pair 
infix version par written version par half list second half turns useful 
call pattern parl 
define helper function divides list 
left right left take half right drop half half length div map main 
simulate high low high low high low high low define circuit append takes pair lists length joins concatenates give list length circuit defined terms haskell built infix list concatenate operator 
append lastly define parl parl circ circ circ circ append main 
simulate parl reverse id want perform operation element list signals bus 
connection pattern map seen functional programming language 
example map inv inverts list bits 
main 
simulate map inv high low high low low high low high buses need contain lists bits 
structured circuit descriptions match logical structure circuit 
example circuit map fulladd perfect sense 
main 
simulate map fulladd low high low high high high low high high high low high high low high tri shows map case input list pairs lists 
strangely connection pattern places zero copies circuit signal bus copy arises hardware design 
sort mixture map 
call tri triangle 
understand look diagram 
leave definition tri exercise 
example triangle main 
simulate tri replicate connection patterns seen section useful different kinds circuits 
consider describe tree shaped circuits 
tree shaped circuits circuits shape trees shown systematically apply function combines data values collection data 
binary tree circuit combines half input values smaller trees combines remaining results 
example circuit adder tree adds list 
outline recursive definition tree connection pattern tree circ inp inp tree circ tree circ tree circ circ call parameter circ component circuit 
line outline defines done get base case recursion 
second line copies tree circ combine results gamma gamma gamma gamma gamma gamma gamma gamma tree shaped circuit circ 
exactly definitions look depends partly component circ looks particular type 
example circ binary function pair inputs returning single output sense definition binary tree connection pattern bintree 
bintree circ inp inp bintree circ bintree circ bintree circ circ gives behaviour expect binary tree circ components gets built 
example tree connection pattern want build circuit adds lot numbers 
way doing called adder tree 
need binary adder adds bit numbers give bit number 
means include carry result 
resulting adder slightly different saw earlier 
call 
bs cs carryout cs carryout adder low bs definition adder tree bintree test wrap circuit converters integer binary back 
map int bin bin int main 
simulate beware adder tree works input lists length power 
exercise asks define adder tree works size 
describing butterfly circuits butterfly circuits circuits particular recursive structure 
figures show circuits indicate recursive structures showing means dotted boxes find sub circuits recursive structure 
turns circuits fact equivalent network components recursively described completely different ways 
turns ways describe network 
study 
butterfly circuits example build routing networks switches building efficient sorting circuits 
best known circuit standard cooley tukey algorithm computing fast fourier transform fft 
consider fft 
complicate matters bit 
circuit quite uniform consider 
interested reader referred shows describe compare various fft circuits older version lava 
details verification done see 
section introduce new connection patterns show butterfly circuits just patterns serial composition 
patterns call 
circuit circ contains copies circ 
operates half input list second second half 
copy circ list output resulting lists appended 
pattern easily defined terms parl introduced earlier chapter 
circ parl circ circ main 
simulate reverse main 
simulate reverse related introduce pattern ilv interleave 
applies top bottom halves list ilv applies odd elements 
define terms wiring pattern performs bb gamma gamma delta delta delta theta theta theta theta theta gamma gamma delta delta delta theta theta theta theta theta bb gamma gamma gamma gamma gamma gamma gamma gamma ilv ilv perfect shuffle list 
think pack cards halving interleaving half packs 
pack reverse process returning pack original condition 
somewhat difficult accomplish poker table 
main 
simulate main 
simulate main 
simulate note sequence divides odd elements 
fact define ilv terms 
ilv circ circ main 
simulate ilv reverse main 
simulate ilv ilv reverse shows ilv ilv 
leave definition exercise 
seen examples sense apply ilv repeatedly 
butterfly circuits useful define special functions 
circ circ circ circ bb gamma gamma delta delta delta theta theta theta theta theta gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma delta delta delta theta theta theta theta theta bb bfly circ circ circ ilv circ clearly similarities definitions 
just defined function takes connection pattern input 
iter comb circ circ iter comb circ comb iter comb circ iter iter ilv position define connection pattern butterfly circuits circuits shown figures particular recursive structure 
circuits recursive corresponding connection pattern defined recursion 
bfly circ id bfly circ ilv bfly circ circ smallest butterfly just identity 
butterfly size greater zero consists interleaved size gamma output fed stack circ components 
connection pattern shown shows bfly larger dashed box shows instance bfly instance just 
smaller interleaved left right 
sure find wiring patterns look definition ilv 
interleaved feed outputs components look inside bfly outer dashed box find recursive structure 
strangely connection pattern netlist order inputs outputs possibly different layout described different pattern recursion 
gamma gamma delta delta delta theta theta theta theta theta bb bb gamma gamma delta delta delta theta theta theta theta theta gamma gamma gamma gamma gamma gamma gamma gamma bfly bfly circ id bfly circ circ bfly circ time start repeatedly interleaved stack basic components outputs fed smaller combined 
shows recursive decomposition 
turns ilv bfly circ bfly ilv circ 
see question ilv want 
means define butterfly network single recursive call larger component bfly circ id bfly circ circ bfly circ bfly circ id bfly circ bfly ilv circ circ surprising thing connection patterns give equivalent circuits size component 
original butterfly bfly bfly expressed tree combinator 
take look connection pattern version bintree works component circuit circ processing lists 
circ inp inp circ circ circ think types involved definition 
replacing ilv get sort interleaved tree 
circ inp inp circ ilv circ circ component takes pair input produces pair output describe stack components pairing map follows see exercise answer page pair 
pmap circ pair map circ main 
simulate pmap swap inputs length pmap circ bfly circ relates list list 
kinds circuits build remarkably recursive structures turns bfly id complicated way write identity function lists length 
bfly reverses list length main 
simulate bfly main 
simulate pmap swap choose basic component perfect shuffle lists length circuit call find butterfly components performs perfect shuffle 
main 
simulate bfly examples just wiring functions 
happens add functionality component 
bitonic merger best known uses butterfly network building mergers input output comparator 
start comparators integer inputs 
sorts ascending order descending 
imin imax imax imin main 
simulate main 
simulate ilv turns bfly sorts ascending order list half ascending second half descending vice versa 
call lists dec dec lists 
merger sorts lists called bitonic lists don need worry 
network known bitonic merger 
bfly sorts dec dec lists descending order 
main 
simulate bfly main 
simulate bfly knowing merger sorts dec lists allows build recursive sorter 
fact parameterise circuit comparator comp parameter define sorter time 
sorter sorts ascending order sorter sorts descending order 
sorter comp inp inp sorter comp outs sorter comp sorter comp reversed comparator merger bfly comp bitonic merger outs parl merger main 
simulate sorter main 
simulate sorter note sorter parameterised comparator sorter component 
really designed connection pattern connect comparators 
way tied comparators particular type 
long provide comparator component right type get back function type acts sorter 
step refine comparator component choosing concrete representation integer data 
examples representations parallel significant bit binary serial signed complement 
point refinement choose simply plug new component sorter function 
example lava allows design connection patterns reuse 
exercise asks build sorter comparator binary numbers designed earlier exercise 
interesting property sorting circuits comparators obey zero principle 
sorter works correctly lists integers containing zeros ones works correctly arbitrary integers 
test integer sorter checking works bits 
exercise asked define sorts pair bits 
need circuit sorts list bits min max min max need plug component sorter 
main 
sorter low low low low low low low high low low low high low low high high low low low high low low high high low low high high low high high high low low low high low low high high low low high high low high high high low low high high low high high high low high high high high high high high studying examples find developed interest butterfly networks look poses puzzle butterfly networks switches 
know solve puzzle managed 
exercises parallel composition associative 
circuits 
define connection pattern tri 
triangle delay elements inputs 
circuit useful 
gamma gamma delta delta delta theta theta theta theta theta bb gamma gamma delta delta delta theta theta theta theta theta bb gamma gamma delta delta delta theta theta theta theta theta bb shuffle exchange network binary adder shown chapter works binary numbers added length 
define binary adder adds binary numbers lengths 
general adder tree works size 
define wiring pattern corresponds perfect shuffle pack cards 
define wiring pattern inverse 
verify sorter defined chapter works list bits different sizes 
state property 
hint look exercise 
define comparator works binary numbers binary number sorter 
pack cards size repeatedly take back started 
consider circuits ilv ilv 

show pencil connection patterns bfly bfly 
give iterative recursive description butterfly network 
hint think number ilv combinators stack basic components 
find list comprehension useful 
turns input output components butterfly network called shuffle exchange network consists sequence identical blocks circ 
columns need assuming circ inputs outputs 
define shuffle exchange network lava 
check really butterfly network 
circumstances circuit designer prefer shuffle exchange network 
saw bfly reverses input list 
plugging input output wiring component butterfly 

chapter synthesizing lava circuits chapter number examples generate lava circuit different kind specification 
assume reader familiar haskell programming language 
state machines common way specifying sequential system constructing state machine 
state machine consists parts set states set inputs set initial states transition function 
transition function maps state input set states 
usually draw state machines pictures 
example state machine pictured 
haskell specify datatype representing state machines 
parametrize types states inputs 
data statemachine state inp statemachine states state inputs inp initial state transition state 
inp 
state describe state machine statemachine states inputs initial start example state machine 
active active active schematic translation state machine 
transition state inp 
state inp 
state state inp inp note somewhat clumsy definition transition function easier application states inputs mean 
specification terms state machine able translate circuit 
reason want prototype implementation state machine 
reason want verify circuit implementation equivalent translated version 
method translating state machine circuit pictured figures 
idea state state machine maps component emits active activate detailed view component belonging state 
circuit 
component delay element keeps track state 
component receives messages component activate depending inputs sends messages components activating 
advantage translation method states time allowing non deterministic execution state machine 
disadvantage state machine deterministic delay component state 
type circuits translating state machines circuit input signals list indicators state 
type signal bool 
signal bool type declare type translation function takes state machine state circuit 
statemachine eq inp eq state 
statemachine state inp 
statemachine machine 
define function maps input state machine corresponding signal wire 
input head sig input sig inputs machine zip input input create list components lookup table rest translation 
components component state state states machine component certain state consists pair active emits active indicator signal state emits lookup table representing signal send state 
component state active emits init state elem initial machine active delay bool init activating state emits state active input input inputs machine state transition machine state input declaration active uses delay component initial value depends state initial state value depends signals components sending computed function activating 
list emits constructed follows 
input signal transition function check states 
send signal component state active input incoming signal 
define function activating 
activating state orl activate emits components state activate emits state state components look messages wants send filter signals going right state 
take signals 
create list state indicators output components 
active active components circuit state machine specified earlier 
ina inb ina inb statemachine behavioral descriptions way specifying behavior circuit behavioral description language 
examples kind languages behavioral vhdl verilog esterel idea write program language transform program circuit behavior 
show compile programs simple description language circuit 
call language pace 
haskell datatype pace programs data pace skip emit wait ifthenelse signal bool pace pace signal bool pace pace 
pace pace pace pace program send messages type 
running pace program takes number clock cycles 
informal semantics pace constructs ffl skip program send messages takes time execute 
ffl emit msg program sends message msg takes time execute 
ffl wait program send messages takes clock cycle execute 
ffl ifthenelse cond signal cond high executes sends messages sends takes long time takes 
cond low 
ffl cond cond high executes sends messages sends waits amount time takes finish tries execute program 
cond low finishes right away sending messages 
program valid take clock cycle execute cond high 
finish start emits shape circuit representing pace program 
ffl 
sequential composition program executes waits time takes finish executes 
ffl parallel composition program executes parallel waiting finish finishes 
example pace program describe toggle change high inv change wait 
emit 
wait 
inv change emit 
wait 
wait read program follows 
forever wait change low emit message wait 
wait change low emit message time wait 
type messages pace program message 
give formal semantics language giving translation program circuit 
get implementation free 
going define function circuit takes pace program pace circuit 
type signal bool 
signal bool type signal bool circuit pace 
pace circuit see takes input called start activate program outputs list emits signal finished circuit uses indicate done 
list emits lookup table relates output messages signals 
start skip 
just connect start finish finish immediately 
circuit skip start finish finish start case emit connect start right output finish immediately 
circuit emit start emits finish emits start finish start execute wait connect start finish delay takes clock cycle finish 
circuit wait start finish finish delay low start transform ifthenelse transform subprograms prog prog 
start prog start high condition true start prog start high condition false 
collect emitted messages finish finishes 
circuit ifthenelse cond prog prog start emits finish emits finish circuit prog start emits finish circuit prog start start start cond start start inv cond emits emits emits finish finish finish transform transform subprogram prog 
introduce auxiliary signal called active high exactly consider starting prog loop started prog finished 
start prog active condition true 
finish loop active condition false 
circuit cond prog start emits finish emits finish circuit prog start active start finish start active cond finish active inv cond transforming sequential composition just connects finish start second collects emitted messages 
circuit prog 
prog start emits finish emits finish circuit prog start emits finish circuit prog finish emits emits emits lastly transforming parallel composition starts circuits started collects emitted messages synchronizes finish signals finishing 
synchronize circuit defined exercise answer page 
circuit prog prog start emits finish emits finish circuit prog start emits finish circuit prog start emits emits emits finish synchronize finish finish translator turn pace program plus list output messages interested circuit outputting messages 
compile eq 
pace 

signal bool compile prog outputs signals start delay high low emits circuit prog start signals orl sig sig emits outputs create top level start signal high clock tick low forever filter signals interested resulting circuit 
note take signals parts pace program emitting signal 
create toggle circuit pace program toggle change compile change compile pace circuit say interested messages 
exercises circuit produced state machine translation inputs effect outputs clock cycle 
desirable change state depending current input right away 
way interested initial state 
show change definition statemachine incorporate change 
verify toggle circuit derived pace program equivalent direct definition toggle circuit 
describe synchronize circuit exercise terms state machine generate circuit 
verify implementation answer correct 
describe synchronize circuit exercise terms pace program generate circuit 
verify implementation answer correct 
chapter types chapter describe role types play lava system 
signals circuits circuits lava functions input signals output signals 
basic signals lava low high integer signals 
type signals signal bool integer signals signal int 
notation low signal bool high signal bool signal int signal int signal int types circuits written symbol 
examples signal bool signal bool 
signal bool times signal int signal int 
signal int halfadd signal bool signal bool 
signal bool signal bool adder signal bool signal bool 
signal bool see types pairs written types lists written 
types explicitly written lava automatically derived checked 
type error example giving list signals pair signals gate input get main 
high low error type error application expression low high term low high type signal bool match signal bool signal bool connection patterns able deal types presence connection patterns need features polymorphism higher order functions 
ffl polymorphism means circuits connection patterns care kind type long matches unknown type 
ffl higher order functions allow functions parameters functions 
example type row connection pattern 
row 


see row expects circuit type parameter 
connection pattern care exactly long uses 
case type carry carries matched row 
apart type signal pair signals list pairs signals overloading seen number circuits functions behave differently different contexts 
called overloading 
overloading convenient different versions operations write general operations circuits overloaded operations 
example constant zero generalized version low 
behaves follows 
main 
zero error unresolved overloading main 
zero signal bool low main 
zero signal bool signal bool low low main 
zero signal int main 
zero signal bool signal int low example see lava complains idea kind context want zero 
lava program usually figured explicit shape result notation 
similar constant seen domain 
creates list possible values certain type 
behaves 
main 
domain signal bool low high main 
domain signal bool signal bool low low low high high low high high forth 
examples overloaded operators var random 
overloaded operations special version works lists 
reason case lists want know long 
create list low bits sum possible lists certain domain 
examples special list versions behave different contexts 
main 
signal bool low low low main 
signal bool signal bool low low low low main 
signal bool low low low high high low high high main 
varlist apa signal bool apa apa apa examples circuits overloaded delay mux equal 
appendix quick guide appendix overview options operations predefined circuits connection patterns lava 
lava command command line options lava command 
set memory size size interpreter module compile ghc module compile ghc default hbc module compile hbc update internal modules change executable executable 
compiler logical gates logical gates defined lava system 
binary gates corresponding binary operator example written 
nullary gates signal bool low constant low high constant high unary gates signal bool 
signal bool id identity inv inverse negation binary gates signal bool signal bool 
signal bool 
logical nand inverse logical 
logical inverse logical xor 
logical exclusive xnor 
inverse exclusive equiv 
logical equivalence impl 
logical implication ary gates signal bool 
signal bool andl logical inverse logical orl logical inverse logical logical exclusive arithmetical gates arithmetical gates defined lava system 
binary gates corresponding binary operator example plus written 
nullary gates signal int constant integer signal unary gates signal int 
signal int id identity neg negation unary conversion int bit integer signal boolean signal bit int boolean signal integer signal binary gates signal int signal int 
signal int plus addition times multiplication sub subtraction idiv integer division modulo imin minimum imax maximum binary gates signal int signal int 
signal bool gte greater equal ary gates signal int 
signal int addition multiplication generic gates generic gates defined lava system 
equal 
equality delay 
delay component mux furthermore lava defines operations types domain int 
zero int 
var string 
varlist int 
string 
module patterns get access wiring circuits connection patterns include import patterns top lava program 
swap 

copy 


zipp 

pair 


append 
serial 









compose 


int 



par 









parl 







ilv 


int 



int 



iter int 



bfly int 



tri 


pmap 


mirror 


row 


column 


grid 


module arithmetic get access arithmetical circuits include import arithmetic top lava program 
halfadd signal bool signal bool 
signal bool signal bool fulladd signal bool signal bool signal bool 
signal bool signal bool signal bool signal bool 
signal bool signal bool adder signal bool signal bool signal bool 
signal bool signal bool signal bool signal bool 
signal bool signal bool signal bool 
signal bool multi signal bool signal bool 
signal bool signal int 
signal bool signal int int bin int 
signal int 
signal bool bin int signal bool 
signal int module get access sequential circuits include import top lava program 
edge signal bool 
signal bool toggle signal bool 
signal bool 
signal bool 
delayn int 


signal bool 
signal bool puls int 
signal bool 





signal bool 
int 



note functions completely polymorphic certain restrictions 
interpretations various interpretations circuits lava provides 
simulations simulate circuit input circuit inputs circuit inputs test circuit vhdl name circuit name circuit input name circuit input output verification verify property options property property possible verification name name sat level depth depth increasing errors list number error messages occur running lava system 
ffl error garbage collection fails reclaim sufficient space means lava memory execute circuit 
try start lava memory saying lava 
increase number need 
error circuit definition 
circular definition 
ffl program error evaluating delay component get error try combinational simulation simulate simulate sequential circuit 

ffl program error evaluating symbolic value get error forall var property constructors tried simulate circuit 
ffl program error combinational loop get error defined circuit loop delay 
general circuits hard give meaning allowed normal lava simulation 
probably mistake 
try constructive simulation happens 
ffl program error combining incompatible structures get error delay component mux component structures different shape example lists different lengths 
allowed length list needs known evaluate circuit 
ffl program error equality defined type get error haskell equality signal type 
probably want signal equality 

ffl program error short circuit happens bad combinational loop circuit constructively simulate 
real circuit 
example circuit inv ffl program error output happens bad combinational loop circuit 
output wire driven component 
example circuit ffl program error enumerate symbolic values get error 
wires circuit constants 

constants 
ffl program error internal error 
oops 
probably means bug lava system 
please report bug sending program fix 
typical error liked appear please mail list complete 
appendix answers define swap copy swap copy define sorter way min max min max constant circuit high define multiplexer follows multiplexer left right left inv right built multiplexer lava called mux 
define multiplexer mux defined follows carryin carryout fulladd carryin fulladd carryout fulladd adder adder bs cs cs carryout adder low bs adder circuit takes input pair lists bits adder circuit gets list pairs bits 
binary number integer converter bin int bin int bin int bs num num bin int bs num bit int num define zipp zipp zipp bs rest rest zipp bs define abs bs bs abs define pair pair xs pair xs pair xs choose ignore input number elements odd 
define xys xys define parallel composition circuits par par circ circ circ circ define column column circ carryin carryin column circ carryin carryout bs carry circ carryin carryout bs column circ carry define column terms row 
define connection pattern called mirror swaps left right parts input output mirror circ circ row mirror input row column circ carryin carryout bs bs carryout row mirror circ carryin say column circ mirror row mirror circ define grid grid circ bs cs ds cs ds row column circ bs shorter grid circ row column circ define swap mux swap property defined ok ok inv second property stated ok 
swapped 
ok swapped check really subtracts define bs ok cs bs adder cs bs ok 
general property associativity circ bs cs ok circ circ bs cs circ circ bs cs ok 
define general verify function follows prop ns sequence prop ns verify property saying example main 

define follows inp delay high xor inp edge circuit 
define flipflop follows flipflop set reset state state delay low state state inv reset state set define follows init clk inp delay init val val mux clk inp circuit defined follows inp ok sofar delay high ok ok inp sofar circuits puls puls puls delay low inv delay low xor delay low nand counter define puls follows puls number counter number define circuit follows number number delay number number adder diff number diff replicate rest change 
rest inv 
define synchronize synchronize go go go go go xor go go wait delay low xor wait go wait define helper circuit 
output takes extra parameter done signal output time list empty 
done done sig sigs done delay sig rest rest sigs done define circuit follows sigs sigs property checks inp ok edge inp inp ok inv 
property checks equivalent ok ok 
ok 
ok ok ok verified induction depth 
property checks equivalent ok puls puls ok 
property checks ok low ok 
define property 
inp ok toggle inp delay low delay low 
inp delay low inp inp 
inp ok 
compute output input 
define outputs inputs different points time 
compute implication 
properties state ok load puls load toggle high ok 
ok toggle high high ok 
note need serial parallel converter property interesting input 
slowing circuit means important clock cycles ignore unimportant clock cycles 
look outputs say circuit behaves outputs 
slowed property true circuits equivalent 
problem 
parallel composition associative 


possibility define tri tri circ tri circ inp inp outs outs map circ tri circ ways defining 
example try defining tri 
give definition closely reflects informal explanation card sharp shuffles pack 
halves zips halves get lot pairs cards pats carefully sides pairs 
zipp circuit zipp defined exercise 
definition exactly inverse definition pair append need verify properties output sorter sorted 
verify checking output smaller second second output smaller third bits output bits input different order 
verify counting number high inputs high outputs checking 
details left reader 
inputs length row gets back started 
main 
simulate map int define butterfly circuit iteratively circ id circ compose circ change local definition component component state activated emits init state elem initial machine activated activating state active delay bool init activated 
rest definition stays 
bibliography 
sorting networks applications 
afips spring joint computing conference volume 

automatic verification combinational pipelined fft circuits 
computer aided verification 
springer verlag july 
koen claessen mary sheeran singh 
lava hardware design haskell 
international conference functional programming 
acm sigplan sept 
cooley tukey 
algorithm machine computation complex fourier series 
mathematics computation pages 
alexandre frey erard berry patrice bertin francois bourdoncle jean vuillemin 
jazz 
available www cma fr jazz 
nicolas halbwachs paul caspi pascal raymond daniel pilaud 
synchronous dataflow programming language lustre 
proc 
ieee 
steven johnson 
synthesis digital designs recursion equations 
acm distinguished dissertation series mit press 
jones 
hugs distribution 
currently available haskell org hugs 
simon peyton jones john hughes editors lennart augustsson dave barton brian boutel warren burton joseph fasel kevin hammond ralf hinze paul hudak thomas johnsson mark jones john launchbury erik meijer john peterson alastair reid colin runciman philip wadler 
report programming language haskell nonstrict purely functional language 
available haskell org february 
wayne luk geraint jones mary sheeran 
computer tools regular array design 
editors systolic array processors pages 
prentice hall international 
john matthews john launchbury 
elementary microarchitecture algebra 
int 
conf 
computer aided verification 
springer verlag lncs 
john donnell 
transistors computer architecture teaching functional circuit specification hydra 
functional programming languages education 
springer verlag lncs 
mary sheeran 
fp algebraic vlsi design language 
phd thesis programming research group oxford university 
mary sheeran 
fp language vlsi design 
acm symp 
lisp functional programming 
mary sheeran 
designing regular array architectures higher order functions 
int 
conf 
functional programming languages computer architecture lncs 
springer verlag 
mary sheeran 
describing reasoning circuits relations 
workshop foundations vlsi design 
kluwer 
mary sheeran 
puzzling permutations 
proc 
glasgow functional programming workshop 
index adder binary bit full half sequential tree adder adder andl append base case induction bfly bin int bintree bit int bitonic butterfly column command line options commutativity compilation compose composition parallel serial connection pattern properties sequential copy counter delay delayn depth edge equal equality equiv error messages flipflop fulladd garbage collection grid gte halfadd high hugs id idiv ilv imax imin impl implication increasing induction restricted states depth int bin int bit inv iter lava interpreter lava length list low map mirror multi multiplexer multiplexer mux mux see multiplexer nand neg orl pace pair par parl plus pmap program error properties puls puls quantification recursion row safety properties serial simulate combinational sequential simulate step induction sub swap synchronize test times toggle transition relation tree shaped circuits tri varlist verification verify combinational options sequential verify vhdl generation xnor xor zero zipp 
