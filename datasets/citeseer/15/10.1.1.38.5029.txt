planning constraint satisfaction solving planning graph compiling csp minh kambhampati department computer science engineering arizona state university tempe az email asu edu june deep affinity graphplan backward search process solving constraint satisfaction problems noted earlier relations primarily adapt csp search techniques backward search phase graphplan 
describes gp csp system planning automatically converting graphplan planning graph csp encoding solving csp encoding standard csp solvers 
comprehensive empirical evaluation gp csp demonstrates superior standard graphplan blackbox system compiles planning graphs sat encodings 
results show csp encodings outperform sat encodings terms space time requirements 
space reduction particularly important gp csp susceptible memory blow associated sat compilation methods 
inspired success van beek chen system 
contrast expects hand coded csp encodings individual domains problems gp csp able take domain descriptions strips pddl representation automatically generate csp encodings 
development original graphplan algorithm researchers noted striking similarities backward search phase graphplan constraint satisfaction problems :10.1.1.43.7263
cases detection similarities lead adaptation csp techniques graphplan 
example considered utility adapting explanation learning dependency directed backtracking strategies csp backward search phase graphplan 
researchers csp started interest applying constraint programming classical planning 
van beek chen describe system called achieves impressive performance posing planning csp problem 
important characteristic limitation expects hand coded srivastava explaining inner workings van beek chen constraint solver comments earlier drafts 
peter van beek putting csp library public domain patiently answering questions 
research supported part nsf young investigator award nyi iri arpa rome laboratory planning initiative army daah afosr nsf iri 
source code planner available downloading eas asu edu gp csp html backward search graphplan similar csp search adapt csp search techniques gp convert plan graph csp planning csp idea hasn investigated ebl kambhampati gp csp van beek reengineering technique hand coded gp csp framework comparison efforts take advantage similarity graphplan backward search csp search 
encoding humans setup domain problem encoding independently problem domain 
propose different route exploiting similarities planning graph csp problems 
describe implemented planner called gp csp solves planning graphs automatically converting csp encodings 
shows gp csp differentiates frameworks similarity backward search graphplan csp search 
generates implicitly specified constraints possible keep encoding size small 
encoding passed standard csp solvers csp library created van beek 
empirical studies show gp csp significantly superior graphplan blackbox compiles planning problems sat encodings 
gp csp dominance standard graphplan terms runtime advantages blackbox sat encodings include improvements runtime memory consumption 
relative advantages gp csp easily explained ffl backward search standard graphplan gp csp constrained directional search able exploit standard csp search techniques straight box 
involves non directional search speedup techniques arc consistency dependency directed backtracking learning variety variable ordering techniques 
practice gp csp orders magnitude faster standard graphplan benchmark problems 
ffl compilation planning systems blackbox typically highly susceptible memory blow csp encodings gp csp susceptible problem reasons 
general sat encoding problem tends anecdotal evidence suggests blackbox performance aips planning competition hampered mainly excessive memory requirements larger csp encodings gp csp terms variables 
second gp csp able implicitly specified constraints 
keep size encoding considerably 
ffl csp encodings provide structural advantages sat encodings 
typically csp problems structure sat problems argue improved structure exploited developing directed partial consistency enforcement algorithms suitable planning encodings 
knowledge scheduling ai done posing scheduling problems csp problems 
approaches gp csp may provide better substrates integrating planning scheduling 
fact related discuss csp techniques tease resource scheduling away planning 
rest discusses design evaluation gp csp 
section start brief review graphplan 
section points connections graphplan csp discusses planning graph automatically encoded dynamic csp problem 
section describe way gp csp automatically converts planning graph csp encoding format handled csp library developed van beek 
section describe experiments compare performance vanilla gp csp standard graphplan blackbox different sat solvers 
consider improvements encoding size section improvements csp solver section 
section discusses relation section summarizes contributions sketches directions 
review graphplan algorithm graphplan algorithm seen disjunctive version forward state space planners :10.1.1.43.7263
consists interleaved phases forward phase data structure called planning graph incrementally extended backward phase planning graph searched extract valid plan 
planning graph consists alternating structures called proposition lists action lists 
shows partial planning graph structure 
start initial state zeroth level proposition list 
level planning graph extension structure level involves introducing actions preconditions th level proposition list 
addition actions domain model consider set dummy persist actions condition th level proposition list 
persist action precondition effect 
actions introduced proposition list level constructed just union effects introduced actions 
planning graph maintains dependency links actions level preconditions level proposition list effects level proposition list 
planning graph construction involves computation propagation mutex constraints 
propagation starts level actions statically interfering preconditions effects inconsistent labeled proposition list level action list level proposition list level action list level planning graph variables delta delta delta delta delta delta domains fa fa gg fa gg fa fa gp fa gp fa gp fa fa gp fa constraints normal constraints activity init state dcsp planning graph dcsp corresponding mutex 
mutexes propagated level forward simple rules propositions level marked mutex actions level support proposition mutex actions support second proposition 
actions level mutex statically interfering propositions preconditions supporting action mutually exclusive propositions supporting second action 
search phase level planning graph involves checking see sub graph planning graph corresponds valid solution problem 
involves starting propositions corresponding goals level goals pair marked mutually exclusive search abandoned right away planning grown level 
goal propositions select action level action list supports actions selected supporting different goals mutually exclusive backtrack try change selection actions 
point recursively call search process gamma level planning graph preconditions actions selected level goals gamma level search 
search succeeds reach level corresponding initial state 
consider partial planning graph shown left graphplan may generated search solution 
delta delta delta top level goals want satisfy delta delta delta actions support goals planning graph 
specific action precondition dependencies shown straight line connections 
actions delta delta delta left level support conditions delta delta delta planning graph 
notice conditions level gamma supported actions 
marked connections actions denote action pairs mutually exclusive 
notice mutually exclusive relations graphplan derive mutual exclusion relations proposition level delta delta delta connections graphplan csp process searching planning graph extract valid plan seen dynamic constraint satisfaction problem 
dynamic constraint satisfaction problem dcsp called conditional csp problem generalization constraint satisfaction problem specified set variables activity flags variables domains variables constraints legal combinations 
dcsp initially subset variables active objective find assignments active variables consistent constraints variables 
addition dcsp specification contains set activity constraints 
activity constraint form variable takes value variables active 
correspondence planning graph dcsp clear 
specifically propositions various levels correspond dcsp variables actions supporting correspond variable domains 
types constraints action mutex constraints fact proposition mutex constraints subgoal activation constraints 
actions modeled values variables action mutex constraints modeled indirectly constraints propositions 
actions marked mutex planning graph pair propositions possible supporting actions possible supporting actions constraint fact mutex constraints modeled constraints prohibit simultaneous activation facts 
specifically propositions marked mutex planning graph constraint active active subgoal activation constraints implicitly specified action preconditions supporting active proposition action propositions previous level corresponding preconditions active 
propositions corresponding goals problem active 
shows dynamic constraint satisfaction problem corresponding example planning graph discussed 
ways solving dcsp problem 
direct approach involves starting initially active variables finding satisfying assignment 
assignment may activate new variables newly activated variables assigned second epoch 
process continues reach epoch note literal appearing different levels corresponds different dcsp variables 
strictly speaking literal proposition list level converted dcsp variable keep matters simple example contains syntactically different literals different levels graph 
variables delta delta delta delta delta delta domains fa fa gg fa gg fa fa gp fa gp fa gp fa fa gp fa constraints normal constraints activity init state dcsp variables delta delta delta delta delta delta domains fa fa gg fa gg fa fa gp fa gp fa gp fa fa gp fa constraints normal constraints activity 






init state 



csp compiling dcsp standard csp new variables activated implies success unable give satisfying assignment activated variables epoch 
case backtrack previous epoch try find alternative satisfying assignment variables backtracking assignment possible 
backward search process graphplan algorithm seen solving dcsp corresponding planning graph direct fashion :10.1.1.43.7263
second approach solving dcsp compile standard csp standard csp algorithms 
compilation process quite straightforward illustrated 
main idea introduce new null value denoted domains dcsp variables 
model inactive dcsp variable csp variable takes value 
constraint particular variable active modeled 
activity constraint form compiled standard csp constraint 


worth noting activation constraints concerned ensuring propositions preconditions selected action take non 
values 
allow possibility propositions active take non 
values strictly supporting preconditions selected action 
lead plans mutex constraints ensure unsound plans produced 
avoid unnecessary activation variables need add constraints effect actions needing variable precondition selected value variable earlier higher level variable value 
constraints typically going high arity wind mentioning large number variables previous level may harder handle search 
mutex constraint propositions active active compiled 

action mutex constraints standard csp form compilation activity constraints converted standard constraints entire csp standard csp 
solved standard csp search techniques 
worth noting mutex constraints derived constraints redundant 
soundness guaranteed long keep mutex constraints corresponding static interferences actions 
remaining propagated action mutexes fact mutex constraints redundant 
direct method advantage closely mirrors graphplan planning graph structure backward search 
possible implement approach plan graph structure explicitly representing constraints 
compilation csp requires planning graph converted extensional csp 
allow standard algorithms supports search follow epoch epoch approach assigning variables 
approach taken gp csp 
size csp encoding suppose average actions facts level planning graph average number preconditions effects action respectively 
indicate average number actions supporting fact notice connected relation ne ms indicate length planning graph 
gp csp need lm variables binary constraints ffl ln binary constraints represent mutex relations action levels 
see note actions mutex supports propositions supports propositions wind having model constraint constraints legal values propositions supported take 
ffl lm binary constraints represent mutex relations fact levels 
ffl binary constraints activity relations 
possible compile csp problem propositional satisfiability problem csp problem boolean variables 
accomplished compiling csp variable domain fv delta delta delta vng boolean variables form delta delta delta constraint form delta delta delta delta delta delta compiled delta delta delta delta delta delta 
essentially done blackbox system 
compilation csp strict requirement doing non directional search 
describe technique allows backward search graphplan non directional see discussion section 
default sat encoding blackbox need variables encoding models actions propositions boolean variables constraints clauses ffl ln binary clauses action mutex constraints 
ffl lm binary constraints represent mutex relations fact levels 
ffl lm clauses length describe constraints fact require action support 
ffl lnp binary clauses indicate action implies preconditions 
expressions indicate gp csp lm variables compared blackbox sat encoding 
number constraints relatively higher gp csp 
increase ln constraints modeling action mutexes gp csp ln constraints clauses increase necessary csp actions variables mutual exclusions actions modeled indirectly constraints legal combinations 
section describe exploit implicit nature constraints gp csp reduce constraints 
fact direct translation planning graph csp leads higher number constraints doesn necessarily mean gp csp consume memory sat encodings 
gp csp represents constraints implicit fashion making compact representation 
may domains savings memory implicit representation offset increase due number constraints 
implementation details compiling planning graph csp mentioned previous section gp csp uses csp encoding planning graph 
basic idea graphplan build planning graph representation convert csp encoding lines illustrated 
csp library created van beek constraints put format accepted library 
implementation level details way encodings generated 
start removing irrelevant nodes planning graph 
done essentially doing reachability analysis starting goal propositions final level 
step reduce size encoding refers part planning graph relevant solving current problem 

propositions minimized graph unique csp variable number actions graph unique csp value numbers 
notice fact mutex action mutexes static interference mutexes redundant 
necessary guarantee correctness solution 
correspond extra binary constraints resulted doing directional partial consistency graph expansion phase 

domains individual variables set set actions support planning graph plus distinguished value corresponding propositions levels goal level 
null value placed value domain variable 

setting constraints van beek csp library allows definition implicit constraints 
allowing definition schematized constraint types declaring constraint particular type holds set variables 
constraint type associated function check assignment constraint variables constraint satisfied assignment 
gp csp define types constraints called respectively activity constraint fact mutex constraint action mutex constraint 
activity constraints just ensure variable non null value second variable non null value 
fact mutex constraints ensure variables non 
values simultaneously 
action mutex constraints ensure values assigned variables pair actions mutex 

checking constraints 
csp formulation accepted van beek csp library general sense allows specify variables participate constraint type constraint 
explicit representation solver automatically generate set satisfying failure assignments set constraints csp formulation write customized checking functions type constraint implicit representation 
things easier checking constraints create global hashtable setting csp formulation 
hashtable maps index individual constraint actual actions participating constraint 
activity constraint action assigned fact higher level cause fact lower level active 
mutex constraint pair actions allowed values variables constraint 
constraint checked solver corresponding checking function consult hashtable match current values assigned variables values hash entry constraint return value true false accordingly 
results initial encoding implemented gp csp completely begun comparing performance graphplan planning systems including standard graphplan blackbox compiles planning graph sat encoding 
note systems original implementation graphplan 
differences performance solely searching time conversion time 
matter fact time convert cnf gp csp graphplan satz relsat time mem length time mem length time mem length time mem length bw steps bw large log rocket log rocket log log log hours hours hsp bw hsp bw hours hsp bw hours grid hours grid hours hours grid hours table comparing direct csp encoding gp csp graphplan blackbox 
problems hsp bw ran sun ultra ram machine 
hsp bw ran pentium mhz machine running linux ram 
form blackbox csp encoding gp csp similar quite trivial compared graph expansion searching times 
example problem log blackbox spends converting expanding searching 
problem best gp csp implementation takes conversion expanding graph solving csp encoding csp encodings solved gac cbj solver generalized arc consistency conflict directed backjumping 
solver system 
table compares performance systems set benchmark problems taken literature 
results show gp csp competitive graphplan blackbox state art solvers satz relsat clear cut winner domains see graphplan better serial parallel blocksworld domains worse logistic gp csp sat solvers quite close problems 
particular interest columns titled mem give amount memory swap space program solving problem 
expect gp csp uses implicit constraint representation take space blackbox converts planning graph sat encoding 
problems establish dominance 
example logistics problems take megabytes memory gp csp take megabytes memory blackbox sat encoding 
exception memory dominance gp csp parallel blocks world domain taken hsp suite 
inefficient way csp encoding uses represent mutex constraints increase memory requirements compared blackbox 
domain number actions give fact quite high leads higher number mutex constraints gp csp formulation compared sat 
gp csp able outperform bot satz relsat domain 
columns titled length table give length plans returned solver terms steps terms actions 
statistics show solution returned gp csp strictly better equal blackbox satz relsat tested problems 
problem standard directional backward search graphplan returns shorter solutions 
explained noting standard backward search proposition activated action needs proposition precondition gets chosen search branch 
contrast mentioned section activation constraints gp csp encoding capture part leaving open possibility propositions active action needing proposition selected 
lead longer solutions 
loss quality kept check fact default value ordering note mention time sat solver blackbox need convert cnf form structure 
extra time needed gp csp system convert directly structure gac cbj solver 
comparisons meaningful run satz relsat solvers strategy setting cutoff limit 
mainly random restart technique unique sat solvers see example discussion random restart strategy introduced graphplan backward search 
running times sat solvers depended initial random seeds take average runs problem 
fc ac mutex fc bw steps bw large log rocket log rocket log hsp bw hsp bw table solving csp encoding different local consistency enforcement techniques 
fc ac stand forward checking arc consistency 
running time reported cpu seconds 
strategy considers value variable proposition long forbidden consider value 
currently considering adding constraints capture part activation see improves quality significantly worsening performance 
preliminary experimentation best settings solver encoding 
particular considered relative advantages doing arc consistency enforcement vs forward checking utility keeping fact mutexes mentioned earlier derivable action mutexes 
table shows results study 
column titled fc shows result applying forward checking types constraints column titled ac shows result arc consistency types constraints 
forward checking involves doing constraint propagation variables constraint instantiated 
arc consistency eager attempts propagation binary constraints variables constraint un instantiated 
comparison columns shows forward checking better problem 
went forward checking default experiments including reported table 
column reports effect removing redundant fact mutex constraints encoding assuming doing forward checking 
comparing column titled fc see including fact mutex constraints encoding change solving time tested problems problem log solve times faster include fact mutex constraints 
problem fact mutex constraint considerably slows search worsens memory consumption decided keep default encoding gp csp encoding 
illustration differences explicit implicit representation mutex constraints 
improving encoding size exploiting implicit constraint representation mentioned earlier gp csp encoding described models mutex constraints way compact possible 
mutex constraint actions translated constrains proposition action variable value combinations leading total ln constraints 
explicit representation mutex constraints allowed gp csp win sat encodings terms memory cases increased number constraints increase memory consumption especially domains parallel hsp blocks world 
devised method uses implicit constraint representation exploits graphplan data structures reduce number constraints needed model action fact mutexes ln lm lm respectively number proposition actions level length planning graph keeping arity constraints binary 
shows example demonstrates differences explicit implicit encodings mutex constraints details compact encoding ffl contrast normal encoding start mutex relation pair actions set constraints pair effects actions start nodes fact levels compact encoding 
pair relevant facts level check pair actions supporting mutex 
exists pair set mutex constraint involving facts 
ffl notice normal encoding commit specific action mutex set csp mutex constraint general information relation supporting actions compact encoding 
order check normal encoding compact encoding time mem length mutex total time mem length mutex total bw steps bw large log rocket log rocket log log log hrs hsp bw hsp bw hsp bw grid grid hours grid table utility encoding mutex constraints compactly constraint need data structure contains pair propositions list forbidden action assignments propositions 
fact graphplan keeps data structure accessed function mutex standard implementation 
suppose action mutex constraint facts current values assigned csp solver call mutex check mutex particular action assignment 
tell csp solver reject current assignment 
clearly approach number constraints needed model action mutexes lm worst case pair propositions level may related action mutex 
experiments new encoding show help reduce number csp constraint representing graphplan mutex relations times 
table shows comparison types encoding 
columns named mutex show number csp mutex constraints reduced times compact encoding compared normal 
result memory consumed gp csp shown mem columns table reduced times problems mb memory consumed blackbox see table 
new encoding easier solve problem 
particular problem log hsp bw solved times faster normal encoding 
problems get speedup 
problem experiences considerable slowdown easy problem 
compact encoding superior direct encoding 
improvements csp solver csp solver initial experiments gac cbj solver comes pre packaged constraint library 
gac cbj uses forward checking conjunction conflict directed backjumping 
solver quite competitive blackbox graphplan decided investigate utility variety enhancements commonly improve csp solvers 
enhancements investigated include explanation learning ebl level variable ordering random restart search cutoff limit backtracks distance variable value ordering min conflict value ordering constraints 
experiments date enhancements demonstrated significant improvements performance 
limit discussion enhancements 
complete details experiments 
ebl nogood learning important extension solver incorporation ebl helps solver explain failures encountered search explanations avoid similar failures 
nogoods stored partial variable value assignments semantics assignment subsumes nogood refined solution 
extending gac cbj support ebl reasonably straightforward conflict directed backtracking provides required apparatus identifying minimal failure explanations 
specifically nogood recording process similar jump back learning discussed 
know identify failure explanations decide explanations store 
indiscriminate storage nogoods known increase memory consumption runtime terms cost incurred matching nogoods current partial best known solutions problem csp size learning relevance learning 
degree size learning ignore nogoods size greater nogood names variables values 
degree relevance learning scheme ignores differs current partial assignment variable value assignments 
relevance defined respect current partial assignment relevance nogood varies backtrack partial assignments search 
table shows time memory requirements solving problems blocksworld serial parallel rocket logistics domains size relevance learning schemes 
size learning experimented size limits 
results suggest nogood size gives best compromise results time memory requirement problems 
blocksworld domains bigger size nogoods learn better speedup able get 
especially parallel blocksworld domain significant speedups occur 
problem size ebl relevance ebl speedup mem ratio gp csp rel ebl gp csp graphplan satz relsat bw steps bw large rocket rocket log log log hsp bw hsp bw hsp bw grid grid grid table incorporating ebl gac cbj 
times second 
problems ran sun ultra unix machine mb memory 
consistent tables problem hsp bw ran linux machine 
prob ldc ldc dcl gp bw steps bw large rocket rocket log log hsp bw hsp bw hsp bw grid grid grid table gp csp different variable orderings 
ebl experiment size ebl maximum nogood size set 
experiments done ultra unix machine hsp bw ran linux mhz machine 
relevance learning experimented relevance limits 
cases included size limit nogood size greater stored notwithstanding relevance 
columns grouped heading relevance ebl table show performance relevance learning terms time memory consumption 
see relevance learning generally faster best size learning larger problems 
memory requirements relevance sized learning similar 
relevance learning default gp csp 
columns table show speedups time relative memory consumption gp csp armed relevance ebl compared naive gp csp compact encoding graphplan blackbox satz relsat 
example cell row named rocket column titled relsat value 
means gp csp ebl times faster consumes times memory blackbox relsat problem 
results show ebl memory consumption gp csp increased consistently times smaller blackbox satz relsat solvers 
gp csp faster blackbox relsat powerful sat solver basically uses search techniques gp csp gac cbj ebl bw large problem 
slower satz problems bw large log 
solution length terms number actions returned gp csp smaller equal satz relsat solutions returned gac cbj ebl ones returned gac cbj reuse reuse reuse reuse reuse reuse mem mem mem mem mem bw steps mb mb mb mb mb mb bw large mb mb mb mb mb mb log rocket mb mb mb mb mb mb log rocket mb mb mb mb mb mb log mb mb mb mb mb mb log mb mb mb mb mb mb log mb mb mb mb mb mb hsp bw mb mb mb mb mb mb hsp bw mb mb mb mb mb mb hsp bw mb mb mb mb mb mb hsp bw mb mb mb mb mb mb table reusing ebl nogoods levels 
nogood learning strategy experiment size ebl values 
experiment columns show time seconds memory consumptions mb 
reusing ebl nogoods encodings problem planning graph size really superset planning graph size csp encodings corresponding planning graphs considerable overlap 
graphplan backward search exploits overlap encodings reusing failures memos encountered searching level planning graph improve search level planning graph 
contrast discussed point exploit overlap treats encodings essentially independent 
blackbox fails exploit overlap consecutive sat encodings 
inter level memoization typically quite useful standard graphplan implemented version gp csp ebl exploits overlap consecutive encodings storing nogoods learned encoding reusing succeeding encodings 
main technical difficulty nogood sound th level encoding may remain sound th level encoding 
sound strange blush structure planning graph ensures variable th level encoding identical domain inter variable constraints th level encoding 
imply nogood variables hold encoding 
change go iteration specific variables active non 
values change level level 
specifically suppose problem attempting solve single top level goal th level encoding variable corresponding proposition level required non 
value 
go th level non 
value constraint shifts leaving free take value domain 
nogood delta delta delta th level produced required non null value longer sound th level encoding 
fortunately way producing nogoods retain soundness successive encodings 
involves explicitly specifying context nogood holds 
example remember nogood delta delta delta contextualized nogood safely applicable encodings 
producing nogoods involves modifying base level ebl algorithm tracks flaws variables non 
constraints resolution forced search specific failures conjoining learned nogoods 
section kambhampati provides algorithms generating contextualized nogoods adapted algorithms gp csp 
managed implement inter level nogood usage verify correctness disappointment reusing recorded nogoods provide favorable cost ratio 
inter level nogoods lead consistently worsened performance intra level nogoods problem 
table shows comparison results reusing ebl nogoods consecutive encodings default strategy reusing 
possible reasons exploiting nogoods previous levels didn lead improvements expected 
plausible explanation phenomenon caused differences graphplan memoization strategy standard ebl nogoods see 
particular pointed graphplan memos seen nogoods form 
delta delta delta 
propositions level planning graph 
nogoods correspond conjunction exponential number standard csp nogoods form delta delta delta due allowance inter level nogoods total number nogoods gp csp increases drastically graphplan go higher level encodings 
result benefit reusing nogoods previous encodings decrease driving utility storing matching previous level nogoods 
course possible increase reusability nogoods concentrating graphplan style nogoods gp csp context 
nogoods effectively requires search gp csp done level level akin graphplan 
unfortunately experiments section show solving csp encodings level level variable ordering strategy rarely best choice gp csp 
second minor issue augment program compiles planning graph csp encodings additional book keeping information proposition level planning graph conceptually mapped csp variable encodings 
notice go level level nogood learning process terminate csp search stopped 
result learn big nogood higher level encoding 
utility specialized heuristics variable value ordering level variable ordering standard graphplan better gp csp domains serial blocksworld wondered level level variable ordering graphplan help gp csp speed search domains 
currently solver gp csp uses dynamic variable ordering prefers variables smaller live domains breaks ties constrained variable ordering prefers variables take part constraints followed level variable ordering prefers variables higher levels planning graph 
call default strategy dcl strategy 
dcl strategy gives tertiary importance level information 
variable ordering graphplan tried variable orderings ldc gives primary importance level gives secondary importance 
variable ordering strategies compared table 
easily see new variable orderings significantly speedup gp csp blocksworld domains slow search logistics domain 
hsp variable value ordering results previous section suggest simple variable ordering schemes dvo effective csp encodings planning problems 
variable value ordering heuristics suited planning problems different classes domains worth investigating 
section describe variation variable value ordering heuristics graphplan algorithm discussed 
heuristics difficulty achieving propositions graph alternatively distance initial state measured number action applications needed achieve initial state 
distance fact node graph approximated level appears plan graph structure 
difficulty achieving set propositions computed terms distances individual propositions sum max operation see 
call distance estimates hsp values terminology :10.1.1.16.5803
specifically compute hsp values fact action nodes graph follows ffl hsp value fact value level appears plan graph 
ffl hsp value action maximum value max hsp sum sum hsp hsp values preconditions 
hsp values fact nodes setup variable ordering hsp values action nodes value ordering csp search 
backward search graphplan go backward level level choose set actions time heuristics discussed values applied set propositions 
search planner done variable time 
modify way calculate distance heuristics fit csp context 
prob max sum default skip normal skip normal skip normal log rocket log rocket log log log log log log hsp bw hsp bw bw steps bw large grid grid table hsp values variable value orderings csp search 
skip means skip bearing levels start solving level 
normal means csp search normal way graphplan starting level goals appear non mutex 
hsp values guide search follows csp basic strategy choosing difficult assigning value variable constrained value 
difficulty measured number remaining value dvo number constraint variable participate approximate distance number actions initial state 
specifically search involves ffl choosing csp variable corresponding fact node highest hsp value 
ties broken normal constrained variable ordering heuristic 
ffl selected variable choosing value domain corresponding action smallest hsp value 
table shows results hsp values variable value orderings set benchmark problems 
values table running time seconds 
variable orderings experiments hsp values described 
column titled max shows results max hsp value ordering column sum shows results sum hsp value ordering 
suggested tested cases problem normal case start searching level goals appear non mutex skip case skip levels contain solution start solution bearing level 
results show tested problems new heuristics speed search normal cases 
speedup search bw large times slightly improve search time gridworld problems 
results second testing case start solution bearing level promising 
case speedup gridworld prob gp csp satz relsat rocket rocket log log log table gp csp cutoff limit blocksworld problems get improvements logistics problems 
result agrees observation 
contrast results normal skip cases logistics problems suggests fairly solution bearing level hsp heuristics misleading search non solution levels contributes high total searching time default case 
observation table difference performance max sum heuristics 
big differences problems log rocket running times close remaining problems 
result shows value orderings important compared variable ordering solution bearing search 
random restart search tested strategy randomly restarting search limited number backtracks 
strategy quite effective handling heavy tail distribution solutions planning domains 
table shows result setting cutoff limit value class logistic problems 
table shows speedups random restart search change relative superiority gp csp blackbox 
cutoff limit gp csp better sat solvers problems 
setting right cutoff limit different problems different domains tricky issue received attention 
related compilation approaches quite popular planning years 
compilation approaches construct bounded length disjunctive structure substructures subsume valid solutions length 
concentrate identifying substructure corresponds valid solution 
extraction need address issues 
writing set constraints model constraints valid plan 

compiling constraints standard combinatorial substrate 
discussed answers question boil deciding type proof strategy basis checking correctness plan 
essentially standard proof strategies corresponding progression regression causal proof 
translation planning graph gp csp seen regression proof 
tradeoffs encodings different proof strategies investigated believe tradeoffs continue hold csp compilation substrate 
standard answers second question compilation substrates include propositional satisfiability constraint satisfaction integer linear programming 
compilation different types canonical problems offers different advantages 
example ip encodings exploit linear programming relaxations give global view problem provide natural support continuous variables 
sat encodings benefit developments fast sat solvers 
csp encodings exploit rich theory local consistency enforcement implicit constraint representations 
additionally fact knowledge scheduling csp models may csp encodings natural candidates scenarios require close integration planners schedulers 
successful compilation approach planning kautz selman satplan hand coded sat encodings bounded length planning problems 
ernst extended idea advocating automated construction sat encodings strips type problem specification 
studied tradeoffs multiple different compilation techniques 
kautz selman developed blackbox system automatically converts planning graph sat encoding 
including kautz considered hand coded integer programming encodings planning problems 
despite fact similarities graphplan planning graph csp sat noticed early van beek chen consider compilation planning problems csp encodings 
mentioned earlier emphasis hand generating tight encodings individual domains defend approach pointing constraint programming taken seriously 
appreciate efficiency advantages hand coded encodings believe facets encodings effective ones incrementally automated 
gp csp step process automatically constructs csp encoding competitive direct compiled approaches solving planning graphs 
expect improve encodings introducing ideas distances symmetry exploitation 
wolfman surveys approaches existing literature help automatically discover hand coded knowledge encodings 
seen implicit representations exploiting richer structure csp problems automatically generated csp encodings outperform automatically generated sat encodings terms memory terms cpu time 
mentioned lifted sat solvers provides way improving memory consumption requirements sat encodings 
believe lifting transformation adapted csp encodings 
directions described graphplan variant called gp csp automatically converts graphplan planning graph csp encoding solves standard csp solvers 
described experimental studies comparing gp csp standard graphplan blackbox family planners compile planning graph sat problems 
comprehensive empirical studies evaluate tradeoffs offered variety encoding simplifications solver optimization techniques 
results clearly establish advantages csp compilation approaches planning 
gp csp superior standard graphplan blackbox variety solvers terms time significantly outperforming systems problems 
importantly gp csp susceptible memory blow problem systems compile planning graph sat encodings 
url eas asu edu 
html contains language implementation gp csp system 
progress till promising way just begun scratch surface terms exploiting possibilities offered csp encodings 
considering different directions extending exploring general csp encodings improving csp solvers planning related enhancements 
terms plan investigate temporal csp representations basis encodings gp csp 
representation actions propositions take time intervals values 
encodings offer clear cut advantages handling planning problems metric time provide significant reductions memory requirements gp csp problems involving non metric time 
specifically efficient graphplan implementations bi level planning graph representation keep compact 
compilation strategies gp csp sat compilers blackbox wind unfolding bi level representation losing compression 
contrast time intervals values allows maintain compressed representation compilation 
improve csp solvers planning specific enhancements considering incorporation automatically generated state invariants csp encoding automatically identifying variables encodings marked hidden csp solver handle visible variables handled 
additions useful intent essentially automatically generate encodings 
ai scheduling systems csp encodings gp csp provides promising avenue attempting principled integration planning scheduling phases 
currently exploring avenue integrating gp csp csp resource scheduler 
model planning scheduling phases loosely coupled csps communicate exchanging failure information terms graphplan style goods 
bayardo miranker 
complexity analysis space bounded algorithms constraint satisfaction problem 
proc 
th nat conf 
artificial intelligence 
blum furst :10.1.1.43.7263
fast planning planning graph analysis 
artificial intelligence 

mixed integer programming models planning problems 
cp workshop constraint problem reformulation 
bonet geffner 
planning heuristic search new results 
proc 
th european conference planning 
bonet geffner 
robust fast action selection mechanism planning 
proc 
aaai 
dechter meiri pearl 
temporal constraint networks 
artificial intelligence 

solving planning graph compiling csp 
proc 
aips 
ernst millstein weld 
automatic sat compilation planning problems 
proc 
ijcai 
fox long 
detection exploitation planning domains 
proc 
ijcai 
fox long 
efficient implementation plan graph 
journal artificial intelligence research 
frost dechter 
dead driven learning 
proc 
aaai 
ginsberg parkes 
satisfiability algorithms finite quantification 
proc 
kr 
kambhampati 
challenges bridging plan synthesis paradigms 
proc 
ijcai 
kambhampati 
improving graphplan search ebl techniques 
proc 
ijcai 
kambhampati 
relation intelligent backtracking failure driven explanation learning constraint satisfaction planning 
artificial intelligence page spring 
kambhampati 
planning graph dynamic csp exploiting ebl csp search techniques graphplan 
journal artificial intelligence research 
kambhampati 
distance goal ordering heuristics graphplan 
technical report asu cse tr arizona state university 
kambhampati parker lambrecht 
understanding extending graphplan 
proceedings th european conference planning 
url eas asu edu graphplan ps 
kautz selman 
pushing envelope planning propositional logic stochastic search 
proc 
aaai 
kautz selman 
pushing envelope propositional logic stochastic search 
proc 
aaai 
kautz selman 
blackbox unifying sat graph planning 
proc 
ijcai 
kautz 
state space planning integer optimization 
proc 
aaai 
srivastava 
investigating effect relevance reachability constraints sat encodings planning 
proc 
aips 
mali kambhampati 
utility plan space causal encodings 
proc 
aaai 
mittal falkenhainer 
dynamic constraint satisfaction problems 
proc 
aaai 
rintanen 
planning algorithm non directional search 
proc 
kr 
smith frank jonsson 
bridging gap planning scheduling 
knowledge engineering review 
smith weld 
temporal planning mutual exclusion reasoning 
proc 
ijcai 
srivastava kambhampati 
scaling planning resource scheduling 
proc 
ecp 
tsang 
foundations constraint satisfaction 
academic press san diego california 
van beek 
library csp routines 
university alberta www cs ualberta ca 
van beek chen 
constraint programming approach planning 
proc 
aaai 
weld anderson smith 
extending graphplan handle uncertainty sensing actions 
proc 
aaai 
wolfman 
automatic discovery domain knowledge planning 
generals 
university washington 
zimmerman kambhampati 
exploiting symmetry plan graph explanation guided search 
proc 
aaai 
zweben fox 
intelligent scheduling 
morgan kaufmann 

