convenience tilings peter van emde boas illc wins universiteit van amsterdam tv amsterdam july tiling problems provide simple transparent mechanism encoding machine computations 
gives rise simple master reductions showing various versions tiling problem complete various complexity classes 
investigate potential tiling problems subsequent reductions showing hardness combinatorial problems really matter 
approach means examples short reduction chain knapsack problem followed hilbert reduction similar ingredients 
deterministic exponential time lowerbound propositional dynamic logic 
resulting reductions relatively simple principle orthogonality reductions abuse extra structure instances problems reduced results fact instances generated master reduction previously 
presents results originally obtained tiling problems combinatorial reductions application ideas 
aside wish hardly accessible papers broader audience looking improved understanding tiling problems convenient source combinatorial reduction 
shall see hand simplicity tiling problem combined local structure tiling constraints problems attractive reductions 
hand encoding computational structures means tilings sufficiently transparent information computational realm available combinatorial world invoked needed 
relates distinction arbitrary reductions master reductions 
phrase master reduction reduction computational problem combinatorial problem intended directly visible correspondence records accepting computations computational problem solutions combinatorial problem consideration 
traditional proof cook levin supported part hcm program complexity logic recursion theory nr 
dg coma theorem establishing np completeness satisfiability prime example master reduction formulas propositional logic constructed reduction designed way satisfying assignment encodes computation record accepting computation 
providing reduction problem shown np complete new problem new master reduction may obtained master reduction composition assuming reduction preserves reasonable way solutions combinatorial problem 
trivial turn requirement formal condition reductions literature preserve correspondence 
time reductions shown preserve solvability scope wider required order provide master reduction prove np hardness problem defined solvable instances outside range original master reduction fact presenting proving reduction felt exploit information follows assumption particular instance translation computational problem violation principle orthogonality reductions correctness reduction combinatorial structure problems 
discuss number reductions obtained violating principle 
shall consider known master reduction tiling problem infer number known completeness results 
combinatorial reduction tiling problem set covering problem known result known shortcut 
short treatment karp original reduction set covering problem knapsack problem 
extra information obtained investigating combination reductions 
insight obtained supports hilbert reduction originally discovered reduction provides elementary proof undecidability solvability exponential diophantine equations davis putnam robinson part hilbert problem 
final section person game version tiling problem staring point new proof known hardness result propositional dynamic logic 
case discover orthogonality principle termination assumption computational world easily expressed reasonable condition tiling games adapt rules determining winner tiling games 
turing machine model cook levin theorem basic model computational world standard single tape turing machine 
turing machine device consists finite control reading head moves way infinite tape consisting tape cells 
machine described finite set internal states finite alphabet sigma tape symbols initial state blank symbol sigma program program relation theta sigma theta theta sigma theta fl rg 
meaning quintuple machine state reading symbol reading head replace symbol tape symbol change internal state perform move reading head tape denotes move step left right means don move 
indication termination instruction 
configuration machine consists finite string tape symbols internal state indication symbol currently scanned reading head 
configuration conveniently encoded string format sigma theta sigma sigma 
string encodes left part tape scanned symbol internal state right part tape 
encoding impact instruction easily expressed context sensitive production rule 
example instruction corresponds collection production rules sigma 
rule added order represent effect instruction performed scanning rightmost symbol tape 
full computation input gamma sequence configurations gamma initial configuration corresponding gamma production rules corresponding program halting configuration instruction executed 
configuration may replace pair symbol way indication machine halted internal state longer matters 
convention regularly terminating computation accepts input 
machine model nondeterministic sense pair single instruction may applicable 
allowed applicable instruction available configuration containing pair successor sequence 
sequence configurations terminating manner represents finite rejecting computation 
infinite computations 
machine program pair applicable instruction called deterministic 
configurations computation represented dimensional tableau symbols representing single tape square aligned 
tableau represents time space diagram computation time running top bottom space represented horizontal direction 
height width diagram represent time space computation 
notwithstanding fact time space defined way obtained machine interpretation resulting measures turn reasonable 
polynomially bounded overhead time constant factor overhead space resource requirements algorithm turns independent machine model implemented provided model selected collection studied reasonable sequential models 
way example consider machine program typical computation machine represented time space diagram machine searches state input symbol moving right blank detected moves left state rewriting symbol time space diagram computation successor machine blank symbol detected subsequently rewritten move machine halts 
considering input denote number written binary interpretation computation straightforward machine incremented binary counter 
turing machines count counting represents basis mathematics surprise turing machines represent universal formalisms computability 
time space diagram obtain direct proof cook levin theorem states np completeness problem satisfiability satisfiability input formula oe language propositional calculus built set propositional variables fx question exist truth value assignment variables fx oe assignment evaluates true 
nondeterministic machine accepts set strings time space denotes length input string question string belongs expressed satisfiability formula oe obtained follows input belongs exists time space diagram accepting computation input width height bounded sigma denote set states tape symbols set symbols may occur time space diagram sigma theta sigma 
jlj 
introduce propositional variables intended meaning row column th symbol written 
consider means terms variables diagram defined describes legal computation machine accepts 
formula oe conjunction large number local clauses enforcing condition position diagram position symbol written symbols position gamma gamma gamma denotes set incompatible quadruples symbols exclusion enforces proper computation diagram 
clauses express symbols written diagram encode resembling computation locally 
clauses add clauses representing condition initial row diagram initial configuration condition easily enforced sequence unit clauses computation terminates accepts condition enforced requirement bottom row diagram symbols sigma 
interesting observe formula obtained way size proportional traditional textbook proof cook levin theorem produces larger formula size 
larger size caused part formula enforces configuration accepting computation position reading head uniquely determined 
condition stated explicitly head position encoded separately rest configuration 
basing proof time space diagram uniqueness head position direct consequence local consistency diagram enforced explicitly 
master reduction basic combinatorial problem consider tiling problem 
tile square unit size divided triangles diagonals 
tile type obtained selecting colour finite set colours triangles 
tile types rotated reflected image tile type symmetry transformation general considered different tile type 
see 
note example tile types occur image rotation degrees 
expresses explicitly particular tiles may rotated 
tiling mapping subset square grid plane set tile types equivalently covering region plane instances tiles tiling property tiles share horizontal vertical edge plane equal colours triangles adjacent edge 
see 
sample tile types region legally tiled tile types reduction arbitrary adjacency relations matching colours effect condition tile types exists horizontal vertical compatibility relation tile type horizontally compatible colours right side triangle equals colour left triangle alternative way defining tiling problems start arbitrary horizontal vertical compatibility relation finite set tile types 
evidently relations induced colouring obey special structure condition compatible compatible compatible alternative definition represents larger class structures 
hand construction suitable set intermediate tile types pair arbitrary compatibility conditions encoded standard coloured tiles price doubling size region covered 
construction sketched 
tiles placed grid points coordinates represent original tiles tiles coordinates connecting represent horizontal vertical compatibilities remaining tiles odd coordinates filler tiles type 
example represent original tile types pairs horizontal compatibility relation pairs vertical 
alternative construction yielding reduction see gradel 
third way enforcing compatibility relation bumps dents real life jig saw puzzle format compatible tiles dual equal geometrical structures shared edge 
resulting compatibility relations structural property format short cut reduction knapsack problem 
tiling problem consists set tile types region plane tiled instances tiles furthermore specified additional constraint colouring part edge region extended single tile placed included resulting tiling 
specific instances tiling problems consider problems bounded tiling input set tile types theta square region colouring edge question exist tiling extending colouring edge 
tiling input set tile types pair segments top bot length question exist height exists tiling theta rectangle top bottom edges top bot respectively white left right sides 
white fixed colour set colours origin constrained tiling input set tile types single tile type question exist tiling entire plane placed origin 
origin constrained quadrant tiling input set tile types single tile type question exist tiling positive quadrant plane placed origin 
unconstrained tiling input set tile types question exist tiling entire plane 
recurring tiling input set tile types single tile type question exist tiling entire plane infinitely 
usefulness tiling problems obtaining reductions computational problems results known translation time space diagrams turing machine computations machine tilings set tile types entirely determined construction originates robinson ideas go back wang berger 
idea enforce adjacent horizontal lines tiled region encode successive configurations com putation time run downwards 
enforcing region tiled initial configuration input colouring top boundary bottom boundary accepting configuration encoded forces entire tiling encode accepting computation 
order explain construction tile types notation tile type denotes tile left colour top colour right colour bottom colour furthermore denote white colour delta 
sigma denote state tape symbol alphabet horizontal colours tiling selected set sigma theta sigma vertical colours white colour 
moving configuration larger part turing machine tape happens tape symbol preserved transition 
behaviour encoded tiles shape delta delta tile type tape symbol sigma including blank symbol 
tape cell presently scanned head may scanned head configuration head moves corresponding tape square left right neighbour 
behaviour encoded tiles shape delta delta 
note having tile types creates problem tiles may placed indicating position configuration tape symbols configuration pair phantom heads appeared 
phenomenon may occur quantum mechanical reality happen encodings turing machine computations 
easiest way prevent normalizing turing machine program way state obtains direction transferring state head moves right left directions 
stated program contains tuple contain tuple time underscores represent arbitrary symbols proper type 
set includes pair theta sigma tile types depending direction state 
third sort tile types represents instructions program example instruction encoded tile type delta instruction yields tile type delta delta 
halting instruction encoded delta delta 
way include instruction corresponding tile type 
note due directionality states happen colour occurs right left side instruction tile 
consequently situation pair heads annihilated leaving plain tape symbols configuration 
various sort tiles obtained way illustrated 
performed translation case successor machine described previous section 
sample computation machine encoded tiling illustrated 
construction easy obtain theorem theorem bounded tiling complete class np demonstration model tiling puzzle inch tiles full colours presently teaching purposes university amsterdam 
tile types obtained reducing turing machine program tiling complete class pspace origin constrained tiling origin constrained quadrant tiling pi complete recurring tiling sigma complete difficult show problems belongs class claimed complete show problems hard classes 
hardness results obtained direct master reduction turing machine computations tiling problems 
evidently bounded tiling encodes computation time space bounded completeness class np 
corridor tiling encodes computation explains pspace completeness problem 
suitable modification set enforce unique way extending row containing particular tile type yields encoding initial configuration machine blank tape bottom edge arbitrary neutral colour easily extended top half plane top edge 
computation blank tape terminates tiling extended particular row encoding halting configuration 
solvable instances origin constrained problem translation correspond diverging computations 
explains pi completeness problem 
tiling representing computation similar encoding show recurrent tilings correspond recurrent turing machine computations computations return infinitely initial state explaining sigma completeness result 
bounded versions bounded tiling tiling completeness results obtained explicit boundary condition 
suitable extension set colours enforce tile type single column single row column 
version question square size rectangle width white sides tiled 
construction destroys nice features previous proofs fact tile set entirely determined machine independently input turn determines boundary condition 
far complicated proof needed show problem unconstrained tiling pi complete 
reason tile set variations mentioned typically include tiles evidently allow trivial tiling plane tiles representing unchanged tape symbols example 
result unconstrained tiling pi complete originally proved berger proof subsequently simplified robinson 
proof requires construction set tiles supporting tiling plane supporting periodic tiling plane tiling obtained tiling fixed rectangle equal top bottom sides left right sides respectively 
case tile sets supporting tiling plane support periodic tiling lemma set solvable instances unconstrained tiling recursive 
constructing sort tensor product tile set enforcing aperiodic tilings plane set enforce aperiodic tiling encodes longer longer initial segments turing machine computation 
machine computation halts encoding get stuck 
conversely arbitrarily long initial segments computation machine exist support infinite computation 
final version master reduction takes world person games 
way looking alternating turing machine model consider person game players alice elias turn select transition machine 
task elias take machine accepting state alice wants prevent 
starting initial configuration elias winning strategy takes accepting configuration strategy alice input accepted alternating machine alice force machine reject prolong game forever input rejected 
evidently alternating character preserved consider person tiling games players tile entire row region tiled turns 
artificial sort game 
shown version players place turn single tile subject standard left right top bottom order placements results intended completeness results 
results obtained 
formally person tiling game consists tile set region tiled possible additional constraints previously 
fixed order cells game played letting player place tile free position subject compatibility tiles placed previously boundary constraint applicable 
elias player move 
player unable perform move set tiled looses game 
set fully determined start game case bounded tiling elias wins completing tiling 
region tiled particular shape case corridor tiling elias wins completing tiling required shape 
alice wins preventing elias attaining goal possibly letting game go forever 
main ingredient proof modification construction set prevents player deviating protocol encoding proper turing machine computation 
example introducing state accepting tile delta position shouldn player ruin game 
problem solved turning move immediate loss game 
hand elias able prevent alice moving head square left refusing play state accepting tile 
problem solved dividing moves stages stage player announces intent move second stage move performed assistance player failure provide support yields immediate loss 
details refer 
result obtain completeness results tiling games obtained master reduction theorem person bounded tiling pspace complete person tiling exptime complete results follow known results alternating complexity classes construction 
alternative way encoding alternating turing machine computations tiling games gradel 
tilings described terms adjacencies matching colours conditions 
players place turn series tiles forced give turn opponent 
construction exists correspondence turns alternations encoded turing machine computation 
yields complete tiling games bounded levels polynomial time hierarchy 
gradel considered bounded versions tiling problems 
constructions provides complete game feasible complexity classes furthermore shows dimensional versions tiling game complete 
master reduction bounded tiling interesting property 
encoding consisting part representing tile type set followed part encoding sides boundary observes length part fully determined turing machine specific problem np machine fixed part bounded tiling instance fixed 
size second part linear size square tiled turn proportional time computation 
bounded tiling instance produced master reduction size proportional running time accepting nondeterministic turing machine 
master reductions literature quadratic cubic blow instance size required 
note quadratic blow results soon encoding bounded tiling instance requires list cells square individually 
shortcut knapsack problem textbook proofs np completeness knapsack problem see example garey johnson textbook introduce sequence intermediate problems reductions 
problems nice properties uses just interested proving np completeness knapsack problem students cryptography course detours better eliminated feasible define problems section 
problems mentioned refer standard textbooks 
exact cover input finite set family subsets question exist covering consisting mutually disjoint members knapsack input sequence nonnegative integers target value question linear equation solution 
stated alternatively written sum subsequence elements 
standard proof satisfiability way formulas required cnf literals clause sat 
sat reduced problem called dim matching requires cover union disjoint sets points disjoint triangles family member contains member sets reduction requires substantial amount component engineering 
dim matching easily seen special case general problem exact cover just requires find disjoint cover set consisting subsets family restrictions cardinalities members size covering 
final bit string encoding described karp original completes chain reductions knapsack problem 
seen master reduction satisfiability obtained encoding state time transition diagrams yields reasonably short propositional formula cnf 
construction transparent reducing bounded tiling needs assign new meaning variables row column tiling tile type placed 
equals number tile types 
resulting propositional formula consists parts tile placed clauses size tiles placed theta clauses size incompatible pairs horizontal vertical edges theta clauses size boundary condition easily enforced theta unit clauses 
resulting formula cnf part cnf 
real shortcut direct reduction bounded tiling exact cover requires unintuitive component engineering 
needs geometrical insight 
magic word digitizing equivalence various forms tiling problem proceed true jig saw world bumps dents aligning bumps dents horizontal vertical edges tile types ensure tile placement solution corresponds specific grid position 
step replace tiles represent continuous subsets euclidean plane finite discrete sets pixels obtained digitizing sufficiently fine scale expose differences various bumps dents 
area covered tiles finite set consisting pixels image placement tile type proper grid position finite subset pixels add single set expressing boundary condition 
evidently correspondence tilings original square coverings disjoint subsets translation bounded tiling special case exact cover 
idea simplified specific structure bumps dents 
colour occur horizontal vertical edge need matching pair bump dent bump dent won match ones corresponding different colours 
realized assigning horizontal vertical edge occurring boundary square tiled finite set points fp fq corresponding colours occurring horizontal vertical edge 
dent corresponding colour take singleton set fp fq bump take complement set gamma fp fp gamma fq fq 
digitized tiles bumps top left edges dents bottom right edges 
note encoding properly placed tile covers pixels square cell corresponding position located 
pixels noninformative may removed construction 
effect size set reduced factor theta 
resulting translation earlier illustrated 
structure reduction evident need precise description sets consider set just draw edges grid cells square size theta observe occur vertical edges top square horizontal edges 
reasons regularity convenient add spurious horizontal edges right side square similarly vertical edges added bottom see 
result effectively added new cells right bottom side square including single cell having left upper corner right lower corner square 
evidently added points covered sets reducing tilings exact cover extending tiling region spurious edges cover boundary set extension set consists theta theta points 
introduce constants theta theta equals size number elements systematic way cell cell row row top bottom cell takes care points upper left edge 
added cells cover right lower side original square spurious edges 
key observation numbering explicit description sets available 
set numbers fa am number introduce notation set fa am sg 
define th tile type horizontal vertical colours tile set gamma gamma nice expressions sets theta theta tile placement set results shifting tile set depending tile type distance fully determined position 
observation key hilbert reduction section 
need describe boundary set set determined colouring edges original square 
gamma gamma denote colour th th edge top left bottom right border square respectively obtain unpleasant expression gamma gamma theta gamma gamma theta gamma gamma theta theta gamma gamma theta theta theta gamma theta theta gamma theta theta terms cover contributions upper left lower right side square followed spurious edges lower right side square 
tilings problems resulting encoding turing machine computation colours edges square constant white colour corresponding blank tape symbol section top encoding input 
encoding accepting configuration consists tape filled blank symbol 
effect sets sets expression constant shows disturbance proportional size input consists union arithmetic sequences 
observation needed section 
final step reduction chain knapsack problem unchanged karp construction 
need details sequel 
assume set gamma denote family subsets exact cover 
associate target value gamma member knapsack item represented radix digit strings consisting 
evidently exact cover members yields translation yields solution resulting knapsack equation 
conversely solution originates exact cover provided radix selected large addition proceeds generating carry 
choice larger number elements 
bound sharpened number element occur member gamma members bound appropriate instances produced exact cover instances generated reduction bounded tiling edge grid adjacent precisely cells edge border square case points occur tile placement sets grid cell possibly boundary set 
suffices denotes number tile types 
chain reductions lower bound radix determined turing machine program independent length input 
convenient take power satisfying 
observe nice structure sets preserved relation theta theta translates theta thetac thetam corresponding knapsack items values factorize product consisting factor depending tile type factor completely determined position tile 
similar concerning various sets united set representing boundary 
contribution set consists set possibly determined edge colour shifted distance depending position 
translates product 
explicit expression gamma gamma theta thetai gamma gamma theta thetaj gamma gamma theta thetan thetai gamma gamma theta thetan thetaj gamma theta thetan thetai gamma theta thetan thetaj expression notation gamma expression similar sets consisting edge colours 
case edge colours constant sides border colour factor may factored result knapsack weight corresponding side tiled region product constant factor multiplied sum geometric series depending height width region 
observations crucial hilbert reduction section 
conclude presenting final knapsack equation results reduction gamma note due combinatorics construction evident solution equation satisfy constraint expresses cell precisely tile placed pair hilbert reduction solution hilbert problem completed line research going decades 
result decision procedure solvability diophantine equations basically consists steps 
shown reduction halting problem solvability equations substantial larger language exponential diophantine equations undecidable 
result known early sixties results davis putnam robinson 
shown remaining exponential relations expressed restricted language diophantine equations shown 
historical survey refer 
section simplified proof davis putnam robinson part proof 
original reduction machine computations exponential diophantine equations encoding potential beta function realized mid ies far powerful technique obtained called dominance relation expressible exponential diophantine terms classic results lucas 
technique jones obtaining simplified proofs davis putnam robinson result 
presenting results workshop paderborn october raised question methods invoked register machine computations turing machine model 
proof answers question affirmatively 
obtained workshop published proceedings 
inaccessible private publication university paderborn proof remained unpublished 
presenting historical survey attempt explain problem solution 
hilbert asks tenth problem general method determining diophantine equation solvable 
equation represented polynomial integral coefficients integral variables 
alternatively require solution defined non negative integers easy see versions problem non negative integer written sum squares natural variables replaced integral variables price multiplying number variables factor doubling degree polynomial 
conversely integer written difference non negative integers converse reduction exists doubles number variables leaving degree polynomial invariant 
alternative way looking problem obtained realize solvability equation amounts truth existentially quantified sentence 
illustrates analogy hilbert problem problem expressibility mathematical properties order arithmetic 
fact seldomly interested just single diophantine equation solvability equations depending parameters 
investigate class predicates integers definable am am real question large class called diophantine predicates 
example halting problem resides predicates assuming translation sufficiently effective undecidability problem direct consequence 
result shows class large coincides full class recursively enumerable predicates larger evident definition turing machine brute force find solution equation exists 
result provides various nice representation schemes re sets 
denote th re set standard enumeration 
diophantine representability expressed existence polynomials satisfying reduction turns uniform exists single polynomial satisfying furthermore re sets represented range polynomial function domain solvability equation results mathematicians started look simplest polynomials satisfying conditions 
evident measures number variables degree 
jones lists number best results showing definite trade variables degree 
hard see degree reduced needs variables 
best known bound number variables equals degree order theta adleman investigated role size solution solvable equations resulted theory diophantine complexity 
sample predicates easily seen diophantine state property polynomial equation solvable es 
nonnegative positive square theta positive theta mod theta nonnegative gamma fact definitions involve single equation finite set simultaneously satisfied solution 
difficult see collection diophantine predicates closed finite union intersection 
follows relations theta set diophantine predicates definition closed existential quantification promote parameter unknown preserving equation 
life easy provided find simple method close diophantine predicates logical operations negation universal quantification 
key ingredient missing diophantine language simple method talking combinatorial structures sets sequences 
original proofs finite sequences numbers encoded single number residues mod 
arithmetic sequence divisors beta function 
exists alternative method dominance relation definition binary representations digit occurs locations digit occurs example binary representations sees 
observed iff odd special case general theorem due lucas theorem lucas prime number numbers radix represented digit sequences mod result proven considering polynomial mod binomial expansion radix expansion fact mod obtain thetax mod xn yn properties radix expansion entail choice values leads different exponent expression 
subsequently comparing coefficients expressions yields result 
relation shows binomial coefficients turn defined terms exponentials theta theta expression may choose suitably large chosen power 
correctness description seen inspection decimal representations small powers nice decimal numbers collected ingredients need describing reduction halting problem problem deciding solvability exponential diophantine equations 
loss generality consider instances halting problem simple form turing machine starts blank semi infinite tape computation halt 
techniques section construct collection tile types properties halts blank input exists number possible tile square size theta boundary colouring leftmost cell upper boundary colour corresponding edge colours white 
case machine diverges regardless size tiling theta square form possible 
previously structure set tile types depends program 
scenario boundary constraint fixed input 
important difference compared reduction bounded tiling size square tiled part solution specification problem instance 
dependence evident consider effects reduction section 
select radix power satisfying denotes number tile types 
tile corresponding basic set gamma gamma theta set dependent size output 
remember completely determined program 
set corresponding placing position square form theta theta set exhibits dependence reconsider set corresponding boundary constraint 
wh wv denote code white colour horizontal vertical edge 
set represents boundary constraint square entirely white 
gamma gamma wh theta gamma gamma wv theta gamma wh theta theta gamma wv theta theta theta gamma theta theta gamma theta theta order accommodate single non white colour edge update set gamma wh gamma expression quantities dependent size square theta inspect subsequent reduction knapsack equation 
target value knapsack instance gamma radix thetac 
depends size square sum geometric series obtain thetac gamma gamma 
shows simple exponential expression knapsack items theta thetac thetam size affects values means contribution bottom edge cell tiled effect leads expression form constants depend program 
furthermore exponent depends note dependencies expressed means simple exponentials 
boundary item obtain expressions gamma gamma wh theta thetai gamma gamma wv theta thetaj gamma wh theta thetas thetai gamma wv theta thetan thetaj gamma theta thetas thetai gamma theta thetas thetaj expresses boundary constraint entirely white square adjust obtain correct value gamma gamma wh gamma summands represents simple geometric series expression rewritten gamma wh wh theta thetas theta thetas gamma gamma gamma wv gamma wv theta thetas theta theta gamma gamma gamma gamma gamma wh quantity expressed simple exponentials 
knapsack equation 
task hopeless number unknowns dependent rearranging order summation obtain expression gamma subsequently substitute expressions obtained yielding gamma theta theta thetac thetam rearranged gamma thetac thetam theta gamma thetac thetam equation reduces linear equation theta longer represents knapsack equation unknowns gamma valued 
represent numbers special form keeping mind represents suitable power fact gamma valued see numbers written binary digits multiples theta previous section observed solutions knapsack equation obtained reduction satisfy condition pair condition translates equation gamma thetac thetam gamma thetac thetam gamma thetac thetam thetac gamma gamma theta thetam gamma gamma quantity structured number expressed binary digits exactly multiples theta positions corresponding added cells right boundary square form theta theta 
point invoke dominance predicate obey conditions conditions combined linear equation theta express need 
gathering seen far final reduction 
theorem turing machine effectively obtain collection constants dependent gamma wh wh gamma wv wv gamma properties machine halts started empty input system exponential diophantine equations solution theta thetac gamma gamma gamma wh wh theta thetas theta thetas gamma gamma gamma wv gamma wv theta thetas theta theta gamma gamma gamma gamma gamma wh thetac gamma gamma theta thetam gamma gamma theta note real unknowns equations remaining unknowns exponential expressions constants determined principle eliminated system 
lower bound pdl final example tiling problems reductions alternative proof deterministic exponential time lowerbound satisfiability propositional dynamic logic 
lowerbound originally proven fischer ladner means master reduction polynomial space bounded alternating turing machines 
seen computational power space bounded turing machines captured corridor tiling problem 
construction alternating space bounded turing machines conveniently simulated person version tiling game 
target reached designing reduction person corridor tiling game satisfiability pdl hoping resulting reduction turn elegant original 
pdl foremost logics programs 
invented pratt extended version known order dynamic logic developed harel standard example application intensional logic computer science 
system sound complete axiomatization means called segerberg axioms 
details refer harel chapter dynamic logic handbook philosophical logic cited 
purpose suffices give short description language semantics 
language consists expressions sorts formulas programs 
propositional variables rop represent basic building blocks formulas atomic program variables act building blocks programs 
formulas closed traditional connectives propositional logic 
programs closed regular operators sequential composition union kleene star 
rules grammar connection sorts ff denotes program oe denotes formula ff oe ff possible attain oe ff oe ff certain attain oe formulas 
oe denotes formula oe 
test oe denotes program 
standard semantics kripke structures amounts interpreting pdl multi modal logic highly structured set modal operators 
model consists set worlds called states interpretation propositional variables program variables 
rop interpreted subset act interpreted binary relation theta interpretation oe general propositions subsets standard obtain traditional meaning complement intersection union subsets defined standard way abbreviation oe oe 
interpretation ff binary relations capturing conception ff nondeterministic multivalued partial state transition obtained follows connectives interpreted relation product union respectively 
ff interpreted transitive reflexive closure interpretation ff 
semantics operators connecting sorts oe 
iff 
oe 

ff oe iff 
ff oe ff oe iff 
ff oe clauses show program modalities ff ff obtained standard kripke semantics modal logic 
model pdl formula oe interpretation world set states oe 
formula called satisfiable model 
shown satisfiability pdl formulas decidable means finite model construction formula model small model number states bound exponential function length formula model constructed deterministic exponential time leading dexp upper bound problem 
purpose show upper bound tight 
proof method consists expressing person version corridor tiling game means pdl formula way formula model iff player tiling game winning strategy 
consider instance person corridor tiling problem 
denote set tile types 
denote particular tile type enforce condition corridor sides white 
ensure tile placed 
width corridor denoted initial configuration upper corridor starts ends tile type elias alice turn place tile free location row row left right observing tiling adjacency conditions 
collection tile types 
tiles type represent sides placed alice elias referee game 
unable move loses game 
game won elias locates tile special type column 
loss generality assume placed column soon placed game terminates exists tile placed 
remaining tile types denoted ft consider possibility game doesn terminate 
require corridor include repeated rows 
evidently advantage elias construct repeated rows consider infinite game win alice 
introduce propositional variables intended meaning tile placed column corridor type furthermore introduce propositional variables meaning tile placement occurred column propositional variable encodes move true positions elias places tile 
introduce single program variable intended meaning move tiling game 
describe structure tiling game progression expressed pdl formula 
formula constructed reduction conjunction collection subformula expressing required conditions 
note intended model pdl formula state means position game 
conditions hold move elias alice expressed existential universal modal operator 
followed expressions hold move 
model formula represent complete game tree position tree alice elias move single successor positions required exist 
subformula expresses initial position game tn players alternate moves expressed subformulas express move occurs exactly column corridor tiles placed correct left right order expressed column exactly tile played expressed collection subformulas subformula expresses columns move changes need express tile placement obeys adjacency conditions 
tile placed column depends general tile placed left column gamma possibly column tile placed column constraint column tile type placed enforced 
denote collection triplets tile types illegal place right denote larger collection triplets describing illegal placements column subformulas express tile placements legal gamma gamma gamma express possible moves alice taken consideration 
requirement alice expressed subformulas gamma gamma gamma elias suffices express move turn 
easy see models conjunction pdl formulas represent legal game trees include position elias alice move possible successor configuration 
remains express initial state starting position game win elias 
evidently order elias wins game terminal positions states successor states game positions tile located column expresses winning condition elias 
expressed subformula formula insufficient guarantee game fact terminates 
existence infinite branch game tree interpreted win alice pdl formula incomplete 
compare proof original fischer ladner see obtained simplifications due fact combinatorics tiling game person variant simple compared turing machine configurations 
facing problem fischer ladner didn consider 
evident polynomial space bounded alternating turing machine may assumed terminate reason assume holds corridor tilings 
facing choice 
leave proof shape observing suffice eventually establishing required lowerbound pdl satisfiability consider reduction chain alternating turing machines tiling games pdl invoke hidden termination assumption implicit fischer ladner proof 
alternative extending formula component excludes presence infinite branches game tree 
strategy easily implemented introducing binary counter counts number moves 
positions counter overflows declared win alice enforce counter fact doesn overflow 
easy see required number bits counter proportional width corridor cn bits suffice suitable value bits counter represented propositional variables true bit equals 
formula expresses counter properly initialized initial state set subformulas express counter properly incremented move 
gamma gamma incrementing binary counter amounts replacing leftmost block followed substituting block remaining digits remain unaffected 
counter overflow detected bit 
termination game enforced final subformula number known results illustrated convenience tiling games stead turing machine configurations combinatorial structure proving lower bounds computation complexity theory 
higher regularity decreased interaction successive constituents combinatorial structure leads formula easier write understand 
example hilbert reduction shows notorious scenario relatively simple structured system exponential diophantine equations obtained starting turing machine model computation 
reverse side medal order reap gains frequently resort principle orthogonality reductions abuse structure instances problem generated previous reduction presenting reduction line 
remains seen examples master reductions encountered strategy shown offer advantages standard proofs literature 
adleman diophantine complexity proc 
ieee focs 
berger undecidability domino problem mem 
amer 
math 
soc 

domino tiling games comput 
syst 
sci 

chandra kozen stockmeyer alternation assoc 
comput 
mach 

cook complexity theorem proving procedures proc 
acm stoc pp 

davis hilbert tenth problem unsolvable amer 
math 
monthly 
davis robinson hilbert tenth problem 
diophantine equations positive aspects negative solution 
mathematical developments arising problems proc 
symposia pure math 
vol part ams 
pp 

davis putnam robinson decision problem exponential diophantine equations annals math 
ser 
vol 

fischer ladner propositional dynamic logic regular programs comput 
syst 
sci 

garey johnson computability intractability guide theory np completeness freeman 
gradel domino games complexity siam comput 

harel recurring dominoes making highly undecidable highly understandable karpinski ed proc 
fct springer lncs pp 

harel dynamic logic gabbay guenthner eds handbook philosophical logic vol 
reidel pp 

harel recurring dominoes making highly undecidable highly understandable ann 
discrete math 

jones universal diophantine equation symb 
logic 
jones register machine proof theorem exponential diophantine representation enumerable sets symb 
logic 
levin universal nie ix pp 
russian 
lewis complexity solvable cases decision problem predicate calculus proc 
ieee focs pp 

lewis complexity results classes quantificational formulas comput 
syst 
sci 

lewis papadimitriou elements theory computation prentice hall 
lucas sur les congruences des nombres des coefficients diff des fonctions un module premier bull 
soc 
math 
de france 
karp combinatorial problems 
miller thatcher eds 
complexity computer computations plenum pp 

kozen parikh elementary proof completeness pdl theor 
comp 
sci 
uber die zu den 
diophantine representation enumerable predicates nauk sssr ser 
math 

transl 
math 
ussr 
new proof theorem exponential diophantine representation enumerable sets im 
nauk sssr pp 

transl 
soviet math 

pratt semantical considerations floyd hoare logic proc 
ieee focs 
robinson undecidability non periodicity tilings plane inv 
math 

van emde boas bounded tiling alternative satisfiability 
ed 
proc 
nd frege memorial conference sep akademie verlag mathematische forschung vol 
pp 

sherman harel combined proof exponential decidability completeness pdl ed proc 
st workshop paderborn oct theoretische informatik paderborn 
pp 

van emde boas dominoes forever ed proc 
st workshop paderborn oct theoretische informatik paderborn 
pp 
van emde boas machine models simulations appear van leeuwen ed handbook theoretical computer science north holland publ 
comp 

preprint rep cs 
wang proving theorems pattern recognition bell system tech 


