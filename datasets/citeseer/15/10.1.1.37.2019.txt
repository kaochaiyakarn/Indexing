tries approximate string matching shang september tries offer text searches costs independent size document searched important large documents requiring spelling checkers case insensitivity limited approximate regular secondary storage 
approximate searches search pattern differs document substitutions transpositions insertions deletions hitherto carried costs linear size document 
trie method cost independent document size 
shang school computer science mcgill university montr eal qu ebec canada email cs mcgill ca experiments show new method significantly outperforms nearest competitor arguably important cases 
linear cost methods begins catch small files 
larger files complexity arguments indicate tries outperform linear methods larger values trie indexes combine suffixes compact storage 
text need stored spelling checker obtain negative overhead compression 
discuss variety applications extensions including best match spelling checkers case insensitivity limited approximate regular expression matching 
need find approximate match string arises practical problems 
example optical character reader interprets automatic checker need look resulting word say dictionary find edit matches substitution 
writer may transpose letters keyboard intended word worst case run 
time extra space ref 
naive mn kmp bm gamma sigmaj shift sigmaj sigmaj patricia log exact match algorithms say sent detected error 
applications occur strings text strings dna base pairs strings musical pitch duration strings edge lengths displacements diagram 
addition substitutions transpositions errors include insertions deletions 
approximate match problem strings development simpler problem exact match text characters alphabet sigma string pm characters find occurrences baeza yates reviews exact match algorithms summarize 
algorithms naive approach require preprocessing 
knuth morris pratt kmp boyer moore bm shift algorithms preprocess search string save comparisons 
algorithms sublinear practice better bigger depend patricia method builds trie truly sublinear 
preprocessing text search strings substantially greater linear algorithms need done text 
note tries size built ram time secondary storage memory differences better log method practical sizes trie 
quote complexity 
trie methods best suited large texts require secondary storage 
emphasize compare trie method experimentally linear methods 
approximate string matching adds parameter algorithm reports match string differs text term sublinear literature meanings distinguish sublinear truly sublinear 
truly sublinear means sublinear function log 
sublinear means truly sublinear multiplicative constant 
changes 
change replacement substitution insertion deletion 
transposition illustrated 
operations formulated damerau notion edit distances levenshtein 
dynamic programming dp algorithm shown wagner fischer mn worst case 
ukkonen improved kn clearly finding cutoff dp 
chang lawler worst case get sublinear expected time log space opposed earlier methods 
building suffix tree just patricia trie morrison pattern method detecting common substrings 
kim shawe taylor propose log algorithm preprocessing 
generate ngrams text represent trie compactness 
baeza yates propose counting algorithm runs time independent bounded zero characters pm distinct 
summarizes discussion 
agrep package related ideas limited regular expression matching pm regular expression 
regular expression matching approximate string matching solve worst case run 
time extra space ref 
dp mn mn cutoff kn kn suffix tree kn gram log approximate match algorithms different problems 
problem areas overlap place wildcard written regular expression approximate match coincide 
review techniques book stephen 
hall dowling give early survey approximate match techniques 
directed searches relatively small texts large fit ram 
texts require secondary storage far slow need log faster methods conventional files containing separate records 
price pay store index built text text changes 
interested text ordered sequence characters store text index represents additional storage requirement 
interested text substrings contains dictionary spelling check need store index achieve compression retrieval speed 
tries index large texts known truly sublinear way 
tries trees nodes empty potential subtree letter alphabet sigma encoding data binary tries 
data represented nodes path root leaf 
strings sharing prefix represented paths branching common initial path considerable compression achieved 
substring matching just involves finding path cost log plus terms number resulting matches 
log component reflects number bits required store pointers text unimportant 
regular expression matching note compression index may larger text 
typically index character text section index times size text 
index word index smaller compression results dictionary searches section great compression 
simulates regular expression trie fast log ff ff 
proposes approximate match algorithm dp text represented trie 
insight trie representation text drastically shortens dp 
theta dp table match pm text new table suffix length gamma 
trie representation compresses suffixes overlapping paths corresponding column need evaluated 
furthermore ukkonen cutoff terminate unsuccessful searches early soon differences exceed chang lawler showed ukkonen algorithm evaluated columns implies searching trie depth 
fanout trie sigma trie method needs evaluate sigmaj dp table entries 
method terms full text retrieval index text stored 
applications spelling checkers text dictionary set words need stored separately index 
special cases describe 
cases method offers negative storage overhead virtue compression addition fast performance 
compare experimentally agrep show tries outperform agrep significantly small number mismatches 
agrep complexity linear trie search complexity exponential agrep expected better tries large experiments show breakeven occurs practically important case 
authors agrep compare thoroughly approximate search techniques comparisons 
organized follows 
section introduces dp approximate string matches 
section briefly describes trie data structures gives new algorithm approximate search text tries 
give experimental results comparing approximate trie methods agrep 
sections discuss extensions advanced applications method including important case dictionary checking attain speedup compression 
conclude discuss possible research 
dynamic programming pm pattern target string respectively 
pm edit distance minimum number edit operations change pm edit operation insert delete replace transpose adjacent symbols pm assume symbols drawn finite alphabet sigma 
example example 
changing needs delete replace add edit distance recursively defined follows min gamma gamma gamma gamma ij gamma gamma ij oe null character ij ij gamma gamma evaluate pm need invoke times subscripts decreasing 
brute force evaluation take min calls 
pm theta possible values 
dp evaluates pm storing possible value theta table 
table shows theta dp table ab bbc 
oe oe oe table dynamic programming furthermore necessary evaluate values dp table entries 
ukkonen proposed algorithm reduce table evaluations 
algorithm works follows maximum 
gamma compute gamma set largest gamma chang proved algorithm evaluates expected entries 
shown table theta entries ukkonen algorithm evaluates entries 
ukkonen algorithm sets initial time 
evaluates column row 
largest entry value column row sets 
evaluates second column row 
largest entry value column row sets 
similarly evaluates third column row get fourth column get fifth column get indicates impossible change prefix edit operation 
know 
evaluation want know exact value 
trie approximate search follow gonnet semi infinite strings sistrings 
suffix text starting position 
text consists sistrings 
assume sistrings start word boundaries text echo sample example sistrings kind 
shows sistrings index trie constructed sistrings 
simpler truncate sistrings blank 
index full size sistrings simply replace leaf nodes locations text 
prevent proper suffix append arbitrary numbers null symbol text unique text symbol 
index trie distinctive properties ffl conducting depth traverse get sistrings get lexicographical order 
ffl searching string say example branching decisions node character string sought 
trie test letter get left branch second letter get right branch 
result search time proportional length pattern string independent text size 
text echo sample example sistrings echo sample example sample example sample example example example example ho ce ld ample le trie text index trie ffl common prefixes sistrings stored trie 
gives substantial data compression important indexing large texts 
trie methods text 
describe briefly 
constructing trie large number extremely long sistrings consider representation huge trie secondary storage 
tries represented trees pointers subtrees proposed morrison came patricia trie text searches 
orenstein compact representation uses bits node adapted secondary storage 
shang refined method workable patricia tries bit node 
essentially representations entail sequential searches trie bits partitioned secondary storage blocks trie nodes blocks grouped levels level nodes entirely entirely level blocks 
addition integers block sequential search restricted blocks may searched tree 
details representation see 
observations introducing approximate search algorithm give observations link trie method dp technique 
observation trie path prefix shared sistrings subtrie 
evaluating dp tables sistrings identical columns prefix 
columns need evaluated 
suppose searching string sane trie shown 
calculate distances word need evaluate tables 
table shows 
table entries ith column depend entries ji th column letters target word 
words sample prefix sam share table entries third column 
column words echo example columns words 
general path length dp entries words subtrie identical xth column 
observation tells edit distances indexed word general calculated traversing trie storing evaluating dp table 
sharing common prefixes trie structure saves index space search time 
observation ii entries column word prefix distance searching subtrie 
table table entries second column 
searching words differences evaluating strings subtrie sure sane en 
reason evaluating fourth column table sample find entries column evaluation 
observation tells necessary evaluate trie 
bypassed 
extreme case exact search trimmed 
search algorithm algorithm shows functions traverses index trie depth evaluates jth column dp table pattern string target string purpose illustration start evaluation word boundary explanation 
essentially algorithm trie walker cutoffs rejects reaching leaves 
node root path prefix shared strings rie 
changing possible prefix costs string rie array gamma max gamma max integer gamma gamma array max integer variables ukkonen cutoff array max character pattern target string oe integer number allowable errors procedure anode level integer depth trie search leaf node character node retrieve characters level retrieved character level find target word output return level mistakes return level level child node retrieve child node retrieved node level retrieved character level find target word output return level cut 
don search subtrie return level search subtrie function integer integer evaluate column dp table min length evaluate table entry min return approximate trie search algorithm mismatches 
need walk subtrie 
cutoff occurs 
letter jx path cause call 
ukkonen algorithm minimize row evaluations 
suppose misspelled word want words mismatches 
shows index trie intermediate results search 
evaluating ech find entries third column 
observation ii word prefix ech 
reject word echo continue traversing 
evaluating know word prefix need walk subtrie 
cut subtrie 
ech share prefix copy column ech evaluating observation 
evaluating path find example accept word 
search stops cutting path sa 
shows intermediate results search 
pattern string search path search path search path search path string distance action ech example sa reject cutoff accept cutoff depth ho ce ld ample le approximate trie search example experimental results built tries texts king james bible retrieved 
cac washington edu shakespeare complete works provided oxford university press section unix manual pages computer source programs selected randomly departmental teaching machine randomly selected ftp file names provided information system 
sistrings start character word boundary blank tab characters 
table shows sizes texts index tries 
search time randomly picked substrings texts searched substrings agrep trie algorithm 
elapsed time cpu time measured mhz machines mb ram mb ram 
table shows measured times averaged substrings seconds 
testing results show trie search algorithm significantly outperforms agrep exact match approximate match error 
exact match trie methods usually give search time proportional length search string 
measurements show trie search times exact match directly relate text size 
requires data transfers search path insensitive ram size 
ae average trie search depth 
average number columns evaluated assuring proven ae target string length ae 
complete trie worst case text trie trie search algorithm find substrings mismatches sigmaj expected time sigmaj paths depth column dp table rows 
time independent trie size 
fact trie algorithm better agrep small large agrep scans text linearly trie grows exponentially 
measured texts relatively small trie search brings data ram agrep ram size larger data size measured cpu times closer elapsed times 
query tested repeatedly data text trie cached ram searches cpu bound 
smaller ram size larger text data searches wait data transferred secondary storage 
agrep scans entire text search time linearly proportional text size 
file names different tested texts 
file names pairwise distinct 
substrings resemble helps agrep evaluation quickly 
help trie search trie shallow complete trie takes time scan top trie levels 
extensions trie search algorithm extended various ways 
example spelling checkers ask best matches words fixed number errors 
optical character recognizers may search words substitutions 
searching telephone numbers license numbers postal codes users require penalties certain types edit operations combination exact search approximate search remember numbers sure 
text searching patterns expressed terms regular expressions 
extensions described section section discussed 
dp 
best match applications know exact number errors search 
want strings minimal number mismatches strings mismatches string text having mismatches 
algorithm define preset small number minimal distance exists string text pattern simple method set arbitrary string text set pattern 
better way search pattern deletions insertions substitutions 
traverse trie pattern string 
subtrie corresponds character pattern skip character pattern look subtrie character 
number skipped characters initial traverse pattern leaf node path root leaf node 
set clear strings 
best match searching decreases monotonically 
weighted costs distances evaluated assumed cost edit operation 
may want different cost 
example substitution costs deletion insertion disallow deletions completely 
edit operations cost differently need modify distance function 
costs insertion deletion substitution transposition respectively 
assume costs 
disallow operation say insertions set 

redefine follows min gamma ij gamma ij gamma gamma ij gamma gamma ij ij ij ij ij gamma gamma furthermore may add cost changing case 
example case insensitive searches set case sensitive searches set 
may disallow case changes setting 
checking case difference mean case 
define ij replace ij ij ij gamma gamma gamma gamma concept changing cases extended generally 
example searching white page telephone numbers don want apartment number recognized telephone number replace character digit digit 
reason may want mix letters digits punctuation searching license plates rmp postal codes 
applications definitions ij ij give new interpretation elaborate 
combining exact approximate searches know advance certain parts pattern may errors 
example spelling checkers may give suggestions 
suppose knew suffix spelled right 
case want search part pattern exactly 
agrep standards denote pattern ga 
characters inside 
edited operations 
support exact approximate searches pattern need modify ij ij ij ij ij function predicate determines member character inside exact match 
function predicate tells character inside 
new definitions ij 
ij ij ij ij ij gamma gamma gamma gamma gamma definitions string guarantees matches ga 
insertions 
disallow insertions exact match introduce anchor symbol borrowed unix standards 
pattern ga means target strings suffix 
needs changed set false symbol followed pattern looks 
similar way introduce anchor symbol prevent insertions exact match 
example means target strings start letter ended suffix 
time set true 
approximate regular expression search ability match regular expressions errors important practice 
regular expression matching approximate string matching solve different problems 
may overlap coincide 
example regular expression place wildcard written approximate match substitutions insertions second character 
baeza yates proposed search algorithm full regular expression tries 
section extend trie algorithm deal regular expression operators errors 
extension operators single characters group operator 
example may search mismatches ab 
searching tries full regular expression approximation open problem 
alternative operator suppose want find postal codes 
introduce notation borrowed unix standard describe 
formally operator defines set alternative characters 
matches pattern exactly matches pattern mistake 
substituting character set allowable characters easily achieved redefining operators section section respectively 
pattern 
define words set allowable characters means matches characters defined operator 
case insensitive version 
syntactic sugar unix standards may denote lower case letters range characters vowels complement listed characters characters wild card 
star star allows associated characters deleted free replaced identical character free 
example ac abc abbc match pattern ab exactly 
means unbounded number digits appear function predicate says star associated pattern character support star operator need change ij ij remember means delete cost insert number cost 
give new definition follows ij 
ij ij counter algorithm extended provide counters 
star ab means unbounded number bs appear pattern ab says ac abc match exactly 
want strings abbc bs write pattern abf gc unix syntax 
support counters need modify ij 
means character deleted free 
define function says counter symbol associated pattern character new definition ij dictionary search dictionary mean text file contains keywords set strings pairwise distinguishable 
dictionary searches interested keywords relate pattern measurements case edit distance 
orders locations keywords important 
applications text file stored entirely trie structure 
trie dictionary trie 
experimental results show dictionary trie sizes file sizes english words 
words providing algorithm exact approximate searches data structure compressing data 
searches done structure decompression operations 
searching soundex codes example dictionary search 
replacing english words soundex codes storing codes dictionary trie able search soundex code efficiently exact trie search reduce soundex code size half 
searching inverted file example dictionary search 
inverted file sorted list keywords text 
trie structure keeps order keys 
storing keywords dictionary trie search keywords location 
furthermore trie algorithm provides search methods various patterns mismatches 
tries search exact matches long time 
expanded trie methods solve approximate string matching problem 
approximate search algorithm finds candidate words differences large set words sigmaj expected worst time 
search time independent algorithm achieves time complexity known 
algorithm searches trie depth shortcuts 
smaller cut 
irrelevant cut gives exact string search time proportional length string sought 
algorithm search full regular expressions 
proposed trie structure uses bits node pointers 
trie structure designed storing large sets word strings secondary storage 
trie partitioned pages neighboring nodes parents children siblings clustered terms pages 
pages organized tree structure searched time logarithmic file size 
trie method outperforms agrep results show order magnitude factor 
linear worst case performance agrep beat trie method moderately large documents measured 
spelling checkers searching minimal edit distance performs typographic errors phonetic errors 
example example difference scenery differences 
deal phonetic misspellings may follow giving weights edit operations phonetic similarity non integer distances obtain finer grained scores typographic phonetic similarities 
solution follow convention assumes mistakes letters gives higher penalty mistakes 
excluding errors allows bypass near trie root 
gives quicker search time reduces number possible candidates 
small set candidate words impose linear phonetic check 
difference short word say letters matches english words 
short words long words 
type error difficult correct context 
acknowledgments supported canadian networks centres excellence nce institute robotics intelligent systems iris projects ic natural sciences engineering research council canada nserc ogp 
apostolico 
myriad virtues suffix trees 
combinatorial algorithms words pages 
springer 
baeza yates 
string searching algorithms 
frakes baeza yates editors information retrieval data structures algorithms pages 
prentice hall 
baeza yates gonnet 
efficient text searching regular expressions 
ausiello dezani ciancaglini rocca editors proceedings th international colloquium automata languages programming lncs pages italy july 
springer verlag 
baeza yates gonnet 
new approach text searching 
communications acm 
baeza yates 
fast practical approximate string matching 
goos hartmanis editors proceedings rd annual symposium combinatorial pattern matching lncs pages tucson arizona april 
springer verlag 
boyer moore 
fast string searching algorithm 
communications acm 
chang lawler 
approximate string matching time 
st annual symposium foundations computer science pages st louis missouri october 
ieee computer society press 
damerau 
technique computer detection correction spelling errors 
communications acm 
gonnet 
efficient searching text pictures 
technical report oed centre new oed university waterloo 
gonnet baeza yates snider 
new indices text pat trees pat arrays 
frakes baeza yates editors information retrieval data structures algorithms pages 
prentice hall 
hall dowling 
approximate string matching 
computing surveys 
kim shawe taylor 
approximate string matching algorithm 
theoretical computer science 
knuth morris pratt 
fast pattern matching strings 
computer journal 
kukich 
techniques automatically correcting words text 
computing surveys 
levenshtein 
binary codes capable correcting deletions insertions reversals 
soviet physics dokl 
mccreight 
space economical suffix tree construction algorithm 
journal acm 

relational information systems 
reston publishing reston va 
shang 
trie methods representing text 
proceedings th international conference fodo lncs pages chicago ill october 
springer verlag 
morrison 
patricia practical algorithm retrieve information coded alphanumeric 
journal acm 
odell russell 
patent numbers 
patent office washington orenstein 
multidimensional tries associative searching 
information processing letters 
shang 
trie methods text spatial data secondary storage 
phd dissertation school computer science mcgill university november 
stephen 
string searching algorithms 
lecture notes computing 
world scientific pub 
ukkonen 
finding approximate patterns strings 
journal algorithms 

computerized correction errors 
comput 
hum 
wagner fischer 
string string correction problem 
journal acm 
weiner 
linear pattern matching algorithms 
ieee symposium switching automata theory pages 
wu manber 
fast text searching 
communications acm 
shang received degree computer engineering institute technology china degree computer science concordia university montr eal qu ebec canada ph degree computer science mcgill university montr eal qu ebec canada 
research interests include data structures searching techniques large textual spatial database data database programming languages parallel processing concurrency control 
dr shang replication server engineering sybase california usa 
received sc 
mathematics physics queen university kingston ontario canada phil 
theoretical physics oxford university 
years ibm joined school computer science mcgill university professor 
research interests database programming languages data structures algorithms secondary storage 
dr directs project mcgill university responsible data structures multidimensional data order trie structures text spatial data 
database programming language contributions project included domain algebra quantified tuple qt selectors relational mechanisms multidatabases metadata inheritance methods process synchronization nondeterminism computation mechanism unifies relations functions aspects constraint programming 
oe oe oe oe table ukkonen cutoff oe oe column oe oe oe delta delta delta oe delta delta delta delta delta delta table dynamic programming tables text text size sistrings trie nodes bible mb shakespeare mb unix manual mb program mb file names mb table text file index trie mb ram mb ram text elapsed cpu sec elapsed cpu sec agrep trie agrep trie bible shakespeare unix manual program file names bible shakespeare unix manual program file names bible shakespeare unix manual program file names table approximate search time 
