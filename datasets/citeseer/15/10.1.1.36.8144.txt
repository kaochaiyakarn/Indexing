achievements relational database schema design theory revisited joachim biskup fachbereich informatik universitat dortmund dortmund germany biskup ls informatik uni dortmund de 
database schema design seen decide formats time varying instances rules supporting inferences semantic constraints 
schema design aims faithful formalization application optimization design time 
guided heuristics separation aspects separation specializations inferential completeness unique flavor 
theory schema design investigate heuristics provide insight syntactic properties schemas related worthwhile semantic properties desirable syntactic properties decided achieved algorithmically syntactic properties determine costs storage queries updates 
known achievements design theory relational databases reviewed normal forms view support deciding implications semantic constraints acyclicity design algorithms removing forbidden substructures 
due great importance database applications database schema design attracted lot researchers accordingly lot insight schemas obtained 
side practical experience suggests follow basic design heuristics ramified considerable detail 
side theoretical investigations accumulated formal notions theorems database schema design 
unfortunately theory apparently impact practice 
purpose improve mismatch theory practice presenting known theoretical results schema design fresh unifying framework 
companion bis discuss shortcomings database schema design theory suggest directions elaboration 
aim providing complete survey established current contributions highlighting important examples 
accordingly literature understood just hints reading 
problem schema design purpose database system roughly summarized follows database system aims persistently storing large amount structured data shared various users efficiently managing data respect update execution query evaluation 
database structured data organized self describing way consists time independent part schema time varying part instance schema describes structure formal semantics possible instances 
design time database administrator representing group people involved basically perform steps abstracting modeling application formalizing formatting model 
step administrator models application hand employing disciplined linguistic framework descriptions reality say framework widely accepted entity relationship approach che 
second step administrator formalizes model declares database schema data definition language implemented fragment order logic 
step procedure fundamental paradigm semantic reality space concepts ideas laws logic language 
fig sketches basic assumptions paradigm obvious tried attempt helpful restricted tasks 
fig 
fundamental paradigm semantic fig indicates correspondences framework entityrelationship approach approved heuristic tool detecting reconstructing pertinent concepts syntax order logic set theory semantics studied formal language declarative programming 
er approach logic set theory syntax semantics entity ae simple composed constant symbol ground term function symbol element universe relationship ground fact tuple relation property attribute ae binary ground fact ground term tuple binary relation value function role place predicate symbol component relation abstraction universe discourse set constant symbols universe separation specialization formula phi comprehension power set generalization union aggregation intersection cartesian product constraint implicational statement model class key constraint equality isa constraint partition constraint constraint equality existence constraint referential constraint view rule set formulas relation action message statement positive information conjunctively added statement reduction model class fig 
correspondences entity relationship approach order logic set theory semantics steps design require decisions 
step administrator decide relevance certain aspects consideration 
important realize database system seen different related viewpoints system constitutes formal image outside manages autonomous formal documents example mediates formal messages communicating actors actor inserts message delivered actor query result example 
structure universe phi formula free occurances variables xn comprehension defined dm phi phi gamma fi fi xn delta fi variable assignment universe phi true structure assignment fi psi ae fact viewpoint appears comprehensive human individuals act outside application basic facts events reflected formal documents turn mediated time space database system 
database part overwhelming formalism reality bis surrounding users 
decisions relevant aspects available step design second step administrator decide structure formalization 
specifically decide problems essentially aspects application enumerated represented time varying enumeration ground facts formats statically declared schema 
aspects application inferrable derivable time varying enumerations possibly complemented additional input rules declared schema 
aspects constrain enumerations updates format conforming enumerations ground facts considered meaningful sense satisfy semantic constraints declared schema 
decisions result schema comprises formats enumerations time varying extensional instances produced life time database rules intensional views supporting queries semantic constraints 
fixed time schema statically determines dynamic behaviour database particular usefulness users 
fig illustrates design usage database summarizes terminology introduced far 
quality schema evaluated lines reasoning schema formalize application faithful achievable 
schema allow execute queries updates far operations foreseen efficiently possible 
point view schema design understood optimization design time 
faithful formalization achieved evaluated solely formal mathematical reasoning 
investigate database successfully provide technical support communications persons employ database users 
presumably successful support common agreement questions application modeling abstracting model enterprise description time varying description shared persistent local transitory local interpreting administrator users declaring updating querying integrating formalizing formatting schema instance query query result formats rules constraints enumeration ground facts result format rules implied ground facts algorithm logical implication fig 
design usage database entities considered basic 
relationships considered basic select basic ones actual redundancy free enumerations relationships completely inferred 
actions considered basic 
optimization design time evaluated formal mathematical terms considering storage costs basically determined size enumerated instances query costs basically time complexity anticipated queries particular declared rules schema update costs basically time complexity anticipated insertions deletions including maintenance semantic constraints declared schema 
design heuristics guidelines schema design summarized heuristics separation aspects declared format appropriate enumerate exactly aspect 
separation specializations declared format appropriate conform exactly specialization aspect 
inferential completeness meaningful aspects enumerated declared format inferrable query language 
unique flavor meaningful aspects identified understood expressing basic attributes omitting additional context information clearly administrator tentatively apply separation heuristic agreement entities relationships class considered basic 
justify property mathematically respect formally declared schema inferential power formal query language 
similarly administrator tentatively apply inferential completeness heuristic agreement selection basic relationships enumerations justify claimed completeness property mathematically respect selected formalization 
spirit application unique flavor heuristic firstly intuitive agreements subject mathematical verification respect selected formalization 
having mind achievements design theory rest artificially distinguish desirable syntactic properties schemas worthwhile semantic requirements properties refer purely syntactically schema requirements explicitly related semantics query language 
accordingly separation heuristics primarily suggest desirable syntactic properties completeness uniqueness heuristics worthwhile semantic requirements 
understood side syntax semantics closely related side computing aim eventually finding appropriate syntactic expressions kind notion 
tasks design theory order helpful achieving faithful formalizations pursuing design heuristics tasks design theory due task formalize worthwhile semantic requirements desirable syntactic properties schemas 
task state prove relationships formalized versions worthwhile semantic requirements desirable syntactic properties 
task find algorithms deciding achieving syntactic properties schemas prove correctness efficiency 
order helpful optimization design time additionally design theory tackle fourth task task prove desirable syntactic properties ensure low costs 
supplied appropriate solutions tasks administrator effectively benefit design theory 
design time administrator essentially deal syntactic material supported task evaluated respect semantic properties stated task task side operational cost stated task side 
achievements relational databases notations sake readability conciseness employ standard notations sloppy imprecise way 
order study carefully elaborated versions notations results reader consult particular textbooks mai ull ull vos ad ahv bis 
sc denotes relation scheme relation symbol set attributes possibly range values format sc local semantic constraints 
database schema comprises relation schemes rules global semantic constraints sc rn xn scn relation schemes extensional enumerations qm rules queries intensional views sc global global semantic constraints 
semantic constraints denoted follows sets attributes relation symbols omit components relevant current discussion 
instance notation sc indicate set attributes semantic constraints sc important omitted relation symbol 
functional dependency 
jz multivalued dependency join dependency pi ae pi inclusion dependency sc implicational closure set semantic constraints sc 
normal forms separation aspects formalized desirable syntactic property design heuristic separation aspects rephrased considering formats semantic constraints kind structure requiring nontrivial substructure correspond refer identify exactly aspect application 
depending class semantic constraints involved define different notations nontrivial substructure cases notion exactly aspect related concept identification unit pieces information 
order formalize heuristic desirable syntactic property normally referred normal form see task favor expressing separation requirement negative form structure contain forbidden substructures harmful respect quality measures 
algorithms achieve high quality schemas conveniently described iterated schema transformations stepwise detect remove forbidden substructures 
popular normal forms listed fig giving names forbidden substructures cod cod fag del zan bbg fag ken df name forbidden substructures nf third normal form sc attribute sc bcnf boyce codd normal form sc sc nf fourth normal form 
sc ae sc nf fifth normal form sc gamma sc exists sc referential normal form pi ae pi sc sc unique key normal form sc minimal sc minimal fig 
normal forms forbidden substructures view support inferential completeness formalized worthwhile semantic requirements third design heuristic inferential completeness rephrased considering aspects application explicitly represented enumerations requiring aspects completely supported intensional views appropriate rules 
essentially versions support view instance support view query support view update support 
restricting discussion relation views called universal relation views suppose database schema form ds extensional semantic candidate view external schema es sc set attributes semantic constraints sc supported 
state formal versions heuristic worthwhile semantic property see task 
schema ds provides view instance support es iff exists query ds esg ae dsg 
equality view instance support called faithful 
case additionally supporting query injective dsg view instance support called unique 
schema ds provides view query support es iff query es exists query ds instances es exists instance ds 
weak assumptions query language fundamental equivalence br theorem 
ds provides view instance support es iff ds provides view query support es 
ds provides view query support es query corresponding identity query es supports instances es 
hand ds provides view instance support es query composed queries es 
compositions yield query translation queries view queries full schema 
support updates views essentially need view instance support unique 
known view update problem bs db fc kel information available resolve ambiguity caused non injectivity 
syntactic characterization view support task worthwhile semantic requirements view support related desirable syntactic properties schema 
main results available concern universal relation views supporting query natural join 
instance theorems ris ris bbg 
theorem 
schema ds formats xn extensional enumerations ignoring local global semantic ds supports universal relation view sc natural join iff xn sc theorem 
schema ds formats xn extensional enumerations functional dependencies fn local semantic constraints faithfully supports universal relation view set functional dependencies natural join xn oe proof theorem straightforward just confirming formal semantics join dependencies appropriately defined 
faithfulness natural join results inclusion oe showing functional dependencies valid component valid join refined results appear example var cm 
general theory schema decomposition 
theory explores algebraic framework class instances database schema partially ordered possesses element inverses supporting queries projections case natural join isotonic preserve elements 
turns framework components schema ds faithfully supporting universal relation view uniquely complement 
treating topics theory deals union supporting query selection inverse called horizontal decomposition dp clarifies role null values schema decomposition 
deciding desirable syntactic properties normal forms view support heuristics treated far lead syntactic properties basically expressed terms implications semantic constraints 
section normal forms formalizing separation aspects heuristic just defined terms section view support formalizing inferential completeness heuristic reduced terms 
task design algorithms decide implications semantic constraints additionally explore relevant implications systematically prominent examples results arm men bis bv bv var mit cfp cv fv var tha bc theorem 
implication problem phi sc decidable important classes semantic constraints 
theorem 
implication problem phi sc undecidable class functional inclusion dependencies 
important semantic constraints expressed implicational order logic formulae 
various proof procedures called chase procedures specialized versions general proof techniques hyper resolution paramodulation 
roughly described hyperresolution applied implicational formula nonequality previously generated premises yields additional statement paramodulation applied implicational formula equality previously generated premises equates terms equality side substituted side 
chase procedures designed apply rules starting premises constraint decided change produced 
procedure terminates constraint implied iff produced statements 
general implication problem semantic constraints fairly understood relational case long constraints full basically implicational formulae existentially quantified variable occurs positively decidability 
embedded constraints undecidability due positively occuring existentially quantified variables 
variables cause generation unlimited number terms executing proof procedures terminate case 
restricted case embedded multivalued dependencies implication problem proved undecidable 
sophisticated proof employs reduction word problem finite semigroups known undecidable implication problem embedded multivalued dependencies 
mentioned null values important theory schema decompositions cm called representative instances fragmented database schemas hon sag 
accordingly meaning semantic constraints presence relations null values corresponding variant implication problem studied lie vos gra am tha ll 
theorem 
class relation schemes set functional dependencies problem third normal form npcomplete 
deep reason negative result situation problem attribute appears key relation scheme npcomplete result turn related fact relation scheme possibly exponentially keys lo jf kat vs 
theorem 
class relation schemes set functional dependencies problem boyce codd normal form decidable polynomial time 
decision procedure equivalence boyce codd normal form iff ae noted boyce codd normal form important decision problems high computational complexity 
particular deciding boyce codd normal form projection scheme conp complete bb 
result intractability theorem contrast fact corresponding decision problems relations schemes decidable polynomial time number attributes tuples relation consideration dlm 
theorem 
class relation schemes set functional dependencies problem unique key normal form decidable polynomial time 
decision procedure equivalence statement unique key normal form iff fa una achieving normal forms view support simultaneously far separation aspects inferential completeness heuristics treated separately seen section heuristics lead related implication problems 
task explore relationship formalizations detail particular formal versions compatible 
far achieve desirable syntactic properties simultaneously task design algorithms obtain 
theorems known examples results compatibility 
theorem 
universal relation scheme es set functional dependencies exists database schema ds relation schemes xn fn extensional enumerations schema ds supports es natural join 
ii scheme ds boyce codd normal form 
theorem 
universal relation scheme es set functional dependencies exists database schema ds relation schemes xn fn extensional enumerations schema ds faithfully supports es natural join 
ii scheme ds third normal form 
proofs related theorems constructive yielding outlines design methods decomposition synthesis respectively cod fag fag ber bb km bk sr bm 
methods discussed general framework section 
normal forms ensure low storage update costs introduced normal forms desirable syntactic properties formalizing separation aspects heuristics 
task justify normal forms terms cost providing formal counterparts informal motivations separation aspects heuristic avoid called update anomalies 
benefits purely decompositional normal forms terms storage costs summarized follows theorem 
relation scheme sc decompositional normal form bcnf nf nf relative class semantic constraints considered sc functional dependencies multivalued dependencies join dependencies iff decomposed database schema ds supports sc natural join instance sc size instance sc size decomposed instance 
size means number occurences constant symbols instances 
folklore theorem closely related theorem vs characterizes normal forms terms data redundancy 
intuitive reasoning proof 
assume sc decompositional normal form 
decomposition result duplicating key components tuples increase size getting compensating size benefit 
hand sc decompositional normal form forbidden substructure cause redundant representation facts size benefit removing redundancy decomposition exceed disadvantage duplicating tuple components necessary support natural join 
decompositional normal forms helpful ensure low update costs bg vos bis cha hc bd 
example theorem takes care functional inclusion dependencies bd 
theorem characterizes database schemas allow maintenance semantic constraints simply checking newly inserted tuple violate key condition 
theorem 
database scheme ds relation schemes rn xn fn functional dependencies local semantic constraints inclusion dependencies global semantic constraints allows ae update object ii instance ds tuple dx fg instance ds iff properties hold iii referencing inclusion dependencies iv unique key normal form 
boyce codd normal form 
proof careful analysis equivalent reformulations fundamental notions separation conditions restrict interaction functional dependencies inclusion dependencies may complex general theorem 
unique unique flavor formalized worthwhile semantic requirement fourth design heuristic unique flavor formalized framework designing called universal relation interface database schema muv var bb bv lev 
interface translate queries expressed terms attributes omitting information relation schemes join paths hypergraph structure schema 
candidate join paths unique flavor heuristic candidates provide essentially query answer 
database schema ds formalized version requirement defined follows fx xn describes hypergraph ds 
jp jp fe ae connected ae defines translation set attributes join paths 
essence fx essence join path set attributes unique flavor motivates unique ae jp essence essence 
course property unique defined purely syntactic terms semantically motivated 
acyclicity unique flavor formalized desirable syntactic property fourth design heuristic unique flavor rephrased considering hypergraph structure database schema defined formats requiring hypergraph degree acyclic fag 
important degrees listed names forbidden substructures fl acyclic ff acyclic nontrivial hypergraph produced reduction applied schema gra 
contribution task turns fl acyclicity syntactically characterizes semantic property section theorem 
ds fl acyclic iff ds unique 
easily construct join paths set attributes different cyclic substructures forbidden fl acyclic database schemas case fa bg contained single relation scheme constitutes trivial covering join path covered essentially different join path containing relation schemes connecting running long way 
converse claim theorem proved tedious subtle examination called intersection hypergraph ds generated hypergraph adding nonempty intersections hyperedges 
contribution task desirable syntactic property acyclicity efficiently decided gra fag ty dm theorem 
problems ds fl acyclic ds ff acyclic decidable polynomial time 
degree acyclicity recursive decision procedure pruning predicate hyperedges 
stage procedure delete hyperedge satisfies predicate 
initial schema acyclic iff procedure succeeds reducing schema 
pruning predicate fl acyclicity paraphrased exists hyperedge set intersections remaining hyperedges nonempty intersections remaining hyperedges identical 
pruning predicate ff acyclicity paraphrased exists remaining hyperedge contains intersections remaining hyperedges 
decision procedures elaborated variants known acyclicity test ordinary graphs test recursively deletes leaf corresponding edge recognizes acyclic graphs trees graphs reduced 
acyclicity ensures low query costs task impact acyclicity desirable syntactic property costs examined 
suggested corresponding worthwhile semantic requirement evaluation view queries join paths efficient 
assertions subtle tedious proofs fag theorem 
ds fl acyclic iff join trees monotone pairwise consistent relations partial results consistent iff projections computed determining covering join path evaluating jp 
theorem 
ds ff acyclic iff exists monotone join tree essentially determined reduction 
design algorithms remove forbidden substructures fig summarizes achievements respect tasks 
task lot design methods achieving desirable syntactic properties proposed 
apparently concrete refinement method necessarily result highly interactive design procedure 
general skeleton procedures division labour insightful administrator automatic algorithm bis bc bc bis outlined shown fig 
formalize heuristics separation task 
syntactic properties forbidden substructure nf bcnf nf nf referential nf unique key nf unique flavour task 
semantic requirements join paths essentially unique task 
syntactic properties forbidden substructure fl acyclic ff acyclic inference task 
semantic requirements faithful view instance support view query support task 
syntactic characterization fds join support xn sc gamma delta oe task 
relationships syntactic properties semantic requirements bcnf join support compatible decomposition nf faithful join support compatible synthesis fl acyclic iff join paths essentially unique optimize design time task 
syntactic properties ensure low costs storage normal forms query fl acyclic ffl join trees monotone ffl projection covering joins ff acyclic existence monotone join trees update referencing key bcnf fig 
short summary achievements respect tasks 
modeling administrator model application document model parametrization administrator identify desirable syntactic properties omega particular interest define appropriate worthwhile semantic requirements gamma related inferential completeness initialization administrator algorithm initialize current database schema ds formalization model ds satisfies semantic requirements gamma achieve properties loop fds gamma check properties algorithm determine set omega forbidden substructures current database schema ds set empty exit investigate forbidden substructure administrator select omega forbidden substructure forb forb appears inherent application mark forb unavoidable adjust omega accordingly elsif forb stems faulty modeling improve model adjust omega gamma necessary elsif forb arises bad formalization agreed model remove forbidden substructure algorithm ds ds forb schema transformation removes forbidden substructure forb current schema ds leaves semantic requirements gamma invariant transformed schema satisfies gamma endif endif endloop fds satisfies gamma omega fig 
outline interactive design procedures 
embraces comments indicating module active entity semantics respectively embraces state conditions invariant post condition main loop 
shortly discuss examples fit skeleton fig indicating omega gamma classical decomposition theorem related statements identifies omega boyce codd higher normal form selects gamma view support initial universal relation scheme natural join 
splits current relation scheme attribute set fragments determined components forbidden join dependency gamma invariant semantics join dependencies functional dependency implies corresponding multivalued dependency 
classical synthesis theorem related statements phases 
phase achieves faithfulness second phase adds view support initial universal relation scheme natural join 
phase omega identified third normal form gamma selected faithfulness syntactically characterized preservation set functional dependencies 
removes kinds redundancy lead omega forbidden substructures functional dependencies 
early version synthesis ber achieves goal computing minimal cover functional dependencies leaving gamma invariant 
version bm achieves goal removing called abnormal attributes relation schemes sophisticated strategy somewhat stronger invariant gamma faithfulness object faithfulness strong preserved 
second phase view support initial universal relation scheme natural join guaranteed ensuring existence relation scheme contains global key 
necessary key component added case previously missing substructure 
view integration formalized bc omega identified absence socalled integration constraints indicate redundant overlap views interpreted forbidden substructures wanted integrated schema gamma selected view support view database schemas 
removes integration constraint appropriately merging relation schemes involved leaving gamma invariant 
examining general skeleton design procedures comment tasks design theory 
parametrization step task task 
check properties step remove forbidden substructure step task 
getting final output schema administrator evaluate quality design results task necessary iteratively process design procedure different parametrization 
skeleton shows impact administrator interaction responsible modeling parametrization selection investigation forbidden substructure 
modeling investigation forbidden substructures principally outside scope automatic algorithms parametrization selection forbidden substructures possibly better supported algorithms known today 
final remarks pioneering codd cod armstrong arm substantial body results database schema design theory published 
summarizes small part highly detailed 
emphasizes tasks design theory producing interactive design tools 
companion bis main topics enhancement design theory outlined current achievements carried unifying framework current achievements embedded full design process extended deal deeply advanced database features incomplete information recursive query languages complex objects object identifiers achievements reconsidered viewpoint distributed computing abandoning classical centralized approach databases 
ralf menzel torsten valuable discussions 
am grateful anonymous reviewer helpful remarks hints 
atzeni ausiello batini 
inclusion equivalence relational database schemata 
theoretical computer science 
ada atzeni de 
relational database theory 
benjamin cummings redwood city ca 
ahv abiteboul hull vianu 
foundations databases 
addisonwesley reading ma 
am atzeni 
functional dependencies constraints null values database relations 
information control 
arm armstrong 
dependency structures data base relationships 
rosenfeld editor proceedings ifip congress pages 
north holland amsterdam 
bb beeri bernstein 
computational problems related design normal form relational schemas 
acm transactions database systems 
bb biskup 
universal relation views pragmatic approach 
proceedings th international conference large data bases pages 
bbg beeri bernstein goodman 
sophisticated database normalization theory 
proceedings th international conference large data bases berlin pages september 
bbg beeri bernstein goodman 
sophisticated database normalization theory 
proceedings th international conference large data bases berlin pages september 
biskup kramer 
flavor assumption fl acyclicity universal relation views 
proceedings fifth acm sigact sigmod symposium principles database systems pages 
bc biskup 
formal view integration method 
proceedings acm sigmod international conference management data washington pages 
bc biskup 
schema design methodology deductive databases 
thalheim editors proceedings symposium mathematical fundamentals database systems number lecture notes computer science pages 
springer 
bc biskup 
relational chase procedures interpreted resolution paramodulation 
fundamenta informaticae xv 
bd biskup 
objects relational database schemes functional inclusion exclusion dependencies 
informatique th applications theoretical informatics applications 
biskup dayal bernstein 
synthesizing independent database schemas 
bernstein editor proceedings acm sigmod international conference management data sigmod boston pages new york ny 
acm 
biskup libkin muchnik 
relational database schemes having unique minimal key 
journal information processing cybernetics eik 
ber bernstein 
synthesizing third normal form relations functional dependencies 
acm transactions database systems december 
beeri fagin maier yannakakis 
desirability acyclic database schemes 
journal acm 
bg bernstein goodman 
boyce codd normal form 
proceedings th international conference large data bases pages 
bis biskup 
inferences multivalued dependencies fixed undetermined universes 
theoretical computer science 
bis biskup 
entwurf von durch 
gi entwurf von methoden und pages 
bis biskup 
boyce codd normal form object normal forms 
information processing letters 
bis biskup 
impacts creating implementing formal languages 
duncan krueger editors proceedings th world congress volume pages 
elsevier northholland amsterdam 
bis biskup 
database schema design theory achievements challenges 
proceedings th international conference information systems management data number lecture notes computer science pages bombay 
springer berlin bis biskup 
grundlagen von 
vieweg 
bk beeri kifer 
integrated approach logical design relational database schemes 
acm transactions database systems 
bm biskup meyer 
design relational database schemes deleting attributes canonical decomposition 
journal computer system sciences 
br biskup 
equivalence problem relational database schemes 
proceedings st symposium mathematical fundamentals database systems number lecture notes computer science pages 
springer verlag berlin 
bs bancilhon 
update semantics relational views 
acm transactions database systems 
bv beeri vardi 
formal systems tuple equality generating dependencies 
siam journal computing 
bv beeri vardi 
proof procedure data dependencies 
journal acm october 
bv vossen 
update retrieval relational database universal schema interface 
acm transactions database systems 
cfp casanova fagin papadimitriou 
inclusion dependencies interaction functional dependencies 
journal computer system sciences 
cha chan 
design theory solving anomalies problem 
siam journal computing june 
che 
chen 
entity relationship model unified view data 
acm transactions database systems march 
cm chan mendelzon 
independent separable database schemes 
siam journal computing 
cod codd 
relational model data large shared data banks 
communications acm june 
cod codd 
normalization database relational model 
editor database systems number courant institute computer science symposia series pages 
prentice hall englewood cliffs nj 
cv chandra vardi 
implication problem functional inclusion dependencies undecidable 
siam journal computing 
db dayal bernstein 
correct translation update operations relational views 
acm transactions database systems 
del delobel 
normalization hierarchical dependencies relational data model 
acm transactions database systems 
df date fagin 
simple conditions guaranteeing higher normal forms relational databases 
acm transactions database systems 
dkm thalheim 
average length key functional dependencies random databases 
gottlob vardi editors database theory icdt pages 
springer verlag berlin 
dlm libkin muchnik 
functional dependencies relational databases lattice point view 
discrete applied mathematics 
dm 
recognition algorithms design methodologies acyclic database 
kanellakis preparata editors advances computing research volume pages 
jai press greenwich ct 
dp debra paredaens 
horizontal decompositions handling exceptions functional dependencies 
gallaire minker nicolas editors advances database theory volume 
plenum new york london 
fag fagin 
multivalued dependencies new normal form relational databases 
acm transactions database systems september 
fag fagin 
normal form relational databases domains keys 
acm transactions database systems 
fag fagin 
degrees acyclicity hypergraphs relational database schemes 
journal acm july 
fc casanova 
updating relational views 
kim reiner batory editors query processing database systems 
springer verlag berlin 
fv fagin vardi 
theory data dependencies overview 
proceedings th international colloquium automata languages programming number lecture notes computer science pages 
springer verlag berlin 
horty lobo minker 
view updates stratified disjunctive databases 
journal automated reasoning 
graham mendelzon vardi 
notions dependency satisfaction 
journal acm 
gra graham 
universal relation 
systems research group report university toronto 
gra grahne 
dependency satisfaction databases incomplete information 
dayal editor proceedings th international conference large data bases pages singapore 
hc hern andez chan 
constant time maintainable bcnf database schemes 
acm transactions database systems december 

unique complements decompositions database schemata 
journal computer system sciences 
herrmann 
undecidability implications embedded multivalued dependencies 
information computation 
hon honeyman 
testing satisfaction functional dependencies 
journal acm 
hull 
relative information capacity simple relational database schemata 
siam journal computing 
jf jou fischer 
complexity recognizing nf relation schemes 
information processing letters 
kat 
combinatorial algebraic results database relations 
database theory icdt number lectures notes computer science pages 
springer verlag berlin 
kanellakis cosmadakis vardi 
unary inclusion dependencies polynomial time inference problems 
proceedings th symposium theory computing boston pages 
kel keller 
role semantics translating view updates 
ieee computer january 
ken kent 
simple guide normal forms relational databases 
communications acm 
korth kuper feigenbaum ullman 
database system universal relation assumption 
acm transactions database systems 
km 
covering boyce codd normal forms 
information processing letters 
lev levene 
nested universal relation database model 
lecture notes computer science 
springer berlin 
lie lien 
multivalued dependencies nulls relational databases 
proceedings th international conference large data bases pages 
ll levene 
nested universal relation model 
journal computer system sciences 
lo lucchesi osborn 
candidate keys relations 
journal computer system sciences 

ling tompa kameda 
improved third normal form relational databases 
acm transactions database systems 
mai maier 
theory relational databases 
computer science press rockville md 
men mendelzon 
axiomatizing multivalued dependencies relational databases 
journal acm 
mit mitchell 
implication problem functional inclusion dependencies 
information control 
mannila 

relationship minimum optimum covers set functional dependencies 
acta informatica 
mannila 

inclusion dependencies database design 
proceedings second international conference data engineering pages washington dc 
ieee computer society press 
mannila 

design relational databases 
addison wesley wokingham england 
muv maier ullman vardi 
foundations universal relation model 
acm transactions database systems june 
osborn 
normal forms relational data bases 
phd thesis department computer science university waterloo 
paredaens debra gyssens van gucht 
structure relational database model 
number eatcs monographs theoretical computer science 
springer verlag berlin 
ris rissanen 
independent components relations 
acm transactions database systems 
ris rissanen 
equivalence database schemes 
proceedings st acm sigact sigmod symposium principles database systems pages 
sag sagiv 
characterization globally consistent databases correct access paths 
acm transactions database systems 
sr 
designing gamma acyclic database schemes decomposition augmentation techniques 
proc 
st symposium mathematical fundamentals database systems number lecture notes computer science pages 
springer verlag berlin 
tha thalheim 
dependencies relational databases 
teubner stuttgart leipzig 
jones 
database schemes 
international journal computer mathematics 
ty tarjan yannakakis 
simple linear time algorithms test graphs test acyclicity hypergraphs selectivity reduce acyclic hypergraphs 
siam journal computing 
ull ullman 
principles database knowledge base systems volume 
computer science press rockville md 
ull ullman 
principles database knowledge base systems volume ii new technologies 
computer science press rockville md 
var vardi 
decomposition relational databases 
proc 
rd symposium foundations computer science pages 
var vardi 
implication finite implication problem typed template dependencies 
journal computer system sciences 
var vardi 
fundamentals dependency theory 
borger editor trends theoretical computer science pages 
computer science press rockville 
var vardi 
universal relation data model logical independence 
ieee software 
vas vassiliou 
null values database management denotational semantics approach 
proc 
acm sigmod symp 
management data pages 
vos vossen 
new characterization fd implication application update anomalies 
information processing letters 
vos vossen 
data models database languages database management systems 
addison wesley wokingham england 
vs vincent srinivasan 
note relation schemes nf bcnf 
information processing letters 
vs vincent srinivasan 
redundancy justification fourth normal form relational databases 
international journal foundations computer science 
yu ozsoyoglu 
algorithm tree query membership distributed query 
proceedings rd ieee compsac chicago pages 

yuan ozsoyoglu 
design desirable relational database schemes 
journal computer system sciences 

yuan ozsoyoglu 
unifying functional multivalued dependencies relational database design 
information science 
zan zaniolo 
analysis design relational schemata database systems 
phd thesis university california los angeles computer science department 
technical report ucla eng july 
article processed macro package llncs style 
