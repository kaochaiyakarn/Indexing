imps interactive mathematical proof system william farmer joshua guttman javier thayer mitre february imps interactive mathematical proof system intended general purpose tool formulating applying mathematics familiar fashion 
logic imps version simple type theory partial functions subtypes 
mathematical speci cation inference performed relative axiomatic theories related inclusion theory interpretation 
imps provides relatively large primitive inference steps facilitate human control deductive process human comprehension resulting proofs 
initial theory library containing repeatable proofs covers signi cant portions logic algebra analysis provides support modeling applications computer science 
key words interactive theorem proving automated analysis computing theorems theory interpretation higher order logic partial functions supported mitre sponsored research program 
published journal automated reasoning 
primary goal imps interactive mathematical proof system provide mechanized support traditional techniques mathematical reasoning 
system consists data base mathematics represented collection interconnected axiomatic theories collection tools exploring applying extending mathematics data base 
imps distinguished logic methodology formalizing mathematics style proof 
logic 
imps logic intended allow user formulate mathematical concepts arguments natural direct manner 
simple type theory strong support specifying reasoning functions 
classical logic functions may partial terms may formulas standard truth value 
section describes imps logic 
methodology 
mathematics formalized imps network axiomatic theories 
theories network linked theory interpretations serve conduits pass results theory 
way formalizing mathematics little theories version axiomatic method advantages mechanized mathematics 
particular fosters reuse theories constituents 
section discusses little theories approach imps 
proofs 
contrast formal proofs described logic textbooks imps proofs blend computation high level inference 
consequently resemble intelligible informal proofs informal proofs details imps proof machine checked 
imps emphasizes interactive proof development 
essentially structural di erence completed proofs partial proof attempts 
development proofs imps subject section 
remaining sections discuss imps user interface section imps mathematical analysis section imps mathematics data base section 
brief section 
logic logic imps called lutins logic unde ned terms inference natural style 
lutins conceptually simple implementation higher order predicate logic closely conforms mathematical practice 
partial functions dealt directly consequently terms may 
logic bivalent formulas true false 
lutins derived formal system pf turn derived formal system pf 
pf version church simple theory types functions may partial pf multivariate simple type theory partial functions subtypes de nite description operators 
shown pf pf respectively complete respect henkin style general models semantics 
lutins essentially pf plus number convenient expression constructors discussed 
formal semantics lutins straightforwardly derived standard models semantics pf 
see detailed description syntax semantics lutins 
higher order functions types higher order logic type theory developed early part century serve foundation mathematics lost popularity foundation mathematics rise set theory rstorder logic 
higher order logic emphasizes role functions contrast set theory emphasizes role sets 
type theory functions logic mean ect function 
particular vocabulary set nonlogical constants logic yields triple consisting formal language class models language satisfaction relation models formulas 
function normally determined syntax semantics set logical constants logic 
satisfaction relation determines consequence relation sets formulas individual formulas 
formula consequence set formulas holds holds speak theory mean essence language set axioms 
formula theorem theory consequence axioms 
pronounced word french 
may quanti ed may take functions arguments 
order avoid circularity functions organized type hierarchy 
type theory uniform syntax familiar notions highly expressive 
notation allows functions speci ed succinctly 
type theory contains second order logic things expressed directly expressed rstorder logic 
example induction principle natural numbers expressed completely naturally single second order formula 
see discussion expressive power second order logic relative rst order logic 
type hierarchy lutins consists base types function types 
language lutins 
base types type propositions prop types individuals 
function types inductively de ned base types base function types function type 
may strictly greater type structure sorted multivariate respectively 
higher order logic sort type hierarchy called simple type theory automatic theorem proving system tps developed cmu proof development system hol developed university cambridge pvs veri cation systems developed sri international simple type theories 
systems function types contain total functions lutins types may contain partial functions 
types kind ind say type kind ind base type individuals kind ind say kind prop 
function type known kind ind prefer write form emphasizes contains partial functions total functions 
formal expression lutins unique type 
type expression serves semantic syntactic role expression denotes object denotation type expression de ned syntactic formedness expression determined basis refer types names ind ind course may convenient names 
types components 
expression said kind ind respectively prop type kind ind respectively prop 
expressions kind ind refer mathematical objects may unde ned 
expressions kind prop primarily making assertions mathematical objects de ned 
partial functions primary distinguishing characteristics lutins direct approach specifying reasoning partial functions functions necessarily de ned arguments 
partial functions ubiquitous mathematics computer science 
term constructed simpler expressions application expression denoting partial function expression denoting argument outside domain term natural denotation 
term violate existence assumption classical logic says terms denotation 
direct handling partial functions lie outside classical logic 
semantics lutins principles variables constants expressions denotation 
expressions type prop denote standard truth value 
expressions kind ind may denote partial functions 
application kind ind unde ned function arguments unde ned 
application type prop false arguments unde ned 
consequence principles expressions kind prop denoting 
chosen approach dealing partial functions causes minimal disruption patterns reasoning familiar graph function partial total represented relation problem terms theory easily avoided cost unwieldy verbose expressions packed existential quanti ers 
pragmatic concerns important classical logic perfectly adequate dealing partial functions 
classical logic standard mathematical practice 
detailed discussion various ways handling partial functions predicate logic see 
constructors expressions language lutins constructed variables constants applying constructors 
constructors serve logical constants available language 
lutins approximately constructors 
pf pf constructors application abstraction 
logically basic constructors apply operator lambda iota equals principle expression lutins built 
constructors serve provide economy expression 
full set constructors predicate logic constants true false propositional connectives equality universal existential quanti ers 
lutins de nite description operator operator de nedness constructors defined denoted post symbol defined expression sort 
constructors implies correspond genuine functions constructors 
example constructor nonstrict second third arguments expression de ned theory arithmetic unde ned 
constructors bind variables forall forsome basic variable binding constructor 
constructor de nite description operator lutins constructor easily imitated logics 
constructor create term form predicate denotes unique element described precisely denotes unique satis es unde ned 
addition quite natural kind de nite description operator constructors denoted traditional symbology 
example lambda iota denoted respectively variable binding symbols equals denoted usual symbol apply operator denoted implicitly standard notation function application 
meaning formula denote value false assertion 
useful specifying partial functions 
example ordinary division unde ned second argument de ned times function expression form logics terms denotation completely satisfactory way formalize de nite description operator see russell attempt 
de nite description term denotation unique element satisfying imps implementation allows create macro abbreviations called quasi constructors de ned terms ordinary constructors 
example quasi constructor quasi equals de ned biconditional quasi constructor di erent modes device constructing expressions common form ordinary constructor 
rst mode needed proving basic theorems quasi constructors second mode ectively gives user logic richer set constructors 
quasi constructors especially useful formulating generic theories theory nite sequences special purpose logics imps 
constructors quasi constructors polymorphic sense applied expressions di erent types 
instance constructor take expressions arguments long type rst expression prop second third expressions type 
sorts superimposed type hierarchy lutins system subtypes 
call types subtypes jointly sorts 
sort hierarchy consists atomic sorts compound sorts 
language lutins 
contains set atomic sorts includes base types compound sorts inductively de ned atomic sorts way function types de ned base types atomic sort assigned enclosing sort 
re exive transitive binary relation sorts atomic sort 
follows de nition lutins language enclosing sort function satis es properties enclosing sort base type 
enclosing sort atomic sort kind prop atomic sort prop 
noetherian ascending sequence sorts 
eventually stationary 
properties imply partial order 
sorts unique type called type sorts type upper bound 
sort denotes nonempty subset denotation type 
sorts may overlap convenient formalizing mathematics 
overlapping sorts dubbed inclusion polymorphism 
partial function set set partial function superset superset compound sorts kind ind elegant semantics denotation type kind ind set partial total functions type unde ned arguments lies outside denotation sorts serve main purposes 
help specify value expression 
expression assigned sort called syntactic sort expression basis syntax 
expression de ned denotes object denotation syntactic sort 
second sorts restrict application binding constructors 
example sort type formula form says sort holds equivalent formula sorts directly determining formedness expressions 
expressions sorts respectively application formed provided type 
simple illustration ectiveness subtyping mechanism consider language basis theory real numbers complete ordered field stipulate enclosed enclosed enclosed enclosed base type ind denotes set partial functions natural numbers real numbers 
set functions subset denotation ind ind function constant speci ed sort automatically applicable expressions sort similarly function constant declared sort expression sort automatically wellformed de ned denotes natural number 
subtyping mechanism kind quite awkward logic having total functions 
lutins partially ordered set sorts ordered sorted logic 
ordered sorted type theory weaker order sorted logics directly embedded lutins 
summary lutins sorted multivariate higher order predicate logic partial functions subtypes 
strong support specifying rea functions notation partial functions true de nite description operator full quanti cation functions 
type hierarchy sort mechanism convenient natural developing di erent kinds mathematics 
lutins contains polymorphism sense variables types polymorphism achieved constructors quasi constructors sorts theory interpretations see section 
importantly intuition lutins closely corresponds intuition everyday mathematics 
logical principles employed lutins derived classical predicate logic standard mathematical practice 
puts contrast higher order logics martin constructive type theory coquand huet calculus constructions logic nuprl proof development system 
logics constructive higher order employ rich type constructors incorporate propositions types isomorphism see 
motivated part desire model computational reasoning signi cant departure traditional classical mathematical practice 
allow dependent types quanti cation type variables create complicated type systems 
martin style systems provide simpler speci cally predicative methods de ning mathematical objects domains respect complicated classical simple type theories 
restriction predicative de nitions may may advantage point view developing classical analysis instance certainly impediment 
little theories approach imps supports little theories version axiomatic method big theory version reasoning performed single powerful highly expressive axiomatic theory set theory 
little theories version number theories course developing portion mathematics 
di erent theorems proved di erent theories depending amount kind mathematics required 
theories logically linked translations called theory interpretations serve conduits pass results theory 
argue way organizing mathematics network linked theories advantageous managing complex mathematics means abstraction reuse 
theories mathematically theory imps consists language set axioms 
implementation level theories contain additional structure encodes axiomatic information procedural tabular form 
facilitates various kinds low level reasoning theories encapsulated imps expression simpli er see section 
theory constructed possibly empty set subtheories language set axioms 
theories related ways theory subtheory theory interpreted theory interpretation 
theory may enriched de nition new atomic sorts constants installation theorems 
examples theories discussed section 
de nitions imps supports kinds de nitions atomic sort de nitions constant de nitions recursive function de nitions recursive predicate de nitions 
arbitrary theory 
atomic sort de nitions de ne new atomic sorts nonempty unary predicates 
atomic sort de nition pair symbol intended name new atomic sort nonempty unary predicate intended specify extension new sort 
installed formula known theorem example pair de nes atomic sort denotes natural numbers 
sort expression gives immediate information value expression advantageous de ne new atomic sorts directly unary predicates 
constant de nitions de ne new constants de ned expressions 
constant de nition pair symbol intended name new constant expression intended specify value new constant 
installed formula veri ed theorem example pair oor de nes oor function reals constructor 
recursive function de nitions de ne functions mutual recursion 
essentially implementation approach recursive de nitions moschovakis 
recursive de nition pair list distinct symbols intended names new constants list functionals functions map functions functions kind ind intended specify system values new constants 
installed functionals veri ed monotone respect subfunction order names denote simultaneous xed point functionals example pair factorial recursive de nition factorial function standard theory real numbers 
approach recursive de nitions natural imps expressions kind ind allowed denote partial functions 
notice requirement functions de ned recursive de nition total 
logic functions total list functionals legitimate recursive de nition solution composed entirely total functions 
dicult condition machine check especially 
course imps need recursive de nition satisfy condition recursive de nition legitimate long de ning functionals monotone 
imps automatic syntactic check sucient monotonicity succeeds common recursive function de nitions 
recursive predicate de nitions de ne predicates mutual recursion 
implemented essentially way am am tuples ha am domain recursive function de nitions order predicates 
approach classic theory positive inductive de nitions see 
example consider pair odd prop truth 
prop falsehood 
de nes predicates odd natural numbers mutual recursion 
recursive function de nitions automatic syntactic check sucient monotonicity succeeds recursive predicate de nitions 
theory interpretations chief virtues axiomatic method theorems theory transported specialization theory 
theory interpretation syntactic device translating language source theory language target theory 
de nition property image theorem source theory theorem target theory 
follows formula proved source theory translates theorem target theory 
method variety ways described reuse mathematical results mathematical theories 
theory interpretations constructed imps giving interpretation sorts constants language source theory standard approach usually seen logic textbooks see 
give summary theory interpretations imps detailed description theory interpretations pf 
theories languages respectively 
translation pair mapping sorts sorts mapping constants expressions am am tuples ha am common domain prop prop 
sort kind 
sort type type 
constant sort type type 
expression denotes expression de ned obvious way translation 
translation obligation formula axiom formula asserting particular constant de ned sort formula asserting particular atomic sort subset enclosing sort 
theorem called interpretation theorem see theory interpretation obligations theorem imps system provides support theory interpretations di erent ways 
brief descriptions important ways theory interpretations imps 
see discussion applications theory interpretations mechanical theorem proving 
theorem reuse mathematicians want able formulate result general axiomatic framework taste ease comprehension allow 
major advantage approach result proved theory holds contexts structure theory 
imps theory interpretations foremost translations available imps general describe allowed map sorts unary predicates 
occurs expressions variable binders relativized 
example maps unary predicate sort 
implication conjunction 

binomial theorem fields mechanism realizing advantage theorems proved theories transported theory interpretation appropriate concrete structures 
instance binomial theorem may proved theory elds see 
real numbers form eld de ne theory interpretation theory elds theory reals 
consequence install usual binomial theorem real numbers 
automatic application theorems theorems automatically applied imps ways rewrite rules see section see section 
theorems applied inside outside home theories 
theorem applied theory outside home theory ect transporting theorem applying new theorem directly mechanism kind polymorphic matching called translation matching theory interpretation transport theorem selected constructed automatically imps 
see sections details 
polymorphic operators noted section constructors quasi constructors polymorphic sense applied expressions di erent types 
sort polymorphism useful results constructors quasi constructors formulation underlying sort eld elements 
printed exactly formatted presentation facility imps 
various switches available instance cause connectives printed line usual logical symbols written words subexpressions format 
proofs regardless actual types involved 
constructors generic results coded form rules described section 
quasi constructors constructors introduced imps users imperative way prove generic results quasi constructors 
done proving theorems quasi constructors theory generic types transporting results needed theories quasi constructor 
example consider quasi constructor composition de ned follows expressions type respectively basic properties associativity proved generic theory having base types constants axioms atomic sorts 
see section discussion quasi constructors polymorphic operators 
symmetry duality proofs theory interpretations formalize certain kinds arguments involving symmetry duality 
example suppose proved theorem theory noticed conjecture follows theorem symmetry 
notion symmetry frequently precise creating theory interpretation theory translates theorem conjecture 
illustration theory groups binary constant denoting group multiplication 
translation takes holds xed maps left cancellation law right cancellation law translation fact theory interpretation need prove left cancellation law show cancellation laws theorems parametric theories argued burstall goguen exible notion parametric theory obtained ordinary theories theory interpretations 
key idea primitives subtheory theory collection parameters instantiated group theory interpretation 
example consider generic theory graphs contains subtheory nodes edges theory containing graphs concrete representation 
general results graphs transported creating theory interpretation lifting completely mechanical way theory interpretation extension theory interpretations implemented obj imps obj facility theorem proving translation obligations checked hand 
detailed description technique see 
relative consistency theory interpretation theory theory consistent consistent 
theory interpretations provide mechanism showing theory consistent relative 
consequence imps foundational system 
approach introduces theory shows consistent relative chosen foundational theory theory real numbers real arithmetic described section 
theory ensembles ordinarily mathematicians term theory broader sense logicians generally 
sense metric space theory refers formal theory single metric space mathematical point view interesting theory metric spaces mappings 
example notion continuity mappings involves separate metric spaces naturally de ned theory union copies theory metric space 
family theories organized way implemented imps theory ensemble consists base theory copies base theory called theory replicas unions copies base theory called theory multiples 
various theories theory ensemble connected theory interpretations rename constants 
theory interpretations automatically created base theory theory replica theory interpretations theory multiples created needed user 
theory interpretations allow user de nition prove theorem just place transport de nition theorem members theory ensemble needed 
implication conjunction continuous continuous continuous implication conjunction continuous continuous continuous composition preserves continuity printed overloading illustration consider theory ensemble imps theory metric space 
points distance function metric space denoted atomic sort constant dist sort 
copy set points distance function denoted dist union 
usually 
theorem says composition continuous functions continuous function proved constant continuous de ned user 
imps introduces constants continuous continuous transporting de nition continuous obvious theory interpretations 
normally user mechanism imps overloading constants continuous constants written user continuous theorem printed second form 
composition theorem proved transported theory replicas multiples theory ensemble 
example obtain composition theorem continuous functions single metric space theorem transported theory interpretation maps dist dist dist dist theory ensemble mechanism supports transportation de nitions theorems theory multiple instances 
example user transport de nition continuous real arithmetic doing little specifying map dist dist map jx yj 
theorem proving accordance emphasis mathematically natural intuitively understandable proofs distinguish levels reasoning proving theorems imps 
reasoning lower formula level largely done automatically expression simpli cation routine 
reasoning proof structure level done user machine interactively 
imps designed provide automated support giving free machine course machine deduction orchestrated controlled user 
imps produces formal proofs serve basis conveying theorem true 
intended purpose di erent formal proofs described logic text books 
usually text book formal proof sequence tree constructed small number low level rules inference 
formal proofs kind tend composed mass small logical steps 
humans usually nd proofs unintelligible 
contrast steps imps proof large low level inference proof performed expression simpli cation routine 
number larger steps may grouped result single human level command 
inference described high level proofs constructed imps resemble informal proofs understandability informal proof details imps proof checked machine 
deduction graphs proof carried formal theory 
process constructing proof imps builds data structure representing deduction proof process user great freedom decide order wants di erent subgoals try alternative strategies particular subgoal 
proof object called deduction graph surveyed user typeset automatically analyzed software 
items appearing deduction graph formulas sequents sense derived gentzen see discussion advantage organizing deduction way 
sequent consists single formula called assertion context 
context logically nite set assumptions implementation caches various kinds derived information context 
addition implementation associates context particular theory 
write sequent form context assertion 
deduction graph directed graph nodes kinds representing sequents inferences respectively 
arrow points sequent node inference node sequent node represents hypothesis inference 
inference node exactly arrow pointing sequent node sequent node represents inference 
sequent node said grounded known valid true arrow comes grounded inference node inference node grounded arrow coming source arrow grounded sequent node 
particular inference node arrows coming represents inference hypotheses immediately grounded 
deduction graph distinguished sequent node goal represents theorem proved 
deduction graph proof sequent represented grounded sequent node graph 
representation deductions advantages 
number inference nodes may share common sequent node user program may try number alternative strategies proving sequent 
second loops deduction graphs arise naturally indicate sequents may derived possibly combination di erent sets additional premises 
proof resulting deduction graph serves transcript analyzing reasoning proof ideas 
hand cost store objects signi cant current imps data base proofs contain sequent nodes average number 
building deduction graphs deduction graph begun posting goal node sequent node representing sequent proved 
deduction graph enlarged posting additional sequent nodes creating inferences 
building deduction graph usually stops goal node marked grounded 
inference nodes created procedures called primitive inferences 
primitive inferences provide means add inference nodes deduction graph way modify delete existing inference nodes 
primitive inference works roughly way certain information fed primitive inference zero new sequent nodes posted nally inference node constructed links newly posted nodes previously posted nodes 
primitive inferences 
primitive inferences special simpli cation inference basis simplifying expressions see section application inference applying see section 
remaining primitive inferences embody basic laws lutins variant simpli cation application 
example primitive inference direct inference applies analogue rule gentzen sequent calculus reverse 
selected leading constructor assertion input sequent node inference 
system primitive inferences beta reduction universal generalization existential generalization equality substitution contraposition cut backchaining eliminating iota expressions extensionality unfolding de ned constants de nedness assertions raising expressions assuming theorems introducing choice functions modifying context sequent various ways 
primitive inferences available theory simpli cation de unfolding depend axioms theorems theory 
primitive inferences called directly user 
user invokes interactive proof commands procedures call primitive inferences useful patterns 
akin called tactics systems hol lcf nuprl 
commands useful mere primitive inferences reasons 
primitive inferences commands interface procedure collecting information user 
interface procedure protects user primitive nature arguments primitive inference 
instance command unfold single de ned constant collects set natural numbers number represents nth occurrence de ned constant unfolded 
contrast primitive inference de ned constant unfolding requires set paths de ned constant unfolded 
interface procedure calculates path natural number calls primitive inference de ned new information 
precisely interface procedure conversation information exchanged number times user system 
example user applies command unfold single de ned constant sequent node system list constants occur assertion sequent user select system unfold constant occurrence sequent 
occurrence system ask user occurrences unfold 
second commands may combine primitive inferences larger humanly understandable units 
may lift user higher level inference primitive inferences 
illustration consider command unfold single de ned constant 
command calls primitive inference unfold speci ed occurrences de ned constant beta reduction primitive inference called repeatedly beta reductions possible 
desirable ect building beta reduction constant unfolding 
third commands provide user new inferences realize certain pattern primitive inferences 
kind commands informally call strategies usually add new inference nodes deduction graph time 
simplest useful strategies break logical structure assertion applying direct inference primitive inference repeatedly instantiate universal assumptions existential assertions theorems 
extremely important strategy proving theorems induction 
strategy takes arguments speci es induction principle apply induction principle path mean sequence natural numbers navigates topmost node expression regarded tree subexpression 
way formalizing implementing notion occurrence 
implication sum sixth powers implication implication monotonicity summation heuristics employ trying prove basis induction step 
imps allows user build induction principles axioms theorems appropriate form 
example induction principle integers real arithmetic just full second order induction axiom 
induction strategy ective theorems elementary mathematics simple cases strategy produce complete proof formulas printed figures cases part returns control user 
imps strategies basic called logic simpli cation 
strategies correspond statements theorem follows lemmas commonly informal proofs 
complicated shallow inferences lots logical deduction simpli cation 
strategies avor proof search strategies classic automated theorem provers give imps automated interactive theorem proving capability 
soundness intend course user sound inferences imps 
scheme guaranteeing simple imps allows user modify deduction graph posting sequent nodes calling primitive inferences directly indirectly 
posting sequent node ect inferences encoded deduction graph imps sound long primitive inference sound 
primitive inferences carefully implemented high degree assurance sound inferences 
scheme problem soundness commands ultimately ect deduction graph application primitive inferences 
machinery deduction graphs primitive inferences type discipline ml unnecessary assuring complex reasoning go 
theory supported reasoning logical content theory determined language set axioms 
imps object theory variety characteristics sequence de ned constants introduced sequence theorems derived far 
section discuss mechanisms support theory speci reasoning mean reasoning sound relative axiomatic content particular theories 
simpli cation humanly understandable proofs take relatively large steps reader overwhelmed forest detail 
expression simpli er crucial achieving human sized proof steps 
invoked expression relative context serves primary purposes invoke variety theory speci transformations expressions rewrite rules simpli cation polynomials theory suitable algebraic structure ring simpli cations logical structure expression locations deeply nested discharge great majority de nedness sort de nedness assertions needed apply forms inference 
notion quasi equality mentioned section serves correctness requirement simpli er simpli er transforms expression relative assumptions context theory entail say de ned share denotation unde ned 
lutins quasi equality justi es substituting place occurrence free algorithm traverses expression recursively traverses propositional connectives simpli cation respect richer context 
instance simplifying implication may assumed true local context relative simpli ed 
similarly simplifying conjunct ternary conjunction may assumed local context 
hand operator traversed context assumptions bound variable occurs free simpli er rename bound variable discard assumptions 
strategy exploiting local contexts justi ed incorporated 
stage recursive descent theory speci procedure may successfully transform expression applied 
procedures currently include 
algebraic simpli cation polynomials relative range algebraic theories see section 
decision procedure linear inequalities variable elimination method theorem provers instance boyer moore 
rewrite rules current theory certain theories imps nd interpretations see section 
lutins functions may partial terms may unde ned term simpli cation lutins involve considerable amount de nedness checking 
example simplifying expressions naively may cancel unde ned terms reducing possibly unde ned expression certainly de ned 
example previous replacement valid context seen entail de nedness convergence general algebraic reductions kind produce intermediate de nedness formulas simpli er applied recursively 
formulas called convergence requirements 
rewrite rules generate convergence requirements 
suppose theorem form rewrite rule left right 
portion expression simpli ed form rewritten unde ned value type change justi ed instance theorem 
despite apparently stringent restrictions imps simpli er able ectively 
allowing partial functions theories require checking de nedness expressions signi cant lessons learned imps diculty overcome 
transform applicable simpli cation routine determined top constructor quasi constructor expression simpli ed applied 
routines normally invoke simpli er recursively subexpressions di erent contexts 
routines constructors especially de nedness constructors section special routines exploiting information extracted axioms theorems context theory 
simpli cation procedures systematically course building deduction graphs 
instance simpli es truth relative sequent recognized valid inference 
addition power simpli er ensures proof idea may successfully applied di erent formulas di erences syntactic super cial 
emphasis powerful simpli cation procedure allow large inference steps course interactive proof development shared predecessor pvs 
reasoning de nedness simpli cation involves large numbers convergence requirements important automate greatest extent possible process checking expressions de ned de ned value particular sort 
kind reasoning rely heavily axioms theorems axiomatic theory issue 
algorithm simplifying de nedness assertions separated layers recursive calls simpli er involved 
lower level de nedness checking lower level recursive calls simpli er kinds information totality theorems form unconditional sort coercions form unconditional sort coercion theorems syntactic ordering sorts de ned section determines pre order sorts 
particular set unconditional sort coercion formulas language weakest pre order extending formula form 
model denotation included denotation relation pre order partial order di erent syntactic sorts may case denotation model fix collection axioms theorems respect de nedness checking carried 
relation totality theorems imps algorithm checking de nedness 
totality information unconditional sort coercions extract critical pairs subterms sorts simply critical pairs set critical pairs mean set pairs hs subterm holds particular null set set critical pairs true 
naturally fht ig set critical pairs useful sets critical pairs may computed expressions main principles suppose fhs ig set critical pairs variable constant expression syntactically declared sort 
patently true set critical pairs 
suppose application contains set critical pairs set critical pairs conditional term critical pairs may combined provide set principles de nedness checking fragment lutins corresponds order sorted theories higher order logic 
frequently set critical pairs relatively small nonnull 
terms contains may far smaller instance consider term 

range integers function symbols denote usual binary functions reals 
critical pairs de ned rationals hj qi 
case combine results lower level fact reason results lower level de nedness checking passed upper layer uses sort conditional information 
upper level de nedness checking layer conditional information de nedness consulted 
simpli er invoked resulting assertions attempt reduce truth 
conditional theorems level stored domain range handler theory 
contains primary kinds information domain range functions relations sorts theory 
de nedness conditions form value information form theorems characterize range checking de nedness expressions form 
conditional sort coercions form check de nedness term sort look de nedness condition alternatively sort coercion condition syntactic sort declared range 
de nedness condition form new goal 
subterm form value condition add forming expanded context call simpli er 
sort coercion call simpli er assertion 
part establishing imps ensure course doing de nedness condition may 
recursive calls greater depth certain vain prevented implementation 
assertions imps expressed partial functions subtypes expressed ordinary simple type theory 
machinery subtypes de nedness assertions helps guide imps automated support 
provides syntactic cues reasoning embodied algorithms useful 
transforms theory contains table information simpli er 
table organized hash table procedures called transforms transform expression sound manner 
look table done constructor leftmost function constant keys 
rewrite rules implemented way algebraic simpli cation procedures impractical represent rewrite rules 
imps transforms generated uniform way independently speci constants play role algebraic operations 
means simpli er crafted provide particular forms simpli cation constants certain algebraic properties 
instance algebraic simpli cation arbitrary eld real arithmetic modular arithmetic derived entity called algebraic processor 
algebraic processor applied establishing correspondence operators processor addition multiplication operators speci constants theory 
imps theory elds eld elements form type algebraic processor con gured stipulating multiplication operator function constant addition operator function constant zero individual constant 
certain operators need instance modular arithmetic division operator general 
depending correspondence operators constants algebraic processor generates set formulas theorems theory order manipulations correct 
imps name portuguese clever trick denote user de nable extensions simpli er direct control user 
formally function takes arguments context expression returns expression 
apply theorem collection theorems sequent deduction graph 
individual theorems applied theorem built automatically theorem installed theory 
compound constructed ultimately theorem special beta reduction simpli cation simple constructors just functions 
include constructs apply number succession repeatedly changes 
compound provide simple mechanism applying lists theorems manner direct user control 
kind theorem straightforward matching expressions called elementary 
explain behavior need auxiliary notions 
expression matches pattern expression substitution applied equivalent context substitution say immediately entails de ned component 
sort simpli cation reduces truth 
kind theorem generate elementary purposes exposition assume theorem universal closure conditional equality form applied context expression pair works follows 
left hand side matched matching succeeds resulting substitution applied formula 
entailed immediately entails de ned returns result applying substitution right hand side stage process fails simply returns 
mechanism described detail 
elementary apply theorem home theory 
kind theorem called transportable 
interesting kind matching call translation matching allows inter theory matching expressions 
translation match essentially fold operation consisting theory interpretation ordinary matching 
expression translation match pattern expression theory interpretation substitution applied translation equivalent translation matching transportable way elementary 
transportable apply theorem outside home theory 
section simple examples elementary transportable chosen hundreds examples contained imps initial theory library 
theorem jxj real arithmetic generates elementary rewrites expression form jsj provided simpli er verify nonnegative real number local context expression 
theorem generates elementary reduces goal form new goal provided simpli er verify de ned reals integers respectively 
theorem fyg indicators generates transportable rewrites expression form fbg regardless sorts transportable rewrite rules transportable rewrite rules translation matching simpli er 
unconditional equality formula suitable syntactic form theorem may installed simpli er theory simplifying expression translation matching nd 
successful context ensures de ned may replace 
transportable rewrite rules provide ecient simpli cation rewrites generic theories things mappings nite sequences 
instance theorem ind ind ug ug rewrites expressions cons nested append 
role translation matching case simply select sort instance ind user interface imps user interface removable component imps primarily written gnu emacs imps core written sophisticated version scheme 
user interface implemented subordinate process mechanism gnu emacs allows program executing issue commands emacs vice versa 
imps request formulas derivations user specially formatted emacs conversely user frame requests imps interactive machinery emacs 
interface provides additional facilities case emacs running window system instance menu driven mode 
user interface provides major activities interactive theorem proving theory development parsing printing 
actual interface code devoted rst activity 
activities discussed 
interactive theorem proving imps user interface provides facilities directing monitoring recording replaying proofs 
facilities monitor state proof include graphical displays deduction graph tree typesetting proof history typesetting individual subgoals deduction graph 
graphical display deduction graph permits user visually determine set unproven subgoals 
typesetting facilities allow user examine sequent proof entire proof mathematically appealing notation possible raw textual presentation 
various facilities direct proofs 
example particular subgoal interface presents user pruned list applied subgoal 
list obtained syntactic semantic information available interface imps supporting machinery 
situations theorems available user rarely user options 
interface assists user command syntax commands require additional arguments 
example order apply command instantiate universal assumption user specify universal assumption instantiated instantiations variables 
cases interface prompt user necessary arguments rst determine available information 
previous example universal assumption interface ask user formula instantiate 
mechanism producing transcript interactive proof 
resulting transcript segment text edited replayed fully partially way text editing macro replays sequence commands entered keyboard 
especially useful building new proofs di er small ways previously constructed ones 
theory development imps user creates modi es theory theory interpretation theory constituent de nition theorem imps object evaluating expression called de nition form def form short 
approximately def forms provide mechanism extending mathematics imps system 
user interface provides templates user writing def forms 
def forms stored les loaded needed running imps process 
instance def form introducing natural numbers de ned sort real arithmetic def atomic sort nn lambda zz theory real arithmetic witness stipulates natural numbers integers satisfying advises imps consider checking predicate non empty 
def form introduces symmetry translation reversing group multiplication mentioned section reads def translation mul reverse source groups target groups fixed theories real arithmetic constant pairs mul lambda gg mul theory interpretation check simplification stipulates theory groups forms source target translation vocabulary de ned real arithmetic left unchanged 
binary function symbol mul translated lambda expression shown 
imps requested simpli er ascertain theory interpretation obligations translation fact met translation interpretation 
parsing printing interaction imps requires extensive amount reading expressions keyboard les displaying expressions screen writing les 
abstractly expression tree structure determined imps logic 
implementation imps expression data structure corresponds closely tree structure addition large amount cached information available deductive machinery 
imps user expression typically represented text instance ln correspondence expression data structure external representation input output determined user syntax employed 
imps allows multiple user syntaxes example syntax reading expressions usually text may di erent syntax display expressions text text interspersed commands 
exible arrangement means users freely change syntax course interactive proof 
words core machinery completely syntax independent 
imps mathematical analysis large extent development imps guided attempts prove theorems mathematical analysis theorems real numbers theorems objects banach spaces spaces continuous functions metric space 
imps logic little theories methodology possible develop parts graduate level analysis sacri cing clarity naturalness 
partial functions higher order operators subtypes lutins suited logic analysis 
value having natural way dealing partial functions development analysis overestimated 
important operators analysis integral function limit sequence conveniently treated partial higher order functions 
example limit sequence de ned unique real number satisfying familiar predicate holds limit number having logic partial functions possibly terms de ne limit operator lim having specify separately domain 
analysis various types spaces classes functions 
little theories approach especially framework organizing kind mathematics 
example little theories advantage imps proof open mapping theorem certain banach space functions close identity 
examples brie described subsection 
mathematical analysis traditionally served ground testing adequacy formalizations mathematics analysis requires great expressive power constructing proofs 
automated theorem proving areas analysis 
notable exception bledsoe students dealt problems analysis general topology early see bledsoe discussion 
particular group built series powerful provers combining resolution techniques variable elimination reason formulas involving real inequalities 
prover direction developed hines described 
entirely di erent approach automated theorem proving analysis taken clarke zhao 
successfully implemented system reason large class expressions encountered real analysis including trigonometric functions real inequalities limits nite summations derivatives integrals 
clarke zhao system called analytica implemented top commercially available system mathematica 
mathematica provides wide range facilities possessed provers 
include sophisticated algebraic manipulation reduction rules apply analytic identities ability determine closed forms transforms functions cases solutions di erential equations 
analytica combines theorem proving capabilities sophisticated symbolic manipulation capabilities interesting way drawbacks 
firstly mathematica unsound example doing beta reduction soundness analytica issue 
clear analytica relate formal facilities manipulating objects ered mathematica underlying semantics objects 
example de nition integral set axioms characterizing integral manipulations performed mathematica code ultimate arbiter integration means 
clear analytica handle objects banach spaces useful kinds analysis classical analysis 
initial theory library theory library collection theories theory interpretations theory constituents de nitions theorems serves data base mathematics 
theory library composed sections section particular body knowledge stored set les consisting 
section loaded needed running imps process 
course imps imps user builds theory library top initial theory library supplied imps 
imps initial theory library contains large variety basic mathematics 
ers user developed starting point theory library 
rich source examples illustrates diverse ways mathematics formulated imps 
initial theory li includes formalizations real number system objects sets sequences theories mathematical structures groups metric spaces theories support speci applications imps computer science 
section describes major theories contained imps initial theory library 
way point important theorems proven theories 
real numbers theories real numbers contained initial theory library 
theories equivalent sense interpreted interpretations compose identity 
interpretations constructed theory library imps translation machinery 
rst complete ordered field theory real numbers speci ed complete ordered eld rational numbers integers speci ed axiomatically substructures real numbers 
exponentiation integer power de ned constant denoting partial function 
second axiomatization real arithmetic consider working theory real numbers 
axioms real arithmetic include axioms complete ordered field formulas characterizing exponentiation primitive constant formulas theorems proven complete ordered field 
theorems needed installing algebraic processor utilizing de nedness machinery simpli er 
proofs theorems theory complete ordered field require large number intermediate results little independent interest 
equivalent axiomatizations frees working theory reals burden recording uninteresting results 
theory real arithmetic equipped routines simplifying arithmetic expressions rational linear inequalities see section 
routines allow system perform great deal low level reasoning user intervention 
theory contains de ned entities natural numbers de ned sort higher order operators de ned recursively 
real arithmetic useful building block speci theories 
theory real arithmetic subtheory theory developed help large portion basic everyday mathematics 
example theory graphs includes real arithmetic introduce concept weighted graph nodes edges assigned real numbers 
imagine real arithmetic subtheory theories formulated imps 
generic objects advantages working logic lutins rich structure functions generic objects sets sequences represented directly logic certain kinds functions 
instance sets represented imps indicators similar characteristic functions member indicator de ned 
operators indicators functions representing generic objects formalized imps quasi constructors theorems operators proved generic theories contain constants axioms possibly axioms real arithmetic 
consequently reasoning performed generic theories purely logical apparatus lutins possibly real arithmetic 
theorems generic objects easy apply theories operators quasi constructors polymorphic theory interpretations involved usually obligations check 
initial theory library contains theorems operators kinds generic objects sets 
operators basic set operations union intersection complement membership subset sets represented indicators basic theorems proved just command simplify 
unary functions 
operators formalize basic function notions composition domain range inverse function operators supplement built function machinery lutins 
sequences 
sequences sort represented partial functions natural numbers lists identi ed sequences domain nite initial segment natural numbers 
operators include basic list operations nil car cdr cons append 
pairs 
pair elements sort represented function domain equals singleton set fha big 
operators include pair constructor pair selectors 
part initial theory library contains theorems constructor cardinality sets 
cardinality theorems schr oder bernstein theorem theorem says subset nite set nite surprisingly dicult prove complete detail 
analysis structure imps analysis theory library aggressively exploits little theories approach outlined earlier section providing users extensive network theories interpretations 
approach desirable permits users state prove basic facts high degree generality reuse results speci contexts 
analysis library consists theories theory interpretations 
theory interpretations close percent created automatically system theories created translation match machinery 
follows small sample theories available partial order 
theory set transitive re exive anti symmetric relation theory provides framework stating proving general theorems ordering relations including de nitions characterizations supremum mum set 
interesting theory interpretations explicitly constructed section library order reversing interpretation takes constant symbol de ned constant symbol de ned allows results suprema immediately usable results ma 
clear results partial order interpreted theory real arithmetic 
metric space 
theory set real valued function non negative symmetric satis es triangle inequality theory appropriate de ning metric topological properties limits sequences open sets closed sets completeness sequential compactness 
theory library contains statements proofs numerous facts concepts 
metric spaces tuples 
theory pair metric spaces 
natural setting notions mappings spaces continuity uniform continuity lipschitz property 
theory easily prove versions intermediate value theorems assert respectively image connected sequentially compact set connected sequentially compact see details 
transporting machinery developed theory theory metric spaces obtain versions contractive mapping xed point principle banach 
mappings pointed metric space 
theory spaces bounded de ned functions set metric space distinguished point function bounded range contained closed ball centered basic properties spaces completeness conditions formulated theory 
normed spaces 
theory real vector space norm function 
sample theorem theory open mapping theorem certain functions near identity suitable sense discussion proof theorem imps see 
mappings interval normed space 
theory normed space arbitrary interval real numbers 
theory de ning fundamental notions calculus functions variable di erentiation integration 
important theorems proved library mean value theorems di erentiation integration see 
formulation denotes underlying sort vectors denotes arbitrary possibly unbounded interval real numbers 
implication conjunction kf fk 
jb aj mean value theorem integrals algebra initial library contains theories algebraic structures monoids 
monoid set associative binary operation identity element 
theory monoids constant monoid prod de ned recursively iterated product primitive monoid operation 
basic properties constant proven monoids transported theories iterated product operators real arithmetic operators 
groups group actions 
group theory developed theory network consisting theories various interpretations group actions groups groups 
theorem quotient group normal subgroup group proved fundamental counting theorem group theory lagrange theorem easy corollary 
fields 
basic operations elds exponentiation integer power multiplication integer de ned 
theory developed suciently installing algebraic processor simpli cation 
useful identities binomial theorem proved 
computer science theory library computer science currently developed mathematics 
signi cant facilities exist 
state prop state implication accessible conjunction state initial state action accessible induction accessibility deterministic state machines state machine theories reusable parametric theories sense described section characterize number di erent kinds state machine 
state machine theory state space need nite transition function relation depending machine speci ed known deterministic 
typical theorems include induction theorems accessible states shown 
theorem proved may applied full power induction command section 
order specify particular state machine say deterministic user develops axiomatic theory characterizing objects serve states inputs 
instantiates parametric theory deterministic state machines 
supplies interpretation consequence de ned expressions available possibly suitable renaming theorems available interpretation 
safety theorems expressed terms resulting accessibility predicate liveness assertions may expressed directly 
re nement relations state machines may formulated direct way joint theory describing individual machines 
domain theory denotational semantics simple parametric theory continuous functions related notions developed denotational semantics 
developed imps theory representing ocial scheme denotational semantics basis 
facility de ning free recursive datatypes applications computing datatypes constructed recursively number operations previously objects atoms 
datatypes speci ed bnf notation 
instance elt denotes class previously objects nite lists composed elements may speci ed clauses nil cons elt cases instance syntax programming language di erent sorts objects statements expressions variables may de ned mutual recursion starting objects identi ers semicolon assign plus block var ident speci cation normally interpreted denoting free algebra generated regarding atom constant constructor function symbol 
justi es induction principle principle function de nition primitive recursion 
imps provides procedure legitimate speci cation generate new theory speci cation may stipulate known theory characterize objects list elements identi ers examples 
model conservative extension mean model may enlarged form model adding suitable new objects 
particular satis able extends adding new type speci cation declares new categories statements expressions variables example represented subsort clause may represented sort inclusion instance sort included 
represented function serving datatype constructor 
axioms ensure ranges di erent datatype constructors disjoint include values atoms domain datatype constructor characterized exactly sorts arguments 
second order induction principle axiom 
primitive recursion principle supplied theorem proof generated time constructed 
imps interactive proof development system intended support standard mathematical notation concepts techniques 
particular provides exible logical framework specify axiomatic theories prove theorems relate theory inclusion theory interpretation 
theory interpretations extensively imps reusing theories theorems 
imps logic conceptually simple highly expressive version higher order logic allows partially de ned higherorder functions unde ned terms 
simple types hierarchy logic equipped subtyping mechanism 
proofs developed imps aid di erent deduction mechanisms including expression simpli cation automatic theorem application mechanism orchestrating applications inference rules theorems 
naturalness logic high level inference proofs possible develop machine checked proofs imps intuitive readable 
imps initial theory library provides evidence claim imps supports traditional methods mathematics 
theory library contains repeatable proofs theorems including signi cant portions algebra analysis 
sources include traditional presentations parts graduate course algebra parts foundations modern analysis 
standard mathematical development possible imps system accessible ective tool wide range mathematically educated users 
acknowledgments grateful mitre sponsored research program funded development imps 
key ideas imps originally developed dr leonard monk heuristics research project funded mitre sponsored research 
ideas described 
authors grateful suggestions received referee 
andrews 
mathematical logic type theory truth proof 
academic press 
andrews pfenning 
tps theorem proving system system 
stickel editor th international conference automated deduction volume lecture notes computer science pages 
springer verlag 
bledsoe 
automatic proofs analysis 
automated theorem proving years 
american mathematical society 

second order logic 
journal philosophy 
boyer moore 
integrating decision procedures heuristic theorem provers case study linear arithmetic 
technical report cmp institute computing science university texas austin january 
cardelli wegner 
understanding types data abstraction polymorphism 
computing surveys 
church 
formulation simple theory types 
journal symbolic logic 
clarke zhao 
analytica theorem prover mathematica 
kapur editor automated deduction cade volume lecture notes computer science pages 
springer verlag 
constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith 
implementing mathematics nuprl proof development system 
prentice hall englewood cli new jersey 
coquand huet 
calculus constructions 
information computation 
craigen meisels 
overview 
technical report cp ora 
craigen meisels 
system description 
kapur editor automated deduction cade volume lecture notes computer science pages 
springer verlag 
foundations modern analysis 
academic press 
enderton 
mathematical logic 
academic press 
farmer 
data types sorted second order logic 
technical report mitre 
farmer 
partial functions version church simple theory types 
journal symbolic logic 
farmer 
simple type theory partial functions subtypes 
annals pure applied logic 
farmer 
technique safely extending axiomatic theories 
technical report mitre 
farmer guttman thayer 
little theories 
kapur editor automated deduction cade volume lecture notes computer science pages 
springer verlag 
farmer thayer 
computer supported proofs metric space topology 
notices american mathematical society 
feferman 
systems predicative analysis 
journal symbolic logic 
gentzen 
investigations logical deduction 
collected works gerhard gentzen 
north holland 
goguen 
principles parameterized programming 
technical report sri international 
goguen burstall 
introducing institutions 
logic programs volume lecture notes computer science pages 
springer verlag 
gordon milner wadsworth 
edinburgh lcf mechanised logic computation volume lecture notes computer science 
springer verlag 
gordon 
hol proof generating system higher order logic 
birtwistle editors vlsi speci cation veri cation synthesis pages 
kluwer dordrecht netherlands 
grundy 
window inference hol system 
proceedings international workshop hol theorem proving system applications pages 
ieee computer society press 
guttman 
proposed interface logic veri cation environments 
technical report mitre 
henkin 
completeness theory types 
journal symbolic logic 
hines 
central variable strategy str 
kapur editor automated deduction cade volume lecture notes computer science pages 
springer verlag 
howard 
formulae types notion construction 
curry essays combinatory logic lambda calculus formalism pages 
academic press 

uni cation order sorted type theory 
voronkov editor logic programming automated reasoning volume lecture notes computer science pages 
springer verlag 
kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction volume pages 
proceedings symposium compiler construction 
martin 
constructive mathematics computer programming 
cohen los er editors logic methodology philosophy science vi pages amsterdam 
north holland 
monk 
mathematical logic 
springer verlag 
monk 
inference rules local contexts 
journal automated reasoning 
moschovakis 
elementary induction structures 
north holland 
moschovakis 
recursion foundation theory algorithms 
computation proof theory lecture notes mathematics pages 
springer verlag 
owre rushby shankar 
pvs prototype veri cation system 
kapur editor automated deduction cade volume lecture notes computer science pages 
springerverlag 

system summary 
lusk overbeek editors th international conference automated deduction volume lecture notes computer science pages 
springer verlag 
rees adams 
manual 
computer science department yale university fth edition 
rushby von henke owre 
formal speci cation veri cation 
technical report sri csl sri international 
russell 
denoting 
mind new series 
russell 
mathematical logic theory types 
american journal mathematics 
shapiro 
second order languages mathematical practice 
journal symbolic logic 
eld 
mathematical logic 
addison wesley 
stallman 
gnu emacs manual version 
free software foundation sixth edition edition 
thayer 
obligated term replacements 
technical report mtr mitre 
weyl 
das 
leipzig 
whitehead russell 
principia mathematica 
cambridge university press 
paperback version section published 

