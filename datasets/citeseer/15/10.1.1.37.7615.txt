gda ska technical university gda sk incremental construction finite state automata transducers natural language processing jan daciuk eti may ii dissertation states possible construct minimal deterministic nite state automata fast little memory 
new construction algorithms 
implementation discussed 
compared similar algorithm dominique far memory 
thesis states possible construct automata guess canonical forms categories unknown words faster done algorithms 
new algorithm discussed 
overview nite state automata natural language processing nlp 
new type automata introduced 
method spelling correction enhanced handle polish words 
iii iv contents motivation 
related 
overview dissertation 

basic denitions finite state automata 
finite state transducers 
data applications spelling restoration diacritics 
morphological lexicon 
transducers 
automata acceptors 
morphological analysis unknown words 
perfect hashing 
construction algorithms taxonomy 
incremental construction 
sorted data 
data arbitrary order 
algorithm dominique 
representation 
discussion 
vi contents construction guessing automata motivation 
method description 
lexicon reduction 
default annotations 
generalization 
experimental results 
related 
concluding remarks 
usage spelling correction 
restoration diacritics 
morphology 
transducers 
automata acceptors 
unknown words 
perfect hashing 
summary fsa package 






package 




list figures nlp layers 
sample nite state automaton 
deterministic version sample automaton 
useful version sample deterministic automaton 
classical minimal deterministic acyclic fsa corresponding fsa nal transitions 
simple transducer adopted rs 
subsequential transducer transformation transducer taken rs 
morphology spa path transducer 
categories kept minimum due lack space part speech transducer input data spa 
format input data spa simple automaton acceptor 
prexes automata enforcing storing lexemes full form 
coded prex data morphological analysis automata acceptors 
coded inx morphological data 
removable prex coding automaton morphological analysis 
input data spa morphological guesser 
input data morphological guesser 
input data morphological guesser 
coded data morphological guesser 
vii viii list figures family trees nite automata constructions taken wat 
solid edges denote solution explicit relationships constructions 
labeled name trie language french regular endings verbs rst group 
unique minimal dafsa language french regular endings verbs rst group 
incremental construction algorithm sorted data 
examples construction process sorted data 
result adding word bae minimized automaton containing abd bad 
automaton inadvertently contains abe 
incremental construction algorithm data arbitrary order examples construction process unsorted data changes propagate root 
examples construction process unsorted data cloning example automaton represented lists 
compression sparse table adopted ty 
spelling correction nite state automata 
spelling correction nite state automata restoration diacritics nite state automata 
morphological analysis transducers 
morphological analysis automata acceptors 
morphological analysis unknown words 
guessing categories words 
prexes lexemes 
sample deterministic nite state automaton implementing perfect hashing 
list tables neighborhood matrix example automaton example automaton represented vectors transitions 
example automaton represented vectors transitions state resides inside state 
matrix labeled states symbols storing example automaton 
dafsa ft compared dafsa dictionaries french polish words 
impact rules statistics french dictionary 
impact rules statistics polish dictionary 
impact rules analyses 
average quality guessing polish morphological data 
ix list tables chapter motivation seen part greater framework 
goal create system computer assisted correction written texts 
algorithms thesis general variety applications 
concerned natural language processing nlp applications nite automata useful domains compilers text processors dna sequence matching vlsi design natural language processing nlp applications layered architecture 
real life nlp system layers may missing 
higher level situated diagram greater possibility missing 
happens reasons 
rst lower levels easier implement 
second applications signicant loss performance 
boundaries layers blurred 
perform syntactic analysis knowledge semantics semantic analysis pragmatics statistical methods way levels 
divisions useful correspond dioeerent modules groups modules nlp software 
bottom layer lexicon morphology 
morphology provides information features individual words 
done dictionary lookup computation 
set features depends requirements system components 
features included chapter 
semantics syntax morphology lexicon pragmatics nlp layers frequently morphological nature part speech number gender features considered subcategorization meaning 
algorithms thesis situated lowest layer 
layer implemented variety ways 
method chosen nite state automata transducers 
main features automata justify choice ffl small size ffl great speed 
seen jointly comparison methods 
deterministic acyclic nite state automata dafsa 
acyclic automata suited represent dictionaries accept nite 
motivation languages nite set words corresponds denition dictionary 
extend notion word represent inaeected form annotations construct morphological dictionaries dictionaries contain words canonical forms morphological categories 
deterministic automata faster recognition nondeterministic counterparts recognizing word means single path automaton costly backtracking required 
nite state automata nlp new 
new incremental method construction lowers memory requirements 
type automata original 
nal states nal transitions 
origins date back lecture lauri karttunen kar seminar france 
chapter discusses new original method constructing automata guess lexemes morphological categories correspond unknown inaeected word forms 
automata constructed existing morphological lexicons 
method guessing rule inference lexicon proposed andrei mikheev mik conversion rules nite state transducers proposed emmanuel roche yves schabes rs eric brill learning paradigm 
dissertation theses ffl possible construct minimal deterministic acyclic nite state automata memory previously known algorithms maintaining speed construction process 
ffl possible construct automata guess canonical forms words annotations directly data morphological lexicon 
little linguistic knowledge required process 
state process faster previously known algorithm serving purpose maintains similar quality guessing 
realize objectives ffl proposing new construction algorithms sorted data unsorted data 
computational complexity rst runs faster possible perform chapter 
operations automaton constructed second accepts data coming arbitrary order possibly process 
ffl proposing new way constructing guessing automaton 
method direct 
current implementation construction automaton divide phases construction automaton holding data morphological lexicon application rules prune phases performed synchronously 
related excellent general automata see hu 
taxonomy nite state automata minimization algorithms wat related taxonomy nite state automata construction algorithms wat 
papers discuss nite state automata general include algorithms described 
algorithms deterministic acyclic fsas 
specic faster traditional ones memory 
form separate branch watson taxonomy 
algorithm data arbitrary order developed independently richard watson bruce watson 
alternative way incremental construction automata transducers proposed dominique rev 
doing pseudo minimization construction phase memory algorithms construct minimal automaton steps second proper minimization 
rst stage results automaton minimal needs memory minimal 
classical automata level rules morphology kk 
published unpublished versions circulation years earlier 
fundamental papers eld articles kos kos kimmo koskenniemi kk 
level rules implementation transducers discussed spr probably popular books morphology 
survey transducers nlp moh 
articles subject book rs 
overview dissertation edited emmanuel roche yves schabes 
physically smallest automata produced concepts algorithms developed tomasz kowaltowski 
kls 
introduce notion binary automata perform eoecient optimization bit level see section 
morphological analysis unknown words discussed eric brill bri bri andrei mikheev mik mentioned emmanuel roche yves schabes rs 
eric brill tries discover rules governing assignment morphological categories words 
assignment prexes endings context 
need annotated corpus learn rules 
various rules generated templates applied corpus turns best gives categories closest corpus chosen applied corpus process continues new rules improve results 
emmanuel roche yves schabes rs show rules transformed subsequential transducer results signicant improvement processing speed provides compact representation rules 
andrei mikheev mik uses morphological lexicon corpus learn rules brill algorithm 
statistical techniques wms purpose 
spelling correction rich bibliography 
classical works dam pet dls 
papers deal isolated words 
systems context spelling correction described ch cdk cgm ks 
shallow parsing spelling correction advocated 
pioneering nite state methods spelling correction done kemal og 
perfect hashing nite state automata described tutorial roc acl conference 
overview dissertation chapter introduces basic concepts denitions rest 
hu wat wat rs moh 
new type automata discussed 
chapter describes input data formats programs build automata 
format interpreted programs interpreted chapter 
applications automata 
chapter presents algorithms constructing deterministic acyclic nite state automata 
algorithms eoeciency need sort input data 
problem representation automata storing discussed 
chapter describes algorithm family algorithms constructing nite state automaton guessing lexemes categories inaeected forms 
algorithm uses data existing morphological lexicon 
data prepared special way automaton built algorithms prune obtain generalizations smaller size 
automata built variety applications nlp domain 
chapter discusses algorithms automata spelling correction restoration morphological analysis perfect hashing 
dissertation ends summary 
people contributed various forms thesis 
susan armstrong issco universit de gen bouillon issco universit de gen thierry universit de gen martin kay xerox king issco universit de gen krawczyk technical university gda sk christopher universit de gen sabine lehmann issco universit de gen university technology tomasz university technology dominique issco universit de gen michael rosner university graham russel issco universit de gen university technology aw technical university gda sk zygmunt adam university bruce watson software canada richard watson software canada eric universit de gen 
express gratitude swiss federal scholarship commission providing scholarship covered stay issco geneva faculty electronics telecommunications informatics technical university gda sk supporting research 

chapter 
chapter basic denitions denitions automata transducers 
dioeerences consist mainly choice symbols describing particular items way transitions dened function relation various orderings constituents ffl transitions distinguished denition 
notational dioeerences important theoretical point view choice particular suite denitions notational conventions simplify description problem contributing clarity explanations 
suite denitions watson papers wat wat converted notational convention hu regarded standard automata 
dioeerent equivalent denitions enhances clarity discourse 
denitions nite state transducers taken mainly rs 
introduce new type automata nite state automata nal transitions 
transformation classical automata automata nal transitions provided 
discuss deterministic acyclic automata nal transitions 
automata implementation algorithms dissertation 
finite state automata nite state automaton device nite number states 
certain conditions switch state 
called transition 
automaton starts working switched chapter 
basic definitions initial states 
important subset states automaton nal states 
automaton nal state stops working said accept input 
input sequence symbols 
interpretation symbols depends application usually represent events interpreted ithe event particular data 
symbols come nite set symbols called alphabet 
particular symbol particular state triggers transition state transition labeled symbol 
labels transitions contain particular symbol alphabet 
transition labeled ffl alphabet traversed input symbol 
convenient automata directed graphs 
vertices denote states 
portrayed small circles 
transitions form edges arcs arrows pointing source state state transition originates target state 
labeled symbols 
clear context initial states short arrows point 
nal states represented concentric circles 
example automaton contains states labeled state labeled initial 
states nal 
automaton contains cycles impossible leave state follow transitions return way original state 
starting initial states automaton processes sequence input symbols 
state checks input symbol matches labels transitions go state 
automaton follows target state transition 
ffl labels transition labels followed reading input 
may transition label transition matching label transition labeled ffl 
case decision path choose arbitrary 
transition matches input symbol particular ffl transition automaton stops rejects input 
input accepted input read matched transitions automaton nal state 
set sequences symbols gathered pursuing paths initial states nal ones called language accepted automaton 
example automaton accepts language fffl ac ae bcg 
symbol ffl meaning empty input accepted initial state nal 
accepted transition 
finite state automata sample nite state automaton labeled nal state 
input bc accepted control automaton go follow ffl labeled transition transition labeled nal state 
sequences ad ae af ba rejected nal state 
language automaton nite automaton contains cycles 
automaton ffl labeled transitions called ffl free 
automaton initial state ffl free state transition labeled symbol called deterministic nite state automaton 
automaton transformed deterministic automaton 
state said reachable state ioe sequence transitions leading state state 
automaton said start useful ioe state reachable initial states 
automaton useful ioe start useful state chapter 
basic definitions deterministic version sample automaton nal state reachable state 
automaton useful useful version 
version accepts language 
automaton said acyclic contains cycles possible arrive state twice transitions 
automata gures dissertation acyclic 
formally automaton tuple sigma ffi set states set initial starting states set nal states sigma alphabet ffi partial mapping ffi theta sigma ffl gamma 
denoting transitions 
extend ffi mapping ffi theta sigma gamma 

size automaton jm equal number states jqj 
dene language accepted automaton fx sigma jffi mapping lm gamma 
sigma right language state set strings sigma take state nal state extended transition relation ffi lm fx sigma jffi 
finite state automata useful version sample deterministic automaton consequence myhill nerode theorem hu automata accept language isomorphism minimal number states 
called minimal automaton 
automaton minimal 
property minimality dened follows wat wat wat min jm jm alternative denition minimality sigma ffi wat wat minimal qq qq useful useful property specifying states reached start state dened follows useful sigma ffi particular interest nlp community deterministic acyclic nite state automata dafsa best suited representing dictionaries various sorts 
refer automaton chapter 
basic definitions fsa mean acyclic deterministic nite state automaton dafsa explicitly stated 
denitions rewritten simpler way deterministic nite state automaton tuple sigma ffi set states starting state set nal states sigma alphabet ffi partial mapping ffi theta sigma gamma 
denoting transitions 
extend ffi mapping theta sigma gamma 
hu 
denitions language accepted automaton right language state useful property dafsa simpler fsa fx sigma ffi fg lm fx sigma ffi useful sigma ffi possible alternative denition fsa sigma meaning sigma relation theta sigma theta alternative expression ffi function 
alternative denition may useful descriptions 
algorithms described operate classical dafsa deterministic acyclic nite state automata 
implementation uses dioeerent kind automata nite state automata nal transitions fsa ft dene automaton sigma nite set states sigma alphabet set initial states automaton theta sigma theta set transitions set nal transitions 
say fsa ft accepts word symbol input transition transition traversed recognizing word nal 
dene transformation classical nite state automaton nite state automaton nal transitions fsa sigma nd fsa ft sigma fi new initial state ffl fg 
transitive closure dened recursive relation 
finite state automata ffl ffl aa dene language fsa ft fsa gammaf fx sigma fig fg deterministic acyclic nite state automaton sigma accept empty input written ffl ffl nd deterministic acyclic nite state automaton nal transitions dafsa ft sigma fg 
call transformation moving markers 
preserves number states number transitions 
transformation exists dened minimal automata write minimal deterministic acyclic nite state automata nal transitions smaller classical counterparts see 
denition minimality fsa ft classical fsa denition right language state fsa ft change gammaf fw sigma fg classical dafsa accepting fa ac bcg 

dafsa ft accepting language 
exclamation point marks nal transitions classical minimal deterministic acyclic fsa corresponding fsa nal transitions chapter 
basic definitions note dafsa ft ffl 
dioeerent classical automata ffl 
dioeerence important 
means recognition word moved nal state classical automaton transition reaching state fsa ft resulting removal empty string ffl right language automaton 
sigma dafsa classical sigma dafsa ft obtained transformation moving markers 
write ffflg nd states classical fsa right languages empty string merge states deterministic acyclic nite state automaton nal transitions 
resulting automaton smaller states transitions corresponding classical nite state automaton 
note implementations automata implicit states transitions represented explicitly new kind automata saves space cost 
automata nal transitions seen mealy automata property nal output label 
perceived notational convention new kind automata 
transducers property concatenated output labels 
finite state transducers transducers automata transitions labeled symbols 
symbols represents input output 
transducers translate strings 
automata theory see hu called mealy automata 
transducers seen automata transitions labeled symbols sigma theta sigma sigma sigma alphabets input output respectively 
perception mind denitions automata hold transducers 
alphabets sigma sigma frequently denition rs simply sigma sigma nite alphabet nite set states vertices initial 
finite state transducers state set nal states theta sigma ffl theta sigma theta set transitions edges 
state transition function maps theta sigma ffflg dened fq qj sigma 
emission function ffi maps theta sigma ffflg theta sigma dened ffi fw sigma 
simple transducer adopted rs shows transducer 
translates ab bh ae ce 
transducers translate strings 
transducer said represent mapping sigma sigma transitive closure dened recursive relation rs ffl ffl aa bb mapping ioe writes jt example gure jt ah bh jt ae ce 
input output allowed called rational transduction 
called rational function 
transducers device compute function translate string dioeerent denition deterministic 
denition transducer said deterministic ioe transition function emission function ffi lead sets containing element 
formally sigma jd jffi jd ffl jffi ffl 
traditionally deterministic transducers chapter 
basic definitions called subsequential sequential transducers deterministic transducers states nal 
subsequential transducers function computed deterministically single path transducer 
transducer gure subsequential computes rational function 
transitions leaving rst state input labels determine path follow looking input 
subsequential transducers dened tuples sigma omega ae meaning sigma simple transducers described omega deterministic state transition function maps theta sigma deterministic emission function maps theta sigma sigma function confused kleene star written superscript nal emission function ae maps sigma writes omega ae shows subsequential transducer accepts language transducer 
ce bh subsequential transducer transformation transducer taken rs subsequential transducers faster recognition tasks may take space 
faster follows single path automaton need go back case simple transducers 
may take space needs store strings characters symbols transitions 
chapter data applications chapter discuss problem automata contain languages accept various applications 
construction algorithms perceive data lists words words sequence symbols alphabet 
interpret symbols 
programs automata interpret expect words automata formed particular way 
data formats discussed appropriate algorithms chapters suitable incremental construction automata transducers 
mean construction algorithms mean suitable construction algorithm 
fact family methods wat see section build automata regular expressions 
widely method building lexical transducers kk kar merge transducers representing lexemes level rules intersection composition 
method possible construct transducers directly form morphological descriptions lexicon entries 
algorithms deal lexicalized data automata transducers implementation translating rules 
example level rules compiled transducers kos kos simple automata model phonological phenomena 
disadvantage data format data takes space regular expressions 
produced occupying space 
addition format assume particular tool form chapter 
data applications data 
believe method coding lexemes specifying characters inaeected form appending inaeected form common knowledge researchers eld 
aware methods coding prexes describe 
spelling restoration diacritics various algorithms spelling correction restoration diacritics may require various data 
perform simple dictionary lookup word arrive list similar words 
algorithms need simple list words lexicons 
word language accepted automaton word natural language additional annotations 
advanced algorithms check word context 
done form syntactic analysis full shallow 
syntactic analysis requires morphological data described section 
morphological lexicon specic form data morphological lexicon depends kind automata simple automata acceptors transducers 
morphology levels strings come surface level lexical level 
surface string inaeected form word 
string spa inaeected form word spa 
lexical string corresponding lexeme morphological annotations 
lexeme word form main entry word dictionary 
lexeme corresponding inaeected form spa spa 
annotations describe properties word form word spa note verb past tense third person female singular imperfect 
may need morphology various purposes 
tagging annotating corpus part speech labels need lexemes categories matter 
stemming widely information retrieval retain lexemes suppress categories 

morphological lexicon transducers concept transducers consists translating string 
possible translate surface string lexical string vice versa 
translation stored lexicon generated translation rules 
approach numerous sources kk kos kos rs spr 
describe 
lexicon method see kar moh simple 
paths transducer describe translations strings 
morphology spa path transducer 
categories kept minimum due lack space part speech format data simple possible 
implementation line input data ht separated elds ht means horizontal tabulation character aka 
tab inaeected form lexeme categories 
spa spa aspect mode ind tense past num sg pers gender fem transducer input data spa surface lexical strings may length 
special ller characters pad shorter string 
inside strings 
inserting ller characters places reduce size transducer increasing number identical transitions 
chosen places allow alignment corresponding segments strings 
note representation leads small devices beginnings words consist mainly pairs identical characters endings mappings surface inaeected form lexical 
analysis simple decoding necessary 
chapter 
data applications automata acceptors simple automata acceptors storing morphological lexicon 
single word language accepted automaton represent morphological information inaeected word form 
longer level structure embedded transducer need express structure inside word language accepted automaton 
divide word parts inaeected form annotations separated inaeected form annotation separator 
annotations may contain lexemes morphological categories 
internal structure 
order minimize size automaton order imposed categories appear entry 
categories written order 
categories entries written rst category specic general 
including lexemes full lexicon size 
automata compress beginnings endings strings compressing inner parts strings 
word stem root may specic word 
occurs words lexemes 
beginnings compressed words share letters starts 
endings shared words 
put inaeected form lexeme twice central part stem time dioeerent 
sequence items stem stem unique shared 
solution problem 
inaeected form lexeme share word specic information stem needs occur 
suoecient indicate letters inaeected form deleted added stem obtain lexeme 
code indicate number letters deleted inaeected form 
means deleted letter letters 
code followed corresponding lexeme 
inaeected forms may prexes lexemes 
inaeected form dioeerent corresponding lexeme lexemes stored automata see 
prexes may inaeuence categories 

morphological lexicon spa aspect mode ind tense past num sg pers gender fem format input data spa simple automaton acceptor deg sup gender masc num sg case nom prexes automata enforcing storing lexemes full form order decrease inaeuence prexes size automaton method similar described 
code name prex code may introduced indicate letters inaeected form deleted 
means prexes letter prex letter prex code inserted front code indicating letters delete word 
shows morphological data time prexes coded save space 
rst idj annotation separator means rst idj letters deleted giving 
second idj says letters deleted giving 
ki appended giving lexeme 
deg sup gender masc num sg case nom coded prex data morphological analysis automata acceptors polish morphology containing words expressions automaton coded prexes smaller coded prexes 
french automaton coded prexes bigger original french prexes 
word structure complicated 
german verbs parts 
rst part loosely connected second separated inx put separately sentence 
example ein valid forms chapter 
data applications verb 
order cope problem code special annotation need introduced 
code inserted prex code prex code says prex dioeerent 
code name inx code species inaeected form characters deleted 
convention codes means letters deleted right true prex means letters deleted start second letter inaeected form 
shows entry 
rst annotation separator followed capital letters characters deleted idj characters deleted start third character inaeected form character deleted form inaeected form 
string ki follows capital letters lexeme 
pp num sg gender masc case nom deg pos coded inx morphological data special annotation similar method represent prexes section 
inaeected form lexeme annotation separator introduce removable prex 
shows indicate part ein ein separated form words 
ein abn verb mode ind tense pres num sg pers removable prex coding automaton morphological analysis morphological analysis unknown words languages polish french german part carries information categories word ways obtaining canonical form contained inaeected form 
intended recognize word endings lexicon 
morphological analysis unknown words constructed inverted words letter word rst letter string stored lexicon penultimate second 
word marked special character possible distinguish complete words 
append annotations inverted word 
special character annotation separator separates words annotations 
term refer past annotation separator 
annotations may include lexemes morphological categories 
lexemes included need similar coding scheme shown previous subsection 
annotations inverted 
word spa annotations aspect mode ind tense past num sg pers gender fem may represented shown 
aps aspect mode ind tense past num sg pers gender fem input data spa morphological guesser prexes introduce problems similar automata representing lexicons 
lexemes guessed represented full form automata 
exactly coding scheme described previous subsection solve problem 
assume categories inaeected forms depend suf xes 
true french languages follow rule 
polish adjectives adverbs formed adding prex corresponding comparatives 
german past participles formed adding prex forms 
prexes guessing automata parts distinguish various annotations beginnings words 
transitions code removed transitions precede 
prexes words stored automaton 
solution problem 
augment annotations move prexes inaeected forms 
separate prexes annotations annotation separator 
polish adjective input data shown 
chapter 
data applications dki deg sup gender masc num sg case nom input data morphological guesser means inaeected form adjective comparative degree categories form prex corresponding lexeme formed removing gamma letters appending 
data superlative form adjective 
dki num sg gender masc case nom deg sup input data morphological guesser means inaeected form formed prepending prex giving lexeme formed removing letters adding 
note endings forms dioeerent morphological categories 
moving prexes annotations achieved situation inaeected form prex corresponding lexeme regular words obtain lexeme inaeected form need cut letters inaeected form append just prexes 
unfortunately approach solve problems german past participle 
verbs prexes separated stems 
cases prex inx past participle 
solution case data morphological analysis additional code inx code species inx word 
code inserted front inx 
inx inaeected form contains prex code says zero code 
code 
capital letters rst annotation separator specify deleted inaeected form appended obtain lexeme means characters deleted near inaeected form idj characters deleted third character inaeected form character inaeected form deleted 
removable prex removed form inaeected form put sentence ier sie ein come lexeme 
perfect hashing pp num sg gender masc case nom deg pos coded data morphological guesser 
data guesser take account similar way handling prexes 
question done dictionary guesser 
prexes behave way listed guesses making output clear 
problem solved syntactic level 
perfect hashing hashing maps words set words numbers addresses 
mapping bijection set gamma hashing said 
possible number words language accepted automaton 
numbers associated words depend order stored automaton 
order roughly lexicographical determine words rst compares codes rst letters 
smaller code means corresponding word stored rst 
codes equal comparison repeated words rst letters recursively 
example automaton stores french regular endings verbs rst group page words numbered receives number ais ait ant 
numbers result way words stored needed input data algorithm builds perfect hashing automaton simple list words 
match order words automaton list lexicographically sorted 
information perfect hashing see section page 
mean depends application 
words list entries dictionary holding description meanings words list entries encyclopedia 
rst example list inaeected forms entries provide possibility looking inaeected forms 
limited entire words words natural language process 
words may contain annotations similar described subsection 
put categories annotations dictionary example provide full morphological analysis inaeected forms 
chapter 
data applications chapter construction algorithms taxonomy taxonomy wat additional branch deterministic acyclic automata 
bruce watson prepares new extended taxonomy containing algorithms shown 
gure shows families construction algorithms 
sigma algebras generalization regular expressions 
algorithms constructing nite state automata regular expression date early days computer science 
results obtained variety ways diagram shows 
family methods myhill nerode theorem methods belong derived theorem 
incremental algorithms acyclic automata added separate branch myhill nerode tree 
diagram algorithm data arbitrary order derived algorithm sorted data 
line development algorithms author 
note passage sorted data algorithm necessary arrive version data arbitrary order richard watson bruce watson developed algorithm considering version sorted data 
incremental construction trie deterministic acyclic nite state automaton dafsa transition graph trie initial state root leaves nal 
imagine fsa form trie gure example 
see subtrees isomorphic 
minimal dafsa chapter 
construction algorithms relation thompson left biased top lookahead guarded commands rfa subset constr 
berry sethi rfa subset constr 
right biased derivatives item sets brzozowski item sets aho sethi ullman myhill nerode myhill nerode minimal mc naughton yamada glushkov improved item sets algebras filter filter daciuk acyclic fsa postorder daciuk watson watson daciuk incremental unsorted data family trees nite automata constructions taken wat 
solid edges denote solution explicit relationships constructions 
labeled name isomorphic trees copy kept pointers pairwise isomorphic subtrees replaced pointers unique copy 
traditionally obtain minimal dafsa rst create dafsa language necessarily minimal minimize number known algorithms see wat wat 
usually rst stage done building trie 
algorithms minimize dafsa fairly eoeective memory size original automaton huge decreasing memory requirements reported rev 
way reduce intermediate memory requirements total construction time constructing minimal automaton 
incremental construction trie language french regular endings verbs rst group unique minimal dafsa language french regular endings verbs rst group incrementally word word maintaining invariant minimality soon new data arrives avoiding having trie memory 
central part fsa minimization algorithms classication states wat wat 
states dafsa partitioned classes abstractions representatives states minimal dafsa 
assuming original dictionary useless states useful true see denition minimality state minimal dafsa unique right language 
necessary suoecient condition minimality equality right languages equivalence relation classes wat wat 
denition right languages easily shown equality right languages equivalence relation symmetric transitive 
denote states belonging equivalence class walk minimization trie gure algorithm hu 
initially pairs states nal recognized marked belonging dioeerent classes 
pairs states dioeerent number transitions number dioeerent labels marked dioeerent 
pairs states transitions labeled symbols leading states considered marked dioeerent immediately marked dioeerent 
chapter 
construction algorithms sorted data traverse trie see postorder method see partition performed 
start lexicographically rst leaf 
states rst forward branching state state outgoing transition belong dioeerent classes 
put register states nd easily 
need replace states 
looking branches starting leaves rst need know state belongs class 
newly considered states belong class representative established class 
nal non nal 
number outgoing transitions 
corresponding transitions labels 
corresponding transitions lead states 
states reachable outgoing transitions sole representatives classes 
condition satised postorder method traverse trie 
conditions satised state replaced state register 
representative new class put register 
procedure leads minimal automaton 
note leaves belong class 
pair states equivalent transitions number transitions labels target states target states sole representatives classes right language pair target states 
intuition equivalence states supported alternate denition minimal automata 
leaves right language ffl empty string 
pair states right language language represented fa sigma ffi ffflg fa sigma ffi note simply inductive denition right language state ffi ffi 
states equal number transitions labels lead states right 
incremental construction languages 
nal non nal dioeerence nal non nal states nal ones ffl right language 
want add new words automaton gradually maintaining minimality property 
need know synchronize processes adds new words automaton minimizes 
crucial questions answered 
firstly states subject change new words added 
secondly way add new words automaton minimize number states may need changed addition word 
looking gures clear order reproduce order traversal states data lexicographically sorted 
note order sigma ordered 
farther investigation reveals add words order states need traversed accept word added automaton may change words added 
rest automaton remains unchanged 
happens states changed removing appending new transitions 
call common prex longest prex new word prex word automaton 
new transitions added state belongs common prex new word added automaton 
words lexicographically sorted common prex contain states represent word added automaton word word prex new word 
new word reuse states common prex add new states 
states may removed path represents word added automaton part contain common prex 
new word added word prex new word states part subject removal replaced identical states registered new states 
discovery leads algorithm 
function nds longest prex word added prex word automaton 
function creates branch extending automaton represents word added portion word left common prex cut 
state branch marked nal 
function returns state reached lexicographically transition going argument state 
data lexicographically sorted returns state reached transition added state addition previous word 
state marker indicates registered necessary determine states processed 
parts automaton left treatment replacement reg chapter 
construction algorithms register word word word word ffi ord length length ord function word return ord max ffi ord function state child state child child child register child child state register register child incremental construction algorithm sorted data word added states longer belong path automaton accepts new word 
marker read set returns true outgoing transitions state deletes argument state states reached marked registered 

incremental construction memory requirements algorithm maximum processing 
memory needed minimized automaton construction call stack register states 
memory automaton proportional number states total number transitions 
memory register states proportional number states freed construction complete 
automaton common prex ais rest appended nal state path representing ais replaced equivalent state automaton done ait common prex ant automaton rest appended state path representing ant replaced equivalent state automaton penultimate state path representing ant replaced equivalent state automaton examples construction process sorted data main loop algorithm runs times number words accepted automaton 
function executes jwj chapter 
construction algorithms time jwj maximum word length 
function executes recursively jwj word 
recursive call register search may register insertion 
pessimistic time complexity search log number states minimized automaton 
pessimistic time complexity adding state register log 
hash table represent register average time complexity operations constant 
children state replaced registered executes constant time 
pessimistic time complexity entire algorithm log average time complexity achieved 
shows examples construction process data ais ait ant 
data arbitrary order dioecult impossible sort input data construction automaton example disk space store sort data data comes program physical source 
incremental automaton building algorithm may useful situations unsorted data dioecult merge trie building process minimization process 
extreme solutions ffl minimize may changed 
immediately determine equivalence class new state algorithm 
leads traditional method building trie minimizing ffl minimize possibly changing states equivalence class time word added 
constructing new state automaton rst determine equivalence class pre existing state 
addition need change equivalence classes previously constructed states right languages changed 
leads incremental construction algorithm 
description second case included 
time word added automaton minimized 
lead parts automaton previously minimized 
similar algorithm sorted data new word added common prex searched automaton 
assume path containing prex changed 
states path traversed word preexisting automaton targets incoming transition known 
incremental construction automaton containing words abd bad word bae added automaton abd bad result adding word bae minimized automaton containing abd bad 
automaton inadvertently contains abe 
states appending transition state path accidentally add words desired see 
avoid generation spurious words states common prex rst state incoming transition cloned 
cloning process creating new state outgoing transitions labels destination states state 
compare minimal automaton equivalent trie note state seen root original isomorphic subtrees merged described previous section 
isomorphisms needs modied separated cloning root 
rest word appended 
new subtree modied states removed register re registered replaced equivalent state register 
states common prex state adding rest word algorithm sorted data 
process traversing common prex state adding complete 
previous states prex path may need changed right languages states may changed 
recalculate equivalence relation states path new word 
process new minimal automaton smaller 
resulting algorithm shown 
procedure previous algorithm needs modied slightly 
new words added arbitrary order longer assume child added modied 
children state checked altered chapter 
construction algorithms register word word word word rst state ffi clone ffi ord length length ord length ffi length downto clone ffi ffi length repeat ffi ord register register incremental construction algorithm data arbitrary order child 
child may need treatment execution time order 
previous algorithm passed ffl argument 
version may happen 
eoeect current state marked nal common prex entire word 

incremental construction main loop executes times number words accepted automaton 
inner loops executed jwj times word 
putting state register log may constant regular data hash table 
estimation valid removal register 
time complexity algorithm remains constant changes 
sorted data small part automaton changed time new word added 
data arbitrary order changes frequently percolate way back start state processing word costs 
automaton accepting word added ffi replaced equivalent state state equivalent state state replaced equivalent state final result examples construction process unsorted data changes propagate root chapter 
construction algorithms automaton ais ait ant asses added states cloned examples construction process unsorted data cloning algorithm dominique know algorithm constructs minimal deterministic acyclic nite state automata incrementally 
dominique rev stages rst called second proper minimization 
give account algorithm rev 
notion longest common introduced 
longest common word set longest common word word set 
simplify search longest common written lsc french ile plus long words appended order comparison letters words done right left 
order possible enter words longest common prex longest common prex word set words entered 
transition labeled current letter word state reached transition predecessor moves state transition 
transition exists target state predecessor target state duplicated transition redirected copy 
moves copy 
longest common reached creates new transition labeled current letter new state moves transition 
longest common reached 
state longest common belongs path automaton prex word creates new transition labeled 
representation current letter new state moves transition 
state longest common prex belong state prex word creates transition leads state moves state 
state reached loops 
nal ffl predecessor clones get nal 
ffl predecessor nal 
phase 
followed true minimization phase consists partitioning states classes maximal length strings right languages 
states sorted classes starting class maximal length string right language equal proceeding sorting equivalent states eliminated 
representation size automaton speed depend method representation 
dioeerences drastic 
noted single representation method suitable applications providing best characteristics aspects 
choice seen compromise various requirements 
representations automata directed graphs see ahu 
classical methods neighborhood matrix lists 
neighborhood matrix matrix axis labeled source state numbers transitions labeled target state numbers transitions 
state attributes stored vector 
entries matrix attributes transitions labels 
table shows structure example automaton page 
large automata may millions states may dioeerent transitions states method eoeective 
variant neighborhood matrix uses possible symbols columns target states values matrix 
matrix better previous terms memory requirements processing time 
traditional approach coincidence lists 
fig 
shows example automaton page form coincidence lists 
note transitions stored consecutive memory locations need links transitions 
needed number chapter 
construction algorithms ce table neighborhood matrix example automaton example automaton represented lists transitions state 
transitions stored consecutive entries vector 
move properties number transitions nal status states transitions lead longer need store states explicitly stored implicitly transitions 
see table example 
interestingly moving state properties transitions resulted creation new state 
state exists solely dummy transition provides properties initial state 
states method shown implicit compression possible 
methods explored implementation automata 
representation transition label transitions nal target source state start table example automaton represented vectors transitions construction algorithms dissertation ffl storing smaller state inside bigger transitions smaller state subset transitions bigger ffl storing state shares consecutive transitions states stored consecutive locations state overlaps states transitions represented transitions states 
note rst method eoeciently transitions sorted 
order imposed sorting compression 
best results achieved sorting transitions frequency occurrences labels finding ideal layout transitions state np hard 
table shows example automaton states put state 
assuming transitions state ordered denote ffi ith transition state state method consists nding representation state ffi ffi ffi ffi ffi ffi ffi gamma ffi ffi ffi ffi method applied rst described 
take state represented set outgoing transitions look states 
transitions rst rst transitions state want compress remaining transitions state compressed rst transitions second state search 
formally state look states ffi ffi ffi ffi ffi ffi ffi personal communication martin kay chapter 
construction algorithms transition label transitions nal target source state start table example automaton represented vectors transitions state resides inside state jmin ffi ffi ffi ffi ffi gammai ffi ffi ffi gammai ffi programs states allowed take part match making transitions 
tomasz kowaltowski kls uses form coincidence lists obtain best compression automata 
state traditional nite state automaton treated list states binary automaton 
states call binary states avoid confusion states traditional fsa correspond transitions traditional fsa 
state binary automaton pointers 
rst leads target state transition 
second points transition current state original fsa 
tomasz kowaltowski notes representation states possible merge endings lists merge parts states 
note approach described state merged adjacent states bigger state contains transitions smaller state bigger state may merged bigger state 
kowaltowski approach smaller state may merged bigger states merged 
proper state binary state ffl initial state automaton ffl target transition ffl target pointers chain binary states fsa state failure transitions kowaltowski terminology 
representation proper states visited order proper state visited proper states targets transitions state visited 
proper state visited looks states visited state contains set binary states subset set transitions current state 
set states search state biggest number binary states chosen 
binary states current proper state reordered chosen state 
pointer replaced pointer chosen proper state 
maximize probability current state matched parts states binary states shared chosen proper state ordered frequency occurrence proper states visited contain binary states chosen state 
failure transition frequent binary state proper state points frequent binary state frequent binary state failure transition points chosen state 
automaton represented vector binary states 
judicious coding possible obtain substantial compression 
symbols labels transitions coded dlog sigmaj bits 
number symbols language incremented accommodate special symbol marks word 
tomasz kowaltowski notes states fsa transition target transition previous state states numbered sink state start state 
extra bit distinguishes situation target previous binary state 
case target state number coded bits gamma 
nal states states need bare marker nal word marked special symbol 
means nal state transition labeled symbol 
case need code target state transitions labeled symbol 
case failure transition target states previous binary state states numbered 
third possibility arbitrary state coded shown possible bits distinguish situations 
tomasz kowaltowski reports compression rates size compressed folded automaton divided size original automaton 
dominique rev emmanuel roche yves schabes rs argue dioeerent representation method 
automaton stored matrix row state column labeled symbol 
sigmaj columns 
transition state labeled symbol exists entry coordinates state symbol contains symbol chapter 
construction algorithms number target state 
contains 
table matrix labeled states symbols storing example automaton example shows table sparse recommend method described ty 
method compresses matrix trying arrange rows overlap 
matrix compressed vector 
row attempt store vector way transitions fall empty spaces left rows 
empty spaces appear state question sigmaj transitions 
symbol sigma potential label transition labeled empty space appears 
compression sparse table adopted ty 
discussion discussion algorithms new original 
developed author stay issco geneva switzerland 
time independently algorithms developed bruce watson richard watson 
exploiting particular features deterministic acyclic fsa opposed nite state automata general possible devise way build automata eoeciently possible general case 
algorithm described rev constructs automaton sorted data performing sort minimization 
data sorted reverse order property compress endings words building automaton 
called pseudo minimization supplemented true minimization 
technique economic memory standard techniques left automaton minimal intermediate state 
writes dictionary automaton pseudo minimization phase times bigger minimal 
algorithms need space minimal automaton register 
size register proportional number states automaton may index structures proportional logarithm number states 
case size smaller size automaton 
compared es algorithm algorithms memory minimize automaton time new word added 
algorithm sorted data possible perform possibly reduce size pruning required building morphological guesser minimized parts automaton left unchanged till construction process 
algorithm data arbitrary order longer interesting property dominique 
note possible incremental algorithms described build deterministic acyclic nite state automata nal transitions 
fact algorithms chapter modied versions algorithms dafsa ft vectors transitions sparse table representation dominique dafsa ft obtain smaller automata 
gains depend characteristics particular data 
table provides examples 
french words taken morphological lexicon french issco geneva 
contains words 
polish words come lexicon developed prof zygmunt adam university poland 
contains words expressions 
polish lexicon regular 
may reason bigger chapter 
construction algorithms gains data 
note gains depend percentage nal states automaton 
possible construct deterministic acyclic automata states corresponding dafsa ft gamma state 
large automata kind gamma ft 
automaton gure automaton 
french polish dafsa states transitions dafsa ft states transitions savings states transitions table dafsa ft compared dafsa dictionaries french polish words algorithms construct transducers 
labels levels put possibly ller character symbol level treated words automaton alphabet sigma theta sigma sigma sigma alphabets levels 
transducers constructed way subsequential 
representation advocated ty 
representation produces smaller dictionaries 
achieved better placement states transitions optimal vector representation eliminating need store number transitions state 
faster recognition 
applications needs list try descendants state spelling correction restoration partly morphological analysis slower check sigmaj possibilities state 
chapter construction guessing automata motivation morphological analysis words text needed applications 
constitutes prerequisite natural language parsing applications useful document retrieval 
analysis usually lexicon requires morphological lexicon 
unfortunately real world texts contain correct words lexicon 
impossible record words living language lexicon lexicon static nature language living thing new words coined continually 
reason nding words lexicon zipf law bri 
zipf law states rank element divided frequency occurrence constant 
brown corpus percent dioeerent words account percent text 
percent dioeerent words occur fewer times corpus 
percent dioeerent words occur fewer times fourth percent occur 
consequence zipf law doubling number words lexicon gets percents coverage arbitrary unrestricted text 
increasing size lexicon costly yielding minute results 
new words constructed derivation compounding 
analysis words relatively easy number small compared number potential words formed way 
practical eric brill uses terms word type token chapter 
construction guessing automata store derivatives compounds lexicon 
cases may ways form new word possible predict chosen 
additionally texts may contain incorrect words 
purpose spelling corrections morpho syntactic categories misspelled word may help reduce list possible corrections 
misspelling word prex categories may easily obtainable corrupted version 
possible textbooks write rules associate word endings specic tags 
natural way write category guesser 
possible enhance rules categories lexemes predicted 
process requires considerable amount linguistic knowledge 
textbook rules capture exceptions nature human languages rules 
aim ffl existing morphological lexicon ffl reduce size lexicon cutting useless information beginnings words ffl generalize knowledge contained lexicon accurate prediction morphological information unknown words possible 
method description method consists preparing data guesser building nite state automaton data cutting useless information automaton recognize meaningful word endings 
automaton transition labeled character 
particular format data important way guesser constructed 
please refer section detailed description 
lexicon reduction strings constructed way described section build nite state automaton 
strings consist inverted inaeected forms followed annotation separator annotations resulting automaton annotations corresponding inaeected form 
inaeected form analyzed inverted look resulting 
method description string automaton 
word lexicon search fails certain state transition labeled letter string 
case annotations reached state printed 
automaton purposes unnecessarily big contains useless information 
word endings normally decide annotation associated word automaton particular structure 
word rst states outgoing transitions 
chain states linked single transitions 
passing annotations complicated transition network 
state central part way leading state appropriate annotations represents useful information purpose 
states part pruned corresponding transitions 
pruning governed rules 
pruning process apply transitions belonging annotations annotations separated inaeected forms annotation separator represented 
rule obvious annotations want obtain recognition phase 
transitions pruned belong inaeected forms precisely beginnings inaeuence annotations 

transition removed pruning process visited transitions reached target state transitions representing annotations 
words states visited outgoing transitions pruned possible postorder method 
chapter 
construction guessing automata means traverse automaton recursively depth cutting unneeded transitions way back 

transition removed target state transition belong annotations removed 
warning sign transition gure shows transitions removed 
different sign reason transition removed dioeerent 
means target state transitions distinguish different annotations lead dioeerent sets annotations 
want lose distinction 

state replaced equivalent state transitions leading states 
automaton kept minimal 

state transitions leading state removed transitions transitions point replaced transitions pointing target state 
rule cuts transitions 
note applies states transition 
consequence rules remove states transitions lead transitions leading dioeerent sets annotations 
rule ensures transitions visited state lead states removed outgoing transition labeled annotation separator 

method description default annotations process described leads construction nite state automaton contains required information 
automaton big reduce size 
looking contents see states majority transitions leading state term default state transitions 
target state outgoing transition labeled annotation separator 
treat frequent transitions exceptions assuming transitions appeared lexicon lead default state 
acting assumption replace frequent transitions default state transition leading default state 
limit imposed ratio frequent frequent transitions trigger pruning 
dioeerence rules 
rule 
rule introduces generalization 
words lexicon annotated correctly may select annotation correct hide possibilities 
may speed annotation process introduce errors correct probable possibilities may shown lexicon may contain data associates endings correct annotations 

state number transitions leading state default state greater equal number transitions multiplied small integer default state outgoing transition labeled annotation separator default state removed transitions lead replaced transition leaving default state 
generalization impossible devise rule associates correct annotation choice lexicalized depends particular word arbitrary morphological point view 
example polish rule transforms adjectival endings lexemes comparatives 
rule transforms endings ny comparatives 
chapter 
construction guessing automata way knowing lexeme comparative superlative dictionary lookup 
introduces articial divisions ra ra ny ia ma ma ny wa wa ny ja ny ny ze ole ble ble ny ny right answer annotations considered ny cope situation introduce new rule strives accommodate cases 
term rst annotated state name state target transition labeled annotation separator state begins annotation set annotations 

state number rst annotated states reachable state exceed limit ffl replace rst annotated states union ffl replace states transitions chosen state union rst annotated states single transition labeled annotation separator 

experimental results note possible introduce lower limit number states removed order insure dealing case described ny 
rule parallel 
things clear need describe mean union states 
constructing new state transitions contributing states 
pairs transitions go dioeerent states construct transitions going unions states union states state having transitions labeled characters transitions transitions form labels go states transitions labels go dioeerent states transitions labels going states union target states 
worth noting rule introduces detailed distinctions discards details 
guesser result applying gets choices having applied 
lexicon size removes small dioeerences similar word forms making possible infer general compact relations endings annotations 
please note annotation possibility lost automaton smaller answers known words longer accurate 
correct answer appears may accompanied incorrect possibilities 
cases exceptions merged regular rules 
lower limit imposed number states removed rule solve problem 
experimental results algorithms tested french polish data 
polish prexes impact categories removed automata lexemes possible comparison french 
rule twice frequent transitions trigger rule 
rule limit number rst states 
lower limit number states removed 
table shows automata french table polish 
chapter 
construction guessing automata states outgoing transition constitute half states incoming transition 
states incoming outgoing transition form single lines 
number heading absolute numbers 
headings listing rules percents numbers automaton rules applied 
standard procedure rules 
reduces automaton percent original size 
rules best french lexemes worst polish lexemes 
french data regular 
french dictionary built level morphology polish source listing irregular roots entries prone errors 
polish irregular rich french 
polish dictionary contained inaeected forms french 
lexemes introduce new irregularities irregular words 
rules 
operate states outgoing transitions 
adding preserves pattern peaks emerge states transitions 
result threshold rule 
frequent transitions infrequent trigger rule states satised condition transitions originally 
second peak comes situation transitions 
worth noticing introduce extra reduction states reduction occur result making states equivalent transitions cut ooe 
rule eoeective terms lexicon size reduction 
doing better states fewer outgoing transitions cuts number states better methods 
number states number transitions automaton reduced 
size automaton depends number dioeerent features tagset 
richer tagset bigger automaton 
tagset experiments verbose 
algorithms guesser constructed rules described chapter evaluation results see section 
related past various handcrafted heuristics purpose morphological analysis unknown words 
supplemented statistical techniques wms 
probabilities dioeerent endings leading corresponding categories calculated 
related endings chosen manually 
revolutionary approach proposed eric brill bri bri 
endings prexes program 
unknown words rst tagged naive initial state annotator tags proper noun common noun bases capitalization 
types transformations applied change tag unknown word 
deleting prex jxj results word string length 

rst characters word 
adding character string prex results word jxj 

word appears immediately left right word 

character appears word 
result compared tagged corpus 
best scoring rule chosen applied corpus new input data 
learning stops rule increase score 
transformation type takes account context unknown word 
morphological analysis separated contextual tagger case approach tagger nd rules 
transformation types checks adding deleting characters word results word 
algorithm transformations transformation type treated necessary supplementary heuristics 
rules schemata account treated method 
andrei mikheev mik applied brill transformations data pre existing morphological lexicon 
uses template fb gammas class class ffl indicates rule applied word possible values ffl segmented deleted unknown word value ffl segment possibly empty added result string segmentation chapter 
construction guessing automata ffl class required pos class set pos tags stem result string operations checked 
lexicon having particular pos class class set checking required ffl class pos class assign 
unknown word operations successful compared brill algorithm mikheev checks optionally morphological class set categories resulting word transformation templates 
algorithm returns categories unknown word probable 
mikheev aware fact rules learnt brill algorithm transformed nite state automaton 
process complex time consuming 
learning process takes time 
algorithm produces fsa directly data exploring links occur naturally format data 
brill approach copied mikheev length prexes constant 
increasing means computation 
method discovered naturally need limit lengths 
concluding remarks method leads device perform morphological analysis known unknown words accurately possible see section evaluation preserving advantages nite state automata great speed small size 
eliminate need separate devices space 
plan experiment values thresholds rules 
issue needs farther investigation impact closed categories data guesser lexicon recognition process 
exclusion categories lexicon reduce size 
excluding categories requires additional linguistic knowledge contradicts goals 
hand current treatment prexes requires knowledge 
believe existing algorithms dc tc possible process data automatically 
believe method lexical acquisition 
annotations may contain morphological descriptions data morphology program 
rs appear mik 
concluding remarks small core morphology construct guesser process new words corpora acquire new lexemes 
noted average current method gives lexemes analyzed word 
programs experiments available free charge research purposes www pg gda pl fsa html 
french data comes issco universit de gen available research purposes ftp issco ftp unige ch multext le french gz 
le french gz input data issco morphology program available address 
polish data comes zygmunt adam university poland available research purposes 
chapter 
construction guessing automata contents lexemes lexemes rules total total transitions states total transitions outgoing incoming sg lines total length table impact rules statistics french dictionary 
concluding remarks contents lexemes lexemes rules total total transitions states total transitions outgoing incoming sg lines total length table impact rules statistics polish dictionary chapter 
construction guessing automata chapter usage algorithms deterministic acyclic nite state automata classical automata 
comparison algorithms easier classical automata standard 
versions deterministic acyclic nite state automata nal transitions implemented 
implementations implicit states features states moved transitions 
means fact dafsa fts minimal 
spelling correction purpose spelling correction verify text correct linguistically constitutes sequence statements correct statements language text written propose means correct 
text correct words text ffl correct words language document written ffl correct context 
possibly incorrect words detected dictionary lookup 
word dictionary may valid word language changes time 
errors dictionary 
past statistical techniques detect erroneous words 
program called typo pet frequencies trigrams nd possibly incorrect words 
words contained trigrams low frequency judged possibly incorrect 
incorrect words expressions spelling checker produce list possible replacements 
replacements words chapter 
usage dictionary word certain aspect 
similarity measured number ways 
important involve ffl edit distance ffl similarity roots morphological categories ffl pronunciation measures origins errors 
errors result ffl translation word image brain sequence nerve impulses drive muscles ngers hit keys keyboard erroneous words lie short edit distance correct forms ffl lack knowledge morphology certain words improper derivational paradigm polish gives give correct forms morphological analysis ffl lack knowledge proper spelling words knowledge approximate pronunciation correct forms looking words pronounced similar way 
measures rely solely properties individual words 
lists replacements reduced checking context words 
certain words appear certain contexts 
disambiguation done syntactic semantic analysis statistical methods machine learning 
nite state tools success syntactic level see rs developed tools purpose methods described 
reason methods implemented involve syntactic level stays morphology lexicon level see 
description methods nite state tools see cdk cgm gc ks 
syntactic level higher levels detect words correct words language lexicon wrong context 
probably incorrect forms words 
edit distance dam strings species basic editing operations needed convert string 
basic editing operations ffl insertion symbol 
spelling correction ffl deletion symbol ffl change symbol ffl transposition adjacent symbols note symbols involved basic operations space operations may break words join 
edit distance strings words lengths respectively dened follows dc og ed ed characters gamma gamma ed ed characters transposed ed ed ed ed ed gamma ed gamma max boundary denitions recursive part denition divided sections 
rst obvious characters edit distance remove ends words 
example ed aba bba ed ab bb ed 
section provides formula applied case letter rst word penultimate letter second word vice versa 
situation transposition letters words transformations need done obtain word case 
cases give similar results deletion 
aba abab insertion 
abab aba 
section deals cases letters words equal equal penultimate letters word 
situation result operations replacement letter 
deletion 
ab insertion 
ab 
edit distance dene set plausible corrections word sigma fw lj ed tg chapter 
usage maximum edit distance word correction 
possible attribute dioeerent costs dioeerent editing operations 
formula ic insertion cost dc deletion cost cc change cost tc transposition cost 
manipulating constants possible favor type operation 
ed ed characters gamma gamma tc ed ic ed dcg characters transposed cc ed ic ed dcg ed delta ic ed delta ic ed gamma ed gamma max delta ic boundary denitions editing operations produce typographical errors reversible string obtained basic editing operation correct word correct word obtained performing single basic editing operation complementary lead error 
insertion deletion mutually complementary change transposition self complementary 
generation strings lie specied edit distance testing presence lexicon time special techniques past limit number candidates corrections 
joseph pollock antonio zamora pz skeleton key omission key index words dictionary corrections incorrect string 
words value key incorrect string tested edit distance incorrect string 
skeleton key contained rst letter incorrect string unique consonants order occurrence unique vowels order occurrence 
omission key nd corrections handled skeleton key 
constructed sorting unique consonants incorrect string order appending unique vowels original order 
order consonants established empirically frequencies omissions letters words corpora 

spelling correction pioneering spelling correction nite state automata done kemal og 
approach polish language 
nd corrections erroneous word need nd paths start state nal states labels transitions path concatenated resulting string edit distance threshold erroneous word 
searching needs fast search automaton 
soon clear current path lead solution abandon 
detect cases notion cut ooe edit distance introduced dc og 
cut ooe edit distance minimum edit distance initial substring incorrect word initial substring candidate correct word 
edit distance cut ooe edit distance string length partial candidate word length dened follows min liu ed min gamma max range lengths substrings checked gamma close word boundaries 
gamma take null string length append additional characters depth rst search automaton cut ooe edit distance gives algorithm 
procedure spell state word candidate sigma ffi state candidate candidate word candidate spell word candidate ed word candidate print candidate spelling correction nite state automata note possible automata store words annotations morphological analysis algorithms substituting test test presence transition labeled annotation separator 
dynamic programming technique chapter 
usage reuse computed values edit distance speed algorithms improved dc 
closer examination formula computing edit distance shows value ed depends ed gamma ed gamma gamma ed gamma ed gamma gamma 
values ed put matrix ed 
looking algorithm see move row values row gamma computed 
stay transitions tried loop 
need recompute gamma gamma gamma gamma gamma 
need recompute gamma 
algorithm computing cut ooe edit distance proceeds rows smaller indices bigger ones value gamma computed needed calculation 
languages nd words dioeerent spelling pronounced identically similar way 
polish example pairs rz identical pronunciation native polish speakers distinguish voiced ch voiced polish speakers pronounce ch 
number books write properly grows new types errors emerge om en em 
pairs ch treated typographical errors 
pair rz new pairs involving nasal vowels 
finding words pronounced similar manner word usually done transducers 
transducer level contains inaeected forms symbols represent pronunciation 
search candidates correct forms done pronunciation level possibly edit distance 
languages highly regular pronunciation polish away automata acceptors 
solution takes account possibility replacing pair characters single character vice versa 
note transformations produce errors change 
highly accidentally drop insert consecutive letters move letters positions 
algorithm suoecient polish 
elegant general solution involve weighted transducers local extension algorithm rs moh 
application morphological analysis correction lexical errors proposed number papers cgm 
method requires steps 
checking word lexicon 
morphological analysis incorrect word yielding lexeme root derivational morphology corresponding morphological 
spelling correction procedure spell state word candidate sigma ffi state candidate candidate match word candidate spell word candidate gamma length word gamma length candidate ed word candidate gamma gamma max distance print candidate word candidate spell word candidate match word candidate spell word candidate gamma length word gamma length candidate ed word candidate gamma gamma print candidate ed word candidate print candidate spelling correction nite state automata categories 
morphological generation inaeected form basis lexeme root derivational morphology categories obtained form morphological analysis 
implemented steps attempt integrate 
second step morphological analysis word lexicon performed 
analysis described section page construction nite state automaton discussed chapter page data discussed section page 
analysis correct errors incorrect nominalization proper nominalization detect errors recognizing possibly candidates lexeme pies categories noun animal chapter 
usage single genitive 
morphological generation input data lexeme categories obtained previous step yield psa 
morphological generation analogous morphological analysis described section page 
note lexeme root lexicon inaeected forms categories candidates generated 
restoration diacritics restoration diacritics seen special case spelling correction 
particular division word methods methods context 
methods context similar spelling correction 
description methods see 
word methods restoration diacritics basis context methods providing choices 
techniques partially dioeerent spelling correction 
particular word text lexicon mean correct words deprived diacritics give word 
dene function strip converts letter diacritics word argument function letters shape diacritics 
function relation sigma theta sigma strip strip purpose word method restoration diacritics nd words word question 
achieved statistical techniques measuring frequencies sequences letters words see dac standard technique lexicon 
particular lexicon form nite state automaton usual advantages compact representation great speed processing 
gives algorithm nding words lexicon word 
dot operator represents concatenation 
note possible algorithm morphological dictionaries implemented transducers automata acceptors 
corrections necessary adaptation trivial 
morphology purpose morphological processing obtain morphological information inaeected word form generate form corresponding 
morphology procedure state output state print output sigma ffi state output restoration diacritics nite state automata lexeme morphological categories 
transducers transducers translate string string morphological analysis generation inaeected forms straightforward consists labels level dictionary transducer 
generation inversion analysis follow output labels input labels include analysis 
procedure analyze state word index output state print output sigma ffflg ffi state ffl analyze word index output sigma ffflg ffi state word index analyze word index output morphological analysis transducers dot operator represents concatenation 
result concatenating string empty string string word ffl word 
empty string transition labels necessary lengths strings may string string transducers 
string weight transducers moh describe 
chapter 
usage match 
useful alignment segments strings represent features 
alignment may reduce size transducer automata acceptors simple automata acceptors morphological analysis 
provide faster analysis range languages described machines limited case transducers 
special encoding techniques necessary contents dictionaries see section page instructions prepare data dictionary form automaton acceptor 
note strings dictionary internal structure 
parts rst inaeected form word second annotations describing corresponding lexeme morphological categories 
parts separated annotation separator 
analysis phases corresponding parts 
rst phase recognition inaeected forms 
second treats annotations 
annotations may contain lexemes 
lexemes coded see section page reduce size dictionary 
decoded analysis 
decoding consists copying inaeected form letters indicated code 
procedures gure 
note may useful introduce prexes dictionary way analysis unknown words 
additional code say characters rejected word get lexeme 
variation implemented 
unknown words process tag assignment word tagged inverted word marker appended string subsequent transitions automaton starting start state traversed labels match subsequent characters string 
state reached matching transitions 
transitions state labels belonging tags labels paths automaton starting transitions nal states printed tags 
algorithm applies recursively states reached directly state 
process recognizing words nding corresponding annotations decomposed steps see 
personal communication martin kay 
morphology procedure analyze state word index ffi state word index analyze word index index length word ffi state annotation separator lexeme word procedure lexeme state word ffi state annotations word length word gamma ord procedure annotations state output state print output ffi state annotations output morphological analysis automata acceptors steps described involve recognition prexes decoding lexemes 
purpose obtain lexemes categories language question prexes french algorithms appropriate procedures 
see example guessing categories inaeected forms 
evaluate rules described sections page inaeuence analyses inaeected forms unknown lexicon correct polish words selected corpus 
words chosen words started judged correct 
foreign words abbreviations misspellings rejected 
small percent words fell classes lexicon construction rejected 
table shows results 
rule best suited tagging preprocessor parser better lexicographer nd additional analyses 
standard measures quality guessing recall percentage pos tags correctly assigned guesser chapter 
usage procedure recognize state word invert word procedure state word ffi state word letter number word ffi state annotation separator state word sigma ffi state ij procedure state word index ffi state word index word index ffi state annotation separator word index length word procedure state word ffi state word length word gamma ord procedure state annotation state print annotation target state ffi state word letter number target state sigma ffi state target annotation morphological analysis unknown words total number correct pos tags word precision percentage pos tags guesser assigned correctly total number pos tags assigned word 
morphology mix bla kac guessing categories words 
prexes lexemes lexemes lexemes rules analyses word correct analyses words incorrect analyses words correct analyses lexemes word table impact rules analyses coverage proportion words guesser able classify necessarily correctly 
set apart tenth morphological data constructed guessing automaton remaining tenths data 
words separated part measure quality guessing 
table shows results 
mikheev reported recall precision recall 
comparing method mikheev take circumstances account chapter 
usage rules recall precision recall table average quality guessing polish morphological data ffl dioeerent language mikheev language experiment sort 
impact dioeerence may manifold 
polish typically language large paradigms defective forms precision polish may lowered english 
frequent nouns plural singular forms adjectives adverbs comparative superlative degrees verbs participles 
ffl mikheev corpus smoothing 
thing 
smoothing eliminate unproductive rules introduced frequent irregular words see bs discussion hapax words 
ffl method constant development see potential improvements 
introducing limit number transitions triggering application rule combining rule rule give method recall close displayed table heading precision heading 
ffl method better coverage feature language independent 
ffl method faster 
construct automaton prune 
mikheev uses brill method obtain rules 
time consuming rule chosen run data processing words 
mikheev obtains set rules automaton 
application rules slow compared statistical methods 
schabes rs give method transforming rules transducer gives higher recognition speed 
transformation time consuming involves local determinization 
ffl mikheev recognized categories recognize canonical forms 

perfect hashing perfect hashing hashing maps keywords set keywords numbers addresses 
mapping bijection set gamma hashing said 
perfect hashing implemented form automaton roc 
treat keywords words language accepted automaton 
build automaton accepts language consequently stores words 
language contains nite number words automaton acyclic 
eoecient deterministic 
need establish mapping words cardinal numbers 
note transitions automaton sorted labels mapping implicitly exists automaton 
words ordered order appearance automaton traversed postorder method 
mapping provided counting words precede word automaton 
counting words mean traversing automaton computationally impractical 
possible precompute values search eoeective 
look sample automaton deterministic version 
sample deterministic nite state automaton implementing perfect hashing chapter 
usage small numbers near state circles tell words words accepted automaton accepted part automaton reachable state state including 
formally number computed sigma ffi gj number calculated recursively dynamic programming jq sigma ffi numbers precomputed stored respective states available dictionary lookup 
nd number associated word nd word automaton doing calculations states pass 
looking number words precede word automaton 
word fourth word recognized automaton 
nd fourth word rst look start state go state count count total number words language accepted automaton 
see label second transition 
rst transition leads state count value set 
means word automaton precedes words start add total initially zero 
transition labeled leads state labeled state nal shorter words come longer ones add total go 
add second transition state rst transition leads state count value set 
total 
go nal add total go nal state accepted 
total meaning words automaton fourth 
chapter summary new type automata number new algorithms dissertation 
finite state automata nal transitions fsa ft hold exactly information classical nite state automata 
smaller classical counterparts states transitions 
implementations implicit states features states stored transitions fact fsa ft unfortunately automata simple transformations minimal classical fsa number states transitions 
new kind automata explicitly making automata smaller 
new algorithms constructing deterministic acyclic automata 
main characteristics incremental 
main implication fact require memory methods need data memory start 
dictionaries experiments mean having store gb practically impossible current technology 
automata smaller construction algorithms require memory proportional size automaton memory requirements algorithms additionally lowered implementation 
aware algorithm builds deterministic acyclic fsa incrementally rev 
algorithm dominique similar characteristics algorithms 
dominique constructs automata steps rst produces automaton pseudo minimization second true minimization 
automaton pseudo minimization phase times larger rev minimal increasing intermediate memory requirements 
algorithms 
algorithm sorted data possible perform operations automaton parts chapter 
summary minimized longer changed 
algorithm data arbitrary order require data sorted fed directly programs produce data minimizing storage space intermediate results 
words lexicon pose problems treatment free texts 
method constructing guesser data morphological lexicon 
guesser form nite state automaton usual advantages machines great speed compact representation 
guesses basis word endings beginnings 
method predicts corresponding lexemes categories associated words 
compared traditional approaches textbook rules method relies directly data exceptions easily overlooked manual processing included 
compared eric brill solution bri bri infer rules directly lexicon text accurate information input 
lexicon method guessing rule inference mik 
andrei mikheev uses eric brill learning techniques rule schemata approach rules implicit automaton 
fact guesser automaton transformation automaton built data prepared special way 
rule schemata rules infer general 
algorithm acquisition morphological lexicon 
core lexicon level morphology built 
lexicon contain rules 
guesser morphological descriptions annotations corresponding lexeme continuation classes 
moment writing level morphology polish test ideas 
enhancement kemal algorithm spelling correction possible give proper corrections incorrect polish words 
problem frequent errors pass edit distance barrier specic recognized corrected 
solution elegant solution weighted transducers 
put ideas algorithms context refer reader sources appropriate 
solutions compared advantages methods pointed clearly 
algorithms implemented freely available internet non commercial purposes url www pg gda pl fsa html 
theses stated ffl possible construct minimal deterministic acyclic nite algorithm developed independently richard watson bruce watson state automata memory previously known algorithms maintaining speed construction process 
ffl possible construct automata guess canonical forms words annotations directly data morphological lexicon 
little linguistic knowledge required process 
state process faster previously known algorithm serving purpose maintains similar quality guessing 

proposed algorithms construction minimal deterministic acyclic nite state automata desired features 
method construction nite state automaton guesses categories unknown words guesses corresponding canonical forms 
method faster methods similar quality guessing requires little linguistic knowledge knowledge embedded data 
chapter 
summary appendix fsa package name build automaton sorted data words synopsis options description builds automaton list words 
list sorted 
important locale sorting long order consistent 
output automaton 
options resulting automaton smaller 
time required build automaton greater 
greater depends compile options compilation 
see install distribution explanation various compile options 
default options compress automaton 
option option 
appendix fsa package species input le 
le contain list words word line 
absence option standard input 
species output le automaton placed 
absence option standard output 
species character separates words morphological annotations 
prepares index predict word categories 
option available program compiled compile option 
specifying compile option helps making resulting automaton smaller faster 
compile options default 
format data depends compile options build program outcome program 
compiled input data list inverted words annotations 
line contain inverted word rst character character word second penultimate 
inverted word followed immediately ller character annotation separator grammatical annotations 
specify morphological properties words number gender assuming le le contains data columns inaeected word canonical form annotations awk length substr printf snn file sort file idx prepares data index 
line 
detail see contents awk le included distribution 
standard name extension automata prepared way atg 
compiled data line contain information additional annotation separator code corresponding lexeme inserted front rst annotation separator 
code species characters inaeected word rejected appending lexeme 
code letter 
means characters reject 
detail see awk le included distribution 
standard name extension automata prepared way atl 

compiled data lines similar specied 
inaeected forms contain prexes additional annotation separator added rst see awk le included distribution 
inaeected forms contain prexes prex removed inverted word leaving ller character placed annotation separators simple form 
awk le contain code recognizing prexes modied individual languages recognize specic morphological categories 
prexes forms recognized 
standard name extension automata prepared way atp 
number entries 
entries numbered position line number input stream 
called perfect hashing 
option works program compiled numbers compile option 
option option 
print version details compile options 
exit status ok invalid options lack required option 
memory 
see bugs send bug reports author jan daciuk pg gda pl name nd words deprived diacritics match words input appendix fsa package synopsis options description reads lines input 
line contains word 
word looked specied dictionaries 
words deprived diacritics match input word printed 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries automata built 
establish relationships characters diacritics 
rst character comment character 
lines comments ignored 
lines specify character diacritics characters diacritics 
rst character line character diacritics 
followed spaces ht characters string characters diacritics followed immediately new line 
spaces characters diacritics 
word containing character rst column words containing character characters listed right looked 
species input le le words lack accents 
input les specied way 
option standard input 
species le hold language specic information 
characters form words pairs lowercase uppercase characters case conversion 
option specied latin letters standard case conversions wil 
note information depends module handling 
prints version details 

exit status ok invalid option lack required option 
dictionary le opened 
memory 
accent le opened 
see bugs send bug reports author jan daciuk pg gda pl name guess lexeme categories word synopsis options description reads lines input 
line contains word 
word probable categories printed contents dictionary category word pairs 
program compiled option dictionary prepared accordingly categories lexemes printed 
appendix fsa package options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries automata built option 
data automata prepared special way 
automata predict categories line input contain inverted word inverted word marked ller character followed annotation separator followed tags 
see awk script available package treat dictionaries compiled compile option 
standard name extension dictionaries prepared way atg 
guess lexemes compiled compile option input contain line inaeected form annotation separator code lexeme annotation separator tags annotations 
code species characters inaeected form deleted appending lexeme get lexeme 
character 
calculate number take character code character code 
see awk script available package 
standard name extension automata prepared way atl 
take account information included prexes compiled 
data lines rst annotation separator replaced annotation separators entries contain prexes prex deleted inverted inaeected form leaving ller character placed annotation marks 
standard name extension automata prepared way atp 
compiled 
option available program compiled 
compiled 
option program compiled 
species input le le contains words categories guessed 
le specied option 
absence option standard input 
species le holds language specic information 
characters form words pairs lowercase uppercase char 
case conversion 
option specied latin letters standard case conversions 
print version details 
exit status ok invalid options lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl name convert words numbers numbers words synopsis options options description reads lines input 
line contains word number 
word looked specied dictionaries 
word number printed printed 
number treated word number 
word corresponding number printed error message word dictionary 
note demo underlying 
appendix fsa package options dictionary dictionary 
dictionaries may 
dictionary specied 
rst dictionary 
dictionaries automata built 
convert words numbers 
convert numbers words 
species le words corrected 
le specied way option 
absence option standard input 
species le hold language specic information 
characters form words pairs lowercase uppercase characters case conversion 
option specied latin letters standard case conversions wil 
note information depends module handling 
prints version details 
exit status ok invalid option lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl 
name perform morphological analysis word synopsis options description reads lines input 
line contains word 
inaeected word morphological analysis printed 
consists pairs lexeme tag 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries automata built 
data prepared special way 
line data consists inaeected form followed separator followed code followed lexeme followed separator followed tags 
code species characters inaeected form dioeerent characters lexeme characters constitute inaeected word 
means characters rejected 
data dioeerent normal word list format automaton content dioeerent magic number normal data 
species input le le contains words analysed 
le specied option 
absence option standard input 
species le hold language specic information 
characters form words pairs lowercase uppercase characters case conversion 
option specied latin letters standard case conversions wil 
note information depends module handling 
appendix fsa package print version details 
exit status ok invalid options lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl name print words specied prex synopsis options description reads lines input 
line contains word 
word treated prex 
words specied dictionaries word prex printed 
word empty contents dictionary printed 

options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries automata built 
species le prexes completed 
le specied way option 
absence option standard input 
species le hold language specic information 
characters form words pairs lowercase uppercase characters case conversion 
option specied latin letters standard case conversions wil 
note information depends module handling 
print version details 
exit status ok invalid options lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl name nd words dictionary propose replacements appendix fsa package synopsis options description reads lines input 
line contains word 
word looked specied dictionaries 
word similar words listed 
degree similarity controlled edit distance option 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries automata built 
word dictionaries look words lie specied distance 
edit distance number basic editing operations needed transform string 
operations inserting character deleting character changing character transposing adjacent characters 
species le words corrected 
le specied way option 
absence option standard input 
species le holds language specic information 
characters form words pairs lowercase uppercase characters case conversion 
option specied latin letters standard case conversions wil 
species le information relation single characters character sequences 
letter sounds dioeerent letter relation established le replacement rst second treated edit distance unit apart 
rst character le comment character lines ignored 
data lines consist columns 
columns specify single character character sequence sum number characters 
rst column species may incorrectly appear text second correct form 
prints version details 

exit status ok invalid option lack required option 
dictionary le opened 
memory 
see 
bugs send bug reports author jan daciuk pg gda pl appendix fsa package appendix package name build transducer unsorted data string pairs synopsis options description builds transducer level nite state automaton list word pairs second word annotations 
format input annotations annotations arbitrary strings contain ller annotation separator 
output transducer 
options resulting transducer smaller 
time required build transducer greater 
greater depends compile options compilation 
appendix package indicate character input data separate surface string lexical string lexical string annotations 
ller indicate character align surface lexical strings annotations character may appear input data put program strings transducer equal length 
string longer padded trailing llers 
default 
indicate character separate annotations lexical string output 
default 
species le source data transducer 
option standard input 
species le transducer written 
option standard output 
print version details 
exit status ok invalid options lack required option 
memory 
error secondary index 
attempt register registered node 
attempt register node registered 
arcs node 
see 
bugs send bug reports author jan daciuk pg gda pl french data transducer built arc bigger build 
bug programs transducer 
name nd words deprived diacritics match words input synopsis options description reads lines standard input 
line contains word 
word looked specied dictionaries 
words deprived diacritics match input word printed 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries transducers built 
establish relationships characters diacritics 
rst character comment character 
lines comments ignored 
lines specify character diacritics characters diacritics 
rst character line character diacritics 
followed spaces ht characters string characters diacritics followed immediately new line 
spaces characters diacritics 
word containing character rst column words containing character characters listed right looked 
appendix package species name le containing language specic information characters letters 
rst character language le comment character lines character ignored 
rst data line sequence characters valid words default letters 
second data line contains sequence pairs letters lowercase letter rst uppercase 
option standard case conversions apply 
species input le standard input 
prints version details 
exit status ok invalid option lack required option 
dictionary le opened 
memory 
accent le opened 
see bugs send bug reports author jan daciuk pg gda pl name print morphology word synopsis options 
description reads lines standard input 
line contains word 
word looked specied dictionaries 
entry dictionary matches word information entry printed 
assumed dictionary entry described pair surface form annotations 
surface forms match word case possible lexical forms annotations printed 
names surface form lexical form main purpose 
purposes 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries transducers built 
species name le containing language specic information characters letters 
rst character language le comment character lines character ignored 
rst data line sequence characters valid words default letters 
second data line contains sequence pairs letters lowercase letter rst uppercase 
option standard case conversions apply 
species input le standard input 
generate inaeected forms lexemes sets categories aka tags annotations performing morphological analysis 
species character separates lexemes annotations tags sets categories input option 
option eoeect specied 
print version details 
exit status ok invalid options lack required options 
dictionary le opened 
memory 
appendix package see bugs send bug reports author jan daciuk pg gda pl name print words specied prex synopsis options description reads lines standard input 
line contains word 
word treated prex 
words specied dictionaries word prex printed 
output form annotations see 
word empty contents dictionary printed 
options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries transducers built 
species name le containing language specic information characters letters 
rst character language le comment character lines character ignored 
rst data line sequence characters valid words default letters 
second data line contains sequence pairs letters lowercase letter rst uppercase 
option standard case conversions apply 

species input le standard input 
print version details 
exit status ok invalid options lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl name nd words dictionary propose replacements synopsis options description reads lines standard input 
line contains word 
word looked specied dictionaries 
word similar words listed 
degree similarity controlled edit distance option 
appendix package options dictionary dictionary 
dictionaries may 
dictionary specied 
dictionaries transducers built 
word dictionaries look words lie specied distance 
edit distance number basic editing operations needed transform string 
operations inserting character deleting character changing character transposing adjacent characters 
species name le containing language specic information characters letters 
rst character language le comment character lines character ignored 
rst data line sequence characters valid words default letters 
second data line contains sequence pairs letters lowercase letter rst uppercase 
option standard case conversions apply 
species input le standard input 
prints version details 
exit status ok invalid option lack required option 
dictionary le opened 
memory 
see bugs send bug reports author jan daciuk pg gda pl bibliography ahu aho hopcroft ullman 
design analysis computer algorithms 
addison wesley publishing 
eric steven atwell 
detect grammatical errors text parsing 
acl proceedings third european conference pages 
steven bird mark ellison 
level phonology representations rules nite automata 
computational linguistics march 
ben jon bentley 
spelling checker 
communications acm may 
bri eric brill 
corpus approach language learning 
phd thesis department computer information science university pennsylvania usa 
bri eric brill 
transformation error driven learning natural language processing case study part speech tagging 
computational linguistics december 
bs harald baayen richard sproat 
estimating lexical priors morphologically ambiguous forms 
computational linguistics june 
jacques le damian ir ne 
de perspectives 
prc communication machine le langage toulouse france january 
cdk jacques le ir ne damien vera lucia strube de lima 
complete detec bibliography tion correction system 
international conference current issues computational linguistics malaysia june 
cgm jacques damien jacques men zo 
int de strat gies de correction dans un system de tection correction 
colloque informatique iln nantes france 
ch jaime carbonell philip hayes 
recovery strategies parsing language 
american journal computational linguistics july december 
doug cutting julian kupiec jan pedersen penelope sibun 
practical part speech tagger 
proceedings third conference applied natural language processing trento italy 
acl 
available xerox parc technical report ssl 
ct jean pierre pasi tapanainen 
creating tagset lexicon guesser french tagger 
acl sigdat workshop texts tags issues multilingual language analysis pages university college dublin ireland 
acl 
dac jan daciuk 
za automat volume pages september 

dam damerau 
technique computer detection correction spelling errors 
communications acm march 
dc du chang 
model fast algorithm multiple errors spelling correction 
acta informatics 
dls durham lamb saxe 
spelling correction user interfaces 
communications acm october 
jan daciuk richard watson bruce watson 
incremental construction acyclic nite state automata transducers 
finite state methods natural language processing bilkent university ankara turkey june july 
bibliography gc damien jacques 
detection correction computer aided writing 
coling nantes france july 
gen damien 
de analyse une hi de cat gories 
colloque informatique iln nantes france 
gj dan gildea dan jurafsky 
automatic induction nite state transducers simple phonological rules 
technical report tr international computer science institute berkeley california october 
gls dennis john daniel sleator 
robust parsing algorithm link grammars 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa usa august 
heidorn jensen miller byrd chodorow 
text critiquing system 
ibm system journal 
hu john hopcroft ullman 
automata theory languages computation 
wesley publishing reading usa 
jensen heidorn miller ravin 
parse tting prose xing getting hold ill formedness 
american journal computational linguistics july december 
kar lauri karttunen 
constructing lexical transducers 
coling kyoto japan 
kk ronald kaplan martin kay 
regular models phonological rule systems 
computational linguistics september 
kls tomasz kowaltowski cl lucchesi jorge 
application nite automata debugging natural language vocabularies 
south american string processing workshop 
kls tomasz kowaltowski cl lucchesi jorge 
minimization binary automata 
south american string processing workshop 
bibliography kos kimmo koskenniemi 
level model morphological analysis 
ijcai pages karlsruhe germany 
kos kimmo koskenniemi 
general computational model word form recognition production 
coling pages stanford university california usa 
association computational linguistics 
ks stan norman 
relaxation techniques parsing grammatically ill formed input natural language understanding systems 
american journal computational linguistics april june 
mik andrei mikheev 
learning part speech guessing rules lexicon extension non concatenative operations 
coling th conference computational linguistics volume pages copenhagen denmark august 
mik andrei mikheev 
automatic rule induction unknown word guessing 
computational linguistics september 
moh mehryar mohri 
compact representations nite state transducers 
acl san francisco california 
association computational linguistics morgan kaufmann 
moh mehryar mohri 
syntactic analysis local grammars automata eoecient algorithm 
international conference computational lexicography complex budapest hungary 
moh mehryar mohri 
finite state transducers language speech processing 
computational linguistics june 
kemal 
error tolerant nite state recognition applications morphological analysis spelling correction 
computational linguistics march 
og kemal 
spelling correction agglutinative languages 
th conference applied natural language processing pages stuttgart germany october 
pet peterson 
computer programs detecting correcting spelling errors 
communications acm december 
bibliography pv joseph lucy 
automatically identifying morphological relations machine readable dictionaries 
ninth annual conference uw centre new oed text research pages 
pz joseph pollock antonio zamora 
automatic spelling correction text 
communications acm april 
rev dominique 
algorithmes 
phd thesis institut blaise pascal paris france 

roc emmanuel roche 
finite state tools language processing 
acl 
association computational linguistics 
tutorial 
graeme ritchie graham russell alan black stephen pulman 
computational morphology 
bradford books 
mit press cambridge massachusetts usa 
rs emmanuel roche yves schabes 
deterministic part speech tagging nite state transducers 
computational linguistics june 
rs emmanuel roche yves schabes 
finite state language processing 
bradford book 
mit press cambridge massachusetts usa 
shs bruno schulze ulrich helmut schmid anne schiller mats rooth gregory grefenstette jean annie zaenen simone teufel 
decide 
project str november 
spr richard sproat 
morphology computation 
bradford books 
mit press cambridge massachusetts usa 
tc pieter ian 
automatic acquisition level morphological rules 
fifth conference applied natural language processing pages washington dc usa april 
association computational linguistics association computational linguistics 
ty robert endre tarjan andrew chi chih yao 
storing sparse table 
communications acm november 
bibliography ver jean 
morphosyntactic correction natural language interfaces 
international conference computational linguistics pages 
international computational linguistics 
zygmunt bogdan tomasz gra 
unambiguous coding polish nouns application electronic dictionaries format 
uam 
wat bruce watson 
taxonomy nite automata construction algorithms 
computing science note eindhoven university technology netherlands 
wat bruce watson 
taxonomy nite automata minimization algorithmes 
computing science note eindhoven university technology netherlands 
wat bruce watson 
taxonomies toolkits regular language algorithms 
phd thesis eindhoven university technology netherlands 
wms ralph weischedel marie meteer richard schwartz lance ramshaw 
coping ambiguity unknown words probabilistic models 
computational linguistics 
david yarowsky 
comparison corpus techniques restoring accents spanish french texts 
nd annual workshop large text corpora kyoto japan 
david yarowsky 
decision lists lexical ambiguity resolution application accent restoration spanish french 
proceeding acl san francisco california 
association computational linguistics morgan kaufmann 
index acyclic automaton alphabet annotation separator automaton acyclic deterministic deterministic acyclic nal transitions language minimal minimality start useful useful nal transitions binary automaton binary state cloning common prex state coverage cut ooe edit distance dafsa ft default state deterministic acyclic automaton deterministic acyclic fsa nal transitions deterministic automaton digram edit distance emission function failure transition rst annotated state fsa ft hashing inx code language automaton longest common minimal automaton minimality minimization morphological annotation category lexicon morphology analysis guessing moving markers neighborhood matrix omission key perfect hashing precision prex prex code proper state index pseudo minimization rational function rational transduction reachable state recall restoration diacritics right language sequential transducer skeleton key spelling correction start useful automaton state binary cloning default rst annotated proper reachable right language statistical techniques restoration diacritics spelling correction subsequential transducer transducer construction nding words similar pronunciation morphological analysis morphological data sequential software package subsequential weighted transition failure function trigram useful automaton zipf law 
