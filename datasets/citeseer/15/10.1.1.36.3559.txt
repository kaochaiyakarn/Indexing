type system equivalent flow analysis jens palsberg patrick keefe flow safety analysis higher order languages studied shivers palsberg schwartzbach 
open problem finding type system accepts exactly programs safety analysis 
prove amadio cardelli type system subtyping recursive types accepts programs certain safety analysis 
proof involves mappings types flow information back 
result obtain inference algorithm type system solving open problem 
background program analyses higher order languages flow analysis known closure analysis 
examples include various analyses standard ml new jersey compiler binding time analyses scheme partial evaluators similix 
analyses advantage applied untyped languages 
contrast traditional interpretations types defining domains 
popular define program analyses typed languages annotating types information program behavior 
lead clear specifications range analyses analysis efficiently computed straightforward extension known type inference algorithm 
extended proc 
popl nd annual sigplan sigact symposium principles programming languages 
computer science department aarhus university dk aarhus denmark 
mail palsberg daimi aau dk 
avenue ma usa 
mail pmo world std com 
precision type analysis depends expressiveness underlying type system 
similarly precision flow analysis depends expressiveness underlying flow analysis 
address instance fundamental question fundamental question 
type analysis computes information flow analysis 
consider case flow safety analysis analysis collects type information example constants applications primitive operations 
analysis shivers called type recovery 
palsberg schwartzbach proved basis collected information define predicate accepts programs go wrong 
called safety analysis 
proved safety analysis accepts programs simple type inference 
consider instance question type system accepts programs safety analysis 
particular safety analysis consider defined section 
thesis type system answers specific question cases answer fundamental question 
result prove natural type system subtyping recursive types accepts programs safety analysis 
proof involves mappings types flow information back 
type system studied amadio cardelli algorithm deciding subtyping relation kozen palsberg schwartzbach :10.1.1.33.8725:10.1.1.33.8725
open question type inference 
corollary result get type inference algorithm works doing safety analysis mapping flow information types 
set types grammar int type system contains components binary function type constructor constant type int possibility creating recursive types constant types 
subtype relation written contrast safety analysis uses domain containing sets syntactic occurrences abstractions constant int 
slogan form result reads flow analysis safety checks simple types recursive types subtyping component type system captures facet flow analysis ffl function type constructor corresponds set abstractions 
intuitively function type concrete set abstractions 
components type system essential accept programs safety analysis 
ffl constant int purpose systems 
simplicity consider base types product sum constructors constructs handled techniques similar ones 
ffl recursive types needed order safety analysis accepts programs contain constants 
ffl constant corresponds largest possible set flow information 
type needed variables hold function base value 
intuitively program variable type incorrect 
flow analysis may detect variable passed 
type system capability required 
ffl constant corresponds empty set flow information 
type needed variables function base value 
intuitively program uses variable ways type incorrect 
flow analysis may detect part program executed 
type system capability required 
ffl subtyping needed capture flow information 
intuitively information flows type subtype type palsberg schwartzbach proved system accepts programs safety analysis 
type system accepts exactly programs safety analysis 
may seen natural culmination previous results 
examples example language calculus generated grammar succ programs yield run time error include succ succ function succ applied functions succ function 
programs typable rejected safety analysis 
programs typed type system example xx ff ff ff means type 
programs require example fi note type fi programs require example succ 
type inference safety analysis phrased solving system constraints derived program text 
constraint systems examples 
notational convenience give occurrences label term reads succ 
brevity succ 
constraint system type inference looks follows succ succ succ int succ int symbols succ succ type variables 
solving constraint system yields possible types term succ 
type 
type 
general constraint system need solution 
constraint system safety analysis looks follows feg feg feg succ feg succ succ fintg succ fintg constraint system solvable solution 
particular constraint system solvable solution mapping feg succ fintg succ sections type system safety analysis section prove accept programs 
type system types definition sigma int ranked alphabet binary int nullary 
type regular tree sigma 
path root tree string indicates left subtree indicates right subtree 
definition represent type term partial function sigma domain maps path root type symbol path 
set terms denoted sigma finitely represent term called term automaton follows 
definition term automaton sigma tuple sigma ffi ffl finite set states ffl start state ffl ffi theta partial function called transition function ffl sigma total labeling function state fi ffi fint fi ffi partial function ffi extends naturally partial function ffi theta inductively follows ffi ffl ffi ffi ffi ffi ff 
term represented term ff ffi ff intuitively ff determined starting start state scanning input ff transitions far possible 
possible scan ff transition way exist ff undefined 
hand scans entire input ff ends state ff 
types ordered subtype relation follows 
definition parity ff number mod ff 
parity ff denoted ff 
string ff said ff odd ff 
partial order sigma int int reverse int int sigma define ff ff ff ff 
kozen palsberg schwartzbach showed relation equivalent order defined amadio cardelli :10.1.1.33.8725:10.1.1.33.8725
relation partial order 
type rules term type type environment partial function assigning types variables judgement means type environment formally holds judgement derivable rules int int succ int provided ef rules usual rules simple types rule rule subsumption 
type system subject reduction property derivable fi reduces derivable 
proved straightforward induction structure derivation constraints term type inference problem rephrased terms solving system type constraints 
assume ff converted bound variables distinct 
xe set variables occurring ye set variables disjoint xe consisting variable occurrence subterm 
notation ambiguous may occurrence clear context occurrence meant 
generate system inequalities xe ye ffl occurrence subterm form inequality int ffl occurrence subterm form succ inequalities int succ int ffl occurrence subterm form inequality ffl occurrence subterm form gh inequality gh gh ffl occurrence variable inequality subscripts ease notation section semantic impact explicitly written section 
denote system constraints generated fashion 
solutions sigma correspond possible type annotations sense precise theorem 
type environment assigning type variable occurring freely function assigning type variable xe ye say extends agree domain theorem judgement derivable exists solution extending particular closed typable type exists solution proof 
similar proof theorem journal version outline follows 
solution constraint system straightforward construct derivation conversely observe derivable exists derivation ordinary rules followed exactly subsumption rule 
approach example gives set inequalities desired form :10.1.1.44.6387
safety analysis flow analysis basis safety analysis 
term assume ff converted bound variables distinct 
set abs set subterms form set cl powerset abs fintg 
safety analysis term phrased solving system constraints xe ye type variables range cl 
ffl occurrence subterm form constraint fintg ffl occurrence subterm form succ constraints fintg succ fintg provides safety check ffl occurrence subterm form constraint fx fg ffl occurrence subterm form gh constraint abs gh provides safety check ffl occurrence variable constraint ffl occurrence subterm form occurrence subterm form gh constraints fx fg fx fg gh subscripts ease notation section semantic impact explicitly written section 
denote system constraints generated fashion 
solution assigns element cl type variable constraints satisfied 
solutions ordered variable wise set inclusion 
see cubic time algorithm computes solution decides exists 
see proof subject reduction property 
fi reduces solution solution 
equivalence deductive closures introduce auxiliary constraint systems called 
may thought deductive closures 
show isomorphic theorem 
definition term define smallest set ffl non conditional constraints members 
ffl constraint 
ffl xe ye 
notice constraint form forms fintg fx fg forms fintg abs gh xe ye definition term define smallest set ffl 
ffl gh 
ffl xe ye 
notice constraint form forms int form int gh xe ye definition functions 
definition prove defined inverses 
definition functions defined follows 
lj lj functions lj xe ye int fintg fx fg gh gh abs gh lj xe ye fintg int fx fg abs gh gh gh theorem sets isomorphic bijections inverses 
proof 
defined clearly inverses bijections isomorphic 
show defined 
proceed induction construction 
base case consider non conditional constraints observe fintg int fintg succ int succ fintg int fx fg abs gh gh gh follows lemma holds base case 
induction step consider constraints fx fg fx fg gh suppose fx fg 
induction hypothesis 
gh gh 
gh gh gh 
consider suppose xe ye induction hypothesis 
xe ye get 
show defined 
proceed induction construction 
base case consider constraints 
table observe defined constraints 
induction step consider gh gh 
sufficient prove lj lj lj lj gh equivalently gh 
fx fg fx fg gh fx fg 
gh 
consider suppose xe ye induction hypothesis lj lj lj lj 
xe ye get lj lj lj 
equivalence proof definition term set total functions xe ye sigma cmap set total functions xe ye cl 
construction key mapping flow information types 
definition term cmap cl define term automaton follows cl sigma ffi ffl ffi fx ffl ffi fx ffl int fintg abs lemma suppose cmap cl 
proof 
define orderings cl equals equals 
desired follows immediately property ff ffi ff ff ffi ff 
property proved straightforward induction length ff 
prove type system safety analysis accept programs 
theorem term conditions equivalent 
solvable 

solvable 

solvable 

solvable 

contain constraints forms fintg abs fx fg fintg 

contain constraints forms int int xe ye 
function constraint fkg solution 
proof 
term notice isomorphism theorem 
show remaining equivalences proceed proving implications prove suppose solution cmap 
function define ffi 
show solution 
consider constraints turn 
cases constraints generated subterms forms succ immediate lemma 
consider constraint 
lemma get fx fg consider gh constraint gh 
know abs cases 
suppose 
gh 
consider case fx 
gh ng 
gh 
lemma gh gh prove suppose solution 
sufficient show solution proved straightforward induction construction 
prove suppose solution 
define cmap follows ffl fintg ffl int abs ffl abs fintg ffl show solution 
see constraint 
forms fintg fintg fx fg abs solvable functions including 
remaining cases notice theorem solution 
means forms fintg abs fx fg fintg 
suppose remaining forms fintg fintg fx fg abs xe ye treat just similar 
constraint form fintg follows int 
solution get ffl fint fintg abs fintg fintg solution 
prove observe constraints forms fintg abs fx fg fintg solvable 
prove suppose contain constraints forms fintg abs fx fg fintg 
define constraint fkg proceed steps follows 
ffl show solution 
consider turn possible forms constraints 
constraints forms fintg fintg fx fg abs solution including left constraints forms fintg fintg fx fg abs xe ye treat just case similar case case similar case 
constraint form fintg notice int constraint solution constraint form suppose 
constraint fkg constraint fkg 
follows 
constraint form fintg suppose solution exist int 
follows constraint fkg constraint fkg fintg contradiction 
ffl show solution 
solution suppose xe ye sufficient prove 
suppose 
constraint fkg 
solution 
ffl show solution 
consider constraints 
constraints members solution consider fx fg suppose fx fg solution definition fx fg solution ffl show solution 
solution 
solution proved straightforward induction construction 
solution smaller 
prove simply notice solution solvable 
corollary type system accepts programs safety analysis 
algorithms corollaries theorem get cubic time algorithms 
term observe computed time size easily answer questions ffl question safety accepted safety analysis 
algorithm check contain constraint forms fintg abs fx fg fintg 
ffl question type inference typable 
annotation 
algorithm safety checking algorithm 
turns typable get annotation calculating functions constraint fkg forming composition ffi function solution 
question type inference open 
contrast wellknown flow analysis style discussed computed time 
authors mitchell wand encouragement helpful discussions 
results obtained author northeastern university boston currently hosted brics basic research computer science centre danish national research foundation 
roberto amadio luca cardelli :10.1.1.33.8725
subtyping recursive types 
acm transactions programming languages systems 
proc 
popl 
torben 
minimal 
proc 
wsa pages 
andrew appel 
compiling continuations 
cambridge university press 
anders bondorf 
automatic higher order recursive equations 
science computer programming december 
charles consel 
tour partial evaluation system higherorder applicative languages 
proc 
pepm second acm sigplan symposium partial evaluation semantics program manipulation pages 
dexter kozen jens palsberg michael schwartzbach 
efficient recursive subtyping 
mathematical structures computer science 
appear 
proc 
popl twentieth annual sigplan sigact symposium principles programming languages pages charleston south carolina january 
dexter kozen jens palsberg michael schwartzbach 
efficient inference partial types 
journal computer system sciences 
proc 
focs rd ieee symposium foundations computer science pages pittsburgh pennsylvania october 
min kuo mishra 
strictness analysis new perspective type inference 
proc 
conference functional programming languages computer architecture pages 
jens palsberg 
closure analysis constraint form 
acm transactions programming languages systems 
appear 
proc 
caap colloquium trees algebra programming springer verlag lncs pages edinburgh scotland april 
jens palsberg michael schwartzbach 
safety analysis versus type inference 
information computation 
appear 
jens palsberg michael schwartzbach 
safety analysis versus type inference partial types 
information processing letters 
jens palsberg michael schwartzbach 
object oriented type systems 
john wiley sons 
olin shivers 
data flow analysis type recovery scheme 
peter lee editor topics advanced language implementation pages 
mit press 
mitchell wand 
type inference record concatenation multiple inheritance 
information computation 

