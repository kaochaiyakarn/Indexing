multi agent systems development software engineering enterprise marco giorgio maurizio martelli universit di genova genova italy martelli disi unige max planck institut fur informatik im stadtwald saarbrucken mpi sb mpg de 
multi agent systems provide ideal level abstraction modelling complex applications distributed heterogeneous entities need cooperate achieve common goal concur control shared resources 
proposes declarative framework developing multi agent systems 
formal approach logic programming proposed specification implementation testing software prototypes 
specification prs agent architecture example application framework 
declarative languages functional logical languages academic world 
imperative paradigms development industrial software usually motivated reasons efficiency 
reusable declarative knowledge modular flexible imperative knowledge 
better semantics detecting correcting contradictory knowledge easier provides abstraction real world natural way 
setting meta programming techniques provides support integration different kinds knowledge 
features declarative paradigm solution suitable developing verifying prototypes complex applications set autonomous intelligent distributed entities cooperate coordinate exchange integration knowledge 
agent oriented technology faces problem modelling kinds applications 
suitable modelling entities communicate social ability monitor environment react events occur ity able take initiative situation requires proactivity human beings agents intervening autonomy 
societies entities called multi agent systems mas 
take account distribution involved agents integration heterogeneous software data 
issues fundamental success software systems reasons consensus mas obtained academia industry 
combination declarative agent oriented approaches studied years promising theoretical practical point view see 
unfortunately time evidence established engineering approach building mas applications 
due inherent complexity experimentation direction important 
presents features experimental logic programming prototyping environment mas 
particular methodology combines traditional software engineering approaches considerations agent oriented field 
approach exploits logic declarative languages specification implementation testing prototype 
methodology formal specification mas linear logic programming language hhf provides constructs concurrency state updating 
extension logic programming language eclipse agent oriented constructs build software prototype closer final implementation mas 
declarative nature hhf guides translation turn number programming features making resulting prototype efficient easier integrate technologies 
framework consider possibility building prototypes encompassing agents different architectures 
designer choose predefined architecture library part environment develop new 
case relevant data agent provided user 
example application steps methodology specification known planning reasoning system prs agent architecture 
structured follows section presents development framework focusing prototype developing methodology 
section describes prs architecture hhf model architecture part methodology described section 
section compares frameworks specification development mas concludes considerations research 
framework mas development development agent software seen traditional software engineering enterprise 
specification suitable specification formalism refined executable piece software 
assure correctness refinement process final concrete system verified respect initial specification 
formal methods play important role development phase agent systems high level developing complex cooperating systems 
generally accepted taxonomy classifying agent applications clear approaches appropriate specifying different classes agent systems methods exploited transform specifications final software product 
years approaches logical languages temporal logic proposed specification formalisms agent technology 
logic programming languages contribute research provide easy define executable specifications 
propose framework realization mas prototypes specification implementation carried declarative logical languages 
prototype realization complex application specification environment logic programming mas framework prototyping applications involving heterogeneous distributed entities 
precisely framework includes methodology guides application developer easy rapid definition prototype iteration sequence simple steps 
provides set tools achieve aim step methodology 
particular tools specification mas tools describing behaviour agents system means simple rule logical language tools integration legacy systems data simulation tools animating mas execution provided 
agent logical agent shows capabilities complex reasoning interface agent provides interface external modules agents system 
final prototype built combining existing software tools new components 
approach integration reuse issues highly relevant success new technologies 
agents share main components updatable set facts defining state agent fixed set rules defining behaviour agent mail box incoming messages events interpreter accessing external software interface agents 
language high level mas specification hhf interesting capabilities modelling concurrent resource sensitive systems see section 
language defining agent implementation prolog language enriched primitives safe updates agent state assert state act retract state act communication agents mas send message receiver receive message sync receive message sender 
message follows syntax kqml chosen agent communication language 
update primitives operate way agent fails activities safe state automatically restored 
primitive async receive message inspects agent mail box retrieves message contained mail box 
kind reception blocking 
hand sync receive message sender blocking reception primitive 
agent waits message coming agent sender enters mailbox 
provides appropriate primitives loading agents system associating appropriate interpreter interface agents 
creates mas ready simulation performed means round robin scheduler interleaving activation agents 
simulation produces line line information agents state changes messages exchanged 
visualizer provides gui loading initializing tracing agents execution graphical manner 
prototyping methodology 
realization mas software prototype performed steps 
static architectural description prototype 
developer decides static structure mas 
step broken determining classes agents application needs determining set requested services set provided services class determining set necessary instances class defining interconnections instances agents matching appropriately requested provided services 
phase defines components able require communication channels needed manage services 

description component interactions 
step specifies service provided requested means particular conversation set kqml messages specific order pair connected agents 
conversation performed different communication models synchronous asynchronous message passing 

architectural choice agent 
logical agent structured particular agent architecture reactive proactive agents may needed 
step allows developer decide appropriate internal architecture agent system 
example decides predefined architecture prs guiding example choose build specification 
obviously case steps involved writing specification easier dealing modelling internal mechanisms agents needed 

high level specification system 
step linear logic programming comes play hhf build executable specification system 
due peculiar properties hhf allows easy concurrency agents updates agents states 
identify different levels specification interactions agents external concurrency abstracting architecture account interaction model specified step specification new architectures chosen step interactions internal components agents internal concurrency specification agents behaviour operate provide services 
important point process listed steps may repeated testing phase step reveals flaws initial choices developer decides refine specification 
example stage specification listed defined 

testing system 
phase concerns testing system order verify closely prototype corresponds desired requirements 
logical language hhf phase numerous advantages hhf interpreter possible evaluate goal step step evolution particular system detail 
possible verify particular computation may carried important computation starting configuration leads final state satisfies property 
possible employ standard techniques prove properties programs logic programming context 
part authors 

implementation prototype 
point development process hopefully correct specification final application 
step transforms hhf specification prototype closer final implementation interfaces external software data message passing communication 
furthermore performance standardization reasons suggest efficient widespread logical languages hhf actual implementation mas prototypes 
step specifications translated executable code 
corresponds various implementations message exchange 
translated suitable data structures obtaining different architecture parts meta program implements control flow architecture 
architecture dependent rules defining translated rules 
framework allows user join agents form prototype unique executable specification system tested 
obviously cases translated existing solutions chosen 

execution obtained prototype 
step tests implementation choices checking system behaves expected 
error discovered step may imply revision choices previous steps 
practical application 
adopted order develop applications different areas 
applications related transportation logistic problems 
particular developed collaboration fs italian railway solve train scheduling problems la milano route developed bailey international provides service automation plan transportation goods 
application concerned retrieval medical information contained distributed databases 
case successfully adopted reverse engineering process 
combination agent oriented constraint logic programming techniques faced solve transaction management problem distributed database 
prs architecture specification implementation architecture agent certainly difficult phases development methodology 
furnish library agent architectures application developer pick desired model 
section steps methodology applied implement prs architecture 
procedural reasoning system prs obtained broad consensus researchers multi agent systems field 
model practical reasoning underpins prs bdi beliefs desires intentions operationalized prs agents notion plans 
agent plan library set plans represents agent procedural knowledge 
plan consists trigger invocation condition specifies circumstances plan considered context precondition specifying circumstances execution plan may commence maintenance condition characterizes circumstances remain true plan executing body defining potentially complex course actions may consist goals primitive actions 
agent interpreter outlined cycle observe world agent internal state update event queue consequently generate possible new desires tasks finding plans trigger event matches event event queue select set matching plans execution push selected plan existing new intention stack event sub goal select intention stack take topmost plan execute step current plan step action perform subgoal post event queue 
basis specification dmars implementation prs specification language show architecture modelled hhf 
briefly introduce basic features linear logic programming 
executable specifications linear logic language hhf executable language modelling concurrent resource sensitive systems general purpose logical specification language forum 
hhf multiset logic combining features extensions logic programming languages prolog goals implication universal quantification notion formulas resources note triggered plan start execution context satisfied basis linear logic 
informally describe operational semantics hhf programs 
specifically hhf programs collection multi clauses form 
ffi gamma goal atomic formulas linear disjunction 
corresponds head clause 
furthermore ffi gamma gammaffi linear implication 
main peculiarity clauses consume resources formulas need order applied resolution step 
formally multiset atomic formulas state computation omega resolution step omega omega performed applying instance 
ffi gamma clause program multiset theta consisting atoms contained omega omega obtained removing theta omega adding resulting multiset 
interpreter instantiation replaced unification 
point may complex formula search rules logical rules connectives occurring exhaustively applied order proceed 
derivation corresponds branch proof tree multiset omega model evolution prs agent omega represents current global state beliefs intentions event queue describes possible plans triggered point computation 
hhf provides way guard application clause 
extended type clauses gm 
ffi gamma goal goal formulas solved executed order clause triggered 
new components added current state form 
fact goal 
delta simply reduces delta 
conditions current state tested goal formulas form fact goal delta reduces delta delta 
copies state consumed verify contextual condition 
universal quantification goal formula create new identifier local derivation tree subgoal 
constant succeeds context constant simply removed current goal 
description observe evolution agent backward analysis detect violations requirements specifications 
llp specification prs agent section explain detail specify salient aspects prs architecture hhf beliefs goals actions plans 
beliefs modelled ground facts form belief fact 
set beliefs maintained current state omega goals terms form achieve fact query fact 
achieve goal commits agent sequence actions execution goal true 
query goal implies test agent beliefs know goal true 
internal actions represented terms assert fact retract fact update agent beliefs 
external actions sending messages denoted generic terms 
plans basically consist sequences actions sub goals 
represented facts form plan trigger context body maintenance trigger trigger linked particular event context condition true start plan body sequence actions sub goals bn maintenance condition true plan executed sequence actions executed plan succeeds 
plan library agent described collection facts 
contrary take consideration failure actions aim generally rollback safe state case plan fails 
obtained effort lp setting exploiting backtracking 
triggers events 
triggers raised events aim activate plans 
distinguish external triggers force agent adopt new intention internal triggers cause agent add new plan existing intention 
external triggers fact fact linked respectively events denoting acquisition removal belief goal denoting acquisition new goal 
internal trigger subgoal denoting sub goal call executing plan 
events terms form event trig id trig assume forms id possibly undefined identifier plan instance causing event 
event queues 
event queue associated prs agent 
contains external internal events represented term form event queue en en events 
events linked external triggers inserted event queue events linked internal triggers inserted top 
events taken top event queue policy gives priority events generated attempt achieve sub goal 
plan instances 
plan instances represent plans execute 
new plan instance created inserted intention stack soon trigger activated context satisfiable 
plan instance contains instantiated copy original plan derives information plan active suspended 
differently shared variables unification inherit knowledge original plan 
unique identifier associated plan instance 
plan instances form plan inst id body maintenance active 
intention stacks 
intention stack contains currently active plan set suspended plans 
internal trigger subgoal generate new plan instance pushed intention stack plan containing sub goal execution activated trigger 
external trigger produces new plan instance stored new intention stack 
representation intention stack term form int stack pn pn plan instances 
internal behaviour prs agent described means hhf rules listed 
sake example explicitly give rules perception rules simulating interactions external world 
idea start simulation agent initial queue events initial intention stack 
execution perception rules build appropriate events information produced perception devices example environment sensors inter agent communication devices non deterministically post agent event queue 
rules listed consider program containing plan library information distinguish external internal triggers actions form external external action plan triggering 
plan triggering rules handle creation new plan instances intention stacks raised trigger 
external trigger handled new intention stack created new plan instance pushed 
formalized rule plan sa external event queue event jl ffi gamma verify id int stack plan inst id act sa 
event queue conditions plan external fulfilled unified facts goal formula verify id allows test contextual condition copy current state sake brevity verify specified 
new identifiers plan instances created universal quantification 
note modification event queue defined consuming current head clause creating new copy body 
similar clause formalizes trigger internal 
main difference intention stack top plan identifier event event queue consumed 
verifying context intention stack rewritten adding new instance plan trigger matches trigger topmost event event queue 
plan execution 
plan executed event queue agent empty 
intention stack top plan instance active non deterministically chosen action plan instance executed maintenance condition verified 
developed rules possible plan component external internal actions query goals achieve goals 
sake brevity report significant 
case external action executed rule applied external event queue 
int stack plan inst id act sa jl ffi gamma verify event queue 
execute 
int stack plan inst id act sa jl call execute activates agent output devices example effectors environment inter agent communication sending message agent 
case internal actions rules applied top component plan assert action corresponding belief added database event queue 
int stack plan inst id assert act sa jl ffi gamma verify believed belief 
event queue event id 
int stack plan inst id active sa jl similarly top component plan retract action corresponding belief removed consuming 
plan component achieve goal corresponding belief database agent proceed event queue 
belief 
int stack plan inst id achieve act sa jl ffi gamma verify event queue 
belief 
int stack plan inst id act sa jl previous rule applied current plan suspended new event containing subgoal trigger current plan created event queue 
int stack plan inst id achieve act sa jl ffi gamma verify believed event queue event subgoal id 
int stack plan inst id susp jl plan component query goal belief agent query succeeds rule similar achieve rule plan instance top intention stack query achieve 
plan termination resuming 
plan completed successfully sequence internal actions executed 
furthermore previously suspended plan may necessary 
rules capture execution event queue 
int stack plan inst id act assert sa jl ffi gamma believed event queue 
belief 
int stack plan inst id act sa jl event queue 
belief 
int stack plan inst id act retract sa jl ffi gamma event queue 
int stack plan inst id act sa jl execution completed plan instance popped away intention stack suspended lower plan instance awakened event queue 
int stack plan inst plan inst id susp sa jl ffi gamma event queue 
int stack plan inst id act sa jl intention stack empty removed rule int stack ffi gamma mentioned specification directly executed logic programming language setting initial set events intentions 
step methodology refine specification order get closer real implementation 
lp prototyping prs agent refinement hhf specification concrete prototype aims mainly realization software product established technology modules written different languages integrated 
consider possibility building prototypes encompassing agents different architectures aim providing environment library meta interpreters reproduces particular kind management agent behaviour 
abstractly specified hhf meta interpreters automatically translated concrete language 
step library interpreter prs architecture directly derived previously defined hhf specification 
interpreter prs architecture 
mapping hhf specification prs agent require great effort 
fact hhf data structure previously defined finds direct mapping terms 
furthermore representation beliefs intentions stored agent state event queue corresponds agent mail box plans memorized agent behaviour facts 
note hhf clauses specifying prs interpreter assume general form gm 
ffi gamma gm gm 
formulas gm atomic 
order translate multi guarded clause form introduce auxiliary predicate pc defined pc retract state retract state gm assert state assert state retract state assert state state update predicates previously described 
execution retract state retract state consumes atomic formulas proof gm tests clause guard condition current state execution assert state assert state adds new information state 
applying transformation hhf clause obtain corresponding set clauses 
set partitioned grouping clauses regarding main activities performed prs agent perception plan triggering plan execution action execution 
top level behaviour simple version prs interpreter rule starts main activities priority reflects order body clause 
prs interpreter perception plan triggering plan execution action execution obviously sophisticated strategies implemented execution activities may take additional information account 
activity defined clauses belonging corresponding activity group example plan triggering pc pcs pc pcs clauses plan triggering group 
complete code prs interpreter give part rules handling internal triggers external actions 
rule handling internal trigger belonging definition plan triggering rules external triggers plan triggering retract state mail box event id jl retract state int stack plan instance id act sa jl plan sa internal verify get new id id assert state mail box assert state int stack plan instance id act sa plan instance id act sa jl clause call pc substituted definition goal get new id id creates new identifier 
execute plan step involving external action interpreter uses rule plan execution retract state int stack plan instance id maint active sa jl retract state mail box external verify maint assert state int stack plan instance id body maint active sa jl assert state mail box assert state execute rule executing external action action execution retract state execute send message receiver send message receiver verification goal send message receiver side effect performing message send 
note allowed external actions concern sending messages specialized rule 
prs interpreter started agent awakened system scheduler 
achieved calling hook predicate activate defined activate prs interpreter prs agent executed main activities control returns system scheduler agent activated 
translation hhf specification concrete logical language refined efficient exploiting advanced features eclipse system 
comparison described tool adopts software engineering techniques develop multi agent system prototypes 
logic prototype specification implementation language 
compare general purpose tools mas development testing 
mix conceived distributed framework cooperation multiple heterogeneous agents 
basic components agents network interact 
yellow page agent offers facilities receiving information dynamic changes network environment 
open agent architecture oaa provides software services cooperative efforts distributed collections autonomous agents 
different categories agents recognized framework 
facilitator server agent responsible coordinating agent communications cooperative problem solving 
application agents specialists provide collection services eventually legacy applications 
meta agents help facilitator agent multi agent coordination phase user interface agent provides interface user 
zeus advanced development tool kit constructing collaborative agent applications 
defines multi agent system design methodology supports methodology environment capturing user specification agents automatically generates executable source code userdefined agents 
zeus agent composed definition layer organization layer coordination layer 
zeus provides predefined yellow white pages agents 
zeus appears similar 
proposed methodology set questions answers mas developer uses define agent terms role services provides relationships agents 
formalized aim methodology 
feature characterizes approaches presence predefined agent helps discover agent provides services yellow white pages zeus yellow pages mix facilitator oaa 
difficult provide agent moment user implement necessary 
integration legacy software dealt mix oaa zeus adopting wrapping approach existing software 
contrary adopts interpretation approach 
example specification mas architecture possible realization prs 
think approach followed prs specification may advantages ones literature 
specification prs specification language set theory order logic notions state space transformations states 
think linear logic may natural candidate specification systems notion state transformations resources involved 
main advantage hhf respect directly executable 
supports specification different levels abstraction higher order extensions firstorder greatly facilitate meta programming 
formal specification prs 
particular temporal logic language concurrent metatem supports specification concurrent distributed entities 
goals beliefs plans represented means formulas temporal logic execution committed run time execution algorithm 
verification specifications direct moment small fast interpreter concurrent metatem available 
contrary language propose linear extension classical logic languages prolog 
execution mechanism goal directed clause resolution unification usual logic programming 
hhf concurrent metatem easily supports broadcast message passing simulate meta level activity means higher order features 
experimental interpreter hhf developed authors see ftp ftp disi unige pub person 
development efficient interpreter language part 
furthermore plan investigate possibility extending standard logic programming techniques software verification validation linear logic context 
worth considering symbolic model checking possibly techniques partial evaluation interpretation 
far concerned plan extend system allowing real distribution agents network prototypes closer final implementation 
described intend integrate different research experiences logic programming including common joint project lead development general open framework agent rapid prototyping environment global information organization specification rapid prototyping engineering agent software 
framework include integration multiple data sources reasoning systems carried department computer science university maryland usa done animation specifications department computer science university melbourne australia 
dart martelli sterling subrahmanian 
combining logical agents rapid prototyping engineering distributed applications 
submitted fase 


logic object oriented programming linear logic 
phd thesis universit di pisa dipartimento di informatica 

inverno fisher luck de rijke ryan wooldridge 
formalisms multi agent systems 
knowledge engineering review 

inverno kinny luck wooldridge 
formal specification dmars 
intelligent agents iv 
springer verlag 
lnai 

fisher mueller schroeder staniford wagner 
methodological foundations agent systems 
knowledge engineering review 

georgeff lansky 
reactive reasoning planning 
proc 
sixth national conference artificial intelligence aaai seattle wa 

gonz 
mix general purpose multiagent architecture 
intelligent agents ii 
springer verlag 
lnai 

sadri 
unified agent architecture combines rationality reactivity 
proc 
international workshop logic databases san italy 
springer verlag 

lesperance levesque lin marcu reiter scherl 
foundations logical approach agent programming 
intelligent agents ii 
springer verlag 
lnai 

locke sterling sonenberg kim 
aris shell information agents exploit web site structure 
proc 
paam london uk 

martelli 
multi agent software prototyping 
proc 
paam london uk 

martin cheyer moran 
building distributed software systems open agent architecture 
proc 
paam london uk 

mayfield labrou finin 
evaluation kqml agent communication language 
intelligent agents ii 
springer verlag 
lnai 

miller 
forum multiple specification logic 
theoretical computer science 

mulder treur fisher 
agent modelling metatem desire 
intelligent agents iv 
springer verlag 
lnai 

ndumu nwana 
research development challenges agentbased systems 
iee proc 
software engineering 

nwana ndumu lee 
zeus advanced tool kit engineering distributed multi agent systems 
proc 
paam london uk 

rao georgeff 
bdi agents theory practice 
proc 
icmas san francisco ca 

spivey 
notation second edition 
prentice hall international 

wooldridge 
agent software engineering 
iee proc 
software engineering 

wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 
