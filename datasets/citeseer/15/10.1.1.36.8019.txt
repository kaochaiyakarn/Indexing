proof normalization linear logic didier galmiche guy perrier cnrs inria lorraine campus scientifique les nancy cedex france mail loria fr proof theoretic foundation automated deduction linear logic 
systematically study permutability properties inference rules logical framework exploit introduce appropriate notion forward backward movement inference proof 
discuss naturally arising question redundancy reduction investigate possibilities proof normalization depend proof search strategy fragment consider 
define concept normal proof basis works automatic proof construction design logic programming languages linear logic 
linear logic powerful expressive logic connections variety topics computer science 
mainly interested significance may different domains logic programming program synthesis theorem proving 
matter fact classical linear logic denoted cll logic actions introducing notions controlled strict resource management 
disallows weakening contraction general introduced local modalities conserves constructive character deep symmetry 
linear logic appropriate framework study logic programming better intuitionistic classical logic concurrent aspects logic programming petri nets reachability 
main point resource sensitive aspect logic example functional programming 
previous works considered synthesis correct programs theorem proving approach constructive logics extraction programs proofs 
intuitionistic logics limits due non symmetrical character logics 
try consider approach linear logic appropriate calculus logical language 
fact point understand proof proof net fragments linear logic able construct proofs linear logic formulas 
theorem prover linear logic step effective applications cll development proofs logic programming 
efficiency reasons construction linear logic prover imposes course restrictions adequate fragment cll 
works devoted important topic 
starting fragment linear accepted publication theoretical computer science vol 
december horn clauses try extend various ways 
difficulty extend expressiveness language keep time efficiency initial kernel 
concerning efficiency criteria noticed works common point necessity normalize possible proofs fragments properties inference permutability 
aiming extend logic programming chosen approach consists starting full linear logic searching equivalence proofs order normalize central notions invertibility focusing 
study proof search strategies cll bottom direction notions top direction specific resolution method 
central point permutability properties appears approaches 
classical concept works conception efficient proof search methods non classical logics 
approach begins study inference permutability possibilities full linear logic aiming efficient proof construction mechanization 
attempt direction developed focused additive multiplicative fragment cll proposed algorithm automated deduction fragment 
completely refine permutability notion extend approach full linear logic 
having systematically studied inference permutability properties define specific movements inference proof analyze redundancy reduction proof 
able propose new proof forms called normal proofs define complete tractable proof subclasses discuss interest proof construction 
compared approaches bottom top theorem proving mainly focus logical bases complete study inference justify choices fragments cll adequate applications logic programming 
point position study seriously linear logic framework automated deduction logic programming programming proofs approach 
section linear logic framework language inference system recall basic definitions 
section shows complete study permutability properties inferences section deal notion movement inference proof 
section presents reduce redundancies proof appropriate reduction cut elimination 
section defines notion normal proof mechanization proof construction cll adapted 
section emphasize importance approach designing logic programming languages adequate fragments linear logic 
section discuss connections related works different fragments cll conclude usefulness results application embedding linear logic proofs development 
linear logic classical linear logic cll introduced girard logic actions 
born semantics second order lambda calculus linear logic expressive traditional logics classical intuitionistic ones 
compared classical logic structural rules weakening contraction dropped gentzen type rules obtain system resource hypothesis exactly 
conjunction disjunction allow resource sharing split multiplicative version omega disallowing resource sharing additive version phi requiring resource sharing 
restore power classical logic modal operators introduced knowing allows unlimited consumption allows unlimited logical constants true false split constants involutive negation denoted introduced 
characterized absence structural rules specific treatment negation cll proofs considered actions introduces dynamical resource management proofs directional character distinction input output 
refer reader broad explanation purpose meaning linear logic 
language language consists set finite terms term countable set variables countable set atoms having arity 
allows construct set atom atomic formulas arity atom term atomic formula set logical operators op omega phi 
allows construct set form formulas formulas cll grammar jf omega jff jf jf phi xf xf atom manipulate sequents left hand sides notation conventions variables referred letters terms term letters atoms letters atomic formulas atom letters formulas form letters multisets formulas form letters gamma delta 
letters possibly indexed integers 
linear sequent calculus inference system classical linear sequent calculus 
recall sequent finite multiset formulas form 
implicitly take account exchange rule consider commutative linear logic 
inference rules linear sequent calculus 
identity group ax gamma delta gamma delta cut structural group delta delta 
delta delta 
logical group ffi multiplicative rules gamma gamma omega gamma gamma omega gamma gamma gamma gamma ffi additive rules gamma gamma gamma gamma phi gamma phi gamma phi gamma phi delta ffi exponential rules gamma gamma gamma gamma ffi quantifiers rules gamma xf gamma gamma xf gamma rule free gamma different rule constant linear negation essential symmetrical character cll defined equalities omega omega 
phi phi 
xf xf xf xf 
consider full linear logic equivalent sequents lefthand side part system called cll left hand side part system called cll 
due property linear negation allows move formula side sequent changing negation 
chosen cll simplification purposes applications logic programming cll presents advantages example restricted difficulty fragment linear logic negation 
matter fact translation results cll cll easily performed 
derivations cll proceeding study necessary fix vocabulary relatively notion derivation proof cll 
recall inference instance rule system defined type inference name corresponding rule denoted type derivation necessary follow evolution formulas time introduced called principal time disappearing subformulas called active 
take account evolution necessary mark derivations 
give definitions 
principal active formulas contexts definition principal formula inference type formula exist premises 
type 
principal formula result contraction formulas premise 
definition principal part inference denoted delta delta multiset principal formulas 
example inference delta fa inference delta delta delta delta delta 
definition active formula inference type formula premise exist 
type active formulas ones contracted formula 
definition active part th premise inference denoted delta multiset active formulas 
example considering gamma fg gamma delta ff gg 
gamma gamma delta 
considering inference gamma gamma gamma gamma omega delta ffg delta fgg 
definition context inference premise complement active part 
classify inference rules categories ones depending context premises type 
due fact application rules possible conditions premise contexts 
contexts premises identical context premise form delta variable associated inference free premise context 
marked derivations proofs classical representation binary trees labelled sequents defining notions derivation deduction proof 
recall definitions 
definition hypothesis derivation sequent labelling leaves 
ii intermediate sequent hypothesis labelling leave 
iii derivation sequent labelling root tree 
iv proof cll derivation hypotheses 
sequent delta provable exists proof delta 
appears important able follow evolution formula proof consider marking inferences 
definition marked inference inference function premises allows identify formulas premises formulas sub formulas 
marked proof proof inference marked 
illustrate notion example example case phi obtain different marked proofs phi phi general choice neutral inference properties want study 
rest explicit consider marked proofs 
definition formula intermediate proof pi cll inference pi say introduced principal formula definition formula intermediate proof pi cll inference pi say active formula formula introduced inferences 
example consider cll proof phi phi phi phi phi formula phi introduced inferences type phi type phi presentation logical framework consider focus important notion permutability inferences proof 
inference permutability take point conceptual departure notion inference permutability full linear logic 
basic notion appears important efficient proof search theorem proving non classical logics 
want systematically study possibilities obtain proof cll proofs simple permutation inferences consecutive proof tree 
example take proof inference type immediately precedes inference type phi consider proof pi pi ae delta pi ae delta delta phi delta phi form easily deduce proof pi pi ae delta phi delta phi pi ae delta phi delta phi phi delta illustrates permutation inference type inference type phi possible direction 
counter example shows possible direction 
consider proof id id omega omega omega phi omega phi id id omega omega omega phi omega phi omega phi omega clear inferences type phi 
interesting see happens pair inference types analyze consequences permutability opportunities 
inferences consecutive proof relevant consider permutations 
example principal formula inference active second inference order changed 
appropriate definition definition consider proof pi cll say inferences pi permutation position verify conditions ff follows directly pi denoted pi fi principal part disjoint active part th premise appears delta delta 
intuitively notion permutability easy understand 
means possibility invert inferences proof disturbing rest proof parts inferences 
previous deduction additive multiplicative fragment cll called perfect permutability pp 
inference type difficulty duplication inference due duplication context 
translated variant notion quasi permutability qp 
definitions rough refined embedded general definition 
definition consider proof pi cll inferences pi permutation position permutable pi exists inferences type type type type ii coincides premise iii type inference immediately preceding pi type type 
iv type exists inference type type coincides second premise 
consider derivation called permutation object composed type followed derivation called permutation result composed type followed hypotheses modulo duplication renaming certain free variables 
cases say permutable illustrate definition example counter example section 
example consider previous proof named pi delta delta delta delta phi delta phi permutation position conditions ff fi definition satisfied delta fg delta ffg disjoint 
consider phi delta phi delta phi delta delta phi delta phi conditions ii iii definition satisfied 
type exists delta phi delta phi verifies condition iv 
condition easily satisfied permutable example consider previous proof denoted pi omega omega phi omega phi omega phi omega omega phi omega omega phi omega permutation position conditions ff fi definition verified delta omega phi omega delta fa disjoint 
condition iii verified permutable definition proof pi obtained permutation pi obtained replacing permutation object relatively permutation result modulo renaming free variables duplication tree permutation object operation permutation inferences proof implies involutive character equivalence relation proofs 
definition pi pi proofs cll pi equivalent pi modulo inference permutation denoted pi pi exists inferences pi pi obtained permutation pi 
definition pi pi proofs cll pi equivalent pi modulo inference order denoted pi pi exists finite sequence pi pi proofs cll pi pi pi pi ii gamma pi pi theorem relation equivalence relation systematically study permutability properties inferences proof types 
types phi phi properties gather denoted phi 
theorem permutability theorem types inference array case array contains inferences type permutation position proof pi permutable 
ii case contains np exists inferences type permutation position proof pi permutable 
iii case contains cross theta inferences type proof pi permutation position nt cut omega phi 
cut np omega np np np np np np np np np np np np np np np np phi np 

np np np theta theta theta theta np theta theta theta theta np np np np np proof case analysis partition inference rules groups ones depend context type ones 
complete proof appendix np line indicate non permutability relative definition overcome special treatment see subsection 
analyze array theorem column column 
column contains np means able move forward inference type proof 
repetition elementary operation move forward far possible inference 
problems movement inference type inference principal formula active inferences permutation position 
analyze array line line 
line contains means able move backward inference type proof 
repetition elementary operation move backward far possible inference 
problem movement inference introducing active formula inferences permutation position 
double analysis leads classify inference types groups ones move backward move forward far possible proof 
study details possible contradictory movements proof full linear logic 
inference movement ll proof section define notion movement inference proof 
mainly interested movements inference top proof called backward movement bottom proof called forward movement 
backward movement intuitively iteration movement backward permutation inference proof 
movement complicated presence inference type duplicates inference backward movement 
movement inference duplicated number times goes inferences type 
problem account leads definition definition pi proof ll inference pi proof pi ll obtained backward movement pi exists sequence pi pi proofs ll sequence inf inf inference sets inf inference set pi inferences open permutability ii pi pi pi pi inf fig iii gamma pi obtained pi permutation inference inference inf possibly corresponding inferences pi inf union inferences pi inf possibly 
inf called inference set pi resulting backward movement pi 
illustrate definition example 
example consider proof pi ll phi phi phi phi phi phi omega omega phi omega 
obtained backward movement 
pi proof pi 
phi phi 
phi phi phi phi omega omega observe inference 
get inference type backward movement pi duplication main effect inference set pi resulting movement 
consists inferences 
consider array theorem line line see inference types adapted backward movement 
analysis cut omega phi adequate forward movement notice 
concerning inference type theorem problem backward movement inference 
need active formula permutation position inferences precede immediately 
move backward axioms 
illustrated example expressed theorem theorem backward movement 
pi proof ll inference pi 
type exists proof pi obtained backward movement pi inference pi resulting movement immediately preceded axiom 
proof induction height pi subtree pi premise root 
ffl 
immediately preceded axiom pi consider pi pi 
ffl assume property true height prove 
consider proof pi inference pi 
type subproof tree pi having premise root height inference immediately precedes pi axiom 
active formula permutation position permutable theorem 
type pi proof obtained permutation pi inference pi corresponding subproof tree pi pi having root height apply induction hypothesis 
exists proof pi obtained backward movement pi inference pi resulting movement immediately preceded axiom 
composition backward movement permutation transforms pi pi obtain backward movement leads pi pi property true 
type case similar previous split permutation inferences apply induction hypothesis twice 
concerning type difference previous inference type contains active formula backward movement stopped inferences introducing active formula 
result theorem backward movement pi proof ll inference pi type exists proof pi obtained backward movement pi inference pi resulting movement immediately preceded inference introducing active formula 
proof proof similar theorem proof 
apparently theorem backward movement cut inference hold inference type 
shown example problem solved cut inference behavior inference consequently leads analogous result 
example consider example backward movement cut inference proof pi omega omega omega cut permute cut inference inference left hand side permutation possible inference type omega movement obtain proof pi cut omega omega permutation cut inference inference left hand side possible obtain proof pi 
cut omega omega time movement stops cut inference longer permutation position immediate predecessors 
theorem backward movement cut pi proof ll inference pi cut type exists proof pi obtained backward movement pi inference pi resulting movement inferences preceding immediately introduce active formulas 
proof induction number inferences preceding pi 
ffl 
proof pi preceded inference property true 
ffl assume property true order prove true 
consider proof pi inference type cut preceded inferences pi inference immediately preceding type introduce active formula inference theorem permute obtain proof pi inferences corresponding preceded inferences 
apply induction hypothesis obtain backward movement inferences pi proof pi verifying criteria 
composition movements permutation leading pi pi obtain backward movement pi pi inferences immediately preceding type introduce active formula inferences immediately preceding introduce active formulas case proof pi search pi 
inference immediately preceding type introduce active formula inference form delta delta active inference preceding immediately contains necessarily introduces pi form delta delta delta delta delta delta cut permute obtain proof delta delta delta delta delta cut delta delta inferences preceding new cut apply induction hypothesis go case 
concerning types omega phi potential obstacle inferences type bypassed cuts 
point illustrated example 
example consider backward movement omega proof pi aa aa 
aa omega omega obtain permutation 
omega proof pi aa aa omega omega aa omega 
permutation omega possible backward movement stops step 
theorem backward movement omega phi pi proof ll inference pi type omega phi exists proof pi obtained backward movement pi inference pi resulting movement immediately preceded inference introduces active formula inference type 
proof proof scheme case weakening 
possible move backward inferences type proof 
account particular behaviour rule movement possible successive permutations possibly jumps intermediate form delta form delta fragment consider 
forward movement intuitively iteration forward movement inference permutes proof 
movement complicated meeting process inference type contrary effect backward movement 
movement inference duplicated merged provides branch proof tree 
starting set inferences terminate movement inference 
reason forward movement notion defined duality backward movement 
definition pi proof ll inference pi proof pi ll obtained forward movement pi exists inference pi pi obtained backward movement pi resulting inferences 
unique called inference resulting forward movement pi 
illustrate definition example example consider forward movement proof 
pi proof ya ya za ya omega za omega ya omega za phi phi ya omega za phi permutation omega obtain proof pi ya ya omega omega ya omega za ya omega za phi phi ya omega za phi permutation phi obtain proof pi permutation implies renaming variable subtree having omega root 
ya ya omega omega ya omega phi phi ya omega za phi ya omega za phi consider array theorem column column see inference types adapted forward movement 
result analysis adequate inferences 
contrary happens case backward movement behavior 
obliged extend notion permutability inferences 
theorem illustrated example 
apparently inferences type 
phi rank category shall see proof 
false 
theorem forward movement pi proof ll inference pi type exists proof pi obtained forward movement pi inference pi resulting movement inference pi followed inference principal formula active formula 
proof structural induction pi 
restrict proof proof pi principal formula active pi loosing generality 
denote inference pi 
proof pi equal pi 
type 
apply induction hypothesis subproof pi premise contains principal formula forward movement pi obtain proof pi inference resulting movement 
replace pi pi pi theorem permutable obtain proof pi permutation 
type 
principal formula pi form pi delta pi delta delta assume example inference pi inference pi introducing distinguish cases relationship type type ff case type apply induction hypothesis pi pi forward movement pi obtain proof pi inference resulting movement 
way forward movement pi obtain proof pi inference resulting movement 
replacing pi pi pi pi respectively pi permutation obtain proof pi fi case apply induction hypothesis pi forward movement pi obtain proof pi inference resulting movement necessarily 
type 
replace pi pi pi obtain proof pi delta pi delta 
delta pi delta introducing inference type 
pi permute obtain proof pi implies extension permutability notion problem 
pi delta delta pi delta 
delta delta 
counter examples illustrate previous theorem applied inferences type phi 
phi phi phi phi phi 
concerning inferences type difficult move forward inferences proof 
true try move successive permutations 
inferences specific property conditions able disappear points proof appear forward 
pointed theorem theorem forward jump sequent form delta provable exists proof sequent ends inference introducing proof sequent form delta provable pi proof modify way 
replace starting final intermediate formula inferences introduce delete inferences 
add inference delta delta proof 
clear resulting tree definitely proof search 
consequence theorem possibility forward jump proof 
consider inference types observe different groups inferences respect permutability properties movement inference proof 
principal groups inference types ones move ones move 
partition groups depends proof search direction bottom top choose see section 
correspond groups connectives obtained partition respect notion synchronization determinism 
differences concerning treatment 
connective considered asynchronous andreoli corresponds rules 
behave differently 
member group synchronous connectives moved forward 
classification permutability properties framework logical consequences 
reason tell constants produced axioms 
redundancy reduction study forward backward movement cll proofs provides previous results theorems tools order inferences inside proof view giving called normal form 
defining notion treat question strongly connected objective eliminate reasons redundancy proof definition proof cll redundant consecutive intermediate identical 
proof easy construct equivalent redundant difficult construct directly sequent non redundant proof needing check posteriori 
cut elimination cut rule reasons redundancy 
theorem 
motivates backward movement cut inferences proof eliminate 
consider result cut elimination extension theorem 
considering proof cll cut moved backward inferences introducing active formulae 
ones dual types move step 
apply theorem 
sure process terminates height successive proofs inference number decreases systematically process 
necessary define appropriate new decreasing function possible notion complexity cuts proof 
complexity cuts proof definition formula complexity pi proof cll formula occurrence inference pi complexity formula integer defined inductively delta type fax 
delta delta maxfc delta delta maxfc premise definition cut complexity pi proof cll cut inference pi active formulae complexity cut integer defined 
definitions difficulties subtle 
define complexity cuts proof maximum complexity different cuts difficult prove decrease complexity 
reduction complexity particular cut imply increasing cut 
motivates definition definition cuts complexity proof pi cll proof complexity cuts pi integer pi equal zero pi cuts maximum complexities cuts preceded 
cut elimination theorem complexity reduction pi proof cll sequent delta cut exists proof pi delta pi pi 
proof complete proof appendix cut elimination theorem direct consequence theorem proof uses particular strategy cut reduction theorem theorem weak normalization knowing strong normalization verified linear logic 
theorem cut elimination delta provable sequent cll exists proof delta cuts 
proof pi proof cll pi property exists proof pi pi pi pi gamma property immediate consequence theorem 
sufficient apply pi 
theorem subformula pi cll proof cuts delta intermediate delta pi formula delta subformula delta 
proof induction height delta pi 
ffl 
case delta delta property true 
ffl assume property true order show true 
delta intermediate pi height premise inference height formula delta cut exists formula sequent delta subformula extending subformula notion 
delta height pi induction hypothesis applied subformula formula delta 
transitivity deduce subformula recall theorem sub formula naturally basis proof search methods bottom approaches top approaches 
weakening contraction reduction cuts generate redundancy proof reason 
example proof redundant contain cuts 
connected weakening contraction rules interact 
definition proof pi cll weakening contraction reduction intermediate form delta 
rule introducing formula exists inference 
introducing formula 
ii premise 
rule active formulae formula exists inference 
introduces 
case weakening done immediately axioms condition true ii condition satisfy 
theorem cll proof pi delta exists proof pi delta weakening contraction reduction obtained elimination weakening contraction inferences addition intermediate 
proof induction height proof pi 
ffl 
proof pi property true 
ffl assume result proof tree height prove 
pi proof tree weakening contraction reduction expected result contains intermediate delta form delta verify condition ii definition 
ff delta verify condition 
suppress pi weakening delta contractions introducing formulae add intermediate situated 
obtain proof pi height pi apply induction hypothesis 
fi delta verify condition ii 
proof schema ff 
theorem proof cll cuts contractions redundant 
proof proof fact inference contains number logical connectives greater premise 
unfortunately theorem false allow contractions 
give example illustrating point 
omega omega omega omega omega omega omega omega omega proof redundant cuts 
weakening contraction reduction 
shows exhausted subject redundancies elimination proofs 
proof normalization previous results permutability inferences movements inference proof treatment reduce redundancies aim analyze possibilities reducing non determinism proof search process 
section study proof normalization depending strategy proof construction 
see section depend fragment cll consider 
able define notion normal proof special form proof certain constraints order inference rules applied 
way consider mechanization proof construction full linear logic normal proofs constituting complete subset proofs cll 
necessary consider addition semantical properties improve new strategies theorem proving cll 
normalization construction strategy construction strategy possibility construct proofs cuts essential 
top proof search allows goal oriented procedure sub formula property bottom proof search decomposition process formulas sequent prove 
theorems inference movements lead relative ordering inferences proof 
considering proof object normalization corresponds double movement maximum movements certain inferences proof 
considering proof process interested construction normalization corresponds application soon possible certain inferences late possible inferences 
theorems section help determinate criterion choose inferences move backward forward facility 
example theorem 
allows immediately decompose formula having principal connector appears goal bottom proof search 
contrary top search application rule done late possible 
criterion facility 
consists proof strategy chosen bottom top 
top search move inferences easy control premises move maximum 
bottom move inferences easy control move maximum 
instance consider weakening rule observe controllable premise 
apply rule late possible top bottom proof directions 
analysis contraction rule 
different controllable easier premise 
apply rule soon possible top strategy late possible bottom strategy 
consider example delta delta omega delta delta omega omega delta delta 
omega phi delta delta phi bottom approach moved 
far possible case apply focusing principle means decompose formula omega go omega phi principal connective case example 
want keep movement 
compatible principle modify omega rule gamma delta gamma delta omega gamma gamma delta omega rule easily derivable initial omega rule complete easy prove sequent modified calculus omega preserves completeness 
consider new version sequent calculus 
fixed direction inference movement proof known movement possible 
general answer simple proof object inferences moved inferences active formulas introduced moved inferences principal formulas active 
consequences results section 
consider coherence movements 
concrete want consider bottom construction proof cll aiming analysis non determinism forms reasons reduction possibilities due normalization 
similar dual study done cll top proof strategy 
normalization non determinism reduction consider sequent delta prove cll bottom proof search consists building proof tree axioms 
process construction sequence goal expansions expansion goal delta consisting replacing premises inference delta 
step fundamental selection choice points non determinism choice goal satisfy choice principal formula goal goal principal formula choice inference goal formula principal 
choice goal 
non determinism concerning choice don care non determinism sense goal choose result change form 
true normal proofs 
choice consequences time space resources determine goal 
study permutability inferences proof resulting theorem help elaborate strategies 
sequent element particular fragment cll permutation inferences normalization done efficiently depending sort fragments 
pertinent consider goals fragments expect normalization properties 
considerations semantical point view help refine goal choice 
example goal multiplicative fragment cll interesting apply duality property 
choice principal formula 
choice concerns partially don know non determinism don care non determinism 
proof normalization allow reduce directly 
ffl goal form delta theorem allows surely choose principal formula inference type replace current goal delta ffl goal includes formula having principal connective surely choose principal formula inference reduce goal theorem 
ffl goal previous forms contains formulas literals choice principal formula corresponds don know non determinism 
fix principal formula determinate principal formula inferences immediately follow 
phi omega principal operator surely choose components positive literals form principal formulas inferences immediately follow theorem 
form produced different rules 
surely choose inference 
type goal proved axiom followed sequence weakenings theorem 
produced rule theorem 
choose active formula principal formula inference produced 
rule active formulas principal formula inference immediately follows 
ffl goal literals provable axiom 
choice inference having principal formula external connective determines inference rule realize expansion proof tree case phi possibilities 
choice phi phi corresponds don know non determinism difficult reduce 
rule fixed mean corresponding inference completely fixed 
true general omega choose term associated inference 
omega split context parts important source don know non determinism difficult reduce 
cases postpone choice level axioms lazy methods 
summarize search normal proof imposes constraints general algorithm choice principal formula reduce significantly don know non determinism 
help elaborate specific tactics strategies choice goal prove 
provide mechanisms calculating expansions determined principal formula 
normal proofs provide logical foundations proof search sequent 
normal proofs normalization proofs considered processes corresponds normalization proofs considered objects 
full linear logic bottom proof search direction define notion normal proof 
introduce definition considering sets inference types defined omega phi phi 
definition proof pi cll said normal pi cuts ii pi weakening contraction reduction iii intermediate delta verifies delta form delta immediate inference type delta contains formula introduced inference type immediate inference type delta contains formula introduced inference type premise delta active formula positive literal principal formula preceding inference 
delta principal formula possible cases delta 
rule preceding inferences weakenings axioms 
delta 
rule preceding inference inference type introducing active formulas inference delta delta inference type active formula positive literal principal formula preceding 
intermediate verifies criterion said normal 
example proof phi phi phi phi phi phi omega omega phi omega phi omega omega omega normal form contains intermediate normal example phi omega contains formula introduced inference type immediate inference type omega 
sequent prove proof normal form phi phi phi omega omega phi omega omega omega phi phi phi omega omega phi omega omega omega phi omega omega phi omega omega proof normalization theorem proof gives procedure transformation normalization proofs 
theorem normalization theorem proof pi cll exists normal proof pi ll proof call quasi normal proof proof verifies normality criteria definition possibly ii 
theorem sufficient prove cll proof exists proof 
pi cll proof theorem suppose pi cuts 
order normalize choose different strategies 
example start forward movement concerned inferences move backward 
course proceed methodically carefully new movement destroy realized 
proceed structural induction pi 
pi axiom 
case pi obviously normal proof search 
pi axiom 
inference pi 
induction hypothesis replace subproofs premises quasi normal proofs pi 
obtain way proof pi necessarily quasi normal 
delta normal intermediate pi depends type type 
immediate delta normal pi type delta form delta normal pi type theorem exists proof pi obtained backward movement pi inference pi resulting movement immediately preceded inference introduces active formula top connective 
operation preserves normality modified intermediate possibly inferences 
contain formulas introduced inferences type modify feature theorem allow inference move forward problematic inferences just 
proof obtain quasi normal 
type process variants due particularities types 
backward movement stopped inference type theorem moved just axioms 
type 
concept normal proof static character emphasize essential difference inferences type ones type phi omega 
ones completely concerned don care non determinism second ones partially concerned don know non determinism 
existence part don care non determinism leads different normal proofs sequent equivalent modulo inference permutations 
possibility handling specific case inference permutation investigate notion proof net proof net normalization 
proof net concept proof theory firstly introduced girard multiplicative fragment linear logic fact sequential presentation proofs trees inadequate emphasize meaning 
investigated automatic proof net construction point able extend notion important fragments cll new appropriate representation definition proof nets 
having interesting apply previous results normalization directly concept view reducing useful redundancies 
uniform proof notion essential proof construction normal proof concept possibility systems dependent proof search cll concept defining sub classes proofs complete tractable 
important note notion depends fragment consider proof construction direction bottom top 
general way want build normal proofs cll necessary fix constraints choices mentioned effect mainly reduce non determinism sources 
application linear logic programming considered full linear logic normalization aims improve efficiency proof construction theorem prover linear logic 
prover considered starting point linear logic logic programming 
necessary restrict study fragments cll efficiency purposes 
crucial question arises determine appropriate fragment 
point answer question know type problems want specify help linear logic 
commonly adapted specification dynamic problems need strict explicit resource management planning natural languages analysis petri nets generally reactive systems 
problem reduce syntax necessary coding petri nets omega ffig fragment involved 
point tells fragment determined problem involves efficient proof search procedures 
previous results help analyze adequacy fragment logic possible proof search methods 
illustrate application design linear logic programming including efficient proof search procedures consider example representation standard prolog linear logic analysis possible proof procedures 
note example significant illustration methodological point view applications approach logic programming proposals surely emphasize foundational character 
consider logical fragment standard prolog horn clauses 
basically program goal composed clauses clause form step translation program goal clauses 
clause translated cll formula xm ffia free variables goal translated formula free variables subgoals general query represented linear sequent summarize say prolog queries correspond sequents linear logic form particular formulas cll representing clauses program formula representing goal query defined grammar jg ffix xc 
jg gj xg 
represents positive literal definite clause goal 
translated logical framework obtain previous grammar clauses goals 
chosen standard prolog starting point normal approach give directly grammar study 
second step consists defining cll fragment involved sequent form 
subformula property deduce previous syntax set inference rules cll concerned prove linear sequents deduced step 
example set rules ffi 
logical fragment denoted lf 
third step consists studying logical foundations fragment permutability properties order define proof search procedures 
results sequents left hand side part transpose difficulty application classical sequents 
study inference permutability theorem leads results lf summarized array 
nt ffi 
ffi np theta np np np theta 
np theta theta fourth step consists studying possible inference movements lf fix direction proof strategy bottom top example choose bottom proof search strategy try order inferences general case section 
lf inferences type moved forward far possible proof inferences type ffi 
moved forward far possible 
moved decide move backward 
fifth step consists defining inferences ordering form bottom proof construct 
previous step bottom proof application rules decomposing goal subgoals 
apply 
rules correspond choice clause program 
apply rule 
rule application preceding useless cancel weakening 
means set resources program unchanged step 
backward movement 
inferences means application rule immediately followed rule application application rule introduce redundancy suppress 
selected clause usable application rule apply rule rules moved maximum 
consider ffi rules moved maximum goal form gamma ffix classical strategy prolog unifiable identical 
explain 
inference realize form gamma gamma gamma gamma ffix know moved maximum active formula principal formula inference just atom 
atom inference axiom consequently gamma inference gamma gamma ffix partially prolog mechanism unification corresponding rules applied 
obtain unification sufficient lazy application rules instantiation variables stopped axioms application 
proposed simple example knowledge expressiveness proof search apply analysis method different fragments linear logic considered basis linear logic programming 
related proof normalization linear logic presents similarities differences works various fragments ll mainly focusing extensions logic programming 
study permutability properties significant proof search theorem proving non classical logics general 
shankar proof search method intuitionistic calculus permutability possibilities generalized purpose 
investigate point connections 
aim consists having special proof form called normal form class equivalent cut free proofs 
similar way andreoli emphasizes subclass proofs called focusing proofs complete 
recall normal proof weakenings moved just axioms inferences type moved forward far possible principal formula active proof inferences type omega phi 
moved backward far possible active formulae introduced 
obtain partition inference types groups respect notion movement inference proof 
proposes similar partition connectives consequently inference rules notions synchronization determinism 
presents main differences concerning treatment connectives 
andreoli considers connective synchronous justified triadic system 
syntax system masks point types inferences introducing 

common behaviour study confirms 
difference treatment important 
considers connector called synchronous connectives example omega reduce non determinism case 
principal formula chosen non determinism 
possible suppress shown previous sections sequent delta formula selected principal 
example prove phi possible choose phi principal formula right system choose immediately principal formula 
concentrates problems automated theorem proving full linear logic investigate general search strategies mainly top direction original proposals resolution method cll 
appears consider approach refine define proof strategies top direction 
keeping full linear logic proof normalization process leads limits due impossibility permute inferences 
way solve problem consider adequate cll fragment go cll inference movement proof normalization 
example fragment inferences type phi moved forward possible type course choice fragment important criterion take account ability express problem specifications fragment 
requirements expressiveness efficiency contradictory find best compromise aspects 
way mention hodas miller harland pym 
common objective extend expressiveness capability logic programming languages linear logic efficiently construct proofs logical framework 
consider sided linear sequent calculus negation rule 
framework permutability properties available answer translation 
property inference type sequents left hand side part transposed automatically corresponding inference type righthand side dual inference type left hand side see section 
results fact rule sequent calculus left hand side part leads rules consider sequent calculus 
connective ffi adequate logic programming replaces connective keeps properties inference permutability fact 
briefly say considers sorts formulae goals resources sequents queries specific cll fragment 
point sequents proved notion uniform proofs bottom construction right rules applied left rules 
case fragment ll inferences right hand side parts sequents moved possible proof 
point strongly connected previous results 
complete study done basis method proposed section understand justify limits power fragment considered 
similar study done approach harland pym 
proposed fragment ll chosen uniform proofs remain complete presents difficulty treat right hand sides including difference expressiveness goals contexts 
works refer resolution cll fragments appears specific rule defined mainly analysis permutation properties bottom proof direction 
forget mention relationship fundamental results complexity decidability ll 
works aim develop computational interpretation logic obtain efficient decision algorithms bottom approach 
considers horn fragment ll computational logical point view generalizes approach additives 
knowing propositional linear logic decidable main complexity analysis multiplicative fragment np complete additive multiplicative pspace complete 
connections permutability logical study various related deeply analyzed view mechanizing proof construction fragments linear logic 
considered problem proof normalization full linear logic 
solution propose results systematic study inference logic framework 
issue effective construction theorem prover linear logic possible reduce sources proof construction 
necessary consider tactics strategies proof development addition semantical results 
issue consists analysis permutability inferences designing logic programming languages fragments cll compromise expressiveness language efficiency proof construction 
point strongly connected works extensions logic programming allows understand justify choices language conception 
analysis proof mechanization linear logic better comprehension cll proof theoretic foundation consider various applications proof development linear logic 
addition logic programming mention connections dynamical problems planning proofs programs approach adequate typed calculi 
case knowledge various aspects proof construction transformation necessary algorithmic contents proofs prospect example typed concurrent programming program synthesis program extraction proofs logical framework 
abramsky 
computational interpretations linear logic 
theoretical computer science 
andreoli 
logic programming focusing proofs linear logic 
journal logic computation 
andreoli pareschi 
logic programming sequent systems linear logic approach 
int 
workshop extensions logic programming lncs pages tubingen germany december 
andreoli pareschi 
linear objects logical processes built inheritance 
th conference logic programming mit press pages jerusalem june 

proof nets multiplicative additive linear logic 
technical report department computer science edinburgh university may 

linear semantics allowed logic programs 
th ieee symposium logic computer science pages philadelphia june 
gallier 
logic computer science foundations automatic theorem proving 
john wiley sons 
galmiche 
constructive system automatic program synthesis 
theoretical computer science 
galmiche 
program development constructive type theory 
theoretical computer science 
galmiche perrier 
automated deduction additive multiplicative linear logic 
logic logical foundations computer science symposium lncs pages russia july 
galmiche perrier 
procedure automatic proof nets construction 
lpar international conference logic programming automated reasoning lnai pages st petersburg russia july 
girard 
linear logic 
theoretical computer science 
girard 
geometry interaction 
gray scedrov editors conference categories computer science logic pages boulder colorado june 
harland pym 
uniform proof theoretic foundation linear logic programming 
international symposium logic programming mit press pages san diego october 
harland pym 
resolution fragments classical linear logic 
lpar international conference logic programming automated reasoning lnai pages st petersburg russia july 
hodas miller 
logic programming fragment intuitionistic linear logic 
th ieee symposium logic computer science pages amsterdam netherlands july 

horn programming linear logic np complete 
th ieee symposium logic computer science pages santa cruz california june 
kobayashi yonezawa 
acl concurrent linear logic programming paradigm 
int 
symposium logic programming pages vancouver october 
lafont 
interaction nets 
th acm symposium principles programming languages pages san francisco january 
lincoln mitchell 
operational aspects linear lambda calculus 
th ieee symposium logic computer science pages santa cruz california june 
lincoln mitchell scedrov 
decision problems propositional linear logic 
st ieee symposium foundations computer science pages st louis missouri october 

generating plans linear logic 
foundations software technology theoretical computer science lncs pages bangalore india december 

generating plans linear logic actions proofs 
theoretical computer science 
meseguer marti oliet 
petri nets linear logic 
category theory computer science lncs pages manchester september 
mitchell 
linear logic 
sigact news 
shankar 
proof search intuitionistic sequent calculus 
th conference automated deduction lnai pages saratoga springs june 

proof search strategies linear logic 
programming methodology group report chalmers university group university goteborg 
troelstra 
lectures linear logic volume lecture notes 
csli 
wallen 
automated proof search non classical logics 
mit press 
proof permutability theorem case case analysis partition inference rules groups depending context type 
type 
permutable need pi inference type coincides premiss type find counter example verify condition 
permutable type 
permutation position context form delta contains delta possibilities ff delta type cut fi delta ag type type cut 
case pi form delta delta delta delta cut delta delta consider proof delta delta delta delta delta cut form proof correct permutable extend notion inference permutability adding possibility inserting new inferences resulting proof say permutable certain sense 
permutation add inferences obtain proof delta delta delta delta delta delta delta cut type 
counter example shows general permutable type 
case transformation delta delta 
delta delta delta delta 
correct 
permutable type 
case transformation delta delta 
delta delta delta delta 
correct 
permutable type 
necessarily variable quantified free delta type cut variable free delta delta delta 
independent context permutable analyze cases potential problems 
type cut 
counter example shows general permutable xa xa cut xa xa type 
case transformation delta delta delta xh delta delta xh delta delta xh delta xh delta correct proof 
permutable type 
case transformation delta xf delta xf yg delta delta yg delta xf yg delta left hand side proof pi correct show resulting proof pi right hand side correct 
prove inferences pi correct 
second 
inference pi correct free delta fortiori free yg delta examine 
second inference pi correct free xf delta case free delta identical 
free free association variable free inference pi obtain correct inference 
pi correct permutable type 
counter example shows general permutable xa xa xa type 
counter example shows general permutable type 
type 
premise 
pi form delta delta delta delta delta delta consider proof delta delta delta delta delta delta correct iff delta form delta iff type 
ou 
cases permutable cases 
premises 
cut omega type pi form delta delta delta delta delta delta delta delta delta delta necessarily form delta permutable type type 
premise 
case pi form pi delta delta xf delta delta xf delta delta variable free intermediate pi included 
pi delta delta delta delta xf delta delta correct type depend context free delta delta permutable type phi 
renaming necessary 
premises 
cut omega type pi form pi delta delta xf delta delta pi delta delta xf delta delta delta variable free intermediate pi included 
pi delta delta pi delta delta delta delta delta xf delta delta delta free delta delta proof correct permutable type type 
premise 
case pi form delta delta delta delta delta delta delta delta consider proof delta delta delta delta delta delta delta delta delta delta correct depend context permutable premises 
cut omega type pi form delta delta delta delta delta delta delta delta delta delta delta consider proof delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta correct permutable type 
premise 
pi form delta delta delta delta delta delta delta delta delta proof correct depend context 
delta delta delta delta delta delta delta delta delta permutable premise premises 
cut omega type pi form delta delta delta delta delta delta delta delta delta delta delta delta proof correct depend context 
delta delta delta delta delta delta delta delta delta delta delta delta delta permutable premises premise 
type fc case delta formula cut non empty sets completely included premises example left 
delta delta delta delta delta delta delta delta delta delta delta delta delta proof correct depend context 
delta delta delta delta delta delta delta delta delta delta delta delta permutable type counter examples show case permutable omega omega omega cut aa type 
counter examples show case permutable omega omega omega 
omega omega omega 
omega omega omega 
omega omega cut omega omega 
premises 
cut omega type pi form delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta proof correct permutable delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta proof theorem complexity reduction theorem complexity reduction pi proof ll sequent delta cut exists proof pi delta pi pi 
proof unique cut pi 
theorem exists proof pi obtained backward movement pi inference resulting movement immediately preceded inferences introducing active formulae 
definition equal 
fact problem reduce complexity cut considering subproof pi pi 
pi cut pi pi 
consider cut cases form active formulae 
active formulae atomic constant 
pi different forms delta delta delta delta delta pi delta delta case replaced proof pi delta delta pi pi 
case replaced proof pi contains cut pi pi 
case replaced proof pi contains cut pi pi 
active formulae omega type 
case pi form delta delta omega delta delta omega delta delta delta delta delta cut replace proof pi delta delta delta delta cut delta delta delta delta cut pi pi omega 
pi pi 
active formulae phi type 
case pi form delta delta delta delta phi delta phi delta delta cut replace proof pi delta delta delta delta cut pi pi phi 
pi pi 
active formulae type 
case pi form pi delta xf delta 
delta xf delta delta delta cut replace proof pi pi delta delta delta delta pi obtained pi substitution renaming variables respect condition rule 
pi pi pi pi 
active formulae type 
case subcases depending way active formula type introduced 
inference type 
case pi form delta delta delta delta delta delta cut replace proof pi delta delta delta delta cut pi pi 
pi pi 
inference 
type 
case pi form pi delta delta 
delta delta delta delta cut replace proof pi pi delta delta delta pi pi 
inference 
type 
case pi form delta delta 
delta delta delta delta cut replace proof pi delta delta delta delta cut delta delta delta delta cut delta delta 
pi pi pi 
pi pi 

