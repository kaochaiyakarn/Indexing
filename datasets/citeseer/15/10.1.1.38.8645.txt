scylla smart virtual machine mobile embedded systems phillip stanley department electrical computer engineering rutgers university ece rutgers edu iftode department computer science rutgers university iftode cs rutgers edu proliferation wireless devices embedded processors increasing desire deploy applications run transparently varied architectures devices 
virtual machines solution code mobility providing virtualized processor architecture implemented individual node architectures 
proposed virtual machines embedded systems generally slow consume significant energy making unsuitable devices limited processing power energy resources 
novel virtual machine architecture scylla specially designed mobile embedded systems simple fast robust 
addition basic instruction set scylla supports inter device communication power management error recovery 
fly compilation extremely efficient instruction set closely matches popular processor architectures embedded systems today 
describes scylla preliminary evaluation performance including costs fly compilation overhead having virtual machine simulations measurements prototype system 
mobile devices embedded processors playing increasing role daily lives 
large numbers devices embedded intelligence ranging personal digital assistants cellular phones environment monitoring sensors 
increasing number devices networked interchange data global internet 
main benefits networked devices lie computational capability unique features device geographical location sensors communication capability energy resources 
processor architectures devices encompass broad range making interchange data applications devices difficult 
overcome problem wide variation processor architectures solution define virtual machine implemented different processor architectures shielding applications details underlying hardware facilitating code data mobility 
approach provide means performing remote processing permitting applications initiate computation request data remote device 
remote processing generally lacks flexibility limiting applications fixed set high level operations added cost communication remote servers 
virtual machines hand attempt provide complete programmable machine independent underlying processor architecture usually provide complete set low level primitives 
large majority embedded devices energy limited execution environment provide means logging preventing excessive energy resources applications 
virtual machine architecture energy consumption controlled points including host operating system virtual machine runs compilation byte code native machine code downloaded code fly compiled execution downloaded code 
contemporary virtual machines provide implementation optimized low power consumption means power management 
describes scylla virtual machine architecture specially designed mobile embedded systems 
addition simple comprehensive instruction set easily compiled fly necessary virtual machine supports inter device communication power management error recovery 
communication primitives enable applications running virtual machine communicate devices 
explicitly exposing action communication virtual machine enables estimation amount communication application perform 
applications run scylla may designate code executed exceptional conditions occur permitting internet gateway network web server scylla vm sensor application networked sensor database data analysis phase sensor application high performance cpu os data analysis phase sensor application high performance cpu os scylla vm statistics web 
user accesses processed sensor application communication phase scylla vm long range transmitter 
example application graceful recovery errors 
application accepted execution virtual machine guarantees resources execute provided exception handling code 
power management performed actively passively 
applications may provide virtual machine estimate dynamic instruction count implied computational energy usage estimation may performed fly compilation 
applications deemed expensive terms energy terminated gracefully executing application provided error handling code 
virtual machine designed closely match architectures modern microprocessors microcontrollers making register allocation fly compilation trivial inexpensive 
target class applications scylla small networked devices networked sensors constrained computing resources limited energy resources communication interfaces :10.1.1.110.6935
devices benefit greatly able safely execute mobile code permitting applications deployed large networks having hard coded sensor time deployment 
contributions include novel virtual machine architecture integrated facilities computation communication power resource management graceful error recovery 
rest organized follows 
section provides motivating example section describes related section details architecture scylla section discusses provisions safe execution foreign code section discusses preliminary performance data conclude section 
example intelligent sensor deployed metropolitan area gather statistics traffic congestion 
device activities include monitoring automotive pedestrian traffic logging information database providing real time access statistics web interface 
large amount data collected interpretation data specific context sensor application running sensor perform data analysis formatting prior supplying outside world web interface 
sensor may communicate sensors transmitters network gateways workstations servers standardized protocols devices knowledge structure data gathered sensor 
device able endure extended deployment times permanent source power 
obtain majority energy solar power mechanical vibration function correctly reliably bad weather night 
requirements dictate device conserve manage resources best possible 
illustrates typical scenario intelligent sensor 
sensor application originally resides sensor device limited energy resources gathers statistics environment counts passing automobiles ambient temperature pressure levels acoustic activity 
sensor application runs scylla virtual machine may communicate devices immediate vicinity 
due limited energy resources may transmit data short ranges 
overcome limitation application migrates device powerful transmitter migrates high server equipped scylla virtual machine 
performs detailed analysis gathered data migrated stores copy database generates uploads web page updated traffic statistics web server 
curious driving conditions metropolitan area accesses web server sees date predictions traffic delays 
infrastructure sensor servers communication network simultaneously entirely different application tracking pedestrian traffic monitoring weather conditions hard link applications hardware 
key flexibility able safely execute exchange code devices different architectures hardware capabilities 
related systems virtual machines interpretation fly just time compilation exemplified inferno operating system dis virtual machine java virtual machine dating back ibm virtual machine system facilitate compatibility different architectures providing uniform virtualized view underlying hardware 
abstractions provided virtual machine vary tied intended model usage 
virtual machine system described served dual purpose protecting users time shared system providing backward compatibility generations ibm successors 
java virtual machine originally intended long lived reliable systems providing platform independence heterogeneous networks 
current java virtual machine implementations slow memory hungry making inappropriate real time embedded systems 
issue performance addressed provision just time jit compilers continuous compilation 
jit compilers add large startup latencies problem addressed systems java hotspot compiler 
distributed virtual machine described factors components java virtual machine enable distribution tasks traditionally performed single node 
java micro edition virtual machine provides version java virtual machine targeted consumer electronics 
small compared java virtual machine implementations specifically address issues energy efficiency error recovery critical small networked devices 
dis virtual machine designed specifically fly compilation interpretation 
dis complex instructions performing operations creating processes performing operations lists communicating processes running virtual machine 
communication facilities provided dis permit communication processes running virtual machine 
virtual machine described similar scylla terms instruction set architecture 
instruction set designed analyzing dynamic instruction usages contemporary risc cisc architectures 
risc architecture number complex instructions perform operations memory memory block moves 
high level instructions provided instructions showed significant dynamic instruction traces systems investigated authors 
vcode dynamic code generation system described uses representation idealized risc architecture :10.1.1.25.8634
vcode performs code generation place reducing memory computational cost code generation generates fast native code 
architecture scylla follows principle closely matching architecture common risc architectures just time compilation reduced trivial re mapping 
architecture illustrates structure device hosting scylla 
typical system consists hardware device processor memory peripherals optional operating system scylla virtual machine applications run 
virtual machine may interact directly hardware may interface system calls operating system combination 
provides uniform interface applications independent underlying hardware responsible accepting executing applications subject checks ensure violate security policies energy usage constraints device 
operating system communication protocol issues discussed 
applications run scylla structured entities called modules 
components module logically physically grouped module os kernel system application code fault handler memory image applications hardware cpu memory peripherals scylla virtual machine 
typical structure host running scylla binary image separate pieces may provided different sources 
module consists application code memory image fault handler 
application code mandatory component module typically contains code executed virtual machine module loaded 
memory image component contains data loaded memory execution 
module migrates device memory image may contain modified data may migrate state application may maintained different devices 
fault handler contains code application designated operations performed exceptional conditions arise execution 
application code component contains scylla bytecode preceded header containing number instructions component estimate energy resources consumed execution form predicted dynamic instruction usage digital signature miscellaneous information 
digital signature may checked virtual machine assign level trust module energy consumption estimate 
memory image component contains data loaded memory prior execution module 
preceded header specifies number bytes data image number padding zero bytes appended data loading memory 
scylla permit dynamic memory allocation traditional sense modules may allocate memory receipt virtual machine specifying non zero number padding bytes 
structure fault handler component identical application code component 
addition restrictions instructions may fault handler 
fault handler may contain backward control transfer memory access instructions 
forbidding backward control transfer fault handler permits bounding estimated dynamic instruction usage energy consumption fault handler 
permits scylla guarantee execution module fault handler application accepted 
module loading client sends information module virtual machine virtual machine decides continue negotiation necessary accept module 
initial information sent may include instruction count implementation dependent estimation energy required execute module resources amount memory necessary successful compilation execution module presence specific hardware resources sensors 
sends component time fault handler application code memory image preceded checksum allow virtual machine verify component cached preventing unnecessary transmissions 
receipt components module virtual machine compiles fault handler decides compile application code 
compilation fault handler enables virtual machine determine contains illegal instructions estimate run time energy cost 
cost compilation small making approach attractive inspecting code having interpret instruction instruction 
compilation fault handler fails reasons processing module aborted 
virtual machine compiles application code attempts run 
illegal instructions memory bounds violations detected compilation execution application code execution fault handler initiated 
synchronous exceptions occur execution fault handler due restrictions placed permitted instructions fault handlers 
module energy estimation energy estimation performed energy consumed processor communication interfaces 
methodology appropriate systems energy usage processor communication interfaces dominate system energy usage typical devices small wireless network sensors display disk 
benefit having communication primitives part virtual machine instruction set ability obtain crude estimate communication performed application estimate energy expended communicating application active 
virtual machine estimates energy cost application code fault handlers simple table lookup compiling instructions 
entries table correspond energy estimates obtained native architecture instruction level power analysis similar 
general energy prediction inaccurate due fact easy way statically determine dynamic instruction usage 
virtual machine terminate applications estimated energy cost exceeds limit agreed module loading time attempt execute application fault handler 
fault handler restricted having backward control flow instructions dynamic instruction usage equal static instruction usage energy estimation compilation handler accurate 
acceptance module virtual machine contingent energy cost estimation module fault handler 
module accepted virtual machine provides guarantee need arise execute fault handler sufficient energy resources complete execution 
modules assured accepted execution application code rejected due energy cost illegal instruction behavior fault handlers executed permitting graceful error recovery 
general energy required execute module may dominated cost communication 
possible bound costs knowledge transmission medium amount data expected transmitted received knowledge communication protocols involved 
current implementation scylla assumes fixed cost payload byte transmitted estimates energy cost payload size communication 
investigating impact aforementioned issues power management virtual machine detailed discussion scope 
error recovery error recovery facilitated module fault handler 
control transferred fault handler exceptional conditions low battery levels battery powered device synchronous asynchronous machine exceptions relating execution application code occur application executes fault instruction explicitly requesting control passed irreversibly fault handler 
handler contain potentially excepting instructions memory loads stores contain fault instructions contain backward control transfer instructions 
additionally implementation dependent limit placed size fault handler 
restrictions permit accurate estimation bounding energy cost handler 
restriction placed job fault handler may implement general application specific event handling performed application termination 
fault handler typically cleaning application exits 
may migrate module failed due resource constraints local system device may applications processing sensitive data clear contents memory image event abrupt termination successful completion 
virtual machine guarantees module accepted execution sufficient system resources execute fault handler fault handler execute completion 
instruction set virtual machine sixteen bit general purpose registers 
load store architecture operations performed registers 
instruction set provides abstractions performing operations addition negation shifts memory access control transfer high level instructions fault xin 
instructions explicitly typed 
fault instruction transfers control program fault handler values register operands 
xin instructions provide primitives communication 
take operands start memory address number bytes transmitted port bit destination address broken bit fields denoted addr addr addr addr respectively 
port parameter identifies medium communication performed dictates semantics address parameter 
port specified may correspond local memory case xin instruction function block memory move may specify medium communicating devices semantics address dictated medium 
instructions variable length best code density 
fixed length instructions mandate instructions needed fewer bits fixed instruction length padded instruction length turn need minimum required encode instruction information 
instruction set architectures implemented hardware generally benefit fixed length instructions removes restriction having serialize fetch decode subsequent instructions 
instructions scylla byte code just intermediate representation get re mapped instructions hardware architecture variable length instructions loss application performance 
table compares core scylla instruction set powerpc arm hitachi risc architectures 
architectures extremely popular embedded systems personal digital assistants pdas digital cameras mobile phones 
seen table instructions core scylla instruction set map directly instructions architectures compared 
shown cases map directly replaced short sequences instructions 
architectures compared table typical contemporary risc architectures 
cisc architectures pose problem support superset operations provided risc processors support memory operands instructions 
cisc architectures generally limited number registers larger register files risc processors may emulated memory register file 
example highlights features architecture example data logging application implementing pseudo code 
initialize counters 
data collected read kb sensor device 
avg 
bit word store memory 
increment memory address stores 
transmit kb averaged data device 
code depicts assembler mnemonic form prior necessary checks form fault reset counters andi andi andi andi addi addi xa add addi add add read data xin andi andi average data ld add addi ble andi addi xa st addi got mbyte addi andi ble send data xf xf xe xc 
data logging application 
instructions inserted ld st instructions 
particular application analysis code reveal fault instructions need inserted memory statically unambiguous 
application repeatedly collects kb data peripheral port averages stores result memory 
collecting mb worth raw data transmits kb worth averaged data database connected medium port address xf xf xe xc 
raw data read memory starting address averaged data written memory starting address 
application compiles bytes scylla byte code 
register allocation register allocation done statically module created making job fly compiler easier permitting low startup latencies onthe fly compiled code 
possible know exactly registers available compile time 
register allocation trivial issue hinders performance just time compiled code inferno dis virtual machine 
fixed register set lead interesting issues 
significant similarity instruction sets contemporary risc architectures architectures generally fall distinct classes respect register operands instructions 
architectures powerpc sparc arm mips address instructions explicitly name separate destination register architectures hitachi risc archi scylla hitachi powerpc arm add rm rn add rm rn add rn rn rm add rn rm rn rm rn rm rn rn rn rm rn rm rn rm rn rm rn rn rn rm orr rn rm rn xor rm rn xor rm rn xor rn rn rm eor rn rm rn addi imm rn add imm rn addi rn rn imm add rn rn imm andi imm rn andi rn rn imm rn rn imm ori imm rn ori rn rn imm rn rn imm imm rn rn rn imm eor rn rn imm bra disp bra disp bl disp bal disp ld rm rn mov rm rn ld rn rm ld rn rm st rm rn mov rn rm std rn rm str rn rm rm rn rm rn rn rm neg rm rn neg rm rn neg rn rm sub rn rm table 
comparison scylla arm powerpc hitachi architectures 
tecture address instructions implicit destination register 
scylla employs address instructions implicit destination register 
virtual machine architecture explicit destination registers cost transforming instruction stream match architecture explicit destination registers nil architectures implicit destination registers additional instructions generated virtual machine instruction additional register required hold temporary values 
example implement register add address architecture virtual machine address instructions native instruction sequence needed mov rn add rm rn mov rn rd mov rn virtual machine architecture uses implicit destination registers mapping instructions architectures simple transforming implicit destination register explicit destination register formats 
compilation native architectures instruction set architecture virtual machine suited fly compilation 
scylla instructions map directly instructions instruction sets modern microprocessors microcontrollers compilation usually just matter re encoding instruction word 
illustrates compilation add instruction scylla byte code instruction powerpc architecture 
add instruction scylla architecture opcode opcode src src dest 
rc opcode source registers oe opcode info 
destination register scylla powerpc 
compiling add instruction scylla byte code powerpc architecture 
example source source destination fields set respectively 
powerpc instruction lower portion shaded fields contain opcode information case indicating add instruction remain fixed irrespective register operands 
oe rc fields specify variant add instruction example set 
powerpc uses explicit source fields destination register field operands source field scylla instruction placed field source destination field scylla instruction placed fields powerpc instruction corresponding add scylla instruction constructed just operations syn tax ppc instr contain assembled powerpc instr 
ppc instr ppc instr src ppc instr src ppc instr src current implementation fly compiler compiling kb object code hitachi risc architecture 
running foreign code safely ability safely run foreign code major concern embedded systems embedded processors memory protection hardware memory management units 
primary issue addressed section illegal memory accesses applications 
memory access checks implemented binary rewriting original byte code compilation 
memory accesses disambiguated statically guarded inserting fault instruction check address memory access bounds transfer control application fault handler 
example scylla code cause control transferred module fault handler address memory load greater equal value register 
fault ld memory accesses need guarded checks necessary register indirect loads stores addresses statically disambiguated reducing explosion code size performance degradation result insertion numerous checks memory accesses 
performing insertion memory access checks byte code level enables checking done architecturally independent manner possibly device eventually run code 
distributed architecture described may constructed scylla nodes different architectures different processing capabilities 
static checking relegated trusted nodes digitally sign module component completion analysis 
digital signatures application binaries employed virtual machine architectures described provide degree assurance integrity application authenticity origin 
architectures may ignore authenticity signed modules energy joules measured energy cost compilation measured energy cost execution number elements averaged estimated energy cost execution 
relative cost fly compilation 
marked statically checked risk apparently benign module originate malicious node faked signature trusted entity module trusted entity compromised operating incorrectly 
static checking done node unconstrained terms resources minimal number checks may inserted performing detailed code analysis 
way programs run virtual machine transfer control arbitrary pc locations register indirect jumps provided architecture way applications transfer control code checked illegal accesses 
register indirect jumps supported enforced destination jump valid memory dynamic instruction stream jumps circumvent memory check instructions protect memory accesses 
performance scylla currently runs sh processor evaluation board hitachi sh microcontroller 
analysis hardware measurements augmented instruction usage statistics obtained architectural simulator models processor cache scylla instruction compilation cost execution cost measured instructions instructions compilation cost joules add addi ble bra mult table 
code generation cost statistics hitachi sh 
ld add addi ble andi addi xa st addi 
kernel data logging application 
memory serial communications controller obtain statistics dynamic instruction count cpu cycles execution estimates circuit switching activity 
energy costs determined running application simulator obtain accurate cycle count measuring average current draw development board application executing repeatedly 
measurements entire board including processor memory peripherals 
assembler convert scylla assembler binary byte code format available capable generating array definitions assembler 
included source virtual machine implementation making possible simulate scylla application virtual machine architectural simulator 
relative cost fly compilation investigated determine compilation worth effort point cost compilation exceeded cost execution 
shows innermost loop example 
computes average elements array stored memory stores result memory region 
particular code shown specifically array elements 
kernel run virtual machine sh energy consumption measurements taken averaging array sizes elements 
runs measured cost compilation byte code native machine code remained approximately variation constant defining array size shown 
relative costs compilation execution runs shown 
seen breakpoint array sizes cost compilation begins play smaller role cost executing module 
inferred variation due increasing dynamic instruction usage computing averages larger datasets 
easily determined inspection cost compiling module insignificant compared cost execution small portions code example averaging element array cost compilation insignificant compared cost execution 
shows estimated cost executing kernel 
estimate obtained running implementation scylla compiled sh processor architectural simulator 
code kernel statically included virtual machine modified directly compile run 
sh instruction encountered simulator looks energy cost executing instruction table measured values 
cost compilation relative average cost execution generally significant cost execution small 
table shows average costs compilation execution sampling scylla instructions 
average cost compilation module scylla instruction instructions sh consuming average joules 
scylla instructions map directly instructions native architecture register set virtual machine generally matches actual hardware instructions execute native instruction shown table 
table instructions ble bra mult map native instruction additional registers necessary swapping register values accomplished temporaries 
architectures general purpose registers may utilized implementation swapping efficient 
instruction initiates execution subroutine perform communication energy cost highly dependent communication medium 
scylla smart simple virtual machine architecture mobile embedded systems preliminary evaluation performance 
key features scylla small footprint energy monitoring management graceful error recovery integrated communication primitives instruction set 
feature key enabling system estimate amount communication application undertake important issue high energy cost bit transmitted data 
scylla perform crude estimation energy cost module receipt 
virtual machine guarantees module accepted execution sufficient system resources execute fault handler completion 
virtual machine architecture closely matched popular processors embedded systems 
result cost compilation byte code native machine code terms native instructions complexity compilation process small significant application performance achieved 
implemented scylla sh processor evaluation board hitachi sh microcontroller 
current virtual machine implementation uses fly compiler kb size 
evaluation synthetic application showed energy cost fly compilation insignificant compared cost execution moderately small input data sets cost execution small 
currently investigating benefits proactively putting processor peripherals low power modes 
modern microprocessors microcontrollers support modes prudent take advantage facility 
missing current methodology ability accurately estimate cost communication 
looking performing detailed communication transmission protocol energy analyses specific communication technologies 
engler :10.1.1.25.8634
vcode retargetable extensible fast dynamic code generation system 
proceedings acm sigplan conference programming language design implementation pages 
estrin govindan heidemann kumar 
century challenges scalable coordination sensor networks 
proceedings fifth annual acm ieee international conference mobile computing networking pages 
gosling 
java intermediate bytecodes 
acm workshop intermediate representations pages 
heinzelman kulik balakrishnan 
adaptive protocols information dissemination wireless sensor networks 
proceedings fifth annual acm ieee international conference mobile computing networking pages 
hill szewczyk woo hollar culler pister 
system architecture directions networked sensors 
proceedings th international conference architectural support programming languages operating systems november 
holzle bak 
java tm sun high performance java implementation 
hot chips symposium august 
lindholm yellin 
java tm virtual machine specification second edition 
addison wesley publishing reading massachusetts may 
mur miranda chandrakasan lang 
vibration electric energy conversion 
proceedings international symposium low power electronics design pages 
meyer 
virtual machine timesharing system 
ibm systems journal 
cytron 
just time better late proceedings th acm sigplan sigact symposium principles programming languages pages 
reiher popek kuenning 
remote processing framework portable computer power saving 
acm symposium applied computing pages february 
lucco sharp 
universal substrate web programming 
fourth international world wide web conference 
mit lcs osf world wide web consortium december 
sirer grimm gregory bershad 
design implementation distributed virtual machine networked computers 
operating systems review december 
sun microsystems 
java platform micro edition technology creating mobile devices 
whitepaper may 
tiwari malik wolfe 
power analysis embedded software step software power estimation 
ieee acm international conference computer aided design pages august 
webb 
embedded java uncertain 
electronic design news may 
pike 
design inferno virtual machine 
hot chips symposium august 
