multimedia systems multimedia systems springer verlag comparison reliable multicast protocols brian neil levine garcia luna aceves computer engineering department school engineering university california santa cruz santa cruz ca usa mail brian jj cse ucsc edu 
analyze maximum throughput known classes reliable multicast transport protocols attain 
new taxonomy reliable multicast transport protocols introduced premise mechanisms release data source correct delivery decoupled mechanisms pace transmission data effect error recovery 
receiver initiated protocols entirely negative acknowledgments naks sent receivers sender proposed avoid implosion acks source 
protocols shown require infinite buffers order prevent deadlocks 
solutions ack implosion problem tree protocols ring protocols 
organize receivers tree send acks tree send acks sender ring receivers 
classes protocols shown operate correctly finite buffers 
shown tree protocols constitute scalable class reliable multicast protocols proposed date 
key words reliable multicast multicast transport protocols ack implosion tree protocols increasing popularity real time applications supporting group collaboration reliable dissemination multimedia information internet making provision reliable unreliable multicast services integral part architecture 
minimally endto multicast service ensures packets source delivered receiver session finite amount time free errors packets safely deleted finite time 
additionally service may ensure packet delivered supported part office naval research defense advanced research projects agency darpa correspondence levine order sent source 
reliable broadcast protocols existed quite time viable approaches provision reliable multicasting internet just emerging 
reliable multicast problem facing internet compounded current size continuing growth handling major challenge commonly referred ack implosion problem 
popular approaches reliable multicasting proposed date called sender initiated receiver initiated 
sender initiated approach sender maintains state receivers send information receive acknowledgments acks 
sender transmission retransmission multicast receivers packet receiver obtains correctly sends unicast ack sender 
contrast receiver initiated approach receiver informs sender information error missing sender multicasts packets giving priority retransmissions receiver sends negative nak detects error lost packet 
comparative analysis ideal sender initiated receiver initiated reliable multicast protocols pingali 
analysis showed receiver initiated protocols far scalable sender initiated protocols maximum throughput sender initiated protocols dependent number receivers maximum throughput protocols independent number receivers probability packet loss negligible 
demonstrates ideal protocols prevent deadlocks operate finite memory applications protocol services retransmit data existing implementations receiver initiated protocols inherent scaling limitations stem messages multicast group members set timers needed nak avoidance need multicast naks hosts session lesser extent need store messages sent session 
addresses question reliable multicast transport protocol reliable multicast protocol short designed enjoys scaling properties ideal receiver initiated protocols able operate correctly finite memory 
address question previous analysis pingali extended consider maximum throughput generic ring protocols organize receivers ring classes tree protocols organize receivers ack trees 
classes known approaches solve ack implosion problem 
analysis shows tree ring protocols correctly finite memory tree protocols best choice terms processing memory requirements 
results theoretical nature apply generic protocols specific implementations believe provide valuable architectural insight design reliable multicast protocols 
section presents new taxonomy reliable multicast protocols organizes known approaches protocol classes discusses key papers literature fit taxonomy 
taxonomy premise analysis mechanisms release data memory correct reception receivers decoupled study mechanisms pace transmission data session detection transmission errors 
taxonomy argue reliable unicast multicast protocols proposed date naks correctly finite memory requiring application level store data sent session acks release memory naks improve throughput 
section addresses correctness various classes reliable multicast protocols introduced taxonomy 
section extends analysis pingali analyzing maximum throughput protocol classes tree tree local nak avoidance periodic polling tree ring protocols 
section provides numerical results performance protocol classes different scenarios discusses implications results light reliable multicasting 
section provides concluding remarks 
new taxonomy reliable multicast protocols describe generic approaches known date reliable multicasting 
known protocols unicast multicast purposes mapped class 
taxonomy differs prior addressing receiver initiated strategies reliable multicasting decouple definition mechanisms needed pacing data transmission mechanisms needed allocation memory source :10.1.1.121.1027
approach protocol thought windows congestion window cw advances feedback receivers regarding pacing transmissions detection errors memory allocation window mw advances feedback receivers sender erase data memory 
practice proto ack source receiver set nak fig 

basic diagram sender initiated protocol cols may single window pacing memory tcp separate windows netblt 
reliable protocol assumes existence multicast routing trees provided underlying multicast routing protocols 
internet trees built protocols dvmrp core trees cbt ordered core trees protocol independent multicast pim multicast internet protocol mip :10.1.1.39.7251
sender initiated protocols past sender initiated protocols characterized placing responsibility reliable delivery sender 
characterization overly restrictive reflect way reliable multicast protocols rely positive receivers source designed 
taxonomy sender initiated reliable multicast protocol requires source receive acks receivers allowed release memory data associated acks 
receivers restricted directly contacting source 
clear source required know constituency receiver set scheme suffers ack implosion problem 
characterization leaves unspecified mechanism pacing transmissions detection transmission errors 
source receivers charge retransmission timeouts 
traditional approach pacing transmission error detection tcp context reliable unicasting source charge retransmission timeout 
suggested results reported floyd better approach pacing multicast session receiver set timeout :10.1.1.121.1027
receiver sends acks source rate accept sends nak source receiving correct packet source amount time exceeds retransmission timeout 
ack refer specific packet window packets depending specific retransmission strategy 
simple illustration sender initiated protocol fig 

notice regardless sender driven receiver driven retransmission strategy source charge deallocating memory receiving acks packet set packets 
source keeps packets memory receiver node positively acknowledged receipt data 
sender initiated protocol sender driven retransmission strategy sender polls receivers acks retransmitting timeout 
receiver driven retransmission strategy receivers poll source ack time 
important note just reliable multicast protocol uses naks mean naks basis source ascertain release data memory 
combination acks naks extensively past reliable unicast multicast protocols 
example netblt unicast protocol uses nak scheme retransmission small partitions data cw 
partitions called buffers acks data buffer mw 
receipt ack source release data memory netblt really sender initiated 
fact naks unnecessary netblt correctness buffer considered large packet eventually acked important mechanism improve throughput allowing source know sooner retransmit data 
protocol similar netblt negative acknowledgments periodic polling protocol 
protocol broadcast protocol local area networks lans 
netblt groups large partitions data periodically acked lost packets partition naked 
advances cw naks periodically advances mw acks 
naks cause nak implosion source uses nak avoidance scheme 
netblt naks increase throughput necessary correct operation albeit slow 
periodic polling limits lans source suffer ack implosion problem acks occur 
sender initiated protocols xpress transfer protocol xtp created internet suffer ack implosion problem 
main limitation sender initiated protocols acks need source process acks know receiver set 
known methods address limitation naks acks delegating retransmission responsibility members receiver set organizing receivers ring tree 
discuss approaches subsequently 
receiver initiated protocols previous characterizes receiver initiated protocols placing responsibility ensuring reliable packet delivery receiver 
critical aspect protocols taxonomy acks 
receivers send naks back source retransmission course source needs timer ascertain connection receiver failed 
nak source receiver set fig 

basic diagram receiver initiated protocol needed detected error skip sequence numbers timeout 
receivers restricted directly contacting source 
source receives feedback receivers packets lost delivered source unable ascertain safely release data memory 
explicit mechanism receiver initiated protocol source release data memory advance mw pacing retransmission mechanisms scalable efficient advancing cw 
simple illustration receiver initiated protocol 
receivers communicate naks back source receiver initiated protocols possibility experiencing nak implosion problem source receivers detect transmission errors 
remedy problem previous receiver initiated protocols adopts nak avoidance scheme proposed sender initiated protocol :10.1.1.121.1027
receiver initiated nak avoidance rina protocols shown better performance basic receiver initiated protocol 
resulting generic rina protocol follows 
sender multicasts packets state information giving priority retransmissions 
receiver detects packet loss waits random time period multicasts nak sender receivers 
receiver obtains nak packet received started timer send nak receiver sets timer behaves sent nak 
expiration timer reception corresponding packet signal detect lost packet 
scheme hoped nak sent back source lost transmission entire receiver set 
nodes farther away source get chance request retransmission 
generic protocol describe timers set accurately 
generic rina protocol just described constitutes basis operation scalable reliable multicasting srm algorithm :10.1.1.121.1027
srm embedded internet collaborative whiteboard application called wb 
srm sets timers low rate periodic session messages multicast member group 
messages specify time stamp receivers estimate delay source highest sequence number generated node source 
average multiple sources supported srm focus single source case simplicity 
bandwidth consumed session messages kept small keeping frequency session messages low 
srm implementation requires node stores packets application layer store relevant data 
note naks receivers advance cw controlled receivers sequence number multicast session message poll receiver set ensure receiver aware missing packets 
session messages implement polling function advance mw sender initiated protocol sender specifies highest sequence number source highest sequence number heard source 
practice persistence session messages forces source process number messages needed source know receiver set time periodic message receiver 
accordingly defined basic dissemination session messages srm scale defeats goals receiver initiated paradigm keep receiver set anonymous source scaling purposes 
issues limit rina protocols reliable multicasting 
show section rina protocol requires data needed retransmission rebuilt application 
approach reasonable applications immediate state data exclusively desired case distributed whiteboard 
approach apply multimedia applications current state stream transition states 
second naks retransmissions multicast entire multicast group allow suppression naks 
nak avoidance scheme designed limited scope lan small number internet nodes tree protocols described section basic nak avoidance algorithm requires timers set updates multicast node 
number nodes increases node increasing amount 
furthermore nodes congested links lans regions may constantly bother rest multicast group multicasting naks 
approaches limit scope naks retransmission evolving :10.1.1.121.1027
current proposals rely session messages reach group members 
example receiver initiated protocol log receiver reliable multicast uses hierarchy log servers store information indefinitely receivers recover contacting log server 
log servers feasible applications afford servers leaves issues unresolved 
single server performance degrade due load server multiple servers mechanisms implemented ensure servers consistent information 
ideal receiver initiated protocol main advantages sender initiated protocols source know receiver set source prior description srm incorrectly assumed session messages contained highest sequence number heard source 
steve mccanne pointing 
process acks receiver receivers pace source 
limitation protocol mechanism source know safely release data memory 
furthermore argued practical implementations approach fail provide advantages 
protocol classes organize receiver set ways permit strengths receiver initiated protocols applied local scale providing explicit mechanisms source release memory safely efficient management mw 
tree protocols tree protocols characterized dividing receiver set groups distributing retransmission responsibility tree ack tree structure built set groups source root tree 
simple illustration tree protocol fig 

ack tree structure prevents receivers directly contacting source order maintain scalability large receiver set 
ack tree consists receivers source organized local groups group having group leader charge retransmissions local group 
source group leader charge retransmissions local group 
group leader source communicates local group child group leader closer source request retransmissions packets received correctly 
group leaders may children local group minimally may just contact local group 
local group may group leader handle multiple sources 
group leaders chosen dynamically token passing local group 
hosts children bottom ack tree termed leaves 
obviously ack tree consisting source leader leaf nodes corresponds sender initiated scheme 
acknowledgments children group including source group sent group leader 
children group send group leader soon receive correct packets advancing cw refer local acks local naks retransmissions triggered local acks local naks unicast group leaders children 
similar sender initiated schemes local naks unnecessary correct operation protocol 
tree protocols delegate leaders subtrees decision delete packets memory advance mw conditional receipt aggregate acks children group 
aggregate acks start leaves ack tree propagate source local group time 
group leader send aggregate ack children sent aggregate ack 
aggregate acks necessary ensure protocol operates correctly group leaders fail ack tree partitioned long periods group leader leaf local ack source fig 

basic diagram tree protocol time 
aggregate acks group leader waits children send local acks advancing mw correct operation group leaders fail guaranteed allowing nodes delete packets approach tree protocols 
protocol tree protocol build single shared ack tree multiple sources single session aggregate acks ensure correct operation hosts ack tree fail 
local acks local naks requesting retransmissions important throughput 
source scheduled retransmissions aggregate acks paced slowest path ack tree 
retransmissions scheduled independently local group 
tree protocols eliminate ack implosion problem free source having know receiver set operate solely messages exchanged local groups group leader children ack tree 
furthermore aggregate acks tree protocol correctly finite memory presence receiver failures network partitions 
simplify analysis description protocol assume group leaders control retransmission timeouts timeouts controlled children source group leaders 
accordingly source sends packet sets timer group leader sets timer aware new packet 
timeout local acks received packet assumed lost retransmitted source group leader children 
application tree protocols reliable multicasting internet reported paul compared basic schemes reliable point multicasting hierarchical structures 
results fully developed reliable multicast transport protocol rmtp 
generic protocol sends local ack packet sent source rmtp sends local acks periodically conserve bandwidth reduce processing group leader increasing attainable throughput 
define tree protocol tree protocol uses nak avoidance periodic polling local groups 
naks sufficient guarantee reliability finite memory receivers send periodic positive local ack parents advance cw note messages sent setting timers needed nak receiver set source nak ack fig 

basic diagram ring protocol avoidance limited local group scalable 
tree multicast transport protocol tmtp example tree protocol 
ring protocols ring protocols reliable multicast originally developed provide support applications require atomic total ordering transmissions receivers 
proposals reliable multicasting token ring protocol trp aim combine throughput advantages naks reliability acks 
reliable multicast protocol rmp discussed updated wan version trp 
multiple rings naming hierarchy class protocol actual rings 
rmp throughput bounds trp 
base description generic ring protocols lan protocol trp wan protocol rmp 
simple illustration ring protocol fig 

basic premise token site responsible packets back source 
source times retransmits packets receive ack token site timeout period 
ack serves timestamp packets receiver nodes global ordering packets delivery application layer 
protocol allow receivers deliver packets token site multicast ack 
receivers send naks token site selective repeat lost packets originally multicast source 
ack sent back source serves token passing mechanism 
transmissions source available piggyback token separate unicast message sent 
interested maximum throughput consider case 
token passed member ring receivers new site correctly received packets site received 
token passed site may clear packets memory accordingly final deletion packets collective memory receiver set decided token site conditional passing token 
source deletes packets ack token received 
note trp rmp specify retransmissions sent unicast token site 
analysis focuses maximum attainable throughput protocol classes assume token passed exactly message 
protocol correctness protocol considered correct shown safe live 
minimum definition reliable service assumed reliable multicast protocol live deadlock occur receiver source 
protocol safe data sent source delivered higher layer finite time 
address correctness protocol classes assume nodes fail duration reliable multicast session multicast session established correctly permanent 
analysis correctness focuses ability protocol classes sustain packet losses errors 
assume exists non zero probability packet received error free senders receivers finite memory 
proof correctness ring protocols chang maxemchuk 
proof unicast protocols safe live available sources bertsekas gallager 
proof change significantly sender initiated class reliable multicast protocols omitted brevity 
liveness property receiver violated node store counter sequence number packet delivered higher layer 
safety property proof essentially source waits acks members receiver set sliding cw mw forward 
theorems demonstrate generic tree reliable multicast protocol short correct reliable multicast protocols live 
theorem safe live 
proof 
set nodes belong reliable multicast session including source receivers set organized ary tree height proof proceeds induction case reduces nonhierarchical sender initiated scheme nodes receivers practicing retransmission strategy source 
proof follows correctness proof unicast retransmission protocols bertsekas gallager 
assume theorem holds 
prove theorem holds liveness 
prove member tree height live 
consider subset tree starts source includes nodes tree height leaves subtree group leaders larger tree group leaders nodes bottom larger tree 
inductive hypothesis liveness property true subtree 
show live second subset nodes consisting leaves larger tree group leader parents 
group second subset follows protocol suffices prove arbitrary group live 
arbitrary group second subset tree constitutes case sender initiated reliable multicast difference original transmission sent source external group group leader 
leaves contact group leader prove relationship live 
inductive hypothesis guarantees group leader parent live 
assume source transmits packet time received correctly delivered leaves arbitrary group time time group leader deletes packet advances mw protocol live enter deadlock finite 
rest proof follows proof bertsekas gallager unicast arq protocols group leader takes place source 
live 
safety 
safety follows directly proof liveness shows arbitrary packet delivered receiver finite time 
qed theorem 
receiver initiated reliable protocol live 
proof 
proof example focusing sender arbitrary member receiver set 
sender node memory store packets 
packet takes unit time reach receiver node naks take finite amount time reach sender 
denote th packet zero 
sent start time lost network 
sends packets successfully 
sends nak stating received 
nak lost reaches sender time sender decides send packet pm store packets received naks time clear assuming received correctly 
receives nak time deadlocked unable retransmit qed indicates ideal receiver initiated protocol requires infinite memory correctly 
practice requirement implies source keep memory packet sends lifetime session 
theorem assumes node failures network traffic occur 
node failures happen practice changes operational requirements practical treebased protocols 
tree protocols shown deleting packets memory node receives local acks children live 
aggregate acks necessary ensure correct operation tree protocols presence failures 
tree protocol uses aggregate acks operate finite memory presence node failures network partitions 
maximum throughput analysis assumptions analyze maximum throughput generic reliable multicast protocols introduced sect 
achieve model pingali focuses processing requirements generic reliable multicast protocols communication bandwidth requirements 
accordingly maximum throughput generic protocol function packet processing rate sender receivers analysis focuses obtaining processing times packet node 
assume single sender multicasting identical receivers 
probability packet loss node 
summarizes notation section 
clarity assume single ack tree rooted single source analysis tree protocols 
selective repeat retransmission strategy assumed protocol classes known retransmission strategy highest throughput requirement keeping buffers receivers non issue small cost memory 
assumptions specific protocol listed sect 
interest modeling maximum throughput 
additional assumptions lost loss events node multicast packet mutually independent 
multicast routing protocols cbt pim mip dvmrp organize routers trees means correlation packet loss receiver :10.1.1.39.7251
assumption benefits classes especially favors protocols multicast 
fact assumption essential rina protocols order analyze maximum attainable throughput nak avoidance effective receivers guaranteed receive nak multicast receiver set 
number nodes involved nak avoidance increases task successful delivery nak receivers probable 
rina tree protocols favored assumption rina protocols probability delivering naks successfully receivers exaggerated 
second assumption equivalent scenario correlation packet losses receivers location receivers underlying multicast routing tree source 
protocols take advantage relative position receivers multicast routing tree transmission acks naks retransmissions possibly attain higher throughput predicted model 
class relative advantage assumption 
table summarizes bounds maximum throughput known classes reliable multicast protocols 
results clearly show tree protocols constitute scalable alternative 
sender receiver initiated protocols notation introduced pingali place superscript variable related sender initiated protocol variables related receiver initiated rina protocols respectively 
maximum throughput protocols constant stream packets receivers ln table 
analytical bounds protocol processor requirements constant sender initiated ln ln nak avoidance ln ln ring uni cast 
tree pb ln tree ln pr ln 
probability packet loss goes zero throughput sender initiated protocol inversely dependent size receiver set ack sent receiver source transmission correctly received 
contrast goes zero throughput receiver initiated protocols independent number receivers 
notice throughput receiver initiated protocol inversely dependent number receivers ln probability error negligible 
note result assumes perfect setting timers rina protocol cost single nak reaches source interested maximum attainable throughput protocols 
tree protocols denote class protocols simply superscript variables related protocol class 
derive bound expected cost type node consider system throughput 
symmetry assume loss generality receivers form full tree level 
loss generality assume local group ack tree consists children group leader 
allows symmetry throughput calculations 
assume local acks advance mw aggregate acks assumption receiver fails system 
assume perfect setting timers cost single nak reaches source interested maximum attainable throughput protocols 
source node consider processing costs required source successfully multicast arbitrarily chosen packet branching factor tree group size 
size receiver set 
time feed new packet higher protocol layer 
xp time process transmission packet 
xa xn times process transmission ack nak local ack respectively 
time process timeout sender receiver node respectively 
yp time process newly received packet 
time deliver correctly received packet higher layer 
ya yn times process transmit ack nak local ack respectively 
yp probability loss receiver losses different receivers assumed independent events 
number local acks sent receiver packet tree protocol 
number acks sent receiver packet unicast protocol 
total number local acks received receivers packet 
number transmissions necessary receiver successfully receive packet 
number transmissions receivers receive packet correctly protocols maxr number transmissions receivers receive packet correctly protocols 
processing time packet sender receiver respectively protocol 
processing time packet group leader tree tree protocols respectively 
processing time packet token site ring protocols 
throughput protocol source receiver leaf group leader token site subscript denotes system throughput 
times process reception transmission respectively periodic local ack 
fig 

notation receivers protocol 
processing requirement arbitrary packet expressed sum costs initial transmission retransmissions receiving acks time get packet higher layer time taken attempt successful transmission packet time process timeout interrupt transmission attempt time process local ack number transmissions source packet protocol number local acks received protocol 
expectations 
derived far extremely similar eqs 
analysis pingali 
fact analysis understanding size receiver subset source collects local acks 
expected number local acks received sender 
substituting eq 
eq 
rewrite expected cost source node 
pingali shown expected number transmissions packet equals 
number receivers expected number transmissions packet protocol simplified 
pingali provide bound apply obtain ln 
eq 
bound eq 
follows ln bp ln 
follows constant ln 
leaf nodes denote requirement nodes forward packets leaves 
notice leaf nodes protocol process fewer retransmissions send fewer receivers protocol 
analysis similar pingali receivers sender initiated protocol 
receiving transmissions sending local acks time takes process re transmission time takes send local ack time deliver packet higher layer number local acks generated node number transmissions correctly received 
receiver sent transmissions probability packet lost obtain 
expectations eq 
substituting eq 

noting bound eq 
ln 
treated constant ln 
group leaders evaluate processing requirement group leader note node caught source node children jobs receive retransmit packets 
convenient group leader sender receiver express costs terms sum costs receiving transmissions sending local acks collecting local acks retransmissions 
just case source node expected number local acks received node children packet number local acks generated node 
substitute eqs 
eq 
obtain 
terms equivalent processing requirements leaf node 
cost source node 
substituting subtracting difference yields 
words cost group leader source leaf cost receiving data higher layers transmission original 
substituting eqs 
eq 
ln bp ln bp ln 
constant ln dominant term throughput analysis system 
system analysis throughput sender group leaders leaf nodes 
throughput system min 
eqs 
follows bp ln 
constant obtain ln constant 
maximum throughput protocol throughput non negligible packet loss independent number receivers 
class reliable multicast protocols exhibits degree scalability respect number receivers 
tree protocols local nak avoidance periodic polling bound system throughput generic protocol repeat method tree class derive bound expected cost source group leaders leaves 
case tree protocols assume receivers form full tree level 
place superscript variables relating generic tree protocol 
source node consider processing costs required source successfully multicast arbitrarily chosen packet receivers protocol 
processing requirement arbitrary packet expressed sum costs initial transmission retransmissions receiving local naks receiving periodic local acks bx time get packet higher layer time re transmission attempt time receiving local nak receiver set amortized time process periodic local ack associated current congestion window number transmission attempts source packet 
expectations 
eq 
bound bound eq 
follows ln ln 
follows constant 
leaf nodes denote processing requirement nodes forward packets leaves 
sum cost expressed receiving transmissions sending periodic local acks sending local naks receiving local naks rob 
time takes process re transmission number transmissions required packet received receiver time takes send local nak time takes receiver local nak receiver time set timer time deliver packet higher layer amortized cost sending periodic local ack group packets packet member 
expectations eq 
prob 
follows distribution 
noting eq 
prob derive eq 
expected cost 
bound eq 
bound eq 
ln 
treated constant 
group leaders sum costs group leaders job sender receiver receiving transmissions sending periodic local acks receiving periodic local acks receiving local naks sending local naks retransmissions children bx prob 
expectations substituting eq 
obtain 
similar group leaders protocol processing cost group leader source leaf cost receiving data higher layer transmission 
substituting eq 
eq 
eq 
subtracting difference expected cost expressed 
eq 
bounded ln 
constant 
nodes tree protocol constant amount regard number receivers 
system analysis system throughput protocol minimum throughput attainable type node tree min 
eqs 
follows ln 
accordingly constant obtain eq 

maximum throughput tree protocol throughput non negligible packet loss independent number receivers 
ring protocols section analyze throughput ring protocols denote superscript assumptions sects 

interested maximum attainable throughput assuming constant stream packets means ignore overhead occurs acks piggyback token passing messages 
source source nodes practice special form unicast roaming token site 
sum costs incurred initial transmission processing acks retransmissions number transmissions required packet received token site mean number acks receiver case token site sent unicast number packets correctly received number accordingly 
expectations eq 
obtain 
assume constant costs operations shown constant regard size receiver set 
token site current token site costs note trp rmp specify retransmissions sent unicast receivers 
receiving transmission multicasting ack token processing naks unicasting retransmissions prob number naks received token site ring protocol 
derive consider number transmissions necessary receiver successfully receive packet 
expected value transmission naked 
receivers sending naks token site obtain 
mean processing time token site pe 
expected cost token site bounded regard number receivers 
constant 
receivers receivers practice receiver initiated protocol current token site 
assume packet ack token time stamp multicast token site data packet 
cost associated arbitrary packet receiving ack token time stamp receiving transmission sending naks receiving retransmissions prob prob prob prob 
term equation cost receiving ack token time stamp packet token site second cost receiving transmission sent sender assuming received error free third cost delivering error free transmission higher layer fourth cost receiving retransmissions token site assuming failed terms consider nak sent transmission attempt fails interrupt occurs nak sent 
expectations obtain yr pe 
shown previously 
substituting eqs 
eq 
pe pe 
assuming operations constant costs shown regard size receiver set 
consider constant 
system analysis system throughput generic token ring protocol equal minimum attainable throughput parts min 
eqs 
follows constant obtain constant 
numerical results compare relative performance various classes protocols mean processing times set equal periodic costs set 
compares relative throughputs protocols defined sect 

graph represents inverse eqs 
respectively throughputs tree ring protocols inverse throughput equations derived previously receiver initiated protocols 
top middle bottom graphs correspond increasing probabilities packet loss respectively 
exact values calculated finite version eq 
exact values similarly calculated 
performance nak avoidance protocols especially tree protocols clearly superior 
assumptions place subclasses advantage base classes 
assume lost received error 
effectiveness nak avoidance dependent probability naks reaching receivers assumption effectiveness nak avoidance decreases number receivers involved increases 
accordingly tree protocols advantage limited branching factor ack tree rina protocols advantage increases size entire receiver set 
second assume timers nak avoidance set perfectly 
reality messages set timers subject delays exhibit regularity arbitrarily large 
number fig 

throughput graph exact equations protocol 
probability packet loss respectively 
branching factor trees set conjecture relative performance nak avoidance subclasses lie closer respective base classes depending effectiveness nak avoidance scheme words curves shown upper bounds nak avoidance performance 
results show considering base classes advantage tree class performs better classes 
considering subclasses nak avoidance tree protocols perform better rina protocols model provides unfair advantage rina protocols 
hierarchical structure organization receiver set tree protocols guarantees scalability improves performance protocols 
nak avoidance small scale increases performance 
addition nak avoidance failed tree protocol due incorrect setting timers performance independent size receiver set 
rina protocols property 
failure nak avoidance rina protocols result unscalable performance receiver initiated protocol degrades quickly increasing packet loss 
increase processor speed smaller branching factor increase throughput tree protocols 
number receivers smaller branching factor implies retransmissions traverse larger number tree hops receivers expecting tree 
example packet lost immediately source retransmission multicast children nodes tree wait retransmission tree structure 
poses latency problem addressed advantage dependencies underlying multicast routing tree 
retransmissions multicast receivers attached routers subtree router attached receiver requested missing data 
number tree hops receiver source factor quickly source release data memory presence node failures discussed levine 
processor speed fig 

number receivers protocol 
probability packet loss respectively 
branching factor trees set shows number receivers different classes relative processor speed requirements 
number obtained normalizing classes baseline processor described pingali 
baseline uses protocol support exactly receiver speed processor support receivers protocol set 
baseline cost equal 
eqs 
derive tree tree ring protocols respectively 
number receivers derived sender receiver initiated protocols shown rp 
fig 
clear tree protocols support number receivers processor speed bound node tree protocols attain highest maximum throughput 
important note maximum throughput rina protocols attain insensitive size receiver set probability error decreases 
assumed single nak reaches source naks lost session messages incur processing load implicitly assume optimum behavior rina protocols 
simulation results reported srm floyd agree model result assuming nak losses single packet loss experiments :10.1.1.121.1027
shows tree protocols perform better best possible rina protocol limiting size local groups 
unicast nature retransmissions protocols protocols approach sender initiated protocols indicates allowing multicast retransmissions improve performance greatly 
compared analyzed known classes reliable multicast protocols 
course model constitutes crude approximation actual behavior reliable multicast protocols 
internet ack nak simply packet probability ack nak lost received error error probability data packet 
assumption gives protocols nak avoidance advantage classes 
reasonable compare separately results show tree protocols nak avoidance perform better classes nak avoidance tree protocols perform better rina protocols rina protocols artificial advantage class 
conjecture effects ack nak failure correlation failures underlying multicast routing trees accounted relative performance protocols observed 
results summarized table 
known sender initiated protocols scalable source account receiver listening 
receiver initiated protocols far scalable nak avoidance schemes avoid overloading source retransmission requests 
unbounded memory requirement protocol class efficiently application layer support limited set applications 
furthermore set timers needed nak avoidance existing instantiations rina protocols require group members transmit session messages periodically unscalable 
ring protocols designed atomic total ordering packets 
trp rmp limit throughput requiring retransmissions unicast 
possible reduce cost bound ln assuming constant nak avoidance techniques ramakrishnan jain 
analysis shows ack trees answer scalability problem reliable multicasting 
practical implementations tree protocols maintain anonymity receiver set tree tree classes throughputs constant respect number receivers probability packet loss negligible preclude accurate setting nak avoidance timers 
tree protocols delegate responsibility retransmission receivers employ techniques applicable sender receiver initiated protocols local groups node children tree ack tree mechanism receivers session receiver initiated protocol adopted tree protocol added benefit throughput number receivers completely independent size receiver set regardless likelihood packets acks naks received correctly 
hand scope naks retransmissions reduced establishing structure receiver set limiting scope session messages needed set nak avoidance timers contain scope naks retransmissions require aggregation messages :10.1.1.121.1027
leads organizing receivers local groups aggregate sessions messages sent source local groups 
doing efficiently leads hierarchical structure local groups tree protocols require 
appears organizing receivers hierarchically ack trees necessity scaling reliable multicast protocol 

ballardie francis crowcroft core trees cbt architecture scalable inter domain multicast routing 
proc 
acm sigcomm october pp 
san francisco ca usa september 
bertsekas gallager data networks second ed 
prentice hall englewood cliffs new jersey 
chang maxemchuk nf reliable broadcast protocols 
acm trans comput syst 
clark dd lambert ml zhang netblt high throughput transport protocol 
proc acm sigcomm august pp 
san francisco ca usa september 
deering multicast routing datagram internetwork 
phd thesis stanford university palo alto calif 
deering cheriton multicast routing datagram internetworks extended lans 
acm trans comput syst 
deering 
architecture wide area multicast routing 
proc 
acm sigcomm pp london uk august september 
floyd 
reliable multicast framework light weight sessions application level framing 
proc 
acm sigcomm pp 
cambridge ma usa august september 
holbrook singhal cheriton log multicast distributed interactive simulation 
acm sig comm pp 
cambridge ma usa august september 
postel jb ed transmission control protocol 
request comments 
levine bn garcia luna aceves jj comparison known classes reliable multicast protocols 
proc 
ieee international conference network protocols october 
columbus oh usa october november 
ural ed los alamitos ca usa 
ieee comput soc press pp 
levine bn garcia luna aceves jj case reliable concurrent multicasting shared ack trees 
proc 
acm multimedia pp november 
boston ma usa 
lin paul rmtp reliable multicast transport protocol 
proc 
ieee infocom pp 
san francisco ca usa march 
los alamitos ca usa 
ieee comput soc press 
garcia luna aceves jj protocol scalable multicast routing 
ieee sel areas commun 
paul kristol multicast transport protocols high speed networks 
international conference network protocols pp 
boston ma usa october 
los alamitos ca usa 
ieee comput soc press 
paul kk lin jc bhattacharyya reliable multicast transport protocol rmtp 
ieee sel areas commun 
pingali protocol real time scheduling issues multimedia applications 
phd thesis university massachusetts amherst mass 
pingali towsley kurose comparison sender initiated receiver initiated reliable multicast protocols 
perform evaluation rev 
ramakrishnan jain bn negative periodic polling protocol multicast lan 
proc 
ieee infocom pp 
san francisco ca usa march april 
washington dc usa 
ieee comput soc press 
shields garcia luna aceves jj ordered core tree protocol 
ieee infocom pp 
strayer dempsey weaver xtp xpress transfer protocol 
addison wesley reading mass 
towsley kurose comparison sender initiated receiver initiated reliable multicast protocols ieee sel areas commun 
kaplan montgomery high performance totally ordered multicast protocol 
theory practice distributed systems international workshop lncs september 
dagstuhl castle germany september 
birman kp mattern schiper eds berlin springer pp 
yavatkar griffioen sudan reliable dissemination protocol interactive collaborative applications 
proc 
acm multimedia pp 
san francisco ca november brian neil levine phd candidate computer engineering university california santa cruz ucsc 
received applied mathematics computer science state university new york albany 
received computer engineering university california santa cruz 
current research interests include multicast routing reliable multicast protocols 
garcia luna aceves born mexico city mexico october 
received degree electrical engineering universidad mexico city mexico ph degrees electrical engineering university hawaii honolulu hi respectively 
professor computer engineering university california santa cruz ucsc 
prior joining ucsc associate professor center director sri international sri menlo park california 
joined sri sri international fellow 
current research interest analysis design algorithms protocols computer communication 
ucsc leads number research projects sponsored darpa industry focus wireless networks internetworking 
dr garcia luna aceves coauthored book multimedia communications protocols applications prentice hall published referred papers computer communication journals conferences 
editorial boards ieee acm transactions networking acm multimedia systems journals journal high speed networks 
dr garcia luna aceves chair acm special interest group multimedia general chair acm conference multimedia acm multimedia program chair ieee multimedia workshop general chair acm sigcomm symposium program chair acm sigcomm workshop acm sigcomm symposium 
program committee member numerous ifip acm ieee spie conferences computer communication 
received sri international exceptional achievement award multimedia communications adaptive routing algorithms 
member acm ieee 
