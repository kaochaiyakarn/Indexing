icse workshop testing distributed component systems 
may approach analyzing testing component systems mary jean harrold liang sinha computer information science ohio state university lab neil avenue columbus oh cis ohio state edu software testing maintenance account thirds cost software production 
program analysis techniques offer potential automate testing maintenance tasks reduce cost tasks 
emerging paradigm software development promises enhance software productivity quality composes software independently developed components 
nature component software introduces new problems applying program analysis techniques testing maintenance software providers software components develop test components independently applications components users software components analyze test applications access source code components applications 
describes issues challenges applying analysis testing techniques component software presents approach analyzing testing component systems 
keywords component system software components program analysis software testing software testing maintenance account thirds cost software production 
software tools program analysis techniques promise automate testing maintenance tasks reduce cost tasks improve software quality 
example data flow testing techniques data flow information evaluate adequacy test suites assist test development 
data flow information useful validating properties concurrent programs 
regression testing techniques data flow control dependence information determine retesting required changes program 
techniques debugging program understanding impact analysis dataflow control dependence information reveal dependencies software :10.1.1.114.5033:10.1.1.50.4405
class software efficient effective program analysis techniques program testing maintenance tools useful component software 
component system composed primarily components modules encapsulate data functionality configurable parameters run time 
component systems form significant class existing software 
increasing incidence component systems appropriate consider techniques ensuring quality 
require efficient effective ways test maintain component systems 
describe approach analysis testing component systems consider componentbased system consists parts user application components infrastructure provides communication channels user application components 
user application communicates components interfaces 
communication infrastructure maps interfaces user application interfaces components 
component provides multiple sets functionalities set functionalities accessed configuration 
issues arise analysis testing component systems viewed perspectives component provider perspective component user perspective 
component provider perspective addresses analysis testing issues interest provider software components 
component user perspective contrast addresses analysis testing issues concern user software components 
component provider views components independently context components 
provider ef test configurations components context independent manner 
component user contrast views components context dependent units component user application provides context components 
component user concerned configurations aspects behavior components relevant component user application 
factor distinguishes issues pertinent perspectives availability source code components component providers access source code component users typically 
need test maintain ensure quality components individually need test maintain ensure quality systems components 
require analysis techniques operate efficiently components systems constructed 
need tools track impact changes components systems 
need tools help retest systems modified components 
describe analysis testing issues arise component providers component users 
techniques fall categories techniques component providers analyze test individual components context independent manner gather information assist analysis testing systems components techniques component users require analyze test system uses components 
approach separates analysis testing component systems component user perspective analysis testing components component provider perspective issues analysis testing component systems section describe issues addressed effectively analyze test component systems 
discuss issues arise analysis testing individual components 
component user perspective component users develop component systems integrating applications components 
challenges adapting traditional program analysis testing techniques analyzing testing maintaining systems 
source code components typically available component users 
traditional program analysis techniques alias analysis control dependence computation testing techniques data flow testing require access source code system analyzed tested :10.1.1.114.5033
source code components unavailable traditional program analysis testing techniques applied component systems 
way perform analyses source code conservative approximations analysis relations hold components analysis relations caused user application code components 
approximations cause analysis results imprecise useful 
example suppose component user wants perform control dependence analysis componentbased system 
access source code information computed component provider compute safe control dependence information component user assume component raises exception incorporate information analysis 
second component system source code available components user application implemented different languages 
analysis tool implementation language user application fail analyze components 
third component provides functionality particular user application 
identifying portion functionality particular user application testing tool analysis tool report imprecise results 
example structural testing criteria measure adequacy test suite examining extent test suite covers various structural elements program 
measuring adequacy test suite developed component system structural elements comprise unused parts components embedded system excluded consideration 
failure cause testing tool report low coverage test suite test suit exhaustively tests system respect coverage criteria 
component provider perspective component providers develop test software components independently applications components 
component users component providers access source code components 
testing component similar traditional unit testing 
traditional criteria statement branch testing may sufficient testing component weak fault detection capabilities criteria 
fixing fault revealed component component users typically entail higher cost fixing similar fault detected tion testing non component system potential component user applications 
component provider address issues 
component provider effectively test components context independent units software 
effective adequate testing software components independent contexts increases component users confidence quality components reduces burden users testing components 
adequacy criterion unit testing components described tests components context user application 
criterion relevant component users component providers 
second component provider support better testing analysis user applications faults related components easier revealed user applications released 
improve quality component system reduce cost testing maintenance system 
approach section provide overview approach analyzing testing component systems 
illustrate approach examples 
analyze test component system approach separates analysis testing user application analysis testing components 
approach component provider tests components analysis techniques gathers summary information facilitates analysis testing components component users requiring access source code components 
component provider summary information available component 
component user integrates components user application queries summary information drive analysis testing integrated system 
summary information obviates need access components source code 
facilitate testing dynamic analysis component system tool desires compute information component specific execution approach divides input space operation set subdomains associates summary information subdomain 
compute information component execution tool maps inputs operation subdomain uses summary information associated subdomain 
method obviates need instrument component testing dynamic analyses 
method improve precision program analyses user application functionalities provided component 
example divide input space operation configurations 
case tool uses summary information functionalities user application 
analysis information stored component varied level analysis testing desired component users 
example support alias analysis user application component store alias pairs hold contexts component information subsequently generate context sensitive alias pairs component 
example support program slicing user application component store summary information data dependences parameters component operations control dependence side effects caused operations component 
final example support structural testing user application component store information facilitates generation testing requirements 
stored analysis information component support component user wide range analysis testing techniques minimally stored information support basic set analysis testing techniques 
summary information provided component represented standard notation independent language component implemented 
component provide suitable query facilities example methods operations retrieve summary information 
illustrate approach describing types summary information provided components facilitate analysis testing component systems 
program slicing program slicing identifies statements program may affect value variable specific program point hp vi called slicing criterion 
set statements identified program slicing slice respect hp vi 
program slicing support software engineering tasks program understanding debugging impact analysis 
approach providing testing information software components uses 
records testing history component instrumentation source code component recommends appropriate testing requirements component component user 
approach providing summary information components avoids code instrumentation provides wider variety information facilitates application analysis testing techniques component systems 
program slicing techniques classified static dynamic 
static program slicing computes program dependence program statements examining paths control flow graph computes transitive dependence closure statements 
dynamic program slicing computes program dependence occurs execution program specific input examining execution trace 
slicing criterion dynamic slicing includes input program 
dynamic program slicing compute higher cost precise slices static program slicing 
summary information component allows static program slicer compute precise slices user application component system 
summary information component represented dependence variables 
static slicer encounters call operation component maps real input real output variables uses dependence variables approximate dependence real input real output 
component state summary information provides dependence input variables output variables operation 
component state summary information provides set state variables values define states component dependence state variables input variables output variables 
levels abstraction input output state variables reflect levels precision summary information 
lowest level input variable output variable state variable state variable depends input variable output variable depends input state variables 
higher level multiple input variables output variables state variables dependence represented higher precision level 
summary information techniques handle objects adapted handle components user applications 
support precise dynamic slicing component system dependence summary information component defined context subdomains input variables operation state variables component 
dynamic slicer encounters call operation component maps values real input real state component subdomains input state variables uses subdomains search appropriate dependences 
subdomains divided different precision levels 
lowest level input variable state variable subdomain 
case summary information summary information static slicing 
highest level precision subdomains computed symbolic execution operations 
control dependence analysis control dependence analysis determines program statement predicates control execution statement 
control dependence information required analyses slicing software engineering tools debuggers impact analyzers regression testers 
component affect control dependence relations hold user application uses component errors may arise computation performed component 
underlying reason error component propagated outside component parameters component 
cause error component component take steps recover error 
error propagated outside component component reasonably expected correct error appropriate error recovery depends context user component 
different users may choose recover error different ways 
context independent unit component signals error condition leaves context dependent error recovery user 
exception handling constructs provide mechanism raising exceptions facility designating protected code attaching exception handlers blocks code 
component raises exceptions corresponding errors recover user application provides handlers exceptions 
summary information exceptions raised component enables analysis testing techniques performed component system 
summary information provided various levels precision 
levels successively higher cost records information enables analysis testing techniques applicable component system 
basic level summary information simply lists exceptions raised component 
facility available languages java method declare exceptions raise 
summary information potential exceptions utility component raises exceptions control dependence computation proceed user application considering possible effects component 
component raises exceptions computation consider effects component control dependence relations user application 
cases summary information lists potential exceptions facilitate correct control dependence computation provide information variables determine exceptions raised 
higher level summary information associate exception input parameters state variables component determine exception raised 
increased precision summary information enables computation allows computation slices correctly account side effects control dependences caused components 
precise level summary information stores constraints conditions input parameters state variables cause various exceptions raised 
analysis information supports slice computation allows generation appropriate testing requirements testing behavior exception handling constructs component system 
component choose represent summary information related control dependence computation various levels precision depending analysis testing requirements system component embedded 
data flow testing data flow testing uses data flow information guide selection test cases measure test suite coverage program 
data flow testing assignment variable program tested executing subpaths assignment definition points variable 
test data adequacy criteria require test cases test suite exercise certain definition relationships program 
data flow testing described single procedures functions interacting procedures object oriented classes 
component providers data flow testing provide adequate coverage components provide summary information component users 
component providers approach dataflow testing classes test components context independent manner 
approach provides technique performing analysis computing testing requirements individual methods interacting methods class approach applied interacting classes 
component providers data flow analysis provide summary information component users test software 
minimum summary information provide types information 
summary information consist set uses input variables reached entry module 
uses tested definitions component user software reach interface module 
second summary information consist set definitions reach module 
definitions tested uses component user software reached component executes 
levels abstraction sets definitions uses provide different levels testing information 
lowest level component assumed define input variable 
level may possible infer subdomains input variables component specification 
subsequently higher levels precise information provided 
highest level precision summary information contain definition input variables association uses definitions subdomain belong constraints inputs associated subdomains 
component store subdomain set uses definitions testing component system 
component possess method mapping runtime input values subdomain belong 
method report uses definitions associated subdomain covered input 
typical scenario testing component system proceed steps 
tester execute component system initial test suite 
executions input passed component component maps input subdomain reads uses definitions covered input summary information associated subdomain records coverage 
execution component returns coverage measurement 
tester assesses coverage desired coverage achieved requests information input constraints associated uncovered subdomains 
tester constraints generate test cases execute system test cases cover uncovered uses definitions 
summary identified issues arise description measuring data flow coverage coverage criteria statement coverage 
analysis testing component systems 
described issues perspectives component provider component user 
approach addresses issues provides framework analyzing testing component systems 
techniques described preliminary examination problems arise application analysis testing techniques component systems investigated 
need identify minimal set analysis testing techniques supported summary information provided components 
various levels support analysis testing techniques potentially organized hierarchical structure provide guidance component providers attaining certain level support progressing lower level support higher 
need formally define language independent notation record summary information mechanisms allow retrieval information 
approach model component systems applicable existing component models corba com investigate approach adapted existing component models 
investigate new techniques adaptations existing techniques may required effectively analyze test component systems 
acknowledgments supported part nsf nyi award ccr ohio state university ess award ccr ohio state university 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
bilardi pingali 
framework generalized control dependence 
proc 
sigplan conf 
prog 
lang 
design pages may 
chatterjee barbara ryder william landi 
relevant context inference 
proceedings th acm sigact sigplan symposium principles programming languages pages january 
dwyer clarke 
data flow analysis verifying properties concurrent programs 
proceedings acm sigsoft symposium foundations software engineering pages december 
ferrante ottenstein warren 
program dependence graph optimization 
acm transactions programming languages systems july 
frankl weyuker 
applicable family data flow criteria 
ieee transactions software engineering october 
harrold rothermel 
performing dataflow testing classes 
proceedings second acm sigsoft symposium foundations software engineering pages december 
harrold rothermel sinha 
computation interprocedural control dependence 
proc 
acm int 
symp 
softw 
testing analysis pages march 
harrold soffa 
incremental data flow testing tool 
proceedings sixth international conference testing computer software may 
harrold soffa 
interprocedural data flow testing 
proceedings acm third testing analysis verification symposium pages december 
harrold soffa 
efficient computation interprocedural definition chains 
acm transactions programming languages systems march 
harrold rothermel 
separate computation alias information reuse 
ieee transactions software engineering july 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems january 
korel laski 
dynamic program slicing 
information processing letters october 
landi ryder 
safe approximate algorithm interprocedural pointer aliasing 
proceedings acm sigplan conference programming language design implementation pages june 
lewis 
years part ii 
ieee computer pages may 
liang harrold 
slicing objects system graphs 
proceedings international conference software maintenance pages november 
liang harrold 
context sensitive procedure specific points analysis 
technical report osu tr ohio state university march 
liu richardson 
software components 
proc 
international workshop role software architecture testing analysis pages june 
ntafos 
comparison structural testing strategies 
ieee transaction software engineering june 
pande landi ryder 
interprocedural def associations systems single level pointers 
ieee transactions software engineering may 
pressman 
software engineering practitioner approach 
mcgraw hill new york ny 
rosenblum 
adequate testing component software 
technical report uci ics university california irvine august 
rothermel harrold 
safe efficient algorithm regression test selection 
proceedings conference software maintenance pages september 
sinha harrold rothermel 
graph slicing programs arbitrary interprocedural control flow 
proc 
int conf 
softw 
eng may 
appear 
weiser 
program slicing 
ieee transactions software engineering july 

