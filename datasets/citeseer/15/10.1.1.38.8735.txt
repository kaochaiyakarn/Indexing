university amsterdam programming research group family syntax definition formalisms eelco visser report august university amsterdam department computer science programming research group family syntax definition formalisms eelco visser report august visser programming research group department computer science university amsterdam kruislaan nl sj amsterdam netherlands tel 
mail visser wins uva nl earlier version report appeared van den brand asf sdf 
workshop generating tools algebraic specifications technical report programming research group university amsterdam 
pp may 
author arie van deursen jan heering tobias kuipers paul klint mark van den brand de jonge alex sellink useful suggestions comments previous versions report 
research supported netherlands computer science research foundation sion financial support netherlands organisation scientific research nwo 
project incremental parser generation context sensitive disambiguation multi disciplinary perspective 
universiteit van amsterdam contents contents family syntax definition formalisms 
overview sdf 
design 
organization 
context free grammars symbols 
grammars 
context free grammars kernel 
basic symbols 
parse trees 
disambiguation abbreviation priorities 
regular expressions 
lexical context free syntax 
restrictions 
renaming modularization renamings 
aliases 
modules 
syntax definition formalism sdf sdf 
comparison sdf 
discussion concluding remarks 
auxiliary modules specification sdf literals 
aterms 
renamings 
sdf 
bibliography family syntax definition formalisms chapters design specification family syntax definition formalisms 
kernel family formalisms formed context free grammars 
number orthogonal extensions kernel defined 
extensions defined terms primitives kernel means normalization functions 
provides framework constructing new formalisms adapting extending previous ones 
included family extensions context free grammars uniform definition lexical context free syntax variables disambiguation priorities follow restrictions reject productions rich set regular expressions defined terms context free productions character classes aliases parameterized modules hidden imports renamings 
accumulation extensions syntax definition formalism sdf 
chapter provides sdf gives overview design specification family formalisms 
new programming specification special purpose languages developed continuously 
syntax definition formalisms play crucial role design implementation new languages 
syntax definition formalisms play role embedded languages regular expressions edit operations macro definitions macro preprocessors user definable infix distfix operators programming languages grammars signatures algebraic specification formalisms documents contain description syntax 
core syntax definition formalisms formed context free grammars widely computer science chomsky 
context free grammar set string rewrite rules form ff ff string zero symbols symbol 
string sequence symbols member language described grammar rewritten start symbol sequence ff ff ff step form ff ff ff fi fi fi ff fi bfi contains production fi despite due simplicity basic structure emerged standard formalism syntax definition 
backus naur family syntax definition formalisms form bnf originally developed backus naur 
definition syntax algol commonly notation contextfree grammars status standard variants 
standard notations syntax definition proposed wirth williams 
convincing number similar overlapping formalisms exist 
reason divergence practical syntax definition formalism serves define languages sets strings 
syntax definitions interpreted recognizers decide string belongs language parsers map strings parse trees mappings parse trees syntax trees syntax directed editors 
plain context free grammars adequate purpose 
support compact definition languages formalisms provide variety features extensions basic structure character classes regular expressions disambiguation associativity priority declarations reuse modularization parameterization language definitions interfacing formalism environment mapping syntax 
various extensions context free grammars developed attaching semantics grammars attribute grammars knuth attach attribute evaluation rules productions 
computation semantics parse tree consists computing values attributes 
computation orthogonal parsing 
affix grammars koster extended affix grammars watt similar attribute grammars predicates affix values play role disambiguation parsing 
definite clause grammars pereira warren horn clauses logic programming 
parsing performed sld resolution evaluation mechanism 
semantic values represented means terms passed unification logic variables 
approaches including algebraic specification separate formalism define semantics 
traditionally compiler construction main application area syntax definition formalisms 
known pair lex yacc 
formalism lex lesk schmidt define lexical syntax language regular expressions 
regular expressions string analyzed divided tokens 
case regular expression matched number disambiguation rules prefer longest match prefer regular expressions appearing earlier file 
compiler compiler yacc johnson definition context free syntax language 
lalr parser generator translates grammars programs grammar lalr 
conflicts parse table caused ambiguous expression grammars solved means binary unary precedences ideas aho 

furthermore order productions grammar solve conflicts 
trees string constructed calling functions grammar productions 
formalisms generally deterministic parsing techniques extend expressivity syntax definition providing mechanisms building trees coupling phases compilation 
examples cocktail compiler generator provides bnf formalism lalr parser generator 
eli system gray collection tools developing aspects compilers 
syntax definition formalism context free grammars 
attribute rules added define semantics computations 
tree transformation language txl cordy programming language source source transformations means transformation rules parse trees 
syntax definition formalism txl context free grammars extended regular operators 
lexical syntax defined means predefined lexical notions means regular expressions character classes 
pccts parr quong formalism top ll parsing 
problems unbounded lookahead dealt means backtracking syntactic predicates try variant deciding production predict 
application domain derived compiler construction area programming environments 
programming environment collection tools interactively developing testing programs programming language 
tools usually centered interactive syntax directed editor 
syntax editor knowledge language programs edited provides support checking syntax programs presenting manipulating structure programs 
order rapidly process changes program incremental parsing incremental compilation 
syntax definition formalisms developed derivation programming environments include grammar formalism synthesizer generator reps teitelbaum psg snelting metal kahn sdf heering :10.1.1.28.6239
asf sdf meta environment klint programming environment developing generating programming environments algebraic specifications 
speed development cycle syntax definitions incremental parser generation regenerate parts parser affected change 
syntax definition algebraic specification takes form grammars algebraic signatures 
motivation provide flexible notation functions constructors data type specifications description real programming languages 
requirements lexical syntax strong 
correspondence context free grammars sorted signatures described rus see hatcher rus 
goguen 
showed correspondence define semantics programming languages 
correspondence exploited number algebraic specification formalisms provide flexible user definable notation functions constructors 
formalism incorporate obj futatsugi 
asf sdf heering bergstra meta notation action semantics mosses elan vittek :10.1.1.28.6239
combination features formalism provides necessarily arbitrary strongly influenced expected application definitions environment generated tools operate 
desirable include conceivable features formalism features combined features results unmanageable formalism similarities different formalisms exploited reusing parts design implementation old formalisms 
formalisms conventionally designed monolithic way containing intertwined mix features resulting formalism lack orthogonality uniformity difficult implement extend applications originally intended ones 
syntax definition formalisms form family syntax definition formalisms exception rule 
set design syntax definition formalisms modular way family formalisms extending small kernel feature syntax definition 
approach result orthogonal uniform formalisms easier construct formalisms subset set known features adapt formalisms application areas implement tools formalisms design new formalisms combine new features existing ones 
step accomplish goal design concrete formalism set features useful application areas particular application grammars signatures algebraic specifications programming languages 
result syntax definition formalism sdf generalization sdf 
incorporates concepts techniques introduced heering 
orthogonal uniform way adds new features 
algebraic specification formalism asf sdf formally specify family syntax definition formalisms 
asf sdf see van deursen 

chapter outline main features sdf examine structure design principles specification 
overview sdf sdf syntax definition formalism context free grammars extended character classes sorts literals priorities regular expressions renamings aliases modules combines definition lexical context free syntax formalism 
syntax definition page taken visser presents syntax small untyped order functional programming language data type environments evaluation function interprets functional programs instantiation environments data type 
program language contain definition function map applies function elements list function map nil nil cons call head map tail sketch main features sdf syntax definition running example 
context free productions basis formalism formed context free productions 
rules form ff ff list symbols symbol 
production declares string category constructed concatenating strings categories instance production fun terms 
term defines term constructed means function symbol followed list terms separated commas parentheses 
conventionally overview sdf context free productions written ff ff 
sdf productions written way similarity function declarations apparent 
useful sdf definitions signatures algebraic specifications productions correspond algebraic operators 
example conventional signature declare evaluation function computes value term respect program environment means function declaration eval program term env 
term production eval program term env 
term defines function input types syntax applications program argument enclosed double square brackets term argument enclosed parentheses 
character syntax definitions describe languages consisting strings characters set characters encoded finite set consecutive natural numbers 
character classes compact descriptions sets characters typically definition lexical categories layout identifiers numbers 
example contains character classes characters space tab newline characters newline uppercase letters lowercase letters letters digits hyphen character za 
literals literals strings characters double quotes stand exactly string characters 
represent keywords function program operators literal symbols 
definition function eval quotes function name 
exception general rule identifiers starting lowercase letter literals 
sorts basic nonterminal symbols productions sorts written identifiers starting capital letter 
sorts declared sorts section 
example defines sorts var fun term regular expressions complex nonterminal symbols formed means regular expressions provide abbreviations tupling iteration optional constructs alternatives example za denotes list zero characters set letters digits hyphens term declares list terms separated commas expression key 
value denotes lists zero tuples consisting key symbol value 
family syntax definition formalisms aliases regular expressions quite tedious type useful introduce shorter name symbols 
done introducing symbol alias 
example declaration aliases term 
terms introduces terms alias regular expression term 
priorities productions sensible type syntactically ambiguous 
instance productions destructive consistent environment update env 
env 
env env env 
env ambiguous respect environment expression env 
env env constructed env 
env env env 
env env 
associativity priority declarations way resolve ambiguities type 
example ambiguity expressions resolved means priority declaration env 
env 
env env env 
env declares higher priority entails env 
env env interpretation 
left attribute production declares operator left associative 
lexical context free syntax phrases making string language usually divided lexical tokens words sentence context free phrases 
distinction tokens phrases tokens making phrase separated layout whitespace comments characters comprising token 
definitions distinction indicated means lexical context free productions 
example lexical definition za 
fun indicates function symbols consist number adjacent characters starting lowercase letter followed zero letters digits hyphens 
tokens term succ zero separated spaces characters token succ 
layout occur tokens specified 
symbol layout reserved purpose 
example layout declared 
layout 
layout meaning spaces tabs newlines called whitespace layout suffix line starting percent signs comment 
overview sdf module functional programs exports sorts var fun term program aliases term 
terms var 
vars lexical syntax 
layout 
layout za 
var za 
fun context free syntax var 
term fun terms 
term function fun vars term 
program 
program module environments exports sorts key value env context free syntax key 
value 
env env key 
value env 
env 
env left env env 
env left env 
env bracket context free priorities env 
env 
env env env 
env module function eval imports functional programs environments key 
var value 
term exports context free syntax eval program terms env 
terms sdf definition syntax small functional programming language main evaluation function 
modules grammars divided number modules parts grammar reused various language definitions 
modules consist list exports hiddens sections 
import module module denotes inclusion exported grammar import module terms module functions means syntax terms included syntax programs 
prevent name clashes instantiate generic modules family syntax definition formalisms renamings symbols productions applied imported modules 
example module function eval specifying evaluation function imports generic module defining environments means imports environments key 
var value 
term renaming sort key var sort value term instantiating terms functional programming language 
modules parameterized list parameter symbols instantiated import 
instance module environments declared module environments key value declaring key value parameters 
import imports environments var term perform instantiation 
complete syntax definition consists list modules designated top module 
language defined definition defined grammar associated top module 
course programming environment sdf list reside single file 
module defined file module name file name 
design chapters give formal algebraic specification syntax semantics sdf 
semantics syntax definition characterized formed trees generates 
tree associated sentence yield 
language associated definition set sentences yields trees generated definition 
parser function sentence produces tree set trees sentence yield 
describe parsing part specification sdf specify output required parser allow implementation 
parsing sdf grammars described visser 
modularization formalism sdf designed modularized family formalisms 
kernel family formed context free grammars 
features defined independent extensions kernel 
combination features forms sdf 
setup easier construct variant formalism adding removing modifying features 
depicts structure family means abstraction import graph specification 
furthermore specification sdf covers aspects 
syntax formalism consists definition form constructs 
projection functions constructs defined order extract information 
normalization functions transform syntax definition order simplify 
specification parse trees consists parts 
generic format representation structured data called aterms van den brand design kernel character classes sorts literals priority basic regular modular alias labels restrictions sdf grammar symbols import graph definition sdf 
represent parse trees 
order format specific purpose constructor names defined 
represent grammar information parse trees constructs formalism encoded aterms 
framework formedness tree respect grammar defined 
furthermore yield trees equality trees defined 
feature number modules defined define aspect formalism feature 
result matrix modules listed table 
rows matrix contain modules feature 
columns matrix contain modules aspect 
module matrix name consisting name feature name aspect separated sdf 
instance module kernel sdf syntax specifies syntax constructs kernel 
feature modules sdf syntax sdf projection sdf normalization sdf renamings sdf constructors sdf aterms sdf trees sdf equality 
family syntax definition formalisms syntax projection normalization renaming constructors aterms trees equality symbols grammar kernel sorts cc literals priority regular basic restrictions renaming alias modular label sdf table modules family syntax definition formalisms 
row contains collecting modules sdf 
collection modules rows 
numbers refer sections presenting modules 
exception feature change aspect module omitted 
normalization important role design sdf played normalization function 
general normalization function defines transformation expression yields expression language uses features 
normalized expression meaning original 
normalization mapping language subset language 
ideally normalization function idempotent yield result applied twice 
implementation language consider simplified expressions users expressive language disposal 
requirement normalization produces expression language entails constructs encodings original language language closed normalization 
example normalizations definition renames symbol ha lexi occurs lexical syntax 
constructor lexi introduced purpose normalization construct language normalization 
consideration definition normalization different expressions equivalent respect semantics organization normal form 
useful expressions compared 
example case normalization character classes 
visser normalization character classes unique normal forms defined character classes represent set characters normalized character class expression 
general normalizations property 
instance permutations list productions equivalent 
lists ordered imposing ordering productions done comparisons lists productions needed 
cases definitions syntactic equality determine equivalence 
approach sdf expressive formalism depends small set features sdf context free grammars priorities character classes reject productions follow restrictions features provided formalism eliminated expressed features literals regular expressions lexical context free syntax variables modules renamings aliases 
furthermore character classes priority declarations grammar composition simplified considerably 
normalization sdf defined pipeline normalizations illustrated 
modularization definition normalization easy define extension express existing features new normalization function 
normalization extended adding new function normalization pipeline 
organization chapters discuss specification family syntax definition formalisms basis sdf 
chapter defines context free grammars basic symbols sorts character classes literals defines formed parse trees characterized grammar 
chapter defines disambiguation means priorities regular expressions lexical context free syntax restrictions lexical disambiguation 
chapter introduces renamings aliases modules 
chapter extensions combined formalism sdf 
formalism compared sdf discussion possible improvements extensions 
appendix gives auxiliary modules specification sdf 
family syntax definition formalisms sdf sdf nf modular extract complete grammar selected module basic merge lexical context free syntax alias expand aliases regular define regular expressions means extra productions priorities normalize priority declarations literals define literals terms character classes kernel merge productions cc order character classes grammars order grammar sections sdf define normalize normalization sdf definitions consists series independent transformations 
step performed transformation function rewrite rules acting constructors 
context free grammars chapter context free grammar formalism defined 
framework symbols grammars introduced 
framework grammar interpreted means predicates functions characterize trees strings symbols generated grammar 
formedness predicate parse trees characterizes trees grammar 
parse trees grammar strings language defined grammar derived 
parse trees represented annotated term format aterms 
instance framework set kernel context free productions 
introduce kinds basic symbols productions sorts character classes literals 
symbols syntax definitions define languages sets strings symbols 
string symbols list zero symbols 
sort symbol declared specifying constructors 
entails sort empty point extended constructors 
distinction terminal nonterminal symbols 
symbol terminal nonterminal symbol determined interpretation fixed syntactically 
symbol plays role terminal view nonterminal view 
example literal considered terminal token nonterminal defined terms characters 
module symbols imports layout exports sorts symbol symbols context free syntax symbol symbol symbol symbols variables abc symbol symbol symbol context free grammars projection function concatenates strings gives length string 
predicate decides list membership 
module symbols projection imports symbols booleans integers exports context free syntax symbols symbols symbols symbols int symbol symbols bool equations concatenation length membership symbol lists 
ff fi ff fi ff ff ff ff ff concatenation function sorts symbols needed concatenation built associative lists symbol asf sdf inherited injection symbol symbol 
injection needed list sorts output sorts functions asf sdf 
sets lists symbols construct sets symbols means operation constructor remove double elements list signifies number occurrences list matter 
operations sets union difference membership 
union ae ae adds elements ae ae occur ae set constructed means union singleton sets resulting set contain double elements 
strictly necessary useful done symbol set 
module symbol sets imports symbols projection booleans exports sorts context free syntax symbols symbol bool grammars priorities variables ae equations membership fffg ff union fg ae ae ae fg ae fff fi ae fff ffi ae fag ae ae ae fag fffg fa ffg difference fg ae fg ae fg ae fff fi ae fff ae ffi ae fag ae fg ae fag ae fag grammars syntax definition consists grammar 
generic operations grammars define point associative composition operation combine grammars constant representing empty grammar 
module grammar syntax imports layout exports sorts grammar context free syntax grammar grammar grammar grammar grammar grammar variables grammar interpretation grammar defines set strings symbols language 
specify language derived grammar indirectly trees generates 
parse trees represented means aterms term format representation context free grammars exchange structured data van den brand 
format introduced 
fact just define parse trees parse forests 
parse forest compact encoding collection parse trees contexts shared 
parse forest represent parse trees ambiguous sentence 
interpretation grammar predicates function 
predicate characterizes terms formed parse forests grammar function yield maps parse tree string symbols 
predicate determines membership tree forest set trees generated grammar denoted 
functions derive notion language generated grammar notion parser grammar 
language generated grammar corresponds set yields parse trees generates 
words string symbols ff element language defined grammar exists formed tree grammar ff yield 
parser pi ff function maps string ff parse forest containing formed trees yield ff 
module summarizes definitions 
equations define set parse trees language parser pi terms formedness yield parse forest membership 
module grammar interpretation imports grammar syntax symbols booleans aterms symbols sets aterm sets exports context free syntax grammar aterm bool aterm aterm bool yield grammar aterm symbols grammar atermlist grammar pi grammar symbols aterm equations yield ff ff yield ff pi ff note equations non constructive provide decision procedures merely specification required behaviour 
module symbols sets defines sets strings symbols similar way sets symbols defined module symbol sets 
context free grammars kernel overview rest chapter provide specifications formedness yield forest membership context free grammar formalism 
define syntax normalization context free productions 
define basic symbols grammars sorts character classes literals 
define formed parse trees generated contextfree grammar 
chapters formalism extended number features 
implementation parser specified chosen comply specification 
possible implementation discussed visser 
context free grammars kernel syntax kernel sdf formed context free grammars 
context free production structure ff ff list symbols symbol 
context free grammar formed list productions preceded keyword syntax 
conventionally chomsky context free productions written ff emphasize generative view grammars 
grammar generates string symbol repeatedly replacing symbol string symbols right hand side production 
exist variants standard notation ff bnf backus ff jff yacc johnson 
unconventional ff notation productions introduced heering 
emphasizes functional view productions context algebraic specification 
production coincides declaration name type function 
notation unification definition context free productions declaration mixfix functions algebraic specification formalisms 
example declaration infix addition operator natural numbers declared nat nat nat bnf declared op nat nat 
nat obj futatsugi nat nat nat elan vittek 
sdf nat nat 
nat 
notations equivalent expressive power current 
effortlessly define version sdf uses ff notation bnf define meaning translation notation 
note mean aspects formalisms expressive power parsing techniques coupled formalisms power 
optionally productions list attributes 
attribute annotation production gives extra syntactic semantic information production 
example attribute introduced left indicates left associativity production 
productions number attributes 
kernel provide attributes able introduce attributes having introduce extra constructor productions attribution production defined 
context free grammars module kernel sdf syntax imports symbols grammar syntax exports sorts attribute attributes production productions context free syntax attributes attributes symbols symbol attributes production production productions syntax productions grammar variables attr attribute attr attr attributes production production production projection define concatenation functions lists productions lists attributes 
concatenation function attributes removes duplicates 
production empty list attributes equal production attributes 
projection function gives productions grammar function gives non production parts grammar defined function pa gives productions defining symbol function symbols gives set symbols grammar 
function reachable gives productions reachable set symbols definition symbols 
module kernel sdf projection imports kernel sdf syntax symbol sets exports context free syntax productions productions productions attributes attributes attributes production productions bool productions productions bool production production bool grammar productions grammar grammar symbol productions productions symbols productions symbols grammar reachable productions productions reachable grammar grammar equations context free grammars kernel concatenation lists productions membership subset list productions 
concatenation attribute lists 
attributes lists added 
fattr attr fattr fattr fattr fattr fattr attr attr fattr attr attr fattr fattr attr fg equation states empty list attributes fg equal attributes 
productions similar attributes ff ff function gives productions grammar function gives parts grammar 
function pa gives productions defining symbol syntax syntax ff ff function symbols gives set symbols list productions grammar 
symbols fg symbols ff fffg fag symbols symbols syntax symbols symbols symbols symbols symbols fg function reachable gives productions reachable set symbols ae 
defined applying auxiliary reachable context free grammars function productions grammar 
observe resulting grammar composition reachable productions non production parts grammar 
auxiliary function selects symbol original set productions symbol original grammar 
applied recursively symbols left hand sides productions 
set argument auxiliary function represents symbols handled 
second set contains symbols productions looked 
reachable ae syntax reachable fg ae reachable ae fg ae symbols ae ae reachable ae fa ffg reachable ae fag ae fffg reachable ae fa ffg reachable ae fffg normalization grammar normalization composition grammars commutative empty grammar unit grammar composition 
commutativity expressed means terminating rewrite system module normalizes grammar compositions right associative list grammars ordered merged specified operation 
yields pair hg means composition replaced definition merge grammars yielding pair hg exchange grammars yielding hg termination normalization depends property swap undone 
definition extended new grammar constructor 
example merging productions adjacent syntax sections expressed module 
ordering defined directly grammar composition operator entail equations written pair constructors merged swapped corresponding equations 
module grammar normalization imports grammar syntax exports sorts grammar grammar context free syntax grammar grammar grammar grammar grammar grammar grammar grammar equations empty grammar unit composition composition associative 
basic symbols swapped specified function 
hg hg context free grammar normalization normalization function kernel merges productions arguments result symbols 
productions different attributes joined 
normalization entails occurrences production identified cause ambiguity 
consequently normalization functions generate production changing meaning grammar 
strategy relevant introduce modularization grammars 
identification productions means production declared different modules identified modules imported module 
module kernel sdf normalization imports kernel sdf projection grammar normalization exports context free syntax grammar grammar merge productions productions equations empty list productions equivalent empty grammar multiple syntax sections merged 
syntax syntax syntax normalization function merges productions arguments result auxiliary function merge 
syntax merge ff ff ff merge merge merge basic symbols kernel formalism previous section complete definition context free grammars notation symbols 
section extensions kernel provide notation basic symbols needed syntax definition 
sorts represent non terminals grammars categories domains grammar introduces 
character classes represent terminals grammars characters strings context free grammars built 
literals convenient abbreviations fixed strings characters 
extensions complete notation context free grammars 
extensions sections provide features formalism expressive 
sorts syntax sorts symbols represent basic domains categories syntax definition 
sort identifier word starting uppercase letter followed zero letters digits 
hyphens character 
sorts productions grammar declared separate sorts section consists keyword sort list symbols 
module sorts sdf syntax imports kernel sdf syntax exports sorts sort lexical syntax sort za gamma za sort context free syntax sort symbol sorts symbols grammar variables sort normalization ordering sorts syntax sections sorts placed syntax sections merging sorts sections 
module sorts sdf normalization imports sorts sdf syntax kernel sdf normalization equations sorts sorts ff sorts fi ff fi syntax sorts ff ff syntax projection projection function gives list sorts grammar 
module sorts sdf projection imports kernel sdf projection sorts sdf syntax exports context free syntax grammar symbols equations declared sorts grammar 
sorts ff ff basic symbols character classes character class expression example denotes set characters case set lower case letters prime 
example definition defines identifiers lists characters starting lowercase letter followed zero lowercase letters digits 
sorts id syntax 
id id 
id meaning character classes defined terms productions characters effectively eliminating formalism 
instance character class completely defined productions form 



cause enormous increase number productions 
interpretation character classes defined translating character classes language 
means interpretation functions extended character classes 
give complete specification character classes character class 
full specification character classes visser 
normalization defined ensures classes contain elements normal form 
characters character constant form nd dn decimal digits denoting dn th member finite linearly ordered universe characters 
specifying characters index encoding scheme difficult provide easier syntax specification characters 
alphanumeric characters letters digits specified 
visible characters ascii set specified escaping backslash left parenthesis hyphen backslash followed space space 
characters represent tabs newlines 
special characters eof top 
eof character indicate represent file 
top represent largest character character universe 
module character syntax imports layout exports sorts character lexical syntax za za mo su context free syntax character character top character eof character variables context free grammars character character classes set characters character class represented list characters character ranges square brackets 
list constructed injection characters lists right associative binary concatenation operator lists 
operations character classes difference intersection union complement respect complete character set characters range top 
module character class syntax imports character syntax exports sorts charclass context free syntax character character gamma character charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass priorities charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass charclass variables cr cr cr cc charclass syntax kernel formalism extended adding character classes symbols 
module cc sdf syntax imports character class syntax kernel sdf syntax exports context free syntax charclass symbol normalization character classes normalized unique normal form ordering ranges characters translated numeric equivalent smaller characters larger characters fusing adjacent overlapping ranges 
example class basic symbols normal form numerical representation overlap ordered 
normalization specified module character class normalization visser 
module cc sdf normalization imports cc sdf syntax character class normalization kernel sdf normalization literals literals abbreviations fixed lists characters 
example production uses literals define keywords conditional statement 
exp stat stat 
stat meaning literals expressed means production specifies sequence characters literal 
instance meaning literals expressed productions 


literals identifiers starting lowercase letter specified double quotes 
useful abbreviation category definition syntax prefix functions form add nat nat 
nat abbreviation add nat nat 
nat syntax literals consist list characters double quotes 
complete syntax literals see xa 
literals start lowercase letter written quotes name literals 
prefix functions declared means special form productions double quotes parentheses commas omitted 
module literals sdf syntax imports kernel sdf syntax literals exports sorts lexical syntax za gamma za context free syntax literal literal symbol literal symbol attributes production context free grammars normalization normalization function generates defining production literal symbol productions grammar 
module literals sdf normalization imports literals sdf syntax cc sdf normalization exports context free syntax grammar grammar literals productions chars literal symbols symbols symbols variables char char char literal fl fl equations literals translated quoted literals 
literal function generates production literal symbol grammar 
production generated literal form ff ff list singleton character classes representing characters list produced function chars 
syntax literals symbols literals flg chars literals fag literals fg literals fff fi literals fff literals ffi function chars scans characters literal string translating short characters 
normalized numeric character codes character normalization 
third equation tries character string short character normalizing testing reduced numeric character 
works letters digits 
fails fourth equation translates character escaped short character succeeds characters 
characters escaped handled second equation 
chars cc chars literal cc chars literal cc cc chars literal cc chars literal parse trees cc ff chars literal chars literal cc ff prefix function productions translated normal productions enclosing parentheses commas double quotes 
fl symbols fl symbols symbols symbols fl fl symbols fl symbols fl parse trees define interpretation grammars formed trees characterized grammar yield trees 
general idea context free production constructs trees type labeled production list direct descendants type trees represented means terms 
constructor appl builds application production list trees tn trees type appl tn tree type parse forests constructed representing choice nodes ambiguity nodes means constructor amb 
tn trees type amb tn ambiguity node type formally define notion trees introduce notion terms 
generic term format encode parse trees encoding symbols grammars format 
tools place define formedness rules 
term format van den brand 
introduce generic annotated term format aterms representation exchange structured data 
format designed kinds data represented single fixed format purpose exchanging data tools providing generic operations data 
definition format comes extensive library higher order functions 
aterm format represent parse trees 
syntax aterms defined module aterms 
terms constructed means constructors aterm constant integer constant real number constant 
list terms atermlist empty list terms separated commas square brackets tn 
sort aterms represents lists terms separated commas 
function symbol afun 
context free grammars application function symbol list terms separated commas 
furthermore constructors annotated list terms ann 
literals strings characters double quotes 
integer constants lists digits real constants floating point numbers optional exponent 
syntax literals integers reals see van den brand 

module aterms imports literals exports sorts aterms atermlist afun aterm ann context free syntax aterm aterms aterm aterms aterms atermlist aterms atermlist literal afun aterm atermlist aterm afun aterm afun aterms aterm aterms ann ann aterm atermlist ann aterm afun ann aterm afun aterms ann aterm variables ts aterms tl atermlist afun afun aterm ann ann constructors parse trees function symbols literals strings characters double quotes identifiers 
specification identifiers included aterm format 
application aterms appropriate set declared requirement restricted names form za 
representation grammars symbols productions trees define function symbols 
module kernel sdf tree constructors imports grammar tree constructors exports context free syntax prod afun parse trees attrs afun attrs afun atr afun syntax afun appl afun amb afun function symbols appl amb represent parse trees 
encoding grammar structures 
extension kernel adds new constructors symbols grammars add corresponding aterm function symbols 
included xa 
aterm encoding encode symbols grammars productions terms 
sort function aterm aterm defined encodes expressions aterms 
encoding injective 
sort decoding function aterm defined aterm illustrates encoding symbols productions aterms 
module defines encoding lists symbols 
encoding constructors symbols defined module extension kernel see xa 
module symbols aterms imports symbols projection aterm lists exports context free syntax aterm symbol aterm atermlist symbols atermlist symbol aterm symbol symbols atermlist symbols equations encoding lists symbols 
atermlist aterm atermlist ff ff atermlist ff fi atermlist ff atermlist fi decoding lists symbols 
symbols symbols symbol symbols ts symbol symbols ts requirement symbol aterm equation requires definition decoding encoded symbol gives original symbol 
context free grammars production symbol symbols attributes prod 
tree trees aterm production symbol symbols attributes appl 
amb atermlist aterm aterm aterm encoding symbols productions parse trees fixed term format 
grammar domains symbol production mapped dotted arrows subsets set aterms 
parse trees subset aterms formed constructor appl production list trees constructor amb list trees 
parse trees encoding productions module defines encoding productions 
example consider production exp exp 
exp left encoded prod sort exp lit sort exp sort exp attrs atr left production represented function symbol prod attributes production represented attrs 
note encoding sort literal symbols defined xa 
module kernel sdf aterms imports kernel sdf projection kernel sdf tree constructors symbols aterms grammar aterms aterm lists exports context free syntax aterm production aterm aterm attributes aterm atermlist atermlist aterm attribute aterm atermlist productions atermlist production aterm production attributes aterm attributes attribute aterm attribute productions atermlist productions equations encoding productions attributes 
aterm ff prod atermlist ff aterm aterm aterm attrs aterm fattr attrs atermlist attr atermlist attr fattr fg atermlist attr aterm attr atermlist attr attr atermlist attr atermlist attr decoding productions attributes 
production prod tl symbols tl symbol attributes attributes attrs attributes attrs tl attributes tl attributes fg attributes attributes ts attributes ts requirement attribute aterm attr attr context free grammars encoding grammars lists productions 
aterm syntax syntax atermlist atermlist aterm atermlist atermlist atermlist atermlist decoding grammars lists productions 
grammar syntax tl syntax productions tl productions productions production productions ts production productions ts formed parse trees prepared equipment characterization terms represent formed parse trees grammar 
predicate determines tree formed respect grammar defined terms checks tree type tree contains type information explicitly form productions checked grammar 
formedness respect grammar defined checking productions tree productions grammar 
main constructor trees function appl creates application context free production list trees types argument trees correspond symbols left hand side production 
example consider grammar sorts syntax 

left aterm formed parse tree grammar sentence appl prod sort lit sort sort attrs atr left appl prod char class range sort attrs appl prod char class lit attrs appl prod char class range sort attrs parse trees observe main appl aterm encoding production 
argument second argument list trees types correspond arguments production 
numbers leafs trees denote ascii values characters denotes denotes denotes context free grammars ambiguous generate tree single sentence 
constructor amb introduced represent parse forests compact representations sets parse trees 
term amb tn represents set parse trees containing terms tn contain amb nodes 
example string ambiguous respect grammar sorts syntax 

parse forest represents possible parses left associative right associative 
amb appl prod sort lit sort sort attrs appl prod sort lit sort sort attrs sort lit sort lit sort appl prod sort lit sort sort attrs sort lit appl prod sort lit sort sort attrs sort lit sort note order reduce size term subtrees symbols 
tree represents parse tree sentential form 
yield tree concatenation characters leafs tree 
instance yield tree list characters module kernel sdf trees imports kernel sdf aterms kernel sdf projection exports context free syntax grammar aterm bool aterm aterm bool yield grammar aterm symbols context free grammars args aterm atermlist type aterm aterm aterm productions variables prod aterm res aterm attrs aterm args atermlist equations term formed parse tree grammar formed tree productions productions type tree formed 
function gives productions term list productions applications 
appl prod args production prod args amb args args ts ts definition need auxiliary functions terms 
function args gives arguments production 
type production result type 
type application result type production 
args prod tl res attrs tl args appl prod args args type prod tl res attrs res type appl prod args type prod type amb ts type ts application formed term type type production arguments formed terms types correspond argument types production application 
type prod args args prod appl prod args list trees symbols formed element formed 
ts ts ts ts parse trees ambiguous node formed possibilities type 
amb amb ts amb ts symbol term formed tree type represent trees sentential forms 
symbol symbol yield term concatenation leaf symbols 
yield appl prod tl yield tl yield amb tl yield tl yield yield yield yield ts yield yield ts yield symbol trees characters literals previous section defined character classes literals symbols grammars 
meaning literals defined terms character classes means context free productions definition formedness parse trees need extended literals 
character classes extend definition character tree type character class contains parse tree formed tree character class type character represented natural number element character class 
example term appl prod sort id char class range sort id attrs appl prod char class range sort id attrs formed parse tree identifier ab 
definition formedness yield extended follows module cc sdf trees imports cc sdf aterms kernel sdf trees character class normalization equations character represented integer 
characteristic functions trees extended new tree constructor 
type character character code 
yield character character class containing single character 
character contain productions 
type context free grammars yield character character code formed tree type represents character class contains character corresponding symbol cc character cc cyclic parse forests grammars generate infinitely parse trees single string 
instance grammar syntax 


generates infinitely trees string collection parse trees strings grammars finitely represented means cyclic parse forest lang rekers 
term format defined provisions cyclic forests 
parser sdf visser generate cyclic parse forest 
asf sdf cyclic structures expressed natural way 
simulated explicitly representing pointer structure means table tags represent 
complicate entire specification 
application sdf mainly grammars gone trouble defining cyclic forests asf sdf 
equality trees define equality predicate parse trees 
point comes syntactic equality 
extend predicate trees syntactically equal equal 
useful certain details parse trees 
instance introduce parse trees containing layout 
useful applications aware layout 
applications want specific layout tree consider trees equal layout 
application equality trees associative operators list concatenation 
definition equality predicate intended specify details equality considerations 
furthermore define membership tree parse forest 
module kernel sdf equality imports kernel sdf trees exports context free syntax aterm aterm bool aterm aterm bool parse trees equations equality applications 
productions applications equal argument lists 
args args appl prod args appl prod args argument lists equal elements pairwise equal 
ts ts ts ts ambiguity node equal tree possibilities contained tree vice versa 
amb ts amb ts amb ts amb ts amb ts amb ts cases apply terms equal 
tree member parse forest tree containing ambiguities contained possibilities ambiguity 
amb amb ts amb ts ambiguity contained forest possibilities contained forest 
amb amb ts amb ts application contained application arguments contained arguments second 
args args appl prod args appl prod args lists context free grammars ts ts ts ts cases apply membership hold disambiguation abbreviation chapter features disambiguation ambiguous grammars abbreviation common patterns 
priorities disambiguate ambiguous expression syntax providing support compact syntax 
priorities defined means extension formedness predicate parse trees 
regular expressions abbreviate common patterns productions lists optional constructs alternatives regular expressions defined generating defining productions expression grammar 
lexical context free syntax sections separate definition tokens phrases 
integrated single context free grammar normalization interference levels created 
furthermore definition placement layout tokens handled normalization 
follow restrictions reject productions provided express lexical disambiguation rules prefer longest match prefer literals 
priorities context free grammars ambiguous 
methods disambiguation context free grammars 
programming language oriented formalisms provide kind precedence method 
adopt method disambiguation associativity priority sdf 
new respect design priorities heering 
disambiguation lexical syntax lexical priorities uniform notation priority declarations derivation productions priority declarations provides compact notation avoiding multiple declarations productions 
feature sdf abbreviation productions priority declarations list literals left hand side 
example abbreviation 

reason omission unclear semantics combination modularization 
priority chains included sdf expressed chains 
define syntax projection functions normalization priority declarations 
describe extension formedness predicate parse trees characterizes parse trees priority conflicts 
example grammar defines priority associativity relations syntax expressions unary negation binary operators disambiguation abbreviation exponentiation multiplication addition subtraction 
note sdf syntax arithmetic operators defined inside priorities section 
syntax 
bracket priorities 

right 
left left 
assoc 
left grammar declares unary gamma higher priority higher priority binary higher priority binary gamma 
mutually left associative declared group associativity 
bracket production declares parentheses disambiguate expressions 
grammar expression ee interpreted ee 
syntax priorities section grammar defines priority relation productions associativity relations left right assoc non assoc 
priority declaration chain associativity declaration 
objects declarations single productions groups productions 
group associativity declares productions group mutually associative 
bracket attribute declares production form denoting syntax left right bracket identity function productions explicitly disambiguate text indicate different disambiguation priority rules 
module priority sdf syntax imports kernel sdf syntax exports sorts associativity group priority priorities context free syntax left associativity right associativity non assoc associativity assoc associativity bracket attribute associativity attribute production group productions group associativity productions group priority group associativity group priority priorities priorities priorities priorities grammar variables group gg gg pr priority pr pr associativity projection projection function pr yields list priority declarations grammar 
projection function pr yields grammar priority declarations 
module priority sdf projection imports priority sdf syntax kernel sdf projection exports context free syntax priorities priorities priorities pr grammar priorities pr grammar grammar priority priorities bool equations concatenation priority declarations 
pr pr pr pr priorities non priorities grammar 
pr priorities pr pr pr pr pr pr pr priorities pr pr pr pr pr membership priority declaration 
pair member declaration declaration contains pair similar productions 
recall productions similar attributes may different 
pr pr pr pr pr pr disambiguation abbreviation normalization complex syntax priority declarations expressed means binary declarations relation associativity relations follows priority chains form pn normalized lists simple priorities form relation closed transitively 
associativity declarations attributes group expressed binary associativity declarations form 
productions mentioned priorities sections added syntax section grammar 
example normalization grammar example page syntax 

right 
left 
assoc 
left priorities 

right 
right right 
right 
right 
left 
left 
assoc 
left 
left 
left left 
left 
assoc left 
left 
assoc assoc 
assoc 
left left 
left observe productions mentioned priorities declaration declared productions syntax part 
furthermore chain binary relation transitively closed 
associativity attributes expressed means binary declarations 
module priority sdf normalization imports priority sdf syntax booleans kernel sdf normalization priority sdf projection exports context free syntax grammar grammar assoc grammar priorities assoc productions priorities syntax priorities grammar norm priorities priorities trans priorities priorities equations normalization function extracts syntax information priorities priority information syntax normalizes priorities declarations takes transitive closure 
pr pr norm pr pr pr syntax pr priorities trans pr assoc priorities function norm normalizes priority declaration list pairs form eliminating chains groups 
norm 
norm priority declarations list normalized 
norm norm norm pr pr norm pr norm pr chain broken binary declarations 
transitive closure defined ensures specified 
norm gg gg gg norm gg gg gg gg groups priority 
group abbreviation pointwise extension declared relation members group 
norm fpg norm fg 
norm fg norm fp 
norm fp 
fp 
norm fp norm fp 
fp norm fpg 
norm norm fpg norm norm fas 
norm fas fp 
norm fas norm fas 
fp groups associativity 
norm fg norm norm fp norm fp norm fg norm norm fp norm fp norm fas norm fas fp norm fas norm fas fp associativity groups abbreviations 
members associativity group mutually associative respect declared relation 
group contains single production taken define associativity production 
defined members group defined 
possible instance production left associative respect respect group productions 
norm fas pg norm fas norm fas norm fas fas function trans takes transitive closure relation 
pr pr pr pr pr pr pr trans pr trans pr disambiguation abbreviation trans pr pr pr pr pr trans pr pr pr pr trans pr pr function assoc derives associativity declarations productions grammar 
productions attribute declaring left right non associative produce declaration associativity priorities declaration 
assoc assoc assoc assoc assoc assoc assoc ff fattr attr assoc function syntax derives priorities declaration list productions referred declaration 
syntax syntax pr pr syntax pr syntax pr syntax syntax syntax syntax merging ordering grammars 
priorities priorities pr priorities pr pr pr priorities pr syntax priorities pr parse trees priority conflicts extend notion formedness parse trees formedness grammar priorities 
tree formed formed context free tree contain priority conflicts 
module priority sdf trees imports kernel sdf trees priority sdf projection exports context free syntax grammar prio aterm bool conf priorities aterm bool priorities production atermlist bool left priorities production aterm bool middle priorities production atermlist bool right priorities production aterm bool equations introduce extension notion formedness 
tree wellformed respect priorities grammar formed priorities respect grammar contain priority conflict 
conf pr prio application conflict root conflict descendants conflict 
pr production prod args conf pr args bool conf pr appl prod args bool constructors tree conflict descendant 
conf pr amb conf pr conf pr amb ts conf pr conf pr amb ts conf pr conf pr conf pr conf pr ts conf pr conf pr ts application descendants conflict 
pr application descendant root conflict left conflict middle conflict right conflict 
pr ts left pr middle pr ts injection application child root conflict production higher priority child production 
production prod pr bool pr appl prod args bool tree left conflict productions root left child mutually right associative non associative root production higher priority child production 
production prod right pr non assoc pr pr bool left pr appl prod args bool left child node tree conflict left conflict possibilities ambiguity 
left pr amb left pr left pr amb ts left pr left pr amb ts tree middle conflict root production higher priority middle child productions 
production prod pr middle pr ts bool middle pr appl prod args ts bool disambiguation abbreviation middle pr right pr middle pr amb ts middle pr ts middle pr ts middle pr amb ts ts bool middle pr amb ts ts bool tree right conflict productions root right child mutually left associative non associative associative synonym left root production higher priority child production 
production prod left pr assoc pr non assoc pr pr bool right pr appl prod args bool case ambiguity right child 
right pr amb right pr right pr right pr amb ts bool right pr amb ts bool discussion described requirements parse trees parser produce containing priority conflicts 
various ways implement requirement 
possible scheme discussed klint visser interpret priority rules filter parse forests prunes subtrees conflicts 
scheme parser current asf sdf meta environment heering klint :10.1.1.28.6239
advantage approach disambiguation decoupled parsing disambiguation filters added 
drawback approach parse forest large hampers efficiency 
applying priority rules early possible parsing process increase efficiency 
parser generation time interpretation priorities described visser 
priorities completely expressed parse tables produced parser generator 
implementation method discussed visser 
disambiguation methods disambiguation priority conflicts similar methods precedences earley aho 

describe method interpreting rules parser generation process general visser 
disambiguation priorities defined section definition priorities heering 

definition second interpretation priorities defined 
parse trees interpreted multi set productions priorities interpreted ordering multi sets 
ordering regular expressions selection trees filtering priority conflicts solve ambiguities 
subtree exclusion disambiguation method introduced thorup works specifying finite set partial parse trees forbidden subtrees parse trees yielded parser 
method allows fine tuned disambiguation achievable priority scheme 
examples disambiguation generic operators internal arguments 
problems solved appropriately 
ambiguity solved way priorities correct 
klint visser disambiguation methods studied framework filters parse forests 
brackets unparsing complicated presence priorities 
parse tree created semantics processor rewriter instance create formed tree satisfy prio predicate contains priority conflict 
trees semantically meaningful problematic yield considered 
naively translating syntax tree string described lead string parsed represent tree contain conflicts 
force equivalence tree string brackets introduced 
van den brand visser rules priority conflicts place brackets unparsing syntax tree 
regular expressions certain patterns context free productions occur 
examples patterns lists lists separators optional constructs alternative 
example list identifiers specified grammar syntax id 
id list id list id list 
id list left list defined terms constructors singleton lists concatenation lists 
formalisms provide shortcuts patterns extending language context free grammars collection regular operators symbols 
instance bnf provides alternative level productions production form jan symbol meaning 
extended bnf ebnf canonical extension bnf regular operators 
formulation wirth adds operators fag iteration optionality 
variations notation appear lee williams 
sdf provides iteration fa lg phi iteration abbreviation lists separated literal section give extension context free productions set regular operators symbols 
approaches mentioned regular operators special treatment 
new formulation treatment regular operators class citizens 
constructors new symbols spare specifier burden having invent new names 
consequence regular expression occur positions normal symbol occur particular right hand side production 
disambiguation abbreviation approach motivated considerations enables express meaning regular expressions means normalization grammar adds defining productions expression 
grammars function signatures algebraic specifications production represents function 
regular symbols result functions case sdf define auxiliary symbol define function yields result 
example suppose want define function add adds integer integer list integers 
syntax write add int int 
int sdf introduce auxiliary sort intlist represent result sort function 
syntax consider operators empty symbol represents empty string concatenation symbol denotes concatenation expressions type alternative symbol jan denotes expression types optional symbol 
optional iteration symbol denotes list expressions type iteration separator symbol fa bg fa bg denotes list gamma expressions type separated expressions type observe sdf sdf limitation symbols separators 
example stat denotes lists statements separated semicolons newlines 
constrained iteration symbol denotes list expressions type similarly fa separator set expressions symbol set represents syntax set expressions form fa expressions type product symbol denotes tuples ha expressions type functions symbol denotes function expressions expressions type expressions type permutation symbol ae denotes expressions form exactly type regular expressions syntax operators defined module 
observe empty symbol sequences defined single production symbol symbol parentheses single symbol brackets see 
module regular sdf syntax imports kernel sdf syntax exports context free syntax symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol set symbol symbol symbol symbol symbol symbols symbol symbol symbol symbol symbol symbols ae symbol priorities symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol symbol normalization define normalization function regular expression grammar introduces productions define meaning 
interpretation regular expressions form shorthand defining extra symbols productions 
example production defines single production describing structure block program consisting optional declaration followed list statements 
syntax decl 
stat 
stat normalization grammar syntax decl 
stat 
stat 
decl 
decl 
decl 
decl 
decl stat 
stat stat stat 
stat left disambiguation abbreviation stat stat 
stat stat stat 
stat stat stat 
stat left 
stat stat 
stat priorities left stat stat 
stat left stat stat 
stat stat stat 
stat stat stat 
stat left stat 
stat see meaning operators expressed means extra productions 
observe regular expressions target symbols productions 
module regular sdf normalization imports regular sdf syntax priority sdf syntax literals sdf syntax kernel sdf normalization exports context free syntax grammar grammar symbols grammar alt symbol symbol grammar tup symbol symbols perm symbols productions perm symbols symbols productions equations function adds defining productions regular occurring productions grammar 
existing productions affected 
ff fffg symbols recall function symbols defined gives set symbols grammar 
function generates grammar regular expressions list symbols 
ff fi ff fi concatenation regular expression ff symbol abbreviates concatenation symbols ff 
syntax 
ff 
ff ff syntax ff note ff recursively produces productions regular expressions list symbols ff regular expressions alternative alternative ajb denotes define ajb yield productions ajb ajb 
alternatives alternative unnecessary chain ajb ajb created 

define alt function alt alternative symbol reached alternative 
alt alt alt alt syntax optional optional construct 
empty syntax iteration iteration operator denotes lists iteration denotes list zero ffl empty ways define lists productions 
sufficient define list means productions symbols right hand side production lists result arbitrary functions 
expression contain function calls variables 
instance grammar contains production yield tree 
symbol yield yield expression type symbol expression type tree 
rules composition list expressions 

single 

followed 

followed 

followed 

followed 
empty 

disambiguation abbreviation productions expressing rules generated equation 
priorities section declares concatenation operators mutually 
priority prevents empty production injection vacuously 
syntax priorities 
fp iteration separator iteration separator operators fa bg fa bg denote iteration separated 
meaning defined analogously fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg fa bg syntax priorities 
fa bg fa bg constrained iteration iteration operator denotes iteration 
define zero corresponds iteration corresponds iteration 
integers define terms fag gamma eventually productions form fag gamma 
fag fag gamma fag fag fag syntax fag constrained iteration defined similarly lists separators 
fa bg fa bg fa bg fa bg gamma fa bg fa bg fa bg syntax fa bg regular expressions tuples definition functions return tuple values new sorts invented 
give sensible types tuples notation introduced 
symbol denotes tuple expressions 
tuple written ht tn type tup ff ff syntax ff auxiliary function tup derives syntax body tuple separating symbols commas 
tup tup tup tup sets conventional notation sets list items operator set generates notation tn expressions type ft tng expression type set 
ff fa ff set set ff syntax functions convenient pass functions data 
operator ff give type functions 
denotes sort functions ff operator generates syntax prefix application function argument 
ff ff ff syntax ff permutation permutation symbol ff ae denotes concatenation symbols ff fi ff ae fi permutation ff 
ff ae syntax perm ff ff function perm generates productions permutations set symbols 
case permutation consists elements generates productions directly 
case elements function perm generate permutations 
perm ae perm ae perm ae ae perm ff perm ff ff symbol list production generated symbol permutation symbols 
perm ff ff fi ae ff fi ae perm ff fi perm ff fi perm ff fi disambiguation abbreviation observed efficient way implement permutation constructs 
adequate permutations elements 
needed addition generation productions normalization parse trees productions form lists elements fixed order semantic functions deal permutations 
cameron describes extension ll parsing permutation operators 
alternative approach suggested cameron intermediate symbol representing union symbols permutation check parsing symbol permutation represented exactly 
discussion handled regular expressions translating regular expressions 
instance optionality expressed means empty alternative equation 
ja 
specification chosen follow route 
cases involving constrained iteration 
equality parse trees lists new constructs expressed means existing constructs regular expressions expressed means generated context free productions need extend definition formedness parse trees 
extend definition equality trees 
definition lists equal modulo associativity concatenation operators 
basis matching modulo associativity 
give equations considered matching variable ranges constructs type ffl denotes tree constructed empty sublists units concatenation removed 
ffl ffl ffl ffl injections removed lifted concatenations 
right associative concatenations equal left associative ones 
expressions involves different concatenation operators 
lexical context free syntax syntax programming language usually divided levels lexical syntax context free syntax 
lexical syntax syntax tokens lexical context free syntax words language identifiers numbers keywords 
context free syntax syntax sentences language expressions statements type declarations function definitions 
division affects language definition implementation 
conventionally lexical analysis restricted grammars recognized finite automata context free analysis implemented push automata 
clear division motivated implementation inherent concept lexical syntax 
formalisms separation physical lexical context free syntax defined completely different formalisms written separate files 
instance yacc metal lex define lexical syntax 
means lexical definitions form number regular expressions defined separate file 
context free lexical definitions share declaration token symbols constitutes interface lexical context free level 
syntax definition formalism pccts uses lexical syntax similar lex provides mechanism include token definitions file context free syntax definition 
sdf lexical context free syntax integrated formalism uses different semantics 
approaches common distinction lexical context free syntax identified distinction regular context free grammars 
sdf inherent distinction categories contextfree symbols separated layout lexical symbols 
difference 
exact features available definition lexical context free syntax 
new approach provide uniform notation definition lexical context free syntax means context free productions 
grammars lexical context free syntax normalized contextfree grammars kernel 
distinction lexical context free syntax completely expressed resulting productions 
treating lexical context free syntax identically extension defined applicable 
instance defined priorities disambiguation 
heering 
defined context free syntax 
result approach provide lexical disambiguation priorities 
similarly regular operators introduced definition lexical context free syntax 
addition lexical syntax define variables 
variable schemes specification semantics language 
introduce notion lexical variables range constructs introduced lexical syntax grammars 
extension section called basic sdf covers basic idea original sdf integration lexical context free syntax formalism 
example definition introduces simple expression language variables addition 
sorts id exp lexical syntax 
layout disambiguation abbreviation 
id context free syntax id 
exp exp exp 
exp left variables 
id xyz 
exp lexical syntax section defines syntax layout spaces tabs newlines identifiers lists lowercase letters 
division lexical context free syntax entails whitespace occur expressions letters identifier 
illustrate power integration lexical context free syntax extend layout convention introducing comments consisting string comment words follows sorts comment lexical syntax 
context free syntax 
comment comment 
layout definition comments part context free syntax comment words separated layout including layout 
means specified nested comments useful commenting pieces code containing comment 
extend comments include syntactically correct expressions bars comment words 
context free syntax exp 
instance text expression denotes addition syntactically correct expression grammar denoting expression comment conventional setting separate scanner parser require call parser scanner 
application syntactically correct program fragments comments typesetting programs documentation 
typesetting algorithms applied real program text applied typesetting expressions comments program variables extended variables occurring comments 
syntax grammar constructors lexical syntax context free syntax introduce syntax lexical constructs context free constructs respectively 
grammar constructors variables lexical variables introduce syntax lexical context free syntax variables context free symbols variables lexical symbols respectively 
symbol constructors lexi cfi vari indicate lexical symbols context free symbols variable symbols respectively 
special symbol layout define layout 
module basic sdf syntax imports kernel sdf syntax exports context free syntax lexical syntax productions grammar context free syntax productions grammar variables productions grammar lexical variables productions grammar symbol cf symbol symbol lex symbol symbol var symbol layout symbol normalization normalization function defined expresses meaning lexical context free syntax merging single grammar 
avoid interference levels symbols lexical syntax renamed lexi symbols symbols context free syntax renamed cfi symbols 
ideas illustrated example 
example grammar example mapped grammar lexical context free syntax merged 
sorts id exp comment syntax lex 
id lex 
id lex 
id cf 
id cf 
exp cf 
exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
left 
id cf var 
id cf var 
id cf 
xyz 
exp cf var 
exp cf var 
exp cf 
lex 
lex 
lex 
cf 
layout cf 
exp cf 
layout cf 
cf 
layout cf 
cf 
layout cf 
comment cf 

layout lex 
layout lex 
layout cf 
comment cf 
layout cf 
layout cf 
layout cf 
layout cf 
left disambiguation abbreviation 
layout cf 
layout cf 
layout cf 
symbols lexical productions renamed lexi symbols 
symbols context free productions renamed cfi symbols 
connection lexical context free syntax injection ha lexi symbol corresponding ha cfi symbol 
module ideas formal introducing normalization function 
module basic sdf normalization imports basic sdf syntax regular sdf syntax priority sdf syntax kernel sdf normalization exports context free syntax grammar grammar aux grammar grammar symbols symbols production lex production productions productions grammar lex grammar symbols cfs symbols production cf production productions cfs productions grammar cf grammar productions vars productions productions productions equations normalization function integrates lexical context free syntax 
applies auxiliary function baux grammar transform lexical context free sections normal production sections renaming symbols separating context free symbols cfi entails tokens optionally separated cfi 
contextfree layout list lexical layout 
concatenation layout defined production added function 
cfi cfi cfi syntax baux default rule declares stated baux affect grammar 
deal exceptions 
baux baux baux baux baux lexical syntax lexical syntax grammars translated normal syntax grammars encoding symbols grammar ha lexi symbols 
furthermore symbol appearing lexical syntax section injection lexical context free syntax lexical context free symbol added 
baux lexical syntax lexi hff ff ha ha lexi hff fi hff hfi hff lexi hff ha lexi hff hff lexi ha ha cfi hp hp hp hp lexi syntax hp hg lexi hg lexi hg lexi lexi context free syntax context free syntax treated similarly lexical syntax 
symbols production mapped ha cfi symbols 
important difference adjacent pair symbols left hand side production separated symbol cfi 
baux context free syntax cfi hff ff ha ha cfi hff fi hff cfi hfi hff cfi hff ha cfi hp hp cfi hp hp hp hp cfi syntax hp hg cfi hg cfi hg cfi cfi variables variables lexical variables grammars introduce tokens status variables 
symbol constructor ha vari denote variables symbol left hand sides variable productions interpreted lexical syntax 
lexical value produced left hand side type variable symbol right hand side production 
production variables grammar productions generated 
interprets left hand side production lexical pattern symbols left hand side lexical symbols layout symbols occur 
right hand side hha cfi vari indicating pattern variable context free symbols second production injects ha cfi variables ha cfi variable occur ha cfi occur 
baux variables syntax hp hp hp hp disambiguation abbreviation hff hff hha cfi vari hha cfi vari ha cfi lexical variables treated similarly result sort corresponding lexical sort 
baux lexical variables syntax hp hp hp hp hff hff hha lexi vari hha lexi vari ha lexi ordering grammars equations specify ordering grammars order obtained lexical syntax context free syntax lexical variables variables 
show equations cases similar 
context free syntax context free syntax free syntax context free syntax lexical syntax syntax context free syntax parse trees expressed meaning lexical syntax context free syntax terms normal syntax productions extend definition parse trees encoding symbols grammars aterm format 
see xa encoding decoding newly introduced constructs 
entails trees lexical context free syntax form 
particular structure assigned lexical tokens grammar retained parse trees tokens 
refine equality predicate trees layout ignored 
considering trees equivalent want consider layout 
purpose required translate parse tree syntax tree 
suffices define arbitrary layout trees equivalent done extension equality predicate trees 
module basic sdf equality imports kernel sdf equality basic sdf aterms regular sdf aterms equations symbol type cfi symbol type cfi symbol type cfi symbol type cfi restrictions discussion lexical layout languages fortran tokens contain kind layout 
heering 
symbol ignore introduced purpose 
dealt separating symbols lexical production lexical layout symbol just done context free productions 
done current version languages necessary straightforward add feature normalization 
implementation conventional implementation parsers lexical context free syntax separate scanner parser 
implementation achieved grammars introduced separating productions lexi vari symbols productions cfi symbols generating scanner finite automata set productions generating parser second set productions push automata 
scanner parser communicate shared buffer data structure 
requirement approach lexical productions form regular grammar 
enforced specifying static constraints lexical productions 
parser generator sdf described visser depend separate scanner 
lexical analysis parsing productions lexi symbols incorporated parser 
cope ambiguities lookahead generalized lr parsing 
similar approach described salomon cormack name scannerless parsing conventional lr techniques 
restrictions distinction lexical context free syntax lexical ambiguities solved tokens sent parser 
usually done applying rules prefer longest match prefer keywords prefer variables 
removing distinction previous section lexical ambiguities dealt way context free ambiguities 
example defined disambiguation priorities applies lexical context free syntax 
furthermore lexical ambiguities solved considering context tokens occur 
instance wellknown problem distinguishing occurrence subrange consecutive occurrences real numbers pascal solved automatically ranges reals occur context grammar 
lexical ambiguities solved context means priorities 
lexical ambiguities need solved rules prefer longest match prefer literals 
section introduce extensions context free grammars aimed lexical disambiguation follow restrictions reject productions 
follow restriction cc declares symbol followed character character class cc 
reject production ff declares tree type rejected exists tree disambiguation abbreviation yield reject production root production 
constructs suffice expressing lexical disambiguation rules 
example definition simple expression language nested comments example contains lexical ambiguities 
definition lists comment words ambiguous 
string abc comment word list characters class considered list comment words ab bc want express longest possible comment word selected 
second definition identifiers variables identifiers expressions overlap identifier expression sort exp want express rule prefer variables selects variable lexical 
ambiguities solved rules lexical restrictions syntax id cf var 
id cf 
reject exp cf var 
id cf 
reject rule states comment word followed characters 
solves problem rules parses abc word 
rules state variables preferred identifiers 
syntax follow restriction form cc 
follow restrictions declared grammar starting keyword restrictions followed list restrictions 
reject production normal production attributed attribute reject 
module restrictions sdf syntax imports cc sdf syntax exports sorts restriction restrictions context free syntax symbols charclass restriction restriction restrictions restrictions restrictions grammar reject attribute variables restr restriction restr restriction restr restriction projection function gives restrictions grammar 
function looks restrictions symbol 
module restrictions sdf projection restrictions imports restrictions sdf syntax exports context free syntax restrictions restrictions restrictions grammar restrictions symbol restrictions charclass equations concatenation restrictions 
restr restr restr restr restrictions grammar 
restrictions restr restr restrictions symbol 
cc restr restr ff cc restr cc ff cc restr ff cc restr ff cc restr normalization special normalization needed restrictions normal ordering merging grammars 
module restrictions sdf normalization imports restrictions sdf syntax cc sdf normalization equations merging ordering grammars 
restrictions restr restrictions restr restr restr restrictions restr syntax restrictions restr discussion disambiguation rules derived similar rules introduced salomon cormack 
adjacency restriction salomon cormack general 
form declares symbols adjacent 
may require arbitrary long lookahead chosen simpler follow restrictions implemented restricting lookahead productions 
implementation reject productions parsing described visser general implementation noncanonical slr parsing salomon cormack 
disambiguation abbreviation interpretation follow restrictions reject productions disambiguation devices 
follow restrictions interpreted extension formedness predicate parse trees 
follow restriction applies symbol tree symbol type character immediately right character yield contained restriction 
discussion semantics reject productions see visser 
current situation lexical disambiguation rules invented user 
sdf lexical disambiguation completely taken care scanner means number heuristics 
heuristics cause problems number cases 
attractive complete control lexical disambiguation provided restrictions reject productions introduced 
desirable cases necessary restrictions derived automatically grammar 
schemes considered clear derivation rules defined 
renaming modularization chapter introduce module mechanism reusing parts syntax definitions 
order adapt imported modules specific applications avoid name clashes renaming mechanism provided rename symbols productions 
renaming mechanism definition symbol aliases define abbreviated names large regular expressions 
renamings define symbol parameterization modules 
renamings previous sections number features enable concise definition syntax plain context free grammars 
grammars defined long monolithic lists productions 
promote reuse grammars introduce module layer top grammars parts language definition reused various definitions 
opportunities reuse greater introduce renaming operator grammars 
renamings enable adaptation generic grammar specific needs renaming sorts productions 
renaming symbol renaming renames production renaming renames example renaming key 
var value 
term table 
subst lookup table key 
value 
subst var 
term specifies renaming symbols key value var term respectively renaming production lookup table key 
value subst var 
term 
defined renamings grammars apply situations renaming imported modules symbol parameters modules symbol aliases 
subject sections 
syntax renaming list symbol renamings form production renamings form renaming modularization module renaming sdf syntax imports kernel sdf syntax exports sorts renaming renamings context free syntax renaming renamings symbol symbol renaming production production renaming variables ae renamings ae renaming ae renaming requirement production renamings ff fi renaming ff fi similar non terminal parts correspond 
entails production renamings rename literals arguments syntax order arguments 
projection define projection functions looking value symbol production list renamings 
module renaming sdf projection imports renaming sdf syntax exports context free syntax renamings renamings renamings symbol renamings symbol production renamings production symbols symbols renamings equations concatenation renamings 
ae ae ae ae looking renaming symbol list renamings 
ae ae ae ae ae looking renaming production list renamings 
ae ff ff fi ae fi ae ae ae ae renamings abbreviation renaming list symbols list symbols 
ff fi ff fi ff fi instantiation list formal parameters list actual parameters 
normalization define application renaming grammar 
sort define application function renamings applies renaming constructs sort start defining renaming symbols productions 
rest mainly distribution renamings function constructs building grammar 
module kernel sdf renaming imports renaming sdf projection kernel sdf projection exports context free syntax symbol renamings symbol symbol renamings symbol symbols renamings symbols production renamings production productions renamings productions grammar renamings grammar equations renaming symbol 
symbol defined renaming replaced value renaming 
renaming applied recursively symbol done function ae 
ae ae ae ae renaming production works similarly 
production defined renaming replaced value 
symbols renamed 
ae ae ff ae ff ae 
ae grammar constructs renaming homomorphism applies renamings symbols productions contained structure 
renaming lists symbols 
ff ae ff ff fi ae ff ae fi ae ae ae renaming lists productions 
ae ae renaming modularization ae ae ae ae renaming grammars 
ae ae ae ae syntax ae syntax ae application renaming renaming denotes composition renamings 
module renaming sdf renaming imports kernel sdf renaming exports context free syntax renamings renamings renamings equations renaming ae applied renaming ae ae ae denotes composition renamings ae ae ae ae expressed means single renaming renaming targets ae ae adding ae list renamings 
ae ae ae ae ae ae ae ae ae ae ae ae extensions kernel extend renaming functions new constructors 
see xa specification extensions 
renaming trees formed trees exist grammar renamed trees renamed reused context renamed grammar 
example equations grammar defined equations renamed 
extend definition renaming parse trees 
module renaming sdf trees imports kernel sdf trees cc sdf trees basic sdf trees regular sdf trees kernel sdf renaming literals sdf normalization exports context free syntax aterm renamings aterm atermlist atermlist atermlist mktree literal aterm symbols atermlist equations renaming application 
production defined renaming rename renamings arguments rename literals argument terms new production 
aterm production prod ae prod prod prod args ae args args prod args args appl prod args ae appl prod args production defined renaming rename arguments 
appl prod args ae appl prod args ae renaming homomorphism tree constructors 
ae amb args ae amb args ae tl ae tl ae ae ts ae ae ts ts ts ae renaming arguments 
insert literals new pattern 
symbol ts ts tl mktree rest ts tl skip literals old tree 
symbol type ts tl ts tl rest ts copy layout old tree new tree layout requested new pattern 
symbol ts cfi symbol type ts cfi ts ts ts rest ts rest ts insert empty layout new tree 
symbol ts cfi symbol type tl cfi ts tl appl aterm cfi rest ts tl skip layout old tree 
symbol tl cfi symbol type ts cfi tl ts tl rest ts renaming modularization cases layout literal list 
means concerns argument tree copied old tree renamed tree 
ts ts ts rest ts rest ts function mktree constructs tree literal constructing production definition generating list character codes 
chars ff aterm ff prod mktree appl prod ff list singleton character classes generate term list integers representing character codes 
ff int ff discussion desirable renaming preserves formedness tree formed grammer formed renamed renaming ae 
want ae ae fact renaming preserves structure defined grammar renaming trees generated grammar gives trees generated renamed grammar ae ae unfortunately case renamings 
argument sorts production renamed production renaming sorts renamed independently arguments application production wrong type renaming 
instance renaming 

set set 
set change notation addition sort binary operator sort set 
constructs sort type renaming including arguments operator formed 
sufficient require cases corresponding symbol renamings renaming 
set 

set set 
set preserve formedness 
interaction regular expressions renamings preservation property 
instance consider renaming aliases int 
int intended rename lists integers separated commas lists separated semicolons 
rename symbols int rename concatenation operators sort 
renaming int 
int int int 
int 
int int 
int int int 
int 
int int 
int int int 
int 
int int 
int int int 
int 
int int 
int formedness preserving renaming intended effect 
cases correct renamings preserve wellformedness achieve intended renaming examples show care taken writing renamings 
ideally restrict renamings preservation property holds 
possible complete renaming guarantee formedness preservation examples 
matter study 
aliases regular expressions introduced provide way concisely declare number productions having write 
problem regular expressions large 
property unattractive 
introduce symbol aliases 
alias declaration introduces short name complicated regular expression 
occurences alias replaced meaning 
example declarations aliases term 
terms var 
vars set var 
term 
subst introduce terms vars aliases lists term var respectively subst alias sets pairs variables terms 
entails operations generated list constructs apply terms vars operations generated sets apply subst 
aliases defined renamings previous section 
alias induces grammar renaming applied entire grammar 
introduce extra feature renamings 
renamings apply fixed grammar 
grammar renaming applied including imported grammars affected 
alias renaming symbol affects modules import alias 
renaming modularization syntax alias grammar consists list aliases form define symbol alias symbol module alias sdf syntax imports kernel sdf syntax exports sorts alias aliases context free syntax aliases aliases grammar symbol symbol alias alias aliases variables alias alias alias projection concatenation alias lists 
projection aliases non alias parts grammar 
module alias sdf projection imports alias sdf syntax exports context free syntax aliases aliases aliases grammar aliases grammar grammar equations function gives alias declarations grammar grammar alias declarations 
aliases aliases normalization aliases defined renaming alias symbols defined meaning 
function produces renaming alias declarations grammar applies non alias parts grammar 
alias declarations attached renamed grammar 
done order keep modular property aliases entails aliases replaced flattening module aliases part grammar keep forward renaming property 
module alias sdf normalization imports alias sdf projection kernel sdf normalization kernel sdf renaming exports context free syntax grammar grammar rn aliases renamings symbols aliases equations replace alias symbols definition applying renaming derived alias declarations non alias parts grammar 
aliases rn build renaming list aliases 
target alias declaration renamed source rn rn rn symbols occurring alias declaration 
symbols aliases symbols symbols fg symbols fa bg symbols merging ordering grammars 
aliases aliases aliases syntax aliases syntax aliases subject renamings 
module alias sdf renaming imports kernel sdf renaming alias sdf projection exports context free syntax aliases renamings aliases equations renaming aliases 
aliases ae aliases ae ae ae ae 
ae ae ae ae renaming modularization modules section introduce module framework grammars support management reuse parts grammar language 
modular definition consists list named modules 
modules reused modules means imports 
body module list exported hidden grammars 
export hiding provide means control visible module local module 
hidden syntax useful syntax definition formalism coupled semantics formalism specification semantics languages 
hidden syntax plays role auxiliary functions 
imports abbreviations grammars import hidden exported 
modules parameterized list symbols 
import instantiate parameters required 
parameterization abbreviation renaming 
module ff imported fi formal parameters ff renamed actual parameters fi 
import subject renaming symbols productions 
example aliases renaming module defines syntax tables 
table defined alias set mappings keys values 
value assigned key looked table access function lookup 
module tables exports sorts key value table aliases set key 
value 
table context free syntax lookup table key 
value transform tables mappings variables terms obtaining representation substitutions 
achieved renaming sorts module tables variables keys terms values tables 
module substitutions imports terms tables key 
var value 
term table 
subst lookup table key 
value 
subst var 
term exports context free syntax subst term 
term additional function applies substitution variables term 
example map renaming kind polymorphic higher order functions expressed 
module defines function maps function elements list 
function defined instantiated needed 
module map modules exports sorts context free syntax 

disadvantage kind polymorphism instance polymorphic function explicit module import done 
example parameterized modules module defines syntax list conditional equations preceded keyword equations 
syntax equations part asf sdf module parameterized syntax language 
sort productions defining syntax equations sort defined 
note constrained iteration operator define bar implies conditions equal signs 
module equations exports sorts tag equation implies condition equations lexical syntax 
implies 
aliases condition 
conditions context free syntax equations 
equations tag conditions implies 
equation 
tag equation conditions 

tag define generic syntax sorts equation condition follows module equations exports sorts equation condition context free syntax 
equation 
condition 
condition define syntax equations part module asf sdf generates module equations defines syntax equations klint 
module imports language independent syntax equations defines equations sorts declared module 
parameterized module equations express module contains import declared sort 
instance boolean equations get module module booleans equations imports booleans equations equations bool renaming modularization observe sorts condition equation declared different modules 
problematic modules meet duplicate definitions merged 
syntax modular syntax definition consists series named module declarations 
module declaration consists list sections exports hiddens 
module name consists module identifier optional list parameters 
module identifiers contain slashes enable directory names module names sdf kernel syntax 
module import number modules 
import consists module name optionally renaming applied 
import module denotes grammar declared module import contained exports hiddens sections 
case syntax imported module hidden exported module 
imports occur start module outside exports hiddens section 
case imports exported 
module modular sdf syntax imports kernel sdf syntax renaming sdf syntax exports sorts import imports section sections module definition lexical syntax za gamma context free syntax module definition module sections module exports grammar section hiddens grammar section section sections symbols id attribute imports imports grammar import imports import renamings import import import variables mid section section section module modules module module definition import import import projection projection functions yields body module named exp yields exported part module hid yields hidden part module 
module modular sdf projection imports modular sdf syntax booleans kernel sdf projection modular sdf renaming exports context free syntax import imports bool sections sections sections imports imports imports definition sections exp sections grammar hid sections grammar equations membership list imports 
concatenation section imports lists 
lookup module name list modules 
module name matches module name searched list sections yielded 
parameterized module imported specifying actual parameters parameters left uninstantiated 
list actual rename formal parameters actual parameters 
function constructs renaming formal parameters actual parameters parameterized module 
modules empty list sections yielded 
module mid module mid ff mid mid fi module mid ff ff fi mid fi module renaming modularization exported grammars list sections 
exp exp exp exp exp exports exp hiddens hidden grammars list sections 
hid hid hid hid hid exports hid hiddens normalization define semantics modular constructs introduced means normalization function yields flattening module modular syntax definition replacing import body module refers 
hidden productions renamed attaching name hiding module 
productions occurring hiddens occur hiddens section exported occur renamed productions imported module 
consequence production merging case exported function hidden hiddens part module 
define function yields grammar corresponding module definition module modular sdf normalization imports modular sdf projection modular sdf renaming kernel sdf normalization grammar projection exports context free syntax definition grammar hide grammar grammar hide productions productions hiddens sorts ig context free syntax imports grammar ig imp definition imports import ig ims definition imports imports ig gra definition imports grammar ig equations normalization order grammars 
imports imports imports imports gi modules normalization module sections 
exports hiddens sections merged 
module module exports exports exports exports hiddens hiddens hiddens hiddens exports exports hiddens semantics module named definition expressed composition exported hidden grammars module imports replaced exported grammars modules refer 
gra hid hi gra exp hi hide function hide marks productions hiddens part module module name attaching attribute id 
hide hide hide hide hide syntax syntax hide hide hide ff ff fid hide hide hide hide function gra expands imports grammar 
returns structure hi gi denotes flattened grammar list imports expanded flatten grammar 
list passed rest flattening process order prevent multiple imports module 
important particular presence cyclic imports 
gra hi gra hi gra hi gra imports ims gra hi gi function ims yields flattened grammars list imports 
ims hi imp hi ims hi ims hi function imp yields flattened grammar associated exported grammar import 
list imports denotes imports expanded 
module imported imported 
protection cyclic imports 
exp fi imp gra renaming modularization ae exp ae fi imp ae gra ae see section renaming ae applied exported part imported module equation applied imports module applied recursively modules imported renaming extend definition renaming renaming module sections imports 
includes renaming imports renaming renamings applied imported modules 
module modular sdf renaming imports renaming sdf renaming modular sdf syntax modular sdf projection exports context free syntax sections renamings sections imports renamings imports equations renaming sections 
ae exports ae exports ae hiddens ae hiddens ae ae ae ae renaming list imports implies applying renaming imported modules attaching renaming module name list imports 
imports ae imports ae ae ae ae ae ae ae imported module renaming attached new renaming applied yielding composition renamings 
ae ae ae ae discussion modularization extension symbol parameters import renamings hidden imports modularization asf sdf implemented asf sdf meta environment klint 
definition pure textual inclusion semantics modularization 
hendriks describes textual normalization semantics incremental semantics modules modular constructs renamings hidden imports 
incremental implementation modularization meta environment complicated presence renamings items created fly longer associated module 
addressed issue incremental parser generation modular parser generation setting renamings 
deviate original design asf incorporate origin rule forbids identification names originate different modules bergstra 
style forbids modules partly overlapping signatures introducing sort function imported module overlap intentional 
definition liberal respect 
productions imported different routes identified 
saw renamings guaranteed preserve formedness trees 
study modular properties grammars line module algebra bergstra give insight properties modularization 
topics study properties trees languages renaming ambiguity caused union interaction regular expressions renamings modular properties reject productions 
syntax definition formalism sdf chapter presents assembly syntax definition formalism sdf features designed previous chapters 
mainly matter defining collecting modules import modules defined earlier 
features interfere 
cases normalization functions extended cover constructs introduced features 
cases features extended orthogonality feature maintained 
chapter concludes comparison sdf sdf discussion anomalies possible improvements formalism 
sdf put pieces define syntax definition formalism sdf generalization sdf heering :10.1.1.28.6239
covers features available sdf adds new ones 
furthermore small adaptations sdf textually structurally subset sdf 
means existing sdf definitions literally sdf definitions 
differences translated automatically means migration tool 
combination features described earlier achieved basically combining means imports collecting modules 
aspect definition syntax projection normalization collecting module defined 
show collecting modules syntax normalization sdf 
modules appendix 
tried define features orthogonally interference unavoidable 
instance extend syntax symbols normalization functions deal symbols affected extended accordingly 
syntax syntax sdf simply collection syntax features introduced sofar 
syntax extended lexical context free priorities restrictions arise result combination basic sdf priority sdf restriction sdf 
constructor definition collects list modules single sdf definition 
symbols serve define grammars single syntax definition formalism sdf start symbol 
normalization productions added union sorts grammar 
symbol describe files consist string language followed file character 
label extension symbol labeled literal syntax extension defined 
priorities section extended deal extra symbol constructor 
module sdf syntax imports kernel sdf syntax basic sdf syntax modular sdf syntax regular sdf syntax priority sdf syntax cc sdf syntax sorts sdf syntax literals sdf syntax label sdf syntax restrictions sdf syntax alias sdf syntax exports sorts sdf context free syntax symbol symbol lexical priorities priorities grammar context free priorities priorities grammar lexical restrictions restrictions grammar context free restrictions restrictions grammar definition definition sdf priorities symbol symbol symbol literal symbol symbol normalization define normalization function normalizes syntax definition applying normalization functions individual features 
deal interaction normalization functions separate features constructs added formalism features 
module sdf normalization imports sdf syntax sdf projection sdf renaming basic sdf normalization modular sdf normalization priority sdf normalization regular sdf normalization literals sdf normalization cc sdf normalization sorts sdf normalization sorts sdf projection restrictions sdf normalization alias sdf normalization exports context free syntax normalize sdf symbol grammar grammar symbol grammar symbol symbols productions equations normalization sdf definition defined equation 
function normalize parameterized module name denoting top module normalized sort denoting definition 
definition normalized expanding module means function 
normalization functions basic alias regular sdf priorities literals kernel applied resulting grammar 
function defined add special productions top sorts definition remove productions reachable top sorts 
normalize definition reachable function adds special production symbol declares text grammar string sort followed character representing file 
declared sort definition production added defines text string sort starts ends layout 
syntax eof ff fi ff fi cfi hb cfi cfi interaction normalization functions full sdf formalism contains constructors extension defined 
extend functions accordingly 
exports context free syntax priorities lexp priorities priorities cfp priorities restrictions lex restrictions restrictions cf restrictions hiddens variables literal equations normalization function regular expressions extended symbol constructors added extensions 
equations express sorts character classes literals symbols layout generate productions 
layout cc equations define productions generated symbol transformed productions lexical context free productions lexical context free version symbol occurs 
entails productions generated recursive call transformed lexi cfi function 
ha lexi hr lexi syntax definition formalism sdf ha cfi hr cfi ha vari example context sensitivity generation productions symbols 
meaning hid cfi different hid lexi 
basic literals character classes need lexi cfi constructor lexical definition hcc lexi cc hcc cfi cc hcc vari cc hl lexi hl cfi hl vari basic priorities equations normalization lexical contextfree priorities added level sdf 
context free priorities pr context free syntax free syntax context free priorities pr context free priorities pr lexical syntax syntax context free priorities pr context free priorities pr context free priorities pr free priorities pr pr context free priorities priority declarations context free productions abbreviations normal priorities way context free syntax abbreviation certain style normal syntax 
productions priorities sections treated cfi functions context free productions 
baux context free priorities pr pr cfi pr cfi priorities pr hpr pr hpr pr hpr hpr hp hp cfi 
hp cfi hp hp cfi hp cfi similarly lexical priorities 
baux lexical priorities pr pr lexi pr lexi priorities pr hpr pr hpr pr hpr hpr hp hp lexi 
hp lexi hp hp lexi hp lexi basic restrictions baux lexical restrictions restr restrictions lexi lexi restr restr lexi lexi lexi comparison sdf hff cc lexi hff cc baux context free restrictions restr restrictions cfi cfi restr restr cfi cfi cfi cc cfi cc ha ff cc cfi ha cfi fi cc hff cc cfi fi cc labels hl lexi ha lexi hl cfi ha cfi hl vari ha vari hiding productions hide context free syntax context free syntax hide hide lexical syntax lexical syntax hide hide variables variables hide hide lexical variables lexical variables hide aliases aliases sorts ff ff aliases comparison sdf sdf developed generalization sdf heering :10.1.1.28.6239
briefly list differences formalisms 
semantics sdf defines semantics syntax definition means mappings formalisms 
lexical syntax mapped regular grammar 
contextfree syntax mapped context free grammar 
entire definition order sorted algebraic signature derived 
parse tree string grammar translated term syntax tree signature 
sdf parse trees defined means formedness predicate aterms directly normal form syntax definition 
strings language defined grammar obtained function yield 
external formalism define trees 
way notions grammar signature related mappings sdf completely integrated sdf 
syntax definition formalism sdf lexical context free syntax sdf integrates lexical syntax context free syntax formalism 
integration level formalism level implementation separated 
lexical syntax mapped regular grammar specification lexical syntax regular 
context free syntax translated context free grammar 
sdf integration lexical context free syntax completed 
features orthogonal respect lexical context free syntax 
instance character classes regular expressions exactly way lexical productions context free productions 
lexical disambiguation sdf built lexical disambiguation rules applied token stream tokens passed parser 
sdf built lexical disambiguation rules provides reject productions express prefer literals rule follow restrictions express longest match disambiguation 
character classes sdf syntax character classes defined lexically 
sdf character classes defined means context free constructors 
definition normalization character classes easier 
differences character classes sdf numeric characters decimal interpretation octal interpretation syntactic limit range numeric characters characters letters digits escaped slash 
sdf character classes numeric interpretation character class normalized ordered non overlapping list numeric characters ranges characters 
lists sdf provides list sorts left hand sides productions 
furthermore lists orthogonally defined 
lexical syntax iteration separator provided 
sdf sorts right hand side production 
means list sorts result functions 
order define function list result new sort introduced list sort injected 
furthermore concatenate lists result function concatenation function defined 
sdf provides expressive set regular expressions treated class citizens 
regular expressions symbol 
general symbols left hand side production output symbols 
priorities priorities declarations sdf sdf exceptions abbreviations productions priorities supported problematic semantics setting modules 
chains provided 
implementation provide multi set filter interpretation discussion concluding remarks priorities 
reuse sdf provide renamings module parameterization hidden imports aliases 
discussion concluding remarks modular design family syntax definition formalisms 
result uniform formalism syntax definition designed extensibility 
guiding principle design orthogonality features respect 
consequence easy replace feature variant add new feature affecting design implementation features 
parser generation direct motivation specification parser generator sdf 
techniques originally developed translation sdf intermediate languages context free regular grammars prescribed sdf manual heering :10.1.1.28.6239
gradually clear difficulty project due monolithic design sdf 
features combined formalism sdf intended replace sdf 
specification parser generator sdf easier due uniform syntax elimination cases normalization 
tables generated generator interpreted generic scannerless generalized lr parser described visser 
disambiguation priorities interpreted formedness requirement parse forests operationalized filter parse forests prescribed heering 

approach extended disambiguation methods described klint visser 
provided features disambiguation ambiguous context free grammars 
remain large number ambiguities solved mechanisms 
advanced disambiguation methods described klint visser 
list ideas improvements current scheme 
priority relation productions allow distinction arguments productions applies 
cases useful restrict relation certain arguments 
instance priority declaration 

correctly forbid usage expression argument application 
forbids usage argument application reason 
extension notation syntax definition formalism sdf 


declare desired disambiguation 
implementation problems extension 
case non standard disambiguation ambiguous equations 
gave example specification syntax conditional equations 
occur equations ambiguous due injections 
symbol injected equation expressions interpreted equations 
possible interpretation ambiguity take possibilities 
done definition multi level algebraic specifications visser ambiguous equations occur due overloading functions 
implementation sdf asf sdf meta environment undocumented disambiguation method 
simplification multi set ordering trees fewer injections preferred trees injections 
method needed disambiguate conditions equations 
method implemented part sdf tools added post parse filter problems 
defined follow restrictions reject productions express lexical disambiguation rules 
omitted definition methods extension formedness predicate parse trees 
see visser discussion semantics methods discussion automatic lexical disambiguation 
renaming modules associate name grammar 
grammars combined module imports 
export hiding provide control visibility grammars 
new respect modularization sdf renamings hidden imports 
current definition renaming productions literal skeleton production changed order arguments stays 
desirable change syntax production permutation arguments 
notation permutations devised means kind indexing 
problem notation current definition reuses syntax productions literally definition renamings 
changing syntax productions applicable 
label facility see purpose 
unfortunately renamings guaranteed preserve formedness parse trees 
study needed find set sufficient requirements renamings guarantee formedness 
labels feature discussed labels 
labels intended field names record 
instance consider production defining syntax assignments imperative language var var value exp 
stat cons assign arguments labeled var value respectively 
information derive syntax projection functions field names discussion concluding remarks stat var 
var stat value 
exp accompanied defining equations functions 
derived syntax regular expressions considered name constructors new names existing ones 
normalization function adds canonical productions defining regular operators 
instance 
denotes optional defined productions 
restriction name constructors 
defining productions added user 
context algebraic specification means instance users specify functions lists result 
regular expressions example derived syntax symbol production grammar productions derived 
applications derived syntax useful 
useful explicitly indicate empty constructs injections 
accommodated generating syntax explicitly matching injection functions ffl functions 
production 
similarly ffl 
production 
constructors course match origins 
done translating functions internally real injection ffl function 
see dinesh interesting remarks injections asf sdf 
structure editor provides facilities manipulate sentential forms 
requires specification syntax symbol placeholders 
symbol literal add production 
case kind generation explicit type casts 
bracket attribute constrain type overloaded entity 
similar operator attribute sdf 
better syntax derivation user definable providing schemas discussed 
polymorphic syntax definition regular expressions introducing new productions instance second order quantification 
generalization approach level grammars visser provides syntactic counterpart level specifications meinke multi level specifications visser 
generic productions written production schemata 
syntax symbol constructors described means second level grammar 
dynamic syntax open problem formal description languages extensible syntax 
programs languages contain grammars define part syntax program 
example extensible syntax syntax equations asf sdf 
instances exist cardelli 
vittek elan 
approaches treat metalanguage object language differently 
formal approach problem syntax definition formalism sdf specify syntax base language grammars specify lifting grammars meta level grammars 
design methodology large specification 
approached rigorous modularization specification matrix modules 
feature syntax tools described separate modules 
way feasible flexibly include exclude parts language definition 
parts specification aterm encoding interesting 
better parts generated simple rule 
main technique applied definition features normalization transformation subset language 
great advantage normalization features provided enhance expressiveness language defining semantics formalism small set kernel features features expressed 
normalization disadvantages 
semantics various features defined indirectly reasoning troublesome 
furthermore parse trees grammar normalized productions look different origins 
desirable normalization equations functions order able reason equivalence syntax definitions 
problem approach lack control normalization 
solution strategies described visser 
modularization formalism modularization normalization separate normalization functions feature specification normalization feasible 
normalization function pass grammar normalize complex 
modularization hides interaction features 
defining normalization function extension kernel constructs introduced normalized 
combination features prompts extension normalization function new constructs 
achieved innocent distribution equations cases interaction features problematic 
particular interaction renamings features needs study 
language design software engineering process 
language definition gets better developed prototype implementation 
parts specification sdf parser generator normalization developed demand 
especially fragment sdf corresponds sdf developed syntax definitions fed parser generator converted sdf definitions 
parts specification formedness equality directly tools developed 
parts important define correctness criteria implementations 
formedness checker validate output parser grammar 
equality checker validate matching algorithm terms 
design approach sdf led infrastructure study syntax definition experimentation new features 
easy extend specification order construct subsets supersets formalism replace feature variant 
auxiliary modules specification sdf appendix include auxiliary modules specification sdf 
literals module literals imports layout exports sorts literal lexical syntax char char char char literal variables literal aterms constructors module grammar tree constructors imports aterms exports context free syntax empty grammar afun conc grammars afun module cc sdf tree constructors imports kernel sdf tree constructors exports context free syntax char class afun auxiliary modules specification sdf range afun module sorts sdf tree constructors imports kernel sdf tree constructors exports context free syntax sort afun module literals sdf tree constructors imports kernel sdf tree constructors exports context free syntax lit afun module regular sdf tree constructors imports aterms exports context free syntax empty afun seq afun opt afun iter afun iter star afun iter sep afun iter star sep afun iter afun iter sep afun set afun pair afun func afun alt afun perm afun module basic sdf tree constructors imports kernel sdf tree constructors exports context free syntax lexical syntax afun context free syntax afun variables afun lexical variables afun cf afun lex afun afun layout afun encoding decoding module grammar aterms imports grammar tree constructors grammar syntax exports context free syntax aterms aterm grammar aterm grammar aterm grammar equations encoding grammars 
aterm empty grammar aterm conc grammars aterm aterm decoding grammars 
grammar empty grammar grammar conc grammars grammar grammar module cc sdf aterms imports kernel sdf aterms cc sdf syntax cc sdf tree constructors character arithmetic exports context free syntax atermlist atermlist aterm character ranges atermlist range aterm character aterm character equations encoding character classes 
aterm cr char class atermlist cr atermlist cr cr atermlist cr cr atermlist cr atermlist cr atermlist cr aterm cr atermlist gamma range aterm aterm aterm int decoding character classes 
symbol char class symbol char class ts ranges ts ranges range ranges ts range ranges ts range character range range character gamma character character char symbol char module sorts sdf aterms imports kernel sdf aterms sorts sdf tree constructors sorts sdf syntax equations encoding decoding sorts 
aterm sort sort literal auxiliary modules specification sdf symbol sort literal sort module literals sdf aterms imports kernel sdf aterms literals sdf tree constructors literals sdf syntax equations encoding decoding literals 
aterm lit symbol lit module priority sdf aterms imports kernel sdf aterms priority sdf syntax equations encoding attributes 
aterm left atr left aterm right atr right aterm bracket atr bracket aterm assoc atr assoc aterm non assoc atr non assoc decoding attributes 
attribute atr left left attribute atr right right attribute atr bracket bracket attribute atr assoc assoc attribute atr non assoc non assoc module regular sdf aterms imports regular sdf tree constructors kernel sdf aterms regular sdf syntax equations encoding regular expressions 
aterm empty aterm ff seq atermlist ff aterm opt aterm aterm iter aterm aterm iter star aterm aterm fa bg iter sep aterm aterm aterm fa bg iter star sep aterm aterm aterm fag iter aterm con aterm fa bg iter sep aterm aterm con aterm set set aterm aterm pair aterm aterm aterms aterm ff func atermlist ff aterm aterm alt aterm aterm aterm ff ae perm atermlist ff decoding regular expressions 
symbol empty symbol seq tl ff symbols tl ff symbol opt symbol 
symbol iter symbol symbol iter star symbol symbol iter sep symbol symbol iter star sep symbol symbol iter symbol iter sep symbol symbol set set symbol symbol pair symbol symbol symbol func tl symbols tl symbol symbol alt symbol symbol symbol perm tl symbols tl ae module basic sdf aterms imports basic sdf tree constructors basic sdf syntax kernel sdf aterms equations encoding grammars 
aterm lexical syntax lexical syntax atermlist aterm context free syntax context free syntax atermlist aterm variables variables atermlist aterm lexical variables lexical variables atermlist encoding symbols 
aterm ha lexi lex aterm aterm ha cfi cf aterm aterm ha vari aterm aterm layout layout decoding grammars 
grammar lexical syntax tl lexical syntax productions tl grammar context free syntax tl context free syntax productions tl grammar variables tl variables productions tl grammar lexical variables tl lexical variables productions tl decoding symbols 
symbol lex lexi symbol cf cfi symbol vari symbol layout layout auxiliary modules specification sdf renamings module cc sdf renaming imports kernel sdf renaming cc sdf syntax equations renaming character classes 
cc ae cc module literals sdf renaming imports kernel sdf renaming literals sdf syntax hiddens variables literal equations renaming literals 
ae module sorts sdf renaming imports sorts sdf syntax kernel sdf renaming equations renaming sorts 
ae sorts ff ae sorts ff ae module priority sdf renaming imports priority sdf projection basic sdf renaming exports context free syntax priorities renamings priorities group renamings group equations renaming symbols productions priority declarations 
priorities pr ae priorities pr ae lists priorities 
pr ae pr pr pr ae pr ae pr ae associativity priority declarations 
ae ae ae ae ae 
ae gg ae ae 
gg gg gg ae renamings groups 
ae ae fp ae aeg fas ae fas aeg module regular sdf renaming imports kernel sdf renaming regular sdf syntax equations renaming symbols regular expressions 
ae ff ae fi ff ae fi ae ae 
ae ae ae ae fa bg ae ae aeg fa bg ae ae aeg fag ae aeg fa bg ae ae aeg set ae set ae ae ae ae ff ae ff ae ae ae ae ae module basic sdf renaming imports basic sdf normalization kernel sdf renaming exports context free syntax renamings lex renamings renamings cf renamings equations renaming grammars 
context free syntax ae context free syntax ae lexical syntax ae lexical syntax ae variables ae variables ae lexical variables ae lexical variables ae renaming symbols 
ha lexi ae ae lexi ha cfi ae ae cfi ha vari ae ae vari layout ae layout applying lexi renaming 
lexi auxiliary modules specification sdf lexi ha lexi hb lexi lexi hp lexi hp lexi ae ae lexi ae lexi ae lexi applying cfi renaming 
cfi cfi ha cfi hb cfi cfi hp cfi hp cfi ae ae cfi ae cfi ae cfi module restrictions sdf renaming imports restrictions sdf syntax kernel sdf renaming exports context free syntax restrictions renamings restrictions equations renaming restrictions 
restrictions restr ae restrictions restr ae restr ae restr ff cc restr ae ff ae cc restr restr restr ae sdf module sdf projection imports kernel sdf projection sorts sdf projection priority sdf projection renaming sdf projection modular sdf projection alias sdf projection restrictions sdf projection module sdf renaming imports sdf syntax kernel sdf renaming priority sdf renaming regular sdf renaming literals sdf renaming cc sdf renaming basic sdf renaming sorts sdf renaming restrictions sdf renaming modular sdf renaming alias sdf renaming equations context free priorities pr ae context free priorities pr ae lexical priorities pr ae lexical priorities pr ae ae ae sdf module sdf tree constructors imports kernel sdf tree constructors basic sdf tree constructors modular sdf tree constructors regular sdf tree constructors priority sdf tree constructors cc sdf tree constructors sorts sdf tree constructors literals sdf tree constructors module sdf aterms imports sdf tree constructors sdf syntax kernel sdf aterms basic sdf aterms modular sdf aterms regular sdf aterms priority sdf aterms cc sdf aterms sorts sdf aterms literals sdf aterms restrictions sdf aterms equations aterm sort start aterm sort start module sdf trees imports sdf aterms sdf syntax kernel sdf trees priority sdf trees cc sdf trees renaming sdf trees module sdf equality imports kernel sdf equality regular sdf equality basic sdf equality bibliography technical reports programming research group university amsterdam obtained www wins uva nl research prog reports reports html 
technical reports cwi www cwi nl cwi publications reports reports html 
aho johnson ullman 

deterministic parsing ambiguous grammars 
communications acm 
backus 

syntax semantics proposed international algebraic language zurich acm conference 
proceedings international conference information processing pages paris 
unesco 
snelting 

psg system formal language definitions interactive programming environments 
acm transactions programming languages systems 
bergstra heering klint editors 
algebraic specification 
acm press frontier series 
acm press operation addison wesley 
bergstra heering klint 

algebraic specification formalism asf 
bergstra heering klint editors algebraic specification acm press frontier series pages 
acm press operation addison wesley 
chapter 
bergstra heering klint 

module algebra 
journal acm 
lang 

structure shared forests ambiguous parsing 
proceedings seventh annual meeting association computational linguistics association computational linguistics 
van den brand visser 

generation formatters context free languages 
acm transactions software engineering methodology 
van den brand klint olivier visser 

aterms representing structured data exchange heterogeneous tools 
technical report programming research group university amsterdam 
bibliography cameron 

extending context free grammars permutation phrases 
acm letters programming languages systems 
cardelli matthes abadi 

extensible syntax lexical scoping 
src research report digital systems research center palo alto california 
chomsky 

models description language 
ire transactions information theory 
cordy 

txl programming language 
syntax informal semantics 
version software technology laboratory department computer information science queen university kingston canada edition 
van deursen heering klint editors 
language prototyping 
algebraic specification approach volume amast series computing world scientific singapore 
dinesh 

injection 
brand editors asf sdf 
workshop generating tools algebraic specifications pages 
technical report programming research group university amsterdam 
earley 

ambiguity precedence syntax description 
acta informatica 
futatsugi goguen jouannaud meseguer 

principles obj 
reid editor conference record twelfth annual acm symposium principles programming languages pages 
acm 
goguen thatcher wagner wright 

initial algebra semantics continuous algebras 
journal acm 
gray levi sloane waite 

eli complete flexible compiler construction system 
communications acm 


lalr generator efficient parsers 
software practice experience 
hatcher rus 

context free algebras 
journal cybernetics 
heering hendriks klint rekers 

syntax definition formalism sdf manual 
sigplan notices 
hendriks 

implementation modular algebraic specifications ph thesis university amsterdam 
johnson 

yacc compiler compiler 
technical report cs bell laboratories murray hill bibliography kahn lang el ese 

metal formalism specify formalisms 
science computer programming 
klint 

meta environment generating programming environments 
acm transactions software engineering methodology 
klint visser 

filters disambiguation contextfree grammars 
san pietro editors proc 
workshop parsing theory pages milano italy 
tech 
rep dipartimento di scienze dell informazione universit di milano 
knuth 

semantics context free languages 
mathematical systems theory 
correction mathematical systems theory pp 
springer verlag 
koster 

affix grammars 
peck editor algol implementation 
north holland amsterdam 
lee 

formal definition basic language 
computer journal 
lesk schmidt 

lex lexical analyzer generator bell laboratories 
unix programmer supplementary documents volume ps 
visser 

specification rewriting strategies 
sellink editor second international conference theory practice algebraic specification asf sdf amsterdam netherlands 
programming research group university amsterdam 
meinke 

equational specification types combinators 
jaeger richter editors computer science logic csl volume lecture notes computer science pages berlin 
springer verlag 
mosses 

action semantics cambridge university press 
naur 

report algorithmic language algol 
communications acm 
parr quong 

adding semantic syntactic predicates ll pred ll 
fritzson editor compiler construction th international conference cc volume lncs pages edinburgh springer verlag 
pereira warren 

definite clause grammars language analysis survey formalism comparison augmented transition networks 
artificial intelligence 
rekers 

parser generation interactive environments ph thesis university amsterdam 
ftp ftp cwi nl pub reports ps reps teitelbaum 

synthesizer generator system constructing language editors springer verlag 
bibliography salomon cormack 

scannerless nslr parsing programming languages 
sigplan notices 
salomon cormack 

disambiguation scannerless parsing complete character level grammars programming languages 
technical report department computer science university manitoba canada 
thorup 

controlled ambiguity 
acm transactions programming languages systems 
visser 

case study optimizing parsing schemata disambiguation filters 
fischer editors proceedings pages amsterdam 
dutch graduate school logic 
visser 

multi level specifications 
van deursen heering klint editors language prototyping 
algebraic specification approach volume amast series computing pages 
world scientific singapore 
visser 

case study optimizing parsing schemata disambiguation filters 
nijholt editor international workshop parsing technology iwpt boston usa 
appear 
visser 

character classes 
technical report programming research group university amsterdam 
visser 

executable specification programming languages 
draft 
visser 

polymorphic syntax definition 
theoretical computer science 
appear 
visser 

scannerless generalized lr parsing 
technical report programming research group university amsterdam 
vittek 

elan un cadre logique pour le de language de programmation avec contraintes ph thesis universit henri poincar nancy nancy france 


tool interactive grammar construction expression parsing 
science computer programming 
watt 

parsing problem affix grammars 
acta informatica 
williams 

flexible notation syntactic definitions 
acm transactions programming languages systems 
wirth 

unnecessary diversity notation syntactic definitions 
communications acm 
technical reports programming research group note reports obtained technical reports overview www site url www wins uva nl research prog reports anonymous ftp ftp wins uva nl directory pub programming research reports 
moonen 
generic architecture data flow analysis support reverse engineering 
visser 
specification rewriting strategies 
bergstra sellink 
arithmetical module rationals reals 
visser 
character classes 
visser 
scannerless generalized lr parsing 
visser 
family syntax definition formalisms 
van den brand sellink verhoef 
generation components software renovation factories context free grammars 
olivier 
debugging distributed applications coordination architecture 
sellink 
formal axiomatization alphabet reasoning parametrized processes 
van den brand sellink verhoef 
reengineering cobol software implies specification underlying dialects 
visser 
polymorphic syntax definition 
van den brand klint verhoef 
re engineering needs generic programming language technology 
manuel 
ansi cobol iii sdf asf definition tool 

complete system valued logic 

transformations reduction systems 
van den brand klint verhoef 
core technologies system renovation 
moonen 
data flow analysis reverse engineering 
hillebrand 
transforming asf sdf specification application 
sellink 
conservativity leibniz equality 
dinesh 
specifying input output visual languages 
dinesh 
vas formalism vase 
hillebrand 
small language specification grid protocols 

transformation tool pure prolog programs algebraic specification 
visser 
solving type equations multi level specifications preliminary version 
argenio verhoef 
general conservative extension theorem process algebras inequalities 
bergstra sellink 
sequential data algebra primitives revised version 
visser 
multi level specifications 
van den brand klint verhoef 
reverse engineering system renovation annotated bibliography 
bergstra sellink 
sequential data algebra primitives 
olivier 
embedded system simulation 

translog interactive tool transformation logic programs 
bergstra hillebrand ponse 
grid protocols synchronous communication specification correctness 

termination confluence infinitary term rewriting 
bergstra gh 
stefanescu 
network algebra relation operators 
bergstra gh 
stefanescu 
network algebra synchronous asynchronous dataflow 
visser 
case study optimizing parsing schemata disambiguation filters 
van den brand visser 
generation formatters context free languages 

automatic analysis term rewriting systems proving properties term rewriting systems derived asf sdf specifications 

