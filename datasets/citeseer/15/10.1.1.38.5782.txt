expressiveness purely functional systems paul hudak raman department computer science yale university box yale station new haven ct march functional programming languages traditionally lacked complete flexible referentially transparent mechanisms 
previous proposals notion lazy streams continuations model interaction external world 
discuss generalize models introduce third call systems model perform expressiveness styles compared means example 
give series surprisingly simple translations models demonstrating different programming styles suggest implying styles mixed single program 
need express non deterministic behavior functional language recognized 
problem doing destroying referential transparency 
survey past approaches problem suggest solution context models described 
system purely functional language haskell 
system includes rich set operations distinguishes file channel approach nondeterminism 
useful aspect design includes rigorous specification behaviour operating system precisely fixing semantics various operations 
haskell system capable supporting paradigms concurrent computation natural way 
demonstrate emulation actors unity csp ccs linda 
functional languages real applications programming effective system essential 
mention image state side effects sequencing 
hope achieving purely functional universal course efficient question address 
identify basic requirements mechanism ffl referential transparency 
consider inappropriate side effecting function returns value input stream function call get char destroy referential transparency get char return different value time called 
similarly side effecting print function call put char destroy referential transparency example put char put char put char ffl efficiency 
essential property scheme efficiency 
possible implement scheme efficiently resorting expensive operations snapshots system state 
ffl operation 
requirement practical scheme ability external world observe effects program program terminated 
conversely program able observe changes system state program begun 
view suspicion example scheme maps single initial state single final state 
requirement important reasons 
anticipate writing programs operate interactively traditional operating system services 
includes traditional file manipulation example changes file editor need visible programs terminating editor device handling example printing general communication programs machines users example standard input output tcp ip protocols 
reason want non terminating just slow program tie computer resources naturally expect effects various programs running single operating system interleaved 
words suppose prog prog programs prog performs operations op op prog performs operations op op 
os operating system maps list programs initial state final state expect os prog prog final state resulting arbitrary interleaving op op op op 
model propose write operating system os show property hold show operating system written 
purely functional proposals meeting requirements difficult come existing functional languages 
ml hmt hud example side effecting primitives uses normal order evaluation provides ways forcing execution order ensure deterministic results 
summarize existing approaches 
streams 
elegant popular model goes long way meeting requirements streams lazy lists data objects 
name stream coined landin lan functional languages streams including ponder hope miranda fai bms tur 
languages predefined identifiers typically provided bound specific channels 
example stream input characters keyboard name kb stream output characters display name display operating system provide binding kb program expected provide binding display 
elegant problems previous uses stream idiom 
completely general typically devices operations pre determined fixed language 

semantics interactive example interaction user entirely clear languages problem admitted front providing mechanism control order streams consumed produced 

anomalous situations ignored possibility error generally accounted 
stream model section streams invoke arbitrary operations arbitrary responses typically success failure 
addition retain elegant streams model interactive careful precisely define semantics input user example depend output program characteristic interactive applications 
requirements stated earlier satisfied 
continuations 
model continuation proposed context functional operating system called nebula kar 
idea parallel functional language called hol ccs mil adopted functional language hope mh 
continuation model characterized set transactions functions typically take success continuation failure continuation arguments continuations turn functions generate transactions 
continuation model appealing appears quite general continuation structure easy reason sequentiality induced effects 
section continuation model similar important exception assume non strict lazy functional language previous languages continuation approach strict 
simplifies design addition allows interactive lazy stream idea continuation model 
specifically miranda trademark research software hope individual characters read continuation operation model single read operation returns lazy stream 
able combine virtues idioms streams model demand driven sequences data continuations enforce control restrictions 
systems 
introduce third model section call systems model viewed series transformations initial system captures state operating system 
product investigations model view functional program function single initial state single final state severely restricting functionality 
model uses stream systems surprisingly output single initial system sufficient meet requirements 
worth noting language fl bww ww performs adding history parameter function argument result notion history bears strong resemblance notion system 
fl strict language history objects implicit 
strict semantics allows designers cleanly define order occurs ensures exactly history object existence time 
situation simple non strict language view implicit state variables undesirable imperative feel 
equivalence models models streams continuations systems induce different programming styles user 
turns exist surprisingly simple definitions models terms give translations section 
existence translations important consequences indicates models equal long standing debates issue 
second importantly language designer provide styles language simply choosing primitive providing modules define terms styles wired language 
programmer free choose style suitable particular application styles single program 
expressing non determinism non determinism pervasive property real systems desirable express non deterministic behavior functional program 
example program service independent sources input say keyboards fixed interleaving streams unsatisfactory needed non deterministic merge streams 
non determinism express called parallel function property true true true 
model part folklore time active topic haskell committee seen details worked done 
naive addition merge amb operator express behaviors undesirable loss referential transparency 
semantics expressive power operators far clear clinger cli discusses complications caused 
section review past approaches language designers taken adding non deterministic behavior functional language suggest solution insights obtained design systems 
result form non determinism maintains referential transparency single program collection programs argue practical compromise solution problem 
haskell show concepts look incorporated real functional language describe section design haskell system combines ideas 
demonstrate power haskell showing easily naturally simulate various concurrent programming paradigms including actors unity csp ccs linda 
remainder functional programming examples written haskell syntax 
models purely functional introduce models streams continuations systems way slightly modified version example kernighan ritchie programming language kr 
example simple file display program prompts user number file names reads displays contents 
imperative version shown 
program procedure get token reads token input stream 
functional programs shortly get tokens function character stream 
functional models assume characters typed keyboard echoed operating system program 
complete specification haskell system see hea 
include stdio main cat concatenate files file fp fopen char char name printf type file names name stdin fp fopen name null printf open file break fp fclose fp fp copy file standard output file fp int getc fp eof putc stdout stream model stream model program simply viewed black box generates stream requests requests operating system processed returned program stream responses 
request datatype requests response datatype responses program type response 
request nth request generates nth response 
response depends request normally include possibility error 
sample program tests failure omitted program 
haskell program value main 
note resps taken apart pattern matching entail evaluating response list requests issued resulting 
main resps stdout type file names cr stdin tl tl resps case resp return 
resps resps name names stdout name readfile name stdout case resps failure msg 
open file cr return 
tl tl tl resps names functions hd tl obvious head tail functions defined lists similarly fst snd selectors tuples 
referential transparency preserved lexical connection request response 
different read requests file equivalent values effect depend position request list invoke different response reflecting fact programs may modified file question reads 
operating system function os services requests simplicity programs executes interleaved manner 
demonstrate model capability operation communication different programs engaged 
os merge requests requests requests requests os maps list tagged requests initial state system list tagged responses final state system 
non deterministic interleaving effects accomplished merge operator produces tagged non deterministic merge list arguments return issue non determinism section 
picks responses tag value tagged list responses 
note scheme generalized arbitrary number programs 
state system single threaded object implemented efficiently 
hand certain amount file copying may necessary 
example consider scenario program issues read file request read done lazily actual reads done value file demanded 
suppose program updates file 
mean copy old file saved released program 
continuation model model having manipulate lists requests responses programmer initiates operations continuation style transactions 
example request readfile name systems model corresponds transaction readfile name msg 
contents 
second third arguments failure success continuations respectively 
value expression error continuation applied resulting error message read fails success continuation applied contents file read succeeds 
show running example style 
note laid way facilitate imperative reading program 
main stdout type file names cr exit stdin exit 
done name names stdout name exit readfile name msg 
stdout open file cr exit done contents 
stdout contents exit names exit msg 
done referential transparency maintained model reason stream model lexical connection transactions results 
stream model functional connection position list connection established way continuations 
write operating system function model show programs form change shared state 
os state os os done done state os transaction 
args 
os case resp return result 
result failure msg 
msg state resp state process transaction 
args 
state os os perm non deterministic interleaving effects accomplished perm returns permutation arguments bottom avoiding argument 
remainder definition self explanatory 
time version system state existence model implemented efficiently 
comment file copying stream model applies equally 
systems model naive version systems model views program simply function initial system final system system meant capture entire operating state interest files devices 
normal operations reading writing files functions take system return result updated system 
view workable 
see try write operating system function programs doing model 
os state amb state state amb non deterministically returns arguments 

apparent interleaving effects programs 
ignoring problem moment look model angle efficiency 
fact operations programs interleaved means operations desired program performed contiguously 
model possible threaded usage system objects expensive simulation operations done program 
clear example program writes file foo returns original system write succeeds 
prog sys 
case resp success 
sys failure msg 
sys resp sys foo junk sys thomas johnsson pointed flaw translation model streams model 
program value resp needed determine system return program requires result returning system 
write simulated program 
means proper implementation model going arbitrarily inefficient 
obvious fix problem model program viewed function list systems list systems alternative considered haskell committee effect operation system visible input system 
model efficient implementation system state single threaded order operations carried fixed output list systems 
clear model interleave effects programs 
surprisingly functionality obtained model programs map single initial system list output systems 
prefer model equivalent power convenient relieves tedium managing separate lists 
result operation system response modified system new system main advantage stream model tedium matching requests responses avoided 
show running example style main sys sys sys sys case resp return 
sys resp stdout type filenames cr sys sys resp stdin sys sys sys name names sys sys sys sys names sys resp stdout name sys sys resp readfile name sys sys resp stdout case resp failure msg 
open file cr return 
sys specified internals system object section give representation system streams 
implication translation interleaving property showed streams model holds systems model 
note sequence intermediate systems clearly specified means order operations done fixed 
means system state single threaded turn implies efficient implementations possible 
equivalence models apparent sight exist simple translations style 
sections follow show model support 
streams primitive program function responses requests support styles 
continuation style supported simply defining transaction function responses requests just program streams model 
example definition done name resps 
name case hd resps failure msg 
msg tl resps return contents 
contents tl resps done resps definitions program written continuation style map list responses list requests desired 
system style supported representing system response list request pair type system response request operations defined pull response return new system 
example consider definition name resps req hd resps tl resps name definitions program written systems model described earlier coerced streams model follows resps 
map snd resps dummy request 
continuations primitive continuations primitive show provide stream style program written stream model meaning continuation style function viewed interpreter stream model written continuation model 
translation similar simon peyton jones 
prog case prog bottom 
done name reqs 
name msg 
resps 
tl prog failure msg resps contents 
resps 
tl prog return contents resps similarly request bottom bottom interesting note translation unavoidable space leak continuation arguments grow linearly number requests issued 
implies time process requests grows nth request obtained applying tl times 
space leak exists function get information rest program 
similar translation provides systems style systems functions represented previous section 
details omitted 
systems primitive systems model simulating streams straightforward 
consider program written streams model run systems model interpreter sys 
map fst answers answers scan 

req fn fst sys requests requests responses responses map snd answers req fn gives system operator corresponding request 
example req fn name name scan defined scan xs scan xs provide continuation style write transactions systems model 
example done transactions defined second request accessed hd tl reevaluated argument 
compare program continuation model program transaction 
success continuation 
failure continuation 
get second transaction response apply continuations depending operation succeeded failed response 
name sys 
sys case resp failure msg 
msg sys return contents 
contents sys sys resp name sys done sys 
continuation system functions respectively reading channel 
definitions program written continuation style type system 
system 
comments models equivalent say merits respect factors style ease programming 
section comment issues 
ffl programs stream style written care subtle strictness bugs arise 
root problem examining response corresponding request issued results deadlock easy mistake response list request list completely separate 
particularly subtle form bug occurs combination pattern matching 
example program purports write simple message standard output 
main resp stdout hello pattern matching demands response list certain structure simple request issued 
ffl equivalence styles interesting implication single program especially stylistic reasons program divided modules 
module style suited preferred author 
ffl models benefit non strict semantics distinct ways 
operating system delay responding operation response demanded program 
see useful consider compiler scenario library function mentioned source program certain information file read 
ordinarily choose extra pass program pick library functions read required information interleave code reading main pass compiler 
alternatives unsatisfactory inefficient second destroys modularity 
systems lazy evaluation comes rescue 
read required information library files actual reading takes place values demanded library functions mentioned program 
efficiency modularity preserved 
second benefit response requests lazy stream stream characters routines computation need deal synchronization simply get character list argument process usual functional style 
ffl important characteristic functional schemes discussed ability feel external effects 
capability invaluable interactive programs editors 
streams continuation models obviously provide capability surprising systems model takes initial system input 
seen simulation systems streams earlier 
ffl experience writing example programs continuation style easier resulting programs easier read 
reasons continuation model reduces syntax handling responses operations response handling sense built 
non determinism known shortcomings functional languages inability express nondeterministic behaviour 
henderson hen shows behavior functional language possible write wide range useful operating system programs 
introduces non determinism operator called merge produces nondeterministic merge lists 
problem solution referential transparency destroyed 
implies equational reasoning important program verification tool longer 
programs techniques tend difficult read 
term programming describe sto tur 
explicit non determinism raises host questions interaction parameter passing mechanism cli formal semantics non deterministic operators complex ss 
shall critically survey proposals overcome problems outline proposal 
stoye approach stoye sto views operating system collection processes functional program single input list single output list 
output list process list tagged data tag specifying addressee 
non determinism system comes play processes send messages process 
messages sent process merged single list 
merge occurs outside processes stoye calls sorting office 
advantage scheme processes referentially transparent subjected equational reasoning 
turner tur refined idea somewhat functional operating system effort kaos project 
stoye applies style profitably task writing operating system programs device handlers 
claim applications style suited ideally 
consider known generate test paradigm compute set candidate solutions problem apply parallel test 
wish informed solutions 
functional language non determinism behaviour impossible obtain 
list test results obtained fixed order say tests takes long time solutions list available delayed 
case test terminate solutions list may displayed 
express behaviour stoye scheme need create separate process tests send results process collects non determinism sorting office gives desired behaviour 
code considerably complex modularity impaired 
burton approach burton bur addresses problem loss referential transparency different way comes solution involving calls pseudo data 
proposed supply program extra argument infinite binary tree values 
program needs non deterministic choice binary tree consulted kind oracle 
tree chosen list number subtrees extracted binary tree 
burton notes practice values tree determined run time argument special function fixed change 
burton proposal provide non determinism referential transparency advocates possibly merge operator 
stoye sto turner tur claim unrestricted non deterministic operator merge reduces readability program burton proposal criticism heightened tends clutter program 
approach refer burton style non determinism amb stoye style non determinism process 
section show kinds non determinism may achieved small extension models discuss related method haskell 
simple way achieve amb non determinism streams model introduce request called amb takes arguments corresponding response return non deterministic choice arguments 
idea continuation systems model 
way achieve amb non determinism referentially transparent way cluttering program data 
generate test problem mentioned earlier solved nicely approach 
similarly process non determinism stoye uses achieved providing special request perform function stoye sorting office 
section fact exploit idea demonstrating express paradigms concurrency 
seen fundamental idea approach non determinism operating system provide special non deterministic services amb sorting office 
example specialization non deterministic servicing multiple agents keyboards handled generalizing request takes list channels response non deterministic merge streams 
fact solution adopted haskell 
analogous channel read channel write request generalized take number streams write non deterministic merge named channel 
may require logical parallelism program may difficult implement ideas mentioned far 
may desirable alternative solution example generate test paradigm 
haskell system sections describes detail specification haskell system 
interest section semantics haskell program engaged described operating system runs 
haskell system unifies popular styles purely functional processing stream model continuation model 
programs style may combined framework defined semantics 
specific operations available style identical differs way expressed 
cases arbitrary operations conventional operating systems may induced retaining referential transparency internal program 
stream haskell program engaged input output processing type behavior response 
request intuitively response ordered list responses request ordered list requests 
nth response reply operating system nth request 
required requests valid implementation data request readfile name name contents name contents name name name name contents type name string requests operate conceptually different components system file system responding requests channel system responding 
file system fairly conventional mapping file names contents 
channel system consists collection channels examples include standard input 
channel way communication medium consumes values program produces values program response 
channels communicate agents concept precise 
examples agents include line printers disk controllers networks human beings 
example user consumer standard output producer standard input 
requests file system general order dependent response ith request may depend jth request 
case channel system nature dependencies dictated agents certain cases exhibits reverse dependencies 
cases external effects may felt internal effects 
formalized hea 
responses defined data response success return contents failure type string response request kinds success failure 
return occur results expected success occurs simple sufficient 
information kind failure contained exact nature depends request left unspecified 
datatypes contents define kinds values allowed stored file communicated channel type contents string type name char value type instance class gap may written file communicated channel put convert string similarly read value file channel get 
continuation haskell supports alternate style called continuation model haskell program considered type response request having put get automatically derived type 
see hea 
user manipulate requests responses directly collection transactions defined capture effect request response pair continuation style 
transactions just functions 
request req corresponds transaction req shown example readfile request normally form readfile name expected induce failure response failure msg success response return contents 
contrast continuation style transaction readfile form readfile name msg 
contents 
second third arguments failure continuation success continuation respectively 
transaction fails error continuation applied error message succeeds success continuation applied contents file 
functionality defined terms requests responses shown type behavior response 
request type behavior type contents 
behavior type 
behavior type 
behavior transactions done behavior readfile name 
behavior name contents behavior name contents behavior name 
behavior name 
behavior name 
behavior name contents behavior done resps readfile name fail succ resps readfile name case head resps return contents 
succ contents tail resps failure msg 
fail msg tail resps name contents fail succ resps name contents case head resps success 
succ tail resps failure msg 
fail msg tail resps name contents fail succ resps name contents case head resps success 
succ tail resps failure msg 
fail msg tail resps name fail succ resps name case head resps success 
succ tail resps failure msg 
fail msg tail resps name fail succ resps name case head resps return contents 
succ contents tail resps failure msg 
fail msg tail resps names fail succ resps names case head resps 
succ tail resps failure msg 
fail msg tail resps name contents fail succ resps name contents case head resps success 
succ tail resps failure msg 
fail msg tail resps file system requests descriptions follow requests described underlying stream model corresponding behavior continuation model obvious 
successful situations described failures generally result system dependent response indicating cause failure 
typical failure messages file access rights violation readfile name accesses contents file named name 
successful response form return contents structure contents depend course written 
typically required aspect valid implementation contents lazy list filed characters 
example sum elements integer file written contents put grade list name grades issue request readfile grades 
response form return filed grade list foldl grades grades get sum grades accordingly 
name contents associates file name contents contents 
successful response form success 
juxtaposed requests name contents readfile name 
corresponding responses success return contents 
contents contents assuming external effects 
name contents name induce obvious effects successful response success 
note proper implementation readfile may times copies files order preserve referential transparency successful read file preserve correct contents despite writes deletions file 
channel system requests channels inherently different files contain ephemeral streams data opposed persistent stationary values 
common channels standard input standard output standard error fact required channels valid implementation names stdin stdout stderr respectively 
name opens channel named name input 
successful response returns channel contents lazy stream 
possible failures include channel exist illegal access channel write 
files channel opened opened program 
reflects ephemeral nature contents prevents serious space leak 
name opens name input 
successful response type name char list tagged elements non deterministic merge individual channels 
element list form namei ci came channel namei list channel names 
note non determinism mentioned confined operating system programs internally referentially transparent 
name contents obvious effect writing contents channel named name 
semantics similar contents appended previously written 
note channels deleted notion creating channel 
optional requests requests required valid haskell implementation may useful 
prog effect introducing new program prog operating system 
prog type response 
request 
request necessary programs operating system command line interpreters written haskell 
name closes named channel may 
certain kinds devices may require request 
induce obvious effects 
semantics behavior haskell program engaged context running 
context described standard haskell code augmented nondeterministic merge operator 
state operating system os state completely described file system channel system 
channel system split subsystems input channel system output channel system 
type state filesystem type filesystem name 
response type ics ocs type ics name 
agent open type ocs name 
response type agent state 
response type open pid 
bool type pid int type plist pid request response note agent maps list os states responses 
responses contents input channels depend output channels input channels files combination thereof 
example valid implementation required allow user act agent standard output channel standard input channel 
running processes programs identified unique pid 
elements plist lists running programs 
os 
state 
state type pid response type pid request operating system modeled non deterministic function os 
os takes tagged request list initial state returns tagged response list final state list processes 
initial list programs start plist os exhibit behavior state plist os state merge zip pid pid 
proc pid pid proc processes processes plist merge non deterministic merge list lists defined resp resps 
resp resps resps relationship accounts dynamic process creation 
addition valid implementation ensure input channel system defined stdin output channel system defined stdout stderr 
furthermore agent attached standard input called user ics stdin form user open user depend standard output 
words constraint hold user fs ics ocs 
user ocs stdout user strict arbitrary function modeling user 
strictness corresponds user consumption standard output process determining standard input 
required behavior os response kind request hea 
comments ffl seen streams efficiently support styles chose streams primitive haskell example avoid linear space quadratic time inefficient result continuations chosen primitive 
mean streams preferred programming model just considered simple general designated primitive 
ffl note non deterministic requests required feature haskell 
reflects feeling definitely useful operation non deterministic write operation find parallel implementation 
ffl type system handle string 
type converted string potentially problem inconvenient programmer write routines type program 
haskell solves problem automatically generating functions data type derived instance declaration mechanism hea 
ffl introduced notion agent consumes data output channels produces data input channels 
useful capturing semantics interactive operations 
example user agent consumes standard output produces standard input 
particular agent required strict standard output corresponding notion user reads terminal display typing keyboard 
programming paradigms relationship haskell proposals concurrent computation 
put expressive power haskell context show section styles expressed fairly naturally haskell functional language incorporating ideas functional 
point show equivalence demonstrate styles find concise expression haskell 
haskell actor actor model computation agh consists number computational agents called actors 
actor maps incoming communication tuple consisting ffl finite set communications sent actors 
ffl replacement behavior governs response communication processed 
ffl finite set new actors created 
difficult see haskell system write actor programs 
actor represented haskell program 
actor model communication handled underlying invisible mail system similar ways stoye sorting office haskell channel dedicated function mailbox 
note process needs unique tag identify addressees messages 
communication occur write operations 
replacement behavior simply expressed recursive function call rest messages actor 
creating new actors achieved haskell 
languages actor model 
agha agh defines called sal 
sal program fragment models shared bank account 
simplified version example agh 
operations depositing balance querying allowed 
operations return balance completion 
program follows specifies type transaction amount involved specifies mail address customer 
def bankaccount deposit bankaccount send fi balance bankaccount send fi def corresponding haskell program look follows 
program look actor version defining syntax mimic send sal primitives 
main resps answers answers put bankaccount queries queries get resps bankaccount deposit rest bankaccount rest balance rest bankaccount rest unity haskell unity computational model proof system cm developing programs general parallel programs particular 
unity program consists declaration variables specification initial values set multiple assignment statements 
program execution starts state satisfying initial condition goes forever step execution assignment statement selected non deterministically executed 
non deterministic selection constrained fairness rule statement selected infinitely 
unity program cm non deterministically merges sequences program mux assign tail head null tail head null mux haskell naturally expressed follows state program represented tuple relevant values unity multiple assignment statements written state transforming function 
non deterministic control provided oracle form non determinism described 
stage functions chosen inspecting choose transaction applied state obtain new state 
mux mux state choose 
mux state xs xs ys ys style programming haskell previously express asynchronous process simulations ha 
haskell meets linda linda gel parallel programming language program set cooperating processes communicating asynchronously global data structure called tuple space 
processes add tuples tuple space operation 
operation removing tuples tuple space takes template instantiates variable slots values tuple matches constant slots 
haskell provides process oriented model difference processes haskell programs 
flexibility system put providing device called say tuplespace 
operations tuple space form requests corresponding 
common linda paradigm task bag paradigm processes pick tasks bag add new tasks generated 
linda process look follows forever task var task descriptor pick task process task task task descriptor add new task bag haskell look follows resps tuplespace task var task descriptor tuplespace process tasks tasks resps description process 
communicating sequential haskell processes done developing calculus interacting processes important ccs mil csp hoa hoa 
clear parallel programming paradigm csp communication structure reproduced haskell 
main difference hoare points comparison kah communication csp synchronous functional multiprogramming models including haskell asynchronous 
force synchronous execution haskell processes sorting office described earlier match input output requests sending response 
turner tur refines stoye scheme achieve synchronous communication similar way 
hoa hoare points functional multiprocessing system processes deterministic example possible process wait inputs 
criticism clearly apply haskell non deterministic requests give desired functionality destroying referential transparency 
contrary popular belief purely functional flexible concise 
lazy evaluation important tools functional programmer toolbox serves context come surprise 
plan gain practical experience writing numerous functional programs involving haskell 
non determinism manifested glue programs put 
programs remain referentially transparent 
approaches naturally apply writing non determinate systems functional language notably functional operating systems 
agh gul agha 
semantic considerations actor paradigm concurrent computation pages 
volume lecture notes computer science springer verlag 
agh gul agha 
actors model concurrent computation distributed systems 
mit press 
bms burstall mcqueen 
hope experimental applicative language 
proceedings st international lisp conference stanford 
bur burton 
nondeterminism referential transparency functional programming languages 
computer journal 
bww john backus john williams edward wimmers 
fl language manual preliminary version 
technical report rj ibm almaden research center november 
cli clinger 
nondeterministic call need lazy name 
proc 
acm symp 
lisp functional programming 
cm mani chandy mishra 
parallel program design 
addison wesley 
fai jon fairbairn 
design implementation simple typed language lambda calculus 
technical report university cambridge computer laboratory may 
gel david gelernter 
generative communication linda 
acm trans 
program 
lang 
syst january 
ha paul hudak steve anderson 
haskell solutions language session problems high speed computing conference 
technical report yaleu dcs rr yale university department computer science january 
hea paul hudak philip wadler report functional programming language haskell 
technical report yaleu dcs rr department computer science yale university december 
hen henderson 
purely functional operating systems 
darlington henderson turner editors functional programming applications pages cambridge university press 
hmt robert harper robin milner mads tofte 
definition standard ml version 
technical report ecs lfcs laboratory foundations computer science department computer science university edinburgh august 
hoa hoare 
communicating sequential processes 
comm 
acm 
hoa hoare 
communicating sequential processes 
prentice hall 
hol holmstrom 
functional language parallel programming implementation 
technical report programming methodology group university goteborg chalmers university technology september 
hud paul hudak 
manual programmer guide 
technical report yaleu dcs tr yale university department computer science august 
kah kahn 
information processing chapter semantics simple language parallel programming pages 
volume north holland 
kar karlsson 
nebula functional operating system 
technical report chalmers university 
kr brian kernighan dennis ritchie 
programming language 
prenticehall 
lan landin 
correspondence algol church lambda notation 
comm 
acm 
mh lee sean hayes 
interlanguage working pure functional language 
functional programming mailing list november 
mil robin milner 
calculus communicating systems 
volume lecture notes computer science springer verlag 
ss harald peter sestoft 
nondeterminism functional languages 
technical report department computer science university melbourne 
sto stoye 
new scheme writing functional operating systems 
technical report cambridge university computer laboratory 
tur david turner 
miranda non strict functional language polymorphic types 
proceedings ifip international conference functional programming languages computer architecture nancy france springer lecture notes computer science vol september 
tur david turner 
functional programming communicating processes pages 
volume lecture notes computer science springer verlag 
ww john williams edward wimmers 
sacrificing simplicity convenience draw line 
proceedings fifteenth annual acm sigact sigplan symposium principles programming languages san diego california january 

