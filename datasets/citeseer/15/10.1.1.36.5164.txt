chapter weighted grammar tools grm library mehryar mohri labs research park avenue rm florham park nj usa mohri research att com describe algorithmic software design principles general grammar library designed spoken dialogue systems speech synthesis speech processing applications 
library set general purpose software tools constructing modifying weighted finite state acceptors transducers representing grammars 
tools particular compile weighted contextdependent rewrite rules weighted finite state transducers read compile possible weighted context free grammars weighted automata dynamically modify compiled grammar automata 
dynamic modifications allowed include grammar switching dynamic modification rules dynamic activation non activation rules dynamic lists 
access features essential spoken dialogue applications 
motivation describe algorithmic software design principles general grammar library grm library designed spoken dialogue systems speech synthesis speech processing applications 
grammars speech processing applications weighted 
grammar weights crucial building robust spoken dialogue systems 
speech recognition grammar weights combined acoustic weights rank different hypotheses speech utterance rabiner juang jelinek 
due high variability input speech signal robust grammar admits hypothesis possible transcription certain degree probability 
jean claude van noord eds robustness language speech tech nology 
kluwer academic publishers pp 

mehryar mohri similarly speech synthesis tts applications weights produce single output presence ambiguities 
grammar weights weights context dependent morphological phonemic rules acoustic weights target join costs concatenative tts systems mohri riley select plausible output speech signal 
crucial requirement creating grammar library robust speech processing applications allows create weighted rules grammars 
original goal grm library provide algorithms representations constructing dynamic grammars speech recognition 
led requirements generality support representation various grammars dynamic speech recognition efficiency support competitive large vocabulary dynamic recognition automata states transitions 
generality led define extended algebraic framework algorithm general purpose finite state machine library fsm library mohri pereira riley 
weight set rules grammars grm library arbitrary semiring 
implementation algorithm general depend underlying semiring 
general implementation helps avoiding redundancy reducing amount code 
principle efficiency led design implement best known algorithm problem carefully reduce memory requirement implementation 
achieved particular devising dynamic fly algorithms compilation context free grammars 
necessary part resulting weighted automaton constructed expanded specific input sequence 
illustrate detail application principles design library 
overview grm library set general purpose software tools constructing modifying weighted finite state acceptors transducers representing grammars 
tools particular compile weighted contextdependent rewrite rules weighted finite state transducers read compile possible weighted context free grammars weighted automata dynamically modify compiled grammar automata 
dynamic modifications allowed include grammar switching dynamic modification rules 
see mohri definition frameworks corresponding generic algorithms shortest distance problems 

semiring ring may lack negation 
weighted grammar tools grm library dynamic activation non activation rules dynamic lists 
access features essential spoken dialogue applications 
grm library high level library fsm library mohri functions 
format automata transducers grm library compatible fsm library 
allows numerous utilities available fsm library manipulate machines created grm library 
particular compatibility general algorithms ffl removal ffl normalization determinization minimization weighted transducers optimize result compilation weighted rewrite rules weighted context free grammars 
grm tools accessible levels 
user program level grm user program level consists set programs manipulate grammars reading writing files pipelines grm textual file format specification 
example returns weighted finite state transducer represents context dependent rewrite rule input fsms library level grm library level consists library archive functions implement user program level 
typically program user level implemented call corresponding library function preceded grm fsm library function call read input rules input fsm internal object followed fsm library function call write resultant fsm 
definition level grm definition level consists definition level fsm library low level definitions objects defined grm library 
accessing level important wishes know finer points extend internals grm library 
compilation weighted rewrite rules library includes complete set routines utilities compile weighted context dependent rules weighted finite state transducers 

term fsm refer finite state machines format fsm library 
mehryar mohri weighted context dependent rules context dependent rewrite rules areas text speech processing including syntax morphology phonology 
shown johnson rewrite rules represented finite state transducers condition rule allowed apply finite number times output 
kaplan kay equivalently karttunen algorithm compiling rewrite rules finitestate transducers equivalent condition rewrite non contextual part 
assume condition follows 
applications related speech processing particular speech synthesis input may allow possible analyses 
weights assign likelihood uncertainty measure analyses 
generalized rules called weighted contextdependent rules 
formally weighted context dependent rewrite rules general form oe ae interpreted way oe replaced preceded followed ae 
ae represent left right contexts application rules 
rewriting condition mentioned previously means replacement oe serve context applications rule rewritten 
general oe ae regular expressions alphabet rules weighted regular expression rational power series berstel reutenauer salomaa 
weight set power series semiring phi omega 
cases considered speech synthesis applications weights interpreted gamma log probabilities viterbi approximation assumed 
appropriate semiring tropical semiring min 
context dependent rules optional obligatory mode depending occurrence oe appropriate context replaced obligatory case optional case 
rule applied left right right left simultaneous way 
applied left right replacement applies right output previous replacement 
similarly case right left application applies left output previous replacement 
simultaneous case contexts application rule directly determined original string replacement 
example weighted rule aa ba ffl replaces sequence aa ba weight aa left context right context ffl 
effect rule various strings illustrated weighted grammar tools grm library weighted finite state transducer realizing weighted left obligatory rule aa ba ffl 
transducer computed shell command lab aa bb eps aa bb eps automata representing aa ba ffl lab alphabet sigma fa bg 
ffl removed compacted utilities fsm library 
interpreted left right obligatory rule aaa aba aaaa aaaaa application rule contributes weight weight resulting string 
comparison right left obligatory application rule gives aaa aba aaaa aaaaa grm utilities illustration shows weighted transducer representing rule interpreted left right obligatory 
weighted transducer labeled directed graph transition labeled input symbol output symbol weight successful path path initial state states bold final state states represented double circles 
successful path transducer pairs concatenation input labels transitions corresponding output labels assigning pair omega product transition weights 
weight associated pair input output strings obtained phi sum weights successful paths labeled pair 
transducer obtained grm utility compiles rules weighted transducers 
syntax command similar definition rules 
takes mehryar mohri subsequential transducer realizing weighted left right obligatory rule aa ba ffl obtained transducer shell commands 
transducer subsequential minimal ffl considered regular symbol 
input fsms returns weighted transducer representing context dependent rewrite rule input fsms acceptors 
costless 
rule expresses fact string recognized replaced weighted strings recognized context preceded string recognized followed string recognized application rule proceeds left right default option specified 
proceeds right left specified applies parallel simultaneously option specified 
option specified ignored 
application rules obligatory option specified case replacement optional 
alphabet set symbols rule specified option symbols provide textual names symbols 
feature instance specify initial non terminal symbol option textual name instance corresponding number associated non terminal format finite state machines produced grm library compatible fsm library directly apply optimization algorithms weighted minimization output 
resulting minimal subsequential transducer shown 
applications may crucial optimized transducer representing weighted context dependent rule efficiency save space 
weighted grammar tools grm library fxy construction transducer replace 
algorithm section briefly presents illustrates compilation algorithm weighted context dependent rules implemented grm library 
refer reader mohri sproat detailed description algorithm 
algorithm marking transducers transducers introduce delete auxiliary symbols marking sequences described regular expression 
transducers introduce auxiliary symbols necessary opposed algorithm kaplan kay kk short introduces brackets restrict occurrence subsequently 
intermediate results compilation rules easier read check 
number intermediate transducers necessary construction rules smaller kk algorithm transducers constructed directly efficiently primitive expressions rule oe ae 
construction marking transducers consists automata linear size automata 
algorithm requires fewer compositions kk algorithm 
fly composition weighted transducers mohri pereira riley construct part compilation result needed specific input sequence considered 
algorithm shown efficient kk algorithm mohri 
sake simplicity illustrate algorithm case obligatory left right rule oe ae combinations optional right left simultaneous easily derived case 
composition cascade gives brief description compilation algorithm ffi ffi replace ffi ffi replace weighted transducers defined follows 
transducer marking transducer introducing auxiliary left bracket symbol 
belong alphabet sigma occurrence se mehryar mohri minimal deterministic automaton representing ff 
transducer post marking occurrence string described ff 
marking transducers quence accepted regular expression ae input 
described left right obligatory context dependent rule ffl 
sigma ae transducer marking transducer introducing auxiliary right bracket symbols occurrence sequence accepted oe followed string alphabet sigma auxiliary symbol freely appearing position 
ignored matching purposes 
corresponding transduction left right obligatory contextdependent rule alphabet sigma ffl 

sigma oe 
oe regular expression obtained oe freely allowing symbol oe 
oe oe necessary ignored determination occurrences oe 
ffif transforms input string introducing brackets left bracket right bracket sequences accepted oe followed sequence accepted ae 
transducer replace replaces oe sequences weighted sequences rational power series additionally erasing right bracket 
illustrates construction replace 
symbols need ignored determining occurrence oe loops transitions weighted grammar tools grm library transducer ffl ffl ffl states automaton accepting oe equivalently states transducer realizing cross product oe theta 
marking transducer accepts strings sequence accepted followed erases symbol strings 
described context dependent rule 
ffl sigma ffl denotes input sequence symbol ignored input 
similarly transducer marking transducer accepts strings preceded sequence accepted sequence accepted complement sigma denoted sigma erases auxiliary symbol strings 
ffl sigma ffl ffi accepts strings follows sequence recognized sequence recognized erases auxiliary symbols 
clear definition transducers realizes weighted transduction defined weighted context dependent rule 
note mehryar mohri transducer replace 
weighted transducer replace independent left right contexts ae computed independently 
construction marking transducer regular expression deterministic automaton representing expression 
illustrate describing construction marking transducer corresponding transduction sigma ff sigma ff ff arbitrary regular expression alphabet sigma 
sigma deterministic automaton recognizing ff sigma alphabet state set set initial states set final states finite set transitions viewed transducer assign transition output label equal input label 
modify corresponding transducer inserts symbol occurrence string accepted ff follows 
states gamma final 
state state new state copy created transitions final state non final outgoing transitions removed replaced single transition input label ffl output 
illustrates construction resulting transducer specific case ff figures give explicitly weighted grammar tools grm library intermediate results application transducer rule input string cab 
input automaton recognizing cab 
result application transducer 
result application 
result application replace 
result application 
final output resulting application ers compilation rule successive applications transducers input string cab illustrated figures 
compilation weighted context free grammars grm library includes general set algorithms utilities compile weighted context free grammars 
compilation algorithm executed demand needed recognition actual input utterances grammars dynamically modified 
weighted context free grammars context free grammars cfgs widely text speech processing applications 
applications speech recognition necessary weighted cfgs assigning weights grammar rules 
weights interpreted probabilities combined acoustic weights rank recognition transcriptions 
weight set weighted context free grammar semiring phi omega 
cases considered speech recognition applications weights interpreted gamma log probabilities viterbi approximation assumed 
appropriate semiring tropical semiring min 
example weighted cfg 
see bahl jelinek mercer mohri riley full description way grammar language model combined components recognition system pronunciation dictionary phonemic context dependency model acoustic model 
mehryar mohri xy ay bx simple cfg grammar assigns weight rule xy weight ay weighted cfg alphabet sigma weights semiring phi omega consists finite alphabet variables nonterminals disjoint sigma finite set theta theta sigma productions derivation rules autebert berstel boasson 
strings sigma weights write 
derivation weight weight denote lg weighted language generated nonterminal lg sigma theta 
context free grammars spoken dialogue applications represent regular languages church brown construction result finite state approximation general cfg pereira wright nederhof mohri nederhof 
real time applications general cfgs computationally demanding 
grm library provides general tools compiling weighted cfg weighted finite automaton certain general conditions described 
addition compilation method allows recognizer dynamically activate deactivate grammar rules substitute new regular language terminal symbols depending previously recognized inputs recompilation 
terminology field appropriate expression dynamic activation deactivation nonterminal symbols 
paragraphs define precisely dynamic modifications 
dynamic activation deactivation rules define set active nonterminals start symbols derivations 
set active nonterminals language generated lg lg note inactive nonterminals rules involving derivations just available start symbols 
dynamic rule weighted grammar tools grm library weighted finite automaton representing weighted cfg 
automaton computed shell command lab lab lab alphabet sigma fa zg textual representation cfg 
ffl removed minimized utilities fsm library 
tion deactivation consists exactly dynamic redefinition set successive uses grammar 
dynamic substitution oe weighted rational transduction sigma delta theta sigma delta regular weighted substitution berstel 
oe monoid morphism verifying sigma oe reg delta theta reg delta theta denotes set weighted regular languages alphabet delta 
oe simply substitutes symbol sigma weighted regular expression oe 
dynamic substitution consists application substitution oe sigma process recognition word sequence 
substitution language generated new grammar lg oe grm compilation algorithm allows dynamic grammar changes recompiling grammar 
grm utilities illustration textual representation grammar grm library simply 
oe extended usual map sigma theta reg delta theta 
mehryar mohri weighted transducer output 
shows weighted automaton result compilation weighted cfg start symbol grm utilities 
takes input textual representation weighted contextfree grammar file standard input sends standard output binary encoding weighted transducer representing grammar 
grammar represented compound rules factorization left hand side rules option 
example compact representation grammar input symbols represented input file non negative numbers option 
option allows non terminal terminal symbols textual names file symbols gives translation names numbers 
input unweighted context free grammar option case weighted context free grammar 
representation grammar weighted transducer crucial optimized compacted minimized mohri mohri 
preprocessing dramatically improves time space required main compilation step increased sharing grammar rules start way mohri pereira 
shows output grammar compaction 
accepts input weighted transducer representing context free grammar returns delayed weighted acceptor recognizing grammar 
input transducer represent context free grammar weighted regular language 
precisely restriction rules weighted grammar tools grm library context free grammar rules set non terminals mutually dependent set fx instance depending depending right linear left linear respect elements set 
example grammar ary cv td tv formed 
non terminals depend rules defining right linear respect grammar ary cv td dx formed depend rule ary instance left linear right linear respect symbols 
start symbol grammar specified option 
option provide textual name non terminal symbol 
option error messages 
list non terminals problematic printed input grammar formed 
grammar right linear rules left linear rules efficient compilation algorithm 
option purpose 
object returned delayed acceptor admits fsm operation valid acceptors 
necessary part acceptor states transitions expanded fsm operation 
delayed objects created grm library fsm classes edit class replace class 
essential features allow dynamically modify input grammar 

particular acceptor returned belongs replace class 
mehryar mohri edit class edit class fsm class defined grm library 
allows users dynamically modify initial state fsm final cost state fsm 
edit class object represents fsm defined input fsm new initial state state final cost fsm exactly machine obtained delayed operations state new initial state final cost assigned replace class replace class fsm class defined grm library 
allows users construct fsms labels referring fsms 
replace class object represents fsm defined fsm gives general structure array fsms indexed set symbols including input labels fsm exactly result replacement label defined 
replacements done demand input 
case replace class acceptors representing context free grammars typically defined corresponding non terminal symbol acceptor accepting exactly set initial non terminals grammar 
dynamic modifications dynamic modifications input grammar essential systems 
systems require grammars language models evolve dialogue proceeds exploit information context provided previous interactions 
instance previous request address activate address grammar lexicon date grammar lexicon automated reservations task 
dynamic grammars significantly improve efficiency accuracy system considerably restricting set possible transcriptions 
result compilation cfg directly modified command level dynamic modification utilities 
note modifications require recompilation grammar 
results just inputs delayed objects replace class 
possible definition replace class 
takes input finite state machine returns fsm belongs grm replace class 
takes input fsms returns fsm result replacement structure fsm typical application dynamic modification initial non terminal symbols weighted grammar tools grm library dynamically modified grammar active non terminals weights 
automaton generated shell command delayed object output applied grammar activation acceptor 
context free grammar called dynamic activation inactivation rules context free grammar defined 
illustrates corresponding output automaton 
takes input substitution file finite state machine returns fsm obtained substituting fsms symbols mapping defined substitution file 
typical application dynamic replacement terminal symbols context free grammar called dynamic lists 
grm library successfully compile dynamically modify context free grammars rules 
algorithm section briefly presents illustrates compilation algorithm weighted cfgs implemented grm library 
refer reader mohri pereira detailed description algorithm 
algorithm gives transducer representation input grammar minimized take advantage sharing rules 
transducer representation 
build dependency graph dg input grammar graph node corresponding non terminal edge node node non terminal appears right hand side rule left hand side 
compute strongly connected components dg sets mutually dependent non terminals 
assuming grammar reduced scc left linear right linear weighted automaton constructed 
recall strongly connected components sccs directed graph equivalence classes nodes relation defined reached tarjan 
mehryar mohri compact transducer representation grammar scc non terminal weighted automaton built 
simple automaton mg accepting exactly set active nonterminals constructed 
automaton expanded fly input string lazy replacement editing 
consecutive steps compilation algorithm illustrated cfg zy ay bx grammar shows representation weighted transducer benefit transducer determinization minimization sharing rules starting way 
gives dependency graph grammar sccs 
construction delayed operation edit class derived just picking state associated 
weighted grammar tools grm library dependency graph dg grammar strongly connected components dg ft zg fx weighted automaton scc ft zg 
weighted automaton scc fx construction automata representing left linear right linear grammars classical aho hopcroft ullman 
construction easily extended weighted grammars build weighted automata corresponding sccs see 
compilation algorithm works class grammars grammar restricted scc left linear right linear 
cover large set useful grammars 
general algorithm mapping arbitrary cfg generating regular language corresponding finite automaton restriction necessary 
automaton corresponding non terminal easily constructed making final left linear case initial right linear case corresponding state 
mentioned implementation operation delayed 
automaton instance constructed expanded needed specific input string parse 
automaton mg accepts exactly set active non terminals 
shows automaton specific case ft xg 
note automaton dynamically modified requiring recompilation grammar steps algorithm need repeated 
automaton mg expanded input string lazy replacement editing non terminal symbol replaced thefly corresponding automaton computed delayed editing operation automaton shows mehryar mohri automaton mg accepting set active non terminals ft xg 
automaton mg full expansion 
fully expanded automaton mg removal ffl determinization minimization 
experiments full bigram models various vocabulary sizes unweighted grammars derived feature instantiation hand built feature grammars showed efficiency algorithm mohri pereira 
general weighted grammar library designed systems speech synthesis speech processing applications 
notions semiring rational power series code variety different applications 
current version library written semiring operations defined fsm library 
library tested randomly generated automata 
efficiency tested compiling dynamically modifying successfully large grammars rules 
grm library currently projects included product watson 
planned available academic near mohri 
includes utilities local determinization useful context speech recognition projects 
weighted grammar tools grm library compilation algorithm programs context dependent rules shown efficient tasks 
lucent bell laboratories develop tts text analyzers languages including spanish italian french romanian german russian mandarin japanese 
labs research construct efficiently components speech understanding system finite state transducers 
grm utilities compiling weighted context dependent rules compile decision trees weighted transducers sproat riley build general context dependent model transducers speech recognition systems 
compilation algorithms tools weighted context free grammars various speech processing projects including construction spoken dialog systems speech translation systems labs research 
versions grm library include compiler rational power series algorithms constructing compiling weighted approximations weighted context free grammars mohri nederhof transducer learning algorithms tools 
generality replace edit classes directly incorporated fsm library versions libraries 
acknowledgments richard sproat michael riley fernando pereira discussions utilities library ted bruce comments help defining dynamic grammar features 
grm programs kindly tested richard sproat ted bruce context various text speech processing applications 
aho hopcroft ullman design analysis computer algorithms addison wesley reading ma 
autebert berstel boasson context free languages pushdown automata rozenberg salomaa eds handbook formal languages vol 
springer pp 

bahl jelinek mercer maximum likelihood approach continuous speech recognition ieee transactions pattern analysis machine intelligence pami 
berstel transductions context free languages teubner stuttgart 
berstel reutenauer rational series languages springer verlag berlin new york 
mohri riley rapid unit selection large speech corpus concatenative speech synthesis proceedings th european conference speech communication technology eurospeech budapest hungary 
mehryar mohri brown context free grammar compiler speech understanding systems proceedings international conference spoken language processing icslp yokohama japan pp 

church finite state parser speech recognition st meeting association computational linguistics acl proceedings conference acl 
jelinek statistical methods speech recognition mit press cambridge ma 
johnson formal aspects phonological description mouton mouton hague 
kaplan kay regular models phonological rule systems computational linguistics 
karttunen replace operator rd meeting association computational linguistics acl proceedings conference mit acl cambridge ma 
mohri general purpose weighted grammar tools grm library labs research 
www research att com sw tools grm 
mohri finite state transducers language speech processing computational linguistics 
mohri general algebraic frameworks algorithms shortest distance problems technical memorandum tm labs research pages 
mohri minimization algorithms sequential transducers theoretical computer science 
mohri nederhof regular approximation context free grammars transformation 
van noord eds robustness language speech technology kluwer academic publishers netherlands 
volume 
mohri pereira dynamic compilation weighted context free grammars th meeting association computational linguistics acl proceedings conference acl canada 
mohri pereira riley weighted automata text speech processing proceedings th biennial european conference artificial intelligence ecai workshop extended finite state models language ecai budapest hungary 
mohri pereira riley design principles weighted finite state transducer library theoretical computer science 
mohri riley integrated context dependent networks large vocabulary speech recognition proceedings th european conference speech communication technology eurospeech budapest hungary 
mohri sproat efficient compiler weighted rewrite rules th meeting association computational linguistics acl proceedings conference acl santa cruz ca 
nederhof context free parsing regular approximation proceedings international workshop finite state methods natural language processing ankara turkey pp 

pereira wright finite state approximation phrase structure grammars th annual meeting association computational linguistics acl proceedings conference acl berkeley ca 
rabiner juang fundamentals speech recognition prentice hall englewood cliffs nj 
salomaa automata theoretic aspects formal power series springerverlag new york 
sproat riley compilation weighted finite state transducers decision trees th meeting association computational linguistics acl proceedings conference santa cruz california acl 
tarjan depth search linear graph algorithm siam journal computing 
partial algorithm problems context free languages information control 
