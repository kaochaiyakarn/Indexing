truth maintenance david mcallester massachusetts institute technology artificial intelligence laboratory dam ai mit edu appeared aaai 
postscript electronic source ftp ai mit edu pub dam aaai ps 
bibtex ftp ai mit edu pub dam dam bib 
general purpose truth maintenance systems received considerable attention past years 
discusses functionality truth maintenance systems compares various existing algorithms 
applications directions research discussed 
jon doyle wrote masters thesis mit ai laboratory entitled truth maintenance systems problem solving doyle thesis doyle described independent module called truth maintenance system tms maintained beliefs general problem solving systems 
twelve years appearance doyle tms large body literature accumulated truth maintenance 
seminal idea appears particular technical mechanism general concept independent module truth belief maintenance 
truth maintenance systems manipulate proposition symbols relationships proposition symbols 
term boolean constraint mean boolean formula built proposition symbols standard boolean connectives 
implication conjunction negation 
monotonic tms manipulates proposition symbols boolean constraints 
non monotonic tms allows heuristic non monotonic relationships proposition symbols true true evidence contrary assume 
semantics monotonic truth maintenance systems quite clear semantics non monotonic systems focus considerable research past decade supported part national science foundation contract iri part advanced research projects agency department defense office naval research contract 
lead development non monotonic logics 
non monotonic logic closely related belief functions certainty factors defaults type hierarchies 
issues surrounding belief certainty pearl discussion defaults type hierarchies touretzky approaches theory non monotonic logic mccarthy konolige gelfond lifschitz gelfond having briefly mentioned non monotonic logic remainder dedicated exclusively monotonic truth maintenance systems 
reasons 
development truth maintenance algorithms de kleer atms algorithm particular de kleer concern monotonic systems 
second practical applications truth maintenance systems involve monotonic systems qualitative simulation fault diagnosis applications search 
furthermore monotonic truth maintenance systems provide solid foundation build kinds systems algorithms monotonic systems usually nonmonotonic systems converse hold 
survey begins specification functionality monotonic truth maintenance systems 
specification set functions generic interface existing systems 
interface function clean non computational specification 
presenting interface various implementations 
followed discussion applications truth maintenance systems solving search problems 
brief discussion current research construction powerful algorithms 
generic tms interface monotonic tms general facility manipulating boolean constraints proposition symbols 
example automobile diagnosis want enforce constraint spark plug rotor turning 
constraint form proposition symbols outside observer interpret representations statements spark plug rotor turning respectively 
set propositions automobile engines set constraints propositions implication set observations particular automobile tms ask questions consequences observations 
describe functionality monotonic tms specifying generic interface functions 
tms stores set boolean constraints boolean formulas intuitively interested truth assignments satisfy stored set constraints 
constraints appear explicitly arguments interface functions call internal constraints 
interface function add constraint adds constraint internal constraint set 
constraint added removed 
remaining interface functions manipulate literals literal proposition symbol negation proposition symbol 
second interface function follows takes arguments literal phi set literals sigma called premise set 
application follows 
phi sigma return unknown 
follows 
phi sigma returns tms guarantees phi follows premise set sigma internal constraints 
follows 
phi sigma returns tms guarantees phi follow exists interpretation satisfying internal constraints sigma phi false 
tms unable determine phi follows follows 
phi sigma returns unknown 
automobile diagnosis system internal constraints consist facts true automobiles spark plug rotor turning premise sets consist observations particular automobiles 
third fourth interface functions compute justifications 
tms determine phi follows internal constraints premise set sigma ask tms justify fact produce proof phi 
interface functions generate proofs justifying literals justifying constraints 
functions take arguments literal premise set literal derived 
phi derivable sigma internal constraints phi sigma returns set literals phi sigma returns subset internal constraints satisfying conditions 
ffl phi follows literals justifying literals phi sigma constraints justifying constraints phi sigma 
ffl follows 
psi sigma returns literal psi justifying literals phi sigma 
suppose internal constraint set includes constraints truth maintenance systems able derive constraints premise set fp wg 
truth maintenance systems provide justifications relative constraints premises 
derived justifying justifying literal literals constraints fq rg sg fp wg rg fpg fp qg set internal constraints premise set formula derived constraints premises justification functions generate justification tree root tree formula node tree function justifying literals get children nodes reaches members premise set 
justifications required non circular appears justification tree rooted appear justification tree rooted note justifications table local sense justification single justifying constraint 
general require justifications local sense 
virtually tms implementations local derived literal justified terms literals single internal constraint 
contradiction handling specification generic tms interface allows contradictory information tms 
truth maintenance systems way informing user premise set inconsistent internal constraints 
done adding special proposition symbol called contradiction 
tms able determine premise set sigma contradicts internal constraints follows 
contradiction sigma returns 
furthermore follows 
contradiction sigma returns justifying literals contradiction sigma justifying constraints contradiction sigma return set literals set constraints respectively underlie contradiction 
justification functions construct justification tree leaves literals sigma 
allows contradiction blamed subset sigma 
bcp implementations suppose wish compute value application follows 
phi sigma 
done conceptually simple procedure known boolean constraint propagation bcp 
consider network nodes proposition symbols appear premise set sigma internal constraint set 
boolean constraint viewed connection link nodes network 
node proposition symbol labeled possible labels true false unknown 
initially nodes labeled unknown 
compute consequences particular premise set sigma assigns label true false proposition symbol set literals sigma depending symbol appears positively negatively sigma 
new labels computed local propagation new truth label follows existing labels single internal constraint new label added network propagation continues 
set derived labels violates internal constraints special proposition contradiction labeled true 
propagation process newly derived label associated justification data structure records labels constraint derivation 
constraint clause disjunction literals propagation process run completion time linear total size set constraints mcallester answer query form follows 
phi sigma simply runs boolean constraint propagation process starting labels sigma determines label derived proposition symbol literal phi label derived proposition symbol label sign sign literal phi follows 
returns follows 
returns unknown 
boolean constraint propagation logically complete 
example consider constraints literal follows constraints follow constraint individually 
bcp deduce follows constraints 
incompleteness bcp represents compromise functionality efficiency 
boolean constraint propagation runs linear time total size constraint set clausal constraints 
boolean entailment efficient algorithm expected 
incremental context switching 
consecutive queries truth maintenance system similar premise sets 
example user ask follows 
phi sigma ask phi sigma sigma sigma large premise sets differ literals 
propagation answer query answering second query efficient 
done incremental premise retraction incremental premise addition doyle mcallester incremental addition retraction algorithms allow set proposition labels incrementally switched labeling generated sigma labeling generated sigma alternative unrestricted incremental retraction store current premise set premise stack 
new premise pushed premise stack incremental boolean constraint propagation add new truth labels 
premise popped simple undo list remove labels added premise pushed 
consider consecutive queries form phi sigma follows 
phi sigma 
labeling query incrementally computed pushing elements sigma premise stack 
compute labeling sigma pops back premise set subset sigma pushes premises sigma 
premise stack implementation unrestricted incremental implementation provide generic interface functionality level generic interface ask premise set time 
premise stack implementation efficient unrestricted incremental retraction implementation depends statistics consecutive queries 
individual retractions premise stack implementation considerably efficient 
premise stack implementation may require retractions assertions transition labeling states 
application set truth assignments systematically explored algorithms solving constraint satisfaction problems premise stack implementation efficient 
premise stack implementation efficient premises static included premises changed arrange changing premises migrate top stack small retractions additions done switching contexts 
atms implementations initially describe de kleer atms de kleer alternative implementation generic tms interface compare atms implementation bcp implementation 
applications difference atms bcp implementations relative efficiency implementations generic interface 
atms just alternative implementation interface certain additional interface functions easily implemented top atms algorithms top bcp 
additional functionality atms discussed 
universal propagation 
bcp implementation atms implementation generic interface operates propagating labels network nodes propositions connected boolean constraints 
atms implementation atms described version de kleer propagation process independent particular premise set single universal propagation process answers possible queries de kleer universal propagation process efficient user declare priori set possible premises 
possible premise literal premise set query atms subset set possible premises 
atms algorithm label set premise sets 
proposition network true false label 
proposition true label consisting premise sets sigma sigma sigma logically follows sigma internal constraints 
analogous statement holds premise sets false label premise sets propagated constraints 
example sigma premise set member true label sigma premise set true label internal constraint premise set sigma sigma added true label propagation process initialized inserting singleton premise set label possible premise 
example possible premise singleton premise set fpg inserted true label universal propagation performed answer query form sigma checking see exists premise set true label subset sigma 
analogous test queries involving negative literals 
total number propagations total number premise sets generated reduced imposing filters premise sets labels 
premise sets consistent 
obviously premise set contain proposition negation 
addition special proposition contradiction stronger consistency filter 
premise set label true label contradiction contain subset premise set member label contradiction 
second filter involves notion subsumption 
sigma sigma premise sets label sigma proper subset sigma label sigma removed 
atms runs single universal propagation process completion filters prune premise sets labels 
universal propagation bcp 
notation gamma sigma bcp phi indicate phi derived internal constraint set gamma premise 
de kleer original atms allowed horn clause constraints allowed positive literals queries 
restrictions original atms identical system described 
similar universal propagation process truth maintenance systems developed independently drew mcdermott mcdermott 
set sigma boolean constraint propagation 
discussion symbol gamma freely denote fixed arbitrary internal constraint set 
support proposition symbol premise set sigma satisfying conditions ffl gamma sigma bcp ffl gamma sigma bcp contradiction ffl proper subset sigma sigma gamma sigma bcp universal atms propagation procedure run completion premise sets true label precisely supports implies atms implements exactly behavior bcp tms 
atms complexity 
atms bcp implementations generate exactly behavior level generic interface 
furthermore bcp implementation guaranteed require linear space linear time query 
hand label contain exponential number different minimal premise sets atms implementation require exponential time exponential space answer single query 
worst case behavior easily realized case boolean constraints horn clauses implication cycles 
propose algorithm exponential time space improvement algorithm linear 
answer exponential atms algorithm better performance applications 
cases label sets remain small query answering pre computed label sets efficient bcp implementation 
problem size grows exponential cost universal atms propagation begins dominate potential savings query time 
reason preferring atms algorithm involves additional functionality discussed section 
additional functionality atms 
atms universal propagation algorithm computes minimal sets assumptions necessary derive formula 
feature useful device diagnosis wants find minimal number possible faults explains observed behavior de kleer williams de kleer williams fault diagnosis interested premise sets contain single fault 
noted atms described different clause management system described de kleer reiter 
clause management system cms requires logical completeness 
constraints restricted horn clauses queries restricted positive literals original atms bcp logically complete cms bcp specifications equivalent 
single fault assumption full generality atms needed 
applications search said truth maintenance systems useful controlling search doyle de kleer search loosely defined term claim difficult evaluate general 
attempt evaluate general claim consider restricted class search problems known constraint satisfaction problems csps 
csp consists set variables variable associated finite set possible values plus set constraints 
constraint consists variables plus enumeration allowed pairs values variables 
assignment values variables csp said satisfy constraint pair values assigned variables constraint allowed pairs constraint 
solution csp assignment values variables csp satisfies constraints csp 
easy show determining existence solutions csps npcomplete 
definition csp generalized allow constraints variables changing essentials analysis 
large literature algorithms efficiently finding solutions constraint satisfaction problems 
best general theoretical framework knuth methods evaluating running time backtrack search knuth knuth introduces notion consistency test applied node backtrack search tree 
today wide variety possible consistency tests effective form constraint propagation mackworth pearl korf addition constraint propagation consistency tests variety heuristics selecting variable instantiate value variable try haralick elliot freuder dechter pearl zabih furthermore variety mechanisms backjumping jumping back earlier choice points dependency analysis shows intervening choices involved cause failure stallman sussman gaschnig bruynooghe pereira research algorithms solving csps continues active 
translating csps boolean clauses 
possible tms foundation procedure solving arbitrary csps 
truth maintenance techniques operate boolean constraints csps defined 
tms solving csp translate csp set boolean constraints 
specifically variable possible values xn introduce proposition symbols xn constraints delta delta delta xn constraints form set disjunctive clauses equivalent statement exactly propositions true 
simple ways translating constraints csp constraints proposition symbols 
translation call negative translation 
consider constraint variables pair 
possible values respectively allowed pair constraint add clause 
csp defined set boolean clauses generated variables constraints way 
second translation call positive translation 
consider constraint variables possible value set possible values 
allowed pair constraint 
possible value add constraint delta delta delta implication equivalent clause disjunction literals 
constraint satisfaction problem denote positive translation set disjunctive clauses 
interesting note size translation governed number incompatible pairs values constraints size governed number allowed pairs values constraints 
tms solve csp 
constraint satisfaction problem possible give boolean constraint set constraint set tms 
simple backtrack program written search assignments values csp variables partial assignment encoded tms premise sets form 
filter imposed backtrack search asking tms node search tree special node contradiction derivable current partial assignment 
positive translation convert csp boolean constraints tms simulates bcp filter equivalent classical arc consistency 
negative translation tms simulates bcp filter weaker efficient classical linear time bcp algorithm clausal constraints implies arc consistency achieved time proportional number consistent pairs values constrained pairs variables 
bcp provides alternative algorithm achieving arc consistency complexity bound mohr henderson 
arc consistency 
filter results bcp applied negative translation called bcp consistency 
addition providing powerful search filters justification facility tms provides mechanism performing certain form backjumping known dependency directed backtracking stallman sussman failure occurs search process justification mechanisms uncover subset current premise set derive special proposition contradiction 
allows new constraint installed called nogood states premises false 
new derived constraint allows bcp inferences possible old constraints consistency filter remaining search stronger 
dependency directed backtracking backjumping general particularly useful reason poor choice selecting order variables instantiated backtrack search process 
knowledge established pragmatic value backjumping search careful variable ordering constraint propagation consistency testing 
potential generating exponential number additional derived constraints dependency directed backtracking particularly expensive form backjumping 
atms universal propagation algorithm applied boolean translation csp de kleer addition clauses generated translation specify assumption form possible premise 
additional proposition called variables assigned introduced bcp derive proposition assigned proposition form derived variable running atms universal propagation procedure set solutions csp contained true label proposition variables assigned 
note variable assignments violate constraints automatically removed consistency filtration premise sets universal atms algorithm 
way universal atms propagation procedure yields choices backtracking de kleer efficient natural justification structure proposition variables assigned cause atms universal propagation procedure simulate backtrack search fixed order variables considered 
backtrack search done space intensive breadth manner space efficient depth manner 
general space intensive breadth searches considered efficient time space space efficient depth searches pearl korf knowledge atms shown time efficient enumerating solutions csp classical backtracking approaches 
truth maintenance systems may useful general method solving csps provide general efficient mechanism constraint propagation consistency testing partial assignments 
ways tms technology applied csps dependency directed backtracking atms universal propagation appear limited value 
atms universal propagation procedure probably appropriate finding minimal premise sets satisfying condition 
general problem solving truth maintenance systems viewed integral part ai languages knowledge representation programming languages designed allow rapid development expert systems general problem solvers de kleer de kleer highly successful incorporation constraint propagation aspects truth maintenance general purpose language van hentenryck version prolog called chip constraint handling prolog van hentenryck van hentenryck version prolog related literature truth maintenance systems 
languages combine automatic backtracking automatic constraint propagation major competitor tms ai languages 
term van hentenryck language general term programming language combines automatic backtracking automatic constraint propagation 
describe van hentenryck version prolog describe van hentenryck dialect lisp called constraint handling lisp 
built scheme dialect lisp provides call 
automatic backtracking incorporated scheme adding new primitives fail 
special form takes arguments non deterministically returns value 
procedure fail causes computation restarted nondeterministic choice 
scheme implementation call current continuation primitives fail efficiently implemented additional lines code 
standard prolog primitives cut bag implemented similar ease 
procedures fail provide automatic backtracking allow concise expression large variety backtrack search programs 
automatic con version mccarthy amb mccarthy 
word reads naturally 
straint propagation added procedures domain object add constraint force value 
procedure domain object takes argument list possible values returns data structure represents csp variable set possible values 
procedure add constraint takes arguments domain objects objects returned ordinary scheme predicate arguments 
procedure add constraint installs constraint stating simultaneous values domain objects satisfy predicate 
procedure force value takes domain object non deterministically assigns domain object possible values 
procedure automatically invokes constraint propagation 
constraint propagation result constraint violation force value returns selected value 
backtracking occurs 
primitives constraint propagation version queens problem expressed follows 
define queens queen variables map lambda ignore domain numbers numbers add constraint nth queen variables nth queen variables lambda map force value queen variables program uses numbers nth scheme primitives easily defined 
procedure expression bag queens evaluates list solutions queens problem 
furthermore search process specified procedure uses constraint propagation consistency testing node search tree 
van hentenryck shown addition automatic constraint propagation languages automatic backtracking drastically improve performance wide variety useful backtrack search programs 
strengthening constraint propagation constraint propagation appears central importance search problem solving 
way attempting discover powerful constraint propagation techniques study relationship constraint propagation inference 
constraint propagation form inference values unassigned variables deduced values assigned 
relationship inference constraint propagation explicit characterizing constraint propagation processes terms inference rules 
boolean constraint propagation defined terms certain incomplete set inference rules boolean logic mcallester van hentenryck defines various constraint propagation techniques chip terms rules inference 
fact virtually form constraint propagation defined terms rules inference 
constraint propagation inference rules unusual rules inference possible determine polynomial time statement derived premises 
words constraint propagation inference rules generate polynomial time decidable inference relation relations called tractable 
constraint propagation technique corresponds tractable inference relation tractable inference relations correspond standard constraint propagation technique 
example inference rules define bcp combined standard inference rules equality including substitution equals equals resulting rule set polynomial time decidable mcallester mcallester argued power tractable rule sets order inference sensitive syntax formulas expressed alternative syntax taxonomic relationships classes yields powerful tractable rule set 
mcallester givan argued power tractable rule set improved syntax specifier structure natural language noun phrases montague semantics 
observation provides functional justification syntactic features natural language 
mcallester general theory tractable rule sets algorithm automatically recognizing tractability rule sets 
inference closely related constraint propagation constraint propagation clearly important improving search efficiency 
people inference drastically reduce amount search required problem solving 
possible power human inference generalizations constraint propagation powerful tractable inference relations computed fraction second 
hope construction efficient general purpose inference mechanisms 
bruynooghe pereira bruynooghe pereira 
deduction revision intelligent backtracking 
editor implementations prolog pages 
ellis horwood 
dechter pearl dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
de kleer williams de kleer williams 
diagnosing multiple faults 
artificial intelligence 
de kleer williams de kleer williams 
diagnosis behavioral modes 
proceedings ijcai pages 
de kleer reiter de kleer reiter 
foundations assumption truth maintenance systems 
aaai pages 
de kleer de kleer 
choices backtracking 
proceedings aaai pages 
de kleer de kleer 
assumption tms 
artificial intelligence 
de kleer de kleer 
extending atms 
artificial intelligence 
de kleer de kleer 
problem solving atms 
artificial intelligence 
de kleer de kleer comparison atms csp techniques proceedings eleventh international joint conference artificial intelligence detroit mi august 
de kleer de kleer exploiting locality atms aaai boston mass 
august 
de kleer de kleer 
practical clause management system 
ssl xerox parc submitted publication 
doyle doyle 
truth maintenance system 
artificial intelligence 
freuder freuder 
sufficient condition backtrack bounded search 
acm 
gaschnig gaschnig 
performance measurement analysis certain search algorithms 
report cmu 
gelfond lifschitz gelfond lifschitz 
stable model semantics logic programming 
logic programming proceedings fifth international conference symposium pages 
gelfond gelfond 
autoepistemic logic formalization common sense reasoning preliminary report 
non monotonic reasoning nd international workshop lecture notes artificial intelligence pages 
springer verlag 
haralick elliot haralick elliot 
increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 
van hentenryck van hentenryck 
constraint satisfaction logic programming 
mit press 
knuth knuth 
estimating efficiency backtrack programs 
mathematics computation january 
konolige konolige 
relationship default theories non monotonic logic 
artificial intelligence 
mackworth mackworth 
consistency networks relations 
artificial intelligence 
mcallester givan mcallester givan 
natural language syntax order inference 
memo mit artificial intelligence laboratory october 
mcallester mcallester givan 
taxonomic syntax order inference 
proceedings international conference principles knowledge representation reasoning pages 
mcallester mcallester 
outlook truth maintenance 
memo mit artificial intelligence laboratory august 
mcallester mcallester 
knowledge representation system mathematics 
mit press 
mcallester mcallester 
automatic recognition tractability inference relations 
memo mit artificial intelligence laboratory february 
mccarthy mccarthy 
basis mathematical theory computation 
hirschberg editors computer programming formal systems 
north holland 
mccarthy mccarthy 
applications circumscription formalizing common sense reasoning 
artificial intelligence 
mcdermott mcdermott 
contexts data dependencies synthesis 
ieee transaction pattern analysis machine intelligence 
mohr henderson mohr henderson 
arc path consistency revisited 
artificial intelligence 
pearl korf pearl korf 
search techniques 
ann 
rev 
sci 
pearl pearl 
probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann 
stallman sussman stallman sussman 
forward reasoning dependency directed backtracking system computer aided circuit analysis 
artificial intelligence 
touretzky touretzky 
mathematics inheritance systems 
morgan kaufmann 
zabih zabih applications graph bandwidth constraint satisfaction problems 
aaai 
