static semantics haskell simon peyton jones philip wadler department computing science university glasgow qq email cs glasgow ac uk may gives static semantics large subset haskell including giving translation language overloading 
intention cover complete language due course 
innovative aspect ideas second order lambda calculus record type information program 
contents sketch overloading resolved notation syntax programs type declarations class declarations instance declarations value declarations expressions pattern matching dictionary manipulation implementation notes list figures syntax semantic types environments syntax haskell declarations bindings syntax haskell patterns expressions syntax haskell types extra syntax translated programs rule programs rules monotype rules context polytype rules type declarations rules class declarations instance declarations rules monobinds rules binds rules bind type signatures basic rules expressions non syntactic rules expressions rules compound expressions data structures expressions rules enumerations expressions rules quals realistic expression signature rule rules patterns rules match mrule grhs dictionary manipulation purpose give complete static semantics haskell hudak 
approach giving static semantics give translation full language core static semantics 
economical translations elaborate lead incomprehensible error messages type checker 
chosen give static semantics language directly 
wadler blott give formal set type rules describe form overloading haskell 
compact elegant rules quite hard understand especially take explicit account haskell class declarations 
effect class single overloaded operation identify class operation 
adequate operation dictionary mesh haskell performing mental translation quite tricky 
provide set type rules avoids difficulties covers complete language small subset 
overview modelled definition standard ml harper milner tofte provided useful source ideas high standard 
addition performing type inference type system gives translation original source program implied aspects explicit ffl polymorphism explicit type abstraction application exactly second order lambda calculus 
necessary stages compiler know types parts program 
example strictness analyser needs know looking fixed points code generator may able generate better code knows certain types occur 
possible include type information annotating parse tree program hard maintain information program transformed subsequent compiler passes 
machinery second order lambda calculus far know original way ensure type information maintained consistently face transformations 
nice see practical application beautiful calculus 
ffl overloading explicit passing extra dictionary parameters overloaded functions dictionaries include methods implement operations class 
exactly done quite subtle explained informally section 
section summary notation 
section gives syntax source language target translated language 
followed type inference rules rules programs section working smaller constructs sections 
non linear order reading productive sections linear pass 
careful correspondence maintained source syntax inference rules ffl syntactic nonterminal judgement form ffl syntactic production nonterminal inference rule judgement form corresponding nonterminal 
addition inference rules syntax driven 
examples rules spec gen introducing eliminating polymorphic types 
shortcomings incomplete 
aspects haskell covered rough order priority ffl imports 
ffl ambiguity 
ffl deriving clauses data declarations 
ffl default declarations class declarations 
ffl constant patterns 
require substantially sophisticated pat judgement 
reason constants involve translation due overloading patterns require translation subtract addition hope add sections giving advice implementation 
list unresolved issues ffl prove substitution lemma 
ffl prove principal type theorem 
ffl derivations give translation 
proved different ones equivalent 
ffl interaction monomorphic pattern bindings ambiguity 
consider expression 
making monomorphic result free dictionary stage resolved ambiguity mechanism 
cases cause error ambiguity resolution mechanism restricted numeric classes 
better exclude unused definitions assume done initial dependency analysis 
simply remove unused case contain type error 
top level careful eliminate exported 
sketch overloading resolved distinctive feature haskell type system provision systematic overloading 
section sketch informally overloading implemented assume familiarity programmers eye view haskell 
overloading resolved translating program equivalent non overloaded overloaded functions take extra parameters 
example ord num 


belong type instance ord operation num operation 
phrase ord num called context consists ordered sequence class assertions 
translation looks 
takes extra dictionary arguments class assertion context type order translated program functions 
selectors extract appropriate method dictionary applied method extracted actual comparison addition 
consider call int 
int deliberately general type signature 
translation ordint extra parameters supplied ord dictionary num dictionary int type 
formal type rules deliberately away dictionary arguments passed curried fashion example uncurried fashion tuple dictionaries 
examples stick curried form 
strictly speaking translated programs types attached variable pattern omit clarity 
dictionaries dictionary contain 
format set class declaration example taken prelude class real fractional 

integer 

rational dictionary class parts may empty ffl part consists dictionaries superclasses case real fractional 
ffl second part consists methods class case methods 
dictionary usually represented tuple components actual type rules away details representation 
instances instance declaration may context example instance eq eq 
eq instance declaration produce dictionary function dictionaries equality things type returns dictionary equality things type 
suppose function called 
function definition eq 


bool translate eqd eqd notation section summarises notational conventions 
sequences notation hx stands ordered sequence identifiers sequences concatenated 
judgements judgement form nonterminal syntax rule judgement form production nonterminal 
total large number judgements take forms 
quite conventional inherited nonterminal construct synthesised read information inherited derive information synthesised construct construct construct right hand side productions nonterminal typical form general scheme deduce types environment nonterminal construct type general synthesised may type set value type bindings overloaded context example 
rules designed derivation type inference algorithm easy possible 
particular inherited parts generally arguments type inference function synthesised parts generally result 
annotation nonterminal turnstile serves identify judgement form 
rules judgement form give general form judgement explicit form judgement 
rules express translation language construct case second form judgement inherited nonterminal construct construct synthesised read information inherited derive information synthesised construct construct translates construct 
general italic source language nonterminals nonterminal bold font target language nonterminals nonterminal 
types distinguish syntactic types written haskell programmer syntax section semantic types manipulated type inference rules 
denoted words monotype denoted symbols correspondence table syntactic form semantic form type variable tyvar ff monotype monotype overloaded type ae polytype polytype oe type constructor tycon class class context context distinction leads number trivial looking rules translate syntactic types semantic types 
trivial perform useful functions ffl checking scope type variables constructors class names 
ffl checking type constructors correct arity expanding type synonyms 
ffl syntactic names constructors classes appear domain environments see section environment combiners check type constructor class declared 
goals achieved merging syntactic semantic forms giving simpler validation rules 
exception expansion type synonyms conveniently done translation 
gives syntax semantic types 
unit type treated case tuple type zero components 
tuple type 
syntax monotypes includes cases functions lists tuples 
regarded special cases second production particular type constructors productions oe unsurprising 
third oe predicated type context ordered list predicates form enclosed angle brackets hi 
notice syntax permits peculiar types ff ff fi fi ff fi ff types arise class declarations 
example declaration class foo op bar 


monotypes ff bool oe ff ff oe oe predication contexts syntax semantic types attributes just type op 
operational reading op function dictionary foo extracts method op 
method function takes dictionary bar order 
function fv applies overloaded types monotypes returns free type variables type 
extends natural way sets types 
environments environment finite function domain name space 
package environments tuples call resulting tuple environment 
number different sorts environments 
number generic operations performed environments described 
discuss individual environment separately 
generic operations environments environments may written explicitly curly brackets gve fvar oe var oe empty environment denoted fg 
domain range environment may extracted functions dom ran respectively 
dom gve fvar var ran gve foe oe environment applied member domain return corresponding element range 
example gve var oe notation te extracts type environment te total environment similarly components tupled environment 
environment notation type total environment tce tve ce value environment cve gve lve constructor value environment cve con 
oe global value environment gve var 
oe local value environment lve var 
type constructor environment tce tycon 
ff ff type variable environment tve tyvar 
ff class environment ce class 
ff methods gve instance environment gie lie global instance environment gie 
ff ff local instance environment lie dvar 
environments local value environment global value environment monotype polytype 
environments ff gve gve defined ff gve var ff gve var gve var gve var operations phi phi combine environments 
checks domains arguments distinct shadows left argument right 
example gve phi gve var gve var var dom gve var dom gve gve var var dom gve var dom gve gve phi gve var gve var var dom gve var dom gve gve var var dom gve similarly environments 
brevity write phi tuple sums components write phi ce combine ce appropriate component similarly components tupled environments 
implicit side conditions implicit side conditions associated environments follows ffl phi appears rule side condition dom dom implied 
ffl similarly var appears rule side condition var dom implied 
value environments value environments quite conventional mapping variable constructor names types 
distinguish local value range monotypes global value environment range 
type constructor environment type constructor environment tce binds type constructors introduced type introduced data 
maps name type constructor function maps types types 
arguments supplied function arguments type constructor 
case type synonyms introduced type application implements expansion synonym 
case type constructor tycon introduced data function form ff ff semantic type constructor corresponding tycon 
application achieved check constructor correct arity 
type variable environment type variable environment just maps type variable syntactic names semantic counterparts 
main local inference rules validate type signatures written explicitly haskell checks scope type variables mentioned 
part total environment binds type variables mentioned headers class instance declarations 
class environment class environment gives information semantic name signature class 
members domain take form ff methods gve semantic name class ff type variable respect overloading takes place 
specifies superclasses order appear dictionary class 
gve gives type signature class methods sequence variable names dom gve establishes order methods appear dictionary class 
global instance environment global instance environment associates dictionary function name type form ff ff fi fi says polymorphic function take dictionaries corresponding map dictionary giving methods fi fi instance class notice instance declarations syntactically restricted declaring instance class type form fi fi types global instance environment form 
important type constructor instance class way 
ensured adding extra implicit side condition operation gie phi gie types range gie gie respectively class type constructor addition phi ensure dictionary function names disjoint usual introduced type checker just way saying introduce distinct name time 
practical implementation global instance environment indexed pairs dictionary function names 
important invariant global instance types free variables ff ff binds type variables fi fi free 
local instance environment local instance environment maps dictionary variable dvar expression form asserts dvar dictionary corresponding instance class contrast global instance environment type may free type variables 
function zip constructs local instance environment sequence dictionary names dicts context fd zip dvar syntax section give syntax source translated language 
source syntax syntax source language figures 
syntax expresses parse tree program 
punctuation symbols concrete syntax keywords parentheses guide parse redundant omitted 
particular omit syntax parentheses grouping mention operator fixity precedence 
preserve legibility syntax retain remaining punctuation 
implementation 
syntax differs concrete syntax haskell number important respects program typedecl classdecl instdecl binds typedecl typedecl typedecl type declarations data context 
tycon tyvar tyvar condecl type tycon tyvar tyvar monotype condecl condecl condecl constructor bindings con monotype monotype classdecl classdecl classdecl class declarations class context 
class tyvar sigs instdecl instdecl instdecl instance declarations instance context 
class monotype binds binds bind bind sigs binds binds nested declarations sigs fg type signatures sigs sigs var polytype bind monobinds set bindings rec monobinds recursive set bindings monobinds monobinds monobinds set bindings pat grhs pattern binding var match function binding fg empty set bindings syntax haskell declarations bindings match match match case alternatives mrule mrule grhs pat mrule grhs grhs grhs guarded right hand side guard exp exp guard exp pat var variable wildcard con pat pat compound pattern pat lazy pattern var pat pattern pat pat list pattern pat pat tuple pattern unit pattern exp var variable con constructor integer float char string mrule lambda abstraction exp exp application case exp match case expression exp exp exp conditional exp quals list comprehension exp 
enumerations exp exp 
exp exp exp exp exp binds exp local definitions exp exp lists exp exp tuples quals quals quals qualifiers pat exp generator guard filter syntax haskell patterns expressions polytype context 
monotype monotype monotype tyvar type variable monotype 
monotype function type monotype list type monotype monotype tuple type incl unit tycon monotype monotype constructed type context 
class tyvar class tyvar syntax haskell types pat var translated patterns var dictionary variables productions exp ff ff 
exp type abstraction exp type application productions extra syntax translated programs grouping declarations 
various sorts declarations type class instance value assumed sorted groups shown program production 
dependency analysis value declarations 
known order obtain general possible types group local bindings hindley milner system necessary perform dependency analysis explicit recursion occurs 
assume dependency analysis taken place program type checker syntax allows result dependency analysis expressed 
particular groups value bindings binds topologically sorted nested groups combined 
group non recursive group monobinds recursive group rec monobinds declarations monobinds combined 
production solely allow generation general types introduce nested scope shadowing names occurs result 
keyword production expressions reminder bindings structure 
type signatures 
assumed split signature gives type variable 

syntax polymorphic types polytype contain explicit quantification type implicitly quantified free variables 
generality 
syntax constructs permissive concrete syntax 
example syntax lambda abstractions allows multiple guarded bodies 
restriction single guarded body concrete syntax done stylistic grounds 
syntax modular general form give gives rise directly greater modularity type inference rules 
similarly alternatives case expression pattern concrete syntax syntax allows 
similarly empty production monobinds required instance declarations clause 
unit expression written haskell treated zero tuple 
list comprehensions 
syntax permit list comprehension empty qualifier list report 
issue style deep issue 
class signatures 
default declarations incorporated productions 
notice punctuation generated syntax conform precisely concrete syntax nonterminal grhs lambda abstractions function bindings 
syntax matter slightest 
translated syntax syntax translated program similar source program 
write nonterminals translated programs bold font exp translated form exp gives extra productions translated program existing productions retained 
program translated binds value bindings remaining 
forms declaration import class instance type data type signatures eliminated 
extra productions handle second order lambda constructs 
particular variable pattern type attached extra forms expression type abstraction type application 
translation dictionaries introduced explicitly 
dvar variables bound dictionaries 
dictionary variables distinct name space ordinary variables name clashes dictionary variables ordinary ones 
type dictionary needed annotate dictionary variable pattern written notation translated programs constructing translations number design choices especially overloading concerned 
example dictionaries represented tuples trees 
avoid making premature convenient extra notation writing translations 
interpret extra notation shorthand particular representation extra productions syntax translations 
section summarise extra notation design choices imply 
applying constructing overloaded values overloaded value applied appropriate dictionaries 
dually construct overloaded value form lambda abstraction 
ffl notation exp dicts dicts sequence dictionary names stands application overloaded expression exp dictionaries dicts notation abstracts away application curried 
ffl notation dicts 
exp stands lambda abstraction dictionaries dicts type corresponding element 
building dictionaries apart recall dictionary particular instance class value contains ffl methods operation instance ffl dictionaries superclasses need constructs build dictionary take apart 
ffl notation dicts sequence dictionary names methods sequence method names stands dictionary containing methods superclass dictionaries 
typically represented flat tuple component method superclass dictionary 
method superclasses vice versa typically represented method 
notation allows away details 
ffl notation methods 
exp stands dictionary abstraction 
gve give types variable bound abstraction 
construct selector functions take dictionary apart case exp just single variable dictionary variable 
abstraction bindings syntax shorthand notation section give notation type dictionary abstractions expressions 
fact turns need sets bindings single expression expression form directly 
notation ff ff 
dicts 
binds monobinds stands abstraction type variables ff ff dictionaries dicts bindings binds monobinds 
resulting set bindings bind variables bound monobinds bindings binds scope monobinds 
complicated construct discussed detail section 
programs warning looked section pending completion imports stuff 
add stuff check cycles type synonyms class 
inference rule programs 
premises premise validates program type declarations derives type environment subscript identifies environment arising type checking type declarations 
subscripts class declarations instance declarations value declarations 
premise deals class declarations producing translated bindings environments 
program program binds tce phi tce cec typedecl typedecl phi phi classdecl classdecl cec fg cec fg phi phi gie phi inst instdecl monobinds gie phi phi gie bind binds fg program program typedecl classdecl instdecl binds rec monobinds phi gie phi rule programs premise just combines environments derived far total environment premise deals instance declarations 
notice mutually recursive value declarations specified making gie part environment judgement 
see instance declarations mutually recursive consider program fragment class 
int class 
int instance int instance int similarly gie environment obtained typechecking instance declarations clearly scope typechecking value declarations environment obtained value declarations scope typechecking instance declarations methods instance declarations may refer values declared value declaration 
premise deals value declarations 
mutual recursion value declarations handled rules binds empty lie returned 
tce tve monotype monotype tve tyvar ff type taut tce tve monotype tyvar ff tce tve monotype monotype tce tve monotype monotype type fun tce tve monotype monotype 
monotype tce tve monotype monotype type list tce tve monotype monotype tce tve monotype monotype type tuple tce tve monotype monotype monotype tce tycon ff ff tce tve monotype monotype type con tce tve monotype tycon monotype monotype ff ff rules monotype type declarations rules types type declarations figures 
rules monotype context polytype look bit trivial formally specify ffl checking uses type constructors refer type constructors scope specified te ffl ditto type variables specified tve type signatures significant type variables implicitly universally quantified significant data type declarations quantification explicit 
ffl ditto class names 
tve ce context context ce class tve tyvar ff context tce tve ce context class tyvar class tyvar ff ff tce tve ce polytype polytype oe tyvar fv monotype dom tve tve ff tyvar ff tve ce context context tce tve phi tve monotype monotype polytype tce tve ce polytype context 
monotype ff ff tyvar fv monotype dom tve tve ff tyvar ff tce tve phi tve monotype monotype polytype tce tve ce polytype monotype ff ff hi rules context polytype ffl expanding type synonyms 
expansion contain info original synonym decided typedecl rule type 
ffl checking type variables mentioned context part polytype subset mentioned monotype part see rule polytype 
ffl checking context polytype predicates type variables bound enclosing scope defined tve left turnstile 
enclosing tve contains bindings type variables bound class instance declaration 
notice example explicit environment tve polytype judgement 
ensures quantification covers free variables context monotype 
course contain extra unused variables matter 
tce ce typedecl typedecl te cve tve ff tyvar ff tce tve ff ff condecl condecl cve tve ce context context data decl tce ce typedecl data context 
tycon tyvar tyvar condecl ff ff 
ff ff gve tce ff tyvar ff monotype monotype syn decl tce ce typedecl type tycon tyvar tyvar monotype ff ff fg tce ce typedecl typedecl tce cve tce ce typedecl typedecl tce cve type decls tce ce typedecl typedecl typedecl tce phi tce cve phi cve tce tve condecl condecl cve tce tve monotype monotype ff ff fv fff ff mg constr tce tve condecl con monotype monotype ff ff tce tve condecl condecl cve tce tve condecl condecl cve tce tve condecl condecl condecl cve phi cve rules type declarations contexts data declarations context may appear just keyword data data declaration 
effect constructor overloaded function see constr rule 
example consider data eq 
set emptyset singleton set set types constructors follows emptyset ff set ff singleton ff eq ff ff set ff ff eq ff set ff set ff set ff notice emptyset overloaded type variables free arguments constructor predicated 
notation fff ff mg denotes subset predicates type variables fff ff 
reason haskell designed avoid needless ambiguity errors 
note notation note notation type tuple rule premise bar short premises ranging constraints earlier syntax case 
similarly type con rule varies syntax tells constraint imply class declarations rules class declarations shown 
rule classes straightforward observe bindings inferred classdecl scope classdecl vice versa 
ensures superclass contain cycles 
class operation names clash scope names phi combine environments 
rule class interesting 
premise validates context returning semantic form checking type variable tyvar mentioned 
premise validates class signature 
produces gve value environment containing bindings class operations 
notice type signatures class declaration 
allows declarations classdecl classdecl binds gve ce gie classdecl classdecl binds gve ce gie phi gve ce gie classdecl classdecl binds gve ce gie classes classdecl classdecl classdecl binds binds gve phi gve ce phi ce gie phi gie ffg ce context context ce tce ffg sigs sigs gve methods dom gve lie zip dicts class classdecl class context 
class tyvar sigs var ff 
methods 
var var dom lie dom gve ff ffi gve fclass ff methods gve ff ffi lie ce tce tve sigs sigs gve ce tce tve sigs sigs gve ce tce tve sigs sigs gve sigs ce tce tve sigs sigs sigs gve phi gve tce tve ce polytype polytype oe sig tce tve ce sigs var polytype fvar oeg sig empty ce tce tve sigs fg fg rules class declarations class 


type variable polymorphic overloaded 
premise defines methods sequence names class operations obtained domain gve significance methods records order methods appear dictionary 
order arbitrary dictionaries created instance declarations agree selectors defined class declaration 
pragmatic note system supporting separate compilation need canonical ordering methods cd premise backwards zip input context premise invents new dictionary names dicts zips context produce local instance environment lie 
translation class declaration set bindings bind class operations selector functions extract corresponding method dictionary class 
selectors generated extract dictionaries superclasses 
existence selectors recorded environments returned class operation selectors appear value environment gve superclass selectors appear instance environment gie instance declarations gives rules instance declarations 
insts rule straightforward 
contrast classes bindings inferred instdecl scope instdecl top level rule program entire collection instance declarations mutually recursive 
inst rule complex single rule entire system 
premises listed premise looks class class class environment get semantic name type ff methods 
premise defines type variable environment bindings exactly names free type variables monotype instance declaration 
premises validate monotype 
premise checks form monotype correct type constructor applied simple type variables 
premise validates context checking mentions type variables free monotype sense 
premise builds local instance environment lie context generating suitable new dictionary variables dicts instdecl instdecl monobinds gie instdecl instdecl monobinds gie instdecl instdecl monobinds gie insts instdecl instdecl instdecl monobinds monobinds gie phi gie ce class ff methods tve ff tyvar ff tce tve monotype monotype ff ff ff ff distinct tve ce context context lie zip dicts gie lie dicts zip ff binds super phi tve binds binds binds methods lie ff inst instdecl instance context 
class monotype monobinds ff ff 
dicts 
binds super binds methods ff ff instance declarations premise confirms superclass dictionaries described instance constructed dictionaries provided instance declaration lie witnesses fact producing set bindings give terms 
dicts judgement discussed section 
premise type checks value bindings body instance declaration verifies match instance obtained class environment premise 
gives translation function takes dictionaries corresponding context delivers dictionary class complete superclass dictionaries methods 
note type abstraction binding dictionary function polymorphic 
inst rule notice local instance environment lie means instance declarations instance eq 
eq foo 
method calls generate inefficient translation 
call definition result second call dictionary function eq foo 
possible add dvar lie produce translation instance declaration ff ff 
dicts 
rec dvar binds super binds methods dvar declaration dictionary recursive witnessing addition extra assertion class declaration 
modification somewhat complicates rule exchange probable increase efficiency 
value declarations syntax type rules value declarations structured layers ffl monobinds group declarations typechecked monobinds give monomorphic environment 
fact monomorphic ensures right hand sides mutually recursive definitions variables defined monomorphic non overloaded type 
judgement monobinds monobinds monobinds lie lve read environment declarations monobinds translate declarations monobinds types variables bound declarations type environment lve class constraints local instance environment lie 
pattern bindings may bind zero variables may fewer typings lve declarations monobinds 
pattern bindings bind useful inconvenient exclude harm 
case fv lie fv lve 
sets bindings monobinds monobinds monobinds lie lve monobinds monobinds monobinds lie lve monobinds monobinds monobinds lie lve union monobinds monobinds monobinds monobinds monobinds lie phi lie lve phi lve cve pat pat pat lve grhs grhs grhs lie monobinds pat grhs pat grhs lie lve match match match lie monobinds var match var match lie fvar monobinds fg fg fg fg rules monobinds ffl bind deals recursion optionally adding rec monobinds typing rules 
recursion dealt environment overloaded bind pred generalised bind gen give polymorphic environment gve bind pred applies sets declarations function bindings simple variable bound directly lambda abstraction 
constraint required implement haskell unsatisfactory monomorphic pattern binding rule 
bind gen able generalise type variables constrained instance environment 
important operational issues discussed sections 
ffl binds nested set bind groups optionally group type signatures attached connected 
typing rules figures 
construct get general type scoping purposes 
phi binds rule phi 
binds binds binds binds lie gve bind bind bind lie gve binds triv binds bind bind lie gve binds binds binds lie gve phi gve binds binds binds lie gve binds binds binds binds binds binds lie phi lie gve phi gve bind bind bind lie gve ce tce tve sigs sigs gve binds sig bind bind sigs bind lie gve rules binds phi second premise declarations bind shadow outer bindings binds sig rule cop 
simply says type environment bind specified sigs perfectly correct implementation complicated rule implies 
type inference algorithm infer general types bind specified sigs infer general types separate process specialise inferred types specified ones modifying translation appropriately 
rule order rules bind triv bind rec bind pred bind gen applied appropriate order ffl apply bind triv bind rec depending declarations recursive 
ffl bind pred discharge possible assumptions local instance environment 
bind bind bind bind lie gve bind bind bind lie gve ff ff ff ff tve ff ff lie bind gen bind bind ff ff 
bind lie ff ff gve bind bind bind lie lve gie lie phi lie bind dicts lie monobinds lie bind zip dicts bind contains function bindings bind pred bind bind dicts 
monobinds bind lie lve phi lve monobinds monobinds monobinds lie lve bind rec bind rec monobinds rec monobinds lie lve monobinds monobinds monobinds lie lve bind triv bind monobinds monobinds lie lve rules bind ffl bind gen bind free type variables 
reason ordering maintain form types 
rule order indicated giving numbers bind bind translating type dictionary abstractions translations bind gen bind pred involve new constructs translated syntax type abstraction 
constructs readily translated existing ones way see section 
new construct avoid making premature appropriate translation 
type signatures gve sigs sigs binds gve sigs empty gve sigs fg fg fg gve sigs sigs binds gve gve sigs sigs binds gve sigs gve sigs sigs sigs binds binds gve phi gve tce tve ce polytype polytype oe gve var oe sig gve sigs var polytype fg fvar oeg tce tve ce polytype polytype fi fi sig sig gve var ff ff fl fl phi gve sig fl fi fl fi ff ff lie zip dicts ff ff lie sig zip dicts sig sig fl fi fl fi gie lie sig dicts lie binds sig gve sigs var polytype var fi fi 
dicts sig lie sig 
binds var dicts fvar fi fi sig sig type signatures explore possible translations new constructs 
discuss abstraction type abstraction analogous little simpler 
discussion example generalisation straightforward tedious 
consider mutually recursive definitions rec abs recall abs operation class num operation class eq 
recall eq superclass num class declaration num looks class eq 
num 
fact eq superclass num means num dictionary contains eq dictionary 
recorded global instance environment entry ff num ff eq ff says name arbitrary maps num dictionary eq dictionary 
returning example recursive binding typechecked monobinds translated binding rec de abs dn inferred local type environment ff ff ff bool ff ffg local instance environment assumption fdn num ff de eq ffg dn name num dictionary passed abs de name eq dictionary passed dictionary names arbitrary 
applying bind pred bind gen produces binding 
dn 
de dn rec de bool abs dn type environment overloaded types ff ff num ff ff ff ff num ff bool ff ffg 
typewriter font include greek letters ff 
notice type signatures bound variables 
notice eq dictionary de obtained applying global function num dictionary dn 
binding abstraction mean 
binds gives values function type dictionary dn arguments 
bindings mutually recursive dictionary bindings case keep example short degenerate fail terminate 
binding de take account easy just add dn extra parameters definition 
case mutual recursion possible recursive calls pass extra parameter 
furthermore question done dictionary bindings 
alternative add extra parameters recursive calls replicate dictionary bindings right hand side omit type signatures arguments brevity rec dn de dn dn de dn de dn abs dn dn number problems translation 
firstly may dictionaries need repeatedly passed just 
depending implementation may impose significant overhead 
secondly dictionary bindings duplicated increasing code size 
case binding de dropped right hand side may 
thirdly importantly expression dn recomputed recursion 
loses property known full laziness unfortunately standard full laziness transformation recover 
transformation express type rules involves second pass translated expression replace uses dn similarly second possible translation dn de dn rec de abs dn dn de dn rec de abs dn translation recovers full laziness dn computed cost duplicating bindings dictionaries 
usually case mutually recursive group definitions subsequent code 
case example called subsequently 
mean top definition dropped entirely eliminates duplication 
single property guaranteed 
third possible translation duplicate code follows tup dn de dn rec de abs dn dn case tup dn 
dn case tup dn 
appears translation somewhat efficient previous tupling 
common case say subsequently definition dropped case definition tuple safely substituted occurrence body little simplification second translation emerges 
reason third alternative best 
choosing type variables generalise rules correct hope regardless parts lie selected lie bind bind pred type variables chosen generalisation 
type inferencer suitable set chosen section discusses issues 
generalisation firstly bind gen choose type variables free part bind gen rule 
call type variables constrained type variables 
point bind gen choosing type variables free lve generalised 
conclude bind gen select exactly type variables free types lve constrained enclosing call target type variables 
innocuous consider bindings tup 

tup type inference binding derive environment ff fi ff ff fi fig type inference second binding prior bind gen infer environment ff ff ff fi fig bind gen generalise ff fi giving environment ff ff fi ff ff ff fi fi fig curious 
take type arguments types 
real problem especially type abstractions applications vanish real implementations worth noting 
predication situation bind pred interesting 
firstly point bind pred selecting predicates lie predicate constrained type variables 
remember predicate lie predicate type variable example eq ff fi 
predicates lie predicate constrained type variables eliminated consideration 
predicates affecting constrained unconstrained type variables simplified dicts remain property 
remaining predicates affect unconstrained type variables 
example separation process declaration typechecked environment gives type ff lie lve pair returned fd ord ffg fg fi fi fig translation body mention dictionary ff free type bind pred leave dictionary constraint lie returns resolution bind pred deals declaration ambiguity situation may arise predicates affect type variables constrained target variables 
predicates ambiguous 
really say 
type signatures type signatures attached possibly recursive groups declarations individual declarations types checked overloading generalisation taken place done group 
type signatures validated sigs judgement uses gve declaration group check type signatures attached declaration group mention variables declared group exactly correct type 
judgement need return result 
perfectly legitimate help type inference engine 
requires inference engine derives fully general type original binding inferred type precisely matches type signature 
implausible 
happen practice general type inferred signature specialise 
notice translation may required case 
example suppose infer type ff num ff ff ff 
type signature int 
int need new binding form num dictionary ints 
note non recursive binding 
defined distinct specialised form right hand side 
re binds version specialised int 
reason sigs judgement form takes returns set extra bindings modified gve rule sig deals coercing general type specific 
considerably original effect incorporates spec rel 
works premise validates polytype type signature 
premise checks variable typed binding current group finds inferred type 
premise grabs fresh set type variables 
premise checks general instance type instance inferred type 
types instantiate inferred type type 
premise generates lie inferred context inventing new dictionary names 
premise context sig premise generates new bindings produce dictionaries needed instance available sig expressions rules typechecking expressions figures 
expression judgement form exp exp exp lie oe read environment expression exp translated exp type oe class constraints local instance environment lie 
case fv lie fv oe points notice expressions exp exp exp lie oe gve var oe taut var dom gve exp var var fg oe lve var taut lvar var dom lve exp var var fg cve con oe taut con exp con con fg oe taut integer exp integer frominteger integer num taut float exp float float fractional taut char exp char char fg char taut string exp string string fg char basic rules expressions exp var exp lie ff ff ae spec exp var exp lie ae ff ff exp exp exp lie lie zip dicts rel exp exp exp dicts lie phi lie non syntactic rules expressions exp exp exp fg oe tce tve ce polytype polytype oe exp exp polytype exp fg oe fg mrule mrule mrule lie lambda exp mrule mrule lie exp exp exp lie exp exp exp lie comb exp exp exp exp exp lie phi lie binds binds binds lie gve phi gve exp exp exp lie exp binds exp binds exp lie phi lie exp exp exp lie match match match lie case exp case exp match case exp match lie phi lie exp exp exp lie bool exp exp exp lie exp exp exp lie exp exp exp exp exp exp exp lie phi lie phi lie qual quals quals lie lve phi lve exp exp exp lie exp exp quals exp quals lie phi lie rules compound expressions exp exp exp lie list exp exp exp exp exp lie phi phi lie exp exp exp lie tuple exp exp exp exp exp lie phi phi lie data structures expressions taut lvar taut apply binding variable local global value environments typing fails variable scope 
taut integer taut float introduce overloaded numeric fractional constants respectively 
reason interact instance environment 
taut string deals literal strings 
notice empty string type char 
means empty string implemented empty list expression fail type checker constrast lml compiler example passes 
gen spec manipulate group type variables working type variable time conventional 
deep reason analogy pred rel 
rel 
rel short release 

need give explanation 
handles type signatures expressions 
sig rule bindings rule unrealistic requires inference engine derive type expression exactly matches signature 
useful rule 
list comprehensions case expressions 
notice bindings list comprehensions case expressions monomorphic 
easy see list comprehensions polymorphic adding gen rule qual easy see case expressions 
quals 
note phi rule expressing fact bindings list comprehension shadow 
example xs xs ys xs xs allowed 
pattern matching exp exp exp lie enum exp exp 
exp lie phi enum exp exp exp lie exp exp exp lie enum exp exp exp 
exp exp lie phi lie phi enum exp exp exp lie exp exp exp lie enum exp exp exp exp exp lie phi lie phi enum exp exp exp lie exp exp exp lie exp exp exp lie enum exp exp exp exp exp exp exp lie phi lie phi lie phi enum rules enumerations expressions qual quals quals lie lve qual quals quals lie lve phi lve qual quals quals lie lve quals qual quals quals quals quals lie phi lie lve phi lve exp exp exp lie bool filter qual exp exp lie fg cve pat pat pat lve exp exp exp lie generator qual pat exp pat exp lie lve rules quals exp exp exp lie ff ff tce tve ce polytype polytype fi fi sig sig fl fl lie sig fl fi fl fi ff ff lie sig zip dicts sig sig fl fi fl fi gie lie sig dicts lie binds exp exp polytype binds exp lie sig sig fl fi fl fi realistic expression signature rule patterns cve pat pat pat lve taut pat cve pat var var fvar cve con oe oe cve pat pat pat lve constr pat cve pat con pat pat con pat pat lve phi phi lve cve pat pat pat lve pat cve pat var pat var pat lve phi fvar cve pat pat pat lve lazy pat cve pat pat pat lve wild pat cve pat fg cve pat pat pat lve list pat cve pat pat pat pat pat lve phi phi lve cve pat pat pat lve tuple pat cve pat pat pat pat pat lve phi phi lve rules patterns matches match match match lie match match match lie match match match lie matches match match match match match lie phi lie fg mrule mrule mrule lie match match mrule mrule lie lve mrule mrule mrule lie phi lve grhs grhs grhs lie mrule grhs lve mrule grhs grhs lie cve pat pat pat lve lve phi lve mrule mrule mrule lie mrule abs lve mrule pat mrule pat mrule lie guarded right hand sides grhs grhs grhs lie grhs grhs grhs lie grhs grhs grhs lie guard grhs grhs grhs grhs grhs lie phi lie exp guard guard lie bool exp exp exp lie guard grhs guard exp guard exp lie phi lie exp exp exp lie guard default grhs exp exp lie rules match mrule grhs patterns type checked judgement form pat typing rules 
judgement form written cve pat pat pat lve read constructor value environment cve pattern pat translated pat type bindings variables lve judgement guarantees lve contains bindings variables pat pattern linear contains repeated variables 
translated pattern pat gives explicit type variable necessary second order lambda calculus 
mrule judgement type checks sequences patterns followed sequence guarded expressions 
function bindings lambda abstractions 
grhs judgement type checks sequence guarded expressions 
typing rules mrule judgement form 
points worth noting linearity ensured phi pat list pat tuple pat 
mrule abs mrule grhs 
mrule judgement carries monomorphic value environment lve contains bindings variables bound patterns current sequence patterns 
environment initialised empty match rule augmented mrule abs rule non shadowing phi operation checking linearity patterns 
mrule grhs typechecks guarded right hand side type environment lve formed combining environment derived patterns main dictionary manipulation dicts judgement form tells express dictionaries terms 
takes form gie lie dicts lie binds lie local instance environment containing assumptions form dvar judgement shows translate lie collection bindings monobinds give values dictionaries mentioned lie terms mentioned gie lie main places dicts ffl inst rule shows construct dictionaries superclasses terms provided context instance declaration 
dictionary equivalence gie lie dicts lie binds dict triv gie lie dicts fg fg gie lie dicts lie binds gie lie dicts lie binds dicts gie lie dicts lie phi lie binds binds gie ff ff lie zip dicts ff ff gie lie dicts lie binds dict global gie lie dicts ff ff binds lie dvar dict dup gie lie dicts dvar dictionary manipulation ffl judgements return local instance environment lie part result tracks names dictionaries translation construct types 
lies merged expression tree producing merged lie may highly redundant sense dictionaries produced dicts judgement allows redundancy eliminated 
ffl type signatures declarations 
ffl type signatures expressions 
ways dicts give binding dictionary dvar type ffl lie contains dictionary identical type trivial binding suffice ffl form instance declaration instance case gie contain matching assumption dicts global rule translate dvar binding simpler collection lie assumptions 
ffl just type variable ff may assumption lie form dvar ff superclass case possible express dvar terms dvar dicts global rule copes implementation terms case handle involves conditionally superclass 
implementation notes generalising sufficient think look lve gve gve may contain free type variables free free lve bound 
harper milner tofte may definition standard ml version ecs lfcs lfcs dept computer science university edinburgh 
hudak pl wadler arvind boutel fairbairn fasel hammond hughes johnsson kieburtz rs nikhil sl peyton jones reeve wise young april report functional programming language haskell dept computer science glasgow university 
wadler blott jan ad hoc polymorphism ad hoc proc th acm symposium principles programming languages austin texas acm 
index pat bind judgement form bind judgement form bind judgement form bind gen bind pred bind rec bind triv binds judgement form binds sig binds binds triv case class classdecl judgement form classes comb condecl judgement form constr constr pat context context judgement form data decl dict dup dict global dict triv dicts dicts judgement form enum enum enum enum exp judgement form filter generator grhs judgement form guard guard default guard inst inst judgement form instdecl judgement form insts judgement form bind bind bind binds classdecl condecl context dicts exp grhs inst instdecl match monobinds monotype mrule nonterminal pat polytype program qual sigs typedecl lambda lazy pat list list pat match match judgement form matches monobinds judgement form monotype judgement form mrule judgement form mrule abs mrule grhs nonterminal judgement form pat judgement form polytype judgement form polytype polytype program program judgement form qual judgement form quals rel sig sig empty sigs sigs judgement form sigs empty spec syn decl taut char taut con taut float taut taut integer taut lvar taut pat taut string tuple tuple pat type con type decls type fun type list type taut type tuple typedecl judgement form union wild pat 
