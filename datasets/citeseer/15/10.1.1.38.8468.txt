restricted path consistency max restricted path consistency christian bessi ere lirmm umr cnrs rue ada montpellier cedex france email lirmm fr 
need show importance filtering techniques solve constraint satisfaction problems find values problem variables subject constraints specify combinations values consistent 
preprocessing step remove local inconsistencies search efficiently prune search tree 
comparison practicable filtering techniques concludes restricted path consistency rpc promising local consistency requires little additional cpu time compared arc consistency removing path inverse inconsistent values 
rpc algorithm comparison called rpc non optimal worst case time complexity bad average time space complexities 
propose rpc new rpc algorithm worst case time complexity requiring space rpc practice 
second aim extend rpc new local consistencies rpc max rpc compare pruning efficiency practicable local consistencies 
furthermore propose study max rpc algorithm ac comparison 
finding solution constraint network cn involves looking set value assignments variable constraints simultaneously satisfied 
exponential search algorithms proposed solve np hard task 
avoid combinatorial explosion search tree pruned possible 
filtering techniques remove local inconsistencies search 
arc path consistencies studied local consistencies 
seldom real applications maintain arc consistency mac limited version arc consistency forward checking search 
arc consistency ac removes values belong solution strongly reduce search space 
ac enforced cheaply 
hand path consistency pc removes inconsistent pairs values huge complexity 
constraints represented extension structure network changed 
pc important drawbacks 
large hard cns mac outperforms forward checking 
maintaining arc consistency easy small cns useless widely speeds search hard cns 
harder cn useful filtering techniques 
necessary take careful look local consistencies stronger ac fall traps pc 
powerful local consistencies proposed 
comparison concludes restricted path consistency rpc promising local consistency 
requires little additional cpu time compared ac removing path inverse inconsistent values pic 
furthermore delete pair values constraint added modified network 
extend idea rpc new local consistencies rpc max rpc order remove inconsistent values 
greater powerful rpc max rpc removes inconsistent values pic rpc enforcing high level rpc expensive achieving max rpc 
order compare rpc max rpc practicable local consistencies need efficient algorithms achieve 
experimental evaluation shows non optimal algorithm rpc bad behaviour ac 
ac heavy ed data structure average time complexity close worst case 
addition drawbacks rpc worst case time complexity 
propose new rpc algorithm called rpc worst case time complexity requires space rpc practice 
propose study max rpc algorithm ac 
recalls section rpc max rpc local consistencies study pruning efficiency 
recalls rpc section 
propose new rpc algorithm called rpc section max rpc algorithm section 
experimental evaluation section remarks conclude 
definitions notations network binary constraints set variables value respective finite domain elements set binary constraints 
size largest domain 
binary constraint ij subset cartesian product theta denotes compatible pairs values note ij true specify ij say support ij cn associate constraint graph nodes represent variables arcs connect pairs variables constrained explicitly 
neighborhood set variables linked constraint graph 
domain fd sub domain fd instantiation set variables indexed set values fi instantiation satisfies constraint ij fi jg ij true 
instantiation consistent satisfies constraints 
pair values path consistent pair values extended consistent instantiation fi kg 
path consistent support path consistent 
solution consistent instantiation value consistent solution cn consistent solution 
denote fag cn obtained restricting fag restricted path consistency extensions restricted path consistency allows detect inconsistent values ac avoiding drawbacks pc 
rpc value unique support constraint ij path inconsistency leads inconsistency 
addition arc inconsistent value deletions rpc algorithm checks path consistency pairs values unique support tests directly lead deletion path inconsistent 
rpc require explicitly maintain list allowed pairs values remove pairs values constraints avoids prohibitive cost path consistency checks pairs values 
rpc checks path consistency support unique support value 
extended filtering technique checking path consistency supports unique time supports 
principle restricted path consistency rpc ensures values supports constraint path consistent support constraint 
rpc rpc ac corresponds rpc 
greater smaller probability value having supports path consistent support say smaller smaller cpu time number value deletions ratio rpc rely constraint network 
rpc detect inconsistency cn restricted path inconsistent value 
real advantage rpc adaptative way reusing filtering effort 
rpc holds cn want enforce rpc consider values exactly supports constraint propagate possible deletion 
obviously enforcing higher levels rpc soon values path consistent support constraint 
case rpc holds size largest domain 
deletion restricted path inconsistent values value supports constraint rpc holds cn said max restricted path consistent values path consistent support constraint number supports 
max restricted path consistent cn restricted path consistent enforcing max rpc expensive achieving rpc 
opposed rpc enforcing max rpc require determine set values supports binary cn consistent iff consistent instantiation variables extended consistent instantiation including additional variables 
domain arc consistent iff ij exists ij 
cn arc consistent consistent iff arc consistent 
pair variables path consistent iff ij exists dk cik jk 
cn path consistent consistent iff path consistent 
binary cn strongly path consistent iff node consistent arc consistent path consistent 
binary cn restricted path consistent iff non empty arc consistent domain 
supports ij linked dk cik jk 
binary cn restricted path consistent iff path consistent 
binary cn max restricted path consistent iff non empty arc consistent domain linked ij linked dk cik jk 
binary cn path inverse consistent iff consistent ij cik jk binary cn neighborhood inverse consistent iff extended consistent instantiation including neighborhood binary cn singleton arc consistent iff fag arc consistent sub domain 
binary cn singleton restricted path consistent iff fag restricted path consistent sub domain 
fig 

practicable local consistencies constraint expensive great 
properties corresponding rpc rpc max rpc usual local consistencies fig 
order compare pruning efficiency local consistencies transitive relation stronger introduced 
local consistency lc stronger local consistency lc cn lc holds lc holds 
example rpc stronger ac rpc algorithm removes arc inconsistent values 
local consistency lc strictly stronger local consistency lc lc stronger lc cn lc holds lc hold 
theorem 
rpc strictly stronger rpc 
proof 
trivial 
theorem 
max rpc strictly stronger rpc 
proof 
trivial 
theorem 
singleton arc consistency stronger max rpc 
proof 
suppose exists cn singleton arc consistent value max restricted path consistent 
variable path consistent support support exists variable ik jk 
values arc inconsistent fag singleton arc consistent 
theorem 
neighborhood inverse consistency stronger max restricted path consistency 
proof 
show neighborhood inverse consistent value path consistent 
nic holds exists consistent instantiation including neighborhood linked path consistent support linked support 
max rpc holds 
theorem 
max restricted path consistency stronger path inverse consistency 
proof 
suppose exists cn max restricted path consistent path inverse consistent 
max rpc value path inverse consistent variables extended consistent instantiation fi kg 
ij ik pic hold jk values max restricted path inconsistent 
max rpc hold 
jk arc consistent max restricted path inconsistent 
jk ij resp 
jk ik support resp 
max restricted path inconsistent 
supports resp 
support resp 

max rpc algorithm delete supports resp 

ij jk ik extended consistent instantiation fi kg path consistent support max rpc hold 
ac rpc pic sac nic strong pc incomparable stronger relation 
max rpc rpc strictly stronger fig 

relations local consistencies fig sums relations practicable filtering techniques 
continuous arrow means local consistency strictly stronger crossed line incomparable stronger relation 
proof relations fig 
especially stronger strictly stronger incomparable cn holds hold 
local consistencies incomparable respect strong relation 
fig gives qualitative properties quantitative information 
interesting determine local consistency detect inconsistent values local consistency 
order determine pruning efficiency rpc experimental evaluation done 
aim evaluation compare cpu time number value deletions ratio 
part comparison 
want show particular local consistency able detect inconsistency random cns fixed number variables values number constraints constraints tightness varying 
cn generator involves parameters number variables common size initial domains proportion constraints network corresponds complete graph proportion forbidden pairs values constraint tightness 
possible pair random cns having variables values domain generated 
local consistency density fig presents value tightness greater value filtering technique detected inconsistency generated cns 
example sac limit density 
smaller tightness random cns singleton arc consistent 
nic exponential worst case time complexity really prohibitive variables large neighborhoods 
experimental evaluation gives results nic 
path consistency widely studied strong path consistency enforcing arc path consistency huge space time complexities prohibitive large cns 
obviously max rpc removes values ac 
main result rpc stronger pic unusual cns 
pic detected inconsistency restricted path consistent cns density 
recalls rpc enforce rpc achieve arc consistency check path consistency pairs values unique support 
rpc determines pairs values considered ac maintains number supports values constraint 
determination require counting 
look arc consistent values support constraint 
constraint network rpc performs possible constraint checks build lists supported values initialize counters 
rpc bad average time complexity costly initialisation phase useless especially networks loose constraints 
ed worst case space complexity lists supported values disadvantage 
lists costly space propagation list list pc rpc average space complexity list pc far worst case space complexity 
tightness rpc pic rpc max rpc sac ac fig 

evaluation inconsistency detection random cns important drawback rpc worst case time complexity 
common support information stored 
value deleted rpc determine set pairs values may longer path consistent deletion 
overestimates set 
deletion value lead useless path consistency checks 
addition rpc store information know values considered previous path consistency checks 
check pair values path consistent rpc considers checked values 
leads worst case time complexity 
rpc bases algorithm rpc enforces ac determines pairs values path consistency proved checking arc value pair zero supports compatible value arc inconsistent value unique support path consistency checked 
addition ac rpc takes advantage bidirectionality constraints reduce number constraint checks performed 
second idea path consistency pair checked variable linked rpc looks smallest common support pair path consistent rpc stores smallest common support currently supporting 
long path consistent respect deleted know common support exists greater ac behavior leads worst case time complexity 
algorithm data structures rpc initial domain considered integer range current domain represented table booleans 
constant time functions procedures handle current domain ffl returns greatest value nil 
ffl returns smallest value greater nil returns lowest value nil 
ffl remove removes value stops algorithm unique value cn inconsistent 
pair values ac ija currently supported 
nil unique support second current support direct access pair ac ija pair ac ija ac ija ac ija returns pair values ac ija nil nil 
ac ija pair values ac ija ac ija returns successor ac ija nil nil 
consider constraint checks required check path consistency pairs values rpc performs constraint check twice 
ensure property uses array ija rpc checked support 
pc kc unique support currently supporting 
smallest value ik jk 
arc value pair rpc determined supports value removed deletion propagated 
nil nil unique support path consistency checked determine restricted path consistent 
nil nil removed support greater prove path consistency arc value pair rpc uses function gamma supports determine zero supports function tries infer supports looking values procedure rpc forall pc ia forall ij ac ija ija nil choose delete choose delete choose delete nil nbs nbs remove nbs nil nil fig 

rpc ac ija list values supported ij supports rpc goes search looking smallest supports array allows reduce number constraint checks performed 
ija determine values checked check ij rpc checked support compatible value ac ija unique support path consistency checked nil nil put 
check path consistency pair procedure uses function find smallest common support linked path consistency proved smallest common support rpc stores currently supporting updating pc kc restricted path consistent 
value deleted checks values currently supported ac restricted path consistent pairs values smallest common support pc jb path consistent 
complexity removes ac ija values longer test line performed times arc value pair 
addition ija bounded ija increases step second loop 
cost loop arc value pair complexity due calls ed 
pairs values path consistency proved unique support 
worst case path consistency checked ed pairs values 
pair values linked function var integer nil nbs nbs ac ija nbs nil delete ac ija nbs nbs nbs nbs ac ija nbs ija ija ija nil ij nbs nbs nbs nbs add ac ac link nbs add nil ac return nbs procedure var var forall ij ac choose delete ac nil remove delete ac nil nbs nbs remove nbs nil nil pc jb choose delete pc jb procedure var nil true common fk cik jk cg forall common nil cs forall common pc cs pc cs pc kc pc kc remove function boolean false dk dk cik jk true return fig 

rpc value checked twice prove path consistency complexity due calls worst case time complexity rpc 
worst case space complexity ac ija lists ed value current supports constraint ij size ed arc value pair put list 
pair values unique support current support domain variable linked worst case space complexity pc jb lists 
ed nil nil elements pair values variable linked element 
size worst case space complexity rpc 
max rpc bases algorithm max rpc determine set weakly supported values having supports 
ensure values path consistent support constraint 
idea ac twice 
prove max restricted path consistency value max rpc looks domain variable linked smallest path consistent support value 
determine value compatible path consistent support max rpc looks smallest common support domain variable linked algorithm data structures max rpc representation domains rpc 
values smallest path consistent support stored list ac jb path consistent pairs values smallest common support stored list pc kc rpc deleted values deletion propagated put 
arc value pair max rpc verified path consistent support determine path consistent support greater looks smallest support path consistent 
support exists put ac jb order store currently supporting 
addition linked put pc kc procedure max gamma rpc forall pc ia ac ia forall ij choose delete choose delete nil remove function boolean common fk cik jk cg true ij true common nil cs false forall common pc cs pc cs ac jb ac jb false return procedure var ac jb choose delete ac jb remove pc jb choose delete pc jb dk ac kc pc jb pc jb remove ac kc remove fig 

max rpc smallest common support long path consistent value deleted value currently supported path consistent support prove max rpc holds 
support exists greater value smallest path consistent support 
check pair value supported path consistent support 
path consistent common support greater look path consistent support greater 
support max restricted path consistent removed 
complexity max rpc look path consistent support value considers values checked greater current support ij worst case path consistency ed pairs values checked 
addition pair values linked value checked determine smallest support worst case time complexity max rpc 
worst case time complexity best path consistency algorithm pc enforcing max rpc really expensive achieving pc 
number constraints far sparse cns 
furthermore max rpc looks path consistent support value constraint 
worst case path consistency ed pairs values checked max rpc check upper bound practice 
value current support constraint ij size ac jb lists ed 
value currently supporting pc kc list linked size pc data structure worst case space complexity max rpc 
experimental evaluation generator section evaluate efficiency rpc rpc max rpc 
generated cns variables values initial domain 
fig shows results relatively sparse dense cns 
tightness instances generated fig presents mean values 
give evaluation space required sum number counters effective maximal size list 
dense cns rpc outperforms rpc cpu time 
sparse cns rpc requires cpu time rpc lists supported values rpc short path consistency pairs values checked rpc outperform rpc 
situation arise tightness density 
path consistency pairs values checked enforce rpc dense cn size lists supported values rpc important rpc outperforms rpc 
observed tightness greater density non optimal worst case time complexity rpc real drawback 
rpc significantly overcomes rpc consider number constraint checks list checks performed space required 
obviously dense cns enforcing max rpc expensive achieving rpc 
max rpc stronger rpc soon detects inconsistent values expensive rpc 
addition seconds required tightness density remain small compared minutes required enforce singleton density cpu time sec 
cpu time sec 
constraint checks list checks percentage values deleted percentage values deleted space requirements constraint checks list checks space requirements density max rpc rpc rpc max rpc rpc rpc max rpc rpc rpc max rpc rpc rpc max rpc rpc rpc max rpc rpc rpc rpc max rpc rpc max rpc fig 

comparison rpc rpc max rpc random cns arc consistency tightness hours required achieve path consistency tightness 
shows average time complexity max rpc far worst case time complexity 
worst case space complexity rpc rpc requires space rpc generated cns rpc expensive space max rpc 
extended restricted path consistency rpc 
new local consistencies rpc avoiding drawbacks path consistency 
new algorithms proposed 
rpc algorithm called rpc worst case time complexity max rpc algorithm ac worst case time complexity having worst case space complexity 
experimental evaluation shows rpc better cpu time performances performs constraint checks rpc 
experiments highlight max rpc average cpu time performances spite worst case time complexity detects inconsistent values rpc 

improving domain filtering restricted path consistency 
proceedings ieee los angeles ca 
bessi ere freuder inference reduce arc consistency computation 
proceedings ijcai montr eal canada 
bessi ere arc consistency arc consistency 
artificial intelligence 
bessi ere restricted path consistency max restricted path consistency 
technical report montpellier france 
bessi ere practicable filtering techniques constraint satisfaction problem 
proceedings ijcai nagoya japan appear 
bessi ere practicable filtering techniques constraint satisfaction problem 
technical report montpellier france 
freuder inverse consistency preprocessing 
proceedings aaai portland 
haralick elliott increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 
mohr henderson arc path consistency revisited 
artificial intelligence 
sabin freuder contradicting conventional wisdom constraint satisfaction 
allan borning editor second workshop principles practice constraint programming seattle wa 
singh path consistency revisited 
proceedings ieee washington 

