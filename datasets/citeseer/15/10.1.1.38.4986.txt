bbn technical report strongly typed genetic programming david montana bolt beranek newman moulton street cambridge ma march genetic programming powerful method automatically generating computer programs process natural selection koza 
limitation known closure variables constants arguments functions values returned functions data type 
correct deficiency introduce variation genetic programming called strongly typed genetic programming stgp 
stgp variables constants arguments returned values data type provision data type value specified 
allows initialization process genetic operators generate syntactically correct parse trees 
key concepts stgp generic functions true strongly typed functions templates classes functions generic data types analogous 
illustrate stgp examples involving vector matrix manipulation list manipulation multi dimensional squares regression problem multi dimensional kalman filter list manipulation function nth list manipulation function mapcar 
genetic programming method automatically generating computer programs perform specified tasks koza 
uses genetic algorithm search space possible computer programs nearly optimal ability perform particular task 
method automatic programming genetic algorithms earlier approach detailed cramer far successful 
section give brief overview genetic algorithms reader referred goldberg 
section discuss genetic programming differs standard genetic algorithm 
genetic algorithms genetic algorithms class algorithms optimization learning principles natural evolution 
shown capable finding nearly global optima large complex spaces mutation crossover mutation crossover string genetic algorithms 
relatively short time 
davis genetic algorithm basic components 
representation scheme provides way code possible solutions problem form readily manipulable genetic operators 
traditional common representation fixed length binary string representation acceptable long appropriate genetic operators defined 

evaluation function fitness function assigns numerical score element search space 
function optimization problems evaluation function function optimized 

initialization procedure provides way randomly select individuals search points constitute initial population 
fixed length string representation usual approach select field string randomly possible values 

set genetic operators provides way information search points stochastically generate new search points 
standard genetic operators mutation crossover 
mutation takes single parent produces child information parent small number locations new information randomly generated 
crossover takes parents produces children information combination information parents 
shows examples mutation crossover acting fixed length real valued strings 

variety parameter settings determine run time characteristics genetic algorithm 
parameters include population size generation size generation size equals population size full generational replacement generation size steady state genetic algorithm operator selection probabilities parameters involved parent selection 
components genetic algorithm operates steps pictured 
initialization process generate initial population size population size evaluate individuals 

generate new generation size generation size process reproduction 
creation single new occurs follows initialize population select operator select parents apply operator parents add children generation needed 
produce new generation reproduction incorporate new generation population termination criterion met 
control flow genetic algorithm 
randomly select operator operator selection probabilities 
randomly select parents current population probability selecting particular individual monotonically increasing fitness individual 
number parents selected determined operator 
apply operator parents create children 

remove generation size worst member current population replace new generation 

termination criterion met repeat step 
set set subroutine equivalent parse tree 
genetic programming describe components type genetic algorithm genetic programming representation genetic programming computer programs represented parse trees 
parse tree tree nodes procedures functions variables constants 
subtrees node parse tree represent arguments procedure function node 
variables constants take arguments nodes subtrees leaves 
executing parse tree means executing root tree executes children nodes appropriate recursively 
subroutine represented parse tree 
example subroutine shown represented parse tree shown 
conversion subroutine parse tree non trivial languages pascal ada language lisp subroutine lisp called expression essentially parse tree precisely parse tree expressed linear fashion 
node representing variable constant expressed name variable value constant 
node representing function expressed followed function name followed expressions subtree order followed 
lisp expression parse tree 
set set expressions compact way expressing subtrees parse trees written section think parse trees learned genetic programming lisp expressions 
genetic programming user defines possible functions variables constants nodes parse tree 
variables constants functions take arguments leaves possible parse trees called terminals 
functions take arguments branches possible parse trees called non terminals 
set terminals called terminal set set non terminals called non terminal set 
aside terminology term non terminal describe koza calls function 
terminal standard computer science nomenclature call function subroutine returns value 
important constraint user defined terminals non terminals called closure 
closure means elements take arguments single data type scalar return values data type 
implies elements return values arguments element element child node parse tree element having conflicting data types 
koza describes way relax constraint closure concept constrained syntactic structures 
uses tree generation routines generate legal trees uses operators maintain legal syntactic structure 
stgp focus builds generalizes concept 
search space set parse trees elements non terminal set terminal set legal right number arguments function maximum depth 
limit maximum depth parameter keeps search space finite prevents trees growing excessively large size 
evaluation function evaluation function consists executing program defined parse tree scoring results execution match desired results 
user supply function assigns numerical score set derived results matches desired results 
initialization procedure koza defines different ways generating member initial population full method grow method 
parse tree generated full method length path root leaf path taken tree full depth path 
parse trees generated grow method need satisfy constraint 
methods tree generated recursively algorithm described pseudo code maxdepth maxdepth set root tree randomly selected terminal full set root tree randomly selected non terminal set root randomly selected element terminal non terminal argument root generate subtree call maxdepth standard approach koza generating initial population called ramped half half 
crossover mutation mutation crossover genetic programming 
uses full method generate half members grow method generate half 
maximum depth varied max initial tree depth 
approach generates trees different shapes sizes 
genetic operators standard genetic algorithm main genetic operators mutation crossover koza claims mutation generally unnecessary 
tree representation operators differently standard mutation crossover 
mutation works follows randomly select node parent tree mutation point ii generate new tree maximum depth max mutation tree depth iii replace subtree rooted selected node generated tree iv maximum depth child equal max tree depth 
maximum depth greater max tree depth parent koza start scratch 
mutation process illustrated 
crossover works follows randomly select node tree crossover points ii take subtree rooted selected node second parent replace subtree rooted selected node parent generate child optionally reverse obtain second child iii child maximum depth equal max tree depth 
crossover procedure illustrated 
parameters parameters associated genetic programming standard genetic algorithms 
max tree depth maximum depth tree 
max depth maximum depth tree part initial population 
max depth maximum depth subtree generated mutation operator part child tree parent tree 
strongly typed genetic programming stgp discuss extension basic genetic programming approach called strongly typed genetic programming stgp generalization koza constrained syntactic structures 
key contribution stgp eliminates closure constraint described allows functions take arguments data type return values data type 
simplest form stgp requiring function specify precisely data types arguments returned values functions strongly typed 
stgp ensure parse trees generates satisfy constraint arguments functions correct type 
concept generics stgp allows significant relaxation need specify data types precisely data types broad class specified precisely context 
section discusses details extensions basic genetic programming needed ensure argument types correct 
section describes key concept making stgp easier generic functions true strongly typed functions templates classes strongly typed functions 
section discusses generic data types classes data types 
section examines special data type called void data type indicates data returned 
section describes concept local variables stgp 
section tells stgp handles errors 
section discusses stgp started laying foundations new computer language particularly suited automatic programming 
note different approach extending genetic programming allow different data types stack approach described 
approach different data types stored different stacks manipulated differently different stacks opposed stgp method reasoning legality data types 
basics discuss detail changes standard genetic programming genetic algorithm component representation stgp standard genetic programming variable constant assigned type 
example constants type float variable type vector indicating dimensional vector variable type matrix indicating matrix 
furthermore function specified type argument value returns 
shows variety strongly typed functions argument types returns types 
readers familiar lisp car function takes list returns element steele 
stgp lisp list contain elements type return type car functions returning element list deduced 
note describe generic functions provide way define single function functions essentially operation dot product dot product different values 
handle multiple data types definition constitutes legal parse tree additional dot product vector float vector vector add mat vec mult car float int length vector vector vector matrix vector vector vector list float float list vector integer boolean integer integer integer function name arguments return type strongly typed functions argument types return types 
scalar vec mult dot product vector add example legal tree return type vector 
criteria required standard genetic programming root node tree returns value type required problem ii non root node returns value type required parent node argument 
criteria legal parse trees illustrated example example consider non terminal set product dot product vector add vector add scalar vec mult scalar vec mult terminal set fv variables type vector variable type vector 
required return type vector 
shows example legal tree 
shows examples illegal trees left tree root returns wrong type right tree places argument types match return types 
evaluation function changes evaluation function 
initialization procedure change initialization procedure standard genetic programming type restrictions element chosen node 
scalar vec mult dot product vector add scalar vec mult vector add vector add examples illegal trees return type vector 
restriction element chosen node return expected type root node expected return type tree node argument type parent node 
second restriction recursively selecting nodes select element impossible select legal subtrees 
note impossible select tree specified depth generation method tree returned initialization procedure proceeds depth generation method 
discuss second restriction greater detail give example tree generation process 
example consider full method generate tree depth returning type vector terminal non terminal sets example 
give detailed description decision process generate tree 
point choose scalar vec mult vector add chooses scalar vec mult 
point choose dot product chooses dot product 
points choose 
point choose vector add 
note tree depth scalar vec mult root scalar vec mult legal choice returns right type 
points choose chooses point point 
regarding second restriction observe non terminal element root tree maximum depth argument types generated trees maximum depth gamma 
check condition efficiently types possibilities tables generate generating tree 
table tells max initial tree depth possible return types tree maximum depth different types possibilities tables trees generated full method grow method 
example shows tables necessarily 
algorithm pseudo code generating tables 
trees depth single terminal element loop elements terminal set contain element type add element type loop loop grow method trees size valid trees size grow method add types loop elements non terminal set element argument types contain element return type add element return type loop loop example terminal non terminal sets example types possibilities tables full grow method vector vector vector vector float note example choosing node point known scalar illegal seeing float table entry depth 
example consider case vec mult mat vec mult matrix add fm type matrix type matrix type vector 
types possibilities tables grow method vector matrix matrix vector vector matrix matrix types table full method vector matrix matrix odd vector matrix matrix genetic operators genetic operators initial tree generator respect enhanced legality constraints parse trees 
mutation uses algorithm employed initial tree generator create new subtree returns type deleted subtree internal consistency argument types return types see 
impossible generate tree mutation operator returns parent 
crossover works follows 
crossover point parent selected randomly nodes tree 
crossover point second parent selected subtree returns type subtree parent 
crossover point selected randomly nodes satisfying constraint see 
node crossover operator returns parents 
parameters changes parameters 
scalar vec mult dot product scalar vec mult dot product mutation scalar vec mult dot product vector add mutation stgp 
scalar vec mult dot product scalar vec mult dot product scalar vec mult dot product vector add scalar vec mult dot product vector add crossover crossover stgp 
dot product vector float vector vector add mat vec mult car length vector vector matrix vector vector vector list list integer boolean function name arguments return type generic functions argument types return types 
arbitrary integers arbitrary data type 
generic functions examples illustrate major inconvenience basic stgp formulation need specify multiple functions perform operation different types 
example inconvenient specify dot product dot product single function 
eliminate inconvenience introduce concept generic function 
generic function function take variety different argument types general return values variety different types 
constraint particular set argument types generic function return value defined type 
specifying set argument types return type generic function called instantiating generic function 
examples generic functions shown 
note case specifying argument types precisely allows deduce return type precisely 
example specifying car argument type list float implies returned value type float specifying mult arguments type matrix vector implies returned value type vector 
parse tree generic function instantiated 
instantiated instance generic function keeps argument types passed parent child 
instantiated generic function acts exactly standard strongly typed function 
generic function gets instantiated process generating parse trees initialization mutation 
note multiple instantiations generic function single parse tree 
generic functions act standard strongly typed functions instantiated changes stgp algorithm needed accomodate generic functions tree generation procedure 
changes required 
process generating types possibilities tables recall standard non terminal functions needed just check argument types table entry depth gamma order add return type table entry depth generic functions generic function variety different argument types return types 
generic functions step replaced loop ways combine types sets argument types function set arguments types legal return type set argument types add return type loop second change tree generation process 
recall standard functions deciding particular function child existing node independently check returns right type argument types generated 
generic functions replace tests single test loop ways combine types sets argument types function set arguments types legal return type set argument types correct return function legal loop return function legal third change tree generation process 
note types generic functions ones argument types fully determined selection return types ones argument types fully determined return types 
call generic functions free arguments 
examples generic functions free arguments dot product mult examples generic functions free arguments vector add scalar vec mult 
select generic function free arguments node tree return type determined parent node root position required tree type fully specify argument types 
determine arguments types return types children nodes types possibilities table determine possible sets argument types give rise determined return type set function selected randomly select sets 
example generic functions rewrite non terminal set example compact form product vector add scalar vec 
recall fv scalar vec mult dot product vector add legal tree generic functions 
type vector type vector 
types possibilities tables example 
shows equivalent tree 
generate tree shown example full tree depth go steps 
point select vector add scalar vec mult choose scalar vec mult 
point select dot product 
dot product free arguments select argument types 
examining types possibilities table see pairs vector vector vector vector legal 
randomly select vector vector 
points type vector 
point vector add 
scalar vec mult illegal float types possibilities table entry depth 
points choose point point 
generic data types generic data type true data type set possible data types 
examples generic data types vector gennum represents vector arbitrary dimension represents arbitrary type 
generic data types treated differently tree generation tree execution 
generating new parse trees initializing population reproduction quantities gennum treated algebraic 
examples generic data types manipulated tree generation shown 
execution quantities gennum specific values data evaluation 
example evaluation data choose particular vector type vector gennum dimensional vector gennum equal purpose executing data 
examples illustrate generic data types 
example consider terminal set fv non terminal set product vector add scalar vec example 
set type vector gennum type vector gennum return type tree vector gennum 
illegal add different dimensions legal add dimension 
fact set legal parse trees example set legal parse trees example 
difference example providing data evaluation function constrained dimension dimension 
example providing examples arbitrary vectors long dimension 
vector gennum vector add car vector list function arguments return type vector gennum vector gennum vector gennum vector add different dimensions illegal vector add vector gennum vector gennum different dimensions illegal vector add illegal vectors car illegal list boolean examples generic data types manipulated 
example consider terminal non terminal sets examples 
specify type vector gennum type vector gennum type vector gennum 
illegal add illegal add happen type vector gennum gennum data provided evaluation function 
fact majority trees legal examples illegal example including 
reason generic data types eliminate operations legal particular set data evaluate performance illegal potential sets data 
examples function nth discussed section function mapcar discussed section 
evaluation functions lists type list float 
generic data types perform operations car car 
nth mapcar list including lists types list string list list float expression car car illegal 
generic data types purpose generating trees lists type list expression illegal 
advantage generic data types eliminating certain operations reduces size search space large factor 
smaller search spaces mean time required search 
noisy evaluation functions smaller search spaces help problem overfitting fitting solution model random noise evaluation data addition signal problem arises kalman filter example described section 
third reason generic data types generic data types functions learned genetic programming generic functions 
see means note variable type set variable dotimes integer function arguments returns void float turn right execute void void void void examples functions void data type 
examples section learning function stgp function takes typed arguments returns typed value 
example nth function takes arguments list integer returns value type elements list squares function takes matrix vector arguments returns vector 
generic data types functions stgp learns non generic functions fully specified data types arguments returning value fully specified data type 
example nth take list float integer arguments return float 
functions generic functions nth take list integer return arbitrary type generic data types possible 
particularly important start learned functions building blocks higher level functions 
void data type special data type indicates particular subroutine procedure function returns data 
call data type void consistent special data type purpose kernighan ritchie 
procedures act side effects changing internal state 
examples functions arguments returned values type void shown 
set variable effect changing local variable value see section 
effect making agent robot simulated ant turn right certain angle 
execute executes subtrees sequence returns value second 
dotimes executes second subtree certain number times succession number executions determined value returned subtree 
having execute dotimes take voids arguments take arbitrary types arguments 
philosophy choice void values arguments effect arguments side effects 
function may return value side effects useful just execute side effects function separate procedure just executes side effects 
eliminating parse trees meaningless operations involved computing values reduces size search space 
float vector entries type value integer list empty list default values different variable types 
additionally generic functions handle arbitrary types handle type void 
example take void second third arguments return void 
local variables high level programming languages provide local variables slots data stored execution subroutine 
stgp provides local variables 
terminal nonterminal sets local variables types specified user 
example user specify variable type vector gennum variable type integer 
local variable functions automatically defined set var takes argument type variable returns type void get var takes arguments returns type variable fact effect specifying local variable define functions add get var terminal set set var non terminal set 
set var sets value variable equal value returned argument 
get var returns value variable value set variable set default value variable type 
shows default values chosen different types 
run time errors stgp avoids important type error mismatched types strong typing ensure types consistent 
types errors occur executing parse tree call run time errors 
implementation stgp handles run time errors follows 
functions return values non void functions return pointers data 
function gets error returns null pointer 
functions return type void procedures signal errors returning null pointer signal successful operation returning arbitrary non null pointer 
arguments function returns null pointer function stops executing returns null pointer 
way errors get passed tree 
function initially detects error sets global variable analogous unix global variable errno indicate type error 
reason function needs specify type error evaluation function information 
example unprotected version nth function see section argument specifies element list bad list element error see right response time error bad response 
eventually error type available functions tree 
example define function error type returns type error part terminal set 
current error types inversion singular matrix matrix inverse function performs gaussian elimination procedure 
procedure column entries absolute values small value ffl inversion fails error type 
note common error doing matrix manipulation easy generate square matrices rank dimension 
example matrix nxn matrix rank singular 
likewise aa mxm matrix rank singular 
furthermore aa gamma gamma dimension trees place disregarding limitations maximum depth 
note point protected inversion analogous koza protected division returned identity matrix attempting invert singular matrix 
problems 
examples evaluation data yield singular matrix protected inversion matrix generally yields incorrect results cases matrix nonsingular 
example evaluation data squares example see section chose dimensions 
optimizing value yields expressions extra multiplications aa gamma included 
problem expression supposed optimal square matrix aa generally invertible case extra multiplications included 
second problem examples evaluation data yield nonsingular matrix protected inversion matrix generally yields incorrect results cases matrix singular 
example consider squares problem 
singular multiple optimal solutions 
right thing case may return solutions may raise error protected inversion 
bad list element consider car element empty list 
lisp car nil empty list return nil 
problem stgp type consistency car return data type elements list return float list type list float 
alternative ways handle raise error second default value possible type 
reasons similar protected matrix inversion choose return error protected car 
note car function type error 
example unprotected version function nth see section raises error argument length argument division zero scalar division examples error type 
include just show alternative protected division koza returns division zero attempted 
time certain trees take long time execute evaluate particularly trees nested levels iteration 
ensure evaluation get bogged evaluating individual place problem dependent limit maximum amount time allowed evaluation 
certain functions check amount time elapsed raise error 
currently dotimes matrix inverse functions perform check 
dotimes check time executing loop body matrix inverse check performing inversion 
stgp programming language process defining stgp taken steps defining new programming language 
language cross ada lisp 
essential ingredient takes ada concept strong typing concept generics way making strongly typed data functions practical barnes 
essential ingredient takes lisp concept having programs basically parse trees steele 
resulting language best considered strongly typed lisp 
note important distinguish language parser 
underlying learning mechanism analog compiler standard genetic programming written language programs learned lisp programs 
similarly learning mechanism stgp written language programs manipulated hybrid language 
reasons strongly typed lisp language learning programs genetic algorithms type automatic learning programs 
having programs isomorphic parse trees programs easy create revise recombine 
easy define genetic operators generate new programs define methods generating programs 
strong typing easy ensure automatically generated programs legal programs 
standard dynamically typed lisp relies abilities human programmers ensure data types manipulated legally 
turn relies human programmers understand functions call read documentation 
formal approach required allow automatic programming techniques rely large amounts computation understanding generate legal trees 
ability define formal approach provided strong typing 
experiments discuss problems applied stgp 
multi dimensional squares regression section multi dimensional kalman filter section problems involving vector matrix manipulation 
function nth section function mapcar section problems involving list manipulation 
discussing experiments describe genetic algorithm experiments 
genetic algorithm genetic algorithm differs standard genetic algorithm ways due trees strings chromosomes 
describe differences readers best analyze desired reproduce results 
code genetic algorithm translation early version davis 
important distinction genetic algorithm steady state replacement syswerda generational replacement performing population updates 
means generation individual small number individuals generated placed population generating new population 
benefit steady state replacement individuals immediately available parents waiting rest population evaluated speeding progress genetic algorithm 
steady state replacement sense report run durations number generations total number evaluations performed 
comparisons results different genetic algorithms units number evaluations 
steady state genetic algorithms parallelized montana comparison fair 
second important features code exponential fitness normalization cox davis qiu 
means selecting parents reproduction probability selecting individual depends relative rank population ii probability selecting th best individual parent scalar times selecting gamma st best individual 
parent scalar parameter genetic algorithm 
important benefits exponential fitness normalization ability simply precisely control rate convergence choice values population size parent scalar 
controlling convergence rate important avoid excessively long runs runs converge prematurely non global optimum 
effect population size parent scalar convergence rate detailed montana 
purposes note increasing population size increasing parent scalar slow convergence rate 
multi dimensional squares regression problem description multi dimensional squares regression problem stated follows 
matrix vector find vector minimizes quantity ax gamma problem known solution gamma gamma called pseudo inverse campbell meyer 
note generalization linear regression problem pairs data find line mx gives best squares fit data 
special case xm output type output type vector gennum 
arguments argument type matrix gennum gennum argument type vector gennum 
local variables local variables 
terminal set fa bg non terminal set non terminal sets transpose matrix inverse mat vec mult mat mat transpose matrix inverse mat vec mult mat mat mult matrix add matrix subtract vector add vector subtract dot product scalar vec minimal non terminal set necessary solve problem 
evaluation function single data point evaluation function 
deterministic problem solution multiple cases single data point theory required 
data point chose gennum gennum matrix vector 
entries selected randomly 
score particular tree ax gamma vector obtained executing tree 
genetic parameters chose max initial depth population size respectively different non terminal sets 
parameters irrelevant optimal solution initial population 
results ran stgp times non terminal set population size times non terminal set population size 
time optimal part initial population 
average optimal parse trees initial population 
total optimal trees generated runs distinct optimal trees 
note steady state genetic algorithm duplicate trees run 
second case average optimal trees initial population 
look sampling optimal parse trees minimum number nodes written expressions mat vec mult matrix inverse mat mat mult matrix transpose mat vec mult matrix transpose mat vec mult mat mat mult matrix inverse mat mat mult matrix transpose matrix transpose tree addition having minimum number nodes minimum depth 
grow full max depth legal trees gp trees fraction legal max depth legal trees gp trees fraction legal legal trees vs gp trees different tree sizes non terminal set optimal tree depth non terminal set optimal trees depth including mat vec mult matrix inverse mat mat mult matrix transpose matrix add mat vec mult matrix transpose vector add see important strong typing problem small experiment 
nonterminal set counted number legal trees trees types consistent size number gp trees trees nodes right number subtrees arguments necessarily type consistent size 
calculated ratio legal trees gp trees determine probability tree size randomly selected non strongly typed genetic programming algorithm legal tree 
results different sizes shown 
analysis problem easy exercise gp genetic programming part stgp problems discussed exercise clearly illustrates importance st strongly typed part 
results show just generating legal parse trees computationally intractable task try generating random gp trees selecting legal ones 
method generating legal parse trees clearly superior approach difficult problem easy 
kalman filter problem description kalman filter popular method tracking state system stochastic behavior noisy measurements kalman 
standard formulation kalman filter 
assume system follows stochastic equation dimensional state vector nxn matrix dimensional noise vector matrix 
assume noise gaussian distributed mean covariance mxm matrix assume continuous measurements system equation dimensional output measurement vector matrix dimensional noise vector gaussian distributed mean covariance kxk matrix estimate state minimizes sum squares estimation errors pc gamma gamma ap pa gamma pc gamma cp covariance state estimate 
done far focused learning right hand side equation 
analysis portion discuss focused just state estimate part equation take simultaneously learn covariance part equation 
output type output type vector gennum 
arguments arguments type matrix gennum gennum type gennum type matrix gennum gennum type matrix gennum gennum type vector gennum est type vector gennum 
local variables local variables 
terminal set fa non terminal set mat mult matrix inverse matrix transpose mat vec mult vector add vector evaluation function running genetic algorithm created track equations parameters chosen gamma gamma gamma gamma gamma gamma note choice parameters implies gennum gennum 
time step ffi significantly larger time steps caused unacceptably large approximation errors significantly smaller time steps caused unacceptably large computation time evaluation function ran system time time steps recording values time step 
initial conditions track genetic algorithm reads stores track part initialization procedure 
evaluating parse tree done follows 
start equal initial value equation 
time steps update new old ffi value returned tree new old ffi right ide equation time step compute difference state estimate state step 
score tree sum time steps square difference 
note guarantee parse tree implementing correct solution equation give best score tree 
possible sources variation quantization effect introduced fact step size infinitesimally small ii stochastic effect introduced fact number steps infinitely large 
problem overfitting briefly discussed section 
genetic parameters population size parent scalar maximum initial depth maximum depth 
results ran stgp times specified parameters time optimal solution equation 
find optimal solution required average evaluations maximum evaluations 
minimal parse tree implementing solution vector add mat vec mult mat vec mult mat mat mult matrix inverse mat vec mult matrix transpose vector subtract mat vec mult runs allowed genetic algorithm execute number evaluations finding optimal solution generally extra evaluations 
case stgp better solution optimal parse tree gave better score solution equation 
letting run continue eventually yielded best tree implemented solution pc gamma gamma gamma score compared score trees implemented equation 
analysis appropriate genetic parameters sufficient number evaluations stgp trouble finding theoretically optimal solution state estimate correct covariance 
validation stgp ability solve moderately difficult problem vector matrix manipulation run stgp able overfit training data finding additional term modeled noise 
search space finite exists time step small total time large theoretically optimal solution evaluates best data 
due lack computational power able experiment different time steps total times order find time step total time required prevent overfitting 
evaluation time parse tree proportional number data points generated track 
indication stgp current shortcomings fact able serious attempt solving full problem simultaneously deriving state estimate equation covariance equation 
problem twofold combined expression complicated single vector expression second terms covariance update equation higher order effects state estimate error 
means large amounts data needed allow higher order effects washed noise 
combined effect required computational power far available experiments 
function nth problem lisp function nth takes arguments list integer returns th element standard definition nth steele specifies returns st element list nth return second element list 
nth defined raise error length nth defined return nil empty list 
stgp learn nth defined way type inconsistency caused returning empty list situations 
define variations function nth increasing order complexity ffl nth identical nth length raises bad list element error returning empty list returns element raising error 
change just simplicity 
ffl nth nth return th element st element 
ffl nth nth length returns element list raising bad list element error 
output type output type 
arguments argument type integer argument type list 
local variables variable type list 
terminal set fn get var non terminal set different non terminal sets variations nth 
nth nth nth respectively fcar cdr execute dotimes set var fcar cdr execute dotimes set var plus fcar cdr execute dotimes set var plus minus min evaluation function nth different examples evaluate performance 
example assume different value range 
examples took list length entries unique 
example evaluation function executed tree compared returned value expected result compute score scores example summed total score 
score example defined correct behavior raise error tree returned value correct behavior raise error tree returned value correct behavior raise error tree raised error gammad correct behavior return value tree returned value positions away correct position list 
example list tree returned get score example tree returned get score 
nth evaluation function nth assumed values range expected result example th st list element 
nth evaluation function nth changes 
case correct behavior raise error cases length correct behavior return list element 
second shortened length purely purpose speeding evaluation function 
third allowed range large number cases length amply reward tree handled case correctly 
genetic parameters nth nth population size parent scalar maximum initial depth maximum depth 
nth population size parent scalar maximum initial depth maximum depth 
results runs genetic algorithm nth problem 
runs optimal solution average trees evaluated finding solution 
runs optimal solution initial population longest run required evaluations initial population trees generated reproduction 
tree minimal respect nodes depth execute dotimes execute set var set var cdr get var car get var runs genetic algorithm nth problem 
runs optimal solution average maximum trees evaluated finding solution 
tree solution minimal respect nodes depth execute dotimes execute set var set var cdr get var car get var nth performed experiment determine effectiveness random search 
consisted randomly generating parse trees method generate initial population genetic algorithm ramped half half maximum depth plus check sure tree generated unique 
experiment kept generating trees optimal 
run random search algorithm required trees evaluated finding optimal 
second run required trees evaluated 
runs genetic algorithm nth problem 
runs optimal solution average maximum trees evaluated finding solution 
unsuccessful run converged point members population provided different solution nth problem 
tree solution nth minimal respect nodes depth execute dotimes execute set var min length set var cdr get var car get var analysis nth problem squares regression problem easy test genetic algorithm part stgp 
moving nth nth adding just little bit complexity problem adding new functions non terminal set replacing minimal optimal tree problem sufficiently difficult clearly illustrate difference random search genetic algorithms 
search time genetic algorithm increased factor search time random search increased factor approximately 
computational limitations kept moving evaluations versus problem complexity curve random search results yield koza genetic search parse tree space superior random search sufficiently complex searches reason better scaling properties genetic algorithms 
nth problem difficult nth reasons 
minimal size optimal solution requires extra nodes parse tree 
second minimal size optimal solution depth requires search space parse trees greater depth bigger space 
third extra functions non terminal set 
increase difficulty reflected increase required times find solution 
function mapcar problem description lisp function mapcar takes arguments list function returns list obtained applying element show stgp learn function 
note able function mapcar element non terminal set learning higher level functions requires concept functional argument ability pass function result applying function argument function 
implemented functional arguments possible stgp functional argument type form function returning type argument type type hope functional arguments 
output type output type list 
arguments argument type list argument function returning 
local variables variable type list variable type list 
terminal set fl get var get var non terminal set fcar cdr execute dotimes set var set var length append evaluation function evaluate performance different lists argument function argument 
lists empty list list single element equal list elements values integers 
function identity 
score sl list executing parse tree produces error list sl gamma gamma length error gamma gamma length dist distance th position rationale choice lists follows 
element list primary test performance 
doing list assures score 
lists penalize slightly parse trees perform correctly short lists 
example parse tree perfectly long list gets error empty list execute dotimes execute set var length cdr execute set var append get var car get var set var cdr get var append get var car get var error comes empty list variable empty list car gives error 
parse tree receive score compared maximum score 
sample parse trees scores 
parse tree append get var car get var receives minimum score 
parse tree append get var car receives score 
parse tree execute dotimes length set var append get var car get var receives score 
parse tree execute dotimes execute set var length cdr execute set var cdr get var set var append get var car get var get var receives score 
optimal parse tree execute dotimes execute set var length execute set var append get var car get var set var cdr get var get var receives maximum score 
genetic parameters population size parent scalar maximum initial depth maximum depth 
results ran stgp times specified parameters runs optimal solution 
runs find optimal solution average number individuals evaluated finding optimal maximum numbers evaluations 
runs stgp converged prematurely population consisting distinct parse trees evaluated 
analysis number evaluations required find optimal solution mapcar clearly difficult problem discussed 
find optimal solution probability takes order evaluations roughly order magnitude problems 
key factor problem difficult existence suboptimal solution relatively easy find difficult get 
large number evaluations required solve mapcar illustrates main shortcoming stgp 
despite relatively scaling stgp genetic algorithms general problem complexity amount computation required function problem complexity grows fast today computers stgp solve relatively simple problems 
introduced concept strongly typed genetic programming stgp 
stgp extension genetic programming fully eliminates closure constraint necessary standard genetic programming 
allows user define functions take data types arguments return values data type 
defined stgp concepts generic functions generic data types local variables errors way making stgp practical powerful 
process taken steps definition new programming language essentially strongly typed lisp particularly suited automatic programming 
primary experiments performed illustrate effectiveness stgp solving wide variety moderately complex problems involving multiple data types 
experiments show importance strong typing generating trees ii importance genetic algorithm random search tree space 
experiments illustrate current shortcomings stgp 
difficult define evaluation functions relatively simple problems 
second despite fact stgp scales complexity compared random search truly complex problems ability stgp solve reasonable time today computers 
experiments show stgp great potential automatic programming tool improvements necessary able learn truly complex programs 
barnes barnes 
programming ada 
addison wesley 
campbell meyer campbell meyer jr 
generalised inverses linear transformations 
pittman 
cox davis qiu cox jr davis qiu 
dynamic anticipatory routing circuit switched telecommunications networks davis pp 

cramer cramer 
representation adaptive generation simple sequential programs 
proceedings fourth international conference genetic algorithms pp 

davis davis 
genetic algorithms simulated annealing 
pittman 
davis davis 
handbook genetic algorithms von nostrand reinhold 
goldberg goldberg 
genetic algorithms search optimization machine learning 
addison wesley 
kalman kalman 
new approach linear filtering prediction problems 
trans 
asme basic eng vol 
pp 

kernighan ritchie kernighan ritchie 
programming language 
prenticehall 
koza koza 
genetic programming 
mit press 
montana montana 
automated parameter tuning interpretation synthetic images davis pp 

montana montana 
genetic search generalized hough transform space preparation 

stack genetic programming steele steele 
common lisp 
digital equipment 
syswerda syswerda 
uniform crossover genetic algorithms proc 
third international conference genetic algorithms pp 


