type checking universes robert harper robert pollack various formulations constructive type theories proposed serve basis machine assisted proof theoretical basis studying programming languages 
calculi include cumulative hierarchy universes type types closed collection type forming operations 
universes interest variety reasons philosophical predicative vs impredicative type theories theoretical limitations closure properties type theories practical achieve advantages type types sacrificing consistency 
generalized calculus constructions cc formal theory types includes hierarchy universes 
essential formalization constructive mathematics universes tedious practice required specific choices universe levels ensure choices consistent 
study problems associated type checking presence universes context cc consider basic type checking typedness problems calculus 
second consider formulation russell whitehead typical ambiguity convention universe levels may elided provided consistent assignment levels leads correct derivation 
third consider definitions basic calculus calculus typical ambiguity 
extension leads notion universe polymorphism analogous type polymorphism ml 
study conducted cc school computer science carnegie mellon university pittsburgh pa laboratory foundations computer science university edinburgh edinburgh eh jz expect methods apply variants calculus constructions type theories constable 
number formulations intuitionistic type theory considered basis studying machine assisted formal proof development theoretical foundation study programming languages see example name :10.1.1.21.5854
system calculus constructions cc introduced coquand huet comprehensive basis formalization constructive mathematics 

cc may viewed calculus associated propositions types principle natural deduction proofs extension church higher order logic 
system proved proof theoretically model theoretically consistent type checking problem proved decidable 
cc exceedingly rich formalism expressing mathematical constructions variety extensions calculus considered :10.1.1.37.3153
extensions motivated variety concerns ranging desire delineate space consistent extensions calculus practical needs formal proof program development 
consideration representation mathematical structures algebras automata ordered sets 
widely recognized appropriate type theoretic representation mathematical structures elements strong sum types introduced martin lof howard 
strong sums model modularity constructs programming languages 
unfortunately strong sums sense incompatible impredicativity :10.1.1.37.3153
result necessary extend calculus level types postulate closure additional level formation strong sums 
mathematical structures represented elements types higher level 
having extension immediately sees process may iterated higher lev known literature dependent products generalized sums 
confused weak sums existential types introduced connection data abstraction 
els needed formalization notions category small categories 
recognition fact coquand introduced generalized calculus constructions cc includes cumulative hierarchy universes 
universe type closed operations calculus formation products strong sums indexed type universe level 
cumulative hierarchies kind arise formal systems mathematics arise various guises principia mathematica contemporary type theories 
universe hierarchies tedious practice 
workers attempted avoid complications hierarchy assuming type types 
assumption destroys normalization property calculus 
result type inhabited closed term interpretation propositions types central applications lost 
context type systems programming languages merits type type assumption subject ongoing research 
alternative approach dealing stratification formal systems introduced russell whitehead principia mathematica 
introduced informal convention called typical ambiguity universe levels explicitly mentioned tacitly asserted exists assignment levels resulting proof correct respect requirements logic principia mathematica 
observed practice exact choice universe levels unimportant matters relationship choices levels different points proof 
modern perspective typical ambiguity described way achieve flexibility having type types sacrificing logical consistency theory 
level concrete syntax user explicit mention universe levels leaving proof checker ensure choice levels yields type correct term underlying calculus explicitly stratified universes 
study type checking typedness problems variants cc type checking problem calculus decide context term candidate type term type context 
typedness problem decide context term exists type term type context 
case solution problems obtained reduction type synthesis algorithm yields context term description set possible types term context 
course exact definitions context term vary calculi consider general pattern remains 
organized follows 
section define system cc state important properties 
section introduce operational presentation cc 
significance operational presentation provides normal form typing derivations exploited type synthesis algorithm 
section type synthesis conversion algorithm cc natural semantics style 
form presentation facilitates proofs correctness algorithm especially evident relationship operational rules 
section extend calculus include anonymous universe means implementing typical ambiguity convention 
explicit universe levels may omitted anonymous universe understanding ambiguous term stands consistent replacement anonymous specific universes 
section extend basic calculus calculus anonymous universes admit definitions form ffi reductions 
failure type unicity induced cumulativity universe hierarchy leads form universe polymorphism similar type polymorphism ml 
combination anonymous universes definitions leads particularly flexible calculus exploiting typical ambiguity 
section discuss related research 
grateful rod burstall thierry coquand despeyroux hayashi erard huet gilles kahn zhaohui luo anonymous referee insightful comments 
research supported british science engineering research council gr gr defense advanced research projects agency contract number 
definition cc syntax generalized calculus constructions cc obtained extending basic calculus constructions full cumulative hierarchy type universes 
range infinite set variables range natural numbers 
syntax grammar prop type kinds fx mm terms gamma ffl gamma contexts metavariables range terms ranges kinds 
terms type called universes 
pair context gamma declaration declares consider contexts variable declared 
dom gamma set variables declared gamma 
write gamma gamma gamma mean declaration occurs gamma indicated position 
notions free bound variable defined usual 
fv set free variables notation fx agb doesn free reduction conversion setting fi redex form contractum relations 
step fi reduction fi reduction fi conversion defined usual 
church rosser property holds fi conversion theorem cr exists im proof see 
term strongly normalizing sn reduction sequence starting term finite 
relation wh 
step weak head reduction defined rules table 
wh weak head reduction transitive reflexive closure wh 
fi contracts wh wh wh table step weak head reduction weak head normal form whnf weak head reduce term 
clearly term whnf fi redex application whnf 
term weak head normal form shapes fx agb weak head normal form shape type system cc formal system deriving assertions form gamma read type context type assumptions gamma 
axioms rules derivation cc table 
write gamma mean indicated assertion derivable formal system omitting explicit mention gamma empty context 
brief summary rules cc may helpful 
rules vali vali define valid contexts consisting sequence declarations assigning variable proposition type arbitrary universe level 
rules introduce constants prop type rule governs typing variables 
rules pif pif pif encode fundamental closure conditions cc class propositions closed universal quantification type including proposition class propositions types universe level rule pif 
universe closed products indexed proposition type level rules pif pif 
rules pii pie govern lambda abstraction application 
rule conv asserts invariance typing conversion type expression rule cum asserts cumulativity hierarchy universes property plays central role 
vali ffl valid vali gamma dom gamma gamma valid gamma valid gamma prop type gamma valid gamma type type gamma gamma valid gamma gamma pif gamma prop gamma fx agb prop pif gamma prop gamma type gamma fx agb type pif gamma type gamma type gamma fx agb type pii gamma gamma fx agb pie gamma fx agb gamma gamma mn conv gamma gamma gamma cum gamma type gamma type table definition cc theorem luo properties cc ffl derivation gamma gamma subderivation gamma kind ffl derivation gamma subderivation gamma valid 
ffl gamma gamma kind ffl subject reduction gamma gamma ffl strong normalization gamma sn 
proof see operational presentation step presentation type checking algorithm cc helpful give syntax directed operational presentation calculus property rule inference applies term 
presentation conversion relation 
conversion relation defined rules table 
informally holds iff reduce standard reduction sequence common term 
convertible usual sense 
converse fails standard reduction sequence fails yield normal form restrict attention typed terms relations coincide relation decidable 
theorem conversion algorithm soundness 
completeness sn 
decidability decidable sn oc type wh type wh type wh wh wh prop wh prop wh fx ga wh fx gb wh wh wh im wh table fi conversion algorithm proof derivation essentially specifies reduction sequences term 
soundness proved induction definition 
completeness suppose sn unique weak head normal forms respectively proceed induction structure example shape 
induction hypothesis cases similar 
decidability follows fact requisite weak head normal forms exist 
operational presentation cc inference rules defining relation gamma completely syntax directed rules conv cum applicable term 
operational presentation cc syntax directed formal system cc admits limited applications rules sacrificing completeness sense precise 
operational presentation table assertion form gamma intended mean type gamma 
operational presentation differs basic definition cc respects 
important difference handling contexts context validity assumed enforced 
result rules gen abs explicitly check validity type bound variable order maintain assumption 
formulation rules closer practical implementation avoids overhead repeatedly checking context validity atomic term 
important difference type conversion 
particular rules gen abs weak head reduction conversion presence church rosser property term convertible kind may weak head reduced 
rule app uses operational definition conversion discussed match domain argument types 
having limited uses conversion care taken ensure prop gamma prop type type gamma type type var gamma gamma cum gen gamma wh dom gamma gamma wh gamma fx agb abs gamma wh dom gamma gamma gamma fx agb app gamma wh fx ga gamma gamma mn cum cum defined cum type wh type prop prop type prop type type max type type table operational presentation cc potential uses cumulativity accounted 
example type type prop type type type prop type cumulativity applies 
similarly ff type type prop type type type examples illustrate need function cum rules var app result type may convertible universe cumulativity may apply point 
similarly rule gen defined terms auxiliary function account potential cumulativity 
lemma shows table cumulativity 
lemma gamma wh type gamma type proof inspection rules table 
main theorem section establishes relationship cc operational presentation theorem operational presentation cc soundness gamma valid context gamma gamma 
completeness gamma exists gamma proof theorem mention 
soundness ffi derivation gamma build derivation gamma induction height ffi 
base case ffi prop respectively type var result follows respectively cum 
induction case root node ffi gen abs app 
suppose example abs ffi 
gamma wh dom gamma 
gamma gamma fx agb induction hypothesis gamma wh necessarily typed conv vali give gamma valid 
induction hypothesis gamma pii shows gamma fx agb 
interesting consider case root ffi app 
ffi 
gamma wh fx ga 
gamma gamma mn cum theorem induction hypothesis gamma gamma typed subject reduction fx ga conv gamma fx ga pie cum gamma mn cum required 
cases similar 
completeness ffi derivation gamma build derivation gamma induction height ffi 
consider possible cases root node ffi 
ffi ends conv respectively cum result immediate induction respectively lemma 
cases follow directly induction hypothesis 
operational presentation syntax directed sense structure derivation gamma determined structure relation gamma partial function gamma due cumulativity universe hierarchy 
fact source variation derivations term context differ choice universe index parameters operational rules 
choice parameters constrained context 
example deriving type term type prop universe level sole occurrence prop constrained fact occurs argument function domain type hand universe level greater admissible type type 
important realize range possible types term determined structure term type 
example prop prop fx fx fx derivable 
cumulativity may thought form type containment distinguished sharply type systems impose upward closure condition typing respect pre order types 
order produce deterministic algorithm operational presentation remove indeterminacy postponing decisions choice possible outcomes replaced single schematic outcome 
introduce notions schematic term constraint section uniformly operational presentation 
fact approach allows sections formalize operationally implement algorithmically notions typical ambiguity universe polymorphism 
decision problems cc section schematic type synthesis algorithm valid context gamma term yields schematic description set possible types relative gamma 
algorithm algorithm testing convertibility schematic terms 
solutions typedness type checking problems cc easily derived algorithms 
schematic terms ff fi fl range infinite set level variables range level expressions consisting level variables natural numbers 
schematic terms ranged terms may involve universe schemes form type ff universe schemes regarded kinds range extended notion kinds 
ff level expressions prop type kinds fx terms lv set level variables occurring constraint set finite set inequalities form 
write pair constraints metavariables range constraint sets 
lv set level variables occurring constraint set level assignment partial function assigning natural numbers finite set level variables 
metavariables oe range level assignments 
dom oe set level variables oe assigns domain function 
level assignment oe satisfies constraint set written oe iff dom oe lv inequalities true assignment oe 
constraint set satisfiable consistent level assignment satisfies 
result due chan theorem chan polynomial time algorithm determine exists level assignment satisfying constraint set 
fact running time algorithm bounded number constraints number level variables 
level assignments extended schematic terms obvious way oex schematic term obtained replacing occurrences type ff ff dom oe type oe ff term oex called instance notice instance may contain level variables 
level assignments written explicitly ff 
ff 

write oe ff 
level assignment assigns ff behaves oe 
lemma reduction schematic terms 
oex sn iff sn 

wh type iff wh type oe 
wh fx gx iff wh fx gz 
similar 
cases wh wh proof subterm occurrence see 
level assignment completely respects structure terms may abuse notation say oe bijection subterm occurrences subterm occurrences oex 
reduction defined regard universe levels clear redex iff oe redex oex 
oex oe contracting redex oe oex produces iff induction get sc type wh type wh type wh wh wh prop wh prop wh fx gx wh fx gy wh wh wh wh table schematic fi conversion algorithm similar result arbitrary reduction sequences 
oe thought bijection reduction sequences oex preserves bijection subterm occurrences 
proves parts lemma 
table defines conversion algorithm schematic terms schematic terms yields weakest constraint set oe oex oey precise characterization relation theorem theorem conversion algorithm schematic terms soundness oe oex oey completeness oex oey exists oe 
decidability decidable strongly normalizing schematic terms exists constraint set derivable 
proof soundness ffi derivation 
hypothesis oe guarantees derivation oex oey proved induction height ffi lemma 
completeness ffi derivation oex oey induction height ffi construct derivation oe example suppose ffi instance oc type oex wh type oey wh type oex oey lemma wh type oe wh type oe sc type oe cases similar 
decidability sn required weak head normal forms exist 
schematic type synthesis algorithm schematic type synthesis rules table 
system deriving judgements form gamma intuitively schematically represent set types gamma 
algorithm auxiliary functions cum defined table 
functions analogous functions cum table characterized lemmas 
lemma suppose cum respectively 

oe exists oey cum oex respectively oe oe oe 

oe dom oe lv lv exists extending oe dom dom oe lv cum respectively 
prop gamma prop type ff ff ff new type gamma type type ff ff ff new var gamma gamma cum gen gamma wh dom gamma consistent gamma wh gamma fx agb abs gamma wh dom gamma consistent gamma gamma fx app gamma wh fx gx gamma gamma mn cum cum defined ff new lvar cum type ff ff wh type prop prop type ff ff prop type type ff ff ff type type table type synthesis algorithm cc proof prove cum clauses parts similar 

wh type ff type ff oex wh type oe oe may take gamma oe obtain cum oex type oe gammaoe type oey wh type oex wh type cum oex oex oey 
oex wh type wh type oe ff ff lv type ff cum oex type oe extended ff 
oex wh type wh type take oe 
rules table informal convention level variables required new 
means level variable chosen rule occurrence unique occurrence different associated occurrence rule derivation consideration 
convention precise expense considerable technical complication introducing set level variables requiring ff chosen apart set 
see careful treatment similar problem 
theorem type synthesis algorithm cc soundness gamma 
lv lv lv set new level variables 

oe gamma oex 
completeness gamma exists oe 
gamma 
oe dom oe lv 
oe decidability decidable valid context gamma term exists schematic term consistent constraint set gamma derivable 
proof soundness property proved inspection rules table 
second property consider derivation ffi gamma roughly speaking constraint set sufficient ensure valid derivation gamma oex 
precisely build derivation gamma oex induction height ffi 
induction proceeds case analysis root node ffi rules table 
interesting case root ffi instance rule app 
ffi form 
gamma wh fx gz 
gamma gamma mn cum 
definition cum oe oe oe gamma gamma oey induction hypothesis 
wh fx lemma oey theorem 
shown hypotheses rule app satisfied conclude gamma mn cum lemma oex cum required 
cases handled similarly 
completeness ffi derivation gamma induction height ffi build derivation gamma assignment oe soundness proof proceed case analysis root node ffi rules table 
consider cases rest handled similarly 
ffi instance axiom type base case gamma type type rule type gamma type type ff ff oe type ff 
root ffi instance rule app 
gamma wh fx ga 
gamma gamma mn cum induction hypothesis exist oe gamma oe dom oe lv oe lemma wh fx gz oe oe similarly exist oe gamma oe dom oe lv oe new convention lv lv disjoint oe oe oe oe oe oe oe theorem oe shown hypotheses rule app satisfied gamma wh fx gz gamma gamma mn cum lemma applies extend oe required oe cum 
decidability proof induction structure keeping mind rules table syntax directed 
base cases prop type variables trivial case variable need check declared context 
constraint set clearly satisfiable 
induction consider case application mn show decide exists schematic term consistent constraint set gamma mn exist required derivation application rule app 
induction hypothesis decidable exists gamma gamma derivable consistent 
fail derivation required form exist 
see note subderivations exist inconsistent possible choice inconsistent 
soundness theorem lemma theorem strongly normalizing 
may effectively test wh fx gx theorem exists 
conditions fail derivation required form 
may apply chan algorithm test constraint set consistent 
succeed fail choice 
remaining cases note check consistency constraint set rules gen abs ensures soundness validity context preserved 
corollary typedness type checking problems cc effectively solvable 
proof gamma valid context term 
theorem effectively decide exists schematic term consistent constraint set gamma soundness completeness exist iff typed gamma 
check valid type gamma may effectively check theorem exists theorem consistent 
soundness conversion type synthesis algorithms valid type gamma 
completeness conversion type synthesis algorithms valid type gamma 
anonymous universes section consider typedness type checking problems extension cc anonymous universe type 
extension intended model russell whitehead typical ambiguity convention 
idea proof explicit universe levels may soundly omitted provided consistent assignment levels exists 
consistent assignment results valid proof absolute values universe levels matters relation 
extending operational presentation range ambiguous terms may contain occurrences anonymous universe type 
ambiguous term understood convenient shorthand reading obtained replacing occurrence type specific universe type algorithmic point view ambiguity term resolved type checking choice reading constrained context occurrence 
example term type type anonymous universe may read standing type type type higher universe 
similarly term type type type bound variable read standing type due application type table operational presentation typing rules cc anonymous universes 
rules specify derivability conditions judgements form gamma gamma context defined section ambiguous term ordinary terms 
judgement understood expressing reading type important stress context gamma contain ambiguous terms type variable fixed put context see example rule abs table 
fundamental properties system table summarized theorem 
theorem soundness gamma reading gamma 
completeness reading gamma gamma prop gamma prop prop type type gamma type type type anon gamma type type type var gamma gamma cum gen gamma wh dom gamma gamma wh gamma fx fx agb abs gamma wh dom gamma gamma gamma fx agb app gamma wh fx ga gamma gamma qr mn cum cum table 
table operational presentation cc anonymous universes proof soundness proof induction height derivation ffi gamma case analysis rule ffi 
example suppose ffi form 
gamma wh fx ga 
gamma gamma qr mn cum induction reading reading gamma gamma result follows rule app noting mn reading qr 
remaining cases handled similarly 
completeness proof induction height derivation ffi gamma reading ambiguous term example type type ffi instance type deriving gamma type type rule anon obtain gamma type type type desired 
remaining cases follow easily induction 
type checking anonymous universes decision procedures type checking typedness problems reduction schematic type synthesis 
level variables distinct ways encode flexibility due cumulativity type term govern set possible readings ambiguous term 
second level variables regulated constraint sets set correct readings ambiguous term constrained context term occurs 
type synthesis algorithm table set rules deriving assertions form phi pair phi schematic context phi context built declarations form schematic term lv lv 
anonymous universes may occur declaration phi 
phi schematic context oe oe phi ordinary context obtained replacing prop phi prop prop type ff ff ff new type phi type type type ff ff ff new anon phi type type fi type ff ff fi ff fi new var phi phi cum gen phi wh consistent phi wh dom phi phi fx fx ugv abs phi wh consistent phi dom phi phi fx app phi wh fx gx phi phi qr uv cum cum table 
table type synthesis algorithm cc anonymous universes declaration phi declaration oex 
schematic context phi said valid iff consistent oe oe phi valid 
theorem soundness phi 
lv lv lv lv lv lv set new level variables 

oe oe phi oex oey 
completeness oe dom oe lv oe phi exists 
phi 
extends oe dom lv 

decidability decidable valid schematic context phi ambiguous term exists schematic terms constraint set phi consistent 
proof soundness proof induction height derivation ffi phi conditions level variables proved inspection rules table keeping mind conventions new level variables 
second claim consider example case ffi form 
phi 
phi phi qr uv wh fx gx cum 
oe induction oe phi oex oe phi oev oey lemma oex wh fx oex theorem oex oey app oe phi qr oev cum oev oex 
oev oe uv oev oex oe lemma exists cum oev oex desired 
completeness proof induction height derivation ffi oe phi oe suppose ffi instance anon oe phi type type type choose type fi type ff ff fi ff fi new obtain required derivation choose oe ff 
fi 
required level assignment 
easy see type type required 
suppose ffi derivation form 
oe phi 
oe phi oe phi qr mn cum wh fx ga induction exists extension oe phi similarly induction exists extension oe phi new convention lv lv lv conditions may form level assignment properties extension oe lemma exists wh fx gx theorem exists app phi qr uv cum lemma exists extending cum cum completes proof 
decidability similar proof theorem 
definitions section treat extension calculi cc cc anonymous universes admit defined identifiers 
take fundamental principle definitions defined identifier indistinguishable definition 
principle leads notion universe polymorphism defined identifier may take constrained set types determined definition 
form polymorphism associated definitions similar form polymorphism ml 
sake simplicity omit consideration local definitions introduced form expression 
expect methods described extended handle case 
definitions cc definitional context delta finite sequence declarations form definitions form subject conditions 
variable may declared defined may variable declared defined 
definitional context delta defined domain dom delta def delta dec delta def delta set defined variables delta dec delta set declared variables 
second delta delta delta delta delta delta fv dom delta 
interesting case valid contexts restriction 
third matter technical convenience require defined variables occur right hand side definition 
convention avoids certain complications proofs arising possibility definition chains identifier defined defined identifier 
order give expression definitions shall need expansion function defined induction structure terms follows delta delta delta delta delta delta fx agb fx delta delta def delta delta delta delta def delta delta delta delta assume bound variables chosen avoid conflicts necessary 
expansion extended definitional contexts follows ffl ffl delta deltaj delta delta deltaj define delta delta conversion hold iff delta delta 
definition expansion terminating relation decidable delta delta strongly normalizing case typed terms 
direct definition relation defined identifier convertible definition usual fi conversion axiom 
relation delta wh delta weak head reduction defined similarly wh see section delta delta wh added axiom table 
term delta weak head normal form shapes def delta fx agb delta weak head normal form shape lemma 
delta wh delta wh delta 
prop delta prop type type delta type type var delta delta cum delta def delta delta delta gen delta delta wh dom delta delta delta wh delta fx agb abs delta delta wh dom delta delta delta fx agb app delta delta wh fx ga delta delta delta mn cum delta table cum delta defined cum delta cum delta 
table operational presentation cc definitions 
delta wh exists delta wh delta extension cc admit definitions operational style table 
system essentially table extended rule def 
rule expresses definitions principle introduces notion universe polymorphism 
example assertion derivable system table prop prop prop type prop type prop type derivation instances distinct types prop type prop type correct types prop prop 
notice single type 
soundness operational system definitions table respect basic operational system table expressed theorem 
theorem delta deltaj delta delta 
proof proof induction height derivation ffi delta suppose ffi derivation form 
delta delta delta induction hypothesis delta delta delta fv dom delta delta delta 
conditions definitional contexts delta delta definition gamma deltaj extension delta easy see derivability closed context extension may derive deltaj delta delta desired 
suppose ffi derivation form 
delta 
delta delta mn cum delta delta wh fx ga delta conventions bound variables may assume def delta 
induction obtain deltaj delta delta deltaj delta delta lemma delta wh delta fx ga fx delta delta 
delta delta definition rule app obtain deltaj delta delta cum delta delta result follows easily definition cum delta remaining cases handled similarly 
converse theorem may proved yielding corollary decidability system definitions 
prefer give direct presentation type synthesis algorithm avoids unnecessary expansion definitions 
idea adapt methods associate definition type scheme summarizing set possible types definiens 
suitable assumptions associated type scheme obtain sound complete type synthesis algorithm cc definitions 
generic definitional context theta defined similarly definitional context definitions form schematic term constraint set lv lv 
abuse notation theta situations definitional context expected convention stored schematic type information ignored 
important stress distinction write theta underlying definitional context theta 
delta conversion delta weak head reduction extended schematic terms obvious way pattern section 
definitional context delta valid iff delta delta delta exists delta delta wh delta delta delta exists delta types declarations types definiens definition formed 
generic definitional context theta valid iff theta valid theta theta theta constraint set satisfiable theta oex oe instance instances valid types 
conversely theta principal iff valid theta theta theta theta exists oe oex type scheme capture valid types 
worth remarking conditions naturally preserved extension system local definitions 
type synthesis algorithm cc definitions table 
rule def operation mapping level variables set new level variables appear derivation 
operation extended schematic terms constraint sets obvious way 
properties type synthesis algorithm give theorem theorem soundness theta valid definitional context theta 
lv lv lv set new level variables 

oe theta oex 
completeness theta principal definitional context theta exists oe 
theta 
oe dom oe lv 
oex 
decidability decidable valid definitional context theta term exists schematic term consistent constraint set theta proof proof essentially theorem assumptions theta suffice defined identifiers 
prop theta prop type ff ff ff new type theta type type ff ff ff new var theta theta cum theta def theta theta lv gen theta theta wh dom theta consistent theta theta wh theta fx agb abs theta theta wh dom theta consistent theta theta fx app theta theta wh fx gx theta theta theta mn cum theta assigns new level variables level variables table cum theta defined cum theta cum theta 
table type synthesis algorithm cc definitions definitions anonymous universes final extension cc shall consider combination universe polymorphism typical ambiguity 
seen definitions introduce form polymorphism induced cumulativity universe hierarchy 
ambiguous definitions allow flexibility definiens re read definition 
example defined term type prop type formed type case ambiguous definition receives reading appropriate context 
terms occur subterms single term principle implies defined identifiers polymorphic occurrence corresponds distinct reading definition 
interesting example self application polymorphic identity function 
definition type term ft typed instances receive distinct readings assigned distinct types 
important realize notion polymorphism extend declarations declaration assigns single underdetermined type referring back polymorphic identity example declared ft ft typed reading type term typed cc considerations formalized operational presentation table 
rules table essentially combination tables 
note type variables receive fixed reading erard huet example ad prop delta prop prop type ad type delta type type type ad anon delta type type type ad var delta delta cum ad def delta delta delta ad gen delta wh dom delta delta wh delta fx fx agb ad abs delta wh dom delta delta delta fx agb ad app delta wh fx ga delta delta qr mn cum cum table table operational presentation anonymous universes definitions added context declarations unambiguous 
definitions hand may ambiguous receive fresh reading 
order ensure declared identifiers remain unambiguous presence definitions require defined identifiers occur type declared variable 
restriction preserved rules ad gen ad abs reading term defined identifiers eliminated 
soundness system respect operational presentation anonymous universes table expressed theorem 
theorem delta deltaj delta proof proof induction height derivation ffi delta interesting case ffi form 
delta delta delta induction delta delta clearly delta delta extension delta delta delta deltaj delta required 
remaining cases similar 
converse theorem proved decidability corollary 
prefer give direct presentation type synthesis algorithm system ambiguous terms definitions 
schematic generic definitional context sgd context pair psi psi context built declarations form lv lv definitions form lv lv lv lv lv 
note anonymous universe occur schematic terms foregoing unambiguous 
conditions regarding formedness definitional contexts apply sgd contexts 
type synthesis algorithm anonymous universes definitions table 
state soundness completeness type synthesis algorithm necessary introduce additional terminology 
schematic ad prop psi prop prop type ff ff ff new ad type psi type type type ff ff ff new ad anon psi type type fi type ff ff fi ff fi new ad var psi psi cum ad def psi psi lv ad gen psi wh consistent psi wh dom psi psi fx fx ugv ad abs psi wh consistent psi dom psi psi fx ad app psi wh fx gx psi psi qr uv cum cum defined table defined table 
table algorithm anonymous universes definitions term denote ambiguous term resulting replacing occurrences type ff anonymous universe type 
psi sgd context oe oe psi denotes definitional context obtained 
replacing declaration declaration oex 
replacing definition definition idea constraint set governs possible readings declarations psi definition level variables result schematic reading ambiguous term erased passing underlying definitional context 
type information associated definition simply erased 
sgd context psi valid iff satisfiable oe 
psi psi psi oe psi oex oex wh 
psi psi psi variants lv oeg satisfiable extension oe oe psi intuitively definition constraint set govern set possible readings set possible types reading 
may mention variables declared earlier context type involve level variables constraint set conversely psi principal iff valid oe dom oe lv psi psi psi oe psi variant lv exists extension oe idea possible reading possible type reading obtainable instance schematic definition stored type information 
theorem soundness psi valid sgd context 
psi 
lv lv lv lv lv set new level variables 

oe oe psi oex oey 
completeness psi principal sgd context 
oe dom oe lv oe psi exists 
psi 
extends oe dom lv 

decidability decidable valid sgd context psi ambiguous term exist schematic terms constraint set psi consistent 
proof soundness proof induction height derivation ffi psi consider rule ad def 
suppose ffi derivation psi psi lv writing psi psi psi lv oe validity psi oe psi oex oey oe psi oe psi oe psi ad def oe psi oex oey desired 
completeness proof induction height derivation ffi oe psi conditions stated theorem 
interesting case ffi form 
oe psi oe psi psi psi psi ad def psi lv 
psi exists extending oe desired 
decidability similar proof theorem 
related huet unpublished manuscript independently developed algorithm handling universes calculus constructions 
approach drop assumption universes form linearly ordered cumulative hierarchy indexed natural numbers consider family calculi founded partial ordering universes 
input language correspondingly restricted specific universes disallowed anonymous universe type may 
principal advantage approach considered consistency checking algorithm significantly efficient chan algorithm reducing acyclicity check dependency graph universe levels 
efficiency considerations aside approach equivalent restricted language huet considers countable founded partial ordering embedded countable linear ordering 
method advantage example easily restrict type checker terms check say universe fixed bound 
calibrating strength proof theory needed formalize argument 
local constraints imposed proof simply specific anonymous universe 
response observation cumulativity entails flexibility type term determined shape type see discussion theorem luo developed alternative formulation cumulative hierarchy universes called fully cumulative eliminates need schematic type expressions basic type checking algorithm cc idea introduce partial ordering type expressions property type form fx delta delta delta fx ordering type form fx delta delta delta fx 
addition prop taken type effect type checking algorithm 
types term required form upward closed set ordering 
way need schematic terms constraint sets basic type synthesis algorithm replaced complex application rule 
course derivation system valid derivation extended sense converse fails 
resulting system consistent decidable demonstrated 
stressed methods handling definitions anonymous universes extend directly luo calculus 
implementation definitions anonymous universes luo calculus significantly efficient cc constraints generated connection typical ambiguity universe polymorphism part basic type checking algorithm 
know machine implementations cc erard huet coworkers developing implementation cc supports huet variant typical ambiguity discussed 
second author implemented algorithms lego proof checker 
lego supports type theories including cc luo variation extended typical ambiguity universe polymorphism 
henk barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland revised edition 
rod burstall butler lampson 
kernel language data types modules 
kahn pages 
luca cardelli 
phase distinctions type theory 
unpublished manuscript 
luca cardelli 
polymorphic calculus type type 
technical report dec src 
tat hung chan 
algorithm checking pl cv arithmetical inferences 
technical report computer science department cornell university ithaca new york 
church 
formulation simple theory types 
journal symbolic logic 
dominique cl ement despeyroux thierry despeyroux laurent gilles kahn 
natural semantics computer 
technical report rr inria sophia antipolis france june 
robert constable daniel 
report type theory programming logic pl cv 
logics programs volume lecture notes computer science 
springer verlag 
robert constable daniel 
type theory pl cv 
acm transactions programming languages systems january 
robert constable implementing mathematics nuprl proof development system 
prentice hall 
thierry coquand 
une th eorie des constructions 
phd thesis universit paris vii january 
thierry coquand 
analysis girard paradox 
symposium logic computer science pages boston june 
thierry coquand gilles dowek erard huet christine 
calculus constructions documentation user guide 
technical report projet inria ens july 
thierry coquand erard huet 
constructions higher order proof system mechanizing mathematics 
buchberger editor european conference computer algebra volume lecture notes computer science pages 
springer verlag 
luis damas robin milner 
principal type schemes functional programs 
ninth acm symposium principles programming languages pages 
nicolas de bruijn 
survey project automath 
seldin hindley pages 
thomas 
categorical semantics constructions 
third symposium logic computer science pages edinburgh july 
paola giannini ronchi della rocca 
characterization typings polymorphic type discipline 
third symposium logic computer science pages july 
robert harper furio honsell gordon plotkin 
framework defining logics 
second symposium logic computer science pages ithaca new york june 
robert harper furio honsell gordon plotkin 
framework defining logics 
technical report cmu cs school computer science carnegie mellon university january 
revised expanded version submitted publication 
robert harper robin milner mads tofte 
type discipline program modules 
tapsoft volume lecture notes computer science 
springer verlag march 
robert harper john mitchell eugenio moggi 
higher order modules phase distinction 
appear popl 
james hook douglas howe 
impredicative strong existential equivalent type type 
technical report tr cornell university ithaca new york 
william howard 
formulas types notion construction 
seldin hindley pages 
douglas howe 
computational behavior girard paradox 
second symposium logic computer science pages ithaca new york june 
erard huet 
extending calculus constructions type type 
unpublished manuscript april 
martin hyland andrew pitts 
theory constructions categorical semantics topos theoretic models 
proceedings boulder conference categories computer science 
appear 
gilles kahn david macqueen gordon plotkin editors 
semantics data types volume lecture notes computer science 
springer verlag june 
luo 
higher order calculus theory abstraction 
technical report ecs lfcs laboratory foundations computer science edinburgh university july 
luo 
cc ae metatheory 
technical report ecs lfcs laboratory foundations computer science edinburgh university july 
luo 
ecc extended calculus constructions 
fourth symposium logic computer science asilomar california june 
luo robert pollack paul taylor 
lego preliminary user manual 
technical report lfcs tn laboratory foundations computer science edinburgh university october 
david macqueen 
dependent types express modular structure 
thirteenth acm symposium principles programming languages 
martin lof 
theory types 
unpublished manuscript 
martin lof 
intuitionistic theory types predicative part 
rose shepherdson editors logic colloquium volume studies logic foundations mathematics pages 
north holland 
martin lof 
constructive mathematics computer programming 
sixth international congress logic methodology philosophy science pages 
north holland 
martin lof 
intuitionistic type theory volume studies proof theory 
bibliopolis 
albert meyer mark reinhold 
type type preliminary report 
thirteenth acm symposium principles programming languages 
robin milner 
theory type polymorphism programming languages 
journal computer system sciences 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
john mitchell robert harper 
essence ml 
fifteenth acm symposium principles programming languages san diego california january 
john mitchell 
type inference type containment 
kahn pages 
john mitchell gordon plotkin 
types existential type 
twelfth acm symposium principles programming languages 
bertrand russell 
mathematical logic theory types 
american journal mathematics 
seldin hindley editors 
curry essays combinatory logic lambda calculus formalism 
academic press 
van 
language theory automath 
phd thesis technical university eindhoven eindhoven netherlands 
alfred north whitehead bertrand russell 
principia mathematica volume 
cambridge university press 

