
database complete proof procedure sld resolution 
intl 
conference logic programming 

recursive query processing power logic 
theoretical computer science 
ramakrishnan 
magic templates approach logic programs 
journal logic programming 
ramakrishnan srivastava sudarshan 
controlling search bottom evaluation 
joint intl 
conference symposium logic programming pages 
ramesh chen 
portable method integrating slg resolution prolog systems 
intl 
logic programming symposium november 
ross 
procedural semantics founded negation logic programs 
acm sigact sigmod sigart symposium principles database systems pages 
ross 
semantics deductive databases 
phd thesis department computer science stanford university august 
sagonas swift warren 
xsb efficient deductive database engine 
acm sigmod conference management data pages 
seki 
power alexander templates 
acm sigact sigmod sigart symposium principles database systems pages march 
seki itoh 
query evaluation method stratified programs extended cwa 
joint intl 
conference symposium logic programming pages 
stuckey sudarshan 
founded ordered search 
proceedings th conference foundations software technology theoretical computer science 
lncs 
stuckey 
constructive negation constraint logic programming 
proceedings th ieee annual symposium logic computer science pages 
tamaki sato 
old resolution tabulation 
intl 
conference logic programming pages 
van emden kowalski 
semantics predicate logic programming language 
journal acm october 
van gelder 
negations failure tight derivations general logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann publishers los altos ca 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm july 
vardi 
complexity relational query languages 
acm symposium theory computing pages may 
david kemp peter stuckey divesh srivastava 
magic sets bottom evaluation founded models 
intl 
logic programming symposium pages 
david kemp peter stuckey divesh srivastava 
query restricted bottom evaluation normal logic programs 
joint intl 
conference symposium logic programming pages 
kemp topor 
completeness top query evaluation procedure stratified databases 
joint intl 
conference symposium logic programming pages 
komorowski 
programming methodology founded partial deduction 
proceedings european conference artificial intelligence 
lloyd 
foundations logic programming 
springer verlag new york second edition 
lloyd shepherdson 
partial evaluation logic programming 
journal logic programming 
marek truszczynski 
autoepistemic logic 
journal acm 
martelli montanari 
efficient unification algorithm 
acm transactions programming languages systems 
morishita 
alternating fixpoint tailored magic programs 
proceedings deductive database workshop joint international conference symposium logic programming 
przymusinska przymusinski 
weakly perfect model semantics logic programs 
kowalski bowen editors joint intl 
conference symposium logic programming pages 
przymusinski 
declarative semantics deductive databases logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann publishers los altos ca 
przymusinski 
logic program natural stratification iterated fixed point model 
acm sigact sigmod sigart symposium principles database systems pages 
przymusinski 
constructive negation logic programming 
north american conference logic programming october 
przymusinski :10.1.1.54.8201
declarative procedural semantics logic programs 
journal automated reasoning 
przymusinski 
founded semantics coincides valued stable semantics 
fundamenta informaticae 
bancilhon maier sagiv ullman 
magic sets strange ways implement logic programs 
acm sigact sigmod sigart symposium principles database systems pages march 
beeri ramakrishnan 
power magic 
acm sigact symposium principles database systems pages san diego ca march 
bidoit 
evaluation procedure logic programs 
intl 
conference database theory pages 
bol 
tabulated resolution founded semantics 
intl 
logic programming symposium october 
bry 
query evaluation recursive databases bottom top reconciled 
intl 
conference deductive object oriented databases december 
chan 
constructive negation completed database 
robert kowalski kenneth bowen editors proc 
th int 
conf 
symp 
logic programming pages 
chen adams 
constructive negation general logic programs 
technical report cse department computer science engineering southern methodist university april 
chen swift warren 
efficient top computation queries founded semantics 
journal logic programming 
appear 
chen warren 
computation stable models integration logical query processing 
ieee transactions knowledge data engineering 
appear 
chen warren 
slg system august 
available anonymous ftp seas smu edu cs sunysb edu 
chen warren 
goal oriented approach computing founded semantics 
joint intl 
conference symposium logic programming november 
available smu technical report cse 
clark 
negation failure 
gallaire minker editors logic databases pages 
plenum new york 
dietrich warren 
extension tables memo relations logic programming 
technical report department computer science suny stony brook 
gelfond lifschitz :10.1.1.24.6050:10.1.1.24.6050
stable model semantics logic programming 
kowalski bowen editors joint intl 
conference symposium logic programming pages 
implement control strategy needed slg resolution 
efficient meta interpreter portable different prolog systems 
implementations support integration slg resolution prolog computation 
distinction predicates solved slg resolution solved prolog 
ordinary prolog computation incorporated slg resolution simple manner overhead 
direction predicates solved slg resolution called prolog predicates 
slg resolution serves foundation practical framework computing wellfounded semantics logic programs 
theoretically number fundamental transformations identified cleanly separating logical issues procedural information 
restricted versions slg resolution developed programs limited uses negation including definite locally stratified modularly stratified programs 
programs pay overhead transformations needed 
sheds light role transformation plays 
slg resolution preserves valued stable models including founded partial model special case 
terminates programs size property 
slg resolution guarantees polynomial time data complexity founded negation function free programs 
enhanced processing answers subgoals relevant query founded semantics deliver answers specific valued stable models 
practically slg resolution upward compatible existing prolog systems 
facilitates integration slg resolution prolog applications 
importantly prolog compiler technology adapted efficient implementation slg resolution 
firmly believe slg resolution important impact theory practice logic computational systems 
termination properties stratified programs strategy deductive database query processing ability integrated seamlessly prolog evaluation logic programming strategy polynomial data complexity handling programs strategy nonmonotonic reasoning knowledge systems 
apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann publishers los altos ca 
apt van emden 
contributions theory logic programming 
journal acm july 
port ramamohanarao 
efficient bottom computation queries stratified databases 
journal logic programming 
resolution 
truth value ground negative literal decided case loops negation delaying allows slg resolution proceed solve remaining literals rule body 
certain sense achieves effect negatively parallel computation rule global sls resolution imposing condition computation rule 
second maintaining delayed literals explicitly simplifying derivation steps slg resolution repeated 
slg keeps delayed literals answers subgoals undefined founded semantics 
allows query evaluation respect valued stable models processing answers founded semantics 
decision slg resolution propagate negative delayed literals bodies answers necessary order guarantee polynomial data complexity slg resolution function free programs 
hand leads creation positive delayed literals positive return need answer completion delete certain conditions answers positive delayed literals bodies 
transformation answer completion expensive operation may require traversing answers subgoals 
interesting topic investigate conditions answer completion avoided minimized 
implementations slg resolution important aspect slg resolution availability implementations performance 
left right computation rule 
implementation prolog meta interpreter 
major implementation issue detect subgoals completely evaluated completion potential loops negation delaying 
needed delaying avoided ground negative literals solved negative return 
require dependency information subgoals system 
turns delaying simplification necessary compute precisely loops negation system expensive run time 
developed efficient approximate algorithm incremental maintenance dependency information subgoals 
top framework slg resolution leads stack subgoals sequence encountered lends naturally incremental maintenance dependencies subgoals 
inspecting dependency information single subgoal possible determine subgoals top stack completely evaluated possibly involved loops negation 
performance meta interpreter implementation competitive handle arbitrary negation 
second implementation prolog compiler called xsb 
xsb modifies warren machine wam prolog implement slg resolution restricted modularly stratified programs 
advantage wam technology efficient indexing tables subgoals answers wam level xsb demonstrated impressive performance query evaluation deductive databases 
implementation uses source program transformation tabling primitives external prolog wam 
program transformed program inserting tabling primitives prolog execution yields slg resolution 
tabling primitives independent underlying prolog wam 
maintain tables subgoals answers program method tends magic facts true means subgoals evaluated necessary 
alternating fixpoint tailored magic sets alleviates problem generates irrelevant magic facts initial stages fixpoint computation 
extension ordered search compute founded semantics called founded ordered search developed stuckey sudarshan 
slg resolution wellfounded ordered search support goal oriented query evaluation allow arbitrary computation rule 
main difference treatment negative literals possibly involved loops negation 
implementation slg resolution checks potential loops negation may delay ground negative literals necessary 
avoids repeated computation keeping delayed literals explicitly simplifying 
contrast wellfounded ordered search maintains precise dependency information subgoals essentially run time re organization stack subgoals able detect genuine loops negation 
portions programs involve loops negation uses alternating fixpoint computation may repeat certain steps computation 
method top tabulated resolution founded semantics 
slg resolution uses transformations construct search forest corresponds notion system subgoals 
majors differences slg resolution tabulated resolution 
slg resolution rule subgoal selected negative literal solved negative return delaying disposed possibly replaced rule 
words child due selection delayed selected computation rule 
delayed negative literal simplified truth value known 
tabulated resolution node search forest selected ground negative literal may child nodes 
derived extension assumption essentially replaced undefined truth value derived extension negation failure known successful failed solved negation failure 
result conjunction remaining literals body may evaluated twice 
difference slg resolution tabulated resolution treatment non ground negative literals 
slg resolution selects non ground negative literal tries solve solved negation failure 
contrast tabulated resolution may select non ground negative literal twice initially selected non ground negative literal ground 
addition answer may contain non ground negative literals body 
non ground negative literals propagated answer solve selected atom node 
small variation example show propagation non ground negative literals may cause exponential number distinct conditional answers subgoal 
polynomial data complexity founded semantics function free programs preserved tabulated resolution 
unique feature slg resolution handling ground negative literals may involved loops delaying simplification answer completion 
advantages 
delaying provides slg resolution freedom arbitrary computation rule compromising soundness search space completeness slg different strategy implemented version xsb computes answers possible subgoal answers returned positive return 
strategy close bottom set time computation ordered search 
different implementations may choose different search strategies specific applications slg resolution offers flexibility choices 
related sls resolution early operational procedure founded semantics 
incorporate tabling mechanism 
selected atom solved resolution program rules selected ground negative literal solved computing corresponding positive literal fixpoint 
tabling serves ideal top procedural semantics may go infinite loops function free programs 
tabling requires positive negatively parallel computation rule order guarantee search space completeness non floundering queries 
positive literals selected negative ones negative literals remain rule body negative literals selected evaluated 
required evaluation ground negative literal may go infinite loop evaluation may fail 

resolution represent simple modification sls resolution tabling handle loops negation 
maintaining negative context subgoal detect loops negation treat ground negative literal involved loop undefined avoid non termination 
answer consists atom truth value negative contexts prevents full sharing answers different negative contexts 
worst case subgoal may evaluated exponential number distinct negative contexts 
methods query evaluation developed left right modularly stratified programs 
extension sls resolution called sls ross extension supplementary magic templates called ordered search 
maintain subgoal dependency information check subgoals completely evaluated 
ross showed sls procedure complexity supplementary magic rewriting 
interesting aspect bottom computation magic templates checking repeated subgoals variant subsumption checking 
subgoals binding patterns treated 
program query example subgoals path path path path binding pattern path different binding pattern 
subgoals binding pattern share table answers 
programs function symbols argument considered bounded variables argument bounded 
subgoals may treated calls binding pattern obtained binding respectively subsumes 
general programs magic sets transformation preserve wellfounded semantics 
proposed solutions doubled program computing definitely true facts computing definitely false facts 
separate computation classes facts may cause redundant inferences sets definitely false facts decreasing computed increasing manner 
doubled subsumption checking subgoals repeated computation fully avoided general specific subgoal say encountered general 
computation rule search strategies slg resolution allows arbitrary computation rule selecting literal rule body 
finite program arbitrary fixed computation rule atomic query possible non ground negative literal may selected rule body evaluation respect situation may lead floundering 
slg resolution able solve answer head empty body subgoal completed answers 
mechanisms constructive negation non ground negative literals solved general 
slg resolution final system respect may completed may contain active rules selected non ground negative literal 
may reduce floundering computation rules select positive literals negative ones 
may avoid floundering imposing conditions programs 
finite program range restricted rule program variables rule head occur rule body variable occurs negative literal rule body occur positive literal rule body 
computation rule selects positive literals negative ones floundering avoided range restricted programs 
slg resolution avoids imposing restrictions computation rule implementation may programs respect queries may evaluated 
main reason implementation slg resolution free choose computation rule left right computation rule prolog systems 
left right modularly stratified programs example left right computation rule guarantee literals predicates lower components selected 
may may consistent requirements positive literals selected negative ones 
programmers knowledge computation rule implementation control floundering write efficient programs 
negative literals may guard conditions determine expensive computation rest rule body evaluated 
slg resolution allows arbitrary strategy selecting transformation apply multiple transformations applicable system 
words definition slg resolution dictate particular strategy 
implementations greedy strategy ffl new answer subgoal created positive return applied rule system selected atom ffl active rule subgoal created selected atom positive return applied existing answer ffl new subgoal encountered initial rules generated new subgoal transformed :10.1.1.48.4048
greedy strategy close top tuple time computation 
stratified programs put sequential order literals lower components solved 
static ordering possible weakly stratified programs level component literal belongs depends variable bindings run time 
full slg resolution needed query evaluation non ground weakly stratified programs 
discussion section discusses decisions design slg resolution variant checking subgoals answers arbitrary computation rule 
compare related experiences implementations slg resolution developed 
variant versus subsumption checking guarantee termination slg resolution checks repeated subgoals repeated answers 
repeated subgoals solved answers previous calls repeated answers returned solve selected atom rule 
slg resolution variant checking detect repeated subgoals repeated answers 
subgoals identical variants 
answers subgoal head atoms variants positive return solve selected atom rule 
approach subsumption checking subgoals answers 
subgoal instance previous subgoal solved answers similarly answer subsumed previous general answer kept 
choice variant checking slg resolution motivated advantages 
variant checking allows easier efficient implementation indexing tables subgoals answers 
ground representation variables variant checking atoms reduced equality ground atoms 
efficient table lookup operation crucial efficiency implementation slg resolution 
advantage variant checking subgoals prolog style meta programming builtin predicates var supported 
main disadvantage variant checking repeated computation subgoals subsume 
example consider simple program edge edge edge edge path edge path edge path suppose query path evaluated left right computation rule 
set subgoals path evaluated path path path path clearly answers path include subgoals path 
modularly stratified 
modularly stratified programs transformations locally stratified programs certain computation rule assumed 
program 
say predicate calls predicate rule occurs head occurs rule body 
dg corresponding calling graph set predicates partitioned equivalence classes strongly connected components dg 
program broken complete components partition predicates 
natural partial ordering oe components oe predicates call directly indirectly predicates definition modular stratification finite program oe partial ordering complete components modularly stratified component ffl total founded model union components oe ffl quotient modulo locally stratified 
query evaluation modularly stratified programs ensure literals predicates defined lower component solved 
arbitrary fixed computation rule 
consider query respect program computation rule selects infinite negative loop case delaying transformation applied 
avoid delaying need computation rule selects literals lower components 
ross introduced notion left right modularly stratified programs 
modularly stratified program converted left right modularly stratified program putting body rule literals lower components literals component head rule 
left right modularly stratified program left right computation rule atomic query 
transformations locally stratified programs necessary sufficient constructing slg derivations respect induction level components levels ground atoms component shown ground subgoals completed succeed fail corresponding negative literal solved negative return 
results section specialized left right modularly stratified programs left right computation rule 
modularly stratified programs weakly stratified converse true 
major difference modularly stratified weakly stratified programs notion components 
modularly stratified programs components defined terms dependency relationship predicates weakly stratified programs components defined terms dependency relationship ground atoms 
result query evaluated respect finite non ground program literals rule bodies modularly locally stratified programs stratified programs programs negation recursion 
przymusinski extended class stratified programs wider class called locally stratified programs introduced perfect model semantics 
infinite recursion negation locally stratified programs 
perfect herbrand model locally stratified program coincides founded partial model 
finite program 
locally stratified assignment ordinal levels ground atoms ground atom appears negatively body instantiated rule head ground rule strictly higher level ground atom appears positively body instantiated rule atom head level 
due stratification selected ground negative literal subgoal completed needs solved negative return 
founded partial model stratified program valued succeeds fails completed 
delaying needed 
summary transformations necessary sufficient locally stratified programs ffl new subgoal introducing new subgoal resolution rules program ffl positive return solving selected atom rule answer empty body ffl negative return solving selected ground negative literal rule positive counterpart succeeds fails ffl completion active rules subgoals completely evaluated 
induction strata ground subgoals shown ground subgoals completed succeed fail corresponding negative literal solved negative return 
results section specialized locally stratified programs corresponding perfect herbrand model 
extensions oldt sld developed stratified programs 
restriction slg resolution locally stratified programs differs single system subgoals maintained guarantees subgoal evaluated 
modularly stratified programs ross studied general class programs evaluated subgoal time fashion called modularly stratified programs 
consider known game playing program win move win :10.1.1.24.6050:10.1.1.24.6050
winning position move winning position 
program locally stratified general 
move acyclic program practice efficient incremental algorithms developed detect subgoals completely evaluated possibly involved loops negation constant amount time 
believe freedom choosing arbitrary computation rule choosing arbitrary strategy selecting transformations slg resolution offers maximum flexibility practical implementations 
restricted slg resolution slg resolution provides general framework effective query evaluation logic programs respect founded partial model 
section show slg resolution simplified restricted classes programs compromising soundness search space completeness 
particular consider definite programs locally stratified programs modularly stratified programs 
program classes founded partial model valued stable model program 
definite programs definite programs programs negation 
founded partial model definite program coincides herbrand model 
transformation deals negative literals longer needed 
negation delayed literals introduced 
rules system just rules 
transformations needed sufficient definite programs ffl new subgoal introducing new subgoal resolution rules program ffl positive return solving selected atom rule answer empty body ffl completion active rules subgoals completely evaluated 
results section specialized definite programs corresponding herbrand model semantics 
completion affect answers subgoals applications completion definite programs postponed step 
necessary answers generated 
new subgoal positive return really necessary definite programs 
restriction slg resolution definite programs results query evaluation strategy equivalent oldt sld modulo differences variant checking subsumption checking subgoals 
practice subgoal completed need choice point potentially new answers subgoal 
active rules selected atom completed disposed answers positive return solve selected atom 
completion may allow early disposal active rules 
similarly takes time logn insert answer check inserted answer head atom previous answer table 
edb pe finite set ground facts literals edb predicates solved directly subgoals edb predicates maintained 
subgoals refer subgoals idb predicates 
application new subgoal takes time logn checking subgoal new constant amount time construct initial rules subgoal fixed 
application positive return negative return carried datadriven manner 
rule generated selected atom positive return performed existing answers answer derived head atom distinct previous answers positive return performed active rules selected atom new answer 
time application positive return negative return logn include time check newly generated answer subgoal head atom distinct previous answers 
similarly application delaying logn 
definition transformation simplification applied subgoals completed 
done data driven manner delayed literal successful failed 
time application simplification constant 
assume completion postponed transformation applied subgoals completed 
linear traversal active rules subgoals completed determine subgoals completely evaluated ffl subgoal active rule selected negative literal ffl subgoal active rule selected atom subgoal completely evaluated 
complement set subgoals completely evaluated respect set subgoals completed gives largest possible set subgoals completely evaluated 
time application completion 
total number applications completion total time spent completion theta 
assume answer completion postponed transformation applicable 
linear traversal answers subgoals completed determine pairs head answer subgoal supported answers completed subgoal heads supported deleted answer completion 
time application answer completion 
total number applications answer completion total number distinct subgoals times total number distinct head atoms answers subgoal 
total time spent answer completion theta 
summary time constructing final system thetak thetak theta jp theta pi polynomial size pe notice pe fixed jp linear size pe pi constant rule pe ground fact empty body 
addition polynomial size pe ffl selected atom ffl 
resulting rules generated directly ffl number delayed literals literal delayed ffl number literals delayed delayed literal rule corresponding ordinal sequence disposed 
size system bounded theta jp theta pi 
transformation increases size system final system constructed theta jp theta pi steps 
framework deductive databases query represented intensional database idb finite function free program 
predicates occur rule bodies rule heads extensional database edb predicates 
edb represented finite set ground atoms edb predicates 
edb pe form program pe viewed function maps pe founded partial model wf pe 
van gelder shown function free programs computing founded semantics polynomial time data complexity 
notion data complexity defined vardi complexity evaluating database query query fixed database regarded input 
definition data complexity idb defined computational complexity deciding answer ground atomic query function size edb context founded semantics means deciding ground atom positive founded partial model 
theorem idb arbitrary finite function free program pe finite edb pe arbitrary fixed computation rule ground atomic query 
final system constructed polynomial time size edb 
proof function free programs atomic queries size argument 
denotes number distinct function free atoms variants 
number predicates arities fixed polynomial size pe theorem final system constructed theta jp theta pi steps 
theta jp theta pi show total time constructing polynomial size pe assume global table subgoals answers maintained 
answers subgoal atom head grouped positive return 
time searching inserting subgoal logn 
theorem finite program arbitrary fixed computation rule atomic query final system completed 
instance subgoal true wf answer head instance body empty 
proof recall herbrand universe hu constructed language lf contains function symbols addition lf contains unary function constant occur distinct variables ground atom obtained replacing variable term 
true wf true wf 
theorem answer subgoal head instance body empty 
occur slg derivation head instance 
termination data complexity slg resolution terminates function free programs generally programs bounded term size property 
definition adapted difference variable treated size due variant checking subgoals 
definition bounded term size property size term defined recursively follows ffl size variable constant 
ffl size compound term plus sum sizes arguments 
finite program bounded term size property function computable computation rule atomic query arguments sizes exceed atom rule subgoal argument size exceeds system slg derivation respect definition finite program 
jp denotes number rules pi denotes maximum number literals body rule arbitrary positive integer 
denotes number atoms predicates variants arguments exceed size 
theorem termination finite program bounded term size property arbitrary fixed computation rule atomic query 
final system constructed theta jp theta pi transformation steps 
proof maximum size arguments system slg derivation definition atom rule subgoal argument size exceeds function 
number distinct subgoals bounded 
subgoal length initial sequence introduced new subgoal bounded jp rule subgoal disposed 
number literals body bounded pi due fact delayed literals answer propagated positive return 
number rules generated directly ffl wf symmetric exists instance wf ffl wf symmetric instance wf 
interpretation wf wf 
symmetric interpretation arguments 
theorem says set answers final system preserves founded partial model far instances subgoals relevant query concerned 
theorem establishes truth values ground instances subgoals founded partial model original program determined simply looking syntactic format set answers derivation 
theorem finite program arbitrary fixed computation rule atomic query final system completed 
subgoal ground instance wf instance head answer empty body wf instance head answer proof interpretation theorem suffices prove wf 
clearly wf definition definition 
direction suffices show st lpm 
final system transformation applied 
negative literal occurs simplified simplification answer completion applied subgoal atom occurs head answer supported lpm 
structural induction definition supported ffl ground instance answer head empty body ffl ground instance answers head answers head delayed literals 
st 
theorem wf slg resolution produces answers queries may contain variables 
theorem shows universal closure instance subgoal true wellfounded partial model slg resolution able derive answer general provided completed final system constructed 
notice symmetric interpretation lpm 
theorem symmetric 
show st independent second atom symmetric third atom verified construction simpl usage valued stable model simpl definition lpm independent lpm implies st 
furthermore symmetric holds 
computation founded partial model primary purpose slg resolution compute answers query respect founded partial model finite program 
final completed system derived atomic query respect finite program show wf coincides wf far ground instances subgoals concerned 
ground instance subgoal true wf instance head answer empty body false wf instance head answer words truth values ground instances subgoals relevant query determined directly answers derivation 
show slg resolution satisfies general answer property sense instance atom true founded partial model answer head instance body empty 
theorem finite program arbitrary fixed computation rule atomic query final system completed 
exists symmetric interpretation wf wf 
proof theorem wf st 
theorem exists symmetric interpretation wf st 
theorem wf subgoal ground instance ffl wf instance symmetric wf ffl wf instance instance symmetric wf 
direction wf st 
theorem exists symmetric interpretation wf st 
theorem wf subgoal ground instance concludes proof part lemma show part lemma holds 
st 
show exists symmetric interpretation theorem wf theorem wf 
independent wf wf wf 
wf interpretation ffl os os fb jb os ground subgoal sg ffl neg neg fb jb neg ground subgoal sg 
existence ensured fact wf 
notice partially symmetric lpm 
theorem symmetric 
independent lpm 
notice ground subgoal 
lpm 
st partition herbrand universe hb set atoms hb ground instance subgoal hb gamma construct symmetric interpretation follows ffl ffl ground instance subgoal atoms truth values chosen follows 
construct program simpl herbrand instantiation ffl deleting rule head atom ffl deleting rule body contains positive literal ffl deleting rule body contains negative literal ffl replacing positive literal body rule ffl replacing negative literal body rule consider ground atom simpl new propositional symbol arbitrary valued stable model simpl viewed propositional program 
atom ffl occurs simpl ffl ffl atom body head finite exists fi rule rule fi und lpm fi os lpm fi 
inductive step induction holds lpm fi symmetric inductive hypothesis 
theorem shows final system derived atomic query finite program arbitrary fixed computation rule lemma completed subgoal completed answers floundered subgoal active rule selected non ground negative literal 
theorem shows theorem valued stable model preserved completed system reached 
discuss section floundering may avoided imposing certain conditions program computation rule 
theorem finite program arbitrary fixed computation rule atomic query final system completed 
st exists symmetric interpretation st st exists symmetric interpretation st 
proof final system completed rules subgoals disposed answers 
independent 
theorem symmetric system 
st 
theorem wf theorem wf 
independent wf wf wf 
wf construct partially symmetric interpretation follows ffl ffl ground subgoal ffl existence ensured fact wf wf notice lpm 
theorem symmetric system symmetric 
independent lpm lpm jj 
st partially symmetric ground subgoal 
completed negative literals occurring form lpm jj lpm st 
selected atom oe obtained ground instance form oe lef oe right ground instance assumption und os 
inductive hypothesis hold instance completed head atom answer disposed 
definition sequence fi contain element form hff rule lemma exists instance oe lef oe right oe lef oe right rule fi number positive literals body active rule bounded maximum number literals body rule finite 
repeatedly applying argument oe oe lef oe right eventually obtain instance hold concludes induction concludes proof case completion 
inductive case limit ordinal 
lpm 
subgoal completed completed fi fi remains completed fi 
completed fi transformations applied simplification answer completion delete answers deletes successful delayed literals body answer properties hold ffl answers disposed obtained fi repeatedly applying simplification answer completion 
ffl second argument case successor ordinal lpm lpm coincide ground literals form fi subgoal completed fi coincides lpm fi literals form subgoal completed instance ground instance subgoal completed arbitrary ground instance lemma implies instance instance direction argument case positive return lemma induction additional observation 
und os corresponding derivation represented finite sequence rules ffl head second arbitrary subgoal completed arbitrary ground instance lemma implies instance instance direction recall show induction subgoal ground instance und instance und os os instance os 
basis case trivial ground atom false 
inductive case consider rule form oe instance lemma rule oe gamma oe fi 
definition fi literal fi form subgoal fi instance ground instance symmetric inductive hypothesis ground atom gamma oe ground atom gamma oe 
und due rule oe und os due rule inductive hypothesis 
similarly os os 
concludes induction subgoal completed ground instance instance instance concludes proof symmetric holds 
completion argument positive return completion affect subgoals completed fi particular coincide literals form subgoal completed fi addition inductive hypothesis remains symmetric subgoals completed fi definition completion active rules subgoals answers obtained fi deleting rules 
respect truth ordering 
lemma implies inductive hypothesis symmetric subgoals completed non empty set subgoals completely evaluated fi active rules subgoals disposed completion 
remains show symmetric subgoals suffices prove subgoal ground instance und und os instance os os instance basis case trivial 
inductive case suppose und os derivation uses rule form oe oe rule fi lemma oe rule fi oe rule hold inductive hypothesis 
succeeds case hold active rule corresponding ordinal ff fi form lef right clearly existence ensured fact wf 
lpm 
wf independent wf wf valued stable model symmetric 
definition literal form wf subgoal instance ground instance symmetric wf 
wf 
established implies prove 
successor ordinal fi 
obtained fi transformations 
lemma fi 
lpm fi lpm 
inductive hypothesis symmetric interpretation fi 
prove symmetric case analysis transformations 
new subgoal suppose new subgoal introduced arbitrary ground instance herbrand instantiation contains rule form oe herbrand instantiation contains rule form oe instance symmetric subgoals fi affected holds inductive hypothesis 
negative return delaying partially symmetric interpretation verified fi holds inductive hypothesis 
simplification subgoal completed fi answer disposed 
delayed literal body negative delayed literal verified fi assumption holds inductive hypothesis 
positive delayed literal form subgoal fi instance instance cases 
successful answer fi head empty body 
deleted body clearly ground instance derived 
holds inductive hypothesis 
case failed similar 
answer completion set pairs fi subgoal head atom answer supported obtained fi deleting answers head definition pair completed answer head exists positive delayed literal body form supported ground instance holds inductive hypothesis 
positive return positive return affect subgoals completed fi particular completed subgoal fi answer disposed fi positive delayed literal body form completed 
reason positive delayed literal created positive return active rule selected atom active rule subgoal selected atom disposed completion 
inductive hypothesis remains symmetric completed subgoals precisely completed subgoals fi oe lef oe right fi obtained ground instance head atom existence guaranteed selected atom answer remains completed case lemma holds inductive hypothesis 
selected negative literal 
remains case lemma holds inductive hypothesis negative return delaying applied case partially symmetric jfi exists ordinal fl fi fl rule fl satisfies properties negative literal delayed contradiction 
preservation valued stable models key theorem shows system slg derivation atomic query symmetric system 
theorem finite program arbitrary fixed computation rule atomic query 
ff arbitrary slg derivation ff ordinal 
ff wf symmetric system 
proof proof induction basis case empty system empty set empty program 
lemma holds trivially 
inductive case prove lpm symmetric partially symmetric interpretation wf 
arbitrary partially symmetric interpretation lemma 
implies symmetric system 
show implies prove 

inductive hypothesis wf 
independent lemma follows wf construct partially symmetric interpretation follows ffl wf ffl ground subgoal ffl subgoal instance ground instance oe lef oe right head atom recall sequence ae annotated rules associated subgoal hff means positive return applied rule corresponding ordinal ff answer head 
lemma rule rule derived directly indirectly solving delaying negative literals body lemma describes essentially relationship active rule selected atom rules derived positive return 
subsection prove correctness completion 
proof lemma proof induction basis case trivial 
successor ordinal fi 
obtained fi transformations 
case new subgoal initial rules new subgoal say derived resolution rules program transformation positive return applied initial rule selected atom 
lemma holds inductive hypothesis 
cases completion simplification answer completion hold inductive hypothesis affect rules subgoals completed cases negative return delaying partially symmetric jfi verified fi lemma holds inductive hypothesis 
positive return active rule fi form lef right selected atom 
answer atom head fi positive return applied derived fi resolvent empty body factor delayed literals body 
satisfies properties specified lemma lemma holds inductive hypothesis 
limit ordinal subgoal completed ae active rule selected atom instance hff element ae rule fi non disposed rules fi rule fewest negative literals delayed body fi ffl non disposed rule fi ffl rule oe lef oe right fi obtained ground instance exists rule oe lef oe right lemma subsection establish direction symmetry lpm especially case positive return introduces new rule 
proof lemma proof induction basis case trivial empty system subgoals 
successor ordinal fi 
obtained fi transformations 
cases completion simplification answer completion trivial affect rules subgoals completed case new subgoal follows general unifier resolution deriving initial rules new subgoal 
obtained fi negative return delaying fi holds argument proof lemma assumption partially symmetric lemma holds inductive hypothesis 
case positive return subgoal fi active rule corresponding ordinal fl selected atom answer subgoal fi empty body resolvent delayed literals body factor head atom head atom ground instance suppose oe rule obtained ground instance definition positive return exists rule oe fi obtained ground instance oe oe oe gamma oe fi 
inductive hypothesis exists rule oe gamma oe fi 
oe gamma oe jfi 
lemma holds 
limit ordinal 
subgoal completed subgoal fi fi completed fi fi subgoal fi definition rule disposed rule disposed fi fi lemma follows inductive hypothesis 
lemma finite program arbitrary fixed computation rule atomic query 
ff arbitrary slg derivation ff ordinal 
ff partially symmetric interpretation subgoal completed ae holds rule corresponding ordinal ff form lef right selected atom atom hff element ae rule exists non disposed rule rule form oe lef oe right obtained ground instance ground instance exists rule obtained ground instance form oe lef oe right limit ordinal 
subgoal completed subgoal fi fi completed fi fi subgoal fi ground instance rule rule fewest negative literals body delayed fi ffl rule fi ffl exists rule fi obtained ground instance head atom existence ensured inductive hypothesis 
cases ffl selected atom answer rule disposed completion simplification completed lemma holds inductive hypothesis ffl selected negative literal remains rule case lemma holds negative return delaying applied case contradicts assumption fewest negative literals body delayed 
lemma finite program arbitrary fixed computation rule atomic query 
ff arbitrary slg derivation ff ordinal 
ff partially symmetric interpretation subgoal completed ground instance oe rule instance rule oe gamma oe oe fb jb occurs oe subgoal instance viewed set atoms 
lemma reflects selected atom body rule subgoal processed 
suppose answer atom head 
application positive return possibilities 
empty body ground instance 
rule generated resolution instance form deleted general unifier new variant condition gamma oe means atom occur oe true 
delayed literals body rule generated instance form general unifier new variant condition oe means atom delayed unsolved oe come 
notice establish key properties relating proving soundness completeness slg resolution 
lemma finite program arbitrary fixed computation rule atomic query 
ff arbitrary slg derivation ff ordinal 
ff partially symmetric interpretation subgoal completed ground instance rule rule instance ground instance intuition lemma follows 
subgoal completed initial rules obtained resolution rules non disposed rule selected atom disposed completion selected negative literal say solved negative return delayed delaying ground remains non disposed rule assumption ensures lemma continues hold application negative return delaying 
notice successor ordinal form fi fi due lemma 
lemma subsection establish direction symmetry lpm 
proof lemma proof induction basis case holds trivially empty system subgoals 
successor ordinal fi 
obtained fi transformations 
cases completion simplification answer completion trivial affect rules subgoals completed case new subgoal follows general unifier resolution deriving initial rules new subgoal 
case positive return follows inductive hypothesis positive return adds rule subgoal completed 
subgoal fi active rule corresponding ordinal fl selected literal ffl negative return 
succeeds disposed definition answer fi head empty body 
ground instance fi fi 
assumption fails replaced deleted 
definition completed fi answers 
ground instance fi assumption 
ffl delaying 
ground replaced replaced ground negative delayed literal viewed partially symmetric 
cases negative return delaying fi lemma holds inductive hypothesis 
lemma finite program arbitrary fixed computation rule atomic query 
ff arbitrary slg derivation ff ordinal 
ff 
proof lemma follows observations 
answer subgoal empty body deleted transformation 
subgoal completed answers simplified new answer added head atom distinct head atom existing answer finite program system slg derivation atomic query relate semantics look partial model lpm interpretation quotient modulo ground instance subgoal compare truth value atoms form lpm instance instance provided satisfies certain conditions 
correctness transformations expressed terms symmetry lpm defined follows 
definition finite program arbitrary fixed computation rule atomic query 
system slg derivation interpretation 
partially symmetric ground subgoal 
symmetric subgoal ground instance ffl instance ffl instance symmetric interpretation symmetric subgoal symmetric system interpretation partially symmetric lpm symmetric 
correctness system respect program specified notions symmetric systems symmetric interpretations 
comparing partial model lpm interpretation required satisfy conditions 
condition originates observation rules essentially derived rules solving subgoals succeed fail simplifying delayed literals successful failed 
mentioned previously represents subgoals succeed fail delayed literals successful failed 
condition partially symmetric due delaying ground negative literal form may replaced body rule 
recall negative delayed literal viewed 
negative literals predicates form ground subgoal 
particular completed negative literals form ground subgoal recall ground non negative program obtained herbrand instantiation replacing ground negative literal truth value rule possibly empty conjunction atoms special atom ffl positive delayed literal form denote program multiset rules rule subgoal disposed 
example system example corresponding program follows non disposed rules non disposed rules non disposed rules general depends original program completed 
technical reasons include herbrand base hb hb ground atoms form subgoal instance ground instance 
alternative introduce useless rules subgoal instance 
definition finite program arbitrary fixed computation rule atomic query 
system slg derivation associate set ground literals follows ffl subgoal answer atom head empty body ground instance ffl subgoal completed instance answers head ground instance ffl subgoal completed ground instance instance head answer instance instance set ground literals captures subgoals succeed fail delayed literals successful failed 
example subgoal succeeds ground instance subgoal fails ground instance similarly positive delayed literal successful ground instance failed negation ground instance 
shall see system slg derivation atomic query interpretation consistent 
point define simply set ground literals 
example suppose atomic query evaluated respect program assuming left right computation rule intermediate system may constructed hc hc hc hc hc delayed rules subgoals observations treatment rules subgoals 
rules different subgoals treated independently subgoals predicate 
instance subgoal may completed subgoal succeeds 
second rules subgoal distinct head atoms treated independently especially positive return simplification answer completion 
positive return selected atom body rule multiple answers head atom solve answers distinct head atoms solve head atom answer subsumes 
simplification answer completion answers head atom grouped order determine delayed literal successful failed head atom answer supported 
relating finite program rules subgoals system introduce new predicates way reflects independent treatment rules different subgoals independent treatment rules subgoal different head atoms 
specifically subgoal instance introduce new predicate arity number distinct variables atoms new predicate written instance derived rules disposed head 
correspondence ground atoms new predicate ground instances definition finite program arbitrary fixed computation rule atomic query 
system slg derivation form rule subgoal denote rule form ffl delayed literal ffl negative delayed literal form ordinal ff ae subgoal ae fae ae ig 
exists ordinal length ae ae bounded 
fae ae ig defined 
clearly concludes inductive proof 
size system bounded number distinct subgoals variants countable length sequence subgoal system bounded 
transformation increases size system slg derivation monotonically increasing sequence systems exist slg derivation ends final system 
theorem shows final system derived atomic query finite program arbitrary fixed computation rule turns final system subgoal completed active rule subgoal selected negative literal ground 
definition finite program system 
completed subgoal completed floundered active rule subgoal selected negative literal ground 
lemma finite program arbitrary fixed computation rule atomic query 
final system completed floundered 
proof follows definitions transformations floundered completed systems 
soundness completeness section establishes soundness search space completeness slg resolution 
slg resolution shown preserve valued stable models 
second slg resolution computes founded semantics sense final system completed ground instance subgoal true instance head answer subgoal empty body false instance head answer subgoal 
third establish termination slg resolution programs bounded term size property polynomial time data complexity slg resolution function free programs 
relating partial answers subgoals program finite program arbitrary fixed computation rule system slg derivation atomic query 
subgoal multiset rules disposed constitutes set partial answers head rule contains relevant variable bindings accumulated delayed literals rule body partially solved may simplified away remaining literals rule body solved respect original program relate rules subgoals system introduce new predicates 
consider example 
exists ordinal system slg derivation length sequence subgoal bounded slg derivation monotonically increasing sequence systems respect exists slg derivation ff ordinal ff ff final system 
proof pi maximum number literals body rule 
system slg derivation ae pair subgoal ae sequence 
length ae bounded observations ffl subgoal added system initial sequence contains rules obtained resolving body rules number literals body rule bounded pi finite initial sequence finite 
ffl transformation extends sequence elements appended sequence 
ff ordinal rule subgoal corresponding ff 
discuss possible forms elements appended 
disposed disposed construction slg derivation ii form hffi rule disposed replaced negative return delaying simplification 
iii hff hi rule atom obtained solving selected atom answer head literal delayed 
number rules obtained positive return bounded number distinct atoms variants countable 
rule subgoal corresponding ordinal ff number rules obtained directly bounded number distinct atoms countable 
ii iii number literals body fewer literals delayed number literals delayed fewer literals delayed 
chain rules obtained transformation pi exists countable ordinal length sequence ae bounded 
ordinal depends finite program language lf defined section countable applicable sequence ae subgoal system arbitrary slg derivation ff slg derivation definition empty system fg 
successor ordinal ff transformation adds new subgoal extends sequences subgoals limit disposed delayed literal body failed successful 
gamma ae ae delta failed gamma ae ae delta hffi successful deleted body 
simplifying positive delayed literal generate variable bindings 
reason variable bindings propagated factoring positive return positive delayed literal generated 
ffl answer completion ae subgoal completed ae sequence 
head atom answer supported gamma ae ae delta ae ae arbitrary sequence elements form ff ordinal rule corresponding ff ae answer disposed head 
derivation slg resolution definition finite program arbitrary fixed computation rule atomic query 
slg derivation sequence systems ff ffl empty system fg ffl successor ordinal fi ff fi obtained fi application transformations new subgoal positive return negative return delaying completion simplification answer completion ffl limit ordinal fi ff fi ae fi subgoal fi ae fae ae fig 
transformation applicable ff ff called final system slg resolution process constructing slg derivation query respect finite program computation rule show final system exists prove slg derivation monotonically increasing sequence systems respect partial ordering system slg derivation bounded size ordinal 
definition finite program systems 
ae exists ae ae ae ae prefix ae theorem finite program arbitrary fixed computation rule atomic query 
ffl positive return ae subgoal ae sequence 
active rule corresponding ordinal ff selected atom answer subgoal head 
ordinal ff ae hff hi rule gamma ae ae delta hff hi resolvent empty body factor delayed literals body 
may multiple answers atom head 
positive return solve selected atom particular redundant answers 
ffl negative return ae subgoal ae sequence 
active rule subgoal corresponding ordinal ff selected literal succeeds fails 
gamma ae ae delta succeeds gamma ae ae delta hffi fails selected literal deleted 
ffl delaying ae subgoal ae sequence 
active rule subgoal corresponding ordinal ff selected literal ground 
gamma ae ae delta hffi obtained replacing non ground negative literals delayed 
ffl completion non empty set subgoals completely evaluated 
replace ae ae delta ae ae arbitrary sequence elements form ff ordinal rule corresponding ff ae active rule 
completion depend priori stratification ordering predicates atoms 
set subgoals inspected completed dynamically 
ffl simplification ae subgoal completed ae sequence 
rule corresponding ordinal ff definition system non empty set subgoals completed 
said completely evaluated subgoal ae sequence ae succeeds active rule corresponding ordinal ff exists atom ffl selected atom ffl subgoal completed ffl atom head answer exists ordinal ff rule ae hff hi 
transformation answer completion needed get rid answers subgoals positive delayed literals bodies provided supported sense 
definition system subgoal atom occurs head answer supported completed ii exists answer head positive delayed literal body supported atom supported follows ii 
notice subgoal system answer atom head negative delayed literals body supported finite program arbitrary fixed computation rule atomic query 
transformations systems transforms current system new 
ffl new subgoal subgoal satisfies conditions initial atomic query active rule subgoal selected literal gamma rules program resolvable resolvent ae sequence length ae hc 
ae repeated subgoals solved resolution rules program 
transformations systems subgoals starting empty system subgoals transformation transforms system 
initial sequence subgoal obtained resolution rules program 
loss generality consider atomic queries contain single atom 
definition resolution rule form selected atom 
rule form variant variables renamed variables common 
resolvable unifiable 
rule gamma resolvent general unifier selected atom body rule solved answer may may delayed literals 
answer delayed literals factoring propagate variable bindings captured head atom answer create positive delayed literal propagating truth values delayed literals body answer 
definition factoring system 
form active rule subgoal selected atom 
suppose subgoal answer form variant variables renamed variables common 
rule gamma factor general unifier selected negative literal possibly containing variables body rule solved positive counterpart succeeds binding variables fails 
delayed literal simplified successful failed 
definition system 
ffl subgoal succeeds answer head empty body fails completed answers ffl ground negative delayed literal successful subgoal fails failed subgoal succeeds ffl positive delayed literal successful subgoal answer head empty body failed subgoal completed answer head 
transformation completion requires notion set subgoals completely evaluated dispose active rules answers 
ffl form rule rule corresponding ff ae disposed replaced ffl form hi rule atom obtained solving selected atom rule corresponding ff ae answer head ffl rule corresponding ff ae simply disposed 
consider main operations sequences concatenation upper bound increasing chain sequences 
extend sequence subgoal system needed transfinite definition notion slg derivation section 
definition ae ae sequences length ff ff respectively 
concatenation ae ae denoted ae delta ae sequence length ff ff ae delta ae ae ff ae delta ae ff ae ff 
sequence ae said prefix ae delta ae ae sequence length ae element write ae delta ae ae delta natural prefix partial order sequences 
ae ae sequences 
ae ae ae prefix ae sequence ae length ff viewed set pairs fhi ae ffg case prefix relation reduces subset relation 
definition fi ordinal ae fi increasing chain sequences respect ff ordinal length ae fi ff 
upper bound chain ae fi denoted fae fig exists length ae fi ff 
sequence union ae fi sequence viewed set 
intermediate state partial deduction query represented system 
definition finite program computation rule 
system set pairs form ae subgoal ae sequence pairs subgoal 
subgoal said ae sequence ae 
ae subgoal ae sequence 
rule ff ordinal 
said rule corresponding ff ae ff ghi hi rule ff atom 
rule corresponding ff ffl disposed ff ae hffi rule ffl answer disposed literals body delayed literals ffl active rule disposed selected literal 
subgoal completed rules disposed answers 
transformations section presents formal definitions systems transformations systems 
systems definition subgoal atom 
subgoals considered renaming variants 
negative delayed literal form ground atom 
positive delayed literal form atoms instance instance substitution defined discussed section positive delayed literal form created selected atom rule solved answer subgoal head delayed literals body case instance annotations provide control information simplification delayed literal 
definition rule form atom atom negation atom delayed literal 
called fact 
delayed literal called answer 
computation rule algorithm selects body rule literal atom negation atom 
called selected literal atom called selected atom notice computation rule selects delayed literal 
may select negative literal ground 
try solve non ground negative literal negation failure sound 
definition finite program rule rule ff ordinal atom 
element form hi 
sequence ae mapping ordinals smaller ordinal ff set elements 
ordinal ff length ae 
subgoal system associated sequence 
sequence captures history addition disposal rules subgoal partial deduction shown examples section 
element sequence indicates rule derived rule program rule earlier sequence rule earlier sequence disposed 
specifically ae sequence subgoal fi ordinal ae fi element ff ordinal ff fi 
ffl form rule rule program created resolving body singleton set fpg subgoals completely evaluated definition 
rules answers disposed transformation completion hc hc pi disposed singleton set frg subgoals completely evaluated definition 
rules subgoal answers disposed transformation completion 
final sequence annotated rules associated follows hc disposed subgoal completed answers occurrences delayed literal deleted 
particular sequence annotated rules subgoal extended hc subgoal succeeds answer head empty body 
rule subgoal disposed 
hc hc pi disposed disposed answer founded semantics original program false 
notice answer derived answer delayed literal deleted remains 
introduce transformation called answer completion deletes answers positive delayed literals certain conditions defined 
example final sequence annotated rules follows hc hc pi disposed disposed disposed answer disposed 
subgoal completed answers 
notice answers 
evaluation subgoal approach generates polynomial number answers relevant subgoals 
contrast propagating delayed literals answers led exponential number answers 
simplification delayed literals delayed literals undefined founded partial model program 
may known true false simplified away 
simplification delayed literals necessary subgoal completed ground instance subgoal true founded partial model instance head answer empty body false instance head answer subgoal 
suppose evaluated respect program assuming left right computation rule evaluation leads system subgoals hc hc hc hc negative loop involving subgoals delaying transformation applied selected negative literals results new system hc hc hc hc subgoal answer delayed literals answer returned selected atom rule sequence annotated rules extended follows hc hc pi recall computation rule select delayed literal 
selected body 
new subgoal added system initial sequence contains rule obtained resolution rule labeled program 
hc rule answer 
solve selected atom rule corresponding sequence 
sequence extended hc completion transformation applied set fp subgoals produces final system subgoals completed hc disposed disposed hc hc hc hc reasons propagate delayed literals body answer answer solve selected atom rule 
necessary propagate delayed literals founded negation 
interested atom definitely true false founded partial model ways atom may depend literals 
second subgoal may answers atom head different delayed literals body 
propagating delayed literals may generate exponential number distinct answers subgoal example shows 
example arbitrary positive integer 
consider program max succ 
succ 
succ gamma 
succ max answer may delayed literals body question propagated 
approach 
illustrate answers delayed literals solve selected atom rule 
give example shows propagating delayed literals answers may cause exponential explosion 
consider evaluation atomic query respect program procedures discussed previous subsections assuming left right computation rule evaluation query leads system hc hc hc hc subgoal completed answer delayed literal succeeds fails negative literal rule delayed 
sequence associated extended follows hc annotated rule means rule corresponding disposed replaced definition answer subgoal contains delayed literals body 
answer solve selected atom rule 
approach propagate delayed literal body answer 
introduce positive delayed literal 
sequence annotated rules associated extended follows hc represents positive delayed literal truth value depends truth value answer subgoal head 
annotation means corresponding rule obtained solving selected atom earlier rule corresponding answer head 
variable bindings head answer propagated unification delayed positive literal serves place holder simplified away truth value known 
annotation delayed positive literal provides control information simplification 
evaluation subgoal leads system follows hc hc sequences associated subgoals rules selected literal viewed directed edges dependency graph subgoals 
edge labeled positive negative selected literal atom negation atom 
system rule sequence subgoal viewed negative edge rule sequence subgoal viewed negative edge loop dependency graph involving negative edges 
loop called negative loop 
waiting completed order solve selected negative literal body rule keeps proceeding 
approach delay selected negative ground literals computation proceed 
delayed literals selected computation rule may simplified away truth values known true false 
delayed literal annotated corresponding subgoal notion rules extended allow delayed literals rule bodies 
selected ground negative literal rule delayed rule disposed replaced new rule delayed literal body 
suppose delayed rule derive system hc hc sequence means rule corresponding ordinal sequence disposed replaced rule delayed literals body considered answer 
subgoal completed rules disposed answers 
subgoal succeeds answer empty body fails answers 
accordingly selected negative literal rule succeeds fails 
approach delay results new system hc hc final system processing done 
subgoals succeeds fails 
fact undefined founded partial model program 
propagation delayed literals answer solve selected atom rule body variable bindings accumulated head answer propagated unification selected atom 
notice answers 
completed rules sequences selected atom disposed 
hand succeed completed answers 
introduce completion transformation handle situation 
applied non empty set subgoals 
checks rules associated sequences annotated rules subgoals certain conditions rules answers 
set subgoals fq properties satisfied required completion transformation 
rule selected negative literal disposed 
second non disposed rules selected atom processed answers selected atom 
condition ensures situation similar tabled evaluation definite programs second condition guarantees answers selected atom returned 
case fq answer 
completion transformation applied fq rules answers disposed hc hc disposed hc disposed completed answers 
negation failure removed rule disposed annotated answer added leading final system subgoals hc hc disposed hc disposed annotated rule mh sequence associated means rule corresponding ordinal disposed 
handling negative loops delaying recursion negation set subgoals may waiting circular fashion selected negative literals 
may waiting completed order solve selected negative literals rules completed 
introduce delaying transformation skip selected negative literals ground computation proceed 
consider atomic query respect program point answers derived subgoals relevant query 
new subgoal introduced annotated rule added sequence subgoal system 
definite programs annotated rules selected atom disposed leaving answers subgoals relevant original query 
final system example follows hc hc disposed hc disposed ordinal ff indicates earlier rule corresponding ff sequence annotated rules simply disposed 
finite program atomic query system subgoals constructed partial deduction respect set rules disposed system constitutes intermediate program subgoals relevant final system reached rules disposed answers partial deduction query evaluation sense program subgoals corresponding final system contains answers 
partial deduction stratified programs subgoal completed rules sequence disposed answers 
stratified negation ground negative literal succeeds completed answers 
mutual recursion subgoals subgoals may rules sequences selected atoms disposed possibly answers 
rules selected atoms disposed subgoals completed negative counterparts succeed 
consider atomic query respect stratified program subgoal system initial atomic query hc selection rule body results new subgoal 
new subgoal processed definite programs leading transformation steps system hc hc hc general sequence ae transfinite necessary founded partial model program may transfinite 
initially system empty 
query atom introduced subgoal 
initial sequence arbitrary sequence rules obtained resolving body rules program 
system introduced hc hc annotated rule form label rule program means obtained resolution rule program 
sequence subgoal written set pairs ff ag ff ordinal ag annotated rule 
general annotation ag indicates rule ag derived rule program earlier rule sequence case earlier rule sequence disposed 
non disposed rule sequence subgoal head captures variable bindings accumulated rule body contains literals remain solved order derive answer subgoal 
rule empty body answer sequence 
rule non empty body literal selected rule body computation rule 
atom selected literal added new subgoal current system 
example selected body added new subgoal 
sequence annotated rules obtained resolution body rules program 
system hc hc hc selected atom subgoal current system 
solved answers subgoal sequence 
avoids repeated evaluation identical subgoals 
solving selected atom answer sequence extended follows hc annotated rule means obtained earlier rule sequence corresponding ordinal solving selected atom answer 
continuing similar way answer solve selected atom 
sequence extended adding resulting rule hc hc rule corresponding ordinal sequence answer 
redundant answer solve selected atom rule 
ffl replacing negative literal rule body undefined valued stable model lpm 
set valued stable models denoted st 
notion valued stable models generalization founded partial model valued stable models :10.1.1.24.6050:10.1.1.24.6050
theorem program wf founded partial model wf smallest valued stable model stable models defined gelfond lifschitz coincide valued stable models 
query evaluation partial deduction partial deduction program transformation technique specializes logic program respect query produce efficient simpler program 
new program equivalent original far query concerned 
uses partial deduction query evaluation respect founded partial model 
primary motivation partial deduction understand fundamental transformations involved query evaluation separate logical issues procedural ones 
recall unification viewed process transforming system equations general form solved form 
transformation preserves solutions unifiers 
follow similar approach query evaluation considered process transforming system subgoals associated rules contains answers subgoals 
section introduces examples representation systems subgoals various transformations 
partial deduction definite programs loss generality consider queries represented atoms subgoal synonym atom 
definite programs partial deduction subgoal corresponds sld resolution tabling oldt resolution 
consider atomic query respect program examples label rule program convenience assume left right computation rule 
system set pairs form ae subgoal ae sequence annotated rules pairs system subgoal subgoals considered renaming variants 
sequence ae annotated rules represents history addition deletion rules subgoal annotation rule ae indicates rule derived rule disposed 
intuitively rule disposed longer contribute derivation 
ffl neg rule head herbrand instantiation false interpretation ground atoms hb false 
powers defined follows gamma successor ordinal tft ng limit ordinal upper bound operation interpretations respect truth ordering assume special ground atom atom undefined und 
appear rule bodies program 
non negative program multiset rules bodies contain negative literals may contain atom theorem non negative program 
unique valued model denoted lpm 
furthermore fixed point coincides lpm 
interpretation determined specifying os und 
non negative program interpretation define hb ffl os rule herbrand instantiation true ffl und os rule herbrand instantiation true undefined powers defined lemma non negative program interpretation 
non negative program fixpoint coincides lpm 
proof notice os os neg os und 

rest lemma follows theorem 
definition program interpretation quotient modulo denoted non negative program obtained herbrand instantiation ffl deleting rule negative literal body false ffl deleting negative literal rule body true respectively 
sets uniquely determine viewed set os neg ground literals 
definition programs hb hb interpretation restriction denoted ij interpretation mapping restriction mapping hb definition interpretation program ffl ground atom true os false neg undefined und ffl ground negative literal true neg false os undefined und ffl existential closure literal true denoted ground instance true false ground instances false ffl universal closure literal true denoted ground instance true false ground instance false ffl ground rule true true rule body true rule body false false ffl rule true ground instance true false ground instance false model rule true definition interpretations program natural orderings interpretations truth ordering called fitting ordering information ordering ffl os os neg neg ffl os os neg neg 
models sense truth ordering called models 
models smallest sense information ordering called smallest models 
associated program mapping interpretations 
generalization immediate consequence operator 
definition program interpretation interpretation hb ffl os rule herbrand instantiation true ward compatibility existing prolog systems 
prolog notorious non logical features real value making slg resolution available prolog applications 
implementations slg resolutions carried including prolog meta interpreter partial implementation prolog compiler called xsb partial implementation prolog program transformation prolog interface 
experimental results demonstrated prolog compiler technology adapted efficient implementation slg resolution providing impressive performance memory query evaluation deductive databases 
valued stable models section reviews notion valued stable models logic programs 
basic terminology logic programs assumed 
atom form ary predicate symbol terms 
literal atom negation existential closure literal denoted universal closure denoted 
rule form rule head atom rule body literals 
called fact program possibly infinite multiset rules 
unique labeling annotations need distinguish different occurrences rule expression atom literal rule ground variable free 
considers query evaluation process partial deduction may involve multiple programs possibly infinite original program normally finite 
allowing program infinite possible consider intermediate result partial deduction program 
relate semantics program single herbrand universe programs 
specifically assume countable language lf function symbols 
lf contains function symbols occur programs involved evaluation query plus unary function symbol zero ary function symbol occur programs considered 
symbols needed cope universal query problem semantics program containing single fact may imply herbrand universe fag :10.1.1.54.8201
empty answer substitution obtained sld resolution 
new symbols eliminates situations 
herbrand universe hu set ground terms constructed function symbols lf instance expression atom literal rule obtained replacing variable expression term constructed function symbols lf variables 
program 
herbrand instantiation set ground instances rules herbrand base denoted hb set ground atoms constructed predicates terms hu truth values ordered interpretation program mapping hb ff tg 
represented partition hb os und neg os respectively und neg set ground atoms contexts 
worst case subgoal may evaluated number negative contexts exponential size herbrand base function free programs 
techniques effective set time query evaluation studied deductive databases including magic sets magic templates alexander templates 
main idea simulate top sld resolution avoid generation tuples irrelevant goal 
fact tuples magic predicates correspond subgoals maintained oldt resolution 
definite programs shown top memoing set time approaches essentially equivalent 
methods query processing investigated stratified modularly stratified programs 
negation major issue maintaining dependencies magic tuples subgoals ensure positive subgoal fully evaluated negative counterpart solved 
kemp developed technique computes wellfounded partial model doubled program deriving definitely true answers deriving potentially true answers 
doubled program technique may magic facts true means subgoals evaluated necessary 
morishita proposed alternating fixpoint semantics tailored magic sets computation generates fewer magic facts 
presents partial deduction framework query evaluation called slg resolution linear resolution selection function general logic programs 
slg resolution addresses problems non termination redundant computation identical subgoals 
detecting handling infinite recursion negation focus complementary problem ensuring complete evaluation subgoals 
summarize main results follows 
fundamental transformations identified applied transform query step step set answers respect founded partial model 
restricted forms slg resolution identified definite locally stratified modularly stratified programs shedding light role transformation plays 
programs pay overhead transformations needed 
second separation logical issues query evaluation procedural ones results maximum freedom control strategies 
slg resolution allows programmer implementer choose arbitrary computation rule selecting literal rule body choose arbitrary strategy selecting transformation apply 
third slg resolution supports answer sharing subgoals variants 
subgoal guaranteed evaluated 
slg resolution terminates programs bounded term size property polynomial time data complexity founded negation function free programs 
slg resolution delays ground negative literals involved loop simplifies away truth values known true false 
delaying mechanism key maximum freedom control strategies enables slg resolution avoid repetition derivation step 
importantly valued stable models founded partial model computed processing answers subgoals relevant query possibly delayed literals founded semantics 
shown marek truszczynski propositional logic programs determining valued stable model np complete 
software engineering point view major advantage slg resolution seminal apt van emden kowalski provided foundation declarative procedural semantics logic programs 
program rule viewed procedure declaration literal rule body viewed procedure call 
operational interpretation formalized sld resolution linear resolution selection function definite programs sound complete positive queries respect model semantics definite programs 
clark extended sld resolution sldnf resolution sld resolution negation finite failure 
ground negative literal succeeds positive counterpart finitely fails fails positive counterpart succeeds 
sldnf resolution serves purpose operational semantics predicate logic programming language 
advantages goal oriented computation efficient stack memory management computation strategy prolog systems 
significant progress understanding default negation leading variations sldnf resolution including sls resolution global sls resolution :10.1.1.54.8201
ideal procedures computing perfect model founded partial model logic program :10.1.1.54.8201
sld resolution sldnf global sls resolution top goal reduction search strategy 
may terminate due infinite recursion possibly negation function free programs 
prevents directly query evaluation data knowledge bases 
terminate repeated computation identical subgoals may result unacceptable performance 
partial solutions proposed improve termination properties top computation avoid redundant evaluation subgoals 
extensions sld resolution memoing studied including extension tables oldt resolution 
main idea keep global table subgoals answers computed 
subgoal identical subsumed previous solved rules program solved answers computed previous subgoal 
avoids infinite branches redundant computation due repeated subgoals search space sld resolution 
techniques generalized stratified programs modularly stratified programs 
non termination may occur due infinite recursion negation treated differently infinite recursion definite programs 
positive loop considered failed seen founded partial model false 
contrast negative loop considered indeterminate undefined founded partial model mechanisms handling infinite recursion negation studied tabled evaluation queries including 
resolution 
key idea associate set ground negative literals called negative context subgoal 
negative context initial subgoal empty 
subgoal negative context calls ground negative literal replaced undefined truth value truth value determined evaluating larger negative context fbg 
function free program herbrand base finite size negative context finite infinite recursion negation avoided 
negative contexts prevents full sharing answers subgoal different negative symbols negative literal hu herbrand universe programs query evaluation lf language function symbols constructing hu hb herbrand base program truth values truth ordering interpretations information ordering interpretations transformation interpretations program ordinal power lpm valued model non negative program variation ordinal power quotient modulo st set valued stable models wf founded partial model delayed ground negative literal delayed positive literal control annotation rule rule delayed literals body head atom rule element annotated rule ae sequence elements ae delta ae concatenation sequences ae delta concatenation ae singleton sequence containing ae ae ae prefix ae fae fig upper bound chain sequences system set subgoals partial order systems pi maximum number literals rule body number distinct atoms argument sizes program rules disposed rule corresponding rule subgoal ij interpretation restricted interpretation program union jp number occurrences rules ii contents valued stable models query evaluation partial deduction partial deduction definite programs partial deduction stratified programs handling negative loops delaying propagation delayed literals simplification delayed literals transformations systems transformations systems subgoals derivation slg resolution soundness completeness relating partial answers subgoals program preservation valued stable models computation founded partial model termination data complexity restricted slg resolution definite programs locally stratified programs modularly stratified programs discussion variant versus subsumption checking computation rule search strategies related implementations slg resolution iii slg resolution avoids positive negative loops terminates programs bounded term size property 
polynomial time data complexity founded negation function free programs 
delaying mechanism handling ground negative literals involved loops slg resolution avoids repetition derivation steps 
restricted forms slg resolution identified definite locally stratified modularly stratified programs shedding light role transformation plays 
slg resolution rule specifications effective programs 
simple user computer generated annotations sldnf resolution slg resolution single application allowing smooth integration prolog computation tabled evaluation queries 
furthermore prolog compiler technology adapted efficient implementations slg resolution 
reasons believe slg resolution provide computational basis generation logic programming systems 
tabled evaluation delaying general logic programs chen computer science engineering southern methodist university dallas tx david warren department computer science suny stony brook stony brook ny march sld resolution negation finite failure sldnf reflects procedural interpretation predicate calculus programming language forms computational basis prolog systems 
despite advantages stack memory management sldnf appropriate query evaluation reasons may terminate due infinite positive recursion may terminate due infinite recursion negation may repeatedly evaluate literal rule body leading unacceptable performance 
address problems goal oriented query evaluation general logic programs presenting tabled evaluation delaying called slg resolution 
distinctive features slg resolution partial deduction procedure consisting fundamental transformations 
query transformed step step set answers 
transformations separates logical issues query evaluation procedural ones 
slg allows arbitrary computation rule selecting literal rule body arbitrary control strategy selecting transformations apply 
ii slg resolution sound search space complete respect founded partial model non floundering queries preserves valued stable models 
evaluate query different valued stable models slg resolution enhanced processing answers subgoals relevant query 
preliminary version appeared chen warren query evaluation founded semantics 
proceedings th annual acm symposium principles database systems 
acm washington pp 

supported part national science foundation 
iri iri 
supported part national science foundation 
ccr new york state science technology foundation 
rdg 
