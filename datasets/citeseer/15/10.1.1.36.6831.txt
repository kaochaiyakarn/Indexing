algebraic software architecture reconfiguration michel jos luiz fiadeiro departamento de inform tica de ci tecnologia universidade nova de lisboa portugal mw di fct unl pt departamento de inform tica de ci universidade de lisboa campo grande lisboa portugal llf di fc ul pt 
ability reconfiguring software architectures order adapt new requirements changing environment growing interest formal area 
existing approaches deal run time changes deficient way 
language express computations low level specification integration different formalisms computations reconfigurations require substantial changes 
address problems propose uniform algebraic approach characteristics 

components written high level program design language usual notion state 

approach combines existing frameworks specify architectures rewrite labelled graphs just small additions 

deals certain typical problems guaranteeing new components introduced correct state possibly transferred old components replace 

shows relationships reconfigurations computations keeping separate approach provides semantics architecture algebraic construction equivalent program computations mirrored architectural level 
motivation topics raising increased interest software architecture sa community ability specify sa evolves time particular run time order adapt new requirements new environments failures mobility 
issues stake modification time source architectures may change execution run time called dynamic reconfiguration 
run time changes may triggered current state topology system called programmed reconfiguration 
modification operations fundamental operations addition removal components connections 
names vary operators provided reconfiguration languages 
programmed reconfiguration changes perform initial architecture may executed architecture changed 
necessary query run time state components topology architecture 
system state reconfiguration cause possible disruption new system consistent state 
related adls able express dynamism 
darwin permits constrained dynamism initial architecture may depend parameters run time components may replicated 
wright formalism bit cumbersome requires distinct configurations uniquely tagged 
acme proposal allows specification optional elements components connectors links 
formal area 
uses different formalisms represent reconfigurations computations approaches uniform notion rewriting 
works common drawbacks 
languages represent computations simple lowlevel rewriting labels process calculi term rewriting graph rewriting 
capture abstractions programmers lead cumbersome specifications 
second combination reconfigurations computations leads additional complex formal constructs uses constraint solving define new semantics language constructs process calculi dynamically change rewriting strategies imposes constraints form graph rewrite rules express computation communication reconfiguration 
result shortcomings reconfigurations constrained uses context free rules handle systems potentially infinite distinct configurations relationship reconfigurations computations complex quite apparent 
approach overcome disadvantages propose uniform algebraic framework program design language explicit state 
allows represent architectures reconfigurations explicitly relate computational architectural level direct simple way 
hand language incorporates usual programming constructs keeping simple syntax formally tractable 
precise components written unity language consist set commands assignments typed attributes 
attributes explicit initialisation conditions state component usual set pairs attribute value 
algebraic framework category theory benefits sa 
graphical notation independent language represent components able relate different languages allows formalisation connectors construction 
represent architectures labelled graphs showing components interconnections 
additionally categorical framework provides semantics operation transforms architectural diagram equivalent component representing system computations performed 
relates architectural computational levels 
reconfiguration specified algebraic graph rewriting formalism years research theory application 
representation components approach guarantees components removed quiescent state interacting components introduced properly initialized state 
self contained accessible wider audience written informal way mathematical definitions sparingly 
needed algebraic notions briefly introduced 
facilitate exposition second part deals reconfigurations performed system shut third part incorporates notion state order deal reconfigurations coordinated going computations 
example example inspired distribution system illustrate mobile unity 
carts move units long track shape cart advances unit step direction shown arrows 
th cart starts unit determined injective function start carts continuously moving circuit 
movement synchronised way collisions occur crossing 
assume track units cross 
reconfigurations may due mobility component upgrade cart may replaced builtin lap counter 
category theory category theory mathematical discipline studies general way relationships arbitrary entities 
category collection objects collection morphisms pairs objects 
morphism source object target object written morphisms come equipped composition operator composition associative identities ida object diagrams directed graphs nodes denote objects arcs represent morphisms represent complex objects configurations smaller ones 
categories behaved configuration denotes object retrieved operation diagram called colimit 
informally colimit diagram returns minimal object morphism object diagram colimit contains objects diagram components addition morphisms original configuration results commutative diagram interconnections established morphisms configuration diagram enforced 
pushouts colimits diagrams form definition colimit pushout returns object diagram exists commutes 
furthermore pushout candidate unique morphism ensures component object conditions minimal 
object called pushout complement diagram graph transformation algebraic approach graph transformation introduced years ago order generalize grammars strings graphs 
necessary adapt string concatenation graphs 
approach algebraic gluing graphs done pushout appropriate category 
main variants double pushout approach single pushout approach 

category objects labelled graphs morphisms total maps nodes arcs preserve labels structure graph transformation rule called graph production simply diagram form left hand side graph right hand side graph interface graph injective graph morphisms 
rule states graph transformed common subgraph nodes arcs deleted rule 
example rule substitutes arc 
graphs written dotted boxes improve readability 
nodes arcs numbered uniquely graph show mapping done morphisms 
production applied graph left hand side matched graph morphism direct derivation exists diagram constructed square pushout 
intuitively pushout complement obtained deleting nodes arcs appear obtained adding nodes arcs appear fact injective guarantees unique 
example derivation previously production direct derivation possible match obeys conditions 
production removes node arc incident image arc attached second production removes node arc maintains may map node arc conditions quite intuitive 
prevents dangling arcs second avoids contradictory situations 
allow unambiguous prediction removals 
node removed context adjacent arcs nodes completely matched lefthand side production 
advantage production specifier control exactly contexts node deleted 
means possible remove node matter nodes linked 
single pushout approach simpler 
graph morphisms partial maps productions simply morphisms restriction derivations may unintuitive side effects 
approach allows removal nodes unknown contexts 
put differently production removes node remove automatically arcs incident designer having means prevent 
feel dynamic architecture reconfiguration preferable allow designer control precisely situations component node may removed 
reasons adopt double pushout approach 
community community program design language unity ip 
consider subset full language 
assume fixed algebraic data type specification 
specification types predefined functions 
programs purposes community program consists set typed attributes boolean expression satisfied initial values attributes set actions form name guard assignment 
empty set assignments denoted skip 
step actions selected guard true assignments executed simultaneously 
precise syntactically program form prog write read init exp exp 
exp 
external attributes program may change values local attributes initialisation condition ai actions boolean expressions gi wij expressions values external attributes environment may change step 
program describes behaviour th cart introduced section 
prog write int init start move true mod henceforth abbreviate mod omit action guards true 
superposition morphism program program states component system shown captures notion program superposition 
mathematically speaking morphism maps attribute attribute type local attributes component mapped local attributes system maps action name possible empty set action names 

actions correspond different possible behaviours system different behaviours usually result synchronisations actions components action preserve functionality possibly adding things specific components particular guard weaker guard assignments contained putting succinct way morphism maps vocabulary vocabulary expression attributes automatically translated expression attributes action exp mapped set actions exp 
implying 
easy see component relationship established mappings attributes actions described reflexive transitive 
programs superposition morphisms constitute category 
continuing example diagram shows way program superposed counter checks cart passes start position 
notice second program strengthens initialisation condition divides action move sub cases satisfying condition 
prog 
move move pass location prog write location laps int init location start laps pass location start location location laps laps move location start location location configurations interactions programs established action synchronisation memory sharing 
achieved relating relevant action attribute names interacting programs 
category theory relationships objects explicit morphisms 
particular case community programs means example attributes actions unrelated programs different name 
state attribute action program attribute resp 
action needs third mediating program channel containing just attribute resp 
action morphisms pi map ai 
general channel contains features shared programs linked establishing symmetrical partial relationship vocabularies programs 
precise channel just degenerate program provides basic interaction mechanisms synchronisation memory sharing programs adds attributes computations 
channel form prog read true skip abbreviated notation disciplined channels establish interactions problems arise synchronised actions update shared attribute distinct ways 
actions change values local attributes sufficient impose local attributes shared directly single channel indirectly sequence channels 
restriction forces interactions programs synchronous communication values local attributes acting output ports external attributes input ports general mode interaction suitable modular development reusable components needed architectural design 
call diagrams satisfy conditions configurations 
order cater architectures obtained application connectors section replacement components specialized ones section configuration program isolated connected channels exactly programs specialisation programs diagram take advantage graphical nature diagrams simple intuitive formal definition straightforward efficient implementation 
define data view diagram programs superposition morphisms directed graph node pi aij attribute aij program pi occurring diagram arc node pi aij pk akl morphism diagram mapping aij akl 
diagram wellformed data view undirected path nodes corresponding local attributes directed path 
represents formally intuitive idea programs may share local attributes sub program 
stated section diagram directed labelled graph possible compute vertex number incoming outgoing edges called indegree outdegree respectively 
configuration formed diagram node channel indegree zero outdegree program outdegree zero configuration example 
efficient check diagram configuration 
notice due restriction outdegree programs data view local attribute outgoing arc easy see directed path 
find union algorithm compute efficiently connectivity attributes actual non directed paths irrelevant 
proved finite configuration colimit definition returns minimal program contains programs diagram 
proof constructive configuration compiled single program simulates execution system 
precisely colimit obtained disjoint union attributes modulo shared attributes disjoint union actions modulo synchronized ones conjunction initialisation conditions 
actions synchronized conjunction guards parallel composition assignments 
example provided section 
architectures ary connector consists roles ri glue stating interaction roles 
act formal parameters restricting components may linked connector 
roles may contain attributes actions interaction specification 
likewise glue may contain attributes actions visible roles 
glue role share part vocabulary 
applying notion channel connectors role ri channel ci morphisms ci ci ri stating attributes actions ri interaction specification glue 
connector seen extension channel complex interactions require additional computations 
connector represented specific kind configuration 
returning example assume carts approaching crossing nearer 
avoid collision sufficient force nearest cart move distant 
achieved action subsumption connector 
action subsumes action executes 
seen partial synchronisation mechanism synchronised execute freely 
connector establishes form interaction glue roles far near 
notice roles isomorphic binary connector symmetric glue treats actions differently 
clearly indicated glue may executed time occur interaction place 
action want connect move action cart away move prog far write fl int move fl fl fl move move prog cart 
ab prog ab skip skip fl move ab prog carts write fl nl int init fl start nl start ab fl fl nl nl nl nl ab move prog near write nl int move nl nl nl ab move move move nl prog cart 
fig 

applied action subsumption connector colimit crossing action associated movement nearest cart instantiate role near 
categorical framework allows precise ary connector applied components 
pn morphisms ri pi exist 
corresponds intuition actual arguments components instantiate formal parameters roles 
architecture configuration components programs interact connectors roles instantiated 
follows architecture semantics colimit 
proceeding action subsumption connector roles omit initialisation condition location attribute instantiated particular cart 
shows simple architecture consisting application connector carts assuming nearer crossing resulting colimit 
reconfiguration diagram category graph nodes labelled objects category arcs labelled morphisms algebraic graph transformation approach directly applied architecture reconfiguration 
reconfiguration rule simply graph production left hand side interface right hand side architectures 
reconfiguration step direct derivation architecture architecture algebraic graph transformation approach restriction obtained graphs reconfiguration check result architecture rule match applicable 
example separate connector addition rules may correct applying may yield non architecture see unary connector example previous section 
returning example want add counter cart matter connectors currently linked just program morphism shown section community state fairly easy extend previous definitions order take program state account permitting specification dynamic reconfiguration 
add fixed set typed variables algebraic data type specification 
language terms terms defined usual variables function symbols data type specification 
remaining assume int 
program instances program instance defined program valuation function terms assigns local attribute term sort 
explanations order 
valuation may return arbitrary term just ground term 
running system value attribute ground term need variables able write rules left hand sides match components possibly infinite distinct combinations values attributes 
second point worth noticing terms assigned external attributes 
contrasts previous approach reasons 
pragmatic external attribute local attribute component need duplicate specification value 
conceptual reason way represent state direct control component 
absence external attributes values clear may change moment 
technical reason 
reconfigurations change connectors components 
entails external attribute may shared different local attribute different component 
external attributes explicitly represented state reconfiguration rule change state 
possible graph morphisms change labelling program instances 
consequence choice application rule depends value external attribute left hand side include component containing local attribute provides value 
may drawback requiring user write complex rule necessary benefit forces rule applied behaved states architecture value attribute control system environment 
represent program instances tabular form 
example assuming abs returns absolute value integer location start laps abs represents cart completed lap complete step 
instance morphisms morphism program instances simply superposition morphism preserves state 
precise superposition morphism algebraic data type axioms entail local attribute variable substitution 
terms variables relationships attributes maintained example section program instance start architecture instances location move move pass location start laps abs obvious program instances morphisms form category equality terms reflexive transitive 
diagram transformed diagram category programs superposition morphisms just omitting valuation function 
definitions configuration instance connector instance architecture instance trivial extensions sections 
means architecture instance formed different local attributes conflicting valuations 
architecture instance colimit colimit underlying architecture union valuations architecture instance 
dynamic reconfiguration dynamic reconfiguration basically rewriting process graphs labelled program instances architecture instances just programs 
ensures state components connectors affected rule change labels preserved keeping reconfiguration computation separate 
guarantee new components added precisely determined state order able perform computations right away 
purpose require variables occurring right hand side rule occur left hand side 
furthermore dynamic reconfiguration rules depend current state 
conditional rewrite rules proposition variables algebraic graph transformation framework possible define conditional rules uniform way graphs graph morphisms 
representation components simpler practical formal point view represent conditions boolean expressions state variables 
returning example avoid collisions give rule applies action subsumption connector carts units away crossing fl ab far fl move move move ab move near nl move move fl graph morphisms obvious 
opposite rule negated condition necessary remove connector longer needed 
definition reconfiguration step changed accordingly 
point time current system architecture instance valuations return ground terms 
notion matching involve compatible substitution variables occurring rule ground terms 
applying substitution rule obtain rule variables directly applied current architecture normal definition derivation double pushout labelled graphs 
notion state introduces constraints 
substitution obviously satisfy application condition 
second derivation sure state program instance added right hand side satisfies respective initialisation condition 
complete definition follows 
rule architecture instance substitution variables ground terms reconfiguration step obtains direct derivation rule match true program instance true 
example added subsumption connector initialisation conditions glue roles possible prove rule introduce program instances valid initial state substitution 
run time check reconfiguration step unnecessary leading efficient implementation 
final example dynamic reconfiguration alternative way adding counter cart 
rule replaces cart program program superposing section 
location laps notice double pushout approach guarantees cart replaced connected component 
important conceptual reasons components removed interactions technical ones dangling roles 
notice rule allows description transfer state old new component 
case just copy value general right hand side may contain arbitrarily complex terms calculate new values old ones 
drawback replacement rule connectors applied directly programs just cart programs 
new version subsumption connector addition rule node labels laps cart necessary 
example rule section preferable cases morphism replaced replacing component new component superposition old substitution rule solution 
coordination architecture instance just labelled graph diagram precise semantics colimit 
formally define computation step system performed colimit propagated back components architecture inverse morphisms colimit 
keeps state program instances architectural diagram consistent state colimit ensures point time correct conditional rules applied 
adopt twophase approach computation step followed dynamic reconfiguration sequence 
way specification components simpler guaranteed necessary interconnections place soon required state components 
example cart simply moves forward concern location 
guarantee action subsumption connector exist necessary cart aware surroundings sure collide cart 
program complex 
reconfigurations occur frequently worth computing explicitly colimit 
community programs suffices compute disjoint unions sets attribute names assignments propositions guards condition efficient methods exist 
computation steps performed directly architecture instance 
simply choose action component check guard 
false computation step terminates 
follow morphisms find actions synchronised checking guard finding action 
actions true guards assignments executed 
evaluation guards assignments may depend external variables useful keep equivalence classes attributes computed algorithm data view 
way external attribute efficient see local attribute holds value 
efficiency gain obtained computing data view parallel reconfiguration process reconfiguration rule induces rewrite rule data view graph 
concluding remarks presents algebraic foundation relevant software engineering practice reconfiguration software architectures 
formalisms strive expressivity conceptual elegance including simplicity uniformity suitability implementability 
think approach strikes better balance previous 
category theory software architectures reconfiguration represented graphical mathematical rigorous way level abstraction resulting uniform framework 
furthermore computations reconfigurations kept separate related explicit simple direct way colimit construction 
program design language higher level abstraction process calculi term rewriting allowing intuitive representation program state computations 
illustrated community framework applicable language usual notion state categorical semantics 
fact definitions dynamic reconfiguration rule program instance build just language dependent notions program superposition channel data view 
approach suitable formalise common problems transferring state replacement removing components quiescent state adding components properly initialized 
handled specification aspects 
adapt temporal logic developped community order reason reconfiguration process 
implement framework rewriting logic implementation integrating library community tool developped 
ant nia lopes narciso mart oliet anonymous reviewers helpful comments 

allen douence garlan 
specifying analyzing dynamic software architectures 
fundamental approaches software engineering volume lncs pages 
springer verlag 

canal 
specification refinement dynamic software architectures 
editor software architecture pages 
kluwer academic publishers 

chandy misra 
parallel program design foundation 
addison wesley 

clavel eker lincoln meseguer 
principles maude 
proceedings international workshop rewriting logic volume electronic notes theoretical computer science pages 
elsevier 

corradini montanari rossi ehrig heckel 
algebraic approaches graph transformation part basic concepts double pushout approach 
technical report tr university pisa mar 

description technology clusters 
acm sigsoft software engineering notes sept 


language implementing generic dynamic reconfigurations distributed programs 
proceedings th brazilian symposium computer networks pages 

fiadeiro lopes 
semantics architectural connectors 
proceedings tapsoft volume lncs pages 
springer verlag 

fiadeiro maibaum 
interconnecting formalisms supporting modularity reuse incrementality 
sigsoft third symposium foundations software engineering pages 
acm press 

fiadeiro maibaum 
mathematical toolbox software architect 
proceedings th international workshop software specification design pages 
ieee computer society press 

fiadeiro maibaum 
categorial semantics parallel program design 
science computer programming 

fiadeiro meseguer 
semantics transient connectors rewriting logic 
position working international conference software architecture feb 

francez forman 
interacting processes 
addison wesley 

habel heckel taentzer 
graph grammars negative application conditions 
fundamenta informaticae 

hirsch inverardi montanari 
modelling software architectures styles graph grammars constraint solving 
editor software architecture pages 
kluwer academic publishers 

kramer magee 
evolving philosophers problem dynamic change management 
ieee transactions software engineering nov 

kramer magee 
analysing dynamic change software architectures case study 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press 

lopes fiadeiro 
explicit state describe architectures 
proceedings fundamental approaches software engineering number lncs pages 
springer verlag 


algebraic approach graph transformation single pushout derivations 
technical report technische universit berlin 

magee kramer 
dynamic structure software architectures 
proceedings fourth acm sigsoft symposium foundations software engineering pages 
acm press 

mccann 
roman 
compositional programming abstractions mobile computing 
ieee transactions software engineering feb 

medvidovic 
adls dynamic architecture changes 
joint proceedings sigsoft workshops pages 
acm press 

medvidovic 
classification comparison framework software architecture description languages 
technical report uci ics department information computer science university california irvine feb 

tayer 
describing software architecture styles graph grammars 
ieee transactions software engineering july 

mitchell 
foundations programming languages 
mit press 

monroe garlan 
acme nov 


issues runtime modification software architectures 
technical report uci ics tr department information computer science university california irvine aug 

perry 
state art software architecture 
proceedings th international conference software engineering pages 
acm press 
slides available www com user dep swa icse vg ps gz 


roman mccann 
mobile unity reasoning specification mobile computing 
acm july 

sedgewick 
algorithms 
addison wesley second edition 

taentzer meyer 
dynamic change management distributed graph transformation configurable distributed systems 
proc 
th int 
workshop theory application graph transformation 


hierarchic architecture model dynamic reconfiguration 
proceedings second international workshop software engineering parallel distributed systems pages 
ieee computer society press 


chemical model software architecture reconfiguration 
iee proceedings software oct 

fiadeiro 
connectors mobile programs 
ieee transactions software engineering may 

fiadeiro 
algebra architectural connectors case study synchronization mobility 
proceedings ninth international workshop software specification design pages 
ieee computer society press 

wolf 
second international software architecture workshop 
acm sigsoft software engineering notes jan 


colimit library graph transformations algebraic development techniques 
phd thesis technische universit berlin 
