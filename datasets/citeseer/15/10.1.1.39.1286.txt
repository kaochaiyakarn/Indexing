heartbeat timeout free failure detector quiescent reliable communication marcos aguilera wei chen sam toueg department computer science upson hall cornell university ithaca ny usa 
aguilera sam cs cornell edu may study problem achieving reliable communication quiescent algorithms algorithms eventually sending messages process crashes lossy links 
show impossible solve problem failure detectors 
show solve new failure detector called heartbeat 
contrast previous failure detectors circumvent impossibility results heartbeat failure detector implementable implementation timeouts 
results wide applicability transform existing algorithms tolerate process crashes quiescent algorithms tolerate process crashes message losses 
applied consensus atomic broadcast set agreement atomic commitment heartbeat failure detector novel implementable timeouts output lists suspects typical failure detectors 
restrict failure detectors output lists suspects quiescent reliable communication requires act implementable 
combined results shows traditional failure detectors output lists suspects fundamental limitations 
motivation introduces heartbeat failure detector implemented timeouts shows solve problem quiescent reliable communication asynchronous message passing systems process crashes lossy links 
illustrate problem consider processes sender receiver connected asynchronous bidirectional link 
process wishes send message suppose process may crash link may lose messages directions 
put restrictions message losses obviously impossible ensure receives assumption commonly circumvent problem link fair message sent infinitely received infinitely 
link repeatedly send copies forever guaranteed eventually receive impractical stops sending messages 
obvious fix protocol sends copy repeatedly receives ack receipt sends ack back note protocol quiescent eventually process sends receives messages 
research partially supported nsf ccr arpa onr olin fellowship 
situation changes addition message losses process crashes may occur 
protocol works quiescent anymore example crashes sending ack send copies forever 
quiescent protocol ensuring crashes eventually receives 
turns answer assumes link lose finite number messages 
process crashes message losses common types failures negative result obstacle design fault tolerant distributed systems 
explore unreliable failure detectors circumvent obstacle 
roughly speaking unreliable failure detectors provide possibly erroneous hints operational status processes 
process query local failure detector module provides information processes crashed 
information typically form list suspects 
general failure detectors mistakes process crashed necessarily suspected process may suspected crashed 
local lists suspects dynamically change lists different processes agree eventually agree 
introduced ct abstraction unreliable failure detectors solve important problems consensus atomic broadcast group membership non blocking atomic commitment leader election bdm gue lh sm 
goal unreliable failure detectors achieve quiescence address important question 
note reasonable implementation failure detector message passing system quiescent process monitored failure detector periodically send message indicate alive forever stops sending messages distinguished process crashed 
failure detectors quiescent sense tool achieve quiescent applications quiescent reliable broadcast consensus group membership 
answer reasons 
failure detector intended basic system service shared applications lifetime system cost amortized applications 
second failure detection service needs active forever natural sends messages forever 
contrast applications single rpc call reliable broadcast single message send messages forever quiescent 
conflict goal achieving quiescent applications non quiescent failure detection service tool achieve goal 
unreliable failure detector achieve quiescent reliable communication presence process link failures 
consider eventually perfect failure detector ct 
intuitively satisfies properties process crashes time permanently suspected process crash time suspected 
obvious algorithm solves sender receiver example received ack periodically queries sends copy currently suspected receipt sends ack back note algorithm quiescent eventually process sends receives messages 
act aguilera show failure detectors output lists suspects weakest solve problem 
unfortunately implementable asynchronous systems process crashes violate known impossibility result flp ct 
glance achieving quiescent reliable communication requires failure detector implemented 
show 
see cht concept weakest failure detectors 
heartbeat failure detector show quiescent reliable communication achieved failure detector implemented timeouts systems process crashes lossy links 
failure detector called heartbeat denoted hb simple 
roughly speaking failure detector module hb process outputs vector counters neighbor neighbor crash counter increases bound 
crashes counter eventually stops increasing 
basic idea implementation hb obvious process periodically sends am alive message heartbeat process receiving heartbeat increases corresponding counter 
note hb timeouts heartbeats process order determine process failed 
hb just counts total number heartbeats received process outputs raw counters processing interpretation 
hb confused existing implementations failure detectors ensemble phoenix modules called heartbeat vr cha 
existing failure detectors repeated sending heartbeat timeouts heartbeats order derive lists processes considered applications see lists 
contrast hb simply counts heartbeats shows counts applications 
order regarding practicality hb 
mentioned hb outputs vector unbounded counters 
practice unbounded counters problem reasons 
local memory messages hb implementations bounded messages quite short 
second bound local counter bits assume rate heartbeat orders magnitude higher currently practice hb years 
hb solve problem quiescent reliable communication implementable counters unbounded 
solve problem failure detector implementable bounded output 
act proves answer weakest failure detector bounded output solve quiescent reliable communication difference hb output unbounded existing failure detectors output bounded skin deep 
results combined act show failure detectors bounded output including output lists processes restricted power applicability 
outline results focus types reliable communication mechanisms quasi reliable send receive reliable broadcast 
roughly speaking pair send receive primitives quasi reliable satisfies property processes correct crash receives message exactly times sent message reliable broadcast ht ensures correct process broadcasts message correct processes deliver correct processes deliver set messages 
show quiescent implementation quasi reliable send receive reliable broadcast network process crashes message losses 
holds assume links lose finite number messages 
show failure detectors circumvent impossibility result 
describe failure see types networks actual implementation entirely trivial 
simple network case general network case link fair link fair examples simple general network cases detector hb show strong achieve quiescent reliable communication weak implementable types communication networks 
types networks assume correct process connected correct process fair path path containing fair links correct processes 
type links bidirectional fair fig 

second links unidirectional links restrictions message losses fair fig 

examples networks networks contain unidirectional rings intersect 
network type describe quiescent protocols hb solve quasi reliable send receive reliable broadcast show implement hb 
type networks common practice implementation hb reliable communication protocols simple efficient 
algorithms second type significantly complex 
briefly consider stronger types communication primitives reliable send receive uniform reliable broadcast give quiescent implementations hb 
implementations assume majority processes correct result shows assumption necessary 
explain hb easily transform existing algorithms tolerate process crashes quiescent algorithms tolerate process crashes message losses fair links 
transformation applied algorithms consensus ben rab bt cms fm ct atomic broadcast ct set agreement cha atomic commitment gue approximate agreement dlp show hb extend obtain result 
problem 
suppose correct restricted specification refers behavior correct processes majority processes correct 
solvable quiescent protocol tolerates process crashes solvable quiescent protocol tolerates process crashes message losses 
summarize main contributions assumption precludes permanent network partitioning 
link failure model slightly different cf 
section 

explores unreliable failure detectors achieve quiescent reliable communication presence process crashes lossy links problem solved failure detection 

describe simple implementable failure detector hb solve problem 

hb extend existing algorithms fundamental problems consensus atomic broadcast set agreement atomic commitment approximate agreement tolerate message losses 
extend results 

hb novel implementable timeouts output lists suspects typical failure detectors bdm ct gue gls lh sm 
results combined act show lists suspects best failure detector output 
reliable communication fundamental problem extensively studied especially context data link protocols see chapter lyn compendium 
differs previous results focusing unreliable failure detectors achieve quiescent reliable communication presence process crashes link failures 
basu closest protocols failure detectors quiescent 
section hb extend results obtain quiescent protocols 
organized follows 
model section 
section defines reliable communication primitives focus 
section show failure detectors quiescent reliable communication impossible 
overcome problem define heartbeat failure detectors section show achieve quiescent reliable communication section show implement section 
section consider stronger types communication primitives 
section explain heartbeat failure detectors extend previous results 
section mention generalization results case network may partition 
brief discussion protocol quiescence versus protocol termination concludes 
model consider asynchronous message passing distributed systems timing assumptions 
particular assumptions time takes deliver message relative process speeds 
processes communicate sending messages network 
assume network completely connected links bidirectional 
system experience process failures link failures 
processes fail crashing links fail dropping messages 
simplify presentation model assume existence discrete global clock 
merely fictional device processes access 
take range clock ticks set natural numbers 
processes process failures system consists set processes ng 
processes fail crashing prematurely halting 
failure pattern function denotes set processes crashed time process crashes recover 
define authors cht anticipated possibility put restrictions output unreliable failure detectors determine weakest necessary solve consensus 
crashed correct gamma crashed 
crashed say crashes faulty correct say correct links link failures pairs processes network connected unidirectional links 
link process process denote link addition say neighbor set neighbors denoted neighbor 
link associate primitives send receive 
say process sends message process invokes send 
assume correct eventually returns invocation 
allow process send message link 
say process receives message process returns execution receive 
describe link properties send receive primitives satisfy 
assume links create messages link network satisfies ffl integrity receives times previously sent times 
lossy link fail dropping messages 
link fair send receive satisfy integrity ffl fairness correct sends infinite number times receives infinite number times 
network connectivity path fair processes correct links gamma fair 
assume pair distinct correct processes connected fair path 
loss generality assume path simple process appears twice path 
failure detectors process access local failure detector module provides possibly incorrect information failure pattern occurs execution 
process query local failure detector module time 
failure detector history range function theta output value failure detector module process time failure detector function maps failure pattern set failure detector histories range rd rd denotes range failure detector outputs 
denotes set possible failure detector histories permitted failure pattern stress output failure detector depends failure pattern depend behavior applications 
means failure detectors obtain feedback applications applications transmit information manner 
example consider strong failure detector ct 
failure detector module outputs set processes suspected crashed rd satisfies properties ffl strong completeness eventually process crashes permanently suspected correct process 
precisely crashed correct ffl weak accuracy correct process suspected 
precisely correct gamma class failure detectors satisfy properties denoted class failure detectors 
algorithm solves problem solve problem algorithm implements implements quiescent reliable communication focus quasi reliable send receive reliable broadcast communication primitives sufficient solve problems see section 
briefly consider stronger types communication primitives reliable send receive uniform reliable broadcast section 
quasi reliable send receive consider distinct processes define quasi reliable send receive terms primitives send receive satisfy integrity property ffl quasi loss correct sends exactly times receives times 
note quasi loss integrity implies correct sends exactly times receives exactly times 
want implement quasi reliable send receive primitives lossy send receive primitives provided network 
order differentiate set primitives henceforth denoted send receive second send receive 
informally implementation send receive quiescent finite number invocations send cause finite number invocations sends network 
reliable broadcast reliable broadcast bt defined terms primitives broadcast deliver 
say process broadcasts message invokes broadcast 
assume broadcast message includes fields identity sender denoted sender sequence number denoted seq 
fields message unique 
say delivers message returns invocation deliver 
primitives broadcast deliver satisfy properties ht ffl validity correct process broadcasts message eventually delivers ffl agreement correct process delivers message correct processes eventually deliver ffl uniform integrity message process delivers previously broadcast sender 
stronger property called loss section define reliable send receive 
process execute broadcast deliver neighbor send return receive previously executed deliver deliver neighbor send quiescent implementation reliable broadcast quiescent implementation send receive primitives neighbors want implement reliable broadcast lossy send receive primitives provided network 
informally implementation reliable broadcast quiescent finite number invocations broadcast cause finite number invocations sends network 
relation reliable broadcast quasi reliable send receive quiescent implementation quasi reliable send receive easily obtain quiescent implementation reliable broadcast vice versa 
quiescent implementation reliable broadcast obtain quiescent implementation quasi reliable primitives send receive pair processes implementation trivial send message simply broadcasts message quiescent implementation reliable broadcast sender seq sequence number 
delivery process receives discards 
implementation send receive clearly correct quiescent 
suppose pair correct processes connected path correct processes 
quiescent implementation quasi reliable primitives send receive processes neighbor obtain quiescent implementation reliable broadcast 
implementation reliable broadcast simple flooding algorithm taken ht code consisting lines executed atomically 
clear implementation quiescent 
message invocation broadcast cause gamma invocations send process 
implementation send quiescent invocation send causes finite number invocations sends 
finite number invocations broadcast causes finite number invocations sends 
process executes region code atomically time thread region 
impossibility quiescent reliable communication quiescent reliable communication achieved network process crashes message losses 
holds network completely connected finite number messages lost processes access strong failure detector 
theorem consider network pair processes connected fair link process may crash 
distinct processes 
quiescent implementation quasi reliable send receive holds assume finite number messages lost implementation proof sketch 
assume contradiction exists quiescent implementation quasi reliable send receive construct runs may send message process invokes send 
run sends messages processes correct messages received time unit sent failure detector behaves perfectly process suspects process 
quiescent time messages sent received 
integrity property send receive process receives message 
run identical run time time sends crashes time processes crash messages received time unit sent times failure detector behaves perfectly suspected processes time suspicions 
quiescent time messages sent received 
run failure detector module behave exactly run particular crash receives message receives processes failure detector modules behave exactly run particular process receives message receives 
note messages sent time received 
show send receive primitives satisfy integrity property 
assume process receives process times 
cases 
receives times behaves way 
integrity property send receive sent times 
happens time sends time note time behaves exactly way sent times time 
receives times behaves way 
integrity property send receive sent times 
happens time crashes time time behaves exactly way sent times time 
receives times behaves way 
integrity property send receive sent times 
note behaves exactly way sent times send receive primitives satisfy integrity property 
show send receive primitives satisfy fairness property fact finite number messages lost 
note sends finite number messages send messages time process sends finite number messages send messages time 
construction processes send finite number messages finite number messages lost send receive primitives satisfy fairness property 
show failure detector satisfies properties strong failure detector 
crashes strong completeness holds vacuously exists process suspected process weak accuracy holds 
conclude possible run network fair links lose finite number messages 
note correct sends receive violates quasi loss property send receive implementation send receive contradiction 
theorem immediately imply corollary quiescent implementation reliable broadcast implementation overcome impossibility results introduce heartbeat failure detector 
definition hb heartbeat failure detector features 
output process list neighbors nonnegative integer 
intuitively increases crashed stops increasing crashes 
say heartbeat value output time regarded vector indexed set fp heartbeat sequence sequence heartbeat values time increases 
satisfies properties ffl hb completeness correct process heartbeat sequence faulty neighbor bounded 
formally correct crashed neighbor ffl hb accuracy process heartbeat sequence neighbor nondecreasing 
formally neighbor correct process heartbeat sequence correct neighbor unbounded 
formally correct correct neighbor class heartbeat failure detectors denoted hb 
slight abuse notation hb refer arbitrary member class 
easy generalize definition hb failure detector module process outputs heartbeat process system act just heartbeats neighbors need generality 
quiescent reliable communication hb communication networks consider necessarily completely connected assume pair correct processes connected fair path 
consider simple type networks link assumed bidirectional fair fig 

assumption common practice allows give efficient simple algorithms 
drop assumption treat general type networks links may unidirectional fair fig 

network types give quiescent reliable communication algorithms hb 
algorithms feature processes need know entire network topology number processes system need know identity neighbors 
algorithms denotes current output failure detector process simple network case assume links network bidirectional fair fig 

give quiescent implementation quasi reliable send receive case neighbor see fig 

send message process forks task repeat send seq seq fresh sequence number returns send 
task repeat send seq runs background repeatedly send msg seq msg tag 
send occurs time queries failure detector module notices heartbeat value increased 
task repeat send terminates receives ack seq sent time receives msg seq 
process receives time receives msg seq 
code consisting lines executed atomically code consisting lines 
concurrent executions repeat send task lines execution private copy local variables task seq hb prev hb show algorithm fig 
correct quiescent 
note variables local process 
ambiguities may arise variable local process subscripted hb local variable hb process lemma integrity receives times sent times 
proof 
note sn receives time receives msg sn receives times different values sn sn receives msg sn kg 
integrity property send receive sends msg sn receives msg sn send occur line task repeat send sn 
kg task repeat send sn forked invocation send invocation forks task repeat send 
sent times 
message consider run invokes send exactly times 
associate sequence number sn th invocation send follows sn value global variable seq line executed th invocation 
note sn sn invocation send global variable seq increased decreased 
model means link network link network 
words neighbor neighbor 
crashes th invocation executing line sn equal plus value global variable seq time invocation 
process initialization seq seq current sequence number execute send seq seq fork task repeat send seq return task repeat send seq prev hb gamma repeat periodically hb query heartbeat failure detector prev hb hb send msg seq prev hb hb receive ack seq process receive msg seq time receives msg seq receive send ack seq simple network case quiescent implementation send receive hb neighbor lemma quasi loss correct sends exactly times receives times 
proof 
suppose contradiction receives times 
notice receives time receives message form msg receive 
sn sequence number associated th invocation send 
sn distinct kg msg sn received sequence number associated unique message sends ack sn receives msg sn 
conclude sends ack sn integrity property send receive receives ack sn invokes send th time forks task repeat send repeatedly send msg sn task referred task task terminates crashes receives ack sn loop lines task repeated infinitely 
correct hb accuracy property guarantees heartbeat sequence nondecreasing unbounded condition line evaluates task true infinite number times 
sends msg sn infinite number times 
fairness property send receive receives msg sn contradiction 
show implementation fig 
quiescent 
order focus single invocation send show causes finite number invocations sends 
immediately implies finite number invocations sends cause finite number invocations sends 
consider particular invocation send sn sequence number associated clear crash causes invocations send msg sn task repeat send sn 
receives msg sn invokes send ack sn 
may cause invocations send ack sn clear cause invocations sends 
send caused send msg sn send ack sn 
show sends msg sn finite number times sends ack sn finite number times 
implies causes finite number sends 
lemma sends msg sn infinite number times sends ack sn infinite number times 
proof 
sends msg sn infinite number times correct condition line evaluates true infinite number times 
heartbeat sequence unbounded 
hb completeness correct 
fairness property send receive receives msg sn infinite number times 
sends ack sn time receives msg sn sends ack sn infinite number times 
conversely sends ack sn infinite number times receives msg sn infinite number times integrity property send receive sends msg sn infinite number times corollary sends msg sn finite number times 
proof 
contradiction suppose sends msg sn infinite number times 
sends ack sn infinite number times lemma 
fairness property send receive eventually receives ack sn condition line task repeat send sn true 
task repeat send sn eventually terminates sends msg sn finite number times contradiction 
corollary sends ack sn finite number times 
proof 
lemma corollary 
lemma algorithm fig 
quiescent 
proof 
corollaries remarks lemma 
lemmata theorem simple network case neighbor fig 
quiescent implementation quasi reliable send receive uses hb 
theorem remarks corollary simple network case quasi reliable send receive pair processes reliable broadcast implemented quiescent algorithms hb 
general network case case fig 
links may unidirectional network may contain unidirectional rings intersect 
links may fair processes know ones fair 
achieving quiescent reliable communication type network significantly complex 
instance suppose seek quiescent implementation quasi reliable send receive 
order sender send message receiver diffusion mechanism neighbor link may unfair 
intermittent message losses diffusion mechanism needs ensure repeatedly sent fair links 
repeated send 
possibility mechanism 
unfortunately link reverse direction may fair may part network reliably diffused chicken egg problem 
shows quiescent implementation reliable broadcast obtain quasi reliable send receive pair processes 
message broadcast process maintains variable got containing set processes 
intuitively process got evidence delivered order broadcast message delivers initializes variable got fpg forks task diffuse returns invocation broadcast 
task diffuse runs background 
task periodically checks neighbor got heartbeat increased sends message containing neighbors heartbeat increased got 
task terminates neighbors contained got 
messages sent algorithm form got msg path got msg set processes path sequence processes 
receipt message process checks delivered delivers forks task diffuse 
adds contents got msg got appends path 
forwards new message got msg path neighbors appear path code consisting lines executed atomically 
concurrent execution diffuse task lines private copy local variables task hb prev hb 
show implementation correct quiescent 
lemma uniform integrity message process delivers message previously broadcast sender 
proof sketch 
message process 
line guarantees delivers 
suppose process delivers line line 
case previously broadcast clearly sender 
second case received message form 
integrity property send receive message form previously sent 
easy induction shows happen previously broadcast sender 
lemma validity correct process broadcasts message eventually delivers proof 
correct process broadcasts eventually executes line delivers show process got delivered concerned initialization got takes place 
assume got initialized empty set start 
doing impractical set possible messages broadcast infinite 
may appear need send message processes got got 
reader verify optimization algorithm fail 
process execute broadcast deliver got fpg fork task diffuse return task diffuse neighbor prev hb gamma repeat periodically hb query heartbeat failure detector neighbor got prev hb hb neighbor prev hb hb send got prev hb hb neighbor got receive got msg path previously executed deliver deliver got fpg fork task diffuse got got got msg path path delta neighbor appears path send got path general network case quiescent implementation broadcast deliver hb process initializes got broadcasts see line hears see line 
guarantees got initialized 
establish invariants got keep mind invariants hold initialization occurred 
lemma processes time got got time got initialized got got delivered proof sketch 
clear algorithm follows integrity property send receive 
lemma path finite number distinct messages form path 
proof 
message form path equal path finite set 
lemma suppose link fair correct processes 
delivers message eventually delivers proof 
suppose contradiction delivers delivers delivers correct forks task diffuse 
deliver lemma part belongs got 
correct implies executes loop lines infinite number times 
correct neighbor hb accuracy property guarantees heartbeat sequence nondecreasing unbounded 
condition line evaluates true infinite number times 
executes line infinite number times sends message form infinite number times 
lemma exists subset sends message infinitely fairness property send receive eventually receives 
delivers contradicts assumption deliver lemma agreement correct process delivers message correct processes eventually deliver proof 
suppose correct process delivers correct process simple fair path successive applications lemma conclude eventually deliver eventually delivers show implementation fig 
quiescent 
order focus single invocation broadcast show causes finite number invocations sends 
implies finite number invocations broadcast cause finite number invocations sends 
message consider invocation broadcast 
invocation cause sending messages form 
need show process eventually stops sending messages form 
lemma correct process correct neighbor forks task diffuse eventually condition got holds forever 
proof 
lemma part need show eventually belongs got 
suppose contradiction belongs got 
simple fair path simple fair path 
note process appears claim gamma set containing fp sends infinite number times 
gamma claim fairness property send receive immediately implies eventually receives gamma gamma 
receipt message adds contents gamma variable got 
gamma contains contradicts fact belongs got 
show claim induction base case note belongs got neighbor executes loop lines infinite number times 
correct neighbor hb accuracy property guarantees heartbeat sequence nondecreasing unbounded 
condition line evaluates true infinite number times 
executes line infinitely 
correct neighbor heartbeat sequence nondecreasing unbounded sends message form infinite number times 
lemma sends infinite number times 
note lemma parts implies shows base case 
induction step suppose gamma sends infinite number times containing fp fairness property send receive receives infinite number times 
neighbor appears time receives sends message form easy see message contains lemma exists contains fp sends infinite number times 
corollary correct process forks task diffuse eventually stops sending messages task diffuse 
proof 
neighbor cases 
correct eventually condition got holds forever lemma 
faulty hb completeness property guarantees heartbeat sequence bounded eventually condition prev hb hb holds forever 
time guard line false 
eventually stops sending messages task diffuse 
lemma process sends message form path process appears twice path 
proof sketch 
line algorithm process sends message path process appears path 
result follows easy induction uses fact integrity property send receive 
lemma quiescence eventually process stops sending messages form 
proof 
suppose contradiction process stops sending messages form 
note correct 
lemma third component message form ranges finite set values 
path sends infinite number messages form path 
lemma sends infinite number messages path 
process process invokes send path infinite number times 
cases 
path empty immediately reach contradiction send empty path occur line line 
second case suppose path consists process path 
corollary shows time stops sending messages task diffuse 
invokes send task diffuse line infinite number invocations send path occurs line 
invocation occur receives message form path path gamma 
receives message form path infinite number times 
integrity property send receive infinite number sends message form lemma infinite number sends path exists correct process send path invoked infinite number times 
repeating argument gamma times conclude exist correct processes gamma send gamma path invoked infinite number times path empty 
lemmata theorem general network case fig 
quiescent implementation reliable broadcast uses hb 
theorem corollary general network case quasi reliable send receive pair processes implemented quiescent algorithm uses hb 
implementations hb give implementations hb types communication networks considered previous sections 
implementations timeouts 
process initialization neighbor cobegin jj task repeat periodically neighbor send heartbeat jj task receive heartbeat coend simple network case implementation hb simple network case assume links network bidirectional fair fig 

case implementation obvious 
process executes concurrent tasks fig 

periodically sends message heartbeat neighbors 
second task handles receipt heartbeat messages 
receipt message process increases heartbeat value prove implementation correct 
lemma hb completeness correct process heartbeat sequence faulty neighbor bounded 
proof 
obvious 
lemma process heartbeat sequence neighbor nondecreasing 
proof 
clear changed line 
lemma correct process heartbeat sequence correct neighbor unbounded 
proof 
neighbor links bidirectional neighbor 
correct task executes forever 
sends infinite number heartbeat messages fairness property send receive receives infinite number heartbeat messages time receives heartbeat increments line 
increments infinite number times 
lemma decremented 
heartbeat sequence unbounded 
corollary hb accuracy process heartbeat sequence neighbor nondecreasing correct process heartbeat sequence correct neighbor unbounded 
proof 
lemmata 
lemma corollary theorem simple network case fig 
implements hb 
process initialization neighbor cobegin jj task repeat periodically neighbor send heartbeat jj task receive heartbeat path neighbor appears path path path delta neighbor appear path send heartbeat path coend general network case implementation hb general network case case links may unidirectional fair fig 

implementation complex heartbeat diffused introduces problem process receives heartbeat message relay time receives message 
message new heartbeat originating process 
old heartbeat cycled network came back avoid relaying heartbeats 
implementation fig 

process executes concurrent tasks 
task periodically sends message heartbeat neighbors 
second task handles receipt messages form heartbeat path 
receipt message process increases heartbeat values neighbors appear path appends path forwards message heartbeat path neighbors appear path 
proceed prove correctness implementation 
lemma process heartbeat sequence neighbor nondecreasing 
proof 
clear changed line 
lemma correct process heartbeat sequence correct neighbor unbounded 
proof 
correct process correct neighbor simple fair path 
gamma claim sends heartbeat infinite number times 
show induction base case note correct task executes forever sends heartbeat neighbors infinite number times 
induction step gamma assume sends heartbeat infinite number times 
correct link fair receives heartbeat infinite number times 
appear neighbor time receives heartbeat sends heartbeat line 
sends heartbeat infinite number times 
shows claim 
gamma claim shows gamma sends heartbeat gamma infinite number times 
process correct link gamma fair receives heartbeat gamma infinite number times 
note neighbor gamma 
time receives heartbeat gamma increments line 
incremented infinite number times 
note lemma decremented 
heartbeat sequence unbounded 
corollary hb accuracy process heartbeat sequence neighbor nondecreasing correct process heartbeat sequence correct neighbor unbounded 
proof 
lemmata 
lemma process sends heartbeat path process path process appears twice path 
proof sketch 
follows lines simple induction uses integrity property send receive 
lemma processes path non empty sequence processes 
receives message heartbeat path delta infinite number times receives message heartbeat path infinite number times 
proof 
message heartbeat path delta message heartbeat path 
suppose receives infinite number times 
integrity property send receive process sends infinite number times 
lemma part length path delta send line 
sends receives receives infinite number times 
lemma hb completeness correct process heartbeat sequence faulty neighbor bounded 
proof sketch 
correct process faulty neighbor suppose heartbeat sequence bounded 
increments infinite number times 
infinite number times receives messages form heartbeat second component contains lemma part second component message form heartbeat ranges finite set values 
exists path containing receives heartbeat path infinite number times 
path 
integrity property send receive lemma part sends heartbeat path infinite number times 
contradicts fact faulty 
repeated applications lemma conclude receives message heartbeat infinite number times 
integrity property send receive lemma part sends heartbeat infinite number times 
contradicts fact faulty 
corollary lemma theorem general network case fig 
implements hb 
process initialization seq seq current sequence number execute send seq seq seq broadcast wait received ack processes return process deliver send ack receive quiescent implementation send receive stronger communication primitives quasi reliable send receive reliable broadcast sufficient solve problems see section 
stronger types communication primitives reliable send receive uniform reliable broadcast needed 
give quiescent implementations primitives systems process crashes message losses 
number processes may crash 
shows half processes may crash primitives implemented assume links may lose finite number messages require implementation quiescent 
show quiescent implementations primitives types network considered 
implementations give simple modular highly inefficient 
efficient ones obtained modifying algorithms figures 
assume 
reliable send receive process returns invocation send say completes sending message quasi reliable send receive possible completes sending crashes receives crash 
contrast reliable send receive primitives completes sending message correct process eventually receives crashes 
precisely reliable send receive satisfy integrity section ffl loss correct completes sending exactly times receives times 
loss quasi loss properties similar strong validity validity properties section ht 
process execute uniform broadcast broadcast return deliver send ack wait received ack processes uniform deliver quiescent implementation uniform reliable broadcast reliable send receive primitives denoted send receive 
send receive denote quasi reliable primitives 
shows quiescent implementation send receive code consisting lines executed atomically 
uses reliable broadcast send receive pair processes 
shown primitives quiescent implementations hb types network consideration 
roughly speaking wishes send broadcasts message contains fresh sequence number waits receive message returning invocation send 
process delivers broadcast message sends back receives proof correctness straightforward omitted 
uniform reliable broadcast agreement property reliable broadcast states correct process delivers message correct processes eventually deliver requirement allows faulty process subsequently crashes deliver message delivered correct processes 
behavior undesirable applications atomic commitment distributed databases gra bt 
applications stronger version reliable broadcast suitable uniform reliable broadcast satisfies uniform integrity validity section ffl uniform agreement nt process delivers message correct processes eventually deliver shows quiescent implementation uniform reliable broadcast uses reliable broadcast send receive pair processes 
proof correctness straightforward omitted 
hb extend previous hb extend previous order solve problems algorithms quiescent tolerant process crashes messages losses 
extending existing algorithms tolerate link failures hb transform existing algorithms tolerate process crashes quiescent algorithms tolerate process crashes message losses 
example consider randomized consensus algorithms ben rab cms fm failure detector ones ct probabilistic bt algorithms atomic broadcast ct set agreement cha atomic commitment gue approximate agreement dlp 
algorithms tolerate process crashes quasi reliable send receive reliable broadcast sole communication primitives 
algorithms tolerate process crashes message losses fair links simple steps implement hb described section plug quiescent communication primitives section 
resulting algorithms tolerate message losses quiescent 
extending results way solve problems quiescent algorithms tolerate process crashes message losses obtained extending results 
addresses question problem solved system possible failures process crashes problem solvable links fail losing messages 
models lossy links considered called fair lossy 
roughly speaking fair lossy link satisfies property sends infinite number messages correct receives infinite number messages fair lossy fair links differ subtle way 
instance process sends sequence distinct messages fair lossy guaranteed receive infinite subsequence fair may receive distinct message sent 
hand sends sequence fair lossy may receive copy receives infinitely fair guaranteed receive infinite number copies establishes result problem solved systems process crashes solved systems process crashes fair lossy links provided correct restricted majority processes correct 
cases shows transform algorithm solves system process crashes solves system process crashes fair lossy links 
algorithms result transformations quiescent transformation requires processes repeatedly send messages forever 
hb modify transformations ensure original algorithm quiescent transformed 
roughly speaking modification consists adding message suppressing sending message received message heartbeat increased time sent message modifying meaning operation append queue queue elements queue queue appended queue results combined modification show problem solved quiescent algorithm system crash failures correct restricted majority processes correct solvable quiescent algorithm uses hb system crash failures fair lossy links 
similar steps applied algorithms reliable send receive uniform reliable broadcast provided majority processes correct plugging implementations section 
message piggybacking overcome message losses 
avoid piggybacking adopted model fair links message losses overcome separately sending message repeatedly 
intuitively problem correct restricted specification refer behavior faulty processes gop bn 
generalization networks partition assumed pair correct processes reachable fair paths 
act drop assumption consider general problem quiescent reliable communication networks may partition 
particular generalize definitions quasi reliable send receive reliable broadcast generalize definition heartbeat failure detector implement networks may partition show failure detector achieve quiescent reliable communication networks 
act consider problem consensus networks may partition hb solve problem quiescent protocol generalization eventually strong failure detector ct 
quiescence versus termination considered communication protocols tolerate process crashes message losses focused achieving quiescence 
achieving termination 
terminating protocol guarantees process eventually reaches halting state take actions 
terminating protocol obviously quiescent converse necessarily true 
example consider protocol described section 
protocol sends copy repeatedly receives ack halts receipt sends ack back absence process crashes protocol quiescent 
protocol terminating halts remains forever ready reply receipt possible message hb obtain reliable communication protocols terminating 
answer systems process crashes 
follows result kt shows system message losses fair links process crashes terminating protocol guarantees knowledge gain 
acknowledgments grateful anindya basu hadzilacos having provided extensive comments improved presentation 
tushar deepak chandra suggesting name heartbeat 
act marcos aguilera wei chen sam toueg 
weakest failure detector achieve quiescence 
manuscript april 
act marcos aguilera wei chen sam toueg 
quiescent reliable communication quiescent consensus partitionable networks 
technical report department computer science cornell university june 
marcos aguilera sam toueg 
randomization failure detection hybrid approach solve consensus 
proceedings th international workshop distributed algorithms lecture notes computer science pages 
springer verlag october 
anindya basu charron bost sam toueg 
simulating reliable links unreliable links presence process crashes 
proceedings th international workshop distributed algorithms lecture notes computer science pages 
springer verlag october 
bdm babao glu alberto montresor 
partitionable group membership specification algorithms 
technical report ublcs dept computer science university bologna bologna italy january 
ben michael ben 
advantage free choice completely asynchronous agreement protocols 
proceedings nd acm symposium principles distributed computing pages august 
bn 
simulating crash failures faulty processors 
segal editors proceedings th international workshop distributed algorithms volume lecture notes computer science pages 
springer verlag 
bt gabriel bracha sam toueg 
asynchronous consensus broadcast protocols 
journal acm october 
bt babao glu sam toueg 
non blocking atomic commitment 
mullender editor distributed systems chapter 
addison wesley 
cha soma chaudhuri 
choices allow faults set consensus problems totally asynchronous systems 
information computation july 
cha tushar deepak chandra april 
private communication 
cht tushar deepak chandra hadzilacos sam toueg 
weakest failure detector solving consensus 
journal acm july 
cms benny chor michael merritt david shmoys 
simple constant time consensus protocols realistic failure models 
journal acm 
ct tushar deepak chandra sam toueg 
unreliable failure detectors reliable distributed systems 
journal acm march 
danny dolev roy friedman keidar malkhi 
failure detectors omission failure environments 
technical report department computer science cornell university ithaca new york 
dlp danny dolev nancy lynch pinter eugene stark william weihl 
reaching approximate agreement presence faults 
journal acm july 
flp michael fischer nancy lynch michael paterson 
impossibility distributed consensus faulty process 
journal acm april 
fm paul feldman silvio micali 
optimal algorithm synchronous byzantine agreement 
technical report mit lcs tm laboratory computer science massachusetts institute technology june 
gls rachid guerraoui michael andr schiper 
non blocking atomic commitment unreliable failure detector 
proceedings th ieee symposium reliable distributed systems pages 
gop gopal 
fault tolerant broadcasts multicasts problem inconsistency contamination 
phd thesis cornell university january 
gra james gray 
notes database operating systems 
bayer graham editors operating systems advanced course volume lecture notes computer science 
springer verlag 
appears ibm research laboratory technical report rj 
gue rachid guerraoui 
revisiting relationship non blocking atomic commitment consensus 
proceedings th international workshop distributed algorithms pages le mont st michel france 
springer verlag lncs 
hadzilacos 
relationship atomic commitment consensus problems 
proceedings workshop fault tolerant distributed computing volume lecture notes computer science pages 
springer verlag march 
ht hadzilacos sam toueg 
modular approach fault tolerant broadcasts related problems 
technical report department computer science cornell university ithaca new york may 
kt richard koo sam toueg 
effects message loss termination distributed protocols 
information processing letters april 
lh wai kau lo hadzilacos 
failure detectors solve consensus asynchronous shared memory systems 
proceedings th international workshop distributed algorithms pages netherlands 
lyn nancy lynch 
distributed algorithms 
morgan kaufmann publishers 
nt gil sam toueg 
automatically increasing fault tolerance distributed algorithms 
journal algorithms 
rab michael rabin 
randomized byzantine generals 
proceedings th symposium foundations computer science pages 
ieee computer society press november 
sm laura keith marzullo 
election vs consensus asynchronous systems 
technical report department computer science cornell university ithaca new york 
vr robbert van renesse april 
private communication 

