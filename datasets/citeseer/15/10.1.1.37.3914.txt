tutorial induction functional programming andrew gordon university cambridge computer laboratory new museums site cambridge cb qg united kingdom 
adg cl cam ac uk appear proceedings glasgow workshop functional programming september ayr scotland 
springer workshops computing 
induction important tool reasoning unbounded structures 
tutorial explains foundations induction shows justifies intuitive arguments lazy streams central importance lazy functional programmers 
explain principles theory new formulation bisimilarity functional programs coincides exactly morris style contextual equivalence 
show prove properties lazy streams induction derive bird wadler take lemma known proof technique lazy streams 
aim explain inductive definitions proofs induction useful functional programmers 
induction dual induction 
say set inductively defined just means solution certain form inequation 
instance set natural numbers solution ordered set inclusion inequation fs xg corresponding induction principle just says set satisfies inequation contains inductively defined set 
prove property numbers set numbers property show satisfies inequation 
set 
simply mathematical induction 
dually set inductively defined greatest solution certain form inequation 
instance suppose reduction relation functional language 
set divergent programs greatest solution inequation fa corresponding induction principle just set satisfies inequation inductively defined set contains 
instance royal society university research fellow 
suppose program omega reduces omega omega gamma see omega contained consider set omega satisfies inequation greatest set 
omega member 
bisimilarity equality operational behaviour 
seeks explain bisimilarity important inductive definition functional programmers 
bisimilarity introduced computer science park developed milner theory ccs 
bisimilarity ccs labelled transitions 
transition ff gamma 
means program process perform observable action ff successor program program gives rise possibly infinite derivation tree nodes programs arcs transitions labelled actions 
programs bisimilar root derivation trees ignores syntactic structure nodes 
bisimilarity way compare behaviour represented actions whilst discarding syntactic structure 
contextual equivalence morris widely accepted natural notion operational equivalence pcf languages milner plotkin 
programs contextually equivalent inserted hole larger program integer type resulting programs converge diverge 
main technical novelty show define labelled transition system pcf languages instance miranda haskell bisimilarity operationally defined behavioural equivalence coincides morris contextual equivalence 
virtue characterisation contextual equivalence prove properties functional programs induction 
intend series examples show induction formally captures justifies intuitive operational arguments 
section showing induction induction derive dually tarski knaster fixpoint theorem 
section introduces small call name functional language essentially pcf extended pairing streams vehicle 
conventional definitions divergence contextual equivalence 
section inductive definition divergence prove equals conventional give example inductive proof 
heart section introduce bisimilarity prove coincides contextual equivalence 
give examples inductive proofs state collection useful equational properties 
derive take lemma bird wadler induction 
section explains bisimilarity precongruence preserved arbitrary contexts howe method 
summarise section discuss related 
intended introduce basic ideas bisimilarity coinduction principles 
possible apply theory developed section working details section hardest 
companion gordon develop coinductive tools functional programs 
examples bisimulation proofs see milner gordon instance 
mathematical conventions 
usual regard relation set subset theta relation write mean relations write rr relational composition relation iff relation op opposite relation op iff relation write transitive closure reflexive transitive closure 
tutorial induction induction universal set 
monotone function 
induction induction dual proof principles derive definition set greatest solution respectively equations form 
definitions 
set closed iff dually set dense iff 
fixpoint solution equation 
subsets def fx xg def fx lemma closed set 
greatest dense set 
proof prove follows dual argument 
contains dense set construction need show dense lemma suffices 
dense union 
monotone transitivity dense 
xi theorem tarski knaster fixpoint 
greatest fixpoint proof prove follows dual argument 

lemma 
monotonicity dense combining inequalities greatest fixpoint dense contained xi say solution set inductively defined dually greatest solution set inductively defined obtain dual proof principles associated definitions 
induction closed 
induction dense 
revisit example mathematical induction mentioned introduce 
suppose element injective function define monotone function 
def fs xg set def associated principle induction say words mathematical induction special case general framework 
winskel shows detail structural induction rule induction proof principles familiar computer scientists induction principles obtained particular kinds inductive definition 
examples coinduction sections devoted inductive definitions program divergence equivalence respectively 
aczel standard inductive definitions 
davey priestley give account fixpoint theory including tarski knaster theorem 
small functional language section introduce small call name functional language 
pcf extended pairing streams core fragment lazy language miranda haskell 
define syntax type assignment relation step reduction relation big step evaluation relation 
range countable set variables 
types expressions grammars 
int bool omega ffi ranges finite collection builtin constants omega divergent constant ffi ranges finite collection user defined constants 
assume include map iterate take filter give informal definitions 
builtin constants listed 
say instance schemas 
tt ff bool int succ pred int int zero int bool fst snd pair 
nil cons 
user defined constant ffi assume definition ffi def ffi effect definitions mutual recursion body ffi contain occurrences constant need explicit fix operator 
identify expressions alpha conversion renaming bound variables 
write substitution expression variable free expression context expression holes 
hole written write outcome filling hole expression type assignment relation gamma gamma xn inductively rules simply typed calculus plus gamma gamma omega ffi def gamma ffi gamma bool gamma gamma gamma assume ffi derivable ffi def ffi definition user defined constant 
type assignment unique sense gamma gamma type assignment relation construct universal sets relations 
prog def fe ag programs type prog def prog programs type rel def fa bg prog total relation programs rel def rel total relation programs operational semantics step reduction relation rel inductively defined axiom schemes ffi ffi def omega omega thena tt ff ff succ pred zero tt zero ff fst pair snd pair nil scheme structural rules experiment kind atomic evaluation context felleisen friedman context generated grammar succ pred zero thena fst snd words single structural rule abbreviates different rules kind experiment 
specify deterministic call byname evaluation strategy 
usual definitions evaluation convergence divergence 
def reduces def evaluates def converges def diverges expanding definition easily check complementary iff 
characterise answers returned evaluation relation follows 
normal program program 
value program generated grammar cons lemma program value iff normal 
proof inspection value clearly normal 
direction easily prove structural induction value normal 
xi programs contextually equivalent freely interchanged larger program changing observable behaviour 
form morris extensional equivalence morris 
formal definition contextual equivalence rel recall stands contexts 
iff rel int implies 
iff formalised observable behaviour termination integer type 
relation unchanged specify evaluate integer 
contextual equivalence discriminate grounds termination function pair type 
instance able prove omega omega distinguished call value setting diverges converges call name setting context integer type tell apart 
introduced syntax operational semantics small functional language 
definitions divergence contextual equivalence natural intuitive lend proof 
sections develop inductive characterisations divergence contextual equivalence 
obtain theory admitting proofs program properties induction 
inductive definition divergence characterise divergence inductively terms unbounded reduction 
prog 
prog prog def fa def easily see monotone 
inductive definition greatest dense set 
hughes moran give alternative big step inductive formulation divergence 
simple example show omega 
omega def omega omega dense omega omega omega omega omega omega omega induction omega 
obligation show inductive definition matches earlier iff 
theorem 
proof 
suppose 
show 

furthermore reduction deterministic unique 


induction suffices prove set dense 
suppose 
fact 
dense 
xi inductive definition equivalence labelled transition system characterises immediate observations program 
defined terms step operational semantics sense characterises interface language interpreter outside world 
family relations ff gamma 
prog theta prog ff act indexed set act actions 
lit set literals indexed ff gamma gamma actions follows 
ff fi act def lit snd nil hd partition set types active passive types 
intention directly observe termination programs active type passive type 
type active iff form bool int 
type passive iff form 
arbitrarily define def omega int definitions labelled transition system may defined inductively follows 
gamma 
nil nil gamma 
hd gamma 
tl gamma 
prog gamma 
prog fst gamma 
prog snd gamma 
ff gamma 
ae prog active ff gamma 
derivation tree program potentially infinite tree nodes programs arcs labelled transitions rooted instance trees constant omega empty active 
particular tree empty 
defining transition system indicate observing value literal observe 
milner wish regard programs behaviourally equivalent iff derivation trees isomorphic ignore syntactic structure programs labelling nodes 
formalise idea requiring behavioural equivalence relation rel satisfies property rel iff ff gamma 
ff gamma 
ff gamma 
ff gamma 
fact relations empty set 
largest generous relation 
define inductively follows 
define functions gamma gammai rel 
rel def ff gamma 
ff gamma 
hsi def op op rel examining element wise expansions definitions hard check relation satisfies property iff fixpoint function gammai 
easily check functions gamma gammai monotone 
seek greatest relation satisfy exist equals hsi greatest fixpoint gammai 
standard definitions milner 
ffl bisimilarity rel hsi 
ffl bisimulation gammai dense relation 
bisimilarity greatest bisimulation hi 
expanding definitions see relation rel bisimulation iff implies ffl ff gamma 
ff gamma 
ffl ff gamma 
ff gamma 
asymmetric version bisimilarity interest 
ffl similarity rel 
ffl simulation gamma dense relation 
easily establish basic facts 
lemma preorder equivalence relation 
op 
proof easily proved induction 
omit details 
parts depend determinacy 
part corresponds proposition milner 
xi inductive proof lazy streams motivate study bisimilarity see straightforward induction establish lazy streams bisimilar 
suppose map iterate couple builtin constants specified equations 
map nil nil map cons xs cons map xs iterate cons iterate easily turned formal definitions user defined constants omit details 
pattern matching streams accomplished 
intuitively streams mapf equal consist sequence directly prove equality induction argument induct 
easily prove induction lemma 
lemma rel map prog prog hs proof suffices show hs hs obvious hi 
show hs consider arbitrary establish transition ff gamma 
matched transition ff gamma 
vice versa 
suppose mapf 
calculate reductions 
cons cons map check ff gamma 
iff ff gamma 
reductions enumerate transitions hd gamma 
tl gamma 
hd gamma 
tl gamma 
map plain hs transition matched vice versa reflexive 
transition matched vice versa mapf 
xi gammai dense follows corollary map suitable set show 
operational extensionality obligation show bisimilarity equals contextual equivalence 
key fact need bisimilarity precongruence 
theorem precongruence suitable context holds similarity 
proof non trivial shall postpone till section 
lemma 
proof 
suppose rel int 
precongruence 
required 
follows prove contextual order simulation 
details hard omit 
full details similar proof see lemma gordon theorem howe 
xi contextual equivalence bisimilarity contextual order similarity respectively 
corollary usually known operational extensionality bloom bisimilarity equals contextual equivalence 
theorem operational extensionality theory bisimilarity defined bisimilarity greatest fixpoint shown inductive characterisation contextual equivalence illustrated admits coinductive proofs lazy streams 
section shall note proof various equational properties needed theory functional programming 
proofs similar properties different form bisimilarity gordon 
noted justifies collection beta laws 
easily prove unrestricted eta laws induction 
proposition eta prog proposition surjective pairing prog pair fst snd 
furthermore unrestricted principle extensionality functions 
proposition extensionality suppose ff gg prog 
prog properties relating omega divergence 
proposition divergence omega gamma omega experiment 
omega promised prove omega omega fact proving omega omega consider prog 
omega omega beta reduction omega omega part proposition 
omega omega extensionality 
fact converse false omega omega omega 
easily prove adequacy result 
proposition adequacy prog active iff omega condition active critical example omega omega instance 
convergent program equals value syntax values includes partial applications curried function constants 
characterise types simpler grammar canonical programs 
nil proposition exhaustion program prog canonical program iff converges passive 
pair cons operations injective sense 
proposition canonical freeness prog 
pair 
cons bird wadler take lemma final example derive bird wadler take lemma illustrate proof principle usually derived domain theoretic fixpoint induction follows induction 
take function returns finite approximation infinite list 
take xs nil take nil nil take cons xs cons take xs key lemma 
lemma define rel iff take take 
nil nil 
cons 
hs proof recall values stream type take form nil program stream type value stream omega adequacy proposition nil note easily proved lemma transitions programs active type streams 
prog active ff gamma 
iff value ff gamma 

take take nil nil fact nil take definition take 
know omega gamma nil cons third possibilities contradict nil take nil 
take cons take cons nil take rules possibilities omega nil cons cons take cons take canonical freeness proposition 
suffices prove hs suppose transition ff gamma 
exhibit satisfying ff gamma 
streams possible actions ff consider 
action ff nil 
nil 
part nil 
nil gamma 
required 
action ff hd 
cons part cons hd gamma 
fact part 
action ff tl 
cons part cons tl gamma 
fact part 
completes proof 
xi take lemma corollary induction 
theorem take lemma suppose prog 
iff take take 
see bird wadler sander instance examples take lemma reduces proof equality infinite streams induction finite approximations 
example equations map map map function composition stream processing function preserves size argument easily proved induction take lemma 
case proceed simple case analysis nil suppose stream processing function returns stream elements argument tt intuitively equation hold map map filter straightforward attacks problem take lemma induction style lemma fail 
trouble result stream may elements argument stream 
proof attempts repaired resorting sophisticated analysis 
lack space prevents inclusion way obtain proofs equation take lemma simple induction 
alternatively refined forms induction developed gordon prove equations simple minded case analysis behaviour 
proof principles need effort justify take lemma problems map filter equation easier 
proof bisimilarity precongruence section promise show bisimilarity similarity theorem 
need extend relations bisimilarity open expressions simply programs 
proved expression triple gamma gamma gamma xn gamma closure substitution delta prog 
rel open extension ffi relation proved expressions gamma ffi gamma iff gamma closure 
instance relation rel ffi holds proved expressions gamma gamma provided gamma gamma matter notation shall write gamma mean gamma gamma fact shall omit type information 
need notion compatible refinement characterise means relation open expressions precongruence 
rel ffi compatible refinement rel ffi defined inductively rules 
gamma fx omega ffi gamma gamma gamma gamma gamma gamma gamma define relation rel ffi precongruence iff contains compatible refinement definition equivalent saying relation preserved substitution context 
lemma assume rel ffi preorder 
precongruence iff gamma gamma context 
proof direction induction size context direction straightforward 
note programs type iff ffi similarly similarity 
lemma prove theorem show ffi ffi ffi ffi ffi ffi shall general method established howe 
prove open extension similarity precongruence 
define second relation ffl construction satisfies ffl ffl ffi ffl prove induction ffl ffi ffl ffi relation ffi precongruence ffl second prove open extension bisimilarity precongruence 
op recall lemma 
furthermore ffi ffi ffi follows definition open extension 
easily prove fact rel ffi ffi 
ffi ffi ffi ffi ffi ffi ffi say ffi precongruence 
equivalence relation congruence 
sketched part ffi precongruence 
devote remainder section detailed account 
compatible gamma permits concise inductive induction howe relation ffl rel ffi ffi say ffl relation satisfy rule gamma ffl gamma ffi gamma ffl sands neat presentation basic properties ffl howe 
lemma sands ffl relation closed rules gamma ffi gamma ffl gamma ffl gamma ffl gamma ffl gamma ffi gamma ffl claimed earlier ffl ffl ffi ffl follow lemma 
proof routine substitution lemma 
lemma gamma ffl gamma ffl gamma ffl 
remains howe method prove ffl ffi induction 
note lemma crux proof relating ffl transition 
lemma def ffl bg 

ff gamma 
ff gamma 
proof proofs induction depth inference reduction transition ff gamma 
respectively 
details similar proofs may howe gordon 
xi lemma simulation induction 
open extension monotone ffi ffi ffl ffi follows substitution lemma lemma reflexivity ffl lemma reflexivity ffi 
ffl ffi reverse inclusion follows lemma fact ffl ffi ffi precongruence 
summary related explained dual foundations induction induction 
defined notions divergence contextual equivalence small functional language extension pcf 
gave inductive characterisations divergence contextual equivalence illustrated utility series examples properties 
particular derived take lemma bird wadler 
explained howe method proving bisimilarity inductive formulation contextual equivalence precongruence 
hope shown general principles specific examples easy path leading reduction rules define functional language powerful theory program equivalence induction 
particular formulation new bisimilarity functional languages 
known applicative bisimulation natural semantics style evaluation relation 
earliest find abramsky unpublished martin lof type theory eventually led study lazy lambda calculus abramsky ong 
includes papers howe smith sands ong pitts stark ritter pitts crole gordon book 
formulation coincide contextual equivalence pcf languages 
amounts inductive generalisation milner original term model pcf 
equals contextual equivalence answers turner preface concern abramsky applicative bisimulation distinctions observable typed program contexts 
domain theory perspective foundations lazy functional programming offers 
subject benefits multiple perspectives 
case equal expressiveness 
domain theory independent syntax operational semantics provides fixpoint induction proving program properties 
take care distinguish denotations texts programs theory bisimilarity set section paralleled theory domain theoretic denotational semantics 
winskel instance shows prove adequacy lazy language recursive types albeit functions pairs active types 
pitts develops induction principle domain theory 
hand smith shows operational methods form bisimilarity support fixpoint induction 
advantage operational approach bisimilarity coincides exactly contextual equivalence 
corresponding property denotational semantics full abstraction notoriously hard achieve ong 
earliest presentation lazy lambda calculus appears abramsky thesis chapter explains main results chapter obtained setting martin lof domain interpretation type theory shortly visit chalmers march 
idea defining bisimilarity deterministic functional language labelled transition system arose joint roy crole 
martin coen pointed map filter example hold royal society university research fellowship 
partially supported cec types bra begun member programming methodology group chalmers 
benefitted greatly presenting tutorial functional programming group glasgow university 
am grateful colleagues ayr workshop chalmers cambridge useful conversations 
abramsky 
october 
domain theory logic observable properties 
ph 
thesis queen mary college university london 
abramsky ong 
full abstraction lazy lambda calculus 
information computation 
aczel 

inductive definitions 
barwise ed handbook mathematical logic pp 

north holland 
bird wadler 
functional programming 
prentice hall 
bloom 

lcf 
flat lattice models typed lambda calculus 
proceedings rd lics pp 

crole gordon september 
sound metalogical semantics input output effects 
computer science logic poland 
proceedings appear springer lncs 
davey priestley 
lattices order 
cambridge university press 
felleisen friedman 
control operators secd machine calculus 
formal description programming concepts iii pp 

north holland 
gordon 

bisimilarity theory functional programming 
submitted publication 
gordon 

functional programming input output 
cambridge university press 
revision phd dissertation 
howe 

equality lazy computation systems 
proceedings th lics pp 

hughes moran june 
natural semantics nondeterminism 
proceedings el pp 

chalmers pmg 
available report 
milner 

fully models typed lambda calculi 
tcs 
milner 

communication concurrency 
prentice hall 
morris 
december 
lambda calculus models programming languages 
ph 
thesis mit 
ong 

june 
non determinism functional setting extended 
proceedings th lics pp 

ong 

january 
correspondence operational denotational semantics full abstraction problem pcf 
submitted handbook logic computer science volume oup 
park 
march 
concurrency automata infinite sequences 
deussen ed theoretical computer science th volume lecture notes computer science pp 

springer verlag 
pitts stark june 
observable properties higher order functions dynamically create local names preliminary report 
pp 

pitts 

induction principle recursively defined domains 
tcs 
plotkin 

lcf considered programming language 
tcs 
ritter pitts september 
fully translation calculus types standard ml 
appear tlca 
sander 

logic functional programs application concurrency 
ph 
thesis chalmers pmg 
sands 

operational theories improvement functional languages extended 
functional programming glasgow workshops computing pp 

springer verlag 
sands 
may 
total correctness improvement transformation functional programs st draft 
diku university copenhagen 
smith 

operational denotational semantics 
mfps vii pittsburgh volume lecture notes computer science pp 

springer verlag 
turner 
ed 

research topics functional programming 
addison wesley 
winskel 

formal semantics programming languages 
mit press cambridge mass 
