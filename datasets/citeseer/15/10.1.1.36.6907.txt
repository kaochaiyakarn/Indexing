optimistic replication algorithms yasushi saito august optimistic replication algorithms allow replica contents stale controlled way 
propagating updates background allowing replica read time available ecient traditional replication algorithms unreliable network media inexpensive computers optimistic replication grown due proliferation internet mobile computing devices systematic study begun 
survey optimistic replication algorithms report 
particular focus update propagation mechanisms invented optimistic replication study mechanisms ect functional characteristics systems including data consistency guarantees performance 
distributed computing systems replicate objects multiple sites improve availability performance 
replication improves availability letting users access data sites non functional 
replication improves performance letting users access data nearby site avoid remote network access idle site achieve better load balance 
replication algorithm core replicated service responsible reading updating replicas physical copies object 
important design issue replication algorithms replicas users 
traditional pessimistic replication algorithms er semantics give users illusion having single highly available copy object keeping replicas identical time 
called pessimistic prohibit accesses replica replica contents provably date 
pessimistic algorithms essential class applications banking avoid giving wrong answer major drawback stringent hardware requirements 
example primary copy fail algorithm popular pessimistic replication algorithms assumes accurately distinguish crashed node live unresponsive node reliably re elect primary replica fail 
distinction theoretically impossible probabilistically possible investing highly reliable network hardware capacity computers 
optimistic replication algorithms allow data users stale controlled way 
key feature separates optimistic replication algorithms pessimistic counterparts way object updates handled pessimistic algorithms update replicas possibly block read requests update application optimistic algorithms propagate updates background allow replica read directly time 
feature optimistic algorithms available ecient unreliable network media inexpensive computers 
optimistic replication new idea example magnetic tape backup decades crude form optimistic replication grown due proliferation internet mobile computing devices 
systematic treatments optimistic algorithms including study ecient update transfer replica consistency management mechanisms begun 
survey optimistic replication algorithms report 
particular focus update propagation mechanisms invented optimistic replication study mechanisms ect functional characteristics system including data consistency guarantees performance 
remainder section rst overview advantages applications optimistic replication 
classify existing optimistic replication algorithms update propagation strategies update issued transferred update transfers update discuss strategy choices ect systems usability functional characteristics 
introduce challenges optimistic replication algorithms face replica consistency management performance scaling 
section details optimistic algorithms handles rst challenge rst replica consistency maintenance 
section discusses second challenge performance scaling 
particular argue performance characteristics optimistic replication algorithms determined update propagation strategy show system performance requirements supporting replicas unreliable links determine type algorithm uses 
section discuss open issues addressed adequately past 
advantages optimistic replication advantages optimistic replication algorithms pessimistic counterparts 
fault tolerance optimistic algorithms slow unreliable network links propagate updates replicas background 
allow users read update object far replica alive 
networking exibility optimistic algorithms intermittent incomplete network links allowing updates exchanged pair nodes 
low cost networking exibility scalability optimistically replicated services deployed inexpensive hardware compared pessimistic counterparts 
site autonomy optimistic algorithms improve site autonomy requiring coordination sites 
example services ftp mirroring allow replica added administrative change existing replicas 
applications optimistic replication optimistic replication particularly attractive wide area distributed environments communication sites slow unreliable 
usenet internet bulletin board system oldest popular optimistically replicated service 
usenet consists thousands servers connected ad hoc way 
server replicates news articles user read article closest server 
news articles distributed periodic ooding inter server links 
periodic article propagation process creates delay article posted server reaches long week 
delay confuses novices accept reasonable cost pay usenet excellent availability 
optimistic replication improve performance availability wide area data services www ftp directory services xerox clearinghouse dns active directory grapevine :10.1.1.156.7859:10.1.1.21.1584
optimistic replication attractive reasons 
need replicate data unreliable long haul links 
second operate tight budget 
third data inconsistency inherent incomplete links allow replica communicate subset peer replicas 
network protocols web users routinely hit reload button read latest web page replication algorithm loose consistency guarantee hurt service quality 
optimistic replication key enabling technology mobile computing 
mobile database systems replicate database portable computers 
allow users read update database disconnected merging modi cations replicas reconnect 
optimistic replication choice environments 
applications similar demands include mobile le systems coda roam mobile mail systems bayou lotus notes 
classifying optimistic replication algorithms classify optimistic replication algorithms broadly axes update issued transferred update transfers update 
classi cation determines update propagation strategy system usability complexity system 
update transfer model update issued 
update transfer model determines update issued propagated 
single master systems statically designate replica master stores authoritative copy object 
updates issued master propagated replicas slaves 
multi master systems replica issue update exchange merge updates replicas 
main advantage single master systems simplicity 
updates accepted place single master systems detect report update con icts users immediately confusing users 
simpler algorithmically updates ows way 
disadvantage single master systems master single point failure 
advantage multi master systems availability 
side multi master systems su er lost update problem may lose ects updates con icts detected updates accepted replicas users issued updates long logged system 
unit transfer transferred update 
change object expressed new object contents semantic description log 
systems exchange contents called contents transfer systems systems exchange log called log transfer systems 
consider bibliography database example 
author eld updated replica contents transfer system transfer entire database contents replicas log transfer system transfer description update 
update bibliography set author herman melville title moby dick log transfer owns advantages contents transfer 
log transfer handle update con icts especially multi master systems 
example updates modify authors di erent books merged trivially log transfer choice discarding update contents transfer 
second demonstrated example log transfer reduces computational networking overhead object large updates small 
side log transfer systems tend complex contents transfer systems reasons 
replica needs remember history updates addition replica contents 
second system needs determine set updates transferred peer replica order updates applied 
third updates described semantically log transfer dicult implemented way transparent applications systems attempt separate application dependent logic replication algorithm reusable di erent applications 
direction transfer transfers update 
direction transfer determines replica responsible transferring updates 
pull algorithms replica responsible polling replicas downloading new updates push algorithms replica update responsible guring sets updates sent replicas 
pull systems send update replica twice set updates sent determined precisely polling 
pull systems suited mobile environments scarce network bandwidth 
addition require replica keep track state replicas state obtained polling 
property pull systems attractive internet environments replicas managed autonomously ftp mirroring usenet article caching 
hand push systems computationally ecient obviate polling 
furthermore reduce update propagation delay especially fully connected networks pushing updates immediately issuance 
push transfer attractive systems fully connected environments examples include nis usenet relational database systems 
summary classi cation existing optimistic replication systems shows classi cation major optimistic replication systems 
general systems left side simpler inecient systems right versatile complex 
simple ecient versatile optimistic replication single master multi master 
contents log contents log 

systems appl 
area pull ftp www mirror dns wide area data directory push nis wide area directory pull push oracle sybase database pull roam palm coda mobile db le system push usenet active directory porcupine wide area data service pull bayou golding mobile db le system push agrawal wuu wide area directory service fig :10.1.1.156.7859:10.1.1.156.7859:10.1.1.116.6208
classi cation existing optimistic replication systems 
challenges optimistic replication algorithms optimistic replication algorithms face main challenges replica consistency management performance scaling 
challenges unique optimistic replication complicated updates may issued multiple replicas time con icts may long users issued updates logged system 
maintaining replica consistency maintaining replica consistency controlling quality replica contents crucial function replication service 
de nition optimistic replication algorithms guarantee strict single copy consistency 
rst challenge de ne type consistency algorithm achieve implementations follow naturally consistency type 
distinguish types replica consistencies report eventual consistency view consistency 
eventual consistency eventual consistency guarantees replica consistency quiescent environment 
words guarantees current state replicas new update issued replica fails replicas able communicate freely long period replicas contents identical 
eventual consistency important reasons 
minimal requisite replication algorithm guarantee replica contents may remain corrupted forever making system practically useless 
second eventually consistent services best orts disseminate updates quickly replicas best ort strong practical applications 
design choices exist eventual consistency achieved presence concurrent update example order updates totally partially user specify ordering system determine ordering automatically 
view consistency eventual consistency provide guarantee quality data replica contents eventually converge means little users 
goal view consistency guarantees control quality data intervening replica read update requests 
guarantee optional fact systems serve arbitrarily stale data users 
view consistency includes causal consistency preserves partial orderings read write requests bounded inconsistency explicitly limits degree replica inconsistency 
example causal consistency consider replicated password database 
user may change password replica get frustrated failing log replica password change reached replica 
problem avoided having causal read guarantee read request honor past updates user 
airline seat reservation system example bounded inconsistency guarantee useful 
airline companies allow overbooking streamline reservation system airline operations need limit degree overbooking avoid hurting reputation 
scalability optimistic replication algorithms perform eciently large workload useful practically 
workload size grow axes handling large objects replicas coda transfers contents ordinary les log directories 
object objects 
axes orthogonal algorithms scale replicas large objects 
addition performance scaling optimistic algorithms little disk space possible provide way trim data structures maintain replica consistency necessary 
maintaining replica consistency section surveys techniques maintaining types replica consistency guarantees eventual consistency guarantee view guarantee 
maintaining eventual consistency discuss methodologies maintaining eventual replica consistency 
start various types pull transfer systems 
section show push transfer algorithms derived pull transfer systems techniques blind pushing state estimation 
problem maintaining eventual replica consistency broken set sub problems 
algorithms introduced section breakdown 

distributing updates replicas 

determining order update application 

detecting reconciling con icts updates 
pull single master systems single master systems designate replica master responsible accepting applying changes 
replicas slaves receive changes master 
replica consistency management trivial single master systems 
contents transfer update propagation usually implemented simpli ed variation thomas write rule section 
replica stores timestamp shows time contents modi ed 
slave replica obtains master timestamp periodically downloads master replica contents timestamp older master 
log transfer equally easily implemented remembering update applied replica 
updates issued master update ordering con ict detection handled master database concurrency control techniques phase locking optimistic concurrency control 
pull multi master log transfer systems multi master log transfer algorithms versatile complicated optimistic replication algorithms 
maintaining eventual consistency multi master log transfer systems complicated multiple updates may issued simultaneously di erent replicas may reach replicas arbitrary order 
distributing updates replicas timestamp vectors multi master replication algorithms ensure replica receives updates issuers updates directly reachable 
requirement called update transfer essential mobile environments network links usually incomplete important fully connected environments avoid node failure stalling update propagation entire system 
naive algorithm achieving update transfer replica log updates receives send entire update log peer replicas periodically demand 
time replicas communicate indirectly replicas converge newest value 
notice concerned replicas communicate 
example mobile environment replica communication topology determined users meet synchronize devices 
example internet services replica communication topology set ad hoc way human negotiation 
far communication topology graph strongly connected algorithm distribute updates replicas 
obvious downside slower consumes disk space accumulates updates 
timestamp vector technique pull systems minimize number updates exchanged replicas 
replica keeps disk timestamp vector tv element array timestamps summarizes state replica 
total number replicas timestamp number increases monotonically logical clock wall clock counter increments update issuance may suce 
tv replica represents time update issued tv called replica timestamp 
update exchanged replicas associated issuer timestamp moment issuance 
elements tv meaning tv replica received updates issued timestamps shows update propagation procedure timestamp vectors 
propagate updates replica replica rst sends timestamp vector tv replica compares tv timestamp vector tv element element 
tv replica sends updates issued stored timestamps larger tv 
process ensures receives updates stored absent receive update stores 
updates sent tv replica updated computing pair wise maxima tv tv swapping roles receive updates replicas store set updates 
timestamp vector useful just update propagation 
ecient mechanism estimating state remote node number degree events happened node 
applications timestamp vectors include write con ict detection section update ordering section update log truncation section 
ordering updates having replicas receive set updates achieve eventual consistency replicas may receive updates di erent order 
updates sorted applied replica de ned order 
describe approaches update ordering distributed protocols informing replicas state update propagation semantic relationships updates 
total update ordering eventual consistency achieved naturally forcing replicas apply updates order 
overview techniques developed replicas agree total update ordering 
approach proposed golding uses ack vectors collect status replicas 
ack vector av element array timestamps exchanged replicas updated just timestamp vectors 
av replica de ned min tv received replicas assumed named numbers 
updates newer av regardless issuers 
likewise av replica represents conservative estimate newest update received replica updates timestamps older min av guaranteed received replicas sorted timestamps applied replica 
technique requires replicas timestamps advance roughly speed replica slow timestamp may stall progress ack vectors replicas keeping min tv increasing 
golding algorithm uses loosely synchronized wall clocks timestamps 
second approach bayou designates replica home 
home replica unilaterally totally orders updates order chooses 
home replica assigns monotonically increasing commit sequence number csn ordered update 
mapping updates timestamps propagated back replicas piggybacking ordinary update messages 
notice di erence bayou home node master node single master replication systems 
bayou job home replica update ordering updates transferred pair nodes single master systems master node responsible update issuance ordering propagation 
third approach proposed deno adapts quorum consensus protocol optimistic environment 
administrator deno ballot certain weight replica 
sum ballots held replicas 
update associated vote increases replica ballot received replica 
update application deferred vote exceeds 
multiple updates circulate replicas simultaneously win vote discarded silently 
update circulates replicas twice deno collect votes inform replicas vote passage 
protocol totally orders updates order acquired majority votes 
approaches trade advantage rst approach decentralized aborts updates 
downside single dead replica may hamper progress replicas problem worsens number replicas increases 
bayou home algorithm alleviates livelock problem long home replica receives updates timely manner order updates immediately 
hand bayou algorithm complicated golding 
deno supports spectrum degree centralization assigning entire ballot single replica deno behave bayou assigning equal weight replica deno behave traditional voting scheme 
downside deno allows update outstanding time updates fail win majority votes aborted 
unsuited applications experience large communication delay high update frequency 
partial update ordering intuitive total update ordering disadvantages 
may delay update application unnecessarily ignores semantic relationships updates update commutativity 
second total ordering preserve dependencies updates issued di erent replicas 
example consider source code management database library module modi ed replica application program modi ed replica way depends new library module 
case want library update applied application update replicas may mix updates unrelated modules 
express constraint total ordering mechanisms 
systems address shortcomings total ordering advantage update commutativity 
example additions subtractions numeric value le creations directory applied order produce result 
idea commutative updates extended order updates causality 
causality partial ordering de ned updates speci es conditions form update applied update 
systems user specify causality explicitly 
systems introduce session persistent record encapsulates object access history particular user new update issued user considered depend causally previous updates recorded user session 
earliest implementation causality attached update set names timestamps causally preceding updates delayed update application causally preceding updates applied 
naive algorithm disadvantage size update may grow unboundedly depends preceding updates 
systems solve problem compressing preceding updates set grouping updates issuers picking newest update group 
system guarantees updates issued replica propagated order issuance case timestamp vectors dependency compression algorithm achieves ect earlier solution 
detecting reconciling con icting updates updates con ict replica issues update receives update circulating replicas situation easily detected timestamp vectors follows 
remember replica timestamp vector dominates replica strictly newer sense received updates 
detect update con icts system attaches update issuer timestamp vector moment issuance notice original timestamp vector algorithm described section system attaches issuer timestamp update 
update timestamp vector dominates update con ict issued issuer received update 
updates con ict 
updates con icts ect eventual consistency object con ict detection purely user convenience 
consider conference room reservation system example 
people submit reservation requests room time slot system easily maintain eventual consistency accepting request ignoring 
people informed con ict able negotiate schedule 
resolving con icts fundamentally application dependent 
con icts creations di erent les directory resolved simply merging previous room reservation example need resolved manually 
pull multi master contents transfer systems section discusses multi master contents transfer systems maintain eventual consistency 
propagate order updates contents transfer systems need agree replica newest transferring contents newest replica bring replicas date 
rst introduce thomas write rule simple protocol determine newest replica contents 
describe algorithms applications need detect update con icts 
thomas write rule thomas write rule associates replica timestamp usually loosely synchronized wall clock counter lotus notes shows time replica modi ed :10.1.1.156.7859
replica obtains peer replica timestamp periodically demand downloads peer contents de ne update con icts syntactically report 
example room reservation example concurrent reservation requests di erent rooms con ict de nition common sense 
timestamp dominates element timestamp older 
timestamp smaller peer 
time replicas communicate indirectly replicas converge newest value 
object deletion requires special treatment thomas write rule timestamp read deleted replica 
solutions proposed solve problem 
rst solution simply require human intervention delete objects dns nis :10.1.1.156.7859
second solution keep timestamps contents deleted replicas disk 
timestamps called death certi cates 
third solution adopted porcupine mail server propagates update phases :10.1.1.116.6208:10.1.1.116.6208
rst phase update disseminated replicas 
update record logged disk separately replica contents acts update deletes object 
replicas con rm reception update retirement notices circulated replicas delete update record 
detecting update con icts thomas write rule shortcoming con icting updates silently discarded newest 
systems designed multi user collaboration coda roam locus need know updates con ict users resolve con icts 
applications combine timestamp vectors contents transfer 
systems thomas write rule associate replica timestamp vector tv timestamp 
tv replica shows time update issued elements tv updated merging replicas timestamp vectors section 
timestamp vectors de ned way detect update con icts technique introduced section 
systems er alternative solution extending thomas write rule naturally :10.1.1.116.1182
scheme update message associated sender side replica timestamp just update application 
receiver side replica timestamp di ers attached update message update considered con ict previously applied receiver side replica 
simpler technique timestamp vectors technique may report false positive con ict receiver side replica misses older updates 
push transfer systems push transfer systems derivatives pull counterparts 
pull push systems di er way updates distributed 
issues including update ordering con ict detection reconciliation addressed set solutions developed pull systems 
pull transfer algorithms discussed far associate replica form timestamp represent state replica 
replica retrieve peer replica timestamp discovers set updates contents downloaded 
hand push transfer systems need identify set updates sent replica contact 
achieved ways blindly pushing new updates estimating state replicas 
blind pushing scheme replica update blindly forwards update reachable replicas 
approach simple ective services connect replicas way update ows xed path received replica twice 
single master systems usenet relational database systems porcupine mail server examples services :10.1.1.116.6208:10.1.1.116.6208
receiver side replica uses pull transfer mechanisms thomas write rule usenet porcupine lter duplicate updates 
state estimation techniques blind pushing obvious downside sends duplicate updates replica communicates replicas 
problem alleviated letting replica estimate state push updates missing remote replica 
example state estimating techniques timestamp matrices multi master push systems 
timestamp matrix tm stored replica matrix timestamps number replicas timestamp de ned section 
tm replica holds timestamp vector rows tm shows replica conservative estimate timestamp vectors replicas 
words tm replica knows replica received updates issued replica timestamps update propagation process similar timestamp vectors 
di erence sending updates replica sender uses tm estimate timestamp vector receiving vector receiver side replica timestamp matrix updated merging sender timestamp matrix piggybacked update message 
timestamp matrix eliminate duplicate updates completely replicas receive update simultaneously may send update replica twice 
thomas write rule extended naturally push algorithm similar technique node maintain vector timestamps tmv conservatively estimates timestamp replicas 
replica sends contents replica tmv tmv active directory replicated hierarchical directory service windows uses algorithm similar 
di erence active directory replicates objects site node name space tree object vector estimates largest timestamp objects replicated site 
trading replica consistency update application delay algorithms described far delay applying updates nal application order determined 
slower communication replicas larger number replicas longer update application delayed 
problem alleviated applying updates tentatively soon arrive 
tentative order turns di erent nal order updates undone re applied correct order 
tentative updates allow user see date contents price occasional confusion undone re applied 
tentative updates single master systems user update slave replica disconnected master :10.1.1.116.1182
tentative updates pose implementation challenges 
updates need able undone possible especially interact real world ring missile paying money 
second problem applicable multi master systems number increases quickly number replicas resulting large computational cost section 
managing view consistency optimistic replication algorithms de nition ensure strict replica consistency 
eventual consistency guarantees replica consistency hypothetical quiescent state ers little clue users regarding quality replica contents 
replicated data services ne just eventual consistency semantic limitations network protocols allow replica read time 
porcupine mail server usenet examples services replica inconsistency worse potential problems caused smtp nntp network protocols transfer mail news internet delivery delay duplicate messages :10.1.1.116.6208:10.1.1.116.6208
hand services replicated password database example illustrated section weaker forms quality data guarantees provide visible bene ts users 
section overviews proposals weaker replica consistency guarantees implementations 
causal consistency preserving causal orderings accesses especially helpful avoiding consistency anomalies confuse users 
types causal consistency guarantees proposed depending reads writes interact read writes monotonic reads writes follow reads monotonic writes 
writes follow reads monotonic writes forms causal write consistencies covered section 
read writes guarantees contents read replica incorporate previous writes user 
password example illustrated section example read writes guarantees 
monotonic reads guarantees successive reads user return increasingly date contents 
guarantees trivial user accesses single replica tricky user roams multiple replicas 
view consistency roaming environments implemented technique maintaining causal update consistency section 
read request associated compressed representation set causally preceding read update requests 
request satisfy causality constraint rejected outright delayed replica receives updates satisfy constraint 
bounded consistency systems user specify maximum degree inconsistency allowed replica access 
systems quasi copies dns www measure inconsistency real time guarantee newest object contents propagated replicas xed period :10.1.1.156.7859:10.1.1.21.1584
advantage approach simplicity combination single master replication periodic polling pushing naturally achieves guarantee 
downside practical single master replication systems highly reliable network links 
di erent line studies suggests specifying amount inconsistency terms number updates read overlap terms semantic metrics example dollars amount bank account 
improve performance non replicated database systems increasing locking concurrency studies suggest applying replication improve performance enrich consistency semantics 
generally implemented relaxed phase locking reads writes datum granted certain conditions inapplicable mobile wide area distributed applications designed intermittent network links 
scaling optimistic replication systems study performance issues optimistic replication section 
rst discuss computational networking overhead systems axes workload scaling large objects large number replicas large number objects 
discuss storage requirement systems orts curtail storage consumption 
scaling large objects scaling large objects determined transferred update section 
log transfer systems support large objects better cost depends object size frequency size updates 
hand network computational costs contents transfer systems increase linearly object size 
techniques proposed alleviate problem giving simplicity contents transfer algorithms 
banga proposal originally developed www latency reduction speculatively sends di erence optimistic delta new old object contents falls back full contents transfer remote replica contents match sender 
algorithm saves network bandwidth computational cost 
technique divide object hierarchically structured sub objects thomas write rule level hierarchy rabinovich algorithm lotus notes active directory 
technique extended allow site replicate just sub tree object hierarchy reduce cost replication roam 
scaling large number replicas scalability system replicas determined update transfer model described section 
having replicas presents di erent problems single master multi master systems 
propagation delay load imbalance having replicas increases update propagation delay creates load imbalance replicas especially single master systems master replica responsible propagating updates replicas 
problem fortunately alleviated relatively easily 
solution connect replicas tree structure place master root updates ripple tree root 
cuts propagation delay log number replicas reduces load master constant level 
multi master systems roam usenet active directory push idea connect replicas tree structure supplemented short cut paths improve availability update propagation speed 
technique employs unreliable multicast protocol digital fountain distribute updates eciently common case back slower reliable algorithm described section 
increased update con icts gray argues multi master replication algorithms support replicas experience update con icts section single master systems experience update con icts number replicas :10.1.1.116.1182
addition confusing users increased update con icts leads updates larger computational overhead system supports tentative updates section 
gray important assumption derive data item updated replicas 
assumption hold universally example write sharing unix le systems known rare clear severe scalability problem practice 
assuming equiprobable data access problem inherent multi master systems satisfactory solution 
proposed remedies include single master replication support tentative updates algorithm types space notes single master pull single master push master slaves 
multi master pull contents transfer thomas write rule blind pushing porcupine usenet multi master push contents transfer state estimation active directory multi master pull log transfer timestamp vector blind pushing multi master push log transfer timestamp matrix table disk space occupied timestamps various replication algorithms 
unit space number timestamps 
represents total number replicas system 
contents transfer mechanism resolve update con icts eciently simple overwriting 
scaling large number objects existing optimistic replication systems designed manage single replica site reasons exist replicating objects site 
reason replicate just portion large database site conserve disk space natural solution divide database small pieces replicate selectively 
reason demonstrated porcupine mail server mix match replicas objects site hide system heterogeneity di erences disk capacity cpu speed achieve better performance :10.1.1.116.6208:10.1.1.116.6208
theory single object replication algorithm support multiple objects simply running instances algorithm parallel 
practice technique cheap apply single object may prohibitively expensive objects 
consider polling performed pull systems example 
number polls node pull systems increases rate nx mean number replicas object number replicas stored node pull systems prohibitively expensive node replicates objects 
systems support objects active directory usenet porcupine mail server algorithms :10.1.1.116.6208:10.1.1.116.6208
controlling space overhead replication algorithms keep types data structures disk addition replica contents maintain replica consistency 
examples include timestamp vectors matrices keep track replica state sections keep track deleted objects section update log section 
section examines space overhead data structures overviews strategies reducing overhead 
timestamp overhead table summarizes amount space occupied timestamps replica 
overhead due timestamps usually negligible timestamp matrices timestamp occupies just bits disk space 
study proposes reducing overhead timestamp matrices collapsing rows corresponding remote replicas column wise minimum 
scheme reduces accuracy estimation state remote nodes potentially resulting duplicate update transfers 
controlling size update log log transfer systems keep log updates grows inde nitely updates accumulate 
techniques proposed trim size update log 
rst technique deletes updates older prede ned period month uses xed size update log rolls old updates log lls 
second technique observation log trimming problem total update ordering problem solved discovering update received replicas 
systems reuse ack vector algorithm section trim update log 
contents transfer systems keep deleted objects section accumulate objects deleted 
just timestamp takes far space update log contains entire history changes replica 
reason keep system simple contents transfer systems delete old simply waiting xed period 
summary table summarizes design optimistic replication algorithm ects scalability 
table shows axis update propagation strategy ects scalability space overhead di erent ways 
words performance demand application dictate replication algorithm application 
example mobile database system replicates single large database replicas pick log transfer pull algorithms case 
scaling space large object replicas objects overhead single master multi master push dup update pull contents transfer log transfer update log table table shows architecture systems ect performance 
shaded entries show comparatively better choices 
open issues performance optimization optimistic replication algorithms traditionally mobile widely distributed environments network bandwidth primary bottleneck 
systems optimistic replication local area network environments system highly fault tolerant inexpensive hardware porcupine active directory :10.1.1.116.6208
systems need optimized save cpu cycles disk accesses network bandwidth issue past optimistic replication ignored 
issue addressed ways 
rst approach combine algorithms ecient algorithm common case slower fault tolerant algorithm emergency case 
examples include unreliable multicast protocols section combination distributed transactions optimistic replication 
line algorithms failed gain popularity due complexity 
second approach see investigation study ecient implementations existing optimistic algorithms 
example algorithms timestamp vectors update log need support complicated set operations retrieve updates issuer sort timestamp delete arbitrary set updates 
example tentative updates section require complex supports system undoing redoing operations 
nal approach design new optimistic algorithms focus cpu disk cost reduction 
seen activity area rabinovich hierarchical object decomposition porcupine selective replication :10.1.1.116.6208
tolerating wider varieties failures optimistic replication algorithms implicit assumptions failures failure quickly failure cause permanent damage replica state 
practice assumptions hold 
disk ll disk crash computer theft examples failures handled existing systems 
example algorithms timestamp vectors timestamp matrices er way delete vector matrix entry replica corresponding entry explicitly circulating retirement notices replicas 
replica crashes recovers replicas timestamp vectors matrices contain garbage entry removed manually 
example update log log transfer systems ll replica remains long 
problem weaker variation byzantine consensus problem active area study 
existing solutions byzantine consensus applicable purpose fast fully connected network perform lock step replica synchronization 
systems solved part problem ad hoc ways 
example bayou allows update log erased time save disk space able contain limited types corrupt replicas 
example porcupine allows node retire suddenly announcement 

management replicated data large scale systems 
phd thesis corpus college university cambridge august 
agrawal abbadi 
epidemic algorithms replicated databases 
th acm symp 
princ 
database systems pages may 
alonso barbara garcia molina 
data caching issues information retrieval systems 
acm trans 
database systems september 
mary baker john hartman michael kupfer ken john ousterhout 
measurements distributed le system 
symp 
operating systems principles pages 
gaurav banga fred douglis michael rabinovich 
optimistic deltas www latency reduction 
usenix annual technical conference 
www research att com douglis 
phillip bernstein hadzilacos nathan goodman 
concurrency control recovery database systems 
addison wesley 
birman joseph 
reliable communication presence failures 
acm trans 
computer systems february 
birman schiper stephenson 
lightweight causal atomic group multicast 
acm trans 
computer systems august 
andrew birrell roy levin roger needham michael schroeder 
grapevine exercise distributed computing 
communications acm february 
john byers michael luby michael mitzenmacher 
digital fountain approach reliable distribution bulk data 
acm sigcomm pages vancouver bc august 
john carter anand ranganathan sai 
infrastructure building distributed services 
th annual international conference distributed computing systems may 
miguel castro barbara liskov 
practical byzantine fault tolerance 
operating system design implementation new orleans la february 
chandy lamport 
distributed snapshots determining global states distributed systems 
acm trans 
computer systems 
chankhunthod danzig neerdaels schwartz worrell 
hierarchical internet object cache 
winter usenix technical conference january 
dean daniels lip boon alan downing curtis gary hallmark sandeep jain bob jenkins peter lim gordon smith benny jim stamos 
oracle symmetric replication technology implications application design 
acm sigmod international conference management data page minneapolis mn may 
acm 
susan davidson hector garcia molina dale skeen 
consistency partitioned networks 
acm computing surveys 
demers greene hauser irish larson 
epidemic algorithms replicated database maintenance 
acm symp 
princ 
distr 
computing pages 
daniel dietterich 
dec data distributor data replication data warehousing 
acm sigmod international conference management data page minneapolis mn may 
acm 
alan fekete david gupta victor nancy lynch alex shvartsman 
eventually serializable data services 
acm symp 
princ 
distr 
computing may 
fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm 
david gi ord 
weighted voting replicated data 
th symp 
operating systems principles pages 
goel calton pu gerald popek 
view consistency optimistic replication 
th ieee symposium reliable distributed systems october 
richard golding 
weak consistency group communication membership 
phd thesis uc santa cruz december 
available ftp ftp cse ucsc edu pub tr ucsc crl ps richard golding 
modeling replica divergence weak consistency protocol global scale distributed data bases 
technical report ucsc crl uc santa cruz february 
available ftp ftp cse ucsc edu pub tr ucsc crl ps alex wang mark 
sybase replication server 
acm sigmod international conference management data page minneapolis mn may 
acm 
jim gray pat patrick neil dennis shasha :10.1.1.116.1182
dangers replication solution 
acm sigmod international conference management data pages montreal canada june 
jim gray andreas reuter 
transaction processing concepts techniques 

james gwertzman margo seltzer 
case 
workshop hot topics operating systems 
james gwertzman margo seltzer 
world wide web cache consistency 
winter usenix technical conference february 
brad hammond 
merge replication microsoft sql server 
acm sigmod international conference management data philadelphia pa 
hsu william weihl 
gossip managing distributed event histories 
information sciences 
johnson jeong 
hierarchical matrix timestamps scalable update propagation 
lns cornell edu jeong index directory hmt ps june 
brian kantor phil 
rfc network news transfer protocol february 
www cis ohio state edu rfc rfc html 
peter keleher 
decentralized replicated object protocols 
th acm symp 
princ 
distr 
computing april 
mojo cs umd edu papers podc pdf 
anne marie kermarrec van steen andrew tanenbaum 
framework consistent replicated web objects 
technical report ir vrije may 
james kistler satyanarayanan 
disconnected operation coda le system 
acm trans 
computer systems february 

nntp server small sites 
www org 
kumar michael stonebraker 
semantic transaction management techniques replicated data 
acm sigmod international conference management data june 
kumar michael stonebraker 
analysis borrowing policies escrow transactions replicated environment 
ieee sixth international conference data engineering pages 
kumar 
ects optimistic replication distributed file system 
phd thesis carnegie mellon university december 
cmu cs 
kumar satyanarayanan 
log directory resolution coda le system 
second international conference parallel distributed information systems january 
kumar satyanarayanan 
flexible safe resolution le con icts 
winter usenix technical conference new orleans la january 
ladin barbara liskov shrira sanjay ghemawat 
providing high availability lazy replication 
acm trans 
computer systems 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
kurt josh osborne joseph malcolm 
drinking multicast usenet news 
winter usenix technical conference 
ftp ftp uu net networking news muse 
ps gz 
mattern 
virtual time global states distributed systems 
international workshop parallel distributed algorithms pages 
microsoft 
windows server resource kit 
microsoft press 
david mills 
rfc network time protocol version march 
www cis 
edu rfc rfc html 
david mills 
improved algorithms synchronizing computer network clocks 
acm sigcomm pages september 
mockapetris dunlap :10.1.1.156.7859
development domain name system 
acm sigcomm august 
mohan 
database perspective lotus domino notes 
acm sigmod international conference management data page may 
lily maria ebling satyanarayanan 
exploiting weak connectivity mobile le access 
th symp 
operating systems principles pages copper mountain december 
nakagawa 
mirroring directory hierarchy ftp 
noc jp html november 
patrick neil 
escrow transactional method 
tods 
oracle 
oracle server distributed systems manual vol 

john ousterhout herv da costa david harrison john kunze michael kupfer james thompson 
trace driven analysis unix bsd le system 
symp 
operating systems principles pages 
scott parker gerald popek gerard allen stoughton bruce walker evelyn walton johanna chow david edwards stephen charles kline 
detection mutual inconsistency distributed systems 
ieee trans 
software engineering se 
petersen spreitzer terry theimer demers 
flexible update propagation weakly consistent replication 
th symp 
operating systems principles pages october 
calton pu gail kaiser kun lung wu philip yu 
divergence control distributed database systems 
distributed parallel databases january 
calton pu avraham le replica control distributed systems asynchronous approach 
acm sigmod international conference management data pages denver may 
michael rabinovich gehani alex 
scalable update propagation epidemic replicated databases 
international conference extending database technology edbt pages march 
david ratner 
roam scalable replication system mobile distributed computing 
phd thesis uc los angeles 
ucla csd 
neil rhodes julie 
palm programming developer guide 
reilly december 
saito bershad levy :10.1.1.116.6208
manageability availability performance porcupine highly scalable cluster mail service 
th symp 
operating systems principles december 
yasushi saito 
dynamic decentralized replication algorithm cluster internet services march 
submitted publication 
yasushi saito je rey mogul ben verghese 
usenet performance study 
www research digital com wrl projects september 
sarin lynch 
discarding obsolete information replicated database system 
ieee transactions software engineering 
spreitzer theimer petersen demers terry 
dealing server corruption weakly consistent replicated data systems 
mobicom budapest hungary september 
sun microsystems 
sun directory services administration guide 
www sun com sims docs html admin july 
terry demers petersen spreitzer theimer welch 
session guarantees weakly consistent replicated data 
proceedings international conference parallel distributed information systems pdis pages austin tx september 
terry theimer petersen demers spreitzer hauser 
managing update con icts bayou weakly connected replicated storage system 
th symp 
operating systems principles pages cooper mountain december 
robert thomas 
majority consensus approach concurrency control multiple copy databases 
acm trans 
database systems june 
duane wessels cla rfc internet cache protocol september 
www cis ohio state edu rfc rfc html 
wolman voelker sharma cardwell karlin levy 
scale performance cooperative web proxy caching 
th symp 
operating systems principles december 
wuu bernstein 
ecient solutions replicated log dictionary problems 
rd acm symp 
princ 
distr 
computing pages 
acm august 
jian yin lorenzo alvisi mike dahlin calvin lin 
hierarchical cache consistency wan 
nd usenix symp 
internet technologies systems pages october 
description basic algorithms type update record issuer replica id replica issued update 
ts timestamp timestamp issuer 
var tv timestamp vector replica timestamp vector 
proc reconcile peer send updates peer tv peer receive peer tv 
tv peer tv send peer updates issuer timestamp tv peer tv compute pairwise max tv tv peer proc receive update updates called reconcile 
foreach updates apply replica tv max tv issuer ts fig 
replica reconciliation timestamp vectors proc send update peer send updates peer 
values tm larger tm peer return tm peer tm send peer updates issuer timestamp tm peer tm peer tm send tm peer peer computes pair wise maximum element matrices compute new tm 
tm peer receive tm peer tm compute pairwise max tm tm peer proc receive update updates called send update 
foreach updates apply replica tm issuer max tm issuer ts fig 
replica reconciliation timestamp matrices 
