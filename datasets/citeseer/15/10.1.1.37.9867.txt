efficient implementation adaptive software jens palsberg cun xiao karl lieberherr northeastern university november adaptive programs compute objects just object oriented programs 
task accomplished specified called propagation pattern traverses receiver object 
object traversal recursive descent instance variables information collected propagated way 
propagation pattern consists name task succinct specification parts receiver object traversed code fragments executed specific object types encountered 
propagation patterns need complemented class graph defines detailed object structure 
separation structure behavior yields degree flexibility understandability traditional object oriented languages 
example class graph changed changing adaptive program 
efficient implementation adaptive programs 
adaptive program class graph generate efficient object oriented program example prove correctness core translation 
key assumption theorem traversal specifications consistent class graph 
prove soundness proof system conservatively checking consistency show implement efficiently 
appear acm transactions programming languages systems 
college computer science hall boston ma usa 
internet ccs neu edu 
phone fax 
partially supported national science foundation numbers ccr software engineering cda research instrumentation ccr software engineering 
background goal object oriented programming obtain flexible software mechanisms inheritance late binding 
example flexibility goals project led booch ada package converted component library 
templates parameterize certain components local substitutions possible 
argued opportunity bind certain decisions compile time run time package adaptable 
degree variability components limited 
stated building frameworks hard 
crafting general class libraries balance needs functionality flexibility simplicity 
strive build flexible libraries know exactly programmers abstractions 
furthermore wise build libraries assumptions environments possible programmers easily combine class libraries 
key feature popular approaches object oriented programming explicitly attach method program specific class 
result class structure changes methods need modifications 
read class hierarchy may rigid constraining structure hampers innovation evolution 
idea adaptive programs papers second third author colleagues 
basic idea separate program text class structure 
result called adaptive program 
collection propagation patterns computes objects just object oriented programs 
propagation pattern accomplishes specific task traversing receiver object 
corresponding object oriented program task may require family methods specified classes 
object traversal recursive descent instance variables information collected propagated way 
propagation pattern consists 
name task 
succinct specification parts receiver object traversed 
code fragments executed specific object types encountered 
separation structure behavior yields degree flexibility understandability traditional object oriented languages 
example class graph changed changing adaptive program 
adaptive software possible guess class graph minimal effort change new class graph 
contrast write example program needs significant updates class graph 
related approaches making software flexible 
comparison adaptive programming unique feature succinct traversal specifications 
briefly assess approaches closely related idea adaptive programs 
metaprogramming graph traversals usually expressed attribute grammars syntax directed facilities code walkers see 
attribute grammars detailing traversal necessary laborious subject maintenance problems raw object oriented methods containing explicit traversal code 
code walkers traversal specified separately functionality adaptive programs 
specifying traversal laborious traversal specifications uses defaults similar adaptive programming provides 
object oriented databases introduced ease development database applications 
object navigation common activity processing hierarchical object oriented databases 
queries specified terms navigating property value paths 
observed abiteboul bonner current object oriented databases applications demonstrate lack flexibility 
example restructuring object schemas triggers amount restructuring database applications accordingly 
markowitz shoshani observed need writing adaptive database queries 
state order express database queries users required remember understand large complex database structures 
important relax requirement allowing users express concise abbreviated queries manage partial knowledge database structure 
kifer kim sagiv allow similar abbreviated queries path expression bound sequence attributes 
bussche vossen weights help determine meaning certain abbreviated path expressions 
succinct traversal specifications intended achieve conciseness 
rumbaugh proposed operation propagation mechanism specify object oriented software 
motivation increase clarity program specifications reduce amount code written 
lots operations copy print save propagate objects collection 
proceeded separating propagation part operation specified propagation attaching propagation attributes classes involved operation 
similar code walker approach 
doing rules propagating clearly declared easier understand modify amount code written reduced 
rumbaugh mechanism run time appears flexible succinct traversal specifications 
rumbaugh mechanism requires explicitly attaching propagation attributes individual class involved operation 
class structure evolves programmers update propagation attributes 
adaptive program may need update program underlying class structure changes 
harrison ossher need separate navigation responsibility processing responsibility simplifies system implementations eliminates amount explicit navigation code 
proposed means propagating messages objects widely separated network routing specifications 
single central navigator propagates messages routing specifications 
default routing specifications define messages pass uninteresting objects 
mechanism better rumbaugh mechanism routing specifications described relatively independent object structures 
primary difference mechanism theirs run time 
lamping abadi discuss methods assertions view 
view generalizes object oriented programming helps programmer flexibly express certain piece code correctly implement operation 
methods assertions view consistent adaptive view views complementary combined 
balzer discuss decontextualized components 
decontextualized component architecture description language provides usage context 
compilation decisions delayed context information available 
decontextualized components fewer commitments data control decisions ordinary components 
succinct traversal specifications 
kiczales lamping wrote problem say internal workings class library user write replacement modules saying implementor room 
meta object protocol community addresses problem meta object protocol programs address succinct subgraph specifications exploit regularities object oriented software 
object oriented programs especially follow programming styles law demeter small methods problem 
small methods problem results dispersed program structure hindering high level detailed understanding 
maintain object oriented software software developers trace operation propagated object hierarchy processing job getting done 
experience shows tracing time consuming error prone 
avoid small methods creating larger methods 
price significant maintenance problem method encode details class structure 
adaptive software solves small methods problem introducing large methods associated maintenance problem 
adaptive programs may succinct way document object oriented software 
large group small cooperative methods summarized propagation pattern 
result specification operation localized possibly shorter easier understand 
results efficient implementation adaptive programs 
adaptive program class graph generate object oriented program example prove correctness core translation 
key assumption theorem traversal specifications consistent class graph 
prove soundness proof system conservatively checking consistency show implement efficiently 
translation adaptive program class graph program implemented demeter system 
demeter system adaptive program compiled example assignexp formal body rand variable val var number val id ident exp class graph give example adaptive programming 
way informally introduce concepts defined reasoned sections 
suppose want write program print free variables scheme expression 
writing adaptive program generating program 
boundvars push formal void findfreevars boundvars boundvars pop body findfreevars boundvars void variable findfreevars boundvars boundvars contains print void findfreevars boundvars findfreevars boundvars rand findfreevars boundvars void exp findfreevars boundvars virtual member function void assignexp findfreevars boundvars val findfreevars boundvars var findfreevars boundvars program analyzing problem identify classes relationships yielding class graph shown 
simplicity example cover scheme 
take graph guess class graph solving problem 
uses kinds classes concrete classes drawn instantiate objects classes drawn instantiable 
uses kinds edges subclass edges drawn representing kind relations construction edges drawn gamma 
labels representing relations 
example subclass edge exp means class exp super class class construction edge val gamma 
number means class part called val type number 
write program directly see natural solution write methods called findfreevars classes exp variable assignexp 
explanation terminology syntax appendix operation void findfreevars boundvars traverse exp variable wrapper prefix boundvars push formal suffix boundvars pop wrapper variable prefix boundvars contains adaptive program 
program ingredients traversal processing 
traversal specified code bold font 
finds variable objects exp object 
processing code bold font maintains stack bound variables checks variable free variable stack 
adaptive program specify program 
compared program adaptive program shorter combined class structures 
adaptive program contains just propagation pattern problem solved simple 
propagation pattern consists signature traversal specification code wrappers 
propagation pattern specifies collection collaborating methods described 
informally traversal specification exp variable describes traversal exp objects traverse exp object locate variable objects nested inside 
call specification fragment traversal specification 
code executed traversals called wrappers written interpret traversal specification specifying set paths exp variable 
path described alternating sequence nodes labels 
set paths described regular expression shown 
regular expression concatenation sub expressions 
half union expressions 
second half union expressions 
sentence regular language alternating sequence nodes labels construction edge labels pi 
diamond vertices means second vertex subclass vertex 
example sentence exp pi variable corresponds path exp variable exp pi exp pi rand exp pi body exp pi assignexp val exp pi variable exp pi assignexp var variable exp pi formal variable regular expression sentence exp pi assignexp val exp pi assignexp var variable corresponds path exp assignexp val gamma 
exp assignexp var gamma 
variable set paths guide traversal exp object 
consider object graph 
object nodes graph 
object identifiers 
names colons classes objects 
edges labels part relationships objects 
want traverse object graph starting node guided set paths 
class node assignexp select paths set exp pi assignexp 
paths described regular expression 
exp pi assignexp val exp pi exp pi rand exp pi body exp pi assignexp val exp pi variable exp pi assignexp var variable exp pi formal variable exp pi assignexp var variable remove prefix exp pi paths prefix gives insignificant information assignexp subclass exp left set paths described regular expression denote 
assignexp val exp pi exp pi rand exp pi body exp pi assignexp val exp pi variable exp pi assignexp var variable exp pi formal variable assignexp var variable having visited object continue visiting part objects 
parts called val var 
visit val part object select paths assignexp val exp remove prefix assignexp val yielding exp pi exp pi rand exp pi body exp pi assignexp val exp pi variable exp pi assignexp var variable exp pi formal variable class object select paths set described regular expression exp pi 

traversal stops node 
notice set paths guide traversal long possible 
reason traversal visits node run time information contents val part determined continue traversal 
traversal meets simply abandons path 
visit var part object select paths described regular expression exp pi variable remove prefix exp pi yielding just variable 
visiting object check part objects need visited 
outgoing edge variable path traversal stops node 
nodes visited marked black 
cycles object graph may lead non terminating traversal 
demeter system handle situations inserting appropriate code code wrappers 
possibility discussed 
val var assignexp variable val var val id assignexp variable ident number exp object indicate efficiently implement traversal 
set paths described traversal specification forms graph called propagation graph see 
graph subgraph class graph 
propagation pattern translated follows 
ffl class propagation graph gets method interface specified line 
methods classes virtual explanation term virtual see appendix 
ffl class outgoing construction edge propagation graph method contain method invocation corresponding part 
notice subclass edges propagation graph cause generation code late binding gives right behavior 
assignexp formal body rand variable val var source vertex traversal starts target vertex traversal ends exp propagation graph variable exp propagation graph void findfreevars boundvars formal findfreevars boundvars body findfreevars boundvars void variable findfreevars boundvars void findfreevars boundvars findfreevars boundvars rand findfreevars boundvars void exp findfreevars boundvars virtual member function void assignexp findfreevars boundvars val findfreevars boundvars var findfreevars boundvars traversal skeleton rules propagation graph translated program skeleton 
code wrappers lines enhance traversal specification print free variables 
wrapper clause attached class adds statement method class 
wrapper clause attached class variable adds statement method class variable 
resulting enhanced program statements bold font wrappers 
boundvars push formal void findfreevars boundvars boundvars pop formal findfreevars boundvars body findfreevars boundvars void variable findfreevars boundvars boundvars contains print void findfreevars boundvars findfreevars boundvars rand findfreevars boundvars void exp findfreevars boundvars virtual member function void assignexp findfreevars boundvars val findfreevars boundvars var findfreevars boundvars generated program automatically generated program differs handwritten just way follows 
method contains extra method invocation 
reason simply outgoing construction edge causes generation method invocation 
particular example extra method invocation effect harm 
program efficient course 
general may interested writing traversal specification certain edges bypassed 
example write edge variable bypassed generated code exactly 
possible demeter system discussed 
suppose change class graph adding new classes subclasses exp letting class variable part class renaming labels var val rvalue lvalue respectively 
resulting class graph 
written program hand need considerable change 
contrast adaptive program needs change 
program generated adaptive program new class graph 
example indicates compared object oriented software adaptive software shorter flexible easier understand maintain 
compatibility consistency subclass invariance generating object oriented program adaptive program class graph require traversal specifications compatible consistent class graph require propagation graph determined traversal specification subgraph class graph 
section gives informal motivation concepts 
notions compatibility consistency subclass invariance tied concept propagation graph briefly mentioned previous section 
propagation graph starting point generating code traversal specification 
propagation pattern class graph task compute propagation graph 
propagation graph represents paths traversed 
set paths may infinite propagation graph represents compactly 
intuitively compatibility consistency subclass invariance understood follows 
number val assignexp formal body rand var ident variable id lvalue rvalue exp class graph void findfreevars boundvars findfreevars boundvars rand findfreevars boundvars boundvars push formal void findfreevars boundvars boundvars pop formal findfreevars boundvars body findfreevars boundvars void variable findfreevars boundvars boundvars contains print void exp findfreevars boundvars virtual member function void findfreevars boundvars var findfreevars boundvars void assignexp findfreevars boundvars lvalue findfreevars boundvars rvalue findfreevars boundvars void findfreevars boundvars findfreevars boundvars findfreevars boundvars findfreevars boundvars adapted program ffl compatibility 
propagation graph represents certain paths 
ffl consistency 
propagation graph represents specified paths 
ffl subclass invariance 
nodes propagation graph subclass path class graph 
conditions ensure correctness rules previous section generating efficient traversal code 
specification compatible class graph traversals may reach specified subobjects 
specification consistent class graph propagation graph subclass invariant subgraph class graph traversals go wrong illustrated 
attempt compile adaptive programs conditions 
require representation paths 
currently know efficiently prefer class graphs lead violation conditions 
experience demeter system indicates conditions met typical programs 
cases conditions violated usually straightforward decompose traversal specification components meets conditions 
checking compatibility straightforward compute propagation graph check represents certain paths 
checking subclass invariance straightforward compute propagation graph node pair propagation graph check connected subclass edges original graph propagation graph 
checking consistency non trivial section devoted problem 
traversal specifications combined ways example concatenation paths union sets paths 
analogy type checking want compositional consistency checking 
combine specifications consistent graph want check combination consistent graph 
section compositional proof system checking prove sound 
give efficient algorithm checking compositional consistency 
give informal outline system 
consider class graph 
traversal specification left bottom describes traversal expression object 
traversal visits numerical objects nested compound objects expression object 
corresponding propagation graph 
unfortunately propagation graph path expression numerical go compound 
call path short cut 
efficient traversal code generated propagation graph visit numerical object nested compound object 
consider class graph 
propagation specification right bottom describes traversal object 
specification says want visit name object nested cat object owned female pet lover nested dog object owned male pet lover 
corresponding propagation graph 
unfortunately propagation graph paths satisfy specification male pet gamma 
pet cat name gamma 
name female pet gamma 
pet dog name gamma 
name 
expression compound add op arg arg male pet cat dog pet pet name name name expression compound arg arg male pet cat dog pet pet name name name female female expression compound compound numerical number value numerical numerical female cat female male dog male cat name dog name short cut zigzag source vertex traversal starts target vertex traversal ends inconsistency call paths zigzag paths 
efficient traversal code generated propagation graph visit name objects matter 
cases traversal specifications consistent class graphs 
soundness theorem states conservatively check consistency sufficient able rule short cuts zigzag paths 
show example significance subclass invariance condition 
program prints owned families 
illustrates propagation graph program applied class graph 
notice refrigerator subclass thing class graph propagation graph 
shows code generated propagation graph 
code method attached thing virtual method 
late binding refrigerator object matter part object family object printed 
subclass invariance rules program 
notice decompose traversal specification country family family refrigerator easy see propagation graphs satisfy subclass invariance condition 
programmer rewrite program propagation patterns solve problem detected 
turn formal presentation results 
section syntax semantics adaptive programs 
section show core part efficient implementation adaptive programs prove corresponding correctness theorem 
section prove soundness proof system conservatively checking consistency show implement efficiently 
country thing family refrigerator second country thing family refrigerator second country thing family refrigerator second void country void virtual method void thing virtual method void family print void second void refrigerator violation subclass invariance operation void traverse country family delta family refrigerator wrapper refrigerator prefix find owned families semantics adaptive programs define concepts graphs paths class graphs object graphs traversal specifications wrappers semantics adaptive programs semantics object oriented target language 
graphs directed graph pair set nodes set edges theta source target 
operation graphs defined follows 

totally ordered set labels pi define pi consider graphs edge label edge label written graph node edges denotes set edges paths path graph sequence nodes graph gamma labels edge graph gamma 
call source target path respectively 
define concatenation suppose sets paths paths target paths source define delta fp path set reduce fv pi gamma head fv reduce intuitively path reduce obtained path removing prefix labels pi 
head set classes get pi labels 
example consider graph denote set paths exp variable see 
head variable assignexp path set node label select fv reduce ug car fv select cdr fv select lg intuitively select set paths postfix begins head 
car set edges 
cdr set tails head label example select assignexp language assignexp val exp pi exp pi rand exp pi body exp pi assignexp val exp pi variable exp pi assignexp var variable exp pi formal variable assignexp var variable car assignexp val exp assignexp var cdr var assignexp language denotes language generated regular expression operator graph maps set paths smallest graph contains paths 
set paths consists paths graph set paths convex graph non empty form paths 
write root leaf lemma convex path set head car fu ng cdr paths leaf proof 
immediate 
class graphs notion class graph akin 
class graph finite directed graph 
node represents concrete class 
predicate true nodes represent classes false 
edge labeled element edge indicates class represented instance variable name type represented edge called construction edge 
pi edge indicates class represented subclass represented edge called subclass edge 
construction edges outgoing construction edge label binary equality predicate classes written nodes phi class graph nodes phi subclass phi true head paths phi false 
intuitively path phi consists subclass edges 
phi phi class graphs phi subclass invariant subgraph phi phi subgraph phi phi subclass phi subclass phi 
node rome node class graph phi node phi paths phi head paths phi car paths phi edges phi notion rome node central proof correctness implementation adaptive programs 
class graph flat node outgoing subclass edges 
class graph straightforward generate equivalent flat 
class graphs equivalent define set objects 
object preserving class transformations studied 
henceforth assume class graphs flat 
object graphs object graph finite directed graph 
node represents object function class maps node class concrete class class graph 
edge labeled element edge indicates object represented part object represented node label outgoing edge label class graph phi object graph omega gamma omega conforms phi node omega gamma class node phi ffl class phi exists omega subclass phi class 
traversal specifications traversal specification generated grammar delta nodes class graph 
slogan language calculus traversal specifications 
idea language extended ways ease programming contain essential constructs 
possible extensions include empty specification notation including excluding certain edges boolean connectives 
demeter system extensions 
traversal specification denotes set paths class graph phi intuitively follows 
paths lead rome 
directive set paths set paths phi delta concatenation sets paths union sets paths traversal specification meaningful formed 
traversal specification formed determines source node target node concatenation meeting point union set paths preserves source target 
formally predicate wf defined terms functions source target map specification node 
wf true wf delta wf wf target nodes source wf wf wf source nodes source target nodes target source target source delta source target delta target source source target target source source node determined target target node determined formed pathset phi set paths phi source target defined follows pathset phi paths phi pathset phi delta pathset phi delta pathset phi pathset phi pathset phi pathset phi lemma wf pathset phi defined path pathset phi starts source ends target 
proof 
induction structure wrappers wrapper map mapping concrete classes class graph code wrappers statements language example idea object processed adaptive program code wrapper class object executed 
ease programming convenient prefix suffix wrappers indicated example section 
demeter system supports vertex wrappers construction edge wrappers consider vertex wrappers 
adaptive programs general adaptive program collection propagation patterns 
simplicity consider case just propagation pattern 
adaptive program consists formed traversal specification pair wrapper maps prefix suffix wrappers 
class graph phi object graph omega gamma node omega gamma semantics function run run phi omega execute traverse pathset phi omega traverse omega omega omega object graph node omega gamma path set phi sequence objects judgement omega means traversing object graph omega starting guided path set traversal history sequence objects traversed 
formally holds judgement derivable rule omega cdr class omega delta delta delta car class fclass ng omega label turnstile indicates semantics 
functions car cdr perform operations sets paths informally described example section 
notice rule axiom 
call execute executes sequence prefix wrappers class objects reverse order suffix wrappers class objects leave execute unspecified definition depends language code wrappers written 
target language compile adaptive programs object oriented target language 
source language contains adaptive programs consisting propagation pattern target language correspondingly simple 
program target language partial function nodes class graph methods 
methods name 
semantics name explicit clarity call discussion 
method tuple form hl invoked method executes sending message subobjects labeled omega object graph node omega gamma program target language sequence objects judgement omega means sending message get traversal object graph omega starting traversal history 
formally holds judgement derivable rule omega omega delta delta delta class hl omega label turnstile indicates target 
notice rule axiom 
intuitively rule says sending message check understands message invoke method 
program target language straightforward generate example program 
efficient implementation adaptive programs implement adaptive programs efficiently representing pathset phi graph pathset phi propagation graph 
advantage representation graph pathset phi efficiently computed function pg phi defined follows pg phi graph paths phi pg phi delta pg phi pg phi pg phi pg phi pg phi lemma wf pg phi graph pathset phi pathset phi paths pg phi source target 
proof 
induction structure intuitively may view pathset phi high level interpretation traversal specification describes intent programmer 
contrast paths pg phi source target low level interpretation describes paths implementation consider 
drawback low level interpretation graph pathset phi may contain paths source target pathset phi 
formed specification class graph phi formed specification consistent class graph phi written phi pathset phi paths pg phi source target intuitively formed specification consistent class graph high level interpretation low level interpretation coincide 
compatible phi path phi source target 
translation adaptive programs target language requires compatibility consistency subclass invariance 
class graph phi traversal specification define target program comp phi comp phi pg phi phi class graphs phi phi phi subgraph phi phi phi partial function nodes phi methods ffl concrete class phi phi phi hl edges phi fv ng ffl concrete class phi phi subclass phi phi phi phi hi 
ffl classes phi phi phi undefined 
demeter system compiler generates empty virtual methods classes phi target language inheritance model empty virtual methods generate empty methods concrete classes outside phi subclasses class phi correctness translation proved follows 
lemma wf phi compatible phi pathset phi convex pg phi source root pathset phi target leaf pathset phi 
proof 
immediate lemma 
lemma wf compatible phi target rome node pg phi 
proof 
induction structure lemma class graphs phi phi phi subclass invariant subgraph phi object graph omega conforming phi convex path set phi node omega subclass phi root class leaf rome node phi traversal history omega iff omega phi phi proof 
suppose omega derivable 
proceed induction structure derivation omega omega derivable car class fclass ng omega omega cdr class derivable cases 
class phi car class 
subclass phi root class phi phi class hi omega phi phi derivable 
second class phi leaf rome node phi path phi class leaf 
subclass phi root class phi subgraph phi subclass phi root class path phi root class consisting subclass edges 
convex phi get class head 
leaf rome node phi car class edges phi class 
phi phi class hl lemma get cdr class convex leaf cdr class rome node phi omega conforms phi subclass phi root cdr class class induction hypothesis omega phi phi derivable omega phi phi derivable 
converse proved similarly 
theorem correctness class graph phi formed specification object graph omega conforming phi node omega subclass phi source class traversal history phi compatible phi pg phi subclass invariant subgraph phi omega pathset phi iff omega comp phi proof 
lemma pathset phi convex pg phi source root pathset phi target leaf pathset phi 
lemma target rome node pg phi 
comp phi pg phi phi follows lemma 
compositional consistency algorithm compositional consistency checking 
specification algorithm form inference rules 
phi phi nodes write phi phi case paths phi phi paths phi delta paths phi 
phi phi nodes write phi phi paths phi phi paths phi paths phi 
judgement phi means compositionally consistent phi 
judgement conservative sense formed specifications phi implies phi necessarily vice versa 
rules phi phi phi phi delta pg phi pg phi source target target phi phi phi pg phi pg phi source target theorem soundness wf phi implies phi proof 
proceed induction structure derivation phi base case consider phi 
prove phi amounts proving pathset phi paths pg phi immediate 
induction step consider phi delta prove phi delta amounts proving pathset phi delta paths pg phi deltad source target turn amounts proving pathset phi delta pathset phi paths pg phi pg phi source target 
induction hypothesis phi phi need prove paths pg phi source target delta paths pg phi source target paths pg phi pg phi source target wf delta get target source clearly paths pg phi source target delta paths pg phi source target paths pg phi pg phi source target reverse inclusion follows pg phi pg phi source target target consider phi prove phi amounts proving pathset phi paths pg phi source target turn amounts proving pathset phi pathset phi paths pg phi pg phi source target 
induction hypothesis phi phi need prove paths pg phi source target paths pg phi source target paths pg phi pg phi source target wf delta get source source target target clearly paths pg phi source target paths pg phi source target paths pg phi pg phi source target reverse inclusion follows pg phi pg phi source target 
converse theorem general false 
example consider specification delta graph phi fa cg fa cg 
clearly wf phi phi phi delta 
see phi delta notice amc paths pg phi delta amc pathset phi delta 
phi decide phi algorithm input specification graph phi 
check wf 
check phi ffl building pg phi recursively way ffl computing appropriate instances 
compute wf jdj time build pg phi jdj phij time check instance phij time 
total running time jdj phij 
implementation adaptive programs main advantages 
loss efficiency compared conventional object oriented programming 
generated objectoriented code efficient equivalent hand written traversal code 
examples target language 
possible typed language classes multiple inheritance instance variables methods late binding eiffel 
second scales 
intuitively classes program contains longer paths corresponding class graphs 
larger programs means traversal code 
implementation adaptive programs traversal code automatically generated 
usefulness adaptive software hinges questions 
traversal happens object oriented programs 

traversal specified succinctly 
regarding statistics object oriented systems show contain small methods 
small methods tend contain traversal code presence documents traversal common 
reason traversal common task implement worker classes interesting participate traversals 
go task task class worker may vice versa 
regarding experience demeter system indicates forms traversal appear object oriented programs nicely captured language traversal specifications 
happens traversal going succinct specification traversal want may simply empty traversal specification propagation pattern 
leads generation object oriented program just method propagation pattern 
believe situations traversal succinct traversal specification rare practice 
notice object oriented program reengineered adaptive program 
idea specify method propagation pattern empty traversal specification 
demonstrates adaptive program need long object oriented program task 
conventional object oriented programming object traversal may specified patterns 
gamma helm johnson vlissides introduce structural design pattern composite behavioral design pattern visitor 
composite pattern describes compose objects tree structures represent part hierarchies visitor pattern serves traverse part hierarchy 
respect traversal operations read problem distributing operations various node classes leads system hard understand maintain change 
idea visitor pattern code traversal times 
consequences visitor pattern ffl adding new operations traversal easy 
need change class traversal domain 
ffl related behavior localized visitor spread classes defining object structure 
ffl hard add new class participant traversal 
read new classes participate traversal added frequently probably easier just define operations classes structure 
adaptive software achieve goals visitor pattern effectively 
propagation pattern gathers place code describes traversal 
easy add new class participant traversal 
deductive databases searching guided logical rules 
current addresses combining deductive databases object technology 
believe succinct traversal specifications help eliminate need rules 

authors mitchell wand numerous discussions wealth suggestions improve ideas 
authors jan van den bussche anonymous referees helpful comments draft 
appendix appendix readers familiar 
extension classes generalization structures members class data called data members functions member functions 
table shows different terminology smalltalk clos 
smalltalk clos data member instance variable named slot member function method function virtual function method generic function member function call message send function call table terminology terminology class inherited class class called base class superclass class called derived class subclass 
class may supertype class 
need case inheritance socalled private 
class supertype class class supports member function interfaces supports 
furthermore member function defined class member function interface different implementation overrides implementation late binding function calls possible declaring member function virtual outline follows 
class public virtual void code fragment gives member function definition 
void implementation goes keyword void means method return value 
syntax resolves function member function class fragment enclosed braces implementation member function contains line comment starting 
variable holds objects kinds ffl holding object directly 
defined ffl holding address object 
defined class supertype variable second definition hold addresses objects addresses objects 
invoke member function object pointed variable uses syntax 
serge abiteboul anthony bonner 
objects views 
james clifford roger king editors proceedings acm sigmod international conference management data pages 
acm press may 
paul 
object preserving class transformations 
proc 
oopsla acm sigplan sixth annual conference object oriented programming systems languages applications pages 
grady booch 
design booch components 
object oriented programming systems languages applications conference special issue sigplan notices pages 
acm press 
grady booch 
design application framework 
dr journal february 
stefano ceri tanaka shalom tsur 
deductive object oriented databases 
springer verlag lncs 

path constraints graph data models unified theory typing constraints equations functional dependencies 
delobel kifer editors second international conference dood pages 
springer verlag 
dayal 
queries views object oriented data model 
richard hull ron morrison david stemple editors proceedings second international workshop database programming languages pages 
morgan kaufmann june 
jan van den bussche vossen 
extension path expressions simplify navigation object oriented queries 
proc 
deductive object oriented databases pages 
springer verlag lncs 
margaret ellis bjarne stroustrup 
annotated manual 
addisonwesley 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
appear 
simon gibbs dennis tsichritzis eduardo oscar nierstrasz xavier 
class management software communities 
communications acm september 
adele goldberg david robson 
smalltalk language implementation 
addison wesley 
goldman 
code walking recursive descent generic approach 
proc 
second clos users implementors workshop 
william harrison harold ossher 
structure bound messages separating navigation processing 
manuscript 
linda 
specifying adapting object behavior system evolution 
conference software maintenance pages 
ieee press 
gregor kiczales john lamping 
issues design documentation class libraries 
proc 
oopsla acm sigplan seventh annual conference objectoriented programming systems languages applications pages 
michael kifer won kim yehoshua sagiv 
querying object oriented databases 
sigmod pages 
acm 
john lamping mart abadi 
methods assertions 
pareschi mario tokoro editors european conference object oriented programming 
springer verlag lncs july 
karl lieberherr 
component enhancement adaptive reusability mechanism groups collaborating classes 
van leeuwen editor information processing th world computer congress pages 
elsevier 
karl lieberherr 
art growing adaptive object oriented software 
pws publishing boston 
karl lieberherr ian holland 
assuring style object oriented programs 
ieee software pages september 
karl lieberherr walter silva cun xiao 
experience graph propagation pattern programming tool 
gene forte editor international workshop case pages 
ieee computer society 
karl lieberherr silva cun xiao 
adaptive object oriented programming graph customization 
communications acm may 
karl lieberherr cun xiao 
minimizing dependency class structures adaptive programs 
nishio yonezawa editors international symposium object technologies advanced software pages 
springer verlag november 
karl lieberherr cun xiao 
object oriented software evolution 
ieee transactions software engineering april 
victor markowitz arie shoshani 
abbreviated query interpretation entityrelationship oriented databases 
lawrence berkeley lab berkeley ca 
victor markowitz arie shoshani 
object queries relational databases language implementation application 
proc 
th international conference data engineering pages 
ieee press 
bertrand meyer 
object oriented software construction 
prentice hall englewood cliffs nj 
jens palsberg michael schwartzbach 
object oriented type systems 
john wiley sons 
james rumbaugh 
controlling propagation operations attributes relations 
object oriented programming systems languages applications conference special issue sigplan notices pages 
acm 
guy steele 
common lisp language 
digital press burlington ma second edition 
william waite gerhard goos 
compiler construction 
springer verlag 
norman wilde ross 
maintenance support object oriented programs 
conference software maintenance pages 
ieee press 
norman wilde ross 
maintenance support object oriented programs 
ieee transactions software engineering pages december 
norman wilde paul matthews ross 
maintaining object oriented software 
ieee software pages january 
david 
program developments formal explanations implementations 
communications acm november 
david 
organizing programming knowledge syntax directed experts 
proc 
int 
workshop advanced programming environments pages 
springer verlag lncs 
david robert balzer 
architecture compilation 
sponsored arpa january 

