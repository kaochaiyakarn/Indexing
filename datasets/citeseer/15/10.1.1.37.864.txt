representing actions laws observations hypotheses baral michael gelfond alessandro department computer science university texas el paso universit di bologna el paso texas 
bologna italy cs edu cir unibo propose modi cation action description language language allows representation hypothetical situations hypothetical occurrence actions representation actual occurrences actions observations truth values uents actual situations 
corresponding entailment relation formalizes various types common sense reasoning actions ects modeled previous approaches 
application architecture intelligent agents capable observing planning acting changing environment entailment relation logic programming approximation entailment implement planning module architecture 
prove soundness implementation give sucient condition completeness 
perform nontrivial reasoning intelligent agent situated changing domain needs knowledge causal laws describe ects actions change domain ability observe record occurrences actions truth values uents particular moments time 
central problems knowledge representation discovery methods representing kind information form allowing various types reasoning dynamic world time tolerant updates 
numerous attempts nding solutions problem developments see instance special issue journal logic computation geo workshop proceedings wor 
attempts primarily concerned nding mathematical models describing ects actions designing languages entailment relations suitable axiomatization models discovering inference mechanisms capable uents mean propositions truth values depend time 
eciently drawing inferences axioms 
orts directed development methodologies building provably correct systems capable reasoning actions 
continue started gl authors introduced high level action description language capable expressing causal laws describe ects actions statements values uents possible states world 
entailment relation language models hypothetical reasoning similar situation calculus mcc mh 
years syntax semantics expanded allow descriptions ects concurrent non deterministic actions descriptions global constraints expressing time independent relations uents bg kl bt bar gl bt ht mt 
viewed complementary alternative approach direct axiomatizations theories actions classical logic nonmonotonic extensions pr pin rei ls ms pro 
believe approaches developed serious comparison possible 
brie mention attractive features shared action description languages 
simple restrictive syntax gives advantage speci er similar advantage pascal pl risc languages assembly language ibm 
semantics notion automaton provides additional insight behavior corresponding dynamic system 
languages commit speci set logical connectives believe advantageous certain situations see instance mt bar 
improve expanding ontology actual situations interpreted sequences actions describing actual evolution system opposed hypothetical situations 
consequently new language capable expressing actual situations temporal ordering observations truth values uents actual occurrences actions situations 
corresponding entailment relation formalizes various types common sense reasoning actions ects modeled previous approaches 
clarify motivation consider simple example suppose story john needs bring packed suitcase airport 
john knows car doing action drive airport airport home 
similarly action hit car occurs car action rent car occurs car action pack occurs home suitcase packed 
john knows home airport car 
plan packing suitcase driving airport adequate achieve john goal 
follows plan starts packing suitcase 
right example spirit glasgow london moscow problem mcc 
italicized terms story correspond actions uents example 
packing observes car hit 
rest original plan longer achieve goal 
plan rst performing rent car performing drive airport adequate 
longstanding goal learn design implement programs capable simulating types behavior exhibited john story 
rst step mathematical theory help write similar programs 
believe language corresponding entailment relation form important part theory 
allow precisely describe ects actions available john results john observations characterize set valid past current states world reasonably john basis knowledge 
course 
succeed designing program simulating john behavior need better understand dynamics 
particular theory suggest program architecture possible way decomposing problem simpler independent modules responsible di erent intellectual tasks planning current situation updating current domain description new observations 
develop methodology implementing modules speci cation 
rst sections devoted description syntax semantics entailment relation application entailment design architecture intelligent agents capable observing planning acting changing environment 
start description language capable expressing general laws governing ects actions observations values uents occurrences actions particular situations 
section extend allowing hypothetical reasoning 
probably worth noting extension believe allowing hypothetical statements form uent true execution sequence actions domain descriptions unnecessary presence actual situations facts leads certain complications see section appendix discussion aspect 
limit hypothetical statements queries 
domain descriptions contain causal laws describing ects actions facts hypotheses 
restrictions lead clearer ontology semantics language 
section addresses question computing entailment relation domain descriptions generated architecture 
follow basic idea gl translate domain descriptions declarative logic programs 
su cient conditions type domain description guarantee soundness completeness translation adds list translations domain descriptions action description languages di erent ontologies disjunctive abductive equational logic programs dun dds ht tur alp 
able answer queries need particular query answering algorithm 
standard prolog interpreter implemented instance quintus prolog certainly popular large family algorithms csw adp natural choice 
consequently view prolog program prove soundness completeness prolog inference mechanism answer set semantics gl part discuss implementation planning module proposed system :10.1.1.49.9332
module consists procedural part generates candidate plans declarative description domain description represented translation testing 
planner simple clear declarative speci cation proven correct speci cation 
planner changing domains 
allows line new objects domain appearing new block table blocks world addition new information values uents occurrences actions 
nonmonotonic capable creating new plans new observations invalidate old plans 
reports literature planners combining features wel ped aware system contains 
inclusion features framework require special ort 
main purpose building planner clarity provable correctness eciency bad expected 
domains wel tested planner performed better particular queries initial states considered believe developing action speci cation languages approximating entailment relation logic programming contributes better understanding underlying ontological principles reasoning actions advantages limitations logic programming languages tools implementing reasoning 
allowed establish equivalence previously known theories actions seemingly di erent intuitions languages logics kar kar stimulated theory implementation logic programming languages ab tur mt lt lmt 
software engineering standpoint theories actions interesting testbed building provably correct classes logic programs speci cations 
contributes better understanding process 
hope development planners general theories actions contribute establishing closer ties theories actions planning logic programming 
syntax start description language capable expressing general laws governing ects actions observations values uents occurrences actions particular situations 
section extend allow hypothetical reasoning 
answer set semantics essential 
coincides founded semantics 
self contained de nition answer set semantics appendix currently process doing extensive testing randomly generating queries initial states 
alphabet consists disjoint nonempty sets symbols called uents actions actual situations 
elements denoted possibly indexed letters respectively 
assume contains special situations called initial current situations 
uent literal uent possibly preceded negation 
fluent literals denoted possibly indexed letters possibly preceded 
equated uent denote sequences actions greek letter indexed versions 
action means sequence actions follows denote sequence actions standard prolog notation lists 
example list actions denotes sequence actions followed kinds propositions called causal ect laws facts 
causal law expression form causes action uent literals 
called preconditions 
read law guaranteed true execution action state world true 
write ect law causes causal laws form causes causes said contradictory fp fq 
atomic uent fact expression form uent literal situation 
intuitive reading observed true situation 
atomic occurrence fact expression form occurs sequence actions situation 
states sequence actions observed occurred situation assume actions sequence follow immediately 
sequence mean nite sequence 
word causes may somewhat misleading may true action executed 
justify name probably require included list preconditions 
avoid notational confusion prefer keep name 
atomic precedence fact expression form precedes situations 
states situation occurred situation propositions type express general knowledge ects actions referred laws 
propositions called atomic facts observations 
fact propositional combination atomic facts 
collection laws facts called domain description sets laws facts domain description denoted respectively 
consider domain descriptions propositions mention situation constant see domain descriptions represent knowledge actions consider example example suppose series observations fred water fred seen alive dry 
moment shot red fred 
suppose generally known fred wet shooting fred dead 
information represented domain description consisting propositions acts alive dry squirt occurs precedes shoot occurs laws squirt causes dry shoot causes alive complete description need de ne language 
simplicity assume language contains uents actions actual situations mentioned propositions situation stated assumption examples 
domain descriptions conjunction informal assumptions clarify description meaning changes values uents caused execution actions actions language domain description ects actions speci ed causal laws domain actions occur needed explain facts domain description actions overlap happen simultaneously 
assumptions give reasonably intuitive understanding domain descriptions consider instance domain description example 
easy see assumption implies squirt action occurs shoot action occurs assumptions conclude moment fred wet alive moment story wet dead 
goal build mathematical model help better understand eventually types arguments 
rst step suggest semantics domain descriptions precisely speci es sets acceptable reached descriptions assumptions 
domain descriptions semantics intended system designers formal speci cation language 
semantics section introduce semantics action description language assume states world determined sets uents actions executed particular state add remove uents causal laws 
set possible behaviors dynamic system satisfying causal laws domain description described transition diagram states labeled sets uents transitions labeled actions 
interpret facts need select initial situation path diagram describing actual behavior system 
de nition idea formalized somewhat non standard way 
de ning transition function initial state describe automaton partial function action sequences states 
prefer slightly complex de nition appropriateness expanded domains may contain non deterministic actions kl triggers temporal facts idea precise need introduce terminology 
state set uents 
causal interpretation partial function sequences actions states empty sequence belongs domain pre closed pre closed mean sequence actions action domain called initial state partial function serves interpretation causal laws uent state say holds true holds false 
truth propositional combination uents respect de ned usual 
de ne ects actions determined causal laws domain description informal assumptions 
uent literal immediate ect executing ect law causes preconditions hold 
ff ect ff ect res 
res referred transition function 
de nition captures meaning causal laws de nition causal interpretation satis es causal laws sequence language res unde ned 
say causal model satis es causal laws easy see causal models domain descriptions uniquely determined initial values causal models domain description illustrate notion causal model example 
example consider domain description example 
transition diagram corresponds causal laws easy check function res de ned transition function diagram function causal model state diagram sequence actions action res 
hj qs alive dry alive dry shoot squirt shoot squirt shoot squirt squirt shoot states evolve 
example consider domain description consisting propositions causes causes easy see causal model domain description unde ned nonempty ffg 
continue de nition semantics consider arbitrary domain description causal model interpret observations rst need de ne meaning situations consider mapping sequences actions language mapping called situation assignment satis es properties 

pre sn 
de nition interpretation pair causal model situation assignment sn belongs domain sn called actual path simplicity denoted de ne truth facts interpretation facts true called false de nition interpretation true satis ed true occurs true sequence pre actual path precedes true proper pre truth non atomic facts de ned usual 
set facts true interpretation members true complete de nition model need formalize underlying assumption domain descriptions actions occur needed explain facts domain description 
done imposing minimality condition situation assignments leads de nition 
de nition interpretation called model domain description conditions satis ed 
causal model 
facts true 
interpretation satis es conditions subsequence domain description said consistent model 
notice prove consistent suces nd interpretation satisfying rst conditions de nition 
existence model follow niteness de nition minimizing occurrences actions comparing models initial state 
re ected condition 
alternative de nition obtained replacing condition interpretation satis es conditions subsequence second de nition minimization occurrences actions done regardless possible initial situations 
prefer rst de nition give equal preference possible initial situations minimize occurrences actions locally respect particular initial situations 
query language associated consist facts denoted de nition describes set acceptable obtain domain description sequence xm sequence subsequence exists strictly increasing sequence indices de nition domain description entails query written true models set facts entailed denoted cn 
say answer query unknown 
section devoted analysis formalizations examples reasoning actions literature 
examples section illustrate way examples domain descriptions represent information notion entailment captures informal arguments information descriptions informal assumptions 
domain description example demonstrate entailment relation model simple temporal projection 
proposition domain description unique model dry alive dry alive 
proof 
consider causal interpretation situation assignment de ned follows squirt alive shoot dry squirt sn squirt shoot 
easy check interpretation satis es de nition model show model model de nition situation assignment maps statements satis ed 
abbreviation 
causal models causal models uniquely determined initial values establish notice satisfy conditions actual path start squirt followed necessarily immediately shoot 
sn subsequence 
model satis es minimality condition de nition 
implies sn squirt shoot 
recall de nition situation assignment pre squirt shoot 
true squirt 
complete proof suces notice dry alive dry alive true example reasoning cases consider modi cation example precondition loaded shoot action guns initially loaded 
acts alive loaded loaded shoot shoot occurs laws shoot causes alive loaded shoot causes alive loaded proposition domain description consistent alive proof model de nition causal model satis es conditions shoot loaded shoot loaded model satisfy facts 
loaded loaded loaded loaded satisfy start shoot shoot minimality condition sn shoot shoot examining possible initial situation easy check sn satis es alive similar argument shows de ned initial condition loaded condition sn shoot shoot satis es conditions de nition consistent 
example explaining observations consider modi ed version example moment shot red fred moment fred observed dead 
new scenario represented domain description acts alive dry squirt occurs precedes alive laws squirt causes dry shoot causes alive arguments similar prove proposition proposition domain description consistent squirt shoot occurs domain description language hypothetical reasoning domain descriptions express types knowledge reasoning easily expressible variants lack ability hypothetical reasoning 
simple original version allows propositions form am 
statements understood di erent ways 
viewed observations read true execution sequence am actions 
believe reading misleading 
consider domain description containing statements ontology allow concurrent actions impossible observe occurring statements viewed facts domain description characterized inconsistent course case probably better understand saying am executed initial situation true 
reading allows statements querying domain descriptions possible outcomes actions 
want allow statements form domain descriptions language understand hypothetical counterfactual 
want nd language containing constructs absolutely necessary reasoning actions ects want preserve reading domain descriptions theories containing actual knowledge domain limit hypotheses queries domain descriptions 
appendix discuss restriction lifted 
go precise de nitions start introducing propositions form called hypotheses slightly generalizes syntax 
read sequence am actions executed situation uent literal true 
current situation simply write write currently language obtained allowing statements forms 
de nition domain descriptions coincide queries propositional formulas constructed atomic facts hypotheses 
observe de nitions query language strictly stronger means specifying domain descriptions powerful 
de ne semantics notions model domain description truth atomic facts models remain unchanged 
de ne answers queries need de nition domain description interpretation say hypothesis true interpretation true 
truth arbitrary queries sets queries de ned usual 
reasoner knowledge formulated domain description hypothetical queries various purposes 
probably important planning 
suppose reasoning agent domain description collection uent literals viewed goal achieved performing actions hypothetical statements entailment relation de ne notion plan de nition domain description set uent literals 
sequence actions plan achieving goal uent literal planning program able generate sequences actions viewed possible plans test entailment relation consider instance example 
example planning domain description described acts alive laws shoot causes alive loaded load causes loaded goal reasoner come candidate plan load shoot achieving goal 
candidate plan tested proving hypothetical statement alive load shoot checking alive load shoot 
easy check statement true load shoot plan notice plan carried absence outside interference resulting domain description obtained adding load shoot occurs entails presence outside interference plan may invalidated reasoner forced continue planning new current situation 
replanning discussed section 
previous example illustrates hypothetical reasoning 
example demonstrate hypothetical reasoning assumptions past 
example consider domain description notice contains information gun loaded initial situation 
suppose domain description reasoner know fred dead shooting assumption initially gun loaded 
naturally represented query loaded alive shoot easy see answer course intended answer 
entailment relation allows model sophisticated forms hypothetical reasoning 
notice translation informal question example maps 
question material implication 
possible premise possible models satisfying premise 
case example query form counterfactual 
example counterfactuals consider domain description acts alive loaded unload occurs laws shoot causes alive loaded load causes loaded unload causes loaded information reasoner able conclude gun shoot turkey point zero turkey dead 
example counterfactual statement shooting occurred situation translated material implication 
represented language atomic hypothetical statement alive shoot easy see accordance expectations 
type translation check statement gun shoot turkey point zero alive false 
mentioned counterfactual character follows fact shooting occurred hypothetical contrary occurrence fact consider statement initial moment gun loaded shoot turkey turkey dead 
counterfactual time part contrary occurrence fact previous example uent fact 
dicult see intuitively statement true represent language need represent state world closest gun unloaded 
easy see state di ers value uent loaded achieved executing action unload 
idea represent query alive unload shoot check entails examples course meant illustrate power entailment relation 
detailed study hypothetical counterfactual reasoning extensions scope 
notice expressible situation calculus unload occurs expressible loses counterfactual character represented situation calculus 
general uent literal introduce action causal rule causes translate counterfactual form true true de nitions notations useful discussions 
sets hypotheses 
say premise entails true model true 
denote easy see proposition set hypotheses inconsistent domain description model satis es important notice entailment relation de ned monotonic addition new hypotheses decrease set models satisfying increase set 
non monotonicity occur new factual information world new laws new facts added reasoner knowledge 
architecture autonomous agents ability express current situation record facts perform hypothetical reasoning viable candidate designing intelligent agents capable planning acting changing environment 
section outline possible approach design 
contrast previous sections material covered somewhat speculative character brie describe modules comprising agent control program illustrate main algorithm examples 
heavily relying reader intuition 
sections contain mathematical description modules correct domain independent inecient prolog implementation 
assume agent capable observing receiving outside world values uents occurrences actions executing actions 
assume maintaining internal model world collection possibly prioritized goals updated dynamically outside 
agent behavior controlled simple loop 
agent examines outside world stores obtained information internal model 

urgent goals selected set goals possibly including obtained step 

agent constructs plan achieve goals executes actions plan 
information execution stored agent internal model world control goes back step 
architecture simplifying assumptions 
assumes instance time agent nding plan executing action suciently short avoid disruption observations agent correct research establish restrictive assumptions really 
presence assumptions task building modeling intelligent agent dicult 
particular control strategy need things precise unambiguous language suitable describing agent internal model 
believe successfully purpose illustrate point consider agent john section trying achieve goals changing environment 
example consider story john section 
assume john execute actions pack drive rent observe truth values uents home airport car packed occurrences action hit 
initially internal world model john contains description ects actions represented domain description laws rent causes car hit causes car drive causes airport car drive causes home car pack causes packed home john initial observation values uents recorded collection facts facts home airport car goal bringing packed suitcase airport form currently packed airport 
nd plan actions john de nition previous section needs search sequence actions packed airport easy check packed airport pack drive 
important feature needed purpose available ability represent reason concurrent actions 
restriction imposed simplify presentation easily lifted see bg 
rest abbreviation 
satis ed plan john packs suitcase 
execution action recorded expanding new facts pack occurs precedes denote resulting description needs execute drive 
suppose action executed observations john control goes back step observes car hit truck 
event recorded expanding statements hit occurs precedes easy see resulting domain description currently car packed airport plan invalidated new information 
revise plan john poses query 
packed airport easy check packed airport rent drive 
suppose john goes execute time unpleasant interruptions 
easy see resulting domain description obtained adding statements rent occurs precedes drive occurs precedes entails john goal 
discussion suggests agent program constructed modules observe select goal plan execute organized simple loop 
clarify intuition give short description modules 
module observe consists parts observe facts obtain goals 
responsible obtaining new uent occurrence facts outside world storing agent internal model gets new goals priorities adds set goals agent 
module observe facts considers current internal model current situation performs steps calls submodule observe checks values observable uents expands corresponding uent facts 
notice remains current situation new internal model 
calls submodule observe action checks action occurred action observed occured expands statements occurs precedes situation constant occurring calls observe parameter notice current situation module select goal probably simplest 
selects urgent goals set goals agent 
module plan takes set uent literals goal selected previous step searches sequence actions set agent capable eciently testing entailment relation simple generate test methods 
call planners planners 
despite simplicity attractive features interesting subject investigation 
compare expressive power eciency various nonmonotonic formalisms testing serve testbed developing mathematical methods proving properties planners correctness completeness stability produced plans dynamic world 
instrumental evaluating eciency various domain dependent heuristics controlling generate part program comparing di erent approaches planning points mentioned elaborated sections 
module execute consists possibly complex part responsible physical execution action simple bookkeeping part expands internal model agent statements occurs precedes current situation situation constant occurring description valid contain unique current situation situation constant 
dicult see algorithm guarantees 
hope informal discussion section convinced reader ability express current situation record facts hypothetical reasoning interesting candidate language reasoning agent internal model 
certainly serve powerful speci cation language allowing concise description desired behavior agent 
course needed check agent architecture eciently implemented 
prospects actual implementation critically depend understanding entailment relation ability automate relation 
sections contain rst step direction 
approximating entailment relation methodology computing entailment relation translating domain description declarative logical theory approximating entailment general purpose inference mechanism answer queries success approach depends critically ability construct complete complete approximation eciency inference mechanism related computing entailment relations action description languages concentrated required powerful logics circumscription disjunctive abductive logic programming contrast concentrate sound complete translation circumscription see bgp 
translation declarative logic program answer set semantics inference mechanism incorporated standard prolog interpreter implemented instance quintus prolog 
known general mechanism complete due problems absence occur check may unsound 
show particular case problem translation domain description obtained algorithm previous section prolog interpreter shown sound complete declarative semantics see corollary 
pay course choice weak language possible incompleteness standpoint situation bad expect 
general sources incompleteness lack information values uents initial situation lack information occurrences actions temporal relations situations 
fortunately domain descriptions built agents constructed architecture explicit actual paths allow incompleteness knowledge values uents 
de nition clari es term 
de nition consistent domain description list situation constants occurring statements say explicit actual path precedes sequence actions occurs occurs 
easy see satisfying conditions unique actual path model sn de nition say domain description simple 
consistent 
explicit actual path 
facts atomic 
contain contradictory causal laws 
assumption de nition essential 
purpose simpler 
assumption removed adding rules de ne executability action situation 
describe program approximating entailment relation degree incompleteness depend amount information values uents initial situation lost process translation 
show knowledge values complete translation 
plan investigate abduction narrowing gap logic programming approximation proceed construction logic programming approximation alphabet consists symbols actions uent literals situations language predicates true true true false false occurs causes imm follows current contrary member uent literal ab standard prolog function symbol creating list 
typed variables actions lists actions uent literals lists uent literals variables indexed 
corresponding lower case letters denote constants respective types 
predicate symbol false viewed negation true 
re ect agreement introduce auxiliary terminology 
say atoms true false list terms incompatible program language consistent answer set answer set contains incompatible atoms 
simple domain description explicit actual path logic programming approximation entailment consist rules 
domain dependent axioms ap description actual path imm follows imm follows occurs occurs bc boundary conditions true cl causal laws causes causes 
domain independent axioms ea ects actions true true true causes true false contrary true true true jp true true false member false rst axioms describe ects actions individual uents axioms de ne truth falsity lists uent literals 
fi inertia axiom true literal true ab ab contrary causes false si second inertia axiom true literal imm follows occurs true 
library axioms contrary contrary contrary member member xj member jt member notice program contain de nition relation literal 
assume list atoms containing truth lists uents established axioms 
important realize stage rules ground instantiations schemas substitutions variables ground terms done accordance de nitions types 
means occurrences literal premises inertia axioms redundant removed ect declarative meaning program 
needed ensure correctness answers queries prolog interpreter 
soundness completeness entailment subsection formulate show soundness respect simple domain descriptions 
show restricted class complete respect limit query language formulas form query form denote true 
say declarative program sound consistent query prove soundness guarantee entailment relation approximate entailment state theorem show example complete 
example consider domain description notation denotes term neg acts occurs precedes laws causes causes easy check entail true 
proof soundness theorem lemmas 
introduce notation 
consider ground instantiations rules second inertia axiom si description actual path ap 
set instantiations containing situation constants denoted easy see consists union sets ground instantiations si ap 
lemma consider simple domain description obtained replacing si ap true true occurs 
query 
proof 
follows immediately splitting lemma see lemma appendix 
lemma simple domain description 
collection formulas form true program unique consistent answer set sound proof lemma easy see acyclic ab unique answer set ab 
denote prove soundness consistency showing true ii true iii true false iv false true obtain completeness expand program axiom true true epistemic disjunction gl abduction :10.1.1.49.9332
approach works general usefulness depends somewhat development availability query answering systems disjunctive abductive programs 
statements ii guarantee soundness statements iii iv guarantee consistency induction length formulae iv 
base case length 
true true true true implies 
ii induction length base length vacuously true inductive hypothesis length true implies induction length greater zero exists uent possibly empty list uents 
true true true implies inductive hypothesis 
implies 
iii consistent domain description true true rules heads formed predicate true true true obtain true false iv induction length base length rule false head 
rst argument false ground instance body belongs member false inductive hypothesis length false exists true induction length greater zero exists uent possibly empty list uents 
inductive hypothesis false exists true case true done consider case iii false true case true done consider case true 
lemma appendix false fact implies false ground instance body rule false head belongs lemma false inductive step suppose iv true length prove true length length greater zero assume 
true case causes true case true ab 
lemma case inductive hypothesis true implies easy see causes causes domain descriptions contain contradictory causal laws executable execution situation true models 
case inductive hypothesis true implies 
ab pair causes false lemma causes true lemma causes inductive hypothesis 
positive uent literal implies implies 

means reasoning negative uent literal similar 
ii proof modulo replacing proof ii 
iii show true false true time 
suppose true 
iii suppose false lemma true 
iii consistent iii iii true 
contradiction 
initial assumption false 
true false 
iv proof modulo replacing proof iv 
lemma rule true true tm hm program tm unique answer set sound proof 
induction base case 
lemma follows immediately lemma 
inductive step obviously tm tm hm 
inductive hypotheses tm unique consistent answer set bm notice set head see appendix forms splitting lt set tm 
bm answer set tm bm bm answer set partial evaluation hm bm hm bm easy see 
hm bm hm ftrue tm true inductive hypotheses tm sound implies uent literal true true 
actual path sm sm am satis es conditions lemma hm unique consistent answer set sound implies lemma tm theorem soundness simple domain description logic programming approximation sound proof easy see de ned lemma lemma program sound lemma program equivalent sound theorem soundness completeness restricted class simple domain description explicit complete information initial state uent language logic programming approximation sound complete proof easy see unique model lemmas unique answer set theorem proves soundness need prove completeness 
prove completeness need prove lemma 
lemma simple domain description explicit complete information initial state logic programming approximation 
de ned lemma 
implies true 
proof lemma notice unique model unique answer set induction index situation 
base case index 
suppose need show true prove induction length base case length 
consistent complete information initial state 
true implies true inductive hypothesis length implies true induction length greater 
situation index mean number 
case easy see implies inductive hypothesis true causes causes true inductive hypothesis pair causes false lemma ab lemma lemma true 
case proposition causes implies causes true program inductive hypothesis implies causes true ii proof lemma reverse direction 
implies true program lemma 
inductive step suppose implies true prove true prove induction length base case length 
implies true inductive hypothesis implies true lemma 
implies true lemma 
inductive hypothesis length implies true induction need show length implies true proof similar proof 
completes proof theorem 
computing proceed direction implementing declarative logic programs obtained translations 
theorem guarantees soundness viewed declarative logic program 
want computer answer queries need particular query answering algorithm 
prolog interpreter uni cation algorithm sldnf proof procedure leftmost selection rule cla ad certainly popular large family algorithms natural choice 
theorems ensure safely 
formulating result change notational convention 
follows identifying collection ground instances rules variables replaced ground terms accordance de nitions sorts 
viewed logic program variables input prolog interpreter 
collection ground instances unsorted language denoted collection ground instances obtained substitutions honoring sorts denoted queries ground atoms sorted language 
proofs mainly talk prolog inference referring declarative semantics 
theorem simple domain description logic programming approximation query prolog interpreter sound prolog answer answer 
proof 
mentioned prolog interpreter viewed implementation sldnf resolution prolog selection rule step selects resolution leftmost literal 
assume familiarity notion sldnf tree query program instance ab 
tree corresponds possible selection rule 
rule selects leftmost literal corresponding tree called tree 
branches tree represent possible derivations nodes contain goals nite sequences atoms possibly preceded nite branch ends node marked success node contains empty query leftmost member node goal atom preceded tree viewed directed graph ordering branches ignored 
prolog interpreter uses particular ordering branches corresponding top selection rules resolution distinction irrelevant results hold orderings 
containing uninstantiated variable failed resolution possible 
general branches tree course nite 
resolution proof procedure viewed search tree ground queries search returns particular subtree called main tree contains branch nal node marked success branches nal nodes marked failed 
known algorithm sound answer set semantics answer answer answer set contains 
actual prolog interpreter various prolog systems viewed implementation proof procedure important exceptions allows selection non ground queries form ignored 
implementation uni cation algorithm omits occur check may produce unsound results 
observations suggest structure proof 
demonstrate ground query occur check free ap non deterministic uni cation algorithm martelli montanari mm variants normally implemented prolog interpreters selects step requiring occur check 
show trees ground queries nodes marked 
observations imply ground queries di erences prolog interpreter proof procedure ignored soundness theorem query prolog answer answer 
proceed proving lemmas 
lemma simple domain description program occur check free ground queries 
proof 
prove lemma need notion moded program 
concept due dembinski dm proved useful establishing various properties logic programs 
need terminology mode ary predicate symbol mean function ng set called input position called output position write form 
intuitively queries formed predicate expected input positions occupied ground terms 
simplify notation writing atom assume sequence terms lling input positions sequence terms lling output positions 
denote expressions form var denotes set variables occurring assignment modes predicate symbols program called input output speci cation 
rule called moded input output speci cation var var 
words rule moded variable occurring input position body goal occurs input position head output position earlier body goal ii variable occurring output position head occurs input position head output position body goal 
program called moded input output speci cation rules 
apt pellegrini ap showed moded input output speci cation rule head contains occurrence variable output positions occur check free ground query consider input output speci cation true true false false true ab causes contrary member imm follows occurs easy check moded speci cation satis es second condition apt pellegrini theorem 
proves lemma 
lemma simple domain description query tree nodes marked 
proof 
prove lemma theorem ap independently discovered str moded input output speci cation predicate symbols occurring moded completely input ground query 
predicate symbols occurring false ab 
completely input speci cation lemma 
ends proof theorem 
theorems guarantee prolog interpreter complete answers entailed declarative program answers sound need lemma 
lemma simple domain description query 
proof 
prove lemma notion language tolerance mt 
program language languages containing instantiations ground terms languages called permissible 
program called language tolerant languages permissible holds consistent answer set consistent answer set obviously language extension language contain constants occurring prove lemma suces show language tolerant 
mt mccain turner give sucient condition tolerance uses notions stability predicate order consistency 
program input output speci cation 
rule said stable speci cation variable var program called stable input output speci cation rules 
stable stable input output speci cation 
de nition stability str 
mccain turner de nition substantially general 
notion predicate order consistency mt similar notion order consistency fag 
predicate dependency graph program nodes predicate symbols 
positive edge predicate symbol predicate symbol rule head contains expression body contains expression 
negative edge predicate symbol predicate symbol rule head contains expression body contains expression 
say relation holds path number negative edges path odd number negative edges 
predicate order consistent founded predicate symbol mccain turner prove stable predicate order consistent language tolerant 
de nitions input output speci cation lemma easy check conditions theorem satis ed 
ends proof lemma 
theorem simple domain description logic programming approximation query prolog answer answer proof 
lemma tree nodes suces prove prolog interpreter terminates tree nite 
sucient conditions termination literature 
probably best known acyclicity condition ab 
unfortunately rules si program acyclic need subtle termination condition 
notion acceptable program ap 
need terminology general logic program predicate symbols language 
refers rule head body depends belongs transitive closure refers 
neg set predicate symbol occur body rule neg set predicate symbols language predicate symbols neg depend 
denote program consisting rules heads contain predicate symbols neg clark completion denoted comp 
model called restriction predicates neg model comp 
mapping ground atoms set natural numbers called level mapping 
program acceptable level mapping interpretation model rule lm atom atom preceded ja jl program called acceptable acceptable level mapping interpretation 
apt pedreschi ap proved acceptable program gamma ground query derivations nite prolog interpreter terminates gamma 
result need prove acceptable program 
notice shown stable model 
lemma implies stable model say known stable model program model clark completion implies model number uent literals language plus uent literal list uent literals action list action situation constant action jaj list actions jrj 
uent literal jf list jp uent literals jp jpj 
js ready de ne level mapping false jsj jrj jpj jsj jrj jf true jsj jrj jpj jsj jrj jf jsj jrj jf jsj jf equal length second parameter atoms mapped 
dicult see acceptable implies sldnf tree nite including course tree completes proof theorem 
corollary simple domain description logic programming approximation query prolog answer prolog answer proof 
follows immediately theorems 
theorem guarantees soundness prolog algorithm entailment theorem simple domain description logic programming approximation query prolog answer proof 
notice theorem entailment corresponds entailment sound theorem follows immediately lemma theorems 
corollary simple domain description explicit complete information initial state logic programming approximation query prolog answer prolog answer proof follows immediately theorem corollary lemma 
implementing planner section logic programming approximation section construct implementation planner section 
assume domain description planner simple 
implementation plan obtained combining logic programming approximation domain description rules cs cs de ne current situation rules breadth rst search space possible action sequences rule de nes generate test planner 
cs sit assume relation action read action domain supplied programmer 
cs sit sit imm follows cs past imm follows cs current sit past generate generate xjy generate action find plan generate current true results previous section easily show plans produced planner correct shortest plan rst 
theorem guarantees completeness program fully known initial situations plan achieve goal plan 
course program plan terminate limit length plans guarantee termination imposing conditions 
planner attractive features 
simple clear declarative speci cation proven correct speci cation 

allows line new objects domain addition new information values uents occurrences actions 
alphabet may objects uents actions situations appear particular domain description 
may add new propositions domain description contain objects domain description 

nonmonotonic capable creating new plans new information invalidates old 
feature particularly useful design autonomous agents mae agent may plan execute part plan observe world necessary new plan 

easily incorporate heuristics domain constraints static dynamic kind 
domain constraints heuristics may part speci cation obtained learning program 
example consider case domain knowledge allows rule testing certain sequences actions 
domain property sequence actions satisfy domain constraints sequence actions pre satis es domain constraints rule modi ed follows 
generate xjy generate action satisfies domain constraints satisfies domain constraints means sequence actions xjy satis es domain constraints 
example simple domain constraint saying sequences actions action occurring consecutively expressed rules satisfies domain constraints violates domain constraints violates domain constraints xjz 
easily expanded accommodate advances action description languages 
planners expanding languages currently subset adl ped 
research logic programming theories actions progressed rapidly logic programming theories allow incomplete information initial state gl dds dun concurrent actions bg bt rami cations bar uent sequence actions theories determine truth execution directly conjunction rules cs cs extend plan 
working extending planner general domains doing serious comparison approach existing approaches planning wanted learn eciency 
tested planner domains blocks world briefcase home owner domains wel evaluating planners 
expanded planner additional knowledge prohibits generation impossible actions performance execution time planner comparable ucpop 
brie looked ways improving performance rst way combine imperative declarative paradigms programming 
instance replaced prolog generate procedure written gave order magnitude improvement performance loss testing 
second way multiple processors 
generate test programs exact kind programs give maximum speed parallel computer parallel logic program interpreter compiler exploits parallelism 
preliminary testing showed expected 
performance close times better processors 
domains obtained ftp june cs washington edu homes weld ucpop html 
point performance results preliminary 
just indicate possible trend 
test large number randomly generated queries compiler testing di erent ucpop way claim proposed planners ecient 
believe planners sort described section promising deserve investigation 
proposed modi cation action description language capable expressing actual situations observations truth values uents situations observations actual occurrences actions 
entailment relation allows modeling various types hypothetical reasoning 
feature ability denote current actual situation allows reason design correctness plans changing environment 
discussed possible application entailment relation architecture intelligent agents correct implementation planning module architecture prolog 
plan expand directions 
syntax semantics expanded deal partially de ned actions allow concurrent non deterministic actions bg kl bt global constraints kl general ecient methods computing entailment extensions 
possibility investigate inference mechanisms sound declarative logic programming semantics 
programs unique answer sets slx procedure adp adp promising candidate 
computes answers founded paa semantics logic programs sound answer set semantics 
interesting challenging problem expand slx allowing disjunction reasoning cases 
promising direction research related extension elaboration planner section 
obvious approach modify procedure generate produce sequences actions relevant goal domain dependent heuristics 
need design implement modules architecture 
abduction promising 
continuation approach formalizing actions suggested gl deeply rooted situation calculus mh glr 
formalization especially ucpop written lisp programs written quintus prolog quintus prolog logic programming form viewed combination situation calculus prominent approach formalizing actions event calculus ks 
best knowledge rst combining formalism pr 
approach similar 
pr situation calculus theory classical logic second order features plays role action description language 
approach allow forms incompleteness representation domain investigation precise relationship subject 
works combine event calculus situation calculus ms pro 
approach ms closest 
function state maps time points situations similar maps situation constants sequences actions 
assume domain description includes occurrences actions allow uent facts initial situations 
approach general respect restrictions 
hand ms contains discussions allowing concurrent divisible overlapping actions discuss 
acknowledgment acknowledge nsf iri nsf iri 
vladimir lifschitz norm mccain hudson turner useful discussions dan weld making available ucpop planner kambhampati pointing planning literature 
special rob miller anonymous referees comments helped signi cantly improve quality 
gelfond gopal gupta enrico help running experiments 
ab apt bezem 
acyclic programs 
warren szeredi editors logic programming proc 
seventh int conf pages 
ab apt bezem 
acyclic programs 
new generation computing 
ab apt bol 
logic programming negation survey 
journal logic programming 
ad apt doets 
new de nition sldnf resolution 
journal logic programming 
adp alferes damasio pereira 
slx top derivation procedure programs explicit negation 
proc 
international logic programming symposium pages 
point assumptions weakened abduction 
adp alferes damasio pereira 
logic programming system nonmonotonic reasoning 
journal automated reasoning special issue 
alp alferes li pereira 
concurrent actions changes situation calculus 
ge ner editor proc pages 
mcgraw hill 
ap apt pedreschi 
proving termination general prolog programs 
proc 
int conf 
theoretical aspects computer software lncs pages 
springer verlag 
ap apt pellegrini 
occur check free logic programs 
acm transaction programming languages systems 
bar baral 
reasoning actions non deterministic ects constraints quali cation 
proc 
ijcai pages 
bg baral gelfond 
representing concurrent actions extended logic programming 
proc 
th international joint conference arti cial intelligence pages 
bgp baral 
formalizing narratives nested circumscription 
common sense 
stanford edu fcs final papers 
barrett golden penberthy weld 
ucpop user manual version 
technical report department computer science engineering university washington 
bt thielscher 
representing concurrent actions solving con icts 
proc 
german conference ai 
cla clark 
negation failure 
gallaire minker editors logic data bases pages 
plenum press new york 
csw chen swift warren 
ecient top computation queries founded semantics 
journal logic programming 
dds denecker de schreye 
representing incomplete knowledge abductive logic programming 
proc 
international logic programming symposium pages 
dm dembinski 
parallelism intelligent backtracking annotated logic programs 
saraswat ueda editors proc international symposium logic programming pages 
dun dung 
representing actions logic programming application database updates 
warren editor proc 
iclp pages 
fag fages 
consistency clark completion existence stable models 
technical report ecole normale superieure 
geo george editor 
journal logic computation special issue action processes volume 
oxford university press october 
gl gelfond lifschitz :10.1.1.49.9332
classical negation logic programs disjunctive databases 
new generation computing pages 
gl gelfond lifschitz 
representing actions extended logic programs 
joint international conference symposium logic programming 
pages 
gl giunchiglia lifschitz 
dependent uents 
proc 
ijcai pages 
glr gelfond lifschitz 
limitations situation calculus 
boyer editor automated reasoning essays honor woody bledsoe 
kluwer academic dordrecht pages 
ht thielscher 
actions speci city 
miller editor proc 
iclp pages 
kar kartha 
soundness completeness theorems formalizations action 
ijcai pages 
kar kartha 
counterexamples related baker approach frame problem 
arti cial intelligence 
kambhampati knoblock yang 
planning re nement search uni ed framework evaluating design tradeo partial order planning 
ai journal appear asu cse tr 
kl kartha lifschitz 
actions indirect ects preliminary report 
kr pages 
ks kowalski sergot 
logic calculus events 
new generation computing 
lmt lifschitz mccain turner 
automation reasoning action logic programming approach 
posters international symposium logic programming 
ls lin shoham 
provably correct theories actions preliminary report 
proc 
aaai 
lt lifschitz turner 
splitting logic program 
van hentenryck editor proc 
eleventh int conf 
logic programming pages 
mae maes editor 
designing autonomous agents 
mit elsevier 
mcc mccarthy 
overcoming unexpected obstacle 
manuscript 
mcc mccarthy 
situations actions causal laws 
technical report stanford arti cial intelligence project memo 
mh mccarthy hayes 
philosophical problems standpoint arti cial intelligence 
meltzer michie editors machine intelligence volume pages 
edinburgh university press edinburgh 
mm martelli montanari 
ecient uni cation algorithm 
acm transaction programming languages systems 
ms marek subrahmanian 
relationship stable supported default auto epistemic semantics general logic programs 
levi martelli editors proceedings sixth international conference logic programming pages 
ms miller shanahan 
narratives situation calculus 
journal logic computation 
mt mccain turner 
language independence language tolerance logic programs 
proc 
eleventh intl 
conference logic programming pages 
mt mccain turner 
causal theory rami cations quali cations 
proc 
ijcai pages 
paa pereira alferes 
default theory founded semantics explicit negation 
pearce wagner editors logic ai proc 
european workshop jelia lnai pages 
ped pednault 
extending conventional planning techniques handle actions context dependent ects 
proc 
aaai pages 
ped pednault 
adl state transition model actions 
journal logic computation 
pin pinto 
temporal reasoning situation calculus 
phd thesis university toronto department computer science february 
krr tr 
pr pinto reiter 
temporal reasoning logic programming case situation calculus 
proceedings th international conference logic programming pages 
pro 
hypothetical reasoning actions situation calculus event calculus 
computational intelligence 
rei reiter 
frame problem situation calculus simple solution completeness result goal regression 
lifschitz editor arti cial intelligence mathematical theory computation pages 
academic press 
str 
completeness result sldnf resolution 
journal logic programming 
tur turner 
monotonicity theorem extended logic programs 
warren editor proc 
th international conference logic programming pages 
tur turner 
signed logic programs 
proc 
international symposium logic programming pages 
van denecker de schreye 
combining situation calculus event calculus 
proc 
twelfth international conference logic programming pages 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 
wel weld 
commitment planning 
ai magazine winter 
wor working notes aaai spring symposium 
extending theories action formal theory practical applications 
aaai press 
appendix hypotheses domain descriptions promised section consider impact allowing hypothesis statements form domain descriptions de nition model modi ed adding condition specifying hypothesis true interpretation see de nition de nition 
de nitions section remain 
consider example 
example consider domain description acts precedes laws causes causes causes causes causes consider statement denoted easy see models occurs fhg 
models entail occurs technically somewhat unexpected property easy explain 
case uence construction models plays role selecting models occurs evaluated 
treated fact uences construction models intuitively explanation unclear ontological status having domain description 
semantic ambiguities general principle simplicity language design decided allow domain descriptions appendix logic programming background general logic program collection rules form ground atom 
expression left hand right hand side called head body rule 
head body empty 
intuitively rule read believed true believed believed 
rule form sets fl fl fl referred head pos neg respectively 
lit stands head pos neg 
general logic program head head 
set predicates lit denotes set ground literals predicates general logic program lit denotes set ground literals predicates language 
clear context write lit lit 
answer set stable model general logic program negation failure smallest subset atoms rule answer set program contain negation failure denoted 
general logic program 
set lit general logic program obtained deleting rule formula body ii formulas form bodies remaining rules 
clearly contain answer set de ned 
answer set coincides say answer set 
words answer sets characterized equation 
general program atom say true answer sets stable models 
similarly say false stable models 
lemma marek subrahmanian ms answer set general logic program rule type fl fl 
consistent answer set exists rule type fl fl 
review de nitions splitting proof lemmas 
de nition splitting set lt splitting set program set literals rule head lit splitting set say splits set rules lit called bottom relative splitting set denoted 
subprogram called top relative de nition partial evaluation lt partial evaluation program splitting set set literals program de ned follows 
rule pos neg put rule satis es property head head pos pos neg neg de nition solution lt splitting set program 
solution pair hx sets literals answer set answer set consistent 
lemma splitting lemma lt splitting set program 
set literals consistent answer set solution hx 
