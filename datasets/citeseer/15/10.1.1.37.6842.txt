relevant context inference chatterjee barbara ryder department computer science rutgers state university nj road piscataway nj usa cs rutgers edu william landi siemens corporate research college road east princeton nj usa landi scr siemens com relevant context inference rci modular technique flow context sensitive data flow analysis statically typed object oriented programming languages java 
rci analyze complete programs incomplete programs libraries approach require entire program analysis 
rci context points analysis realistic subset empirical evidence obtained prototype implementation argues effectiveness rci 
points analysis egh statically typed objectoriented programming languages java determines program point objects pointer may point execution 
information crucial applications including static resolution dynamically dispatched calls side effect analysis data flow testing program slicing aggressive compiler optimizations 
solution concrete type inference pc necessary object oriented optimizations method specialization inlining subsumed solution points analysis concrete type pointer set classes corresponding objects possibly pointed pointer 
goal analysis preserve precision possible sacrificing scalability 
flow context sensitivity affect precision cost analyses 
flow insensitive algorithm ignores ordering statements method contrast flow sensitive algorithm follows control flow order statements method computes different solutions variable distinct program points 
context sensitive algorithm considers approximately interprocedurally realizable paths sp lr egh rhs paths research reported supported part nsf ccr hewlett packard edison design group 
calls returns properly matched contextinsensitive algorithm distinction 
existing algorithms points analysis vary flow context sensitivity compute approximate solutions supersets precise points solution 
expensive imprecise context insensitive approaches wei ste sh 
contrast flow context sensitive techniques lr cbc mlr egh deu chs wl ruf pr precise expensive time memory 
alias points analysis adapted points analysis exceptions 
precision solution computed points analysis directly affects utility applications 
flow context sensitive points analysis difficult due dynamic dispatch objects containing pointers subobjects recursive types invocation contexts method 
addition flow context sensitive algorithms memory intensive frequently run memory analyzing moderately sized programs 
difficulties addressed design implementation rci modular technique explained applied points analysis subset term modular mean technique program analysis requires entire program source memory time 
object oriented code written libraries goal rci analyze incomplete programs 
additional goal rci maintain sufficient degree precision data flow information intended applications 
intuitively analyze method assuming unknown initial values parameters globals method entry 
key insight obtain summary function data flow effect method execution bottom inference relevant conditions unknown initial values 
conditions capture relevant contexts method making approach feasible summary function context 
previous techniques lr ema ghi wl incorporated memoization data flow solution associated particular calling context set contexts 
approach method bodies analyzed separately calling context information 
effects method points analysis information calculated dependent certain conditions incoming unknown initial values parameters globals 
calculate possible conditions algorithm calculates conditions may affect points infor mation inferring code method methods may invoke directly indirectly lifetime 
care taken observe object fields method directly indirectly calls conditions inferred fields sense 
results calculations twofold points solution node method ii summary transfer function method function expressing method invocation effects points solution parametrized unknown initial values conditions values 
summary functions callees calculated callers 
points information propagated method callers actual parameter bindings accounted 
recursion requires simultaneous handling calls strongly connected component scc program call graph 
required points solution statement computed demand instantiating unknown initial values points information method entry 
entire calculation carefully staged entire program source need memory time calculation done separately scc program call graph 
algorithm modular flow contextsensitive algorithm points analysis programs written realistic subset explain rci context points analysis programs technique extended handle libraries java programs exceptions threads solve data flow analysis problems 
main results ffl algorithm modular points analysis programs written realistic subset ffl empirical evidence effectiveness rci applied points analysis details research crl including extensions handle java exceptions analyze libraries applications testing 
definitions section presents technical definitions needed explain algorithm delimits subset handled 
subset 
limited space available define significantly restricted subset describe algorithm provide analysis complexity results simple subset 
allows simplify presentation demonstrating interesting parts algorithm 
subset defined includes single inheritance dynamic dispatch recursive types pointer assignment statements single approach analogous way pointer aliases calculated lr 
possible reaching aliases ra aliasing algorithm propagated procedure entry aliases possibly propagated entry 
likewise rci solves conditions potentially affect data flow solution conditions 
expr side effect free expression function call ignored points analysis 
pattern means occurrence pattern 
means occurrences pattern 
means zero occurrences pattern 
fa bg means terminal symbols underlined 
program fclass class class classname public classname protection static type fieldname type classname int char float bool method protection static virtual void type methodname param body param type varname param proc typeg param body body decls decls decl decl type varname call return varname lhs rhs lhs varname varname fieldname rhs varname varname fieldname expr call varname methodname methodname classname methodname varname varname new classname varname varname expr expr varname name fieldname name name methodname name classname name protection public protected private simpler subset level dereferencing 
excludes multiple inheritance explicit address operator pointers stack type function pointers data members structure types note exclude data members pointers structure types general pointer assignment statements arrays array elements mapped single representative element exceptions 
constructs easily accommodated extending algorithm briefly indicate extensions relevant 
algorithm understood fully simple subset handling requires handling details changes fundamental ideas algorithm 
subset easily handled modular points analysis algorithm excludes arbitrary casting uninstantiated templates pointers data members pointers member methods different ordinary function pointers 
cast derived class base class cast base class derived class handled 
implementation algorithm consistent bigger subset excluding addition multiple inheritance exceptions 
precision safety 
program point points analysis calculates set objects pointer may point execution 
static analysis technique points analysis needs represent potentially infinite number heap allocated run time objects finite number names 
lr cbc mlr wl ste represent run time objects created lhs rhs lhs rhs 
program point single name 
pair precise solution points analysis program point exists execution path start node program path executed pointer ptr points object created program point safe solution points analysis superset precise solution 
modular points analysis algorithm calculates safe solution 
data representations 
rci stores data flow facts corresponding alias type context conditions inferred analysis data flow elements dfelms 
initial phase algorithm examines method presuming unknown initial values parameters global variables 
depending pointer assignments method unknown initial values may appear variable names points relations corresponding conditions associated relations 
var init represent unknown initial value global parameter var 
note var init denotes unknown initial object var points address object 
var init init represents unknown initial value var points 
var init init init represents unknown initial value var points 
obviously presence recursive types number unknown initial values accessed method unbounded 
overcome problem unknown initial values mapped finite number sets 
elements set represented single representative name 
rci uses patterns access paths deu unknown initial values form sets crl 
points analysis dfelm propagated rci form context points toi points represents pair form 
var local pointer variable global pointer variable unknown initial value field pointer type heap name field pointer type object unknown initial value heap name 
object null treated special heap name 
relevant context form context type context alias context empty conjunction potential aliases potential non aliases unknown initial values 
potential alias form uiv eq uiv potential non alias form uiv neq uiv 
uiv uiv unknown initial values 
potential aliases potential non aliases inferred algorithm analysis data flow facts dependent specific conditions sort 
type context conjunction type constraints empty 
type constraint form uv uv unknown initial value class dynamically dispatched method defined virtual method 
represents set classes containing subtypes virtual invocation method resolved definition method class constraint means associated dfelm valid contexts concrete run time type uv declared type belongs reaching aliases earlier aliasing lr relevant context dfelm provides approximation calling context 
allows data flow information propagated approximations realizable paths 
modular points analysis section explain rci applied points analysis 
phases rci rci iterative worklist algorithm flow context sensitive 
rci takes input statement level interprocedural control flow graph icfg lr 
initial approximate call graph formed decomposed scc 
phases performed scc condensation scc dag 
ffl phase phase rci constructs safe overestimate call graph called initial call graph resolving dynamically dispatched calls hierarchy analysis dmm 
rci uses linear time algorithm clr construct scc dag initial call graph 
note initial call graph need precise needs safe overestimate precision safe initial call graph affects efficiency rci safety computed solution 
initial call graph precise bs practice hierarchy analysis adequate 
ffl phase rci traverses scc dag reverse topological order bottom analyzes method assuming parameters global variables unknown initial values 
method rci computes terms unknown initial values safe approximation method complete transfer function pointers 
call approximation summary transfer function 
summary transfer function method set dfelms reach exit node represent values local variables function summarizes possible effects method invocation dfelms 
summary transfer functions methods scc cyclic dependences computed simultaneously fixed point iteration 
contrast summary transfer functions methods different scc hierarchical dependences dependence computed bottom traversal scc dag iteration 
phase summary transfer function method points solution node method expressed terms dfelms defined section may contain unknown initial values 
initial call graph function pointer call targets approximated functions addresses stored signatures match type called function 
ffl phase ii rci traverses scc dag topological order top propagates concrete values unknown initial values entry nodes methods 
phase involves entry nodes call nodes empirical results show extremely fast 
rci considers reachable methods phase 
ffl phase iii phase involves nodes entry nodes 
phase unknown initial values dfelms computed phase instantiated concrete values computed phase ii 
phase completely demand driven needs performed nodes final solution needed 
phase points solution node expressed entirely terms program variables heap names 
construction initial call graph hierarchy analysis method needs memory 
node scc dag method needs memory times phases ii iii 
rest time method summary transfer function phase ii solution entry node method needs memory 
modular approach requires memory program analysis techniques method moved memory possibility needed final solution computed 
techniques program kept memory priori constant bound number times method needs moved memory 
course worst case entire initial call graph may single scc rci may need keep program memory 
empirical results show scc quite small practice rci able analyze method time 
specific domains recursive descent parsing scc may occasionally large cases entire initial call graph single scc 
example parsing scc methods dealing statements different scc methods dealing types 
phase phase rci analyzes method unknown initial values parameters global variables 
analyzing method infers relevant potential aliasing unknown initial values relevant potential concrete declared types 
rci computes dfelm conditioned potential aliases dfelm alias context concrete types dfelm type context 
propagation phase occurs reverse topological order scc dag objective calculate points solution node terms unknown initial values calculate summary transfer function method program compute summary transfer function callers method 
intuitively dfelm exit node method valid call site invokes conjuncts relevant context true call site 
general call site invokes things happens conjunct relevant context conjunct evaluates true evaluates false translated similar conjunct involving unknown initial values caller 
propagation dfelms methods different scc iteration necessary 
actual parameter bindings summary transfer function called method calculate dfelms returned call 
obtain proper propagation dfelms non trivial scc necessary propagate dfelms graph scc 
cyclic dependences iteration performed fixed point reached 
iteration partial summary transfer function may available method exit node processing scc callers method 
new dfelm added partial summary transfer function method scc callers method informed dfelm corresponding call sites process new dfelm 
calculation points solution terms unknown initial values calculation summary transfer function method accomplished propagation dfelms method entry exit worklist algorithm 
initially solution node empty grows monotonically new dfelms added 
code method represented icfg 
points information reaches icfg node serves input node transfer function embodies data flow effect semantics code corresponding node 
specify statement transfer functions points analysis pointer assignments call statements 
section examples showing transfer functions relevant contexts manipulated give pseudocode phase appendix examples dfelm propagation shows final phase solution computed rci top statements program points 
dfelms program point say variables values entry node method 
statement assigns value field value dfelm program point says field unknown initial value points unknown initial value 
relevant context emptyi means alias context type context empty dfelm valid contexts 
assignment statement set dfelms gives values left right hand sides relevant context corresponding dfelm implied resulting assignment conjunction relevant contexts dfelms statement consists conjunction relevant contexts dfelms emptyi 
unknown initial values statement modifies field unknown initial value 
dfelms keep track potential modification 
applicable contexts init init equal applicable contexts init init equal 
dfelms implied respectively 
rci consider init potential modification statement method 
rci generates fields unknown initial values lazily explained section inferring relevant potential aliases potential non aliases 
example relationships init init init relevant class emptyi ha init ii public public emptyi ha init ii public virtual choose emptyi ha init ii return emptyi global init ii emptyi global init ii emptyi ha init init init ii class public emptyi ha init init init ii class public emptyi ha init init ii public choose hh init eq init emptyi ha init init ii return hh init neq init emptyi ha init init init ii class test hh init eq init emptyi init ii public static global hh init neq init emptyi init init ii public static global public static void method init choose init ii global init choose init ii global choose phase solution method init method second init directly modified method 
statement dynamically dispatched call site 
invoke choose choose depending concrete type init result rci computes values global program point conditioned potential concrete types init dfelm says global points init contexts concrete type init belongs set types represented choose fa bg 
meaning similar 
aliases rci infers relevant potential concrete types example concrete types init init relevant method 
rci kill dfelm call site dfelm represents value variable result call stored dfelms go call statement 
summary transfer function method consists dfelms program point dfelms represent values variables local method 
consider call sites invoke method static method method test 
static void method method new new method call site rci translates dfelms exit node method replacing unknown initial values values call site unknown initial values respectively 
note propagating data flow information callee back caller 
example call unknown initial value function pointer handled similarly conditioning relationships unknown initial value function pointer functions potentially invoked functions addresses stored function pointer signatures match type call 
libraries assume function external library invoked function pointer library see crl details 
ffl hh init eq init emptyi init ii translated hh init eq init emptyi init ii 
ffl init choose init ii translated init choose init ii 
call site rci evaluates relevant contexts dfelms exit node method object init object init init example ffl hh init eq init emptyi init ii applicable call site object eq object false 
ffl hh init neq init emptyi init init ii translated emptyi object neq object true value object null program point 
ffl init choose init ii translated emptyi object ii concrete type init belongs choose fa bg 
summarize call site rci stores bindings actuals unknown initial values methods invocable call site relevant contexts dfelms imply bindings 
call sites relevant contexts happen emptyi 
actual uiv bindings replacing unknown initial values actuals dfelm resulting dfelm associated new relevant context 
context conjunction contexts bindings generating context instantiated actuals 
example recursive types finite number unknown initial values accessed representative names needed 
lazy strong update assignment local global variable safely killed subsequent assignment variable 
contrast assignment field heap name killed computing additional information heap name may represent runtime object 
rci able kill assignments fields unknown initial values particular call method unknown initial value represents run time object method execution wl crl 
points set pointer cardinality may points information effectively pointsto information remember explicitly track null 
forms basis algorithm performs kills dfelms 
rci performs kills fields unknown initial values lazily 
phase dfelm representing value field unknown initial value reaches pointer assignment node kill current points solution current solution implies update field unknown initial value decision killing immediately 
fixed point reached partial solution available update change may update potentially larger fixed point solution 
situation rci propagate immediately successors marks worklist scc empty rci revisits marked nodes check marked dfelms killed current solution 
dfelms killed restarts iteration propagate unmarked dfelms 
propagation stops scc remaining marked dfelms require marked nodes kill marked dfelms fixedpoint solution 
practice scheme quite effective 
lazy propagation efficient nodes need revisited belong scc number bounded size scc 
shown section scc usually small 
optimizations phase optimizations phase minimize amount data flow information needs propagated algorithm directly affects cost 
limiting relevant context 
dfelm exit node method call site invokes rc relevant context rc evaluates true relevant context contained rc set conjuncts subset set conjuncts rc evaluates true result theorem theorem dfelm relevant context safe replace relevant context contained due theorem complete relevant context rci subset conjuncts compromising safety may cause propagation spurious dfelms call sites part original relevant context valid approximate similar reaching alias set reaching aliases lr 
context sensitivity 
heuristics choosing part complete relevant context stored 
simple heuristic user specifies bound number conjuncts specific kind store conjuncts kind associated dfelm rest conjuncts dropped 
bound imposed uniformly dfelms rci allows different bounds different dfelms 
reduction alias context 
classes 
satisfy ii subtype iii supertype called compatible 
unknown initial values called compatible declared classes compatible 
concrete values unknown initial values unknown initial values compatible 
compatible unknown initial values participate potential alias potential non alias 
field unknown initial value modified field compatible unknown initial value potentially modified safety dfelms appropriate alias contexts need generated record potential modification 
optimizations enable rci avoid generation dfelms compromising safety 
lazy generation fields 
rci considers fields unknown initial value method directly pointer assignment statements indirectly actual uiv bindings pointer assignment statements methods invoked series calls 
example field init considered method 
field unknown initial value time fact propagated callers scc actual uiv bindings access causes access fields time scc callers facts representing access fields propagated iteratively worklist 
assignment statement fields considered potential modification generation alias contexts fields method 
example field init considered potential modification statement method init type init write fields 
consider method part class test defined 
void method prm prm prm prm prm global prm prm global method uses fields unknown initial values prm init prm init prm init fields prm init prm init considered potential modification statement 
field prm init writing read method 
result statement unnecessary generate dfelm represent potential modification field prm init modification automatically seen call site method values prm init prm init 
hand consider call site invokes method multiple inheritance easily accommodated extending definition compatible classes classes compatible conditions hold classes common derived class 
possible values prm init prm init distinct unknown initial values 
suppose contained method uv uv distinct unknown initial values respectively values prm init prm init field uv read rci generate dfelm appropriate alias context record potential modification field uv due modification field uv statement method 
initially rci considers fields unknown initial values write 
field read time read write candidate potential modification considered generation alias context 
restricting alias context unknown initial values 
pointer assignment statement rci considers fields unknown initial values heap names potential modification generation alias context 
safe particular call method run time objects represented heap name method phase different run time objects represented unknown initial values 
heap name appearing method phase associated unknown initial value method phase ii particular call method run time objects represented heap name cases different 
consider methods part class test defined method prm void method new new prm method method return heap name object value unknown initial value prm init method phase field object read statement type object type prm init statement field prm init modified field object need considered potential modification 
safe statement object value prm init object represents run time objects created statement method called statement call method statement object appearing phase solution method represents run time objects created statement method called statement 
phase ii concrete value unknown initial value computed entry node method phase rci visits call sites ffl dynamically dispatched call site rci incrementally computes set methods invocable suppose receiver value pointer variable set dfelms computed phase represent values rci evaluates dfelms instantiating unknown initial values concrete values computed entry node dfelms relevant contexts evaluate true yield concrete values pointer global created global value unknown initial value 
global method directly unknown initial value global part alias context 
determine set methods invocable phase ii rci produces final call graph significant refinement initial call graph 
dynamically dispatched call site final call graph targets considered invocable invocable concrete values receiver computed call site phase ii 
ffl call site rci uses actual uiv bindings computed phase see section propagate concrete values methods invocable rci evaluates relevant contexts associated actual uiv binding substituting unknown initial values relevant contexts concrete values computed entry node binding propagation relevant contexts associated binding evaluates true 
methods scc concrete values propagated iteratively fixed point reached methods different scc propagation done top manner iteration 
order avoid propagation concrete values unreachable methods rci computes initial set reachable methods incrementally expands set phase ii 
complete programs initial set consists main 
rci visits node scc dag topological order phase ii considers methods current scc marked reachable 
rci finds unmarked method invocable call site reachable method marks new method reachable 
example consider phase ii example method see section 
simplicity assume method reachable 
result method reachable invoked method 
call site rci stores actual uiv binding object init relevant context binding emptyi 
relevant context emptyi trivially evaluates true phase ii propagates object concrete value init entry node method 
call site statement value receiver value value dfelm emptyi ha init ii 
phase ii substitutes object init dfelm obtain object concrete value receiver 
implies choose invocable statement final call graph edge statement choose 
phase iii non entry node reachable method solution points analysis needed dfelm computed phase instantiated concrete values computed entry node phase ii 
instantiations relevant contexts evaluate true yield solution points analysis instantiation concrete values dfelm yields points form var local pointer variable global pointer variable heap name field pointer type object heap name 
incomplete programs libraries initial set consists methods directly invoked outside incomplete program 
consider phase iii example method see section 
suppose phase iii needs done program point 
dfelm program point instantiated concrete values computed entry node method 
example init instantiated object dfelm program point relevant context dfelm evaluates true dfelm yields points object 
complexity section briefly discuss complexity various steps rci 
focus important dominating terms simplicity ignore important terms 
analysis subset significantly impact final results 
phase 
tmax maximum number targets call site initial call graph nc total number call nodes nproc total number procedures methods 
complexity phase nproc 
phase scheme dealing recursive types ensures total number unknown initial values total number possible dfelms finite bound imposed number conjuncts relevant context 
rci finite amount dfelm program point step rci considers new dfelm program point rci terminates 
total number unknown initial values generated rci number user defined pointer variables maximum number fields class including inherited fields fmax total number classes number icfg nodes nnodes total number heap names nh bound number conjuncts relevant context nrc number possible relevant contexts 
nrc pa tc uiv tc 
pa upper bound number possible potential aliases potential non aliases tc upper bound number possible type constraints 
npt number possible points tos 
npt fm sm ae fm nh fmax sm nh oe fm upper bound number pointers member points pair sm upper bound number values second member 
nd fe total number possible dfelms 
nd fe 
total number possible dfelms polynomial nh tmax fmax assuming constant 
consider done rci pointer assignment node 
dfelm reaching node nl nr nh nrc nr nlg upper bound done dfelms directly generated pointer assignment statement 
nl upper bound number elements lhs rc loc pairs see appendix similarly nr upper bound number elements rhs rc loc pairs 
cs fcs nh upper bound done generating dfelms due potential aliases 
cs upper bound number dfelms new generated see appendix may generate dfelms due potential aliases 
nl cs upper bound done generating dfelms due potential non aliases 
cs upper bound number dfelms current solution pointer assignment node may generate dfelms due potential non aliases 
similarly shown node dfelm reaching node done rci polynomial nh tmax fmax assuming constant constant bound number intraprocedural successors node 
maximum amount done rci dfelm program point 
step rci considers new dfelm program point total amount done rci nd fe nnodes 
total done rci polynomial nh tmax fmax nnodes assuming constant 
nh tmax fmax nnodes obviously bounded size program 
theoretically contrived cases rci generate exponential number unknown initial values see appendix 
encountered practice easily avoided enforcing bound lengths access paths unknown initial values analogous limiting jm 
unknown initial values accessible root unknown initial value unknown initial values type having access paths longer represented representative name 
ensure polynomial nproc fmax phase ii 
cmax maximum number call nodes procedure method 
nmap maximum number actual uiv mappings stored call node 
nmap np nr nh nr 
np maximum number pairs actuals unknown initial values term nr counts relevant contexts associated actual uiv mapping 
maximum amount done rci call node concrete value unknown initial value 
nmap ce cp fce nh cp 
ce worst case cost evaluating relevant context associated actual 
unknown initial value nh concrete values 
cp worst case cost propagating concrete values entry node target procedure 
total amount done phase worst case 
upper bound number pairs unknown initial values concrete values 
phase iii 
worst case evaluating dfelm phase er ep fer ep er worst case cost evaluating relevant context dfelm ep worst case cost evaluating points dfelm 
worst case cost phase nnodes nd fe 
extensions section briefly describe extensions rci details crl 
rci designed java subset contains essential features languages threads 
modular points analysis extended handle java exceptions 
essential idea store additional information relevant context summarizes control flow due exceptions 
modular nature rci unaffected structure remains 
definition dfelms computed phase extended account possible controlflow due exceptions 
assumptions section rci polynomial time presence exceptions 
complexity classification doing analysis presence exceptions crl 
important property rci incomplete programs libraries analyzed 
unknown initial value entry node method library directly invoked call site outside library called interface initial value 
rci analyzing library phase ii rci treats interface initial value concrete value similarly propagates interface initial value entry nodes methods 
phase ii iii rci instantiates unknown initial value conjunct interface initial value conservative worst case assumptions interface initial value evaluating conjunct 
relevant contexts computed rci generating relevant test cases libraries 
contexts provide valuable information library may general information obtained program analysis particular driver library 
contexts suggest new coverage measure unit testing libraries standard coverage measures 
implementation implementation built analysis framework incorporates edison design group front ansi initial empirical results modular points analysis encouraging proof concept implementation scope optimization 
table contains characteristics thirteen programs analyzed 
benchmarks pr bs 
columns lines icfg nodes methods virtual calls scc max scc respectively show number lines code icfg nodes methods dynamically dispatched call sites nodes methods maximum sized scc program 
table contains timings sparc megabytes memory 
timings include time scanning parsing column bounds contains pairs mean bounds number potential aliases type constraints relevant context respectively 
analyzed richards deriv penguin electron set bounds 
second row richards corresponds analysis allowed potential alias type constraint relevant context 
different bounds yielded measurable variations characteristics shown tables difference information reported applications table 
analyzed see www rutgers edu public html 
trees implements trees deriv implements arithmetic expression trees employ implements class hierarchy different kinds employees richards operating system scheduler deltablue symbolic constraint solver perform matrix computations library drawing feynman diagrams electron penguin drivers different kinds elementary particles 
smaller bounds programs large running times higher bounds studied cost precision tradeoff respect applications reported table 
phase iii demand driven experiments phase iii performed non entry nodes 
phase solution library shared different driver programs 
illustrated phase timings electron penguin 
programs means time driver code time library code shared cost incurred 
trees employ small benchmarks important show orders magnitude timing improvement previous flow context sensitive program analysis technique pr took seconds benchmarks 
table columns pa tc show total number potential aliases type constraints generated 
column max size relevant context shows maximum number conjuncts non empty relevant context 
order get estimate memory saving obtained summary transfer functions normalized size summary transfer function method size complete phase solution method 
compute considered nodes relevant points analysis excluded nodes preserve points information 
averaged normalized sizes methods program compute average size summary transfer function program results percentage column ave size summ fcn 
possibility compare sizes summary transfer functions number nodes corresponding methods 
reasonable cost method depends size points solution method number nodes reachable method invocation just number nodes method 
comparison gives better indication reduction memory requirement achieved rci needs keep memory summary transfer functions methods called current scc complete solution methods 
counts reported potential non aliases implementation generate potential non aliases 
theorem affect safety computed solution 
impact potential non aliases precision points analysis small potential non alias evaluate false increase precision occur uiv uiv map unknown initial value phase map heap name potential evaluates true heap name represent run time object 
chosen describe rci including calculation potential non aliases believe useful applications analyzing libraries testing 
order test quality solution computed rci solution different applications side effect analysis mod virtual function resolution pr 
results mod shown table 
column mod shows average number heap names fields modified pointer assignment statement phase iii solution 
object oriented programs method usually called different contexts number heap names modified statement large precise solution 
verified inspection multiple calling contexts reason mod numbers high 
phase solution compute average number unknown initial values heap names fields modified statement 
factors effect expansion unknown initial value multiple concrete values invocation method multiple contexts 
column mod shows second average pointer assignment statements benchmark 
table show results virtual function resolution 
rci probably precise necessary solving virtual function resolution really aimed problems gain flow context sensitivity results show calls rci enables better resolution concomitant opportunities aggressive optimizations instruction scheduling specialization 
column reachable virtual calls shows virtual calls program reachable drivers libraries 
column unique hierarchy shows number reachable calls uniquely resolved hierarchy analysis 
column differences rci hierarchy shows number reachable calls number targets rci number targets hierarchy analysis 
show number differing calls program sizes differences 
noted changing bounds difference results 
possible loss precision due imposing bounds number conjuncts relevant context observed applications considered 
lower bounds improved running time significantly 
applications benchmarks situation different 
related wilson lam wl unknown initial values algorithm points analysis programs significant differences rci approach 
algorithm needs know exact alias relationships unknown initial values procedure analyzed 
algorithm keeps program memory analyze incomplete programs 
construct partial transfer functions rci constructs summary transfer functions approximate complete transfer functions 
algorithm handle dynamic dispatch exceptions handle function pointers 
calls method complete program possible relevant contexts occur summary transfer functions partial transfer functions costly 
unknown initial values similar non visible variables lr invisible variables egh summarizing values pointers point outof scope variables 
aspects hybrid data flow analysis unknown initial values model representative external values local analysis 
ff authors method doing analysis component wise manner scheme programs 
data flow analysis aimed object oriented language difficult directly compare rci 
essentially ff describes optimization technique set analyses known programs lines icfg methods virtual scc max nodes calls scc trees deriv employ richards deltablue penguin electron table benchmarks program ph ph ph ii ph iii bounds trees deriv deriv employ richards richards richards deltablue penguin penguin electron electron table timings seconds program pa tc max size ave size bounds relevant summ fcn context trees deriv deriv employ richards richards richards deltablue penguin penguin electron electron table performance data program reachable unique differences bounds mod mod virtual calls hierarchy rci hierarchy trees deriv employ richards deltablue penguin electron table applications differ differ differ differ differ differ differ differences precision rci hierarchy analysis different sets constraints correspond separate modules program 
modular sense simplified constraint sets obtained separately 
terminology section algorithm ff perform strong updates 
concrete type inference call graph construction object oriented languages subsumed analysis 
non modular program analysis approaches problems 
constraint analysis ps pc age dgc chs pr dmm data flow 
chs pr flow context sensitive algorithms compared empirical results pr non scalable 
implementation reported chs 
dmm presents different type analysis techniques modula including hierarchy analysis flow sensitive intraprocedural type propagation contextinsensitive interprocedural type propagation 
presents complex notion context subsumes calling context type context program variables 
presents general framework call graph construction object oriented programs 
constraint approaches dgc flow context insensitive ps pc age flow insensitive contextsensitive 
approaches handle exceptions 
bs extension hierarchy analysis flow context insensitive 
new technique called rci modular flow contextsensitive data flow analysis context application points analysis substantial subset scalable algorithm program analysis needing entire program source memory method memory times algorithm execution 
initial empirical results attest effectiveness technique moderate sized programs 
extensions java exceptions threads analysis libraries discussed 

anonymous reviewers helpful comments tom marlowe reviewing earlier draft rountev matt arnold helping implementation 
age ole agesen 
cartesian product algorithm simple precise type inference parametric polymorphism 
proceedings european conference object oriented programming ecoop 
andersen 
program analysis specialization programming language 
phd thesis diku university copenhagen 
available diku report 
bs david bacon peter sweeney 
fast static analysis virtual function calls 
proceedings acm sigplan conference object oriented programming systems languages applications 
cbc jong deok choi michael burke paul carini 
efficient flow sensitive interprocedural computation pointer induced aliases side effects 
proceedings acm sigplan sigact symposium principles programming languages pages january 
calder grunwald zorn 
quantifying behavioural differences programs 
journal programming languages 
chs carini hind srinivasan 
flow sensitive interprocedural type analysis 
technical report rc ibm watson research center 
clr cormen leiserson rivest 
algorithms 
mit press mcgraw hill book 
crl chatterjee barbara ryder william landi 
complexity concrete type inference presence exceptions 
lncs proceedings european symposium programming april 
crl chatterjee barbara ryder william landi 
relevant context inference 
technical report dept cs rutgers university august 
deu deutsch 
interprocedural may alias pointers limiting 
proceedings sigplan conference programming language design implementation pages june 
dgc greg defouw david grove craig chambers 
fast interprocedural class analysis 
proceedings acm sigplan sigact symposium principles programming languages pages 
dmm amer diwan eliot moss kathryn mckinley 
simple effective analysis statically typed object oriented programs 
proceedings acm sigplan conference object oriented programming systems languages applications 
egh emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
proceedings acm sigplan conference programming language design implementation pages 
ema emami 
practical interprocedural alias analysis optimizing parallelizing compiler master thesis 
technical report school computer science mcgill university august 
ff cormac flanagan matthias 
componential set analysis 
proceedings acm sigplan conference programming language design implementation pages 
grove defouw dean chambers 
call graph construction object oriented languages 
proceedings conference object oriented programming systems languages applications oopsla pages october 
ghi rakesh ghiya 
connection analysis practical interprocedural heap analysis international journal parallel programming 
jm jones muchnick 
flow analysis optimization lisp structures 
muchnick jones editors program flow analysis theory applications pages 

lr landi barbara ryder 
pointer induced aliasing problem classification 
proceedings acm sigplan sigact symposium principles programming languages 
lr landi barbara ryder 
safe approximation algorithm interprocedural pointer aliasing 
proceedings acm sigplan conference programming language design implementation 
landi barbara ryder sean zhang 
interprocedural modification side effect analysis pointer aliasing 
proceedings acm sigplan conference programming language design implementation 
mlr marlowe landi ryder choi burke carini 
pointer induced aliasing clarification 
acm sigplan notices september 
thomas 
marlowe barbara ryder 
efficient hybrid algorithm incremental data flow analysis 
proceedings acm sigplan sigact symposium principles programming languages pages january 
pc plevyak chien 
precise concrete type inference object oriented languages 
proceeding conference object oriented programming systems languages applications oopsla pages october 
pr pande barbara ryder 
data flow virtual function resolution 
lncs proceedings third international symposium static analysis 
ps palsberg schwartzbach 
object oriented type inference 
proceedings conference objectoriented programming systems languages applications oopsla pages october 
rhs reps horwitz sagiv 
precise interprocedural dataflow analysis graph reachability 
proceedings acm sigplan sigact symposium principles programming languages pages 
ruf ruf 
context insensitive alias analysis reconsidered 
proceedings acm sigplan conference programming language design implementation pages june 
sh shapiro horwitz 
fast accurate points analysis 
proceedings acm sigplan sigact symposium principles programming languages pages 
sp sharir pnueli 
approaches interprocedural data flow analysis 
muchnick jones editors program flow analysis theory applications pages 
prentice hall 
stocks ryder landi zhang 
comparing flow context sensitivity modification side effects problem 
proceedings international symposium software testing analysis pages march 
available dcs tr 
ste bjarne steensgaard 
points analysis linear time 
proceedings acm sigplan sigact symposium principles programming languages pages 
suzuki 
inferring types smalltalk 
proceedings acm sigplan sigact symposium principles programming languages pages 
wei weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh annual acm symposium principles programming languages pages january 
wl robert wilson monica lam 
efficient contextsensitive pointer analysis programs 
proceedings acm sigplan conference programming language design implementation pages 
zhang ryder landi 
program decomposition pointer aliasing step practical analyses 
proceedings th symposium foundations software engineering october 
pointer assignment data flow transfer function apply pointer assignment node defined figures 
lhs rhs sol respectively left hand side expression right hand side expression current solution new dfelm hrc hx reaching node sol 
lhs rc loc pairs set pairs relevant contexts objects modified node note lhs dereference lhs rc loc pairs initially oe 
initially emptyi 
consider example 
lhs 
hrc hx imply new lhs rc loc pair top solution assignment emptyi hp lii hh init eq init emptyi hp init ii emptyi hq lhs rc loc pairs ae emptyi li hh init eq init emptyi init oe lhs dereference lhs variable name lhs rc loc pairs contains single element emptyi pi new lhs rc loc pairs oe 
rhs rc loc pairs similar lhs rc loc pairs rhs set pairs relevant contexts objects values rhs 
pot aliases computes dfelms need generated due potential aliases 
pot non aliases computes dfelms need generated due potential non aliases 
statement program point checks killed node kills returns true represents value pointer variable directly updates pointer variable 
directly kill cases 
assignment kills certain unknown initial values distinct 
consider lhs form represents value field unknown initial value point location concrete value type type compatible 
case pot non aliases called generate dfelms condition propagation potential non aliases 
dfelms require equal unknown initial values compatible currently points 
points object propagated unconditionally 
lhs update location value represents 
case propagated unconditionally 
rci conservative assumptions heap names 
heap name represent run time object rci propagates unconditionally represents value field heap name 
complexity rci example program point pn points exponential number unknown initial values 
class void method public public 
class pn public public 
class gamma gamma public gamma public pn pn gamma class pn pn gamma apply hrc hx new dfelm reaching pointer assignment node old lhs rc loc pairs lhs rc loc pairs old rhs rc loc pairs rhs rc loc pairs new lhs rc loc pairs new rc loc pairs lhs implied new rhs rc loc pairs new rc loc pairs rhs implied lhs rc loc pairs old lhs rc loc pairs new lhs rc loc pairs rhs rc loc pairs old rhs rc loc pairs new rhs rc loc pairs new generated oe loop executed lhs dereference 
new lhs rc loc pairs oe 
hrc ui new lhs rc loc pairs null hrc vi rhs rc loc pairs rc rc rc rc impose user defined bounds rc assuming lhs form new dfe hrc hu vii new generated fnew hrc vi new rhs rc loc pairs hrc ui old lhs rc loc pairs null rc rc rc rc impose user defined bounds rc lhs dereference assuming lhs form new dfe hrc hu vii new dfe hrc hu vii new generated fnew new generated new generated pot aliases new generated new generated new generated pot non aliases new lhs rc loc pairs sol kills update new generated new generated pot non aliases lhs rc loc pairs new generated return new generated apply kills hrc hx lhs dereference lhs variable return true return false update lhs dereference return false say lhs type unknown initial value type compatible return true return false pot aliases lhs dereference return oe say lhs generated pa oe dfe hrc hu unknown initial value unknown initial value compatible rc rc eq rc impose user defined bounds rc new dfe hrc hz generated pa fnew return generated pa pot non aliases rc loc pairs lhs dereference return oe say lhs type generated pna oe dfe hrc hu unknown initial value type compatible hrc vi rc loc pairs unknown initial value compatible rc rc rc neq rc impose user defined bounds rc new dfe hrc hu generated pna fnew generated pna hu return generated pna apply 
