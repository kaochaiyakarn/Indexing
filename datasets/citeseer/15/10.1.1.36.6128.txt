analysis efficient implementation functional programs peter sestoft diku department computer science university copenhagen october new address january department computer science building technical university denmark dk lyngby denmark 
mail sestoft id dth dk preface report thesis submitted partial fulfillment requirements danish ph degree 
written period april october supervision professor neil jones diku department computer science university copenhagen 
guide reader report hopefully useful people interested functional programming languages implementations semantics analysis functional languages 
reader familiar functional languages program analysis need know theoretical underpinnings approach quite operational 
main contribution report presentation number automatic program analyses transformations functional programming programs 
analyses criteria proofs correctness implementations analyses transformations experiments implementations 
purpose automatic analyses collect information subsequent optimizing transformations 
analyses collect intensional information information possible executions program just input output function computed program 
point illustrated correctness intensional program analysis defined respect semantics contain operational information respect machines implementations language 
words semantics describe aspects intended implementations 
thesis owes collaboration carsten gomard range topics documented part 
particular chapters joint carsten text appear forthcoming thesis 
working carsten highly productive fun 
office mate hans roskilde university centre provided useful comments chapters thesis notes papers reports mine years 
hans produced package syntactic extensions scheme programming easier 
generally semantics program manipulation group diku head neil jones provided stimulating environment visitors travel new impulses challenges 
special pleasure acknowledge considerable role friend harald sndergaard melbourne university played education computer scientist 
stay glasgow university functional programming group autumn introduced lazy languages implementation 
warm due guy argo john hughes thomas johnsson john launchbury phil wadler interesting discussions hospitality 
particular chapter inspired discussions guy argo improved instruction machine design 
directly member esprit project benefited close contacts glasgow university imperial college london ecole polytechnique paris 
writing thesis accompanied usual crises 
inevitably caused supervisor neil ready helpful supportive comments advice 
want late mother kirsten father dear lone support 
supported danish natural science research council ph 
contents analysis transformation programs functional languages strict lazy machines implementations optimized implementation plan report semantics program analysis semantics program analysis interpretation semantic analysis information instrumented semantics correctness analyses lazy example language lazy language call name krivine machine adding data structures printing algebraic data structures adding laziness adding letrec summary translation evaluation rules closure analysis analysis core language correctness respect machine implementation extending analyses higher order languages usage interval analysis usage interval analysis optimizing call need call name optimizing call need call value experiments contents evaluation order analysis describing evaluation order evaluation order analysis examples variable path analysis applications optimization suspensions occurrence path analysis evaluation order relations backwards strictness analysis recursive data types revisited related globalization partial applications strict language live variables globally live variables interference interference analysis variable groups globalization correctness globalization experiments related lazy example language closure analysis usage interval analysis evaluation order analysis globalization partial applications terminology programs compilation machine closure analysis usage count analysis optimized compilation machine benchmark programs bibliography index chapter thesis deals semantics analysis transformation strict lazy purely functional languages 
goal explore ways improve implementation functional languages automatic program analysis transformation 
improvement reduced run time consumption storage consumption 
shall construct experimental implementation lazy functional language goal construct language implementation efficient possible absolute terms 
study bricks construction language implementations analyses transformations 
number new analyses transformations strict lazy languages 
analyses implemented proven correct optimizing transformations tested experimental implementations 
discuss notions correctness analyses transformations 
particular discuss relevance proving correct respect operational semantics machines opposed denotational semantics instrumented denotational semantics 
chapter introduces central terms concepts 
analysis transformation programs analysis transformation programs shall mean automatic processing program text goal obtaining information program analysis new program transformation 
analyses usually described equations goal typically construct programs realizing analyses 
analyses effective computable algorithms solving equations 
program analysis produces information program analysing text full information run time inputs program 
consequence analysis information approximate computability reasons 
analysis information want collect employed subsequent transformation program 
analysis information show programmer expressed intentions inadequately pointing possible type errors reporting chapter 
bad binding time properties estimates run time consumption program analysis sense called compile time analysis static analysis 
program transformation produces new program equivalent original certain conditions 
information preceding program analysis checking conditions program 
automatic program analysis supports automatic program transformation 
semantics programming language assignment meaning program language 
semantics considered formal model language certain aspects 
slight abuse shall phrase semantics program meaning 
language may number different semantics varying abstractness amount information give program 
different semantics may reflect different kinds implementations agree aspects language 
traditionally programming language semantics possible 
meaning functional program may taken input output function computed program abstracting away order evaluation subexpressions run time consumption shall word extensional semantics prescribes input output function intensional semantics include information 
analysis transformation semantics result applying program bears formal relation meaning program appropriate semantics 
semantics analyses transformations proved correct wrong 
particularly relevant analyse programs possible run time behaviours 
behaviours usually prescribed standard denotational semantics 
analysis transformation may need related non standard non semantics meaningfully characterize correctness 
example closure analysis chapter computes description set functions expression evaluate 
extensional semantics abstracts away identity functions contain sufficient information say means closure analysis correct 
functional languages strict lazy functional programming language programmer relies mainly higher order functions expressing intents 
functional programming languages classified dimensions pure impure strict lazy typed untyped pure functional language miranda tm haskell lazy ml side effects global state completely absent impure language scheme lisp standard ml allows side effects possibly restricted ways 
consider pure functional languages 
language strict call value function arguments evaluated exactly called function body non strict 
nonstrict language may call name argument expression evaluated time times call need argument 
machines implementations expression evaluated 
distinction call name call need operational intensional switching affects run time result computation 
distinction call value strict call name call need non strict hand affects result computation may terminate non strict evaluation fail strict evaluation 
language lazy data structures arguments constructor evaluated need 
language uses call need lazy data structures shall called lazy language 
lazy languages miranda tm haskell lazy ml hard reason order evaluation subexpressions 
turn hard reason side effects lazy languages usually pure 
strict non toy languages lisp scheme standard ml usually 
strict lazy languages shall see different opportunities optimization pose different problems analysis 
pragmatic advantages lazy higher order functional languages convincingly argued turner hughes 
machines implementations functional languages studied described formally translation suitable machines 
machine transition system essentially resembles real implementation including irrelevant detail 
machines useful studying properties implementations 
shall argue machines may relevant standard semantics instrumented semantics respect 
strict languages machine evaluating strict functional language peter landin secd machine strict lambda calculus dates back 
real implementations statically scoped lisp easily secd machine shown henderson 
example cousineau curien categorical machine implementations caml variant ml 
shall variant secd machine proving globalization analysis strict language correct section 
modern real life implementations strict statically scoped languages scheme standard ml sophisticated resemble mainly interpretive implementations secd machine 
converting functional program called continuation passing style flow control explicit facilitates translation traditional machine code 
approach pioneered steele 
chapter 
non strict languages machines evaluation mechanisms non strict lazy languages fall groups graph reduction closure 
graph reduction machines directly achieve laziness letting variables refer pieces graph run time 
replacing subgraph reduced equivalent automatically affects uses variables referring 
graph reduction machine due christopher wadsworth exploited turner combinator implementation 
graph reduction machine machine developed augustsson johnsson implementation lazy ml 
machine focus comprehensive textbook implementation lazy languages peyton jones 
closure machines basically non strict call name versions secd type machines 
necessarily lazy implement call name call need 
laziness achieved explicitly introducing update actions machines 
closure machines include fairbairn wray instruction machine krivine machine see similar developed independently 
directly implementations non strict lazy languages 
variant krivine machine semantics implementation lazy example language chapter 
graph reduction machines assumed subexpressions shared overwriting graph reduced equivalent default mode operation 
closure machines easier leave update operation needed allow optimizations unshared expressions graph machines 
modern real life implementations lazy languages hybrids closure graph reduction machines 
example spineless tagless machine peyton jones 
run time storage consumption optimizing program transformations intended reduce run time consumption primarily reducing number actions needed manage sharing lazy languages chapters 
globalization analysis aims reducing storage consumption run time consumption chapter 
functional languages lazy higher order ones require dynamic heap storage garbage collection mechanism 
shall assume garbage collection methods mark sweep copy chapter 
heap means kinds storage consumption distinguished 
cell turnover amount allocation actions done computation 
residency live set number cells live point time 
equal big cell turnover means garbage collection frequent pool free cells rapidly garbage collection may fast residency small 
similarly big residency means garbage collection frequent pool free cells small garbage collection 
optimized implementation slow live cells marked copied depending type garbage collector 
maximal residency computation important program run storage maximal residency 
reducing cell turnover residency save run time 
allocating cell takes time bounds checking incrementing pointers management 
importantly frequent slow garbage collections cause considerable run time overhead 
analyses report primarily aim reducing cell turnover overhead managing sharing reducing residency 
optimized implementation setting analysing implementing functional languages 
program analysis program analysis efficient implementation particularly pertinent functional programming languages 
reason mismatch concepts higher order functional programming languages real machines executing 
power flexibility functional languages stem fact phrases functional language combined freely subject type restrictions 
flexibility expensive means phrase implemented general mechanism 
program may restricted way specialized efficient implementation possible 
program analysis discover restricted uses program find places specialized implementation suffice 
true conventional procedural languages problem acute 
languages algol pascal ada concessions real machines implemented 
languages contain variety special constructions match machine concepts experienced programmer efficiency 
pure functional language programmer general construct 
advantage think machine efficient way express drawback rely implementation discover uses general mechanism restricted way 
prominent purpose analysis information identify cases restricted allow general efficient implementation 
strictness analysis prime example function argument known evaluated anyway evaluate early avoid overhead delaying sharing evaluation 
report contains examples pattern 
usage interval analysis finds function arguments may treated unshared loss laziness chapter 
interference analysis finds function parameters may allocated globally stack changing meaning program chapter 
chapter 
kind analysis information needed improving specializing implementation tell possible executions program safely assumed certain program phrase possible executions 
general analysis providing information proven correct respect language semantics incorporating intensional operational information 
exception strictness analysis correctness proven basis extensional standard denotational semantics framework denotational interpretation 
transformation implementation shall analysis information guide optimizations source level underlying implementation level 
reason hard understand run time storage consumption functional program looking source program text 
problem pronounced lazy languages strict ones order evaluation complex 
consequence transformation preserves meaning program may drastically unexpectedly change operational behaviour run time storage consumption 
example common subexpression elimination may cause fold increase maximal residency time spent garbage collection offsetting run time saved avoiding recomputation cf 

effects source level program transformation lazy languages quite unpredictable 
get better control effects transformations transformations optimizations done machine code 
allows finer optimizations source language construct usually compiled machine instructions necessarily optimized away 
approach analysis plus optimization implementation analysis plus target level transformation analysis plus source level transformation 
analyses collect operational information information possible executions programs 
plan report purpose part report chapters outline broadly topics dealt 
gives general discussion analysis transformation functional programs attempts establish meaning semantics 
main second part presents example languages operational semantics various analyses languages 
higher order untyped lazy example language operational semantics compilation machine called chapter 
analyses programs closure analysis chapter usage interval analysis optimizing compilation programs chapter 
experimental implementations machine analyses compilation listed described appendix 
plan report order typed lazy language evaluation order analysis lazy data structures language chapter 
strict language operational semantics background interference analysis globalization transformation chapter 
third part summarizes done outlines topics investigation chapter 
final fourth part contains appendices list terminology program listings summary danish bibliography index 
chapter semantics program analysis interested mainly analyses provide information possible executions program 
analyses said semantics relate meaning denotation program shape text instance 
chapter discusses detail 
semantics program analysis base semantics specifies standard required behaviour program executed 
semantics may style denotational semantics strachey structural operational semantics plotkin natural semantics kahn equational algebraic semantics 
semantics may translation understood language 
special case translation language machine secd krivine machines report turn described operationally transition system means 
denotational semantics may considered translation source language defined lambda calculus terms usually involving recursive equations fixed point operator 
meaning lambda terms reduction rules lambda calculus interpreting lambda terms elements suitable domains ultimately assigning meaning terms source language 
advantage translation operationally defined machine language semantics operationally plausible basing akin real machine implementation somewhat complex lambda calculus models denotational semantics 
interpretation interpretation special methodology program analysis 
operator language reinterpreted corresponding operator mimics effect original concrete 
suitable assumptions evaluation 
semantic analysis information term operators give result correctly mimics concrete result ordinary evaluation 
simple example calculation signs 
replace negative numbers value gamma positive numbers replace multiplication numbers signs rules gamma gamma gamma classical example program analysis strictness analysis 
value domain replaced point domain means undefined means possibly defined operators reinterpreted accordingly 
example say strict arguments say strict argument 
program properties calculated choosing suitable value domains operators evaluating program abstractly 
important choose domains operators evaluation terminate 
interpretation described naur idea type checking 
cousot cousot formalized developed idea mycroft applied functional languages strictness analysis nielson developed denotational interpretation 
summary draws sndergaard thesis gives account development interpretation chapter 
semantic analysis information shall distinguish kinds analysis information program 
kinds structured levels analogy classical compiler terminology terms lexical syntactic semantic 
level lexical information length program text lines number occurrences letter program text level program considered stream characters concept variable name sense 
second level syntactic information number different variable names appearing program deepest lexical nesting scopes level program considered syntax tree concepts lay length characters function definition sense 
third level semantic information set input data program terminates set possible outputs inputs numbers maximal run time inputs size level program may considered function input values output values function input values run time consumption reduction steps microseconds examples semantic analysis information may suggest useful finer distinction 
shall distinguish extensional intensional semantic analysis information 
extensional information concerned purely input output behaviour entire functional program intensional information may include things order evaluation subexpressions number chapter 
semantics program analysis uses variable input output behaviour components program run time needed execute program 
term operational intensional semantic information 
example intensional information consider complexity theory 
complexity theory run time space consumption usually treated properties algorithms respect precise class implementations computational models turing machines 
view semantics analysis finds approximate semantic information program 
semantics analysis classified extensional intensional depending sort information finds 
extensional semantics analysis finds information input output function computed program intensional semantics analysis finds information possible executions program 
extensional information identified denotational semantics intensional information operational semantics 
identification misleading intensional information may specified denotational semantics 
denotational semantics example specify run time consumption result execution program 
reason identifying extensional denotational denotational semantics frequently provide standard language defined giving extensional information 
example stoy says denotational semantics provide normative description language may leave impression modes descriptive 
reason identifying intensional information operational semantics operational semantics include accidental detail denotational semantics order number transitions needed run program 
instrumented semantics report deals mainly intensional semantics analyses 
analysis collecting information clearly proved correct respect semantics containing 
particular proved correct respect denotational base semantics 
way solve problem instrumented semantics extended semantics semantics prescribes operational aspects program addition base semantics 
interpretation paradigm applied instrumented semantics obtain approximate operational information correct respect instrumented semantics 
instrumented semantics obtained base semantics adding extra components denotation expression 
examples technique include hudak count semantics bloss hudak path semantics goldberg sharing semantics park 
correctness analyses escape semantics shivers non standard semantics 
correctness analyses shall see general analysis correctness defined semantics contain operational detail usual denotational semantics prescribes input output behaviour programs 
program analysis works program text exact information run time input program 
reasons computability semantics program analyses approximate 
rice theorem states nontrivial property recursively enumerable languages undecidable 
result implies non trivial semantic properties program decided program text mechanical procedure 
certain properties program texts computations decidable frequently happen property detected program analysis really approximation undecidable property 
means require program analyses exact 
mean program analysis correct 
simple utilitarian requirement analysis gives information serves purpose information subsequent program transformation 
instance transformation may preserve meaning program case program certain properties want analysis decide 
analysis provide safe answer 
analysis say program required properties case 
may wrongly apply subsequent transformation program valid 
accept conservative wrong answer long errs safe side 
prevent applying transformation may prevent validly applying transformation 
joint correctness analysis transformation suggest extensional criterion analysis correctness input output behaviour programs 
program analysis correct results transformation preserve program input output behaviour 
may formalize notion analysis correctness follows 
programming languages 
program transformation takes program information input produces program provided information correct equivalent ll ss 
assume program analysis produce information common works instrumented semantics conservative extensions denotational base semantics 
computing passing precise values oracle decide conditional obtaining somewhat approximate 
straightforward add details necessary obtain conservative extension denotational base semantics 
chapter 
semantics program analysis may define analysis transformation jointly correct programs ss ll 
example information may strictness information function parameters may strictness analysis programs may transformation evaluate arguments strict positions function calls 
transformation meaning preserving strictness information correct 
strictness analysis wrong transformation may move evaluation non terminating argument ahead function need 
may change terminating program non terminating corrupting input output behaviour transformed program 
joint correctness sufficient joint correctness general extensional analysis correctness criterion 
situations joint correctness sufficient characterize correct analyses 
may case wrong analysis information affect efficiency size input output behaviour transformed program joint correctness criterion fails capture analysis 
example may information sharability argument expressions may transformation call need call name expressions unshared information see chapter 
analysis classifies expression unshared shared transformed program may run orders magnitude slowly produce expected output 
reason update mechanism wrongly left expression fact shared expression evaluated call name call 
analysis wrong classifies expressions shared extensional joint correctness criterion see difference 
joint correctness requirement weak situations puts requirements extensional aspects program leaves intensional properties run time storage consumption unspecified 
thesis deals large extent analyses joint correctness requirement insufficient 
shall discuss notions correctness particular correctness respect instrumented semantics 
correctness interpretation great attractions interpretation domains operators satisfy certain requirements standard theory guarantees result interpretation correct respect abstracted semantics 
natural require interpretation abstraction denotational base semantics 
fact requirement may responsible considerable interest strictness analysis 
strictness analysis semantics analyses readily justified respect denotational base semantics 
due special interpretation non termination element 
correctness analyses domains lambda terms denotational semantics modelled 
general find intensional analysis information interpretation denotational base semantics 
base semantics contain sufficient information 
interpretation instrumented semantics solution interpretation instrumented semantics usually extension denotational base semantics 
denotation expression contains additional information value effect expression 
instance additional information may sequence variables order accessed evaluation 
interpretation instrumented semantics approach program analysis taken particular yale group led paul hudak 
example hudak derives count analysis instrumented count semantics 
similarly bloss derives path analysis essentially evaluation order analysis path semantics 
goldberg derives sharing analysis sharing semantics park goldberg derives escape analysis escape semantics 
example shivers derives control flow analysis instrumented semantics scheme incorporates information functions 
similar closure analysis proven correct respect machine see chapter 
interpretation instrumented semantics gives method stating proving correctness intensional analyses way closely resembles way extensional analyses proved correct respect denotational base semantics 
correctness instrumented semantics approach raises question correctness instrumentation 
purpose base semantics prescribe correct input output behaviour programs instrumented semantics certainly agree standard semantics inputoutput behaviours 
ensured choosing instrumented semantics conservative extension standard semantics 
prove instrumented semantics analysis correct useful way 
proves possible find machine implementation correct 
extensions base semantics deemed correct 
depends way uses instrumented semantics 
possibilities base semantics may normative manner characterizing valid implementations language 
way correct definition implementations derived proved correct respect instrumented semantics 
secondly instrumented semantics may concise sufficiently way summarize properties reasonable implementation 
way chapter 
semantics program analysis instrumented semantics derived proven correct respect implementation 
idea explicit model phenomenon counts investigation 
respect situation formal specification programs formal specification languages important effect careful formalization forced aspects details problem 
tacit assumptions discovered explicit consciousness subject matter increases mistakes spotted easily 
primary pragmatic benefit instrumented semantics implementations seldom proved correct respect instrumented semantics vice versa 
small problem instrumented semantics lies connotations term 
noted base semantics frequently normative prescriptive manner pointless question correctness 
term semantic connotation correct definition 
problematical instrumented semantics positive connotations semantics may lead researcher forget instrumentation may quite arbitrary 
machines proving analysis correct respect machine avoids questions kind particular possible build implementation similar machine 
may require ad hoc methods interpretation paradigm removes need postulate instrumentation prove instrumentation correct reasonable respect implementation 
analysis results improving program implementations advantage intensional analysis results guaranteed applicable implementations closely modelled machine 
chapter lazy example language introduce lazy example language chapters 
language name shall call lazy 
give simple machine called execute variant called krivine machine 
machine operational model respect prove analyses transformations lazy languages correct 
chapter globalization partial applications strict language shall version landin secd machine krivine machine operational semantics 
lazy language language evaluates function arguments need lazy data structures manner lazy languages miranda tm lazy ml haskell 
language non strict application non strict constructors 
evaluated called weak head reduction outermost weak reduction reduction top level redexes fully characterize intended implementations 
addition implementation lazy argument function application evaluated evaluation application arguments constructor application evaluated evaluation constructor application 
syntax informal semantics syntax language 
shall start implementing applicative kernel abstraction variables application 
extend base values conditional data structures local recursive definitions 
authoritative source terms 
peyton jones calls normal order reduction top level redexes turner calls normal order reduction fairbairn wray calls normal order evaluation leftmost reduction barendregt 
chapter 
lazy example language lambda abstraction variable function application base function base constant conditional nil nil constructor cons cons constructor case nil 
cons xs 
case analysis data structures letrec def local recursive definitions def 
variable function definition intended semantics language lazy ml haskell 
application lambdas non strict lazy 
application argument expression evaluated accessed evaluation evaluated regardless number accesses application base functions strict 
case 
strict case means evaluated sufficiently find constructor nil cons 
constructors data structures non strict lazy 
arguments cons evaluated needed right hand side case rule evaluated regardless number uses 
local recursive letrec definitions non strict lazy 
right hand side binding evaluated letrec body right hand side evaluated 
evaluated regardless number uses implementation analysis purposes shall sublanguage called core language 
full language explained simple syntactic translations core language relevant sections 
syntax core lambda abstraction variable application 
fully applied base function conditional letrec 
fm em local recursive definitions note applicative kernel part core main limitations core language base functions fully applied local recursive definitions explicit handling data structures 
kinds reduced values core functions base values 
call name krivine machine call name krivine machine implement core variant krivine machine shall refer machine 
krivine machine machine call name evaluation lambda terms invented french logician 
krivine described 
krivine machine directly implements outermost weak reduction call name evaluation weak head normal form applicative kernel shall go proof krivine machine implements reduction strategy 
krivine machine similar simpler fairbairn wray instruction machine tim 
operationally speaking main difference uses lists arrays representation environments simplifies handling shared closures lazy version machine slows variable access 
extending basic krivine machine base values laziness shall borrow fairbairn wray ideas tim 
machine described state transition schemas 
machine state components current code current environment stack code machine instruction just lambda term disguise environment stack lists values 
value function represented closure consisting code environment 
ignore base values base functions 
code uses debruijn indices variables environment provides values 
free variables values stack considered arguments function represented 
alternatively stack top element may considered continuation return address code environment remaining stack elements dump sense landin secd machine 
syntax meaning machine instructions apparent defining rules 
assertion machine state may reach machine state step computation written 
assertion machine state may reach machine state zero steps computation written 
rules defining basic call name krivine machine base values data structures code env 
stack code env 
stack app ffle var ffle lam pair machine state called current closure 
say closure activated entered taken environment var rule stack current closure 
activating closure tantamount demanding value demanding weak head normal form whnf 
machine stops rule applies 
happens abstraction lam chapter 
lazy example language finds stack empty applied 
case closure lam ffle result computation 
reduced value weak head normal form whnf closure machine started 
environment provides bindings free variables lam 
basic machine reduced values form lam ffle 
section add base values different 
translation machine code translation applicative kernel machine instructions just change notation named variables debruijn notation 
shall give remaining translation rules relevant subsections 
ae lam ae 

var ae app ae ae handling base values represent base values core extend repertoire machine 
achieve fairbairn wray tim 
instance number represented pseudo closure boolean value true represented 
general representation base value retfflv number boolean 
code component closure simply says base value environment component ab hold actual value action pseudo closure swap stack top element 
pops stack top element pushes activates old stack top element 
stack top element function expects base value argument 
action ret seen return jump computation argument function needs name rule eliminating base values rule introducing instruction cst ret retfflv cst ret kinds whnf machine lam retfflv corresponding kinds reduced value core functions base values 
ret instruction finds stack empty rule applies machine stops 
result computation closure retfflv representing base value note final machine state distinguish base value results form retfflv function type results form lam 
name simon peyton jones guy argo 
name originally fairbairn wray self 

call name krivine machine keep number concepts minimum functional encoding church numerals natural numbers booleans inefficient practical experiments implementation infeasible 
chosen faster slightly complicated representation just outlined 
base values including booleans added machine implement source language conditional adding instruction machine 
simply looks element stack boolean decide enter second stack element true third false 
ffle ffle ffle ffle base value constants conditional expressions compiled follows ae cst ae app app app ae ae ae compilation strict conditional expression expect conditional expression applied instruction 
consider cases fully applied base functions 
core 
considered base constants shall look implementation fully applied monadic functions fully applied dyadic functions 
monadic base function application op compiled app op compiled code op machine instruction corresponding base function op 
means monadic base function find evaluated argument form retfflv top stack 
function just extract base value closure 
dyadic base function argument swapping needed 
application op compiled op 
role rearrange stack top elements start evaluation eventually activate op 
fully applied monadic dyadic base functions compiled follows ae app ae ae app app app ae ae additional machine rules op op op retfflv ret op retfflv retfflv op retfflv retfflv ret op implementation base functions extended strict triadic base functions introducing appropriate new instructions 
op op 
idea instruction rm executed argument number base function arity greater evaluated 
instruction chapter 
lazy example language move stack element stack top activate element 
instruction form bm op applies op topmost stack elements enters result 
implementation base functions fixed arity regular probably inefficient high arities stack rearrangements 
reader may noticed new rules machine instruction op finds insufficient number elements stack 
happen machine code compiled fully applied base functions formed expressions 
running machine evaluating expression run time inputs free variables 
expression evaluated machine starting state ae code compiled initial environment bindings free variables order variables initial compile time environment ae order values applying machine rules state machine state obtained 
manner develop finite infinite trace execution initial state 
adding data structures section extend language data structures pairs lists trees shall refer algebraic data structures 
extending machine special constructs handle data structures encode lambda terms 
advantages 
function application lazy get lazy data structures extra cost 
secondly keeps number instructions machine low great advantage doing proofs induction machine executions 
fairbairn wray suggested encode data structures functions tim 
shall go extreme encoding numbers church numerals resulting data structures vast loss efficiency compared machine arithmetic big 
particular encoding related encoding products sums functions reynolds pierce 
encoding recursive data structures done ignoring recursive type structure obtain self iterating encodings 
appropriate language recursion anyway letrec 
add data structures modification compilation phase need small extension machine cater lazy printing data structures 
extend language lisp style expressions avoid proper type system 
creates special problems lazy printing result computation discussed section 
describe printing behaved typed case section 
implemented typed theory 
adding data structures avoid constructing type inference algorithm complicated compilation algorithm 
data structures encoded lambda terms general algebraic data type defined disjoint sum products syntax 


nc constructor arity 
arity may case simply new constant 
constructors distinct 
ij type expressions base types name algebraic data type type declaration form extends syntax language constructors type 
ic destructor case case analysis value expression type case 



nc 
call root expression case expression refer rules 
ic 
case branch case expression 
functional representation value type function arity number constructors type constructor encoded function takes arguments produces value type value turn function arguments apply th argument arguments encoding constructor 


destructor case 

values type encoded application root expression lambda terms branch case expression 



nc easy see gives desired behaviour 
root expression case 
th branch 
ic selected applied 
result case th right hand side evaluated ij bound component data structure exactly intended 
chapter 
lazy example language data structures handling especially printing general data structures encoded functions requires type system 
interested type issues shall single data structure general interesting lazy functional programming simple require type inference 
extend syntax language handle lisp binary expressions type definition expr nil cons value value extend language syntactic elements nil empty list constructor cons pair constructor case nil 
cons xs 
case analysis hd head element list tl tail element list nl 
test empty list general encoding scheme data structures simply consider syntactic shorthands core expressions 
particular applied selectors hd tl abbreviate case expressions 
arbitrarily decided return empty list nil applied nil 
base functions non applied selector eta converted fully applied 
nil cons case nil cons xs xs hd case nil 
nil cons xs 
tl case nil 
nil cons xs 
xs hd hd tl tl note case strict root expression expression applied reduced 
syntactic shorthands compilation cons machine code goes follows 
cons ae ae app app lam lam lam lam app app var var var ae ae 
printing algebraic data structures result may look somewhat overwhelming expansion linear duplication code 
advantage encoding data structures functions machine lazy section data structures automatically lazy 
components cons treated function arguments evaluated 
may compiled code cons beta reduced lam lam app app var ae destroy laziness evaluated number times contrary intentions 
see assume whnf lam lam app app var ffle cons bound variable assume evaluate occurrences expression hd 
expression hd evaluated reduces application reduces evaluated anew evaluation hd 
printing algebraic data structures data structures really useful add facilities lazy printing data structures 
enable demonstrate point lazy functional languages printer drives computation ultimately determines amount order evaluation language lazy data structures 
print instructions consider print result expression base type 
expression eventually reduce whnf closure form retfflv 
whnf activate closure stack top push stack described section 
applying base value expression print function achieve desired effect 
closure activated base value retfflv print function pb 
print function print activate whichever continuation left stack top 
print function side effect appends printed output 
rule pb pb retfflv ffle print printing algebraic data structures complicated 
data structures represented functions type information needed determine print user recognize lists trees printed output 
impossible distinguish run time encoding empty list nil function decided type print nil function object 
actual fact want print functions 
type monomorphic list numbers printed different way list lists numbers 
base type whnf data structure whnf takes functions arguments apply components data structure 
means achieve desired chapter 
lazy example language effect applying data structure appropriate print functions 
question print functions needed 
example printing binary trees consider print value type tree empty fork tree tree 
encoding value function 
arguments functions 
applying print functions pe pf reduce pe represents empty pf represents fork 
action pe append empty output activate closure stack top 
action pf append fork output evaluate print component arrange evaluation printing right parenthesis closes cons term 
pf pushes closures activating pe ffl pf ffl print value type tree pf ffl take care evaluation printing reached whnf activates pe pf 
subtree described finite pc ffl eventually activated 
print function pc likewise push closures activating pe pf take care printing whnf type tree new pf 
reached whnf activates pe pf subtree described finite pf eventually activated print right parenthesis activate continuation stack top 
summary rules example print functions pe pf pf pf printing tree values pe ffle print empty pf ffle pe ffl pf ffl pf ffl print fork pf ffle pe ffl pf ffl pf ffl print pf ffle print printing algebraic data structures general describe general scheme arbitrary algebraic data type 
assume type definition form 


nc introduce print instructions pi 
pic constructor arity 
action print instruction pij depends 
case pops closure stack top 
prints constructor prints space pushes functions print component type 
prints right parenthesis 
case activates old stack top element 
print value empty empty value fork fork empty empty empty fork fork empty empty empty 

printing algebraic data structures referring example tree empty fork arities 
corresponding print functions pe pf pf pf 
print instructions constructor defined follows pi ffle pi ffl print pi ffle print pij ffle pij ffl print pij ffle print abbreviates list functions necessary print value type ij ij base type just closure pb machine instruction printing base values 
ij algebraic type list functions printing possible summands ffl 
pn ffl 
note disregard printing rules pairwise rule 
activate stack top closure 
applying general theory printing section show general theory adapted printing data structures language 
printing machine follow general theory exactly untyped 
may identify kinds data base values booleans naturals functions 
printable value base value expression components printable values want print functions 
printable expr expr nil cons printable printable run time machine expressions functions indistinguishable shall assume form type correctness program evaluates printable value 
machine spuriously print function values expressions shall considered type error detected compile time type check 
scheme printing printable values follows quite closely printing binary trees discussed section 
design print instructions print base values expressions 
fortunately base values closures form distinguished data structures whnf form lam run time 
pb print base value pn print nil instructions merged called pn 
instruction activated base value nil value 
able distinguish looking stack top closure 
activated base value remove stack element just top hold pc closure 
pn activated nil closure removed nil 
rules instructions general rules prescribe expressions 
chapter 
lazy example language retfflv ffle print ffle print nil ffle pc ffl pc ffl print cons ffle pc ffl pc ffl print ffle pc ffl print rules print value expression cons cons cons nil cons cons cons nil 
running machine printing section explained run basic machine expression evaluation extended machine works similarly initial stack empty contain print functions 
evaluate initial environment machine started state ffl ffl code compiled computation terminates machine print function finds stack empty printing base value finds stack empty printing right parenthesis 
notice machine may terminate useful computing printing infinite data structure 
printing lisp style expressions rules just print data structures general scheme readable format la lisp scheme expressions miranda tm lists preferable 
achieved introducing versions pn pn instruction versions pc pc instruction 
unprimed ones print component pair primed ones print second component 
scheme avoids filling stack closures print right parentheses 
ffl nil component prints 
second component prints 
ffl base value component prints just second component prints dotted pair lisp terminology 
ffl cons component prints 
second component prints blank simply space expressions 
pn retfflv ffle print pn ffle print pn retfflv ffle print pn ffle print pc ffle print pc ffle print pcr ffle pn ffl pc ffl 
adding laziness rules print value expression cons cons cons nil 
considerably readable result general rules especially long complicated lists 
disregard printing done functions pn pn identical pc pc number rules reduces 
run machine expression lisp style printing start state code compiled adding laziness machine lazy way instruction machine 
previously observed pierre cr 
laziness achieved overwriting argument closure ffle held environment reduced closure ffle representing whnf 
achieve overwriting introduce markers new kind object put stack 
operationally speaking marker contains pointer points closure environment lazy machine execution var instruction causes argument closure ffle activated pushes marker stack points closure ffle heap whnf ffle ffle reached expects take argument stack find marker 
causes closure location overwritten ffle assertion points ffle heap written ffle action overwriting closure pointed closure ffle written ffle formalize satisfactory manner include heap fourth component machine distinguish carefully closure construction execution application passing pointers environments heap allocated linked lists heap allocated closures 
shall go degree formality going analyse prove properties sharing mechanism 
mainly indicate intended kind implementation 
noted section possible form retfflv 
expect take argument stack result conveniently test markers argument 
new rules lazy machine shown 
instructions mention app 
remain 
var ffle lam lam lam lam ret ret retfflv ret retfflv instructions lam ret represent whnf repeatedly take marker stack update marked objects markers remain 
find closure stack top stack empty instructions execute usual 
chapter 
lazy example language adding letrec consider letrec expression letrec 
fm em core source expression form compiled new machine instruction lrc follows 
letrec 
fm em ae ae fm 
ae ae 
lrc 
cm idea scheme compile right hand sides em body expression compile time environment ae expected mutually recursive definitions 
effect new lrc instruction environment construct recursive run time environment extends provides recursive bindings right hand sides 
note compiled right hand sides 
cm added run time environment natural order new environment cm ffle 
ffle holds opposite order 
lrc cs cs 
cm cm ffle 
ffle follows general handling laziness markers recursive data structure definition letrec ones cons ones ones create appropriate cyclic structure evaluate expression 
summary translation evaluation rules summarize translation core machine code evaluation rules lazy machine 
translation core machine ae lam ae 

var ae app ae ae ae cst ae app ae ae app app app ae ae ae app app app ae ae ae letrec 
fm em ae ae fm 
ae ae 
lrc 
cm 
summary translation evaluation rules complete set evaluation rules specifying lazy machine code env 
stack code env 
stack app ffle var ffle lam lam lam lam ret ret retfflv ret retfflv cst ret ffle ffle ffle ffle op retfflv ret op retfflv retfflv op retfflv retfflv ret op pn retfflv ffle print pn ffle print pn retfflv ffle print pn ffle print pc ffle print pc ffle print pcr ffle pn ffl pc ffl lrc cs cs 
cm cm ffle 
ffle written experimental implementation compilation machine code machine 
implementation briefly described appendix 
chapter closure analysis chapter describes approximate program analysis called closure analysis 
purpose closure analysis find superset set closures functions expression may evaluate 
information set textual lambdas program may generate closures 
closure analysis defined lazy language introduced chapter works strict lazy languages 
closure analysis useful finding approximation set arguments lambda may applied 
usage count analysis chapter globalization algorithm chapter 
useful general extend analyses order languages higher order languages explained section 
analysis originates master thesis proved correct strict language 
variants 
version extended data structures lambdas letrec proved correct respect machine section 
similar analysis language scheme developed independently shivers 
analysis core language shall show closure analysis core language 
describe analysis language letrec describe straightforward extension handle section 
data structures covered standard translation core language require special treatment 
interesting observe simple minded approach gives quite reasonable results section 
closure analysis closure analysis shall require lambdas program uniquely labelled furthermore variable occurrence program labelled 
analysis core language label lambda binding variable discussion shall identify lambdas variables labels 
semantically speaking label lambda expression abstracts set closures lam formed lambda expression choosing arbitrary environment choosing arbitrary bindings free variables lambda expression 
shall assume closure initial environment computation evaluate function 
desirable consequence labels run time input set labels necessary determined program text 
negative consequence function values data structure values input program 
fixed program label set labels 
analysis closure descriptions oe ae label 
label 
called result closure description oe argument closure description ae intended give information oe set lambdas body evaluate ae set lambdas applied set lambdas variable bound shall define analysis functions meanings oeae set lambdas expression evaluate oeae set lambdas lambda applied function called closure analysis function called closure propagation function 
closure analysis function defined follows expression 
label oeae oeae ae oeae oe oeae 
oeae fg oeae oeae oeae analysis equations justified follows 
lambda expression labelled evaluate 
variable labelled evaluate closure variable bound ae 
application evaluate closures application lambda possible closure value fully applied base function return base value evaluate lambda 
conditional evaluate lambdas branches evaluate 
closure propagation function defined follows chapter 
closure analysis expression label 
label oeae oeae oeae fg oeae oeae oeae oeae oeae 
oeae oeae oeae oeae equations justified follows closures lambda applied lambda expression applied body 
variable expression applied 
application applied applied addition possibilities contribution application evaluate case applied evaluate 
evaluate case contribution application 
base function application applied applied argument expressions 
conditional expression applied applied component expressions 
analyse program seek descriptions oe ae safe unnecessarily conservative 
description oe conservative oe written oe oe labels label oe oe 
definition applies ae 
seek descriptions oe ae constitute simultaneous solution equations oe oeae lambdas ae oeae lambdas closure analysis letrec local recursive letrec definitions core language introduce new names manner lambda expressions 
analyse expression letrec 
fm em require letrec bindings labelled uniquely labels label 
set letrec labels disjoint set lambda labels 
labelled recursive binding meaning oe ae oe set lambdas evaluate set lambdas bound ae understood considering explanation recursive bindings lambda expressions follows 
value defined recursive binding letrec 
satisfies 
equation things clear 
reading equation forwards see possible result applying 
oe contain lambdas evaluate 
secondly considering application see 
correctness respect machine possible argument possible value 
ae contain lambdas evaluate 
analyse program containing letrec seek descriptions oe ae constitute simultaneous solution equations oe oeae lambdas ae oeae lambdas oe ae oeae letrec 
fm em 
additional equations analysis functions letrec 
fm em oeae oeae letrec 
fm em oeae oeae handling data structures restriction run time input initial environment contain functions standard 
encoding data structures functions prevents data structures input program 
obviously restricts usefulness analysis somewhat easy way 
essence problem data structure input labelled 
requirement agree view user consider automatic program analysis black box behaviour workings need understand 
see analysis yields reasonable results programs combination higher order functions data structures consider closure analysis program 
produces infinite list numbers applying infinite list multiples functions argument 
superscripts labels 
letrec multiples cons multiples map case nil 
nil cons 
cons map map multiples closure analysis program tells map bound function map bind function value 
satisfactory evident syntax program 
correctness respect machine section shall prove closure analysis correct respect machine 
analysis proven correct respect standard denotational semantics standard denotational semantics treat functions extensionally chapter 
closure analysis matter function specified extension roughly set argument value pairs matters 
means standard semantics value expression impossible find lambdas may generate value 
operational semantics machine better purpose description function value may usually incorporate information textual lambda generated 
shall assume machine computations carry labelled lambdas lam needed correctness proof 
original closure analysis call value language proved correct respect operational semantics called natural semantics strict language 
improvement correctness proof valid non terminating computations original 
side effect free strict language lazy data structures non terminating computations sense 
usually identify non terminating computations undefined pragmatically speaking useless result 
language lazy data structures possible distinguish non terminating computations compute infinite data structure 
lazy printing allows look arbitrary finite prefixes approximations infinite result 
correctness closure analysis closure analysis correct safely describes set lambdas expression evaluate 
expression evaluate closure analysis function satisfy oeae 
plan proof follows 
start proving analysis correct detail applicative kernel lam var app subset machine instructions 
explain modifications needed base values letrec 
define number auxiliary concepts trace machine computation whnf computation balanced trace 
prove property balanced induction length trace 
property prove correctness analysis evaluate oeae 
preliminaries trace machine finite infinite sequence 

machine states succeeding states related rule machine 
subtrace trace contiguous subsequence 
prefix initial subtrace 
state transitions states 
computation machine program trace 

ae compiled code initial environment empty stack 
recall run time input program free variables initial environment provides values variables 

correctness respect machine balanced trace finite trace 
sequence 
gamma machine instructions form simple simple var app lam balanced trace simple sequence instructions form simple composite 
simple balanced trace 
initial final stacks identical fact easily proven induction balanced trace considering machine rules var app lam 
means initial final instructions continuation context 
balanced subtrace represents subcomputation step evaluation expression whnf 
whnf computation instruction shortest balanced trace 
form lam case whnf ffle lam ffle note case contexts closures 
small notational problem analysis functions labelled language expressions machine executes machine instructions 
labelled translation transfer labels expressions machine instructions ae lam ae 

var ae app ae ae shall occasionally sloppy apply analysis functions compiled instructions 
may say lam mean ae code compiled ae suitable compile time environment 
correctness theorem applicative kernel fixed program applicative kernel corresponding machine code shall prove closure analysis correct program 
oe ae descriptions computed start lemma balanced subtrace 
computation holds oeae oeae 
proof see section 
lemma desired correctness closure analysis follows proposition 
lam whnf computation subexpression oeae 
chapter 
closure analysis proof lemma oeae oeae lam oeae closure analysis function computes superset set lambdas may evaluate safely approximates set 
result balanced traces proved arbitrary computations induction prefixes 
state induction hypothesis need auxiliary concepts 
environment ae safe analysis ffl variable associated value ffle ffle 
ffle ae oeae ffl ae safe 
stack ffle 
ffle safe ae safe 
proof lemma induction hypothesis prefix 
parts 
simple balanced subtrace 
prefix satisfies oeae oeae 
state prefix ae safe safe 
property oeae oeae simple balanced property follows composite ones 
proved considering decomposition simple balanced transitivity 
exploited 
base case prefix just 
contains balanced subtrace holds trivially 
assumption contains function values oeae fg holds 
induction step assuming induction hypothesis prefix show prefix case analysis instruction state prefix 
case var prefix extended transition var 
new simple balanced subtrace var var oeae ae oeae definition variables ae safety follows property holds prefix 
ae safety follows ae safety property holds 
case lam stack empty trace extended assume non empty 
prefix extended transition lam ffle ffle 
extended prefix contains new simple balanced subtrace sequence instructions form app 
correctness respect machine 
lam subtrace 
lam possibly composite balanced trace 
part induction hypothesis note composite traces oeae lam oeae oeae definition lambdas 
see property holds show app oeae oeae 
app oeae oe oeae oe oeae definition applications oeae definition oe 
see property holds prove ae oeae ae safety ffle follow ae safety safety ffle ae oeae app oeae oeae oeae oeae definition ae properties definition applications oeae 
case app prefix extended transition app ffle 
property holds new balanced traces introduced 
property holds safety ffle follows ae safety safety completes proof cases inductive step 
completes induction proof lemma 
property balanced traces holds arbitrary computations infinite ones 
correctness closure analysis function applicative kernel follows noted proposition 
subsections argue analysis correct rest core constructs handling base values letrec 
correctness base value instructions correctness closure analysis parts core dealing base values demonstrated section 
shall give proof full detail 
show adapt notions balanced trace whnf computation introduced extended language extended machine 
preliminaries revisited concepts balanced trace whnf computation need revision take account additional expressions machine instructions 
additional forms simple balanced traces corresponding evaluation base value constants argument base function applications conditional 
simple var app lam cst app ret app app app ret ret app app app ret chapter 
closure analysis hard see new forms simple balanced traces correspond precisely trace evaluating constructs core deal base values ae cst ae app ae ae app app app ae ae ae app app app ae ae ae shall assume expressions involving base values base functions type correct traces evaluation base value expressions ret instruction lam 
assumption easy prove evaluation stack preserved balanced trace 
holds new kind whnf form lam necessitates revision definition whnf computation 
whnf computation shortest balanced trace 
form lam ret 
case whnf ffle function lam ffle case base value extension proof lemma extend case analysis proof section 
case ret introduce new simple balanced traces property preserved 
swapping environments stack top elements affect property 
case cst new balanced subtrace cst ret 
ret oeae fg trivially case cst oeae ret oeae property preserved 
swapping environments stack top elements affect property 
case cst case possible transitions branches conditional 
consider instance ffle ffle 
introduces new simple balanced trace sequence instructions app app app app app app 
ret ae 
app app app oeae oeae oeae oeae oeae oeae definition shows property holds prefix 
property holds earlier state prefix 

implementation correctness letrec new kind simple balanced trace sequence instructions simply consists lrc instruction 
simple 
lrc labelled translation letrec letrec 
fm em ae ae fm 
ae ae 
lrc 
cm extend case analysis proof follows case lrc prefix extended transition lrc 
cm 
introduces new simple balanced trace length 
lrc 
cm oeae oeae definition letrec property holds prefix 
new environment ae safe 
holds ae oeae definition ae closure analysis equal ae safe 
implementation experimental implementation closure analysis goes implementation machine 
implementation briefly described appendix gives example 
extending analyses higher order languages closure analysis extending essentially order analysis methods higher order languages 
main difference order higher order program analysis lies handling function applications 
order language applications form name defined function 
order strictness analysis say keep table value defined function simply look combine value obtain value application 
higher order language applications general form clear function really applied obvious ways proceed 
auxiliary analysis find approximation set functions evaluate map get approximate value valid functions 
value application result combining value argument 
closure analysis approach 
chapter 
closure analysis secondly value function applied value gives value application 
approach taken burn hankin abramsky strictness analysis typed lambda calculus 
untyped language necessary value expression pair properties expression independent type properties expression applied function 
gives strictness pairs method hudak young 
compare approaches untyped languages closure analysis method strictness pairs method 
complexity closure analysis upper bound complexity closure analysis considering height domain oe ae label 
label 
number elements label height label height height function needs passes program 
number elementary operations pass proportional size program elementary operation takes time proportional 
non constant time operation rule application 
assume number labels lambdas letrec bindings expanded program proportional size program 
complexity closure analysis size program 
closure analysis done polynomial time 
fast tractable reflects complexity completely unsophisticated implementation 
serious problem analysis easily extensible separate compilation necessary analyse entire program time 
strictness pairs method strictness pairs method developed hudak young yale university called originally higher order strictness analysis untyped lambda calculus 
strictness pairs method subsequently papers hudak colleagues variety higher order program analyses 
bloss developed higher order path analysis update analysis goldberg developed higher order sharing analysis escape analyses 
strictness pairs method hudak young described roughly follows 
assume order fo analysis working values extension higher order ho analysis ho value pair fo value function values values 
ho value function valued expression pair called strictness pair describes strictness properties describes strictness properties function evaluates 
hudak young call direct strictness delayed strictness value base value pair second component 
extending analyses higher order languages means applicable delayed strictness 
abstracts functional value map value argument value result application 
domain ho values strictness pairs sp sv theta sp sp sv domain values underlying order analysis 
note sv lattice finite height sp infinite chains 
complexity strictness pairs method reason guarantees strictness pairs analysis terminate applied arbitrary untyped lambda term page 
applied lambda terms form weak typing analysis terminate 
certainly sufficient impose monomorphic type discipline burn hankin abramsky framework milner style polymorphic abramsky extension framework 
sufficient require values reducing type value applied arbitrarily times producing base value 
hand restrictions necessary strictness pairs method terminate clear precisely necessary 
reasons shall consider worst case complexity restricted case typed lambda calculus case hudak young approach burn hankin abramsky 
set values underlying order analysis denote domain strictness pairs type nat theta theta number elements ja ja theta ja ja height height height ja theta height 
hard see 
height domain approximately proportional product sizes particular ary function arguments type base type height exponential define rank type nat see height th th 
stack high number elements order domain number iterations needed analysis find value expression bounded height domain 
worst case complexity types get complex 
mean complexity analysis grows size program long types arities involved remain bounded 
practical problem strictness pairs approach necessity construct compare apply representations higher order functions analysis 
tolerable small underlying domains point domain strictness analysis path analysis expensive bloss consider full higher order path analysis implementable page 
chapter 
closure analysis applicability analysis data structures strictness pairs method hudak young explicitly handle data structures conceivably encoding functions section 
clear works recursively defined infinite data structures hallmark lazy languages 
ensure termination strictness pairs method second component strictness pair eventually produce applied sufficiently times pp 

amounts requiring values reducing type encoding infinite list ones cons ones cons reducing type 
seen tail infinite lists 
reducing type requirement sufficient termination discussion entirely clear really necessary 
analysis applicable data structures encoded functions complexity may high 
reason functions resulting encoding types high rank 
type function xs 
takes list xs base values input rank 
height domain values size domain values base types 
xs list functions list functions lists rank higher height value domain grows enormously 
note affect complexity terms size program 
uncertain hudak young strictness pair method analyse data structures encoded functions 
comparison strictness pairs method precise expensive requires programs slightly typed may applicable analysis data structures encoded higher order functions 
closure analysis method hand reasonably fast imprecise requires typing applicable analysis data structures encoded higher order functions albeit possibly considerable loss precision 
claim purposes closure analysis approach feasible precise cf 
section 
fact sufficiently bondorf danvy substantial self applicable partial evaluator similix scheme 
obtain better analyses data structures probably need type structure language 
chapter usage interval analysis chapter describes called usage interval analysis 
analysis computes lower upper bounds number times expression may evaluated containing expression 

evaluated 
provides approximate information number times function application may evaluate argument expression assuming parameter passing call name 
results analysis purposes 
lower bound provides strictness information upper bound provides sharing information 
lower bound greater equal argument evaluated may evaluate argument function body 
upper bound equal argument sharing mechanism needed obtain call need lazy evaluation 
lower bound strictness optimization said replace call need call value 
similarly upper bound sharing optimization said replace call need call name 
usage interval analysis works lazy language introduced chapter 
originally developed guy argo machine tim version fairbairn wray instruction machine 
version analysis simplified extended cover data structures lambdas local recursive letrec definitions 
usage interval analysis purpose usage interval analysis find lower upper bounds number times argument lambda may evaluated language implementation call name call need lazy just non strict 
usage interval analysis subsumes simple strictness analysis sharing analysis lower bound usage interval argument greater zero combinator strict argument 
upper bound argument may shared 
chapter 
usage interval analysis usage counts usage intervals usage count variable evaluation number set represents number greater 
set usage counts ordered zero 
addition multiplication usage counts defined obvious way 
example zero theta zero minimum maximum set usage counts defined obvious way 
usage interval set fu ju min usage counts denoted min max min umax set ui usage intervals ordered set inclusion lattice 
upper bound usage intervals usage interval containing 
addition multiplication usage counts extend usage intervals straightforwardly theta 
operations mimicking effect combining expressions syntactically parallel uses application theta alternative uses 
consider example usage intervals 
example program letrec variables usage intervals zero zero 
illustrate effect higher order functions consider program letrec twice twice obviously usage interval 
find usage interval need know functions may bound 
closure analysis tell bound applied argument really value knowledge usage interval find usage interval usage interval 
implies partial application may shared 
argument may shared usage interval expect sharability lambda expression propagates free variables manifested sharability partial application propagating arguments 

usage interval analysis usage interval analysis core core program usage interval analysis constructs usage description sharing description usage count analysis uses closure descriptions oe ae computed previous closure analysis section 
label ui usage description usage description sharing description analysis intended satisfy usage interval lambda letrec variable scope usage interval lambda expression safe approximation number times lambda applied 
usage interval analysis consists analysis functions 
purpose function called usage analysis function compute usage interval variable expression usage interval variable expression evaluated 
purpose function called usage propagation function compute usage interval lambda program union usage intervals lambda letrec variables possible value usage interval lambda expression appears function position application 
position applied exactly containing expression evaluated 
usage analysis function defined follows expression zero zero theta zero zero theta 
letrec 
fm em zero zero 
mg thetau analysis equations justified follows 
chapter 
usage interval analysis lambda expression variable variable case usage interval zero zero 
usage interval theta usage interval lambda usage interval lambda body expression variable exactly variables exactly zero times 
application variable may evaluate function 
may evaluate function applied application product argument number times function evaluates argument 
safe take upper bound usage intervals functions evaluate 
strict base function application number uses sum arguments 
conditional expression variable evaluate root expression obtain truth value branches taken 
safe take upper bound usage intervals branches 
local recursive definition letrec 
fm em variable variables case usage interval zero zero 
usage interval sum uses definitions body letrec definition 
definition product right hand side usage interval bound variable suffice explain usage interval analysis equations 
usage propagation function defined equations expression ae zero oeae 
letrec 
fm em ae analysis equations justified follows 
lambda 
bound variable ae usage interval subset usage interval lambda 
variable binding lambda contribution usage interval empty usage interval zero identity element upper bound usage intervals 

usage interval analysis lambda 
possible value subexpression function position application exactly evaluation application 
may evaluation subexpressions 
full base function application conditional lambda may subexpressions 
local recursive definition lambda 
possible value letrec variable usage interval subset usage interval lambda 
addition lambda may right hand sides body letrec 
usage interval analysis programs point functions compute pair descriptions gives usage interval variable lambda core program program 
desired pair descriptions solution set simultaneous equations thetau letrec 
fm em 
complexity usage interval analysis upper bound complexity usage interval analysis considering height domain label ui 
inclusion ordering ui lattice height 
assuming number elements label lattice height pointwise inclusion ordering height 
monotonic functions fixed point passes program 
pass done time proportional square size program 
non constant time set operation equation application 
assuming number labels lambdas letrec bindings proportional size program find complexity usage interval analysis roughly size program 
analysing data structures analyse program result lazy data structure need provide initial context program 
initial context drive lazy evaluation way simulates way printing 
functions pn pn printing nil functions pc pc printing cons shown section observed disregarding actual printing primed non primed functions behave 
chapter 
usage interval analysis introduce functions simulate pn pn pc pc analyse application program functions 
artificial context removed analysis results optimizing compilation 
print simulators defined follows 
function strict base function 
easy see behaves pn pn applied non base value 
similarly see behaves pc pc instructions pcr instruction 
having add context really neat sense programs result data structure 
typed language convincing treatment 
related hughes wray describe method estimate number times expression evaluated call name hughes general backwards analysis framework section 
advantage admitting analysis data structures higher order functions 
goldberg sharing analysis similar usage interval analysis higher order untyped language data structures 
jensen mogensen similar analysis compile time garbage collection order language data structures extension higher order programs means closure analysis 
goldberg analysis strictness pairs variety discussed section expensive higher order functions 
higher order analyses framework hughes roughly complexity goldberg investigated detail 
optimizing call need call name lazy evaluation expensive suspensions created values may may needed markers pushed entering argument expressions tests markers suspensions overwritten 
section describe ways improve lazy call need evaluation 
replace call need call name upper bound number times function argument evaluated 
second replace call need call value lower bound number times function argument evaluated 
kinds analysis information provided usage interval analysis 
lazy parameter passing mechanism call need replaced call name loss efficiency argument known evaluated 
optimizing call need call name 
upper bounds computed usage interval analysis provide precisely information need optimization 
replacing call need call name affect result extensional behaviour program inappropriately applied may affect efficiency considerably destroying laziness 
call name machine section shall describe improved compilation core programs instructions improved machine called machine 
compilation algorithm uses upper bound information computed usage interval analysis 
introduce new instructions unsharable variable var unsharable lambda lam 
variable unsharable usage interval contain upper bound 
closure bound unsharable variable accessed necessary push marker entering closure 
lambda unsharable usage interval contain upper bound 
means lambda bound unsharable variables marker stack top lambda takes argument stack 
unsharable lambda need check markers 
compilation rules lambdas variables core summarized section extended follows 

var var ae lam ae lam ae machine rules new instructions follows 
instructions machine summarized section 
code env 
stack code env 
stack var ffle lam unsharable variables var optimizations possible 
observe application app var unsharable variable pair var instruction environment push closure var stack 
closure executed extract value ffle enter 
probably better extract closure ffle immediately put stack entered 
trade time takes needlessly extract ffle time take construct var likelihood variable 
extracting closure immediately added advantage keep components live var stack optimization may reduce heap residency space consumption 
chapter 
usage interval analysis optimization admissible variable unsharable sharable closure entered evaluated times 
concretely manifested need push marker entering ffle introduce new special instruction app loads closure ffle bound variable directly environment optimize machine code replacing occurrences app var app 
code env 
stack code env 
stack app ffle ffle unsharable variables letrec bound textual functions lambdas generally variables known bound objects whnf 
need push marker entering value immediately overwrite avail 
mean letrec bound lambda check markers quite possible whnf closure bound sharable variable needs overwritten 
easy change compile time environment ae distinguish letrec bound function variables compilation generate var instructions 
related hughes wray analysis described developed optimizing call need call name section 
fairbairn removing redundant laziness presents idea avoiding laziness overhead expression give analysis 
peyton jones uses intermediate language stg distinguishes updatable non updatable closures 
calls analyses introduce update annotations update analysis give analysis section 
non updatable closures closely related notion unsharable variable notion unsharable lambda analogy exact 
analysis treat closures individually works variables bound lambdas whnf evaluate 
framework responsibility variables lambdas sure closures overwritten needed 
sharing analysis optimization readily applicable update analysis 
optimizing call need call value mentioned lower usage bounds give strictness information 
machine ill suited exploit information 
strictness optimization possible machine evaluate function argument whnf application time force treat formal parameter unsharable var marker pushed entry variable value 
variable necessarily bound whnf 
optimizing call need call value point pushing marker entering whnf cause needlessly overwrite immediately 
note value variable necessarily closure way represent value machine 
realistic machines strictness gives opportunity treat base values unboxed non closures real machine integers unfortunately forcing evaluation expression quite complicated expression result base type 
simple way get control back expression evaluates function 
hand base values activate stack top element just stack top element function takes stores evaluated base value 
call value machine experimented strictness optimizations base value arguments introduced new instructions machine 
variants lambda sla strict lambda sla strict unsharable lambda 
takes argument suspension stack top puts unsharable lambda lam stack top enters argument suspension 
evaluates base value whnf retfflv activates lambda lam stack top 
language untyped know closure analysis ae fg lambda applied base type arguments 
revised compilation scheme lambdas ae sla ae zero ae fg sla ae zero ae fg lam ae lam ae new instructions interpreted follows machine code env 
stack code env 
stack sla ffle lam sla sla sla sla ffle lam note strict lambda need put marker stack evaluating argument 
argument whnf base value retfflv activate closure lam stack top bound environment necessity construct new closure stack optimization worthwhile argument 
compilation rules modified require usage interval contain 
chapter 
usage interval analysis related theoretical optimizing call need call value supporting called strictness analysis starting mycroft thesis 
strictness analysis higher order typed languages done burn hankin abramsky untyped functions hudak young 
wadler gave strictness analysis lazy lists 
hughes suggested strictness analysis data structures understood interpretation continuations 
subsequently wadler hughes projections simplify presentation data structure strictness 
analyses vastly precise strictness analysis 
fairbairn wray give strictness detection algorithm second order functions data structures bears similarity 
analysis usages called strict lazy dangerous absent correspond respectively usage intervals containing zero zero empty containing zero 
cited describe extension second order languages 
section outline backwards strictness analysis data structures order language 
analysis takes types expressions account expensive give considerably better results chapter 
experiments section describes experiments implementation usage count analysis 
experimental implementation usage count analysis listed appendix 
optimized compilation machine interpreter machine described appendix 
appendices briefly outline implementation give example 
measurements implementation analyses machine run different levels optimization described shortly 
cases letrec bound lambdas bound unsharable variables suggested section 
ffl optimizations 
ffl sharing optimizations section ffl sharing strictness optimizations sections give cpu time seconds excluding garbage collection number expressions 
functions expressions defined appendix 
timings obtained chez scheme running sun sparcstation suffer variation run run 

experiments optimizations sharing sharing strictness take primes hd drop primes nth ones nth scan foldl take lam fact lam fact fact take take repeat fact immediate sharing optimization reduces run time programs 
strictness optimization gains sharing optimization 
come great surprise clumsy way strictness obtained machine 
study effect optimizations number marker checks done instructions ret lam sla number marker updates number markers encountered checks 
optimizations sharing sharing strictness check update check update check update take primes hd drop primes nth ones nth scan foldl take lam fact lam fact fact take take repeat fact seen sharing optimization leads considerable reduction checks updates benchmarks exclusively base values involving fact 
general strictness analysis reduces number updates base value cases eliminates updates 
hand increases number checks 
base values boxed done base value involves marker check 
results satisfactory 
machine exploit strictness information speed ups obtained 
chapter 
usage interval analysis imprecision analysis data structures unfortunately usage interval analysis turns give imprecise results analysis data structures 
due simple minded treatment higher order functions inherent closure analysis approach combined complex higher order functions resulting encoding data structures 
example lower upper bounds usage imprecise examples letrec hd tl cons expect tl summand addition analysis finds usage interval zero 
see consider translation core annotated lambda labels letrec root problem variable twice free lambda 
possible value variable zero zero bound union zero product usage interval zero usage interval program 
example consider expression case nil 
cons xs 
expect lower bound expression 
transformed core expression xs 

closure analysis may show evaluate nil cons analysis analyse expressions xs separately find usage interval zero 
resulting usage interval zero 
particular problem caused independent handling branches case 
analysed expression twice hypothesis evaluates nil hypothesis evaluates cons 
correct usage interval increase complexity analysis considerably solve problem example 
assessment usage interval analysis frequently fails find lower upper bounds expressions involving data structures 
analysis improved various ways especially obtain better lower bounds 
obtain reasonably precise inexpensive analysis probably necessary exploit recursive type structure 
experiments data structures fact structured typed programs tend handle recursive levels way 
type information recursive data types exploited chapter 
particular shall outline usage interval analysis typed order languages data structures 
chapter evaluation order analysis chapter describes analysis obtain approximate information subexpression evaluation order 
language considered lazy data structures typed lazy order functional language 
information optimizing suspensions thunks exploiting knowledge form variable definitely evaluated variable definitely evaluated 
chapter part joint carsten gomard text appear forthcoming ph thesis 
plan chapter follows 
section introduces backwards path analysis presents order example language lazy data structures 
section introduces variable paths tools describing evaluation order expressions data structures 
section shows evaluation order analysis presents main analysis functions 
section presents small examples evaluation order analysis 
section describes application evaluation order information optimization suspensions 
section presents occurrence path analysis intended step analysis evaluation order relations section 
analysis seen cheaper approximation variable path analysis 
cheap approximation backwards strictness analysis section 
section shows extension evaluation order types general data types section discusses related 
previous analysing evaluation order lazy call need languages focussed evaluation order variables dealt lazy data structures 
bloss hudak analyse expression letrec find variables may evaluated orders assuming evaluates arguments left right 
finding expressed set paths path finite sequence 
variable names 
path set example fhv wi hv wig 
bloss hudak path analysis forwards analysis concatenates paths argument expressions order corresponding variables 
variables occur path lazy language argument expression bound variable evaluated 
forwards path analysis method computations involving lazy data structures 
reason order evaluation expression pair depends context expression specifically order parts result required 
call evaluation order type context expression 
assume evaluates arguments left right 
expression pair occurs fst snd evaluated hand occurs snd fst evaluated easy construct contexts ignore variables 
suggest analysis works backwards demand order result expression subexpressions variables occurring expression 
analysis implemented 
backwards path analysis backwards path analysis variable paths 
path sequence events 
variable path event epsilon name variable path describes evaluation records order evaluation subexpressions 
event marks expression bound reaches weak head normal form whnf special event marks reaches whnf 
lazy language expression bound variable evaluated 
variable path tell order different variables reach whnf variable reaches whnf expression 
allow tell expression strict certain variable 
evaluation order data structure described context evaluation order type type data structure path sets describing order evaluation components 
recursively defined types nlist nil cons nat nlist uniform descriptions allowed recursive components type nlist description 
context form evaluation order type result expression find order free variables evaluated contexts 
similarly evaluation order type function application get evaluation order information arguments 
example consider expression assume evaluates arguments left right 
possible path hx expresses evaluated whnf expression reaches whnf 
shows expression strict expression chapter 
evaluation order analysis case nil 
cons xs 
possible paths hy hy depending branch taken case 
variable relevant outside case branch occurs shall assume bound variables distinct cause confusion 
consider expression cons assume occurs context ignores heads uses tails context argument function length 
possible path zi shows expression reaches whnf evaluates cons cell whnf context requires value appears path 
examples show analysing program know branch taken case 
shall consider computations possible program classes computations single computations 
path sets pi single paths 
set intended upper approximation superset set paths possible expression 
order example language simple example language illustrate evaluation order analysis 
lazy simply typed order functional language directly indirectly recursive data types 
standard examples recursive data types tuples lists naturals lists lists naturals program consists data type definitions set recursive function definitions program body 
program typedef 
typedef letrec program types typedef 
data type declaration texp 
texp type summand texp nat natural numbers type name letrec letrec def 
def program def theta 
theta function declaration 
function definition function parameter 
base function application 
constructor application 
function application case branch 
branch case data type branch 
xm 
case branch type expression base type name data type 
data type set summands consists constructor list type expressions 
note data types may recursive 
constructor names distinct 

language order defined functions base functions constructors fully applied 
case expression case branch 
branch consists root expression type data type branches constructor body program letrec expression letrec 
expression language simply typed expressions assumed type correct shall give formal type system 
informal semantics expressions evaluated reduced weak head normal form whnf rules ffl variable reduced whnf reducing suspension closure bound variable overwriting whnf reduced whnf returning whnf reduced 
ffl base function application 
reduced whnf reducing base type arguments 
whnf left right applying base valued function denoted whnf base type expression value 
ffl constructor application 
reduced whnf making suspensions arguments 
returning package consisting constructor closures 
ffl application 
function defined 
reduced whnf follows 
suspensions arguments 
bound formal parameters 
body reduced whnf 
ffl case expression case branch 
branch reduced whnf follows 
reduced whnf form 
selecting th case branch 
ic 
suspensions 
bound formal parameters 
ic right hand side reduced whnf 
assume pure lazy evaluation reduction strategy 
assume evaluated non speculatively sequentially single processor 
machine shown chapter useful operational model language 
origin evaluation order lazy data structures printer demand result entire program 
determines evaluation order type program body expression turn determines evaluation order type evaluation order subexpressions program 
order printer demands result program described generally preorder left right 
printer obtains weak head normal form know constructor print recursively evaluates prints arguments constructor left right 
chapter 
evaluation order analysis describing evaluation order particular evaluation lazy program subexpressions program evaluated weak head normal form abbreviated whnf order ultimately determined printer demand result print 
precise order inferred program input data available program run 
goal give approximate evaluation order description eod expression valid possible evaluations program independently concrete input data 
outlined shall path sets eod 
variable paths operations path repetition free sequence hp 
events 
variable paths event epsilon variable set events 
define paths path sets follows path hp 
implies pi pathset path shall require variable path contains 
denoting eod set possible evaluation order descriptions put eod pathset vars vars set variables free bound 
operator theta ordinary append sequences path theta path path concatenation duplicates 
ordinary prefixing operator hpi path containing call strict part non strict part 
recall describes evaluation expression marks event reaches whnf 
events happen reaches whnf simply strict context requiring whnf expression strict variables occurring justifies terminology 
subset path 
intersection denote subsequence consisting elements pi pathset pi denote distributed intersection pi similarly pi means pi 
equip pathset subset ordering pi pi pi pi pathset lattice join set union meet set intersection element fg greatest element path 
element fg result analysing black hole compare singleton path set fh ig constant function 
assuming non elements path gamma elements 

height pathset number elements pathset 

interleaving paths defined follows 
describing evaluation order path theta path pathset hi hpi interleaving path path set pi gives pi pi interleaving operations needed define combinations path sets 
argument evaluation order describe order function evaluates arguments argument evaluation order description argument eod 
variable path set pi pi aeod 
ng labels entire function application labels th argument position 
relation intended reflect laziness relate evaluations arguments relates uses corresponding variables argument eod fh ig mean variable variable body means precedes lazy language means argument evaluated argument examples fh ig mean second argument evaluated whnf argument fh ig mean function application evaluate whnf evaluating argument 
interestingly fh ig mean argument evaluate whnf function application 
words function needs argument strict 
argument eod function computed finding path set body extracting information formal parameters 
path set 
described section 
application contexts fully describe function say order consumes arguments consumes individual argument value 
information shall called context evaluation order type argument 
define evaluation order types section eot denote set evaluation order types type describe function application context ff pi 
pair argument eod pi tuple 
evaluation order types arguments 
function type theta 
theta set 
possible application contexts defined follows ff 
aeod theta eot assuming eot lattice finite height 
lattice finite height taken componentwise 
chapter 
evaluation order analysis note application context describe order evaluation components values distinct argument expressions order evaluation whnf order evaluation inside 
evaluation order types evaluation order type eot describes evaluation order components value 
evaluation order types base types nat quite trivial nat values atomic 
base value considered nullary constant function natural take evaluation order types base types elements aeod 
evaluation order descriptions aeod ffg fh igg representing contradictory context full evaluation context respectively 
evaluation order types values data type interesting 
shall discuss evaluation order types non recursive data types consider example recursive data type nlist nil cons nat nlist 
avoid excessive technicalities consider general case recursive types section 
constructor contexts data types involve constructors introduce evaluation order types understand represent evaluation order constructors arguments 
ary constructor describe evaluation order arguments argument eod pi aeod 
include contexts constructor arguments describe constructor type theta 
theta arity application context 

describe way function difference constructor application reaches whnf evaluates constructor arguments get evaluated demand context argument eod form fh 


ig 
non recursive data types non recursive data type define evaluation order type eot tuple ff 
ff application contexts constructor 
shall term context mean eot 
set eot evaluation order types defined follows non recursive types eot nat aeod eot 
ic 


nc non recursive data type possible unfold occurrences recursively eot finite product aeod 
ordering inherited fact usual non recursive encoding constructors higher order functions shows possible constructor contexts construed functions functions consume value see section 

describing evaluation order component lattices aeod set eot complete lattice finite height 
element denoted eot clearly definition eot directly indirectly recursively defined data types lead infinite product 
recursive data types recursive data type nlist nil cons nat nlist somewhat complicated describe evaluation order types 
ways solve problem quite conservative lead notational problems stated full generality 
shall postpone general treatment recursive data types section 
just postulate existence operations 
unfolding ff extracts application context ff folding ff 
ff constructs eot type application contexts ff 
ff focus special case nlist nil cons nat nlist 
key solution identify recursive occurrence nlist top level 
means evaluation order information elements list identified information required uniform list elements 
consequence analysis collect information valid elements list 
bad may structured typed functional programs usually treat elements recursive data types anyway 
general schema non recursive types ignoring recursive structure obtain eot nlist theta nat nlist aeod theta aeod theta aeod aeod describes context nil aeod describes context cons second aeod describes context nat argument cons 
examples usually ignore information nil nat represent aeod 
cases notation nlist cons pi evaluation order type nlist corresponding path set pi pathset cons 
consider intuitive interpretation evaluation order types nlist 
example nlist cons fh ig context induced printer strict head evaluates head tail 
context argument function reverse reverses list nat see section nlist cons fh ig result context nlist cons fh ig similarly nlist cons fh ig tail strict context ignore heads elements list context argument function length 
examples evaluation order types nlist analysis examples section 
chapter 
evaluation order analysis evaluation order analysis point evaluation order analysis find evaluation order information program letrec 
shall represent information application context description function type theta 
theta program eot 
idea maps context application 
application context pi 
consists argument eod path set pi evaluation order type argument expression set program called application context description 
analysis functions computing description functions turn rely defined solution recursive equations involving analysis functions 
combining variable path sets obtain compositional evaluation order analysis need way combine paths subexpressions paths containing expression 
consider expression op subexpressions assume path subexpression say paths 
assume op evaluates whnf reaches whnf 
know strict part part preceding precede strict part precede path strict part known happen reaches whnf assumed happens gets evaluated 
hand know relative order non strict parts come resulting path 
consequently consider interleavings non strict parts assumption op path possible paths formal combination paths path sets preceding discussion sort motivates definition 
definition pi 
ng path set called combiner pi pathset 
pi pi pi 
pi path set pathset called pi combination pi 
pi defined follows pi 
pi pi single path combination 
defined hi 
hi 




evaluation order analysis path interleaving defined section 
noted combination 
strict part guaranteed precede rest 
combination 
non strict part consider interleavings rest 
expression evaluation order example language syntactic construct example language show put path sets subexpressions obtain path set entire construct 
analysis function constructor function application rely combination operation defined variables base function application case define plumbing operations var ran case take care 
reflect informal evaluation rules gave section 
pi denote path set subexpression 
pi denote desired path set ffl variable reach whnf reach whnf possible path set pi var fhx ig 
ffl 
base functions strict evaluate base type arguments left right evaluation whnf complete evaluation 
combined path set simply pi ran pi 
pi pi nf 
pi nf ffl 
em application context context ff form pi 

path set variable path combination pi pi pi 
pi 
ffl 
function description gives application context ff form pi 

path set pi computed variable path combination pi pi 
pi 
ffl case 


nc root expression evaluated whnf branches evaluated 
combination conveniently described variable path combination combiner case 
note function application case combination determined syntactic construct context 
need application context description analysis 
chapter 
evaluation order analysis argument evaluation order consider function definition hy zi path evaluation obtain argument eod extract subpath hx construct index path 
case branch 
procedure index paths 
extraction argument eod path set expression done functions defined functions constructors 
pathset theta var 
pi 
pi 
gg pi 
pi fx 
function computes path variable indices describing order occurrence 
variable path path 
ng hi hi hii evaluation order analysis functions evaluation order analysis function computes evaluation order description variable path set expression type context variables formal parameters functions pattern variables case distinct 
eot eod var 
ran 

em 
em 



case 


nc case 
ff 
ff ff 
ic 
ic ij ij 
ng 

evaluation order analysis rules self explanatory section 
application constructor pertinent application context 
extracted context argument expressions analysed contexts path sets combined combiner 
notation pi pi generality sections denote things path sets 
function application application context 
argument expressions analysed contexts path sets combined combiner find evaluation order case expression analyse context analysing branches analyse branches context entire case expression 
find uniform context combine application contexts ff constructors operation ff 
ff type application contexts computing context ij pattern variable ij recursively finding argument eod constructor 
finding turn requires finding evaluation order right hand side combine evaluation order descriptions 
combiner case context analysis function computes context evaluation order type variable expression context context analysis function defined follows type expression var set variables type eot var eot eot 

em 


case 


nc iy ff 
ff ff 
ic 
ic ij ij 
ng 
chapter 
evaluation order analysis variable occurrence contributes context contributes context eot variable 
case equation similar function explanation 
recall variables distinct confusion possible pattern variables ij case 
doing evaluation order analysis analysis result seek program solution simultaneous equations 



program type theta 
thetat solution exists finite time lattice finite height analysis functions monotonic arguments 
finite height virtue aeod eot lattices finite height program finite 
analyse program letrec 
goal expression type start finding evaluation order type expressing printer order demand values type base type evaluation order type simple demand fh ig 
nlist represented path set pi fh ig cf 
section 
data types expressed similarly reflecting printer evaluates prints data structures preorder left right 
analyse goal expression context find possible contexts applications defined function upper bound contexts represents evaluation order information valid evaluations program 
case eod variable path set pi body computed information pi validly optimize body complexity variable path analysis shall give rough estimates complexity variable path analysis studying size lattice containing function type gives upper bound number iterations needed compute fixed point analysis backwards function maps context evaluation order type function result type application context function 
function result type influence complexity argument types 
facts height number elements pathset section see height argument eod lattice aeod 
examples variable path analysis 
number elements 

number possible argument eod argument function 
precisely height aeod height aeod height aeod height aeod height aeod number elements power height case 
argument eod describing constructors require element path argument eod 
argument constructor number different paths gamma height argument eod lattice 

precisely considering constructor descriptions height aeod height aeod height aeod height aeod height aeod number elements power height case 
specifically height eot nat aeod number elements 
height eot nlist aeod number elements 
function take nlist theta nat nlist lattice functions take eot nlist aeod theta eot nlist nat height large 
worse height lattice functions grows fast complexity result type 

largest constructor arity result type 
sections shall see evaluation order analysis functions defined section support range analyses expensive variable path analysis 
analysis functions parametrized items lattices eod aeod upper bound operation functions var ran case combination operation 
functions extracting argument eod eod 
examples variable path analysis section show results applying variable path analysis small programs 
shall assume function simply strict context 
result analysing function type theta 
thetat shown form pi theta 
theta meaning pi 

write evaluation order types type name path sets constructors subscripted 
function length chapter 
evaluation order analysis nlist nil cons nat nlist length nlist nat length xs case xs nil 
cons ys 
length ys analysis result length fh ig nlist cons fh ig nat argument path set fh ig shows length strict context xs nlist cons fh ig means list elements heads ignored function tail strict 
function sum sum nlist nat sum xs case xs nil 
cons ys 
sum ys analysis result sum fh ig nlist cons fh ig nat sum function strict evaluates head tail head tail strict 
function bool false true nil cons bool bool xs case xs nil 
true cons ys 
case false 
false true 
ys analysis result fh ig cons fh ig bool function strict evaluates head tail natural example function head strict tail strict 
version function take take nlist theta nat nlist take xs case xs nil 
nil cons ys 
case true 
nil false 
cons take ys 
examples variable path analysis analysis results take fh ig nlist cons fh ig theta nat nlist cons fh ig take fh ig nlist cons fh ig theta nat nlist cons fh ig take strict xs evaluates xs independent context 
head tail strict context version take head tail strict xs 
nlist cons fh ig context xs nlist cons fh ig context nlist cons fh ig context xs context nlist cons fh ig version function take take nlist theta nat nlist take xs case true 
nil false 
case xs nil 
nil cons ys 
cons take ys analysis results take fh ig nlist cons fh ig theta nat nlist cons fh ig take fh ig nlist cons fh ig theta nat nlist cons fh ig version take strict evaluates xs independently context 
previous version tail strict xs tail strict context head strict head strict context 
propagates order evaluation context argument previous version 
reverse function accumulating parameter reverse nlist theta nlist nlist reverse xs zs case xs nil 
zs cons ys 
reverse ys cons zs analysis results reverse fh ig nlist cons fh ig theta nlist cons fh ig nlist cons fh ig reverse fh ig nlist cons fh ig cons fh ig nlist cons fh ig reverse fh ig nlist cons fh ig theta nlist cons fh ig nlist cons fh ig reverse fh ig nlist cons fh ig theta nlist cons fh ig nlist cons fh ig chapter 
evaluation order analysis context demands whnf line reverse strict xs evaluates zs tail strict xs ignores heads xs zs 
context head strict second line reverse tail strict xs evaluates tail head xs zs head strict 
head tail strict context lines reverse strict xs zs xs head tail strict context evaluates tail head matter context reverse evaluates head tail 
intuitively reverse needs traverse spine xs constructor reversed list returned 
zs evaluated order result application 
argument eod fh ig says reverse strict xs zs sure zs evaluated reverse returns whnf 
function append append nlist theta nlist nlist append xs zs case xs nil 
zs cons ys 
cons append ys zs analysis results append fh ig nlist cons fh ig theta nlist cons fh ig nlist cons fh ig append fh ig nlist cons fh ig theta nlist cons fh ig nlist cons fh ig append fh ig nlist cons fh ig cons fh ig nlist cons fh ig append fh ig nlist cons fh ig cons fh ig nlist cons fh ig lines show context append xs zs transmitted arguments 
line say elements sublist evaluated evaluation element second sublist begins 
illustrates information evaluation order substructures different data structures thrown away concept evaluation order type 
function concat nlist nil cons nat nlist nlist concat 
nlist concat xss case xss 
nil ys 
append ys concat analysis results concat fh ig cons fh ig fh ig nlist cons fh ig concat fh ig cons fh ig fh ig nlist cons fh ig 
applications optimization suspensions note list lists evaluated head tail regardless order result traversed 
applications optimization suspensions bloss describes evaluation order analysis bloss hudak path analysis optimizing suspensions lazy language sec 

summarize bloss description 
variable symbols range occurrences function description described section easy find order different occurrences variable accessed 
expression define expression identical occurrence free variable replaced unique free variable compute pi occ find variable occurrence paths context table describes possibilities status variable occurrence possibilities spanned possibilities variable past definitely evaluated definitely evaluated don know possibilities definitely possibly 
cases allow improve default code variable access evaluation order analysis may allow identify cases 
default code variable access status evaluated 
return value evaluate overwrite return value set pi occ paths variable occurrences expression consider variable occurrence path pi occ occurs split part part pi denote set paths pi denote set paths 
path pi contains definitely evaluated conversely path pi contains definitely evaluated similarly path pi contains definitely table shows exploit information 
optimization code occurrence evaluated evaluated possibly evaluated status check evaluation overwrite status check overwrite overwrite possibly status check evaluation overwrite status check optimization possible chapter 
evaluation order analysis method allows obtain useful analysis lazy data structures involved 
previous analyses bloss hudak deal data structures sufficiently powerful obtain useful results simple cases function cons assume evaluate expression sum take version take previous section 
context nlist cons fh ig find previously evaluated occurrence previously evaluated second 
occurrence safe evaluate suspension immediately overwrite result 
second occurrence necessary evaluate overwrite value 
notice strict evaluated prior entry 
analysis possible bloss hudak methods order evaluation body depends context call appears 
occurrence path analysis described detail variable path analysis finds set variable paths possibly containing expression context 
similar analyses built framework evaluation order analyses occurrence paths evaluation order relations backwards strictness analysis strictness sets 
obtain new analysis framework redefine items analysis functions defined 
ffl finite lattice eod evaluation order descriptions expression pathset vars 
ffl finite lattice aeod describing evaluation order points 
basis defining application contexts evaluation order types 

ng 
ffl combination operation 
lattices 
variable path combination 
ffl plumbing functions var ran case analysis function describe evaluation order variables base function applications case 
ffl functions eod theta var aeod extract argument eod variables expression eod constant part frame framework consists recursive definition analysis functions way application contexts ff 
uniform evaluation order types eot built elements aeod 

occurrence path analysis section define occurrence path analysis refinement variable path analysis intended serve bridge analysis evaluation order relations 
analysis turn interesting cheaper variable path analysis 
occurrence paths operations occurrence expression finite sequence indexes natural numbers 
occurrence labels subexpression denote 
empty occurrence labels entire expression occurrence 
labels subexpression formally define op 

define 
denotes syntactical identity 
examples formal integers labels sequences integers 
integer mean sequence length 
letting occ denote set occurrences occ op 
occ set occurrences occurrence path element path occurrence path set pi element pathset 
interpreting occurrences events occ means precisely variable paths entire expression reaches whnf 
event occ means subexpression reaches whnf relates variable path analysis variable occurrence 
combining occurrence paths concepts variable path sets 
combination occurrence paths subexpressions occurrence paths expression op 
basically operation 
occurrences constituent path prefixed index occurrences relative containing expression definition pi 
ng path set called combiner pi pathset occurrence path sets 
pi pi pi 
pi occurrence path set called pi combination pi 
pi defined follows pi 
pi pi basic occurrence path combination 
defined hi 
hi 



occurrence prefixing distributes elements path hp 
hi 
path interleaving defined section 
chapter 
evaluation order analysis occurrence paths evaluation order description expression eod pathset occ set argument eod aeod 
ng 
evaluation variable gives singleton path consisting occurrence var fh ig 
evaluation base function application described occurrence path combination ran fh 
ig evaluation case expression case fh 
ig 
extracting argument eod 
occurrence path set pi expression done follows pathset theta var 
pi 
pi pi 
pi 
function computes path variable indices describing order 
occurrence path path 
ng hi hi hii necessary refer expression path computed test occurrence variable occurrence 
note rely path concatenation operation delete occurrence index result 
relation variable path analysis occurrence path analysis interesting records order evaluation individual variable occurrences evaluation variable 
main role occurrence path analysis serve bridge analysis variable paths analysis evaluation order relations section 
shall formalize connection analyses point variable path analysis intuitively plausible concepts precedents literature 
variable path analysis hopefully prepared reader traditional sense fundamental occurrence path analysis 
occurrence path analysis turn offers explanation variable path analysis 
importantly allows view evaluation order relations assertions occurrence path set expression providing model evaluation order relations 
expression occurrence path consider path elements variable 
evaluation order relations path occ path vars hi hi hxi small notational problem arises expression consisting variable occurrence 
occurrence path hx hx desired 
general variable path corresponding occurrence path annoying paths computed contain cases particular duplication free concatenation effect cases 
evaluation order relations analysis framework fact inhabit evaluation order relations interesting expensive precise previous analyses 
evaluation order relation eor set occurrences pair reflexive relations set eor evaluation order relations eor identity relation order set eor eor componentwise reverse set inclusion ordering eor lattice 
easy see height gamma gamma short jdj number elements number elements eor greater upper bound te componentwise relation intersection greatest lower bound ue componentwise relation union 
element lattice complete relation occurrences related greatest element relates expression 
shall write relation relation relation called strongly precedes called weakly precedes 
naturally inverse relations gamma gamma written reversed arrows 
clear context leave superscript arrows 
lattice evaluation order relations element set shown arrow notation 
chapter 
evaluation order analysis ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae lattice point evaluation order relations evaluation order subexpression occurrences 
assertion means evaluated evaluated means 
correspondingly means strictly 
assertion means evaluated evaluated words evaluated special cases particularly interesting 
converse subexpressions evaluated 
addition evaluated 
distinct evaluated 
example consider program copy superscripted expressions labels 
copy xs case xs nil 
nil cons ys 
cons copy ys express root expression labelled evaluated branches write 
express reach whnf entire case expression write 
branches mutually exclusive expressed 
evaluation order relations 
note knowing context application copy xs copy unable relate say 
combining evaluation order relations evaluation order relation composite expression op 
expressible combination evaluation order relations 
components 
way 
combined course depends kind expression base function application constructor application defined function application general mechanism 
definition 
ng evaluation order relation called combiner eor evaluation order relations 

evaluation order relation eor 
called eor combination 
defined follows include ensure eor 
evaluation order relations take evaluation order descriptions expression eor occurrences eod eor occ argument evaluation order relations eor 
ng aeod 
ng 
constructors shall essentially leave form argument eod 
combination defined 
plumbing functions evaluation order analysis follows function var analysing variable occurrence var function ran computing evaluation order relation base function application conveniently expressed combination evaluation order relations ran fi 
ng fi ng chapter 
evaluation order analysis function case computing evaluation order relation case expression expressed combination evaluation order relations case 
ng need define functions extracting argument eod expression variables 
functions looking order evaluation variable occurrences notational device needed quantifying occurrences 
range occurrences object associated precisely entire expression associated qua occurrence possible value variable associated ranges occurrences expression variables 
evaluation order relation 
want obtain 

labels entire expression labels variable describe analysis defining terms relation occurrences definition argument eor 
aeod defined follows iff iff intuitively object associated evaluated associated occurrence occurrence evaluated 
object associated evaluated associated occurrence occurrences evaluated evaluated 
special cases worth noting 
variable occur 

furthermore variable occur variable definition argument eor 
aeod defined restriction 
non occurrences 
relation occurrence paths evaluation order relation taken denote set occurrence paths 
conversely set occurrence paths approximated evaluation order relation 
concretization function fl evaluation order relations sets paths definable follows fl eor pathset fl fh 
ig fh 
ig fh 
ig fl fh 
ig fh 
ig fh 
ig fh 
ig distinct 
denotes path fragments fi jg 
fl fl fl 
evaluation order relations greatest lower bound ue eor greatest lower bound pathset fl morphism definition strict maps monotonic approximate inverse abstraction function ff mapping path sets best approximating evaluation order relations 
abstraction function ff definable follows result follow cf 

ff pathset eor ff pi ue eor pi fl definition ff monotonic easy check fl ff pi pi pi pathset ff fl eor abstracting path set gives bigger path set information 
evaluation order relation abstracting expect obtain 
fl injective case 
easy see fl ff fl fl result safe 
words ff fl form galois connection galois insertion 
see fl injective consider evaluation order relations 
mapped singleton path set fl fl indicate lattice evaluation order relations irrelevant elements perfect abstraction pathset 
see evaluation order relations efficient precise way computing information computed backwards path analysis 
notice done retaining framework notion evaluation order types analysis functions way combining evaluation order information subexpressions evaluation order information containing expression exemplify loss expressiveness concretization function fl maps evaluation order relations prefix closed sets paths 
means information evaluated definitely evaluated expressed evaluation order relations 
expressed path sets 
complexity evaluation order relations complexity analysis evaluation order relations lower variable path analysis 
height lattice aeod worse 
variable path analysis 
specifically aeod height element aeod height elements aeod height 
eot nat aeod height element lattice eot nlist aeod theta aeod theta aeod isomorphic aeod 
ignore chapter 
evaluation order analysis element constructor argument descriptions eot nlist isomorphic lattice shown 
follows eot nlist height elements lattice function descriptions take height evaluation order relations compared variable path sets 
importantly height function domain grows largest constructor arity result type compared 
variable path analysis 
backwards strictness analysis analysis defined framework backwards strictness analysis data structures 
variable path sets evaluation order relations works sets variables 
strictness set dnf set variables needed expression context 
variable needed whnf expression produce value required context 
strictness sets contain assume whnf expression consideration needed 
result analysing expression context means variable needed expression context 
set variables domain strictness sets strict superset ordering strict lattice height elements jdj number elements informative element greatest informative element fg 
upper bound greatest lower bound 
combining strictness sets combination strictness sets analogous combination variable path sets defined follows 
definition 
ng strictness set called combiner strict strictness sets 

strictness set strict called combination 
defined follows combination union strictness sets needed combiner 
backwards strictness analysis backwards strictness analysis put eod strict vars vars set variables occurring aeod 
ng 
set variables needed find whnf variable fxg var var fxg set needed variables base function application union sets variables needed subexpressions ran ran 

corresponds precisely letting ran combiner 
ng 
set variables needed find whnf case expression set needed evaluate root expression variables needed branch case case case 

expressed combination strictness sets strictness sets express disjunctive properties branch branch evaluated 
best approximation case lose information variables needed branch 
argument eod extraction functions simply find set indices strict variables 
distinguish argument eod constructors functions defined follows 
relation variable path analysis vars set non epsilon elements path connection variable path sets strictness sets 
variable needed variable path occurs path vars 
note matter variable appears path 
variable needed path set pi occurs paths set vars pi define concretization function fl maps strictness set set paths containing variables fl strict pathset fl path vars fl fl fl fl fl ue fl fl morphism 
fl 
fl fg pathset fl corresponding best abstraction function ff definable follows 
chapter 
evaluation order analysis ff pathset strict ff pi strict pi fl strict path vars pig strict pi vars pi vars vars pi strictness set ff pi corresponding path set pi set variables occur path pi 
examples backwards strictness analysis consider strictness evaluation order types nlist 
argued correspond strictness sets descriptions cons 
head strict context described context induced printer 
tail strict context described head tail strict context 
strictness sets defined describe disjunctive information context evaluate head tail necessarily 
strictness powersets defined section handle disjunctive information 
refer example programs listed section 
function length length nlist cons nat argument strictness set shows length strict context nlist cons xs means function tail strict 
function sum sum nlist cons nat sum function strict xs head tail strict 
function cons bool function strict natural example function head strict tail strict 
version function take take nlist cons fg theta nat nlist cons head tail strict context take strict xs context xs head tail strict 

backwards strictness analysis version function take take nlist cons theta nat nlist cons take nlist cons theta nat nlist cons version take strict xs 
previous version tail strict xs tail strict context head strict head strict context 
reverse function accumulating parameter reverse nlist cons theta nlist cons fg nlist cons fg reverse nlist cons theta nlist cons nlist cons reverse nlist cons theta nlist cons nlist cons reverse nlist cons theta nlist cons nlist cons simply strict context line reverse strict xs xs tail strict context 
holds contexts 
head strict context second line zs head strict context 
tail strict context third line zs strict tail strict context 
head tail strict context xs zs strict head tail strict context 
function append append nlist cons theta nlist cons nlist cons append nlist cons theta nlist cons nlist cons append nlist cons theta nlist cons nlist cons head strict context append strict argument second head strict arguments 
tail strict context append strict arguments tail strict arguments 
head tail strict context arguments append strict head tail strict context 
function concat concat cons nlist cons cons nlist cons cons nlist cons strict context concat strict 
head strict context head strict levels lists cons 
tail strict context head tail strict list lists tail strict sublists cons 
head tail strict context head tail strict levels lists 
chapter 
evaluation order analysis complexity backwards strictness analysis lattice eot nat aeod height element 
lattice eot nlist isomorphic aeod height elements 
function arguments type nlist rest base type application context domain range function height 
function take height lattice function descriptions reasonable 
concat height evaluation order type lattice result domain nlist elements lattice argument domain height 
consider kind strictness analysis tractable size context domains grows rapidly result types get complex 
height function largest constructor arity result type 
operations necessary represent manipulate values strictness sets uniform evaluation order types constructed straightforward implement quite fast 
precise backwards strictness analysis precise backwards strictness analysis lazy data structures obtained strictness powersets sets strictness sets 
way kind relational backwards strictness analysis obtained 
lattice inclusion ordering vr upper bound greatest lower bound informative element fg greatest informative element height size jdj number elements combination defined strictness sets 

ng obtain 
follows sa obtain analysis general framework put eod vars aeod 
ng 
combiner var var 
combiner ary base functions ran ff 

contrast simpler strictness analysis possible express strictness case expression combiner case ff 

analysis related variable path analysis 
concretization function fl maps strictness powerset set paths variable set belongs fl pathset fl path vars 
recursive data types revisited hard see morphism fl maps abstraction function ff defined follows ff pathset ff pi ur piv fl piv path vars sg pi vars fvars pig vars pig abstraction path set pi set sets variables occurring path 
fl clearly injective ff fl fl ff pi pi 
costly variable path analysis analysis expensive shall consider detail 
recursive data types revisited section discussed uniform evaluation order types recursive data types simple example nlist nil cons nat nlist 
section study evaluation order types general recursive data types give general versions analysis functions procedure devise works analyses far 
briefly stated task find data type lattice eot evaluation order types finite height 
uniform evaluation order types reasonable ways identify recursive occurrences type constructor structurally previous occurrences type constructor 
general adapt definition eot 
add argument set type names seen recursive definition meeting type seen replace eot point phi pronounced blank 
redefine eot follows 
aeod theta eot eot nat aeod eot phi eot ftg 
ic 


nc call eot fg uniform evaluation order type data type call ff fg 
uniform application context types 
easy see modified definitions eot fg nlist aeod theta aeod theta aeod theta phig isomorphic aeod theta aeod theta aeod section 
chapter 
evaluation order analysis data type 


nc uniform evaluation order type eot fg tuple ff 
ff application contexts constructor application context ff 
ic consists argument evaluation order description constructor ij eot ftg ij argument 
note ij general uniform evaluation order type type ij argument informative 
fact ij ij element phi 
unfolding folding section postulated operations ff 
ff analysis equations constructor application destructor case 
section defines operations 
give informal explanation technical details needed formal explanation 
analysis constructor application 
em evaluation order type need unfolding application context 
constructor application argument eod describing order evaluation 
em evaluation order type analyse construction data type value extract uniform application context uniform evaluation order type 
implies unfolding appearing inside application context 
conversely analyse case expression data type value construct uniform evaluation order type root expression case uniform application contexts ff case branches 
call folding ff 
ff application contexts ff 
ff respect type think uniform eot type form ff 
ff simply define unfolding ff general throw away information ff 
im fg 
im ft 
im ij uniform evaluation order type ij subtrees ff corresponding phi 
need expand ff occurrences inside ff similarly think folding ff 
ff defined simply tuple ff 
ff result uniform evaluation order type constructors belonging type may different argument evaluation order descriptions associated various occurrences inside ff result uniform evaluation order type safe approximation upper bound 
unfortunately formal definition unfolding folding requires number technical exciting definitions 
reader probably best advised skip remainder section 

recursive data types revisited normalizing evaluation order types define generalization uniform evaluation order types uniform application contexts called tree ff tree 
definition tree ffl node labelled base type ffl node labelled outgoing labelled edges edge labelled ends ff tree 
ic data type 


nc ffl node labelled phi blank 
ff tree 
ffl ff node labelled argument eod aeod outgoing labelled edges edge labelled ends tree clearly trees generalize uniform evaluation order types ff trees generalize uniform application contexts 
uniform evaluation order type path node label type name appearing twice 
shall define normalization operations nr nr ff reduce trees ff large obtain uniform application contexts 
done cutting branches trees 
definition assume tree contains uniform eot subtree root 
reduction nr fg nr defined 
nr base type phi nr ff ftg 
ic ff 


nc ff 
ff nr ff 
ff nr ff 
hard see contains uniform eot subtree root nr element eot 
particular fg nr fg uniform eot similarly nr ff corresponding reducing normalization operations nr nr ff define normalization operations ne ne ff expand trees ff small obtain uniform application contexts 
done growing new branches containing argument eod aeod necessary obtain uniform eot 
chapter 
evaluation order analysis definition assume tree subtree root uniform eot expansion ne fg ne defined 
ne base type phi ne ff ftg 
ic phi 
aeod phi 
phi ne ff ftg 
ic ff phi 


nc ff 
ff ne ff 
ff ne ff 
subtree root uniform eot ne element eot particular fg ne fg uniform eot similarly ne ff subtrees substitution need function replacing empty subtree corresponding tree definition data type uniform eot substitution tree base type ff 
ic ff ff 
ff 


nc ff 
ff ff 
note tree uniform eot subtree root 
need function find set subtrees ff trees correspond give evaluation order information data type definition data type 
set expanded subtrees tree corresponding type set uniform evaluation order types st fg base type ne fg st ff 
ic ff ff 
ff 


nc st ff 
ff st ff 

recursive data types revisited note elements st uniform formal definitions unfolding folding machinery introduced definitions 
definition unfolding uniform evaluation order type type constructor nr ff fg 
ic ff 
ic ff ff 
ff 


nc intuitively speaking substitute occurrence ff reduce result nr ff clear result uniform application context 
ic definition data type 


nc ff 
ff uniform application contexts ff fg 
ic 
folding ff 
ff defined ff 
ff nr fg st ff 
ic ff ff 
ff upper bound eot fg 
intuitively speaking construct tree application contexts ff find occurrences ff st ff reduce normalize find upper bound evaluation order types 
see definitions apply restricted case nlist 
recall uniform eot nlist form ff ff ff application context nil ff phi application context cons aeod aeod eot nat 
example specified 
unfolding nil nil nil nr ff fg ff nlist ff nr ff fg expected 
unfolding cons cons cons nr ff fg nat nlist ff nat nlist nlist ff nr ff fg nat nlist nat nlist nlist nlist phi nr ff fg nat nlist nr fg nat nr fg nlist nr ff ff nr ff nat nlist ff phi chapter 
evaluation order analysis expected second argument cons context cons application 
example consider folding nlist 
ff ff application contexts branches nil 
cons 
case nlist 
contexts eot fg nat phi eot fg nlist definition nlist ff ff nr fg nlist ff ff st ff nlist ff st ff nat nlist nlist ff nr fg nlist ff ff nr ff ff nr ff nat nlist ff nr nat nr nlist phi st ff nlist ff fg st ff nat nlist nlist ff st nat nlist st nlist nlist fg ne fg nlist nlist ff ff phi phi 
expected argument eod nil upper bound argument eod argument eod extracted context similarly argument eod cons 
context nat argument cons upper bound context context extracted context clear computations general treatment overkill nlist example 
recursively defined types slightly complicated recursion pattern generality needed 
consider instance contrived example nat unfolding substitution ff reduction nr ff necessary 
folding ff ff reduction nr locating expanding subtrees corresponding st ff ne necessary 
example exercises machinery introduced 

related related path analysis bloss hudak served inspiration 
bloss hudak forwards analysis gives precise information backwards analysis atomic data expensive 
contrast analysis analysis works higher order languages restricted atomic data clear kind extensions needed analysis lazy data structures 
may ask achieved simply encoding data structures higher order functions applying bloss hudak higher order analysis avoiding new theory 
answers may section 
complexity higher order path analysis depth types expressions analysed encoding data structures functions give complex types 
secondly may type reasons higher order path analysis applied recursive functions involving data structures encoded functions 
automatic evaluation order analysis know 
restricted order languages lazy data structures analysis accommodate evaluation strategies pure laziness 
particular strictness information move evaluation arguments earlier 
original motivation study stems desire generalize technique globalization function parameters lazy languages similar update analysis 
clear results obtained useful connection 
framework obtained chapter seen special instance general backwards analysis theory hughes 
backwards strictness analysis general data structures interpretation continuations done hughes 
account projections wadler hughes 
chapter globalization partial applications chapter describes analysis detect function parameter replaced global variable transformation called globalization replacement 
analysis works untyped strict higher order functional language extends previous schmidt sestoft fradet variables captured closures may 
chapter slightly edited version published presents joint carsten gomard 
text appear forthcoming ph thesis 
chapter strict example language sequentialized variant operational semantics section 
discuss subject proper liveness global liveness section interference section variable groups section globalization section correctness section 
describe experiments related give 
straightforward implementations strict functional languages may quite slow consume storage 
inefficiency problem essentially global data structures passed parameters functions causing copying data structures pointers 
interesting problem detect automatically essentially global parameters functional programs replace global variables assigned values imperative manner 
particularly useful attempts derive language implementations directly denotational functional specifications 
recognize parameters representing run time store functional specification say pascal allow natural efficient pascal implementation derived specification 

previous precisely goal schmidt 
called desirable property single threading showed single threading criteria formulated elegantly conditions types assigned sub expressions language specification 
different approach replacing function parameters global variables taken sestoft called process globalization 
conditions formulated terms definition paths kind traces evaluation program making dependency order evaluation explicit 
method worked untyped programs able detect potential global variables schmidt 
price extra power complicated algorithms 
schmidt assumptions evaluation order strictness sestoft imposed fixed evaluation order 
fradet formulated single threading criteria syntactic conditions typed expressions transformed continuation passing style 
fradet imposed fixed evaluation order 
mentioned techniques unable detect variables captured closure partial function application 
solve problem propose new method chapter 
method suitably extended concept live variable observation non live instances overwritten adverse effect computation 
creation new instance live instance instance allocated globally 
creating new instance overwrite global instance affecting computation 
understand concept instance assume function application extends closure initially possibly empty value value value parameter function evaluates 
say evaluation application results creation new instance holds value addition single variables able find groups variables allocated global variable 
example group set variables holding store value functional interpreter specification imperative language 
need know live instances new instance created variables live instances point 
creation new instance variable instance variable live called interference evidently prevents replaced global variable 
piece information represented interference pair 
concept interference condition globalization stated follows variable interferes allocated global variable 
chapter 
globalization partial applications extension condition groups variables set variables interfere allocated global variable 
give interference analysis finds set interference pairs program call value evaluation left right evaluation function arguments algorithm groups variables information interference analysis 
example consider program map null 
cons car map cdr add goal append map add map add algorithms find function parameters may replaced global variables variables may grouped replaced global variable 
finds variable add may captured closure 
previous analyses particular schmidt sestoft fradet mentioned discovered fact 
started attempt extend sestoft previous method definition paths path semantics instrumented operational semantics 
failed find simple way turned special syntax making evaluation order explicit expression 
respect resembles fradet uses continuation expressions sequencing called sequentialized expressions explained 
sestoft earlier method fradet method uses closure analysis handle higher order functions achieves better precision fradet 
strict language language analyse higher order functional language call value evaluation left right evaluation subexpressions 
call language historical reasons 
program list recursive function definitions local function definitions goal expression functional program brought form lambda lifting letrec 
arity 

arity called defined functions called function bodies arity arity arity arity non zero functions input program free variables goal expression 
strict language source expressions body expressions form function parameter defined function conditional 
basic function application constants treated base functions 
operational semantics secd machine operational semantics language simple translation code secd machine 
believe reasonable choice machine landin invented formalize mechanical evaluation call value lambda calculus 
possibility categorical machine 
give details variant secd machine describe meaning instructions state transition rules 
kinds values handled semantics 
kind base value atomic value true 
second kind value closure partial application 
closure defined function symbol values val parameters 
arity 
closure kind functional value third kind value data structure value form constructor arity values 
formally fun defined functions base values val clo struc clo fun val arity struc val arity param function parameters tvar temporary variables var param tvar state oe state code theta stack theta env theta dump machine components code control stack val stack env param val environment dump code dump piece code sequence instructions 
instructions variant machine listed 
chapter 
globalization partial applications ret var bas vm vm fun true false app arity app arity code body defined function empty stack 
basic secd machine rules code ins ins ret return halt var function parameter bas basic function fun defined function code code conditional app application evaluation rules basic secd machine shown 
scheme compilation source expressions secd instructions natural var fun 

bas app operator appends sequences instructions appends code sequences equals 
give ordinary linear machine code labels jumps immaterial purposes 
code generated defined function ret body sequentialized expressions order evaluation subexpressions explicit expression level shall alternative syntax called sequentialized expressions 
simplifies liveness interference analyses 
sequentialized expressions form sexp sexp texp sequential expression sexp sexp sexp sexp texp trivial expression 

strict language note restrictions applications subexpressions bound variables sexp subexpressions may occur evaluated wholly alternatives 
variables fresh distinct ordinary variables sequentialized form kind functional address code serves purposes classical address code liveness order evaluation explicit 
potential application form source level register allocation 
sequentialization translation scheme source expressions sequentialized expressions straightforward quite obvious sequentialization preserves meaning order evaluation subexpressions 



scheme compiling sequentialized expressions secd machine code trivial particular way sequential expressions generated var fun 
bas app terms operational semantics bound variables sequentialized expressions correspond positions evaluation stack effect evaluating binding expression push value easy prove exactly secd machine code generated sequentialized expression source expression ffi ensures liveness interference analysis done sequentialized expressions analysis results may original expressions 
chapter 
globalization partial applications closure analysis language method doing liveness interference analysis program requires preceding closure analysis phase 
strict language chapter different syntax semantics lazy language analysed closure analysis chapter 
essential difference closure analysis strict language closure analysis non strict results describe possible data flow order evaluation definedness expressions 
shall define just assume closure analysis ca closure analysis concrete closure represented closure arity shall symbol ca set closures require concrete closure may part possible value corresponding closure ca 
ca expr 
ca val possible value fun value val possible value evaluation evaluates operational semantics language 
loosely speaking closure corresponds closure 

analysis closure corresponds lambda label 
note data structures closure analysis quite different data structure encoded lambda expression closure analysis expression evaluates data structure just return label lambda representing topmost constructor 
closure analysis interested functions possibly held inside data structure 
closure analysis data structures described detail proved correct sect 

live variables globally live variables variable locally live program point scope function body temporally possible intervening definition variable 
definition dependent notion time operational aspects order evaluation subexpressions 
example body locally live evaluation variables live just evaluation live just evaluation variable locally live evaluation expression 

live variables globally live variables concepts defined approximate 
concern classes computations individual computations ordinary values 
say variable live expression possible particular computation may 
program point expression point instruction stream compiled expression 
terms compiled code function parameter locally live program point instruction var occurs code point 
sequentialized expressions definition local liveness take bound temporary variables account 
variables correspond stack positions mentioned compiled code 
shall variables precisely apparent expression level temporary results exist computation stack bound live variables 
example program subexpressions superscripted label 
expressions evaluated order 
see value pushed evaluation stack time popped time cons 
example sequentialized form program cons obvious locally live temporary value bound exists evaluation stack definition 
note closure ceases live corresponding popping time mentioned 
ordinary local liveness function parameters backwards concept liveness temporary results kind forwards concept 
consider sequentialized programs way turn forwards liveness temporary results stack ordinary backwards liveness temporary variables 
advantage analysis simpler express 
chapter 
globalization partial applications non local liveness section show kinds non local liveness indirect liveness global liveness 
sequentialized program shown example closure constructed held locally live variable right hand side evaluated 
parameter appear body locally live evaluation instance exists closure stack shall say indirectly live instance closure possible full application operationally value computation stack computed 
turn holds value indirectly live evaluated 
example consider program 
locally live body just call full application 
evaluating body non local variable live body appear 
shall say globally live 
global liveness discussed section 
operationally variable occurs code dump evaluating body 
globally live evaluating body 
indirect liveness capture variables say value may capture set variables instance closure define variable locally indirectly live program point may captured value locally live variable 
base atomic value captures variables 
closure value captures parameters parameters captured values data structure value captures union sets captured component values capture extends linearly sets values set parameters captured set values union captured sets 
exact capture analysis cap computes set parameters captured set values 
ignores temporary variables interesting outside function definitions occur 
cap val 
param cap fbg fg cap ff cap fv mg cap fc cap fv mg cap cap cap 
live variables globally live variables terms operational semantics variable locally indirectly live program point possible machine state corresponds point captured value locally live variable captured value evaluation stack case corresponds bound variable locally live captured value 
liveness interference analyses need approximate capture analysis 
function defined closure analysis section 
param fg fg ca 
ca approximate liveness analysis need find variables may indirectly live due certain variable locally live 
called capture closure variable 
capture closure ccl function parameter set variables captured set values may take computation 
capture closure temporary variable include interested global liveness bound variables 
ccl var 
param ccl fxg fxg ca ccl ftg ca ccl ccl ccl note capture exact concept capture closure ccl approximate talk possible values variable possible executions program defined terms approximate closure analysis 
global liveness define variable globally live program point body function 
locally possibly indirectly live point 
globally live application full application evaluate closure 
arity gamma computation globally live 
idea variable globally live may dynamically surrounding computation necessarily lexically enclosing expression 
means may globally live completely different function parameter 
chapter 
globalization partial applications explained terms operational semantics variable globally live program point locally indirectly live point possible machine state program point globally live 
example example gave example global liveness 
consider example 
parameter globally live body indirectly locally live just call body 
rest chapter take live mean globally possibly indirectly live 
recall includes locally possibly indirectly live variables 
computing liveness information function compute avoid set set variables may live function body evaluated 
example avoid sets follows fg fg fzg 
liveness analysis function computing set 
suppose ffi ffi ffi set variables live evaluation ffi set variables live evaluation result component contribution avoid sets functions program 
interesting rule definition application 
component result set variables live application evidently set ffi live plus second component result contribution avoid sets 
contribution functions full application expression 
functions may evaluate arity gamma values set approximated closure analysis set functions arity possible closure value functions contribution avoid set set variables live application capture closure ccl ffi ffi 
full applications contribute avoid set contribution avoid sets called functions set variables live application 
safe approximation set globally live variables point function computing avoid set function adding locally possibly indirectly live variables 
interference interference analysis interference phenomenon defining variable adversely affect variable allocated global variable 
say interferes 
interference interference analysis expr sequentialized expressions section ffi varset var set live variables fun 
param avoid set map 
fg avoid set map ca expr 
closure analysis section ccl varset 
capture closure section expr varset 
varset theta ffi fx ffi ffi ffi ffi ftg ffi ffi ffi ffi ffi ffi 
ffi ft 
ffi ffi ffi ffi ffi ffi ffi ffi ffi ft 
ccl ffi arity gamma ca desired result liveness analysis pointwise inclusion solution snd function globally live variables defined new instance created globally live 
particular variable defined globally live interferes 
interference pairs interference analysis program done collecting information variables live variables defined 
piece information called interference pair may unconditional form conditional form 
form represents defined live called unconditional interference 
second form special case defined copying variable live called conditional interference 
terminology sestoft 
consider application 
bound value parameter chapter 
globalization partial applications belongs ca conditional interference write live application 
conditional interference pair called harmless condition allocated global variable 
see assume variables allocated 
interference pair says defined copying live 
matter value virtue allocated value changed overwriting conditional interference pair harmless case 
assume variables allocated 
interference pair says defined copying live 
value allocated global variable value updating possibly change value conditional interference pair harmless case 
conditional interference pairs harmless matter variables grouped 
conditional interference pairs particularly useful wants allocate function parameters global variable 
discussed section 
computing interference information interference analysis function computing interference pairs program shown 
slightly simplified analysis function presumes cases interference unconditional 
conservative assumes cases interference harmless 
analysis take conditional interference account collect conditional interference pair rule application bound variable unconditional interference pair 
mechanics shown 
interesting rule application 
unconditional interference pair collected variable new instance may created application variable live new instance created 
set parameters new instance created approximated set variables possible value set possible values approximated closure analysis ca 
set parameters live creation approximated set live capture closure union live application ffi variables 
variable groups expr sequentialized expressions section ffi varset var set live variables fun 
param avoid set map ca expr 
closure analysis section ccl varset 
capture closure section inter param interference pairs expr varset 
varset theta expr varset 
inter ffi fg ffi fg ffi ffi ffi 
ffi fg ffi ffi ffi ffi ffi ffi live ca live ccl ffi ft analysis result seek 
computed analysis total number defined functions 
unconditional interference variable groups variable group fl set variables allocated global variable interference variables fl 
variable grouping gamma set disjoint variable groups 
set variables grouped variables set interfere 
conditional unconditional interference shapes possible variable groups 
proposition fl set variables 
interference pair fl 

conditional interference pair fl fl 
variables fl global variable 
chapter 
globalization partial applications proof point variable fl live variable fl defined assignment potentially disturb value really defined copy fl value fl 
disturbed 
variable singleton fxg possible variable group 
larger variable groups better 
unfortunately easy find program possible variable groupings gamma ffx yg gamma fy gamma ffx possible 
set possible variable groupings program form lattice ordering inclusion variable groups 
means program necessarily best variable grouping may distinct maximal ones 
simple heuristic possible groupings gamma gamma better copying variables belonging group fl 
justification copying disappear variables fl replaced global variable 
heuristic take actual run time frequencies account number occurrences program 
algorithm choose grouping consider set variables fx 
construct trivial grouping gamma ffx 
fx gg 
possible gamma gamma nffl fl ffl fl fl fl chosen 
gamma nffl fl ffl fl variable grouping 

exist groups fl fl gamma satisfying property 
copying variables groups fl fl algorithm works practice able group store variables small interpreter 
globalization interference analysis information find variable grouping gamma turn globalization transformation 
globalization program transformed replace uses variable group fl uses new global variable fl creation new instance replaced assignment new global fl formalize secd machine extended global store new instruction glo fl access global store function application instruction app modified update global store described section 
transforming uses parameters assume variable belongs variable group fl gamma 
globalization means loading value environment load value fl global store effected secd machine code replacing instructions var glo fl 

correctness globalization glo fl fl app arity app arity fl vm fl gamma 
fl code body defined function empty stack 
store handling secd machine rules transforming definitions parameters assume variable fl gamma 
usually new instance created application evaluates closure 
creation new instance replaced assignment global variable fl instruction app modified shown section update application partial full 
note modification app instruction dependent variable grouping gamma computed 
small additional element interpretation introduced 
addition testing closure stack top fully applied app instruction check variable instance created 
find global variable fl update 
alternatively may require functions may evaluate argument global variable argument 
allow specialized application instruction assignment give opportunity globalization 
modifying secd machine modified rules handling variables secd machine shown 
changes global store param val added state machine 
secondly new instruction glo fl introduced refer variables 
rules app changed additional effect global store variable new instance created 
version machine app extend closure environment value 
superfluous purposes running transformed program helpful proving correctness globalization 
correctness globalization show liveness analysis correct respect precise notion live liveness state secd machine section 
second show live time new instance created evaluation globalization correct section 
third know interfere interference analysis live liveness analysis time new instance chapter 
globalization partial applications may created evaluation 
combining previous observations know correct interfere interference analysis 
shall assume closure analysis ca gives safe approximation superset closures evaluate 
proven 
sequentialization change machine code seen previously code se generated sequentialized version se source expression exactly code generated evidently sequentialized expression precisely operational behaviour source expression 
difference sequentialized expression behaviour order evaluation explicit expression level 
extends sequentialized programs 
global store updates introduced program done app instructions partial full applications 
application operations se done exactly order places execution se suffices study effect se drawn se automatically valid correctness liveness analysis prove global liveness analysis result correct prove step evaluation program machine variables live machine state locally indirectly locally globally dump live analysis 
avoid set function approximation set indirectly live variables dump components steps evaluation function body code possible evaluations program 
prove liveness analysis yields safe liveness information annotate sequentialized program analysis results compilation function carry annotations code 
show possible machine states sets live variables contained set attached instruction component 
sequentialized program goal expression letrec 
arity 

arity input program free variables output program value require free variables order values usual input output contain functions 

correctness globalization program compiled code ret generated function secd machine started state ret input program provided initial environment assume avoid set map computed additional requirement snd 
take goal expression contribution avoid set map account 
subexpression function body compute delta ccl fst 
subexpression goal expression compute delta ccl fst fg 
attach sets delta respective expressions 
expression program annotated set contains analysis variables live evaluation expression 
compilation function place delta labels front generated instructions delta 
delta bas label instruction ret code fg ret code goal expression 
claim label instruction yields safe approximation live variables current machine state computation 
live variables live state 
component contributes locally live variables written ll accessed instruction var 
stack get set stack captured variables sc values locally live variables may capture variables ll dump empty form set live variables dump defined accordingly dump live fg dump live live live defined live ll sc dump live proposition states delta may arise computation delta live 
proof split proof parts 
prove claim 
machine state delta delta part code dump live delta live 
component live ll clearly contained delta occurrences var correspond exactly occurrences sequentialized expression 
analysis result includes capture closure variables included 
sequentialized expression values machine push stack get bound temporary variables plain locally live chapter 
globalization partial applications corresponds popping stack machine terminology 
delta sc 
dump live variables assumed included avoid set delta 
claim 
machine state delta delta part code holds dump live 
prove induction depth dump depth function calls execution 
base case claim trivially true 
inductive case consider state form part code function application function progress called preceding state app delta state return function delta result application induction hypothesis dump live claim delta live delta live delta 
prove inductive case follows snd snd delta delta live dump live exploit defined fixed point line definition applications fact arity ca line validity claim noted line definition dump live line 
proved inductive step claim concludes proof liveness analysis safely approximates liveness variables machine defined function live 
correctness globalization shall prove globalization correct exploiting notion live machine states defined previous section 
liveness analysis safely approximates live conclude globalization decisions safely basis information liveness analysis 
globalization done extension app instruction described section formalized 
purposes correctness proof shall consider semi programs 
programs global store kept updated extended app instruction values global store 
evidently conservative extension affect evaluations results allows prove global store accurately keeps track values variables 

experiments assume belongs variable group fl variables fl evaluation step app instance created holds live app want prove contradiction var evaluation fl 
assume case fl 
correct value environment come application app updated fl fl different intervening redefinition fl 
redefinition caused evaluation application machine state app variable fl 
lemma time belonged live contradicts assumption fl 
hold uses var fl fl 
lemma machine states application app creates new instance variable instance belongs live 
proof outline clearly case just application 
application full machine state occurs ll case 
call function call dump live evaluation called function 
instance called function returns 
application partial machine state newly created instance closure stack top belongs sc 
examine happen closure containing new instance stack pushed dump belongs stack popped 
closure applied continue belong sc fully applied case situation described obtains 
closure moved environment value parameter function current code case belongs case environment copy closure may pushed stack variable belong sc 
experiments section show avoid sets variable groupings computed example programs miranda tm implementation analyses 
chapter 
globalization partial applications captured variable source program map null 
cons car map cdr add plus goal append map add map add avoid sets map add ff ng goal fg map fig variable grouping fffg fig flg fng small interpreter imperative language interpreter interprets language source program cmd 
take cond take cmd assignment 
upd take id take exp sequence 
seq fst cmd snd cmd nop ed cd sd zero 
exp ed sd sd ed cd cmd cd sd upd idu eu su update idu exp eu su su seq sc cmd cmd sc exp number 
add fst exp snd exp look look idl sl access idl sl add sa plus exp sa exp sa nop sn sn main cm cmd cm initial store avoid sets 
experiments cmd fc cd ed eu idu sc sdg fc cd ed eu upd fc cd ed eu seq fc cd ed eu exp fc cd ed eu idu sa sd sug look fc cd ed eu idu sa sd sug add fc cd ed eu idu sa sd sug nop fc cd ed eu main fg variable grouping ffc cm fe fsa sc sd sl sn note store parameters replaced global variable 
note surprisingly 
parameters may 
tendency experiments parameters turn 
composing list functions function compose composes functions contained list arguments 
source program compose fs null 
fs car fs compose cdr fs twice double plus main compose cons twice double cons double avoid sets compose ffg twice ffg double ffg main fg variable grouping ffc yg ffg program function parameters may replaced global variables 
chapter 
globalization partial applications related reported continues schmidt detecting single threaded store variables denotational definitions 
schmidt expressed single threading criteria simple elegant conditions types assigned expressions simply typed lambda calculus 
criteria allow variables captured closures free variables lambdas 
attempts lift restriction retaining simpler conditions failed starting point 
extends schmidt giving algorithm construct variable groupings methods require language type structure 
closely related sestoft previous replacing function parameters global variables analysis possible definition paths program 
method required fixed evaluation order able exploit extra information gives 
sestoft previous restriction schmidt variables allowed captured closures 
extending method definition paths allow turned complicated turned concept globally live variable 
fradet single threading analysis continuation passing form typed expressions gives simple conditions syntax types 
respect quite similar schmidt requires fixed evaluation order able exploit 
previous fradet method allow variables captured closures 
knowledge mentioned previous works remained unimplemented constructed working prototype implementation analysis algorithms miranda tm implementation documented report 
chapter developed analyses transformations pure functional languages 
analyses support program transformations support analyses turn support transformations 
purpose program transformations improve programs reducing run time storage consumption 
analyses collect operational information information possible run time behaviours analysed program 
analyses closure analysis usage count analysis interference analysis implemented 
closure analysis interference analysis globalization optimization proved correct 
effect optimizations usage interval analysis tested experimental implementation functional language 
explain contributions outline chapter report 
quick summary obtained reading summary sections 
lazy example language summary designed working implementation untyped lazy higher order functional language base values lazy data types 
implementation variant simple krivine machine encoding data structures higher order functions 
somewhat theoretical implementation works particular lazy printing data structures interesting easy implement 
full details implementation appendices 
claimed machine proper choice machine execution lazy language suitable basis proving intensional analyses correct 
support claim prove machine implement outermost weak reduction 
chapter 
closure analysis summary described implemented closure analysis lazy language computes expression approximation set functions evaluate 
analysis proved correct respect machine implementing contrast earlier versions closure analysis handles letrec bound variables nullary functions 
handles data structures encoding functions albeit loss precision 
implementation included full 
show extend order analyses higher order analyses closure analysis compare strictness pairs method hudak young 
closure analysis method lower complexity precise 
precision closure analysis especially applied data structures studied carefully 
show worth develop closure analysis typed data structures right encoding functions 
investigated closure analysis suitable extending version evaluation order analysis chapter higher order languages 
usage interval analysis summary designed implemented simple usage count analysis lazy language finds approximation number times variable gets evaluation containing expression 
analysis essentially order extended higher order closure analysis just described 
analysis works data structures encoding functions may give conservative results 
information collected usage interval analysis optimization suspensions thunks designed implemented optimizing transformations lazy language transforms call need call name unshared arguments transforms call need call value strict arguments measurements improved implementation shows considerable part bookkeeping necessary call need avoided program analysis 
simple experimental implementation run time consumption reduced optimizations 
implementations analysis transformations included full 

evaluation order analysis machine implementing exploit strictness information 
better study optimizations usage interval analysis require realistic machine spineless tagless machine peyton jones 
relation usage interval analysis update analysis needed far missing peyton jones stg language clarified 
possibly update analysis developed ideas usage interval analysis 
far precise expensive usage interval analysis restricted order simply typed languages achieved evaluation order analysis framework chapter 
purpose evaluation order description eod expression usage interval map mapping variable vars usage interval 
likewise argument eod aeod mapping set 
ng usage interval th argument 
ordering lattices pointwise usage interval inclusion 
plumbing functions analysis function quite straightforward 
instance var maps variables zero zero ran adds argument usage interval maps pointwise variable 
combination usage interval maps extraction argument eod entire framework uniform evaluation order types carry application 
analyses framework kind usage interval analysis justifiable respect occurrence path semantics 
details remain investigated 
evaluation order analysis summary developed backwards path analysis simply typed order lazy language data structures 
path analysis evaluation order analysis provides information subexpression evaluation order lazy language 
backwards path analysis gives information expressions involving lazy data structures previous forwards path analyses 
analysis implemented proven correct 
backwards path analysis fits entire framework accommodates fine grained occurrence path analysis precise faster evaluation order analysis called evaluation order relations strictness analysis data structures improved usage interval analysis briefly suggested 
framework parametrized lattices evaluation order descriptions certain combining operations analysis 
framework provides general way obtain finite lattice contexts expressions recursive data types 
chapter 
framework extended directions application higher order languages polymorphic evaluation order types 
recall example language order simply typed 
analysis higher order functions possibly achieved closure analysis see chapter hughes general method extending backwards analyses higher order languages 
extension polymorphic evaluation order types allow general efficient analysis typically polymorphic functions functional programming 
example append lists lists evaluation order inner lists immaterial analysis append 
consider polymorphic type append list ff theta list ff 
list ff 
append inspect list elements may type ff 
reason append change order evaluation components values type ff evaluation order relation preserved append 
fact conjecture functions polymorphic component types evaluation order polymorphic component conjectured hughes backwards analysis framework 
cheaper approximations 
variable path analysis neat far high complexity practical useful approximations sought 
analysis evaluation order relations candidate 
formal relation occurrence path analysis investigated 
example various operations combination plumbing functions argument eod extraction evaluation order relations proved correct respect corresponding operations occurrence paths concretization abstraction functions 
provide proof analysis results correct respect occurrence path analysis 
consider practical uses evaluation order information analysis sufficiently precise uses 
implementation possibly sticky version analysis shed light practical feasibility 
semantic basis 
occurrence path analysis justified respect simple machine krivine machine see section 
computation machine gives finite infinite sequence states fits sequences events obtained occurrence path analysis 
krivine machine event expression reaching whnf code part machine state reaches lam ret instruction ready take argument computation stack evaluation initiated 
relation analysis machine build concepts balanced trace whnf computation section 

globalization partial applications clearly standard denotational semantics formal model devoid notions time 
machine instrumented semantics meaning expression result value path actions variable accesses needed reach result 
idea bloss hudak path semantics context dependent evaluation order lazy data structures complicate instrumented semantics considerably obvious correct 
globalization partial applications summary designed implemented interference analysis globalization transformation untyped strict higher order functional language interference analysis finds function parameters replaced global variables subsequent globalization transformation 
analysis recognize variables enclosed partial applications equivalently free lambda expressions previous analyses unable 
proven analysis globalization transformation correct respect variant landin secd machine implements strict language experiments show surprisingly high number function parameters replaced global variables method extends earlier ones handling parameters captured closures 
central concept interference live variable turn depends order evaluation 
assumed language strict simple left right evaluation order 
changing translation sequential expressions treat languages fixed evaluation orders 
handle strict languages indeterminate order evaluation scheme require modifications analysis sequentialized expressions little help 
non strict languages data structures subexpression evaluation order depends context analysis evaluation order somewhat harder 
evaluation order analyses exist see chapter presumably determine set live variables program point 
globalization extended lazy languages globalization expression valid respect certain contexts 
globalization intermediate variables interesting extension amount sophisticated interprocedural register allocation 
framework extension achieved variables sequentialized program 
appendix terminology machine machine state transition system 
backwards backwards analysis information expression information happen result expression 
called context expression 
backwards analysis method computes contexts subexpression expression context expression 
base semantics essential un instrumented semantics programming language prescribing input output behaviour 
term sndergaard 
call name non strict call mechanism argument expression evaluated time corresponding formal parameter zero times 
call need non strict call mechanism argument expression evaluated corresponding formal parameter zero times 
call value strict call mechanism argument expression evaluated ahead uses corresponding formal parameter regardless 
cell turnover number allocation actions done run 
compare residency 
closure closure piece code plus bindings free variables compile time compilation time time stage compilation done 
compile time analysis static analysis program analysis done program run time input running program 
denotation object referred expression 
extension denotation cf 
intension 
extensional having base semantics language describes input output behaviour program 
analysis information extensional meaningful exclusively results computation may give results obtained 
correctness extensional analysis defined basis program input output behaviour 
head normal form core expression head normal form form 

em 

em variable 
em partial application built function 
adapted core peyton jones 
instrumented semantics semantics giving information input output behaviour program 
usually extra information describes result computation obtained intension set characteristics object referred expression roughly 
intensional analysis information intensional understood computation results produced computation 
correctness intensional analysis justified respect semantics giving information input output behaviour program 
lazy language language functions data structure constructors evaluate arguments need 
operational analysis information intensional analysis information 
residency number live cells heap consumption point time 
compare cell turnover 
run noun execution evaluation program 
run time time stage program run 
run time consumption amount time takes run program 
storage consumption see cell turnover residency 
suspension thunk 
closure constructed suspend evaluation expression evaluation code environment produce value suspended expression 
weak head normal form whnf 
core expression weak head normal form whnf top level redex application variable 
em 
adapted core peyton jones 
appendix programs lazy language discussed chapter implemented making experiments closure analysis usage count analysis call need call name optimization 
appendix briefly describes implementations lists programs 
section describes machine section describes closure analysis section describes usage count analysis section describes improved code generation refined version machine 
programs concerning analysis written chez scheme impure untyped functional language lisp tradition 
programs easier write read package syntactic extensions function definition cases developed hans diku 
pattern matching notation easily understandable 
scheme chosen implementation language allows various data structures pointers encoded quite straightforwardly includes garbage collection allows destructive updates necessary laziness 
executed quite efficiently computers necessary interpretation non trivial programs feasible 
implementation language properties standard ml added advantage modules type system handling pointers explicit error prone manner 
admittedly programs cleaner probably readable written standard ml 
offer apology arcane backquote notation program generating programs compact readable got 
compilation machine implementation consists compiler core full core compiler core core machine code interpreter machine summarized section 
implementation organized files compile ss contains compiler core file ss contains compiler core machine interpreter file ss contains auxiliary functions interpreter 

compilation machine file auxiliary ss general auxiliary functions 
run programs compile run program load file execute run scheme system prompt 
example program compute squares integers 
load 
run letrec nil cons square map xs case xs nil 
nil cons ys 
cons map ys map square machine terminated 
time term collections ms elapsed cpu time ms elapsed real time bytes allocated measurements seen example statistics printed terminating computation cpu time milliseconds time spent garbage collection wall clock time milliseconds cell turnover computation 
furthermore machine interpreter profiling mechanism measure frequency execution various instructions app lam 
profiling switched 
interpreter loaded switched 
profiling information printed terminating computation 
computations interrupted manually printing infinite list profiling information requested typing interrupt 
mechanism report residency amount live cells heap just garbage collection 
turned command interpreter loaded 
residency bytes brackets 
execution machine instructions traced 
tracing turned command interpreter loaded 
tracing produces lot output ordinary especially data structure output unreadable 
appendix programs program files file compile ss contains compilation function core description concrete scheme syntax languages 
file compile ss peter sestoft compilation programs core language representation full source language exp lam var 
exp abstraction var 
variable function exp exp application 

quote expression 
base constants numeral 
numerals exp exp exp conditional nil empty list cons list constructor hd tl head tail selectors case exp nil 
exp 
cons var 
var 
exp case exp 
exp 
var 
var 
exp letrec def exp local recursive definitions exp def local recursive definitions def 
var 
var exp variable functions definition representation core language 
lam var 

abstraction var sym 
variable app 

application bapp 
base constants functions 


conditional letrec cdf 
local recursive definitions cdf 
var 

variable function definition compilation source language core language fun core match 
core core core hd 
core lam lam tl 
core lam lam nil 
core lam lam 
core nil cons 
core lam lam lam lam 
core cons hd 
core lam hd tl 
core lam tl quote 
bapp lam 
lam core case 

atom 
atom 

core lam lam case nil 
cons 
atom 
atom 

core lam lam letrec 
letrec defs 
core letrec append defs number 

bapp atom 

match assoc op 
core lam op 
core lam lam 
compilation machine 
var variable er 
match assoc er op 
bapp op core op 
bapp op core core 
core map core er compiling applications fun app compile local recursive definitions 
fun letrec defs 
letrec reverse defs core xi def 
letrec xi core def def defs 
error letrec local definition syntax convert formal parameters letrec definitions lambda variables fun def def body 
body 
error def local definition syntax def atom 

lam def 
error def local definition syntax def defining strict base functions fun name op name op fun name op name op define list equal 

remainder remainder quotient quotient machine file ss contains description machine instructions compilation core instructions machine interpreter 
file ss peter sestoft uses auxiliary compile interpretive implementation machine lazy krivine machine 
basic version optimized instructions 
machine instructions follows instructions named chapter report 
appendix programs ins 
lam ins 
abstraction debruijn binding var num 
variable debruijn index app ins 
ins 
application cst scheme value 
base constants op 
op 
base function evaluation conditional letrec ins 
ins 
local recursive definitions ret base value pn pn lazy print instruction pnp pn pc pc pcp pc pcr pcr stopping machine main functions compile run time programs fun run exp run time exp fun core core compilation core instructions fun core env match lam 
lam core env var 
var env app 
app core env core env bapp op 
cst op bapp op 
app core env op bapp op 
app app app core env core env op 
app app app core env core env core env letrec defs 
letrec defs env variable lookup compile time environment fun env fun get aux env index 
error core variable undefined 

index 
get aux index get aux env compiling letrec definitions core fun letrec defs env rhss 
letrec map lambda core env reverse rhss core env xi ei 

letrec xi env ei rhss representation data structures machine warning heavy fact obtain pointers data structures substructures modified destructively 
particularly important updating markers creation recursive environment letrec 

compilation machine environment scheme list un closures env 
clo closure scheme pair machine instruction environment clo 
ins 
env 
machine stack represented vector closures markers stack top pointer stack accessed macros sr ss sr denotes stack top element sr element stack top ss val sets stack top val 
sr sr sr bottom marker pair tag mrk pointer closure 
mrk 
mrk clo 
machine interpretation function fun prof print car record case app ss var mrk enter list ref lam 
sr sr sr uo sr ss ss uo enter op cdr sr cdr sr op ret op cdr sr op cdr sr enter sr enter sr cst val val pn 
match sr ret val 
print val enter sr 
print enter sr pcr sr ss pcp ss pnp enter pcp 
sr ss pcr ss pc ss pn print mrk enter pc 
sr ss pcr ss pc ss pn print mrk enter pnp 
match sr ret val 
print val enter sr 
print enter sr letrec rhss rhss newline println machine terminated newline println unknown instruction fun val 
ret val appendix programs sr ss ret val enter function enter obj enters closure obj function mrk enter addition pushes marker pointing obj stack fun enter obj car obj cdr obj fun mrk enter obj prof mark print marked ss mrk obj car obj cdr obj updating suspensions machine auxiliary functions machine machine shown file ss listed 
particular contains functions updating suspensions mechanism allocating recursive environments 
destructive updates data structures possibility creating cyclic structures 
essential note run time environment data structure machine refers nested environment pointers copies environments 
updating suspensions creation cyclic environments letrec achieve lazy evaluation 
function 
takes arguments piece code pointer environment pointer obj closure 
destructively overwrites side effect intended effect 
function creates cyclic run time environment evaluation local recursive bindings described section 
core source term letrec 
compiled instruction lrc 

function takes list 
current environment env creates new cyclic environment form ffle 
ffle env 
cyclic environment created allocating hole new closure environment destructively overwriting hole new environment 
file contains functions profiling residency reporting tracing execution machine 
file ss peter sestoft auxiliary functions common machines stack handling extend syntax sr sr index vector ref index extend syntax ss ss index value vector set 
index value run time machine fun run time term 
compilation machine 
collect vector cells bytes allocated set 
collect request handler lambda collect print bytes allocated cells ss ss pc ss pn time term collect request handler reset crh function 
updates markers stack top object returns part stack markers 
fun 
match sr mrk obj 

obj 

prof fun 
obj prof print updated set car 
obj set cdr 
obj function rhss env extends environment env recursive bindings mn 
env terms rhss mn 
fun rhss env 
env 
newe env set cdr 
newe newe functions stopping printing define 
define pn pn 
define pc pc 
define pnp pnp 
define pcp pcp 
define pcr pcr 
collecting printing instruction profiling information fun set 
fun set 
fun 
set 
profile fun prof 
inst op 
match op profile ptr count 
set cdr 
ptr count 
set 
profile op profile fun fun prt entry op count 
print op tabulate op println count appendix programs fun sym string length symbol string sym fun tabulate 
print tabulate map prt sort lambda ent ent 
cdr ent cdr ent profile facilities tracing machine instructions fun set 
fun set 
facilities measuring residency heap consumption fun reset crh set 
collect request handler lambda collect fun set 
fun set 
file contains general auxiliary functions implementation closure usage count analyses 
file auxiliary ss peter sestoft general auxiliary functions common programs strict fold left fun xs 

print functions define print args map display args flush output port define println args map display args newline flush output port versions strict binary list booleans iterating predicate list 
fun sor define sor ar sor ar fun sor fun lambda chg 
sor chg 
closure analysis section describes implementation closure analysis chapter 
closure analysis usage count analysis described decorated core expressions described section 

closure analysis analysis organized files closure ss contains closure analysis functions proper ss contains auxiliary functions common closure analysis usage count analysis 
closure analysis program apply closure analysis program load file execute 
print decorated core expression rho phi properties computed closure analysis 
print format easy read large programs intended mainly debugging 
example closure analysis program example chapter 
letrec twice twice letrec zero lam zero zero lam zero zero bapp procedure 
var var twice zero lam zero zero lam zero zero app var app var var app app var twice app var bapp bapp output concrete syntax decorated core term lam 
label lambda phi list shows evaluate lambda labelled rho list shows applied lambda label 
usage intervals zero concern usage interval analysis meaningless 
result shows variables bound lambdas variable bound lambda partial application argument 
shows twice return lambda 
file closure ss peter sestoft uses auxiliary ss closure analysis core programs analysis compiles program core program fields recording analysis information applies closure analysis functions pe pv 
appendix programs fun set 
decorate core subcontext iter pv closure analysis functions function pv iterated fixed point reached annotations stabilize 
result circular printed 
fun iter pv pv iter pv closure analysis function pe computes set closures lambdas expression may evaluate 
fun pe env var 
get rho env lam ps 
list app 
lambda union get phi empty pe env 
union pe env pe env bapp bop es 
empty letrec defs 
newe defs env pe newe closure propagation function pv pushes phi rho information expression analysing places binding takes place lambdas applications letrec bindings 
function returns new propagation took place information stabilized 
fun pv fun pv env var 
lam ps 
newe var env sor phi pe newe pv newe app 
sor pe env lambda rho pe env pv env pv env 
sor pv env pv env pv env bapp bop es 
es lambda pv env letrec defs 
newe defs env sor defs lambda def def newe pv newe fun def env rhs ps 
sor rho rhs pe env pv env pv decorated core descriptions oe ae closure analysis descriptions usage count analysis represented decorations core syntax tree 
details described comments file lists functions 
closure analysis constructing decorate printing decorated core expressions accessing updating descriptions called properties file 
file ss peter sestoft uses auxiliary auxiliary functions common closure usage count analyses decorated core expressions decorated core program list properties attributes lambda letrec binding syntax tree 
properties called inx phi rho psi chi 
access value property node tree executes get set property value val executes put val transform property node function executes upd 
returns values changed eq 
warning properties modified destructively analyses accessed functions get put upd properties inx phi rho psi chi 
properties added replacing subtree node expr pair expr properties expr result applying process recursively subtrees expr 
representation decorated core expressions dex 
lam var 
dex 
properties 
var sym 
app dex 
dex 
bapp 
dex dex 
dex 
dex 
letrec ddf dex 
ddf 
var 
dex 
properties properties 
inx 
phi 
rho 
psi 
chi 
lambda properties interpreted follows inx unique printable label number phi set lambdas evaluate applied rho set lambdas applied var 
bound psi usage interval variable chi usage interval bound variable properties rho set lambdas bound psi usage interval decorating core expressions fun decorate define occurrence fun set 
occurrence occurrence list occurrence fun var 
lam 
lam app 
app 
bapp bop es 
bapp bop map es letrec es 
letrec map es fun def rhs 
rhs add properties node important cons cell created appendix programs anew property created distinct 
fun define emptyset list empty define list list emptyset emptyset properties inx phi rho psi chi fun define emptyset list empty define list list emptyset accessing properties fun upd property node transform ptr property cdr node value transform car ptr changed 
eq 
value car ptr set car 
ptr value changed fun get property node car property cdr node fun put property node value set car 
property cdr node value fun inx properties car properties fun phi properties car cdr properties fun rho properties car cdr cdr properties fun psi properties car cdr cdr cdr properties fun chi properties car cdr cdr cdr cdr properties printing decorated core expressions properties printed notation lambdas numbered identification number printed ahead properties lam number 
phi 
rho 
psi 
chi 
var 
body 
letrec bindings numbers marked letrec fun 
phi 
psi 
body 
body 
fun var 
lam ps 
lam app 
app 
bapp bop es 
bapp bop map es letrec defs 
letrec map defs fun def rhs ps 
list rhs fun node list get inx node phi node rho node psi node chi node printing set property unique lambda labels fun prop node map lambda get inx get prop node printing interval property fun prop node get prop node analysis time environment 
closure analysis environment closure usage count analyses list triples 
label whnf name variable label label binding lambda letrec whnf 
variable bound closures whnf 
fun var env env fun var env env getting binding label variable fun var env match assoc var env 
lab whnf 
lab 
error unknown variable var fun defs env fun env def rhs lam 
var rhs env rhs 
var rhs env env defs functions simulating context printer fun letrec lam fun subcontext letrec app app 
adding set occurrences property 
elements added 
function returns new element added 
note important union return eq unmodified new element added 
fun prop node upd prop node lambda union fun union vr 
union vr union vr 
define empty empty set fun empty 

empty fun ui ui ui ui define unit define zero zero unit define zero unit define zero appendix programs usage count analysis section lists implementation usage count analysis optimizing code generation machine executes optimized code 
chapter 
usage count analysis works decorated core programs described section closure analysis 
usage count analysis programs apply usage count analysis program load file execute 
print decorated core expression psi xi properties rho phi properties closure analysis computed usage count analysis 
example usage interval analysis program example chapter 
letrec twice twice letrec lam lam bapp procedure 
var var twice lam lam app var app var var app app var twice app var bapp bapp result shown decorated core syntax contains information closure analysis usage interval analysis 
lambda lam 
psi interval usage interval variable bound lambda chi interval usage interval lambda 
result shows interval 
sharable lambdas 
file contains usage count analysis relies auxiliary functions file ss listed section 
file ss peter sestoft uses auxiliary compile closure usage interval analysis core programs 
usage count analysis fun iter uv subcontext application iter uv compute usage intervals lambdas variables program 
fun iter uv uv iter uv computing usage interval variable expression 
usage interval variable expression computed function ue plays role analogous function pe closure analysis 
application ue env returns usage interval variable expression expression 
fun ue env var 

lam ps 

get chi ue var env app 
ue env ue env env 
ue env ue env ue env bapp bop es 
map lambda ue env es letrec defs 
member map car defs newe defs env defs newe fun defs env fun def rhs ps 
get psi rhs ue env map defs ue env propagating usage interval information 
usage interval information propagated expression function uv analogous pv function closure analysis 
fun uv fun uv env var 
lam ps 
newe var env sor psi ue newe get rho get psi uv newe app 
sor uv env uv env pe env 
sor uv env uv env uv env bapp bop es 
es lambda uv env letrec defs 
newe defs env fun def rhs ps 
sor get rho rhs get psi rhs psi rhs defs newe uv newe sor defs uv newe appendix programs uv lambda set labs update chi lub usage interval 
fun labs ui labs lambda lab chi lab ui env lub usage intervals lambdas evaluate fun env map lambda get psi pe env usage counts usage intervals operations 
usage count zero 
usage interval pair usage counts 
fun uc uc zero 
uc 
uc 
uc fun uc uc zero 
uc 
uc 
uc fun uc uc zero 
uc zero 
uc 
fun uc uc zero 
uc 
uc 
uc fun ui ui 
fun uis uis fun ui ui 
fun ui ui 
fun uis uis fun ui 
fun ui 
fun prop node upd prop node lambda 
optimized compilation machine describe optimized compilation programs extended machine called machine executes code generated 

optimized compilation machine optimize run programs optimize run program load file execute run 
apply closure analysis usage count analysis optimized compilation machine code run machine optimized code 
behaves exactly machine profiling residency reporting tracing machine section 
file contains optimized compilation machine interpreter 
relies auxiliary functions file ss listed section 
file ss peter sestoft uses auxiliary compile closure interpretive implementation machine lazy krivine machine 
machine extended optimized instructions 
instructions follows instructions named chapter report 
ins 
lam ins 
unsharable abstraction sla ins 
strict lambda sla ins 
unsharable strict lambda var num 
unsharable variable app ins 
num 
application unsharable variable usual machine instructions data structures basic machine 
main functions compile optimize run time programs fun run exp run time comp exp fun comp dc subcontext compilation decorated core instructions usage interval closure information previously computed exploited code generation special machine instructions var unsharable variable lam unsharable lambda app application unsharable variables 
fun dc fun gen env print car match lam 
ps 
match get psi get chi zero 
lam gen var env zero 
lam gen var env empty 
get rho 
sla gen var env empty 
get rho 
sla gen var env 
lam gen var env 
lam gen var env var 
match get psi env 
env var 
env var app 
gen env gen env bapp 
cst appendix programs bapp op 
app gen env op bapp op 
app app app gen env gen env op 
app app app gen env gen env gen env letrec defs 
newe defs env letrec map lambda def def newe defs gen newe 
error dc unknown expression fun def env ps 
gen env gen variable lookup analysis environment fun env ins fun get aux env index 
error dc undefined variable 
tag 

tag var index ins index 
get aux index get aux env fun var 
app 
app machine interpretation function fun prof print car record case app ss app ss list ref var mrk enter list ref var enter list ref lam 
sr lam sr sr marker sla 
sr ss lam enter sla sr sr marker ss lam enter sr sr uo sr ss ss uo enter op cdr sr cdr sr op ret op cdr sr op cdr sr enter sr enter sr cst val val pn 
match sr ret 
val 
print val enter sr 
print enter sr 
benchmark programs pcr sr ss pcp ss pnp enter pcp 
sr ss pcr ss pc ss pn print mrk enter pc 
sr ss pcr ss pc ss pn print mrk enter pnp 
match sr ret 
val 
print val enter sr 
print enter sr letrec rhss rhss newline println plus machine terminated newline println unknown instruction fun val 
ret val sr ss ret val enter function enter obj enters closure obj function mrk enter addition pushes marker pointing obj stack fun enter obj car obj cdr obj fun mrk enter obj prof mark print marked ss mrk obj car obj cdr obj benchmark programs functions benchmark runs section 
file examples peter sestoft examples source terms benchmarks define fact fact fact define ones ones ones define repeat repeat xs xs xs define define nth nth case 
nth define drop drop xs case xs appendix programs 
xs drop define take take xs case xs 
take define filter filter case 
filter filter define foldl foldl case 

foldl define scan scan xs case xs xs 
scan xs version works infinite lists define xs ys hd xs hd ys tl xs tl ys define letrec tl define sieve sieve case 
sieve filter lam remainder define primes primes letrec filter sieve sieve appendix analyse og transformation af rene dvs 

med en er information om program en transformation af 
med er dvs 
programs implementation ved 
er kan pa 
mv 
man ma med en og 
program bruges af en dog pa en og kan med en og 
kan simple og kan den med en og en af en program 
den bruges ma en information dvs 
information om der med program og nar det 
alle information 
ma ske af give information der er og alle 
af giver men information om 
og implementation med 
er dog en og 
en closure analysis der finder en til af der kan ved 
er af men er til det mere 
bruges som til til 
analyse er og 
appendix en usage interval analysis som finder vre og pa af 
den giver og den vre giver information om af af 
en 
det analyse af man gr af program analyse gr 
er 
med nu en af som 
en finder information om den af det til weak head normal form en 
analyser og den information bruges til af 
er sa vides den med 
analyser er 
en 
finder program der kan med variable 
den af som closures 
er og med til en secd 
bibliography abramsky 
strictness analysis polymorphic invariance 
ganzinger jones editors programs data objects copenhagen denmark october 
lecture notes computer science vol 
pages 
springer verlag 
aho sethi ullman 
compilers principles techniques tools 
addison wesley 
argo 
improving instruction machine 
fourth international conference functional programming languages computer architecture 
imperial college london pages 
acm addison wesley september 
argo 
efficient laziness 
phd thesis department computing science university glasgow march 
pages 
barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland revised edition edition 
bloss 
path analysis optimization non strict functional languages 
phd thesis computer science department yale university new haven connecticut usa may 
research report yaleu dcs rr 
pages 
bloss 
update analysis efficient implementation functional aggregates 
fourth international conference functional programming languages computer architecture imperial college london pages 
acm press addisonwesley september 
bloss hudak 
path semantics 
main editors mathematical foundations programming language semantics rd workshop new orleans louisiana 
lecture notes computer science vol 
pages 
springerverlag 
bloss hudak young 
code optimizations lazy evaluation 
lisp symbolic computation september 
bondorf 
self applicable partial evaluation 
phd thesis diku university copenhagen denmark 
revised version diku report 
bibliography burn hankin abramsky 
theory strictness analysis higher order functions 
ganzinger jones editors programs data objects copenhagen denmark october 
lecture notes computer science vol 
pages 
springer verlag 
cousineau 
curien mauny 
categorical machine 

jouannaud editor functional programming languages computer architecture nancy france 
lecture notes computer science vol 
pages 
springer verlag 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
fourth acm symposium principles programming languages los angeles california january pages 
acm 
cousot cousot 
systematic design program analysis frameworks 
sixth annual acm symposium principles programming languages san antonio texas pages 
acm january 
cr 
machine normalization terms 
acm conference lisp functional programming nice france pages 
acm press 
curien 
ae calculus framework environment machines 
rapport de recherche liens ecole normale sup erieure paris france 

compositional analysis evaluation order application 
acm conference lisp functional programming nice france pages 
acm press 

static analysis lazy functional languages 
university massachusetts boston 
pages 
submitted theoretical computer science 
kent dybvig 
scheme programming language 
prentice hall 
ehrig mahr 
fundamentals algebraic specification volume eatcs monographs theoretical computer science 
springer verlag 
fairbairn 
removing redundant laziness supercombinators 
augustsson editors implementation functional languages pages gothenburg sweden 
programming methodology group chalmers university technology 
pmg report 
fairbairn wray 
code generation techniques functional languages 
acm conf 
lisp functional programming cambridge massachusetts pages 
acm 
bibliography fairbairn wray 
tim simple lazy machine execute supercombinators 
kahn editor functional programming languages computer architecture portland oregon 
lecture notes computer science vol 
pages 
springer verlag 
fradet 
syntactic detection single threading continuations 
functional programming languages computer architecture th acm conference cambridge massachusetts august 
lecture notes computer science vol 
pages 
springer verlag 
garey johnson 
computers intractability 
guide theory np completeness 
freeman 
georgeff 
transformations reduction strategies typed lambda expressions 
acm transactions programming languages systems october 
goldberg 
detecting sharing partial applications functional programs 
kahn editor functional programming languages computer architecture portland oregon 
lecture notes computer science vol 
pages 
springer verlag 
goldberg park 
higher order escape analysis optimizing stack allocation functional program implementations 
jones editor esop 
rd european symposium programming copenhagen denmark may 
lecture notes computer science vol 
pages 
springer verlag 
gomard 
program analysis matters 
phd thesis diku university copenhagen denmark november 
diku report 
gomard sestoft 
evaluation order analysis lazy data structures 
preliminary proceedings fifth glasgow functional programming workshop isle scotland august pages 
department computing science university glasgow scotland 
gomard sestoft 
globalization live variables 
partial evaluation semantics program manipulation new haven connecticut 
sigplan notices vol 
september pages 
acm 
henderson 
functional programming 
application implementation 
prenticehall 
hopcroft ullman 
automata theory languages computation 
addison wesley 
hudak 
semantic model counting abstraction 
abramsky hankin editors interpretation declarative languages chapter pages 
ellis horwood chichester england 
bibliography hudak young 
higher order strictness analysis untyped lambda calculus 
thirteenth acm symp 
principles programming languages st petersburg florida pages 
hughes 
strictness detection non flat domains 
ganzinger jones editors programs data objects copenhagen denmark 
lecture notes computer science vol 
pages 
springer verlag 
hughes 
analysing strictness interpretation continuations 
abramsky hankin editors interpretation declarative languages chapter pages 
ellis horwood chichester england 
hughes 
backwards analysis functional programs 
bjrner ershov jones editors partial evaluation mixed computation pages 
north holland 
hughes 
functional programming matters 
computer journal 
jensen ae 
mogensen 
backwards analysis compile time garbage collection 
jones editor esop 
rd european symposium programming copenhagen denmark may 
lecture notes computer science vol 
pages 
springer verlag 
johnsson 
efficient compilation lazy evaluation 
sigplan notices june 
proc 
acm sigplan symposium compiler construction 
johnsson 
lambda lifting transforming programs recursive equations 
jouannaud editor functional programming languages computer architecture nancy france 
lecture notes computer science vol 
pages 
springer verlag 
kahn 
natural semantics 
brandenburg vidal wirsing editors stacs 
th annual symposium theoretical aspects computer science passau germany lecture notes computer science vol 
pages 
springer verlag 
landin 
mechanical evaluation expressions 
computer journal january 
melton schmidt strecker 
galois connections computer science applications 
pitt editors theory computer programming guildford uk september 
lecture notes computer science vol 
pages 
springer verlag 
milner tofte harper 
definition standard ml 
mit press 
bibliography mycroft 
interpretation optimising transformations applicative programs 
phd thesis department computer science university edinburgh scotland 
pages 
report cst 
naur 
checking operand types algol compilers 
bit 
nielson 
denotational framework data flow analysis 
acta informatica 
park goldberg 
escape analysis optimizing counting lifetime 
partial evaluation semantics program manipulation new haven connecticut 
sigplan notices vol 
september pages 
acm press 
peyton jones 
implementation functional programming languages 
prentice hall 
peyton jones 
spineless tagless machine second attempt 
draft proceedings fourth annual workshop functional programming isle scotland august pages 
department computing science university glasgow scotland 
peyton jones 
spineless tagless machine 
fourth international conference functional programming languages computer architecture 
imperial college london pages 
acm addison wesley september 
pierce michaylov 
programming higher order typed 
technical report cmu cs computer science department carnegie mellon university pittsburgh 
plotkin 
structural approach operational semantics 
technical report fn daimi aarhus university denmark 
reynolds 
approaches type structure 
ehrig floyd nivat thatcher editors mathematical foundations software development tapsoft caap berlin germany lecture notes computer science vol 
pages 
springer verlag 
schmidt 
detecting global variables denotational specifications 
acm transactions programming languages systems april 
sestoft 
replacing function parameters global variables 
master thesis diku university copenhagen denmark october 
sestoft 
replacing function parameters global variables 
fourth international conference functional programming languages computer architecture imperial college london pages 
acm press addison wesley september 
bibliography shivers 
control flow analysis scheme 
sigplan notices july 
sigplan conf 
programming language design implementation atlanta georgia june 
shivers 
data flow analysis type recovery scheme 
technical report school computer science carnegie mellon university march 
pages 
shivers 
semantics scheme control flow analysis preliminary 
school computer science carnegie mellon university 
pages february 
shivers 
semantics scheme control flow analysis 
partial evaluation semantics program manipulation new haven connecticut 
sigplan notices vol 
september pages 
acm 

calculating properties programs valuations specific models 
sigplan notices january 
acm conference proving assertions programs las cruces mexico 
sndergaard 
semantics analysis transformation logic programs 
phd thesis diku university copenhagen denmark 
diku report 
steele 
rabbit compiler scheme 
study compiler optimization 
technical report ai tr artificial intelligence laboratory massachusetts institute technology may 
steensgaard 
parameter splitting higher order functional language 
diku student project diku university copenhagen august 
steensgaard madsen 
typed representation objects functions 
acm transactions programming languages systems january 
stoy 
denotational semantics scott strachey approach programming language theory 
mit press 
turner 
new implementation technique applicative languages 
software practice experience 
turner 
semantic elegance applicative languages 
acm conference functional programming languages computer architecture new hampshire pages 
acm 
wadler 
strictness analysis non flat domains interpretation finite domains 
abramsky hankin editors interpretation declarative languages chapter pages 
ellis horwood chichester england 
bibliography wadler hughes 
projections strictness analysis 
kahn editor functional programming languages computer architecture portland oregon 
lecture notes computer science vol 
pages 
springer verlag 
wray fairbairn 
non strict languages programming implementation 
computer journal 
index argument eod extraction ss program file closure machine approximate capture analysis application contexts argument eod extraction ff tree analysis information app machine instruction app secd machine instruction app machine instruction application context application context description applicative kernel argument closure description argument eod argument evaluation order description arity auxiliary ss program file avoid set op machine instruction op machine instruction backwards balanced trace composite simple bas secd machine instruction base semantics base type body branch ca closure analysis call name call need call value cap exact capture analysis captured locally live capture capture closure case ccl capture closure analysis cell turnover sharing description closure closure closure analysis closure analysis function closure machines closure description closure propagation function closure ss program file code combination eor occurrence path strictness set variable path combiner compile time compile time analysis compile ss program file computation conditional interference constructor context context analysis function copying core index cst machine instruction current closure data structure value data type defined function ffi set live variables denotation safe environment eod evaluation order descriptions eod evaluation order description eor evaluation order relation eor evaluation order relations eot evaluation order type eot evaluation order types evaluation order analysis evaluation order description evaluation order relation evaluation order type expand extended semantics extension extensional folding fun secd machine instruction function body gamma variable grouping fl variable group glo secd machine instruction globally live graph reduction machines language head normal form head strict interference analysis function machine instruction secd machine instruction impure functional language indirectly live instance instrumented semantics intension intensional interference interference analysis function interference pair conditional unconditional interferes interleaving jointly correct ss program file ss program file ss program file liveness analysis function language lam machine instruction lam machine instruction lazy data structures lazy language lexical information live liveness analysis function locally live lrc machine instruction markers prefix needed non strict non strict part normative occurrence occurrence path occurrence path set operational outermost weak reduction machine instruction machine instruction machine instruction machine instruction index partial application path path set pb machine instruction pc machine instruction pc machine instruction pcr machine instruction closure analysis function pe machine instruction pf machine instruction pf machine instruction pf machine instruction oe result closure description pi machine instruction pij machine instruction pn machine instruction pn machine instruction preorder printable value program analysis program transformation usage description pure functional language closure propagation function evaluation order analysis machine instruction ran rank case reduce reducing type reduction top level redexes residency result closure description ret machine instruction ret secd machine instruction ae argument closure description ae safe root expression run run time run time consumption var semantic information semantics semantics sequentialized expression sharing description single threading sla machine instruction sla machine instruction static analysis storage consumption strict strict lambda strict part strictness pair strictness powerset strictness set strongly precedes substitution subtrace summands suspension syntactic information context analysis function tail strict tree avoid set map thunk trace usage analysis function ui unconditional interference unfolding uniform application context uniform evaluation order type unsharable update analysis usage analysis function usage count usage description usage interval usage interval map usage propagation function index ss program file usage propagation function var machine instruction var secd machine instruction var machine instruction variable group variable grouping variable path weak head normal form weak head reduction weakly precedes whnf whnf computation set interference pairs application context description 
