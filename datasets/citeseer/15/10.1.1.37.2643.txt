new uses linear arithmetic automated theorem proving induction deepak kapur subramaniam computer science department state university new york albany ny email kapur cs albany edu cs albany edu 
zhang kapur krishnamoorthy introduced cover set method designing induction schemes automating proofs induction specifications expressed equations conditional equations 
method implemented theorem prover rewrite rule laboratory rrl proof management system built top rrl prove nontrivial theorems reason sequential parallel programs 
cover set method assumption function symbol defined finite set terminating conditional unconditional rewrite rules 
termination ordering employed orienting rules perform proofs founded induction 
left side rules design different cases induction scheme recursive calls function right side design appropriate instantiations generating induction hypotheses 
weakness method relies syntactic unification generating induction scheme conjecture 
goes step proposing semantic analysis generating induction scheme conjecture cover set 
discuss decision procedure presburger arithmetic quantifier free theory numbers addition operation relational predicates performing semantic analysis numbers 
decision procedure generate appropriate induction schemes conjecture cover sets function numbers arguments 
extension cover set method automates proofs theorems require human guidance hints 
effectiveness method demonstrated examples commonly arise reasoning specifications programs 
shown semantic analysis presburger arithmetic decision procedure checking completeness cover set function defined operations gamma numbers 
check function definitions proof prime factorization theorem stating number factored uniquely prime factors checked manually checked automatically rrl 
decision procedure guiding generalization generating conjectures merging induction schemes illustrated 
key words induction automated theorem proving heuristics linear arithmetic presburger arithmetic generalization semantic unification 

mechanizing proofs induction crucial problem needs addressed decide induction scheme leads appropriate induction hypothesis set induction hypotheses carry proof 
related appropriate choice variable finite set variables conjecture perform induction 
seminal boyer moore proposed designing induction schemes terminating function definitions 
typically partially supported national science foundation 
ccr subcontract cb sri contract mda maryland procurement office 
deepak kapur subramaniam definitions function symbols appearing conjecture considered candidates designing induction schemes 
soundness induction scheme designed founded ordering show termination function definition 
insight results generation appropriate induction hypotheses cases prove disprove conjecture 
approach supported boyer moore theorem prover heuristics successfully prove nontrivial theorems reason hardware software 
inspired boyer moore zhang kapur krishnamoorthy introduced cover set method designing induction schemes automating proofs induction equations 
method implemented theorem prover rewrite rule laboratory rrl proof management system built top rrl prove nontrivial theorems reason sequential parallel programs 
cover set method assumption function symbol defined finite set terminating conditional unconditional rewrite rules 
termination ordering employed orienting rules perform proofs founded induction 
left sides rules design different cases induction scheme recursive calls function right side design appropriate instantiations generating induction hypotheses 
cover set method founded ordering define function possibly specified induction scheme generated method generalization principle mathematical induction natural numbers principle structural induction obtained constructors data structure 
go step 
case data structures represented different ways example numbers represented stand successor function constructors terms 
functions gcd divides rem convenient easier define finite sets represented null set constructor inserts element alternatively null set singleton sets union operation 
similarly lists represented empty list cons constructor alternatively empty list singleton lists append operator lists 
reasoning functions defined data structures need convert representation 
exhibit semantic information data structure reconciling different representations attempting proof conjecture 
focus generating induction scheme semantic information enables application induction hypotheses applied different uses function 
illustrate idea example decision procedure presburger arithmetic quantifier free theory numbers addition operation relational predicates called linear arithmetic performing semantic analysis 
arithjar tex new uses linear arithmetic automated theorem proving induction provide informal review cover set method mechanizing induction simple example 
related example discuss linear arithmetic procedure performing semantic analysis reconciling different uses function conjecture 
consider definition divisibility predicate natural numbers functions usual meaning 
divides true divides false divides divides equations oriented left right resulting rewrite rules terminating 
defines divides argument non zero arguments 
possible conjecture prove divides divides reader verify conjecture attempted principle mathematical induction proof gets quite complicated 
cover set method definition divides base cases corresponding rewrite rules generated induction step generated third rewrite rule 
cover set definition divides fg fgi vi fg fv gi vi rule definition triple cover set component tuple corresponding arguments divides left side second component finite set consisting arguments recursive calls divides right side rule third component finite set conditions literals condition rule 
triple empty second third components 
induction scheme generated divides position conjecture cover set divides see 
semantic information linear arithmetic rewriting rule terminating example 
termination condition required divides defined argument second argument non zero conjecture true drop condition 
completeness definition divides discussed detail section 
position sequence nonnegative integers refer subterm term 
equation considered term binary predicate conditional equation considered term binary predicate second argument term considered binary function 
example position divides conjecture viewed abbreviation divides true divides arithjar tex deepak kapur subramaniam fg divides gi fgi vg fv divides gi fgi vg fg divides gi vg fg divides induction scheme finite set tuples tuple corresponding induction case subgoal 
component tuple generate induction subgoal second component generate induction hypotheses 
component induction case tuple component substitution conjecture second component finite set conditions induction case applicable third component subterm generating induction scheme replaced rule definition induction case generated applied 
second component induction case finite set tuples generating induction hypotheses way generated 
induction case second component empty set corresponds base case 
note cover set covers values divides argument non zero arguments zero 
induction scheme generated cover set prove properties condition argument divides non zero 
conjecture base case obtained tuple induction scheme comes rule substitutions variables divides divides formula simplifies true definition rule 
second base case obtained second tuple comes second rule substitutions variables condition divides divides trivially simplifies true divides condition simplifies false condition second rule 
induction step comes third tuple induction scheme comes third rule substitution variables divides divides substitutions variables induction hypothesis coming second component divides divides arithjar tex new uses linear arithmetic automated theorem proving induction associativity commutativity properties applying third rule reduces divides divides induction hypothesis 
conjecture proved 
reader noticed founded ordering suggested definition divides led induction hypothesis turned useful proving conjecture 
consider related conjecture divides divides abbreviation 
cover set divides induction scheme divides position generated fg divides gi fgi vg fv divides gi fgi vg fg divides gi vg fg divides base cases divides divides proved rules similarly divides divides simplifies divides false implies 
check applicability definitions lemmas modulo theory linear arithmetic rewriting get expensive 
rewriting primitive operation rewrite theorem prover rrl performing rewriting modulo theory linear arithmetic slow theorem prover considerably 
necessary linear arithmetic procedure judicious manner widen scope cover set method time maintain efficiency 
rewrite modulo linear arithmetic theory 
discuss subgoal divides proved rewriting modulo linear arithmetic considering induction step generated third case induction scheme 
induction step divides divides assuming induction hypothesis divides divides 
rule applicable left side 
right side 
semantic information natural numbers example taken nqthm corpus 
conjecture proved help explicit induction hint 
arithjar tex deepak kapur subramaniam possible see rule applicable divides give divides 
stated reasons efficiency wish rewrite modulo theory linear arithmetic achieve merging induction schemes different occurrences divides conjecture 
induction scheme divides position generated cover set divides 
induction schemes divides divides merged give scheme fg divides divides gi fgi fg divides divides gi fgi vg fg divides divides gi vg fg divides divides base case proved done 
second base case divides divides established rules definition divides 
induction step divides divides hypothesis divides divides 
rule reduced divides divides hypothesis applicable 
reason keeping replacements subterms generating induction schemes evident 
subterm position form divides rule definition divides directly applicable similar applies subterm divides position 
reader observed semantic analysis performed case natural numbers linear arithmetic decision procedure reasoning needs performed 
show presburger arithmetic mechanizing induction reconcile different representations natural numbers successor 
discuss decision procedure presburger arithmetic called la allows go back forth representations judicious manner generating appropriate induction hypotheses 
way aspects proofs induction automated 
discuss la elaborate cover set function generate appropriate instantiations variables conjecture automate proof 
may necessary rewrite backwards done user providing guidance 
arithjar tex new uses linear arithmetic automated theorem proving induction illustrate semantic analysis la helpful checking completeness functions defined completeness cover set merging induction schemes generalization heuristics context mechanizing proofs induction 
main reason focusing linear arithmetic procedure integrated theorem proving systems nqthm pvs rrl 
currently rrl linear arithmetic procedure prove simple facts discharge conditions arising lemmas definitions 
proposing important linear arithmetic procedure 
approach apply data structures multiple representations finite lists finite sequences finite sets multisets possible devise decision procedure heuristics go back forth different representations 

cover sets induction schemes linear arithmetic section show linear arithmetic decision procedure la generate induction schemes 
give definitions cover set induction scheme cover set illustrate certain class conjectures cover set method fails relies solely syntactic unification unification modulo empty theory 
linear arithmetic remedy problem la perform semantic unification 
motivate algorithm running example divides 
algorithm generating induction scheme conjecture cover set 

cover sets set function symbols variables denotes set terms constructed 
term ars denote set variables occur term outermost function symbol called term 
term form delta delta delta distinct variables called basic term 
substitution oe finite map variables terms written fx delta delta delta oe ffi denotes composition substitutions oe substitution oe oe denotes oe viewed equations oe fx delta delta delta oe fx delta delta delta denote equality terms respect set possibly conditional equations definition function symbol finite set conditional equations form cond cond optional term term cond conjunction literals built terms ars ars ars cond ars 
assumed conditional equation definition oriented arithjar tex deepak kapur subramaniam terminating rewrite rule exists founded reduction ordering cond 
constructors data structure need free case integers finite sets 
assumed constructor relations expressed finite set equations 
function may defined symbols 
finite set equations possibly relating constructors consisting definitions defining 
cover set function definition finite set triples triple derived conditional rewrite rule conditional rule cond component triple tuple arguments second component set consisting tuples serving arguments third component set literals cond 
triple second third components empty set 
ars denotes variables cover set cover set function delta delta delta complete tuple delta delta delta ground constructor terms domains exists cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi ground substitution oe oe oe cond true 
triple said cover tuple delta delta delta cover set function complete follows completely defined 
function definition solely constructors rules definition involve function symbol defined constructor symbols definition called constructor 
cover set generated definition contains terms constructors 
relations constructors implying empty set definition complete cover set replaced matching 
contextual rewriting linear arithmetic procedure implemented discharge conditions checking completeness cover sets 
henceforth stated explicitly cover sets function symbols assumed complete 

induction schemes conjecture different nonvariable subterms may suggest different ways performing induction variables rrl currently supports variety heuristics choose appropriate induction multiple alternatives 
possible alternatives specified induction scheme 
discuss induction scheme generated basic term delta delta delta appearing discuss induction scheme generated nonbasic term delta delta delta necessarily variables 
induction scheme suggested basic term delta delta delta derived directly cover set similar induction scheme called basic 
example induction scheme obtained divides cover set basic 
discussed earlier induction arithjar tex new uses linear arithmetic automated theorem proving induction scheme finite set induction cases form hhoe cond repl delta delta delta cond repl delta delta hoe cond repl generate induction triple delta delta delta cond repl delta delta deltag generate induction hypothesis 
components induction case obtained cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi cover set follows oe fx delta delta delta cond cond repl fp delta delta delta position delta delta delta similarly fx delta delta delta cond cond repl fp delta delta delta substitutions oe substitutions linked variables shared left hand side recursive calls right hand side rule cover set triple derived 
variables substitutions invariant induction hypotheses called induction variables 
induction scheme generated cover set divides induction variables 
induction scheme oe oe denote induction variables oe ars oe denote variables substituted oe 
induction subgoal corresponding induction case oe repl cond repl cond 
completeness soundness basic induction schemes induction scheme inductive proof attempt conjecture provided complete sound 
completeness soundness basic induction scheme directly linked underlying cover set obtained 
complete cover set results complete induction scheme 
constructor definitions free constructors soundness basic induction scheme follows reduction ordering prove termination definition relations constructors definition uses non empty reduction ordering preserving congruence relation ensuring arguments appearing recursive calls right side condition rule definition lower left side 
reduction ordering preserves iff implies terms denote ordering 
terms iff ground substitution oe oe oe 
fp delta delta delta pn tng denotes conjecture subterm position replaced term see subsection shown incomplete cover sets generate induction schemes useful proofs induction 
arithjar tex deepak kapur subramaniam alternatively instantiations rule defining generating cover set recursive calls right side condition lower left side respect order ensure third component cover set triple cond strengthened include additional termination condition ensuring tuple second component triple lower tuple appearing component 
approach adopted section linear arithmetic decision procedure generating cover sets induction schemes 
theorem 
induction scheme oe generated basic term conjecture delta delta delta delta delta delta complete cover set complete sound 
proof 
completeness complete tuple delta delta delta ground constructor terms covered cover set triple hhs delta delta delta delta delta delta hs delta delta delta ig condi ground substitution fi fi delta delta delta delta delta delta fi cond true covered corresponding induction case oe hhoe cond repl delta delta delta cond repl delta delta oe fx delta delta delta fx delta delta delta cond cond cond 
soundness contradiction 
assume delta delta delta delta delta delta true subgoal obtained induction case oe true 
delta delta delta smallest tuple ground constructor terms respect ordering prove termination counterexample delta delta delta delta delta delta fi ffi oe false fi delta delta delta delta delta delta 
induction subgoal corresponding oe oe cond assuming cond true 
fi ffi oe equivalent false fi cond true fi ffi false implying smaller counterexample fi delta delta delta lower ordering delta delta delta definition cover set delta delta delta delta delta delta preserved delta delta delta fi delta delta delta fi 
contradiction 

nonbasic induction schemes completeness induction scheme oe generated nonbasic term delta delta delta ensures ground instance covered induction case oe 
definition 
complete induction schemes induction scheme oe generated term delta delta delta complete iff ground substitution fi tuple delta delta delta ground constructor terms domains fi delta delta delta delta delta delta exists induction case oe hhoe cond repl delta delta delta cond repl delta delta ground substitution fl fl ffi oe delta delta delta delta delta delta fl cond true 
arithjar tex new uses linear arithmetic automated theorem proving induction soundness induction scheme oe guarantees conjecture proved induction oe theorem 
precisely induction scheme oe generated term delta delta delta conjecture sound iff proof induction oe implies tuple delta delta delta ground constructors fi delta delta delta delta delta delta ground substitution fi fi true 
give algorithm generating induction scheme nonbasic term delta delta delta appearing conjecture cover set algorithm uses unification generate different cases induction scheme delta delta delta generates basic induction scheme discussed 
order keep presentation simple algorithm assuming definition constructor relations constructors empty 
algorithm generalized consider arbitrary syntactic unification unification modulo empty theory replaced unification 
course unification decidable finitary general unifiers steps generate induction case mgu step generate induction hypothesis 

algorithm generating induction scheme gamma input conjecture form cond definition ary function term delta delta delta position gamma output induction scheme gamma method 
initialize compute cover set 
compute induction scheme cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi generate induction oe mgu delta delta delta 
induction hoe cond repl oe restriction oe ars cond oe cond repl fp oe generate induction hypotheses oe mgu delta delta delta th induction hypothesis oe cond repl restriction oe ars cond oe cond repl fp oe algorithm generating induction scheme unification delta delta delta delta delta delta fails safest cover set method failed derive induction scheme corresponding term consideration especially occurrences 
constructor terms algorithm syntactic unification arithjar tex deepak kapur subramaniam generate sound complete scheme term illustrated theorem 
theorem 
induction scheme oe generated delta delta delta conjecture delta delta delta delta delta delta constructor complete cover set constructor term assuming relations constructors complete sound 
proof 
completeness loss generality assume ars ars fg 
cover set complete tuple delta delta delta ground constructor terms exists ground substitution fi cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi fi fi cond true delta delta delta delta delta delta 
oe induction case corresponding hffi ffi cond fp ffi delta delta delta ffi gi ffi mgu ffi restriction ffi ars position ground substitution fl fl unifiable fi fi fl unifier fi fi ars ars fg 
fi ffi ffi substitution 
fi cond true fi cond true 
implies ffi ffi ffi ffi cond true delta delta delta covered induction case oe induction scheme oe complete 
soundness contradiction lines theorem 

linear arithmetic cover sets fail syntactically unify arbitrary term induction case corresponding associated cover set triple generated 
involves terms preclude existence tuple delta delta delta ground constructor terms domains equivalent instance instance tuple covered induction cases scheme generated resulting scheme incomplete unsound 
problem avoided unification performed modulo theory containing function symbols occurring consider example data structure numbers natural numbers integers involve 
sections describe linear arithmetic decision procedure carry unification modulo theory linear arithmetic generating complete sound induction schemes terms arguments terms theory linear arithmetic function defined terms theory 
theory linear arithmetic denotes quantifier free order theory numbers integers natural numbers numeric variables arithmetic operations successor predecessor addition arithmetic relations arithjar tex new uses linear arithmetic automated theorem proving induction 
linear term number variable form delta delta delta ary arithmetic operation linear terms 
ary arithmetic relation delta delta delta linear terms denotes linear atom 
linear literals linear atoms negations linear atoms 
la denote equality terms respect linear arithmetic theory 
ce fs ng set equations context cond linear terms cond conjunction linear literals 
fx delta delta delta xm variables occurring ce cond 
tuple delta delta delta numbers solution ce cond iff oe cond la true oe la oe oe fx mg 
linear arithmetic procedure la assume existence algorithm specified follows 
gamma input set equations ce fs ng context cond linear terms cond conjunction linear literals 
gamma output ce solved 
solved form ce substitution oe form fx satisfying occur check linear terms possibly involving new variables introduced solving ce feasibility constraints conjunction linear literals restricting values variables take 
gamma completeness soundness input output la related tuple delta delta delta numbers solution equations ce context cond solution oe context foe cond equations solved form obtained algorithm solving linear diophantine equations conditions variables needed included feasibility constraints 
assume linear literal form constant possible enumerate procedure various values requirement completeness algorithm solving set linear equations context 
input restricted subset universally quantified linear arithmetic theory shown complete procedure detect unsolvability set equations context lead solution expressible single substitution feasibility constraints 
definition 
la function definitions definition ary function la iff rule cond arguments linear terms cond conjunction linear literals 
definitions la definitions 
example definition divides la definition 
arithjar tex deepak kapur subramaniam la semantic analysis generating induction scheme cover set need modify definition cover set slightly 
propose la perform semantic unification terms conjecture cover set generated definitions functions definitions functions oriented terminating rules founded reduction ordering 
orderings need preserved semantic transformations 
instance rule definition semantic unification term conjecture la replace term semantically equivalent produce induction case form xg fg fgi xg fg unsound 
avoid require reduction ordering preserve semantic congruence relation numbers induced la soundness rule cond term arguments linear terms arguments recursive calls cond lower arguments semantic founded ordering numbers 
additional requirement incorporated triple cover set strengthening condition component cond include termination condition 
natural numbers lexicographic order tuples works wellfounded order 
integers lexicographic order absolute values linear terms 
semantic founded ordering linear terms preserved substitutions 
founded semantic ordering linear terms la defined la iff substitution oe variables numbers joe joe jtj denotes absolute value linear term lex denotes lexicographic extension la tuples linear terms 
example third rule defining divides hu vi hu vi case termination condition added third component triple corresponding third rule cover set divides 
definition 
la cover sets cover set ary function iff cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag linear terms cond conjunction linear literals termination condition conjunction linear literals ensuring hs delta delta delta lex hs delta delta delta definition la cover set predicate divides introduced section gets modified follows 
divides fg fgi vi fg fv gi vi fu 
definition 
complete la cover sets la cover set ary function complete iff tuple numbers delta delta delta exists cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag cond ground substitution oe oe la oe cond true 
arithjar tex new uses linear arithmetic automated theorem proving induction discussions assume termination condition integrated cond condition governing cover set triples explicitly specified 

linear arithmetic induction schemes generating induction scheme term conjecture cover set arguments corresponding induction variables non variable terms algorithm section fails 
example take divides conjecture discussed earlier 
possible derive induction scheme cover set unified cover set triple 
possible situation consider arguments term argument positions corresponding induction variables distinct variables 
example take divides conjecture 
cover set method fails generate induction scheme case needs unified generate induction case triple cover set possible 
failure cases purely syntactic view taken attempting unify terms expressed 
case unified semantic analysis giving general unifier fy 
similarly second case unified giving general unifier fx 
need relate arbitrary terms expressed achieved linear arithmetic procedure la 
la cases solved 
la generalize algorithm subsection uses syntactic unification generating induction scheme conjecture perform semantic unification selected subterm delta delta delta cover set associated outermost symbol cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi constraint equations ft ng set la invoked produce substitution oe ars ars context cond 
third component empty context assumed true 
restriction oe ars produces substitution corresponding induction similarly substitution oe ars ars induction hypotheses generated invoking la constraint equations ft ng context cond 
restriction oe ars substitution corresponding th induction hypothesis 
wish avoid rewriting modulo linear arithmetic associate induction induction hypotheses set positional replacements form fp oe delta delta delta fp oe delta delta delta respectively position term conjecture replacements enable rules definition simplification seen case conjecture earlier 
arithjar tex deepak kapur subramaniam example consider term divides position conjecture 
cover set triple divides get fx substitution 
second triple substitution obtained constraints vg context fv la simplify fx 
third cover set triple constraints corresponding induction vg context fu vg simplify fx 
similar manner substitution corresponding induction hypothesis obtained fx 
induction scheme fg divides gi fgi fg divides gi fgi vg fg divides gi vg fg divides induction scheme term divides position conjecture computed follows 
induction case generated corresponding cover set triple unified la second cover set triple constraints fu context fv simplifies la fx third cover set triple constraints corresponding context fu simplifies fx 
constraints hypothesis fu context fu simplifies fx gamma feasibility constraint fv 
divides induction scheme specified fg divides gi fgi fg divides gi gamma fv divides 
modified algorithm generating induction scheme gamma input conjecture form cond la definition ary function term delta delta delta position gamma output induction scheme gamma method 
initialize compute la cover set 
compute induction schemes cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi note implicit feasibility constraint natural number left unspecified 
arithjar tex new uses linear arithmetic automated theorem proving induction generate induction induction form hoe cond repl generated set constraint equations ce ft ng 
ii solve ce la context 
solvable oe fx substitution obtained satisfies linear terms possibly involving new variables ars ars 
set feasibility constraints ars 
solution corresponds vacuous induction case 
iii restriction oe ars 
oe restriction oe ars cond cond repl fp oe delta delta delta oe generate set induction hypotheses th hypothesis cond repl generated set constraint equations ce ft kg 
solve ce la context ce new feasibility constraints obtained oe new substitution obtained 
ii oe compute cond repl 
solution corresponds th hypothesis generated 
induction scheme output algorithm applied conjecture discussed earlier 
noted modified algorithm cases yield solutions ignored underlying la procedure assumed sound complete 

examples illustrate algorithm examples involving greatest common divisor gcd function 
properties illustrated proved cover set induction method la methods implemented induction nqthm unsuccessful establishing properties properties proved hints tricks 
conjectures definition gcd function 
gcd gcd gcd gcd gcd gcd conjecture consider gcd oe fs delta delta delta foe delta delta delta oe sk arithjar tex deepak kapur subramaniam 
initialize la cover set gcd gcd fhh xi fg fgi hhx fg fgi hhx yi fhx fx hhx yi fhx fx conditions governing cover set triples terminating conditions 
third rule hx yi lex hx yi iff similarly rule defining gcd leads termination condition 
compute induction scheme cover set triple generate induction case fg gcd gi fgi 
second cover set triple generate induction case solved 
third cover set triple hhx yi fhx fx generate substitution induction constraint equations fm context fx xg substitution obtained fm new variable introduced solving 
constraint equations hypothesis fm context fx substitution obtained fm 
induction case generated fg gcd gi zg fg gcd fourth cover set triple constraint equations fx context fx yg 
substitution obtained fm 
constraint equations hypothesis fx context fy unsatisfiable 
induction hypothesis case induction case generated fg gcd gi fgi 
scheme generated algorithm fg gcd gi fgi fg gcd gi fgi fg gcd gi zg fg gcd pair numbers covered induction case covered case case dropped 
induction scheme conjecture easily proved 
conjecture consider gcd 
initialize la cover set gcd 
arithjar tex new uses linear arithmetic automated theorem proving induction 
compute induction scheme cover set triple constraint equations fm xg trivially solvable 
substitution obtained fm 
induction case generated fg gcd gi fgi 
second cover set triple lead induction case constraint equations fm solution 
third cover set triple lead induction case constraint equations fm yg context fx xg solution 
fourth cover set triple constraint equations fm yg context fx yg 
substitution obtained fm xg feasibility constraints fx 
constraint equations hypothesis fm yg context fy solution hypothesis discarded 
induction scheme generated 
subgoal generated induction case scheme reduces true rule definition gcd 
subgoal generated second case reduces gcd established induction scheme generated subterm gcd la 
fg gcd gi fgi xg fx gcd gi fgi 
completeness soundness schemes section proved completeness soundness induction schemes generated basic terms complete cover sets 
shown section induction schemes generated syntactic unification cover set triples nonbasic term delta delta delta need complete underlying cover set complete 
nonbasic term complete sound schemes obtained syntactic unification unification performed modulo equational theory comprising definitions relations constructors 
possible unification modulo decidable finitary case 
prove induction schemes got complete la cover sets la term delta delta delta linear terms algorithm section complete sound 
proof lines theorem 
theorem 
induction scheme oe generated delta delta delta conjecture delta delta delta delta delta delta complete la cover set complete sound 
proof 
completeness loss generality assume ars ars fg 
complete la cover set tuple delta delta delta numbers exists ground substitution fi cover set triple hhs delta delta delta arithjar tex deepak kapur subramaniam delta delta delta delta delta delta delta delta deltag condi fi la fi cond true delta delta delta delta delta delta 
oe induction case corresponding hhffi ffi cond fp ffi delta delta delta ffi gi 
ffi mgu obtained solving ce fs ng context cond la feasibility constraints ffi restriction ffi ars position ground substitution fl fl la unifiable modulo la fi fi fl unifier fi la la fi ars ars fg fi cond true fi cond true 
completeness soundness la fi ffi ffi true substitution 
implies ffi ffi la ffi ffi cond true true delta delta delta covered induction case oe corresponding oe complete 
soundness contradiction 
assume delta delta delta delta delta delta true subgoal obtained induction cases oe true 
delta delta delta smallest tuple numbers respect semantic ordering la prove termination definition counterexample delta delta delta delta delta delta ffi ffi false 
induction subgoal corresponding oe ffi ffi cond assuming cond true 
ffi false ffi cond true true false implying smaller counterexample delta delta delta lower ordering la definition la cover set la delta delta delta la la preserving ffi delta delta delta ffi la ffi delta delta delta ffi 
contradiction 

merging induction schemes induction schemes suggested various subterms conjecture share induction variables 
inductive proof attempt conjecture schemes succeed cases 
instance subterms conjecture binary functions defined recursively arguments attempting proof conjecture induction scheme suggested term result induction step containing oe oe oe oe oe 
choice induction scheme ensures term simplified match induction hypothesis need true term variable get instantiated 
example definition predicate defining equality lists built constructors nil cons arithjar tex new uses linear arithmetic automated theorem proving induction nil nil true nil cons false cons nil false cons cons 
conjecture attempted schemes suggested subterms possible candidates attempting proof conjecture induction 
scheme suggested subterm follows 
nil fg fgi fgi nil cons fg fgi fgi cons fg fgi fgi cons cons fg fgi fg induction scheme suggested similar scheme obtained replacing variable variable induction cases scheme 
induction scheme suggested subterm follows 
nil fg fgi fgi nil cons fg fgi fgi cons fg fgi fgi cons cons fg fgi fg attempting proof induction schemes result induction step case cons cons cons cons hypothesis simplifies rule definition cons cons simplified hypothesis match proof attempt induction fails 
failure due induction variable instantiated subterms discussed 
reader easily verify proof attempt schemes fail definitions constructor complete induction scheme generated non basic term cons induction scheme alternatively establish conjecture 
arithjar tex deepak kapur subramaniam variables remain uninstantiated induction step proof attempts 
situation remedied induction schemes merged induction scheme instantiates induction variables simultaneously terms generated 
merging schemes eliminates need arbitrarily choose competing schemes 
merge induction scheme scheme merging induction case cases possible definition merging induction cases 
definition 
mergeable induction cases induction case hhoe cond repl delta delta delta cond repl delta delta merges induction case hhoe cond repl delta delta delta cond repl delta delta give induction case form hhoe mhi conditions hold 
gamma oe unifiable oe mgu ffi ars oe ars oe 
oe ffi ffi oe ffi ffi oe ffi cond ffi cond ffi repl ffi repl 
gamma th merged hypothesis triple cond repl triple ffi ffi fl ffi cond ffi cond ffi repl included mh consistent 
second component empty basis case fl restriction oe variables appearing fl restriction variables 
similarly triple cond repl triple ffi ffi fl ffi cond ffi cond ffi repl included mh consistent 
second component empty fl restriction oe variables appearing fl restriction variables 
order merge consider induction case induction cases 
induction case merges induction cases cases substitutions shared variable nil cons unified 
merged cases nil nil fg fgi fgi nil nil cons fg fgi fgi second induction case merges induction cases reasons merged cases nil cons fg fgi fgi nil cons cons fg fgi nil fg assumed reduction ordering proving termination definitions induction schemes corresponding merged 
merged induction scheme need sound hypotheses schemes merged included hypotheses merged schemes 
arithjar tex new uses linear arithmetic automated theorem proving induction similarly third induction case merged cases obtained cons nil fg fgi fgi cons nil cons fg fgi fgi final induction case merges third fourth induction cases merged induction cases obtained cons cons fg fgi fg cons cons cons fg fg fg note merging final case final case merged hypotheses identical retained 
ffi fx fu fv substitutions ffi ffi fl fu ffi ffi fl fl fu restriction variables occurring fl fw restriction variables occurring 
merged cases conjecture easily proved 
procedure merging induction schemes preserves soundness completeness illustrated theorem 
theorem 
induction scheme obtained merging complete sound basic induction schemes oe oe mergeable complete sound 
proof 
completeness oe oe respectively generated terms delta delta delta delta delta delta conjecture delta delta delta delta delta delta delta delta delta 
induction schemes oe oe complete tuple delta delta delta ground constructor terms exist induction cases oe hhoe cond repl delta delta delta cond repl delta delta oe hhoe cond repl delta delta delta cond repl delta delta ground substitutions fl fl fl ffi oe fl cond true fl ffi oe fl cond true delta delta delta delta delta delta 
loss generality assume oe oe mergeable induction cases 
fi fl fl fi agrees substitution common variables common variable oe oe unifiable 
fi cond fi cond true 
merged induction case generated oe oe hhoe delta delta delta fi delta delta oe ffi ffi oe ffi ffi oe ffi mgu oe oe ars ars ffi cond ffi cond 
fi ffi ffi substitution 
ffi oe ffi oe ffi ffi cond ffi ffi cond true tuple delta delta delta covered induction case induction scheme complete 
arithjar tex deepak kapur subramaniam soundness contradiction 
assuming counterexample ground constructor terms serving instances smaller counterexample constructed instance instance smaller 
assume conjecture delta delta delta delta delta delta delta delta delta true subgoal obtained induction case true 
delta delta delta smallest tuple ground constructor terms respect ordering prove termination definitions counterexample ffi oe false 
induction subgoal obtained oe assuming fi true 
oe false true fi false 
fi definition mergeable induction cases form ffi ffi form ffi ffi imply existence counterexample delta delta delta lower ordering delta delta delta respectively restrictions variables occurring 
definition cover set oe oe hypothesis obtained oe oe ffi ffi delta delta delta oe ffi ffi variable occur oe common variable ffi ffi oe ffi ffi ffi ffi oe ffi ffi oe 
hf delta delta delta delta delta delta hypothesis got oe similar result follows hypothesis got oe symmetry 
contradiction 

merging linear arithmetic discussed previous subsection crucial preconditions merging induction cases syntactically unifiable substitutions common induction variables merged induction case obtained mgu substitutions 
definitions involved constructor relations constructors empty merged scheme obtained described procedure syntactic unification need complete 
cases substitutions common induction variables induction cases semantically unified respect 
example divides divides induction schemes suggested divides suggested divides section merged procedure obtain complete sound scheme substitution fx scheme divides unifiable substitution cases scheme divides similarly substitution fx scheme irreconcilable cases scheme 
done provided unification modulo decidable finitary 
merged induction cases corresponding mgu substitutions common induction variables need generated merged scheme complete 
arithjar tex new uses linear arithmetic automated theorem proving induction induction schemes merged linear arithmetic reconcile substitutions 
linear arithmetic procedure perform semantic unification substitutions common induction variables schemes merged 
soundness semantic ordering la prove termination definitions functions schemes derived 
illustrate merging algorithm merging scheme divides scheme divides 
precise details algorithm subsection 
element scheme divides merges element divides give fg divides divides gi fgi second element scheme divides merges second element divides give fg divides divides gi fgi note hypothesis hfx gamma fv divides gii discarded constraint equations induction elements merged fx implies condition governing hypothesis unsatisfiable 
third element divides merges second element divides give vg fg divides divides vg fg divides divides igi 
note obtain merged induction scheme element reconcile substitutions producing 
shown resulting induction scheme conjecture easily proved 

linear arithmetic algorithm merging induction schemes give algorithm la merging induction schemes share common induction variables number type 
algorithm generalized consider arbitrary unification semantic unification la course order unification decidable finitary mentioned 
gamma input induction schemes meet conditions 

fg 

substitutions theory linear arithmetic common induction variables gamma output induction scheme gamma method 
merge distinct schemes induction case hhoe cond repl delta delta delta cond repl delta delta arithjar tex deepak kapur subramaniam induction case hhoe cond repl delta delta delta cond repl delta delta ce oe oe oe oe viewed equations 
solve ce la context cond solvable ffi fx jx ars oe ars oe feasibility constraints ce unsolvable corresponds merged induction case generated 
ii compute merged induction scheme element hhoe mhi oe union substitutions ffi ffi oe ffi ffi oe union ffi cond ffi cond ffi union replacements ffi repl ffi repl 
triple cond repl hypotheses triple ffi ffi fl ffi cond ffi cond ffi repl included mh ffi ffi fl viewed equations consistent respect la context cond second component empty fl restriction oe variables occurring fl restriction variables 
similarly triple cond repl hypotheses triple ffi ffi fl ffi cond ffi cond ffi repl included mh ffi ffi fl viewed equations consistent respect la context cond second component empty fl restriction oe variables occurring fl restriction variables 

return set merged cases induction scheme 
examples illustrate algorithm example definition gcd earlier definition predicate natural numbers 
true false consider proving conjecture gcd scheme suggested position gi fg gi fgi gi fg gi fgi fg gi fg arithjar tex new uses linear arithmetic automated theorem proving induction scheme suggested gcd position la fg gcd gi fgi fg gcd gi fgi fg gcd gi fgi fg gcd gi xg fg gcd merging scheme suggested subterm scheme suggested subterm gcd done follows 

induction case merges induction case gcd 
cases constraint equations respectively unsolvable 
merged case fg gcd gi fgi 

second induction case merges second induction case gcd constraint equations unsolvable rest cases 
merged case fg gcd gi fgi 

third induction case third induction case gcd constraint equations fm substitution obtained fm 
constraint equations hypothesis fm trivially solvable 
merged case obtained fg gcd fg 

third induction case final induction case gcd constraint equations fm substitution obtained fu xg 
constraint equations hypothesis trivially solvable merged induction case obtained fg gcd gi xg fg gcd 
merged induction cases conjecture easily proved 
example consider conjecture quot hf hf definitions quot computes quotient dividing natural number natural number hf halves natural number quot quot quot quot hf hf hf hf arithjar tex deepak kapur subramaniam induction scheme obtained hf position fg hf gi fgi fg hf gi fgi fg hf gi ug fg hf gig obtained quot position la fg quot gi fgi fg quot gi fgi fg quot gi fgi fg quot gi fgi fg quot gi xg fg quot scheme suggested subterm hf merged scheme suggested subterm quot follows 

cases hf merge cases quot resulting fg fgi fgi fg fgi fgi respectively 

case hf merges third fourth cases quot resulting fg quot hf gi hfm fg quot hf fg quot hf gi hfm fg quot hf respectively 

case hf final case quot constraint equations fm 
substitution obtained fm 
constraint equations set individual hypotheses fm resulting substitution fm xg fm resulting substitution fm 
hypotheses generated corresponding substitutions 
merged induction case generated fg quot hf gi xg fg quot hf gi hfm fg quot hf gig 
evident induction step induction hypothesis contributed induction schemes corresponding quot hf 
merged induction cases conjecture easily proved 

completeness soundness merged induction scheme completeness soundness induction scheme generated algorithm merging sound complete induction schemes la semantic unification established way done earlier completeness arithjar tex new uses linear arithmetic automated theorem proving induction soundness merging basic inductions schemes 
unification unification modulo la done 
individual induction scheme proof patterned theorem establishing completeness soundness induction scheme generated la semantic unification 
proof combines proofs theorems 
theorem 
induction scheme obtained merging sound complete induction schemes oe oe corresponding complete la cover sets respectively complete sound 
proof 
completeness oe oe respectively generated delta delta delta delta delta delta conjecture delta delta delta delta delta delta delta delta delta 
tuple delta delta delta numbers ground substitutions fi fi fi la fi delta delta delta delta delta delta exist induction cases oe hhoe cond repl delta delta delta cond repl delta delta oe hhoe cond repl delta delta delta cond repl delta delta cover delta delta delta ground substitutions fl fl fl ffi oe la fl cond true fl ffi oe la fl cond true fi fl fl fi agrees substitution common variables common variable oe oe unifiable modulo la fi cond fi cond true 
follows lines theorem tuple delta delta delta covered induction case generated oe oe algorithm 
induction scheme complete 
soundness contradiction 
assuming counterexample numbers serving instances smaller counterexample constructed manner theorem instance instance smaller 
delta delta delta smallest tuple numbers respect ordering la prove termination definitions counterexample oe false true fi false 
fi computed algorithm section form ffi ffi form ffi ffi imply existence counterexample delta delta delta numbers lower ordering la delta delta delta respectively restrictions variables occurring 
contradiction 

checking completeness cover sets important property cover set complete cover data structure consideration 
proved earlier induction scheme generated complete cover set sound 
ensured terminating rewrite rules defining function left sides basis constructing cover set completely define function 
algorithms checking completeness constructor definitions expressed terminating rewrite rules arithjar tex deepak kapur subramaniam discussed background information topic interested reader may consult 
la definitions linear arithmetic procedure checking completeness 
fills major gap cover set method mechanizing induction rrl 
example proof unique prime factorization theorem reported completeness definitions functions div rem gcd associated cover sets established manually 
linear arithmetic procedure proofs carried automatically rrl 
develop algorithm checking completeness function definitions associated cover sets linear arithmetic procedure 
focus function definitions arguments number type method easily extended consider definitions arguments numbers data structures lists sequences 
algorithm serves decision procedure checking completeness la cover sets heuristic checking completeness la function definitions 

algorithm check completeness function definition gamma input la cover set ary function delta delta delta 
gamma output quantifier free linear arithmetic formula free variables delta delta delta specifying values defined true complete 
gamma method 
initialize initialize false 

linear solve cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi set constraint equations ce fx ng 
solve ce la context cond 
solvable formula solutions exist 
solution exists assumed false 

linear simplify la check valid 
return true 
return simplified form theorem shows algorithm returns true definition complete associated cover set complete 
algorithm returns formula different true definition may may complete depending rewrite rules defining confluent 
associated cover set incomplete 
theorem 
la cover set function delta delta delta complete iff algorithm returns true 
arithjar tex new uses linear arithmetic automated theorem proving induction proof 
la cover set ary function complete tuple delta delta delta numbers exist substitution oe cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi oe la oe cond true 
formula generated algorithm cover set tuple step instantiated fx delta delta delta true making delta delta delta true 
implies quantifier free formula free variables delta delta delta generated algorithm equivalent true 
complete exists tuple delta delta delta covered cover set triple cover set triple set equations ce fe step algorithm solution cond corresponding delta delta delta false 
delta delta delta false implying equivalent true 

examples gamma example consider definition gcd earlier 

initialize false gcd cover set gcd 

linear solve cover set triples gcd constraint equations fx fx xg respectively 
updated third cover set triple constraint equations context 
adding conditions cover set triple symmetry 
adding conditions obtain 
linear simplify la reduces true definition gcd complete 
gamma integer divisibility consider predicate divides defined example discussed 
observed divides defined argument non zero arguments 
established algorithm follows 

initialize false 
divides cover set divides 

linear solve cover set triple constraint equations fx 
fx 
second cover set triple vi fg fv gi constraint equations fx vg context fv 
arithjar tex deepak kapur subramaniam third cover set triple fu constraint equations fx vg context 
updated 
linear simplify valid formula la reduce true 
simplified form output algorithm corresponds initial observation divides defined argument non zero second argument zero 

incomplete cover sets order draw sound important complete cover set 
unsound 
example cover set definition divides caring completeness possible wrongly conclude divides divides formula hold case 
divides defined formula holds condition 
divides divides theorem 
similarly case second conjecture divides divides theorem divides divides condition conditional formula true 
incomplete cover sets useful certain cases proving divides divides incomplete cover set divides cover set incomplete argument divides 
relativize completeness cover set respect formula 
definition 
relatively complete la cover sets la cover set delta delta delta complete respect linear arithmetic quantifier free formula free variables delta delta delta iff tuple delta delta delta numbers conditions hold 
gamma delta delta delta false arithjar tex new uses linear arithmetic automated theorem proving induction gamma exists cover set triple hhs delta delta delta delta delta delta hs delta delta delta delta delta deltag condi substitution oe oe la oe cond true 
complete la cover set complete respect formula true 
cover set associated delta delta delta establish inductive property delta delta delta complete respect delta delta delta 
theorem 
la cover set delta delta delta complete respect delta delta delta induction scheme generated sound complete conjecture delta delta delta delta delta delta delta delta delta 
proof 
contradiction 
assume delta delta delta delta delta delta delta delta delta true induction case scheme obtained delta delta delta delta delta delta delta delta delta true 
delta delta delta smallest tuple numbers respect termination ordering la prove termination definition counterexample delta delta delta delta delta delta delta delta delta 
delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta false 
equivalently delta delta delta true delta delta delta delta delta delta delta delta delta delta delta delta false 
complete respect delta delta delta delta delta delta true exists cover set triple hhs delta delta delta delta delta delta delta delta delta delta delta deltag condi substitution oe oe la oe cond true 
corresponding exists induction case form delta delta delta cond fgi delta delta delta hfx delta delta delta cond fgi delta delta theorem 
induction subgoal corresponding cond assuming true fx delta delta delta fx delta delta delta oe false oe cond true oe cond false 
oe cond true implies smaller counterexample oe hs delta delta delta lower termination ordering la delta delta delta 
definition la cover set hs delta delta delta la hs delta delta delta la preserved la hoe delta delta delta oe la hoe delta delta delta oe 
contradiction 

generalization attempting proofs induction intermediate conjectures generated may difficult prove automatically 
situations possible prove generalization conjecture conjecture follows 
induction theorem provers support heuristics generalizing conjectures 
rrl kinds generalizations performed abstracting nonvariable subterm appearing conjecture variable nonvariable subterm appears conjecture left side right side arithjar tex deepak kapur subramaniam condition ii dropping assumption conditional conjecture 
semantic analysis useful implementation generalization heuristic subterm may multiple occurrences semantically may appear multiple occurrences syntactically 
section illustrate linear arithmetic procedure improving generalization heuristic focusing kind generalization abstracting nonvariable subterm multiple occurrences variable 
briefly review generalization heuristic performed rrl syntactic properties la discuss heuristic improved la conjecture form cond look maximal nonvariable subterm occurring cond 
may maximal subterms collected list possible candidates generalization 
abstracting nonempty subset set candidates lead generalized version conjecture 
subset candidates generalization template generated component list abstraction pairs form hs ui candidate subterm new variable replace second component list triples form hp indicating subterm position replaced abstraction pairs obviously generated abstracting component 
generalization template generate generalized version simultaneously replacing subterm position triple hp second component 
obvious proved proved 
main steps generalization procedure rrl identify maximal nonvariable subterms occur conjecture ii generate different possible generalization templates considering possible nonempty lists abstraction pairs iii generalization template generate generalized conjecture proof obtained 
generation candidate subterms generalization order replacement candidate subterms new variables arbitrary fine tuned rrl experimentation 

linear arithmetic determining subterms drawback heuristic case heuristics discussed earlier syntactic considerations 
subterm may multiple occurrences syntactically conjecture semantically equivalent subterms may occur conjecture 
instance consider conjecture gcd function gcd argument gcd appears quite different second argument 
semantic analysis performed rrl generate gcd arithjar tex new uses linear arithmetic automated theorem proving induction generalized version conjecture abstracting occurrences left right side variable second argument gcd syntactically appears include subterm 
generalization valid formula counterexamples 
subterms expressed normal form say respectively occur second 
semantic standpoint second argument gcd closely related argument 
la look equivalent subterms relationship identified argument gcd appears twice second argument 
conjecture form cond maximal nonvariable subterm check appears cond 
linear term syntactic subterm check performed 
check linear subterms include occurrences check performed la querying linear subterm answer occur find number times appears done repeated query subtraction result smaller 
tr positive integer tr linear term smaller case abstracted new variable giving abstraction pair hs ui subterm conjecture position replaced tr 
candidate subterms conjecture generalization identified generalization templates generated considering possible subsets candidates generalization 
conjecture gcd look occurrences linear term linear terms conjecture 
la queried compute number occurrences linear term conjecture 
repeated subtraction number occurrences computed remainder 
similarly right side conjecture occurrence 
maximal subterm conjecture generalized subterm occur linear subterm 
abstracting template formed hf fh ui ui conjecture generalized gcd conjecture rewritten fourth rule gcd give gcd proved la induction scheme generation procedure shown earlier 
complete description extended generalization procedure la follows 
gamma input conjecture form cond 
gamma output set generalized versions conjecture gamma method maximal nonvariable subterm position arithjar tex deepak kapur subramaniam 
generate templates ars abstraction pair associated compute replacement triples set triples fg 
nonvariable subterm position linear term 
ii linear term compute number occurrences la repeated subtraction rt remainder 
iii replacement triple generated 
nx rt 
templates second components replace terms occurring cond discarded 

nonempty subset templates output generalized version obtained simultaneously replacing triples hp subterm position 
related seminal mechanizing induction boyer moore 
boyer moore discussed recursion analysis definitions formulation induction schemes conjecture 
heuristics manipulate induction schemes choice appropriate induction scheme conjecture developed 
methods implemented theorem prover nqthm 
methods purely syntactic exploit semantic information associated functions manner 
instance formulating induction scheme conjecture term delta delta delta write pp occupying argument positions measured induction template mind distinct variables template construct sound induction scheme 
general measured variable variable measured 
occurred measured positions changed recursion 
variables occurring occupying measured positions change recursion 
template applies term distinct variables 
examples discussed methods inapplicable 
instance definition gcd arguments gcd required justify termination definition measured positions 
changed recursive calls gcd definition sense 
conjecture form gcd induction scheme formulated corresponding term gcd arguments gcd 
example conjecture gcd arithjar tex new uses linear arithmetic automated theorem proving induction induction scheme formulated corresponding term gcd arguments changeable positions gcd distinct variables 
similarly motivating example divides divides nonvariable changeable position divides syntactically compatible defining divides 
nqthm provides mechanism performing user directed induction called hint directive 
user specify function definition generating induction scheme 
variables conjecture additional dummy variables required provided arguments function specified 
conjecture divides divides scheme generated la obtained nqthm hint directive divides divides induct shows power la induction scheme generation procedure 
induction schemes specified hint automatically generated linear arithmetic procedure 
description merging schemes follows lines 
schemes merged basis case merged scheme obtained negating conditions merged induction cases 
case rrl basis cases generated rules recursive calls right hand side 
consequently soundness induction cases considered merging 

concluding remarks shown decision procedure presburger arithmetic embodies knowledge numbers related representations effectively automate effective certain heuristics mechanizing induction 
focus generating induction schemes decision procedure 
briefly reviewed decision procedure checking completeness definitions associated cover sets induction schemes 
extension cover set method semantic analysis help linear arithmetic decision procedure enables automation proofs theorems require human guidance hints 
manually exercised extension quite bit number examples results extremely encouraging 
rrl supports decision procedure linear arithmetic plan extend procedure handle various applications discussed 
believe linear arithmetic procedure performing semantic analysis useful proof consistency popularly known inductionless induction approach 
nqthm corpus induction scheme definition function odd 
arithjar tex deepak kapur subramaniam proposed approach suggests new direction enhancing heuristics mechanizing induction semantic information data structures 
believe data structures finite sets multisets constructors null element inserting single element union operation play role similar constructors numbers 
possible design decision procedures heuristics converting different representations values data structure 
case data structures lists sequences 
need study investigate developing decision procedures data structures especially focusing aspects related convertibility representations 

boyer moore computational logic 
acm monographs computer science 

boyer moore computational logic handbook 
new york academic press 

boyer moore integrating decision procedures heuristic theorem provers case study linear arithmetic machine intelligence 

dershowitz termination rewriting symbolic computation 


jouannaud kounalis automatic proofs induction theories constructors information computation 

kapur automated tool analyzing completeness equational specifications proc 
international symposium software testing analysis issta seattle august 

kapur musser nie overview proof system theoretical computer science journal special issue formal methods databases software engineering ed 
vol 
october 

kapur narendran rosenkrantz zhang sufficient completeness complexity acta informatica 

kapur nie reasoning numbers proceedings th international symposium methodologies intelligent systems ismis charlotte north carolina october 

kapur zhang overview rewrite rule laboratory rrl computer mathematics applications 

walther combining induction axioms machine proc 
twelfth international joint conference artificial intelligence chambery france 

zhang reduction superposition induction automated reasoning equational logic 
ph thesis department computer science rensselaer polytechnic institute troy ny 

zhang kapur krishnamoorthy induction principle equational specifications proc 
ninth international conference automated deduction cade argonne il 
springer verlag lncs 
arithjar tex 
