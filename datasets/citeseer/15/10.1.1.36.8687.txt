haskore music notation algebra music paul hudak tom gadde bo yale university department computer science new haven ct hudak cs yale edu august developed simple algebraic approach music description composition called haskore 
framework musical objects consist primitive notions notes rests operations transform musical objects transpose tempo scaling operations combine musical objects form complex ones concurrent sequential composition 
simple notions embedded functional language haskell complex musical relationships expressed clearly succinctly 
exploiting algebraic properties haskore furthermore defined notion literal performance devoid articulation observationally equivalent musical objects determined 
basis useful properties proved commutative associative distributive properties various operators 
algebra music surfaces 
traditional music notation called common practice notation known limitations 
perspective particularly acute 
traditional notation unable adequately capture composer intentions particular structural aspects composition 

traditional notation biased music humanly 
surprising course obstacle trying notate music intended computer performance notation deficient inconsistent redundant 

known just contemporary ideas music theory difficult impossible express traditional notation 
basic concepts music theory example impossible express meta logic preferable common notation express musical objects interrelationships 

modern notions algorithmic composition impossible express traditional notation simply notion algorithm 
appear journal functional programming 
shortcomings experience computer music algorithmic composition led seek alternatives traditional music notation 
background theory design implementation high level programming languages particular functional languages led satisfying solution functional language haskell 
fact design new language system call haskore essentially set program modules written haskell allow user express musical ideas high level higher order extensible manner 
building results functional programming community haskell effort important advantages obvious avoid difficulties involved new programming language design time take advantage years effort went design haskell 
second resulting system extensible user free add new features substantive creative ways modifiable user doesn approach particular musical idea free change don force ideas user 
advantages obvious little design system useful composing music avoids problems traditional notation alluded earlier 
fortunately shall soon see haskell high level declarative nature suited music composition 
furthermore relying haskell underlying equational theory resulting system clearly defined algebraic properties allow example prove interesting properties musical objects transform way meaning preserved 
key aspect haskore objects represent musical ideas concrete implementations 
means prove property object property true music implementation 
similarly transformations preserve musical meaning preserve behavior implementations 
reason haskell called executable specification language programs serve role mathematical specifications directly executable 
limitations traditional notation simple example limitations traditional notation consider triplet tuple tuple tuple shown 
rules governing default interpretation phrases somewhat ad hoc example notes tuple tuple played space notes respectively tuple intended played space hin 
avoid problem traditional notation generalized implicit denominator explicit shown 
simple generalization freedom expressing interesting phrases shown example see traditional rules broken 
non conventional ratios allowed 

numerator required match number notes 
meaning annotated longer play notes space scale tempo factor 
numbers constrained integers 
ratio allowed irrational ones 

ratio greater tempo compression allowed tempo expansion 
note tempo relative indicates particular phrase rate notes played 
tempo composition just starting point may vary considerably depending context 
numerator denominator deficiencies redundancies tupling notation generalizations adopted haskore clearly move rapidly realm humanly 
example redundancy traditional notation consider convention note extend duration shown 
convention permit note shown 
meaning phrase allowed expressed generalized tuple notation shown 
fact single dotted note expressed similar way figures equivalent 
sense dotted notation redundant form tupling 
final example note traditional notation mechanisms allowing composer express perceives composition structure 
available ad hoc labeling techniques mechanism repeating phrases 
example way describe canon phrase structure phrase played simultaneously part delayed measures 
far sophisticated structures relationships exist compositions limited composer creativity 
haskore shows structure system 
provide details various translators reasonably straightforward functional programs converting internal datatypes file syntax required play haskore compositions conventional midi files ima score files jb score files ver print haskore compositions traditional notation cmn common music notation subsystem 
interest box labeled haskore 
haskell notation readers familiar number strongly typed functional languages miranda ml little trouble presentation 
completely unfamiliar functional languages urged read hf continuing 
written assuming familiarity functional programming general haskell particular different version written haskore haskore translator haskore translator haskore midi translator score file midi file player standard midi file midi instruments midi sound file player snd file haskore notation translator cmn cmn code notated score system diagram targeted mainly musicians 
musical ideas haskell urge reader question step decisions 
supreme theory music dictates decisions versions developed 
believe simplicity elegance version suitable purposes especially pedagogical ones reader may want modify better satisfy intuitions application 
document written literate programming style file generated executable haskell program 
file retrieved www ftp nebula cs yale edu pub yale fp papers haskore user find latest version haskore system consult readme file details 
basics basic musical idea note absence thereof describe haskell datatype data note note pitch dur rest dur deriving text type pitch int type dur float pitch type represents note pitch integer dur type represents pitch duration measured number beats 
additional note parameters volume timbre envelope may easily attached additional note constructor fields omit detail 
deriving text clause simply ensures generate textual representations note overloaded show operator 
convenience refer sequence notes line type line note basic primitives construct complex musical ideas 
example basic transformations may wish perform musical object ffl scaling tempo flavor generalized tupling described earlier 
ffl transposition melody 
addition desirable ways compose musical objects form ones 
particular may wish ffl play musical objects sequence 
ffl play musical objects parallel simultaneously 
convenient represent ideas haskell recursive datatype data music line line base case scale int int music scale tempo trans int music transpose pitches music music play sequence music music play parallel instr music specified instrument deriving text type string musical object haskore sequence notes line tempo scaling melodic transposition musical object sequential parallel composition musical objects 
final construction instr simply declares intent play instrument 
examples modest express quite complex relationships simply effectively 
convenience create functions generate pitch values familiar octave note names follows cf cs df ds ef es ff fs gf gs af bf bs pitch cf cs df ds ef es ff fs gf gs af bf bs note int 
int 
dur 
note alternative represent functions lose ability take musical objects apart analyze structure print structure preserving way alternative define separate enumerated datatype notes manipulating notes integers convenient prefer approach 
note oct pit note pitch oct pit pitch note expression note function applied duration returns note pitch duration similarly convenient names common durations rests wn hn qn en sn dur snr note wn rest wn note rest hn rest hn half note rest qn rest qn quarter note rest en rest en eighth note rest sn snr rest sn sixteenth note rest define longest boring piece music imagine infinite sequence single note note 
line note note note cycle note define function create similar line specified length int 
note 
line len take len consider nested shown 
expressed haskore follows pr pr pitch 
music pr scale scale qn scale en sn qn qn scale en line note pr scale scale en en scale scale en line note qq qq qq pr pr nested note clause pr capture recurring phrases 
play pr pr parallel middle middle respectively assuming middle th octave pr music pr pr pitch pr pitch expression form trans describes melody accompanied second voice perfect th higher 
similarly canon structure involving expressed delay delay dur 
music 
music delay line rest musical object may repeated ad simple function music 
music example infinite expressed way different contexts extract portion needed 
basic notions inversion retrograde retrograde inversion tone theory easily captured haskore definitions demonstrate assume transformations defined lines retro invert music 
music retro line line line reverse line invert line line line map inv line note head line inv note note inv retro invert invert retro final example compute duration beats musical object notion need section follows dur music 
dur dur scale dur float float dur trans dur dur dur dur dur dur max dur dur line line sum map line rest note dur instr dur float frominteger int 
float performance interpretation defined structure musical objects turn issue performance define temporally ordered sequence musical events type event time pitch type performance event type time float type float event captures fact time instrument plays pitch duration duration measured seconds beats 
performer give interpretation musical object know instrument perform time performance proper key tempo 
model performer function perform maps information musical object performance perform time key tempo 
music 
performance type key int type tempo float course kinds performances music interpreted different ways 
eventually may want develop fairly sophisticated performances interests call literal performance devoid articulation interpretation musical object 
define literal performance line time key tempo 
line 
performance notes case rest 
notes note 
notes foundation define literal performance entire musical object perform case scale 
perform float float trans 
perform 
perform perform dur 
merge perform perform line line 
line instr 
perform merge performance 
performance 
performance merge es es merge es es merge es es merge es es merge es es note perform invokes base case line 
function merge required preserve property performance temporally ordered sequence events dur defined section needed compute duration argument 
equivalence literal performances different musical objects literal performances expect equivalent 
example musical objects certainly equal data structures expect literal performances identical line line line define notion equivalence dur definition perform results quadratic time complexity 
efficient solution perform compute duration directly returning part result 
current approach clearer leave optimization exercise reader 
note merge compares entire events just start times 
ensure commutative desirable condition proofs 
definition musical objects equivalent written perform perform equality values haskell defined underlying equational logic 
useful things notion equivalence establish validity certain transformations musical objects 
transformation valid result transformation equivalent sense defined original musical object meaning preserving 
basic transformation treat axioms evolving algebra music 
example axiom scale scale scale prove axiom conventional equational reasoning proof perform scale scale perform scale unfolding perform perform unfolding perform perform simple arithmetic perform scale folding perform useful transformation validity proof axiom scale scale scale words tempo scaling distributes sequential composition 
proof perform scale perform unfold perform perform perform unfold perform perform scale perform scale fold perform perform scale scale fold perform dur perform simpler axiom axiom scale words unit tempo scaling identity 
equivalent phrases proof perform scale perform unfold perform perform simple arithmetic note proofs establish axioms involve definition perform 
contrast establish theorems proofs involve axioms 
example axioms needed prove theorem scale scale scale proof scale scale scale scale scale axiom scale scale axiom scale scale simple arithmetic scale axiom example fact justifies equivalence phrases shown 
interesting transformations haskore musical objects stated proved correct equational reasoning 
leave exercise reader proof axioms include axioms special cases 
axiom scale transpose additive 
scale scale scale trans trans trans axiom function composition commutative respect tempo scaling transposition 
scale scale scale scale trans trans trans trans scale trans trans scale axiom tempo scaling transposition distributive sequential parallel composition 
scale scale scale scale scale scale trans trans trans trans trans trans axiom sequential parallel composition associative 
axiom parallel composition commutative 
axiom line unit scale trans zero sequential parallel composition 
scale line line trans line line line line line line axiom line line line proofs axioms difficult earlier proof covers example section inductive proof included appendix 
chords far built musical objects lines notes better think terms chords 
course chord consisting notes equal duration expressed current framework line line line convenience define function turn arbitrary list notes chord follows note 
music foldr note mus 
line note mus line may preferable add chord constructor having type music datatype reasons justifying datatype 
case discussion rely decision 
think chord terms actual notes useful think terms chord quality coupled key played particular voicing 
example describe chord major triad root position root middle 
approaches put forth representing information intend cover 
describe basic representations leaving alternatives skill imagination reader 
pitch representation note represented distance fixed pitch 
obvious fixed pitch example represents major triad root position 
zero sense redundant course serves remind chord normal form 
example forming transforming chords may representation normalized normal form fact 
define example forte prescribes normal forms chords setting 
chord pitch normal form pitch zero subsequent pitches monotonically increasing 
represent chord sequence intervals 
major triad root position example represented interval returns origin 
pitch representation interval redundant allows define sense normal form chord interval normal form intervals greater zero equal negation sum 
case define chord type type chord pitch ask advantage computationally representations 
invertible linear transformation defined functions fact little advantage chord 
chord ch aux ch aux ns aux ns aux head ch chord 
chord ch aux ch aux aux ns aux ns fact prove theorem inverses sense chord ch pitch normal form ch interval normal form length ch ch ch ch operation may wish perform test equality chords done levels chord quality inversion account absolute equality normal forms guarantee unique representation equality chords respect chord quality inversion simple just standard overloaded equality operator lists 
hand measure equality chord quality need account notion inversion 
pitch representation inversion chord defined follows ps map subtract ps directly define function invert chord interval representation simply define terms functions defined determine chord normal form quality possibly different inversion chord normal form follows simply test chord equal chord inversions 
finite number inversions defined 
haskell ch ch take length ch iterate ch map ch ch ch take length ch iterate ch map ch example returns true pitch normal form second inversion 
haskore practice version haskore simplified pedagogical purposes 
haskore new language simply collection datatypes functions written haskell tendency evolve gained experience 
blessing curse 
blessing users constrained past design decisions easily adapt system meet current needs 
curse compositions written previous versions haskore run newer ones 
system stabilizing fairly rapidly section briefly describe specific changes extensions part new design 
changes primarily level music datatype associated interpretation perform various translators midi remain unaltered 
uncomfortable treatment line special led point include constructor chords suggested section providing base cases music datatype 
reflection convinced making special wrong 
note rest primitive music objects constructors build lines chords 
resulting datatype data music note pitch dur base case rest dur base case music music play sequence music music play parallel stream lined allows write simple definitions line chord music 
music line foldr rest chord foldr rest wish convenient list representation notes 
music datatype extended annotations allow expressiveness notes larger phrases data music note pitch dur phrase music attributes defined data volume float timbre timbre envelope envelope data dyn dynamic art articulation orn data dynamic accent int int int data articulation float float breath data turn note annotations borrowed traditional common practice notation may useful composer 
immediately pose difficult issues respect interpretation encountered far longer clear notion literal performance valid anymore 
traditional terms image human performance complicating situation 
general articulations subjectively interpreted humans usually played time musician 
phrase expressed notion musical events overlapping slightly note preceding note overlap vary context 
composer computer music may fact wish specify details constructors listed provided numeric arguments specify degree articulation expressed 
note interpretation annotations instrument dependent example phrase interpreted quite differently piano versus say violin 
dealt problem treating instruments pair functions type instrument pitch 
dur 

event 
music 
music interpret individual notes phrases 
relevant lines revised definition perform look perform case note nas 
fst nas perform notes phrase pas 
perform snd pas 
object oriented approach instrument definition permit prove properties interpretation note phrase attributes specific instruments attempted 
event datatype way extended express aspects dynamics timbre arise interpretation extended music datatype described earlier 
aid construction new instruments defined default instruments giving default interpretations things complex instruments may derived 
defaults defined capture certain classes instruments string members classes tend constrained physical features 
related research proposals put forth programming languages targeted computer music composition dan sch col ak hs cr fact difficult describe 
surprisingly pure functional language exception done uses pure lambda calculus approach music description bears strong resemblance effort unfortunately implemented 
related approaches variants lisp notably dannenberg fugue language operators similar emphasis instrument synthesis note oriented composition 
fugue highlights utility lazy evaluation certain contexts extra effort needed lisp non strict language haskell essentially comes free 
efforts lisp utilize lisp primarily convenient vehicle embedded language design applicative nature lisp exploited example common music user find large number macros difficult impossible functional style 
aware computer music language shown exhibit kinds algebraic properties demonstrated haskore 
languages investigated useful distinction music performance property find especially attractive haskore design 
hand balaban describes notion apparently programming language music structure provides various operators look similar bal 
addition describes operation called flatten resembles literal interpretation perform 
interesting translate ideas haskell match 
surprisingly find closely related music henderson functional geometry functional language approach generating computer graphics hen 
find structure spirit similar importantly clear distinction object description interpretation calling musical objects performance 
similar structure arya functional animation ary 
interesting avenues pursue research 
theoretical side need deeper investigation algebraic structure music express certain modern theories music haskore 
possibility expressing scale types far unstated assumption standard equal area investigation 
practical side potential graphical interface haskore appealing 
interested extending methodology sound synthesis 
primary goal currently continue haskore vehicle interesting algorithmic composition example see hb 
proof axiom state simple lemma proof omitted dur line note ns dur line ns dur line rest ns dur line ns lemma proof axiom follows pf line line pf line pf dur line line proceed induction 
basis pf line pf dur line line play pf dur line line pf dur line line pf dur line line pf line pf line proving basis case 
induction step ns pf line ns pf dur line ns line play ns pf dur line ns line point possibilities note note play note ns pf dur line note ns line play note ns pf dur line ns line play ns pf dur line ns line pf line ns pf dur line ns line pf line ns pf dur line ns line pf line ns line pf line ns induction hypothesis play ns play note ns play pf line completing proof induction step note 
proof case rest identical omitted 
ak anderson 
formula programming language expressive computer music 
denis editor computer generated music 
ieee computer society press 
ary arya 
functional animation starter kit 
journal functional programming 
bal balaban 
music structures interleaving temporal hierarchical aspects music 
balaban ebcioglu editors understanding music ai pages 
aaai press 
col 
computer music performance 
proc 
int computer music conference pages 
computer music association 
cr cointe rodet 
formes object time oriented system music composition synthesis 
proceedings acm symposium lisp functional pages 
acm 
dan dannenberg 
canon score language 
computer music journal 
dannenberg fraley 
functional language sound synthesis behavioral abstraction lazy evaluation 
denis editor computer generated music 
ieee computer society press 
forte 
structure music 
yale university press new haven ct 
hb hudak berger 
model performance interaction improvisation 
proceedings international computer music conference 
int computer music association 
hen henderson 
functional geometry 
proceedings acm symposium lisp functional 
acm 
hf hudak fasel 
gentle haskell 
acm sigplan notices may 
hin 
elementary training musicians 
associated music publishers new york edition 
hudak peyton jones wadler editors 
report programming language haskell non strict purely functional language version 
acm sigplan notices may 
hs 
system synthesis music scores petri nets music algebra 
denis editor computer generated music 
ieee computer society press 
ima midi detailed specification document version february 
jb jaffe boynton 
overview sound music kits computer 
pope editor tempered object pages 
mit press 
letz 
lambda calculus music calculi 
proceedings international computer music conference 
int computer music association 
sch 
pla composer idea language 
computer music journal 
ver 
manual audio processing system supporting programs 
technical report mit media lab 

