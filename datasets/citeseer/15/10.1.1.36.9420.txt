originally appeared supercomputing expanded version appeared comm 
acm august omega test fast practical integer programming algorithm dependence analysis william pugh dept computer science institute advanced computer studies univ maryland college park md pugh cs umd edu omega test integer programming algorithm determine dependence exists array conditions 
conventional wisdom holds integer programming techniques far expensive dependence analysis method resort situations decided simpler methods 
evidence suggests wisdom wrong omega test competitive approximate algorithms practice suitable production compilers 
experiments suggest programs average time required omega test determine direction vectors array pair secs mips workstation 
omega test extension fourier motzkin variable elimination linear programming method integer programming worst case exponential time complexity 
show situations polynomial methods accurate omega test low order polynomial time complexity 
omega test project integer programming problems subset variables just deciding 
applications including accurately efficiently computing dependence direction distance vectors 
fundamental analysis step advanced optimizing compiler software tools data dependence analysis arrays deciding array refer element conditions 
information determine allowable program transformations optimizations 
example determine program location array read written 
verify location written know writes done order 
extensive study methods deciding array data dependences bc ak ban wol ly 
focused approximate methods guaranteed fast compute exact results certain commonly occurring special cases 
situations approximate methods conservative accurately report actual dependences may report spurious dependences 
data dependency problems equivalent deciding exists integer solution set linear equalities inequalities form integer programming 
problem formulated integer programming problem shown 
example iw jw refer values loop variables time write performed ir jr refer values loop variables time read performed 
iw jw ir jr iw jw jr conventional wisdom holds integer programming techniques far expensive dependence analysis method resort situations decided simpler special case methods 
evidence suggests wisdom wrong 
describe omega test determines integer solution arbitrary set linear equalities inequalities 
describe experiments suggest programs average time required omega test determine direction vectors array pair secs mips workstation 
time required omega test analyze problem rarely twice time required scan array subscripts loop bounds 
indicate omega test suitable production compilers 
conceptually omega test combines new methods eliminating equality constraints extension fourier motzkin variable elimination integer programming 
detailed level omega test incorporates implementation details described section produce substantial speed improvements practice 
integer programming np complete problem omega test exponential worst case time complexity 
show section situations polynomial methods accurate omega test low order polynomial worst case time complexity 
dependence analysis structured decision problem tests simply answer 
compilers program restructuring tools need know data dependence direction vector wol data dependence distance vector mur describes relation iterations conflicting reads writes occur 
data dependence distance vector describes differences values common loop variables second access array element 
example code fragment dependence distance flow dependence dependence distance constant 
cases dependence direction vector describes possible combinations signs dependence distances 
determining dependence direction vectors may require exponential number calls dependence testing algorithm returns competitive dependence analysis method able short cut enumeration process see bc 
section show omega test modified project integer programming problems subset variables just deciding 
hand efficiently produce set constraints precisely concisely describes possible dependency distance vectors 
information directly deciding validity program transformations standard direction distance vectors quickly computed 
techniques described section 
omega test omega test determines integer solution arbitrary set linear equalities inequalities referred problem 
input omega test set linear equalities aixi inequalities aixi 
simplify presentation algorithms define aixi aixi standard representations denote set indices variables manipulated 
normalizing tightening constraints assume constraint manipulating normalized 
normalized constraint coefficients integers greatest common divisor coefficients including 
initial constraints involve rational coefficients scaled obtain integer coefficients 
algorithms described produce non integer coefficients 
normalize constraint compute greatest common divisor coefficients 
divide coefficients constraint equality constraint evenly divide constraint unsatisfiable 
constraint inequality constraint take floor dividing replace 
floors constant term inequalities 
problem rational integer solutions tightening may produce problem rational solutions making easier determine integer solutions 
equality constraints problem involving equality inequality constraints eliminate equality constraints producing new problem inequality constraints integer solutions original problem integer solutions 
course process decide problem integer solutions regardless inequality constraints 
generalized gcd test banerjee eliminate integer equality constraints 
approach better suited needs somewhat simpler appropriate situations additional equalities may added 
eliminate equality aixi suchthat aj 
eliminate constraint solving xj substitute result constraints 
index variable coefficient smallest absolute value ak 
define mod follows mod create new variable produce constraint ai mod xi note ak mod sign ak 
solve constraint xk xk sign ak sign ak ai mod xi substitute result constraints 
original constraint substitution produces ak ai ak ai xi ak equal ak ai ai ai xi substitution resulting constraints original problem normalization example elimination equality constraints terms divisible normalizing constraint produces ak ai ai mod xi original constraint absolute value coefficient absolute value original coefficient xk 
variables absolute value coefficients reduced rds previous value 
repeated applications rule eventually force unit coefficient appear allow eliminate constraint 
application methods shown 
inequality constraints process equality constraints eliminated 
check see inequality constraints directly contradict constraints 
find contradiction report problem solutions 
deal equality constraints efficiently inequality constraints 
find pair tight inequalities replace appropriate equality constraint revert methods dealing equality constraints 
checking contradictory pairs constraints eliminate constraints redundant single constraint redundant 
problem involves variable passed tests report integer solutions 
reduce problem integer programming problems fewer dimensions repeat process eventually getting problems dimension 
detecting real solutions fourier motzkin variable elimination fourier motzkin variable elimination de eliminates variable linear programming problem 
intuitively fourier motzkin variable elimination finds dimensional shadow cast dimensional object 
visual depiction fourier motzkin variable elimination 
dodecahedron shadow 
constraints specify dodecahedron shadow 
finding shadow intersection constraints 
finding shadow intersection constraints 
constraints resulting combination pairs upper lower bounds redundant 
consider dodecahedron 
want calculate shadow dodecahedron projected dimension xy plane shown 
dodecahedron shadow specified set constraints 
consider constraints lower bound bz upper bound az positive integers 
combine constraints get abz 
constraint shadow intersection constraints shown visually 
combining shadow intersection pair upper lower bounds figures obtain set constraints defines shadow original object 
shadow obtained way describes real solutions refer real shadow set constraints 
integer points real shadow set constraints know integer solutions set constraints 
note set constraints obtained includes redundant constraints 
performing fourier motzkin variable elimination square number constraints produce redundant constraints 
loop nests iteration spaces practice number constraints grow substantially 
attempting determine constraints redundant remove consideration usually cost effective 
detecting integer solutions fourier motzkin variable elimination may integer grid points shadow object object contains integer points consider shadow thin object 
ideally calculate integer shadow object shadow integer point shadow corresponding integer point object vis versa 
unfortunately 
integer shadow convex region may convex region 
developed new methods practice 
approach informally visualized finding shadow translucent object thicker parts object cast darker shadow 
define dark shadows appropriately guarantee integer point dark shadow integer point object 
example reconsider previous example dodecahedron dodecahedron illustrate difficulty finding integer shadows 
dodecahedron shown checking integer points dark shadow 
shadow cast translucent flattened dodecahedron 
view integer points inside flattened dodecahedron inside shadow 
overhead view showing integer points flattened dodecahedron point dark shadow necessarily integer point flattened dodecahedron integer point entire shadow real shadow 
integer points dodecahedron shadow shown figures 
integer points real shadow integer point object 
shadow integer point object 
shadow clearly dark part object unit thick 
coefficients constraints integers determine looser definition dark guarantee integer point dark shadow integer point 
determine dark shadow consider case integer solution integer solution abz multiple ab 
note positive integers 
case 
ab ab ab abi ab abi ab ab ab know integer solution dark shadow az bz note orb shadow real shadow identical 
dark real shadow resulting combination upper lower bound identical projection called exact projection 
happen example coefficients lower bounds coefficients upper bounds 
problems arise dependence analysis find exact projection 
method checking existence integer solutions set constraints 
decide variable eliminate 
choose variable perform exact projection possible minimize number constraints resulting combination upper lower bounds 
forced perform non exact reductions choose variable coefficients close zero possible 

calculate real dark shadows set constraints dimension 

real dark shadows identical integer solutions original set constraints iff integer solutions shadow 

integer solutions real shadow know integer solutions original set constraints 
integer solutions dark shadow know integer solutions original constraints 
know integer solution exists closely upper bound lower bound 
consider set planes parallel lower bound close lower bound 
integer solution closely upper bound lower bound lie planes 
computationally analyze problem follows know exists integer solution original set constraints exist pair constraints az bz ab abz ab abz check determining largest coefficient upper bound lower bound bz testing integer solutions original problem combined bz ab 
steps expensive complicated rarely need practice 
finding real dark shadow omega test nightmare omega test nightmare demonstrate show limitations techniques illustrate steps performed omega test example designed force omega test hard small problem 
consider inequalities exact projections perform decide eliminate coefficients slightly smaller 
shows constraints original problem unnormalized constraints real dark shadows 
real shadow integer solutions dark shadow check integer solutions close lower bound 
checking intersection original set constraints constraints contains integer point shown graphically 
solutions know integer solutions exist 
steps performed example appear complicated expensive 
example designed expensive resolve 
expect situations difficult arise frequently practice 
steps performed process implementation omega test takes milliseconds mips workstation perform 
worse possible problems variables constraints omega test take time proportional absolute value coefficients 
possibility expect situations arise frequently practice 
decision better methods dealing omega test wait experience gained type occur practice 
checking solutions tightly upper lower bound implementation details implementing omega test algorithmic ideas tricks substantially improved running time 
report ideas 
equalities inequalities represented vectors coefficients 
omega test crafted algorithms need deal integers rational number representation scheme needs 
eliminated equality constraints problem check variables lower bounds upper bounds 
refer variables unbounded variables 
performing fourier motzkin elimination unbounded variable simply deletes constraints involving 
delete constraints involving unbounded variables check produced additional unbounded variables 
repeat process unbounded variables remain 
normalize constraints assign hash keys constraint keys 
constraints modified time normalized 
constraint key constraint unique tag coefficients variables constraint constraints equal constraint keys differ constant term 
constraint keys negative positive key constraint negation key constraint coefficients variables negation coefficients variables 
refer opposing keys opposing constraints 
constraint keys assigned constraints constant expected time recording hash table constraint keys previously assigned 
compute hash key coefficients constraint index hash table hash keys guaranteed unique 
method computing hash keys designed opposing constraints opposing hash keys easy assign opposing constraint keys 
constraints normalized enter table constraint key 
allows check redundant contradictory tight constraint pairs constant time constraint 
process normalizing constraints check see constraints involve variable 
normalization multi variable constraints know system solutions return immediately 
examine variables decide variable eliminate 
perform exact projection perform elimination place adding deleting constraints current problem 
copy constraints zero coefficients eliminated variable new problem data structures real shadow dark add constraints produced fourier motzkin elimination 
constraints generated real dark shadow differ constant terms share adding constraints 
nonlinear subscripts integer programming dependence analysis methods allow properly handle symbolic constants lt hp types min max functions loop bounds wt conditional assignments lc 
example information value flow dependences program previous authors suggested handle loop invariant symbolic constants adding additional variables integer programming problem 
example problem generate integer programming program involving variables accommodate integer division integer remainder operations appear previously recognized 
assume expression appears program expressed div positive integer 
handle define new variable inequality constraints value similarly mod add inequality constraint value projection integer programming problems described section omega test simply decides solution integer programming problem 
section describe adapt omega test allow symbolic projection 
way omega test input integer programming program designation set protected variables omega test projects problems involving variables describe possible values variables integer solution values 
example projecting integer programming problem produces problem 
results projection process little complicated just described 
results may terms variables results terms set variables possibly including new variables methods calculating appropriate values values values example asked project integer programming problem omega test produce 
projection process may produce multiple problems 
example projecting problem produces changes omega test changes required simple simple 
quick changes current problem involves protected variables check integer solutions report projection 
performing inexact fourier motzkin elimination project dark shadow intersection original constraints equality checks near lower bounds 
words project subproblems look integer solution stopping integer solution verified 
expensive projecting system involves inexact projections 
believe occur practice problems arising dependency analysis 
perform fourier motzkin variable elimination protected variable 
require perform inexact projections situation performed exact projection protecting certain variables 
simple change involves equalities 
equality constraint aixi gcd coefficients non protected variables 
assume constraint normalized 
constraint involves protected variables 
standard methods eliminate constraint 
result elimination protected variable 
substitutions performed process recorded substitution log 
substitutions involve protected variables 
standard techniques section find substitution involving unprotected variables simplifies eliminates constraint 
create new protected variable add constraint ai mod xi eliminating new constraint transform original constraint gcd variables normalization 
report projection substitutions involving protected variables translated back equality constraints 
projection wildcards modification approach described refuse perform inexact reductions performing projection 
advantage report projected problem result 
disadvantage projected problem additional variables treated wildcards applications projection projection wildcards useful producing multiple results 
projection projection technique purposes 
describe occurred 
dependence direction distance vectors problem dependence analysis methods decision methods 
compilers program structuring tools need know data dependence direction vector wol data dependence distance vector mur describing relation iterations conflicting reads writes occur 
way determine dependence direction vectors calls decision procedure number loops surrounding 
order competitive dependence analysis method able short cut enumeration example see bc 
method take integer programming problem determining dependence exists introduce new variable dependence distance shared loop appropriate equality constraints define value variable 
project problem dependence distance variables 
projected system may better way describe dependence conditions dependence directions distances accurately describes information typically contained dependence direction vectors dependence distance greater 
alternatively projected set constraints determine efficiently dependence direction distance vectors 
scan dependences infer information possible constraints involving single dependence distance variable 
dependence distance variable uncoupled sign completely determined 
coupled variables unprotected project problem protected variables repeat process 
choose protected variable generate subproblems possible signs variable negative zero positive recursively explore 
example dependence distances array pair max max 
simplify consider sign 
considering sign gives know sign project problem obtaining gives direction vector 
returning consideration sign produces recursively analyzing possibilities sign produces direction vectors 
example difficult example seen testing requiring secs analyze 
run time checks compile time assertions projecting problem variables corresponding symbolic constants determined compile time produce predicate allow determine run time particular dependence dependence direction exists described kk 
alternatively compile time ask user predicate true 
summarizing array interprocedural analysis need characterize portions array may affected procedure call tri bk hk 
omega test obtain accurate summary locations array affected single assignment statement 
setting integer programming problem involving variables array index loop variables symbolic constants adding appropriate constraints loop bounds subscript expressions 
projecting problem variables array indices symbolic constants gives accurate summary locations array affected assignment statement 
summary limited convex polyhedron 
projected problem solutions locations changed 
details strides accurately represented 
omega test easily determine regions intersect 
omega test check region subset 
unclear omega test merge affected regions omega test convert exact affected regions approximate affect regions described bk hk regions merged 
determining loop bounds omega test determine appropriate loop bounds interchanging non rectangular loops 
integer programming projection perform described ai 
performance implemented omega test wolfe tiny tool wol 
handle min max expressions loop bounds symbolic constants compute exact sets direction vectors opposed compressed direction vectors normally generated tiny 
applied tool programs nasa nas benchmark suite tiny source files distributed tiny include cholesky decomposition lu decomposition versions wavefront algorithms contrived examples test programs 
programs nas benchmark extensive index arrays 
provide special treatment index arrays decided misleading include 
analysis array pairs different constant subscripts included figures reported cases detected scanning subscripts avoiding analysis time time required scan loop bounds 
standard optimizations induction variable recognition forward substitution performed hand 
compute input dependences input dependence dependence reads location array dependences array pairs share common loop 
timed omega test decstation mips workstation mips cpu 
shown results time array pair required analyze programs nasa nas benchmark program average time tile time mxm secs secs secs secs btrix secs secs secs secs vpenta secs secs analysis time secs copy time sec omega test performance simple regular convex complex third program nas benchmark substantially complicated real world fortran code involving loops nested deep subscripted arrays groups coupled loop indices 
feel confident represents worst case example analyzing deck fortran code excluding treatment index arrays 
results individual array pairs programs tested shown 
point timing result single array pair 
results somewhat machine independent fashion results plotted log log graph analysis time vs copying time time required just copy problem 
times randomly perturbed sec spread overlapping points 
diagonal lines drawn analysis time copying time copying time copying time 
analysis time total time required analyze array pair calculate appropriate direction vectors add dependences dependence graph excluding time required scan array subscripts loop bounds build constraints describe dependence array pairs 
range test programs break time spent omega test time spent dealing inequality constraints time spent dealing equality constraints time spent examining projected constraints construct direction vectors 
test cases required inexact fourier motzkin variable elimination 
analyze results set constraints describing dependence distances array pair analyzed remove redundant constraints cost effective normally 
simplified constraints array pair classified follows simple case involve coupled dependence distances 
regular case dependence distances coupled inequality constraints unit coefficients example 
convex case inequality constraints define convex region constraint non unit coefficient example constraint non regular 
complex case inequality constraints define non convex region 
encountered cases shown identical lower bound loop 
endfor endfor flow anti dependence distances example distances satisfy 
maydan hennessy lam memoization obtain better performance 
memoization added omega test 
cost computing hash key verifying cache hit times copying cost problem adding caching omega test produce significant savings typical simple cases may produce little speed improvement 
cost scanning array subscripts loop bounds build dependence problem typically times copying cost problem 
array pairs cost building dependence problem nearly large larger time spent analyzing resulting problem 
spent effort trying improve performance code builds dependence problems 
difficult imagine building dependence problem twice time required copy problem 
suggests majority array pairs dependence analysis algorithm significantly faster omega test lead significant speed improvements 
polynomial time bounds describe general time bounds parts omega test describe polynomial time bounds cases polynomial time algorithms accurate 
section denote number constraints denote denote number variables 
time taken methods section eliminate equality constraint mn log worstcase time coefficient largest absolute value constraint 
cost arises fact apply perform log substitutions eliminate constraint performing substitution takes nm time 
eliminating unbound variables takes mnp worst case time number passes required eliminate variables unbound 
variable eliminated pass 
normalizing constraints checking directly contradictory redundant constraints requires mn expected time time bound expected worst case hashing 
producing subproblems resulting fourier motzkin variable elimination takes time proportional size subproblems produced 
special cases normalization omega test checks see variables involved constraints variables 
checking contradictory constraint pairs produced contradiction know problem solutions need perform additional computation 
applies iff single variable constraint test applied applicable unique cases perfect club benchmark higher percentage duplicate cases considered separately 
acyclic test applied exactly cases omega test resolve just eliminating unbound variables performing exact projections increase number constraints process takes mn worst case time 
test applied unique cases encountered 
loop residue algorithm sho applied just cases constraint form xi xj xi orc xi 
set constraints property fourier motzkin variable elimination exact preserves property 
variables constraints form eliminating redundant pairs 
omega test take time resolve set constraints solved loop residue algorithm 
maydan hennessy lam loop residue algorithm applied unique cases encountered study perfect club benchmark 
maydan hennessy lam cases encountered determined constant tests banerjee generalized gcd tests 
remaining cases acyclic loop residue tests applied unique cases 
delta test works searching dependence distances easily determined propagating information intent making possible easily determine dependence distances precisely 
cases algorithm determine dependence distance miv tests omega test determine efficiently polynomial time combination solving equality constraints tightening inequality constraints converting tight inequality constraints equality constraints 
omega test treats dependence analysis problem single integer programming problem automatically achieves propagation effects delta test 
dependence analysis problem solved delta test resorting exponential algorithms approximate methods resorting refer miv tests solved polynomial time omega test 
study perfect spec benchmarks linpack percent cases solved requiring miv tests 
omega test solve effectively effective polynomial time problem solved combination single variable constraint test acyclic test loop residue test delta test expect able solve problems exactly efficiently 
related exact dependence analysis constraint matrix test wal simplex algorithm modified integer programming 
constraint matrix test fail terminate clear efficiently works practice 
lu chen describe lc integer programming algorithm dependence analysis 
method appears prohibitively expensive production compiler 
tri fourier motzkin techniques representing affected array regions interprocedural analysis 
fourier motzkin techniques expensive times longer simpler methods representing affected array regions 
implementations fourier motzkin variable elimination described dependence analysis 
power test described wolfe tseng wt combines banerjee generalized gcd test constraint tightening fourier motzkin variable elimination 
take special action performing inexact projection flag result possibly conservative 
fourier motzkin elimination maydan hennessy lam methods give exact answer 
back substitution determine sample solution 
sample solution integral suggest branch bound methods verify disprove existence integer solutions need implement far 
wolfe tseng wt maydan hennessy lam suggest due expense fourier motzkin variable elimination simpler tests situations known accurate 
irigoin ai describe fourier motzkin variable elimination determine loop bounds iterating iteration space described set linear inequalities projection described section 
significant overlaps 
performing apparently inexact projection perform elaborate process check projection inexact 
consider concept similar dark shadow force difference upper lower bounds 
definition safe dark shadow larger preferred choice 
generate dark shadow separate problem 
check see constraints dark shadow redundant respect real shadow 
dark shadow real shadow identical elimination exact 
projection exact add pseudo linear constraints real shadow obtain integer shadow 
pseudo linear constraints appear useful appropriate determining loop bounds 
difficult determining existence integer solutions 
irigoin ai give performance data algorithm 
report pips project mentions fourier motzkin variable elimination analyze dependences described ai 
methods fully described basic framework appears similar described section 
clear constraints ai handled 
point simple cases fourier motzkin variable elimination fast efficient 
state integer programming techniques dependence analysis incurs high cost acceptable pips production system 
state implementation dependence testing take noticeable amount time compared parallelization process 
source code availability language implementation omega test freely available anonymous ftp ftp cs umd edu directory pub omega 
files available include stand version omega test version wolfe tiny tool wol extended omega test 
conservative dependence analysis methods may demands vectorizing compilers 
transforming programs efficient massively parallel simd computers demanding task 
programs undergone transformations loop skewing loop interchange analysis problems substantially difficult encountered typical deck fortran 
studies convinced omega test fast practical method performing data dependence analysis adequate problems encountered vectorizing fortran code demands sophisticated program transformation tools 
performing projection integer programming problems exciting concept 
discussed determine efficiently information dependence direction distance vectors uses 
easier describe build program analysis transformation tools 
example determining loop bounds loop interchange ai extensive considers loop transformations uniform manner pug 
acknowledgments gave feedback especially michael wolfe anonymous referee provided detailed comments research group dave wonnacott borkar wayne kelly 
supported nsf ccr ccr packard fellowship 
author biography dr william pugh received ph cornell 
done research areas incremental computation randomized data structures implementation multiple inheritance programming languages hard real time systems compilers supercomputers 
received presidential young investigator award packard fellowship 
dr pugh currently assistant professor university maryland college park department computer science institute advanced computer studies 
cr categories optimizing compilers ai fran ois irigoin 
scanning polyhedra loops 
proceedings rd acm sigplan symposium principles practice parallel programming pages april 
ak allen kennedy 
automatic translation fortran programs vector form 
acm transactions programming languages systems october 
allen 
dependence analysis subscripted variables application program transformations 
phd thesis rice university april 
ban banerjee 
dependence analysis supercomputing 
kluwer academic publishers boston ma 
bc burke cytron 
interprocedural dependence analysis parallelization 
proceedings sigplan symposium compiler construction palo alto ca july 
bk kennedy 
technique summarizing data access parallelism enhancing transformations 
acm sigplan conference programming language design implementation june 
de dantzig 
fourier motzkin elimination dual 
journal combinatorial theory 
ken kennedy chau wen tseng 
practical dependence testing 
acm sigplan hk conference programming language design implementation 
paul havlak ken kennedy 
experience interprocedural analysis array side effects 
supercomputing 
hp polychronopoulos 
symbolic dependence analysis high performance parallelizing compilers 
proceedings third workshop languages compilers parallel computing august 
fran ois irigoin pierre jouvelot mi 
semantical interprocedural parallelization overview pips project 
proceedings international conference supercomputing pages june 
kk kong 
extending banerjee wolfe test handle execution conditions 
technical report dept ee cs stevens institute technology 
kuck muraoka chen 
number operations simultaneously executable programs resulting speedup 
ieee transactions computers december 
lc lu chen 
subdomain dependence test massive parallelism 
proceedings supercomputing new york ny november 
lt 
introducing symbolic problem solving techniques dependence testing phases 
proceedings nd international conference supercomputing st malo france july 
ly li yew 
results exact data dependence analysis 
gelernter nicolau padua editors languages compilers parallel computing 
mit press 
li yew zhu 
data dependence analysis multi dimensional array 
proceedings international conference supercomputing june 
maydan hennessy lam 
efficient exact data dependence analysis 
acm sigplan conference programming language design implementation pages june 
mur muraoka 
parallelism exposure exploitation programs 
phd thesis dept computer science university illinois urbana champaign february 
pug william pugh 
uniform techniques loop optimization 
proceedings international conference supercomputing pages cologne germany june 
sho shostak 
deciding linear inequalities computing loop residues 
journal acm october 
tri 
interprocedural analysis program restructuring 
csrd rpt 
dept computer science university illinois urbana champaign december 
wal wallace 
dependence multi dimensional array 
proceedings nd international conference supercomputing st malo france july 
wol wolfe 
optimizing supercompilers supercomputers 
phd thesis dept computer science wol university illinois urbana champaign october 
michael wolfe 
optimizing supercompilers supercomputers 
pitman publishing london 
wol michael wolfe 
tiny loop restructuring research tool 
proc international conference parallel processing volume pages 
wt wolfe tseng 
power test data dependence 
ieee transactions parallel distributed systems september 

