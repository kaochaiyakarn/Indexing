bebop symbolic model checker boolean programs thomas ball sriram rajamani software productivity tools microsoft research www research microsoft com slam 
design implementation empirical evaluation bebop symbolic model checker boolean programs 
bebop represents control ow explicitly sets states implicitly bdds 
harnessing inherent modularity procedural abstraction exploiting locality variable scoping bebop able model check boolean programs lines code hundreds procedures variables minutes 
boolean programs programs usual control ow constructs imperative language variables boolean type 
boolean programs contain procedures call value parameter passing recursion restricted form control nondeterminism 
boolean programs interesting subject study number reasons 
amount storage boolean program access point nite questions reachability termination undecidable general decidable boolean programs 
second boolean programs contain control ow constructs form natural target investigating model checking software 
boolean programs thought representation programs explicitly captures correlations data control boolean variables represent arbitrary predicates unbounded state program 
result boolean programs useful reasoning temporal properties software depend correlations 
created model checker boolean programs called bebop 
boolean program statement bebop determines reachable informally stated reachable initial state starts execution state boolean programs equivalent power push automaton accept context free languages 
decl main decl skip skip skip skip fi skip fi bebop microsoft 
done creating bdd variables done building transition relations label reachable path line state line state line state line state line state line state line state line state line state line state line state line state line state line state line state line state line state fig 

skip statement labelled reachable boolean program shown output bebop model checker 
eventually executes 
statement reachable bebop produces shortest trace leading possibly includes loops crosses procedure boundaries 
example 
presents boolean program procedures main recursive procedure 
program global variable procedure main local variable assigned complement procedure parameters 
question label reachable 
answer shown output bebop right 
tool nds reachable gives shortest trace reverse execution order rst line main line 
indentation line indicates depth call stack point trace 
furthermore line trace bebop outputs state variables scope just line 
trace shows order reach label trace lines value initially 
furthermore trace shows calls main procedure change value re emphasize shortest trace witnessing reachability label contributions 
adapted interprocedural data ow analysis algorithm reps horwitz sagiv rhs rhs rhs decide reachability status statement boolean program 
core idea rhs algorithm eciently compute summaries record input output behavior procedure 
summary hi oi computed procedure pr necessary body pr input context arises call pr 
summary pr consulted corresponding output context 
binary decisions diagrams bdds symbolically represent summaries binary relationships sets states 
program algorithm computes summary fg gi procedure rst called line state fg 
summary installed calls particular call line 
state fg propagates call line algorithm nds summary matches jump call descending analyze 
key point bebop distinguishes model checkers exploits locality variable scopes program 
time space complexity algorithm number edges interprocedural control ow graph boolean program maximal number variables scope program point program 
example program total variables global local formals 
statement variables scope main 
program global variables maximum local variables procedure running time 
number variables scope held constant running time bebop grows function number statements program total number variables 
result able model check boolean programs lines code note left unconstrained initial state program 
variable value unconstrained particular trace bebop output 
impossible initially follow trace 
fact example label reachable initially 
linear number statements boolean program 
variables minutes largest example report section variables 
second major idea bebop explicit control ow graph representation encode control ow boolean program bdds 
implementation decision important allows optimize model checking algorithm known techniques compiler optimization 
explain live ranges analysis reduce number variables support bdds represent reachable states program point 
overview 
section presents syntax semantics boolean programs 
section describes adaption rhs algorithm bdds solve reachability problem boolean programs 
section evaluates performance bebop 
section reviews related section looks 
boolean programs syntax presents syntax boolean programs 
comment noteworthy aspects 
boolean variables global declared outside scope procedure local declared inside scope procedure 
type boolean programming language variable declarations need specify type 
variables statically scoped variable identi er style arbitrary string characters 
form useful creating boolean variables names denoting predicates language qg 
constants language false true 
expressions built usual way constants variables standard logical connectives 
statement sub language stmt similar exceptions 
statements may labelled parallel assignment statement allows simultaneous assignment set values set variables 
procedure calls call value parameter passing 
boolean programs support return values procedures simplify technical presentation omitted description 
return value procedure modelled single global variable global variable assigned immediately preceding return copied immediately return local state calling procedure 
syntax description prog decl proc program list global variable declarations followed list procedure de nitions decl decl id declaration variables id za za identi er regular style identi er string string characters proc id id decl procedure de nition sequence statements stmt id stmt labelled statement stmt skip print expr goto id return id expr parallel assignment decider conditional statement decider od iteration statement assert decider assert statement id expr procedure call decider non deterministic choice expr expr expr binop expr expr negation expr id const binop logical connectives const false true fig 

syntax boolean programs 
statements ect control ow program assert 
note predicate statements decider model non determinism 
decider boolean expression evaluates deterministically evaluates non deterministically 
statements variables scope term statement denotes instance derived nonterminal stmt see 
boolean program statements procedures 
assign unique index statement range unique index procedure range denote statement index simplify presentation semantics assume variable names statement labels globally unique set variables globals set global variables formals set formal parameters procedure contains locals set local variables formal parameters procedure contains formals locals 
denote set variables scope includes locals globals 
control ow graph section de nes control ow graph boolean program 
boolean programs contain arbitrary intra procedural control ow goto useful semantics boolean programs terms control ow graph syntax 
presentation control ow graph simpler minor syntactic restriction call procedure pr boolean program immediately followed skip statement skip control ow graph boolean program directed graph gb succ set vertices vb successor function succ vb vb set vb contains vertex statement vertices vertex exit pr procedure pr vertices 
addition vb contains vertex err model failure assert statement 
procedure pr pr index rst statement pr 
vertex vb index procedure containing successor function succ de ned terms function ng pg maps statement indices lexical successor exists exit node containing procedure 
recursive de nition syntax tree see 
tree statement node parent 
sequence statements derived parent statement called containing sequence statement containing sequence index statement immediately sequence 
closest ancestor syntax tree stmt node statement containing sequence 
node exists index statement immediately containing sequence 
exit pr pr 
procedure call de ne guaranteed skip statement syntactic restriction previously placed boolean programs 
de ne succ value succ depends statement follows goto succ fjg statement labelled parallel assignment skip print statement succ return statement succ pr pr 
statement succ fsucc index rst statement branch fsucc index rst statement branch statement succ fsucc rst statement body loop fsucc 
assert statement succ fsucc fsucc err vertex 
procedure call procedure pr succ pr 
de ne succ exit vertices associated procedures 
exit vertex exit pr procedure pr succ exit pr statement call pr succ err fg 
vertex err successors 
control ow graph boolean program constructed time space linear number statements procedures program 
transition system boolean programs set valuation function associates boolean variable boolean value 
extended expressions see expr usual way 
example fx yg xjy 
function de ned 
example fx yg state pair hi vb valuation variables 
states set states intuitively state contains program counter values variables visible point 
note de nition state di erent conventional notion program state includes call stack 
projection operator maps state vertex hi extend operate sequences states usual way 
de ne set terminals 

vb procedure call 
valuation locals clear nite variables boolean variables 
terminals place holder triples introduced procedure call rst component triple call ret corresponding actions call return procedure second return point call third component keeps track values local variables calling procedure time call 
denote labeled transition state state formally holds hi states hi states conditions statement construct shown table 
explain table transitions skip print goto return 
statements exactly control ow successor 
vertices succ fwg de ne statement passes control single successor change state program 
transition parallel assignment passes control sole successor statement state changes expected manner 
transitions assert statements identical 
value decider associated statement skip print goto return xk ek xk ek assert pr ek 

pr globals exit pr 
globals 
table 
conditions state transitions hi hi vertex type see text full explanation 
successor chosen non deterministically set succ 
boolean expression evaluated current state determine successor 
transition call statement contains label 

records values local variables state state gives new values formal parameters called procedure values corresponding actual arguments state furthermore constrained global variables 
transition exit vertex exit pr 
successor output state constrained follows agree global variables agree 
local variables scope trace semantics position give trace semantics boolean programs context free grammar alphabet spec 
ms 









mm 

table 
production rules rules grammar 
es legal sequences calls returns boolean program may 
context free grammar tuple hn si set nonterminals set terminals set production rules start symbol 
program de ne grammar hfs mg rules si rules de ned productions table 
view terminals 

matching left right parentheses language set strings sequences partially balanced parentheses 
right parenthesis 
balanced preceding 
converse need hold 

component insures values local variables time return time corresponding call case boolean programs call value semantics 
nonterminal generates sequences balanced calls returns generates sequences partially balanced calls returns 
allows reason non terminating executions 
note number productions nite contains boolean variables 
assume contains distinguished procedure named main initial procedure executes 
state hi initial main variables take arbitrary initial values 
nite sequence 
trajectory 
trajectory called initialized trajectory initial state initialized trajectory projection vertices called trace semantics boolean program set traces 
state reachable exists initialized trajectory ends 
vertex vb reachable exists trace ends vertex boolean programs reachability interprocedural data ow analysis bdds section interprocedural data ow analysis boolean program control ow graph gb succ determines reachability status vertex vb describe algorithm show extended report short trajectories vertex reachable describe optimizations plan algorithm 
rhs algorithm generalized discussed generalized interprocedural data ow algorithm reps horwitz sagiv rhs rhs rhs 
main idea algorithm compute path edges represent reachability status vertex control ow graph compute summary edges record input output behavior procedure 
re de ne path summary edges follows path edges 
vertex vb 
path edge incident vertex pair valuations initialized trajectory main trajectory hv contain exit vertex exit exclusive 
vertex set path edges incident summary edge special kind path edges records behavior procedure 
summary edges 
vertex vb representing procedure call corresponding statement pr 
summary edge associated pair valuations local variables locals equal global variables change path edge entry exit callee 
suppose set path edges exit pr de ne lift pr set summary edges obtained lifting set path edges call respecting semantics call return valuations de ned respect set variables 
transitions table 
formally lift pr fh locals globals formals pr actuals vertex call set summary edges associated algorithm proceeds incrementally computed call site 
summary edges avoid revisiting portions state space explored enable analysis programs procedures recursion 
call set vertices vb represent call statements 
exit set exit vertices vb condb set vertices vb represent conditional statements assert 
transfer functions 
vertex condb exit associate transfer function transfer vertex condb associate transfer functions transfer true transfer false de nition functions table 
sets pairs valuations join image set respect transfer function formally join fh tg 
processing calls addition applying transfer function algorithm uses function takes set path edges self loops targets edges 
formally fh sg 
generalization rhs algorithm shown 
algorithm uses worklist computes path edges summary edges directed demand driven manner starting entry vertex main vertex initially known reachable 
algorithm path edges compute summary edges vice versa 
implementation bdds represent transfer functions path edges summary edges 
usual bdds boolean expression denotes set states 
set pairs states easily represented single bdd primed versions variables represent variables second state 
transfer functions path edges summary edges sets pairs states represent manipulate bdds 
termination algorithm set path edges vertex empty reachable 
reachable generate shortest trajectory described section 
global worklist procedure propagate insert worklist procedure reachable gb vb fg fg main fh valuation globals local variables worklist main worklist remove vertex worklist switch case propagate join transfer propagate join case lift propagate join ni case condb propagate join transfer true propagate join transfer false case vb condb join transfer propagate ni fig 

model checking algorithm 
transfer skip print goto return xk ek 
xk ek assert transfer true transfer false pr ek xk ek xk formal parameters pr 
table 
transfer functions associated vertices 
derived directly transition rules table generating shortest trajectory reachable vertex describe simple extension algorithm keep track length shortest hierarchical trajectory needed reach state vertex reachable produce shortest initialized hierarchical trajectory ends hierarchical trajectory jump procedure calls summary edges 
formally nite sequence 
hierarchical trajectory hv hv call 
vertex 
path edge set hierarchical trajectories start main enter procedure valuation reach valuation exiting 
note hierarchical trajectory comprised intraprocedural edges summary edges edges represent calling procedure edges representing return procedure keeping path edges incident single set partition set sets path edge shortest hierarchical trajectory length set fr called set rings associated rings generate shortest hierarchical trajectories 
vertex reachable nd smallest ring exists 
pick arbitrary path edge depending type vertex subcases skip immediately call look predecessor exists path edge join fh ig transfer contains skip immediately call say vertex look path edge join fh ig contains case nd caller suitably lift suitable path edge 
formally nd vertex call call procedure exists path edge satisfying transfer 
repeating process vertex path edge guaranteed reach entry main steps 
may traverse summary edges process 
expand summary edges demand produce hierarchical error trajectory shown bebop output 
optimizations basic algorithm described implemented bebop model checker 
section describe optimizations ideas compiler optimization asu substantially reduce size bdds needed perform analysis 
live ranges 
path starting vertex control ow graph gb variable de ned variable said live said dead value ow variable 
variable live vertex need record value bdd 
consider boolean program void main decl live live live live program declares refers variables variables live time 
example statement labelled values variables ow statements 
result bdd rst statement need track values variables mod ref sets 
traditional mod ref modi cation analysis program determines variables modi ed referenced procedure pr procedures calls transitively 
pr procedure pr procedures calls transitively modi es global variable may scope pr may fact live pr procedure pr change value result needed record remains unchanged summary pr 
evaluation section evaluation bebop series synthetic programs derived template shown 
template allows generate boolean programs 
boolean program global variable procedures procedure main procedures form level instances body procedure level replaced call procedure level 
instances body procedure level replaced skip 
result boolean program procedures main calls level twice level calls level twice level procedure choice depending value loop executed implements bit counter local variables calls succession level procedure 
level procedure skip statements executed 
level procedure global variable negated 
program generated template variables visible program point regardless note initialized bebop explore possible values ran bebop compute reachable states boolean programs measured running time peak memory 
shows running time bebop seconds varies decl void main level level reach skip skip fi void level decl elsif elsif fi od fi running time cu cmu peak live bdd nodes fig 

boolean program template performance test performance results 
shows peak memory usage bebop varies curves represent di erent bdd packages cu package colorado university som cmu bdd package carnegie mellon university lon 
note program variables 
model checking program takes minute half cmu package half minutes package 
times quite reasonable considering large number variables relative traditional uses bdds 
space measurements taken package provides detailed statistics bdd space usage 
expected peak memory usage increase linearly sublinear behavior observed due frequent garbage collection larger expected running time increase linearly shows running time increases quadratically quadratic increase running time unexpected time complexity model checking program variables scope program point 
pro ling runs reading code bdd packages quadratic behavior arises due ineciency implementation bdd substitute bdd package 
bebop calls bdd substitute inner loop variable renaming essential component forward image computation 
model checking bdd manager variables interested substituting variables small bdd substitute 
regardless bdd substitute consumes time 
cmu packages ineciency 
ine ciency xed bdd substitute believe running time bebop vary linearly related model checking nite state machines studied problem model checkers smv mcm mur dil spin hp cospan vis mocha developed 
boolean programs implicitly unbounded stack identical expressive power pushdown automata 
model checking problem pushdown automata studied sb bem 
model checkers push automata written 
boolean programs approaches away data concentrate control 
result spurious paths arise models due information loss data correlations 
connections model checking data ow analysis interpretation explored sch cc 
rhs algorithm rhs rhs builds earlier interprocedural data ow analysis ks sp 
shown algorithm generalized model checking procedure boolean programs 
choice hybrid representation state space bebop explicit representation control ow implicit bdd representation path edges summary edges novel 
exploiting design modularity model checking recognized key scalability model checking ah ag mcm 
idea harnessing inherent modularity procedural abstraction exploiting locality variable scoping eciency model checking software new known area data ow analysis rhs 
existing model checkers support exploit procedural abstraction 
result existing approaches extract models software forced inline procedure de nitions points invocation cdh lead explosion size model number variables 
bebop part larger ort called slam progress microsoft research extract models code check temporal properties software 
currently implementing methodology uses boolean programs iterative re nement process path simulation model check critical portions operating system code br 
ag alur grosu 
modular re nement hierarchic reactive modules 
popl principles programming languages 
acm press 
ah alur henzinger 
reactive modules 
lics logic computer science pages 
ieee computer society press 
alur henzinger mang qadeer rajamani 
mocha modularity model checking 
cav computer aided veri cation lncs pages 
springer verlag 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
bem bouajjani esparza maler 
reachability analysis pushdown automata application model checking 
concur concurrency theory lncs pages 
springer verlag 
brayton sangiovanni vincentelli somenzi aziz 
cheng edwards pardo qadeer ranjan villa 
vis system veri cation synthesis 
cav computer aided veri cation lncs pages 
springer verlag 
br ball rajamani 
boolean programs model process software analysis 
technical report msr tr microsoft research february 
bry bryant 
graph algorithms boolean function manipulation 
ieee transactions computers 
www research microsoft com slam cc cousot cousot 
temporal interpretation 
popl principles programming languages 
acm press 
cdh james corbett matthew dwyer john corina pasareanu robby shawn laubach hongjun zheng 
bandera extracting nite state models java source code 
icse international conference software engineering 
dil dill 
mur veri cation system 
cav computer aided veri cation lncs pages 
springer verlag 
esparza hansel 
ecient algorithms model checking pushdown systems 
technical report sfb bericht technische universitat munchen institut fur informatik february 
finkel willems wolper 
direct symbolic approach model checking pushdown systems 
infinity veri cation systems july 
hardin har el kurshan 
cospan 
cav computer aided veri cation lncs pages 
springer verlag 
hp holzmann peled 
state spin 
cav computer aided veri cation lncs pages 
springer verlag 
henzinger qadeer rajamani 
assume guarantee methodology case studies 
cav computer aided veri cation lncs pages 
springer verlag 
ks knoop ste en 
interprocedural coincidence theorem 
cc compiler construction lncs pages springer verlag 
lon long 
cmu bdd package 
emc cmu edu pub carnegie university 
mcm mcmillan 
symbolic model checking approach problem 
kluwer academic publishers 
mcm mcmillan 
compositional rule hardware design re nement 
cav computer aided veri cation lncs pages 
springerverlag 
rhs reps horwitz sagiv 
precise interprocedural data ow analysis graph reachability 
popl principles programming languages pages 
acm press 
rhs reps horwitz sagiv 
precise interprocedural data ow analysis applications constant propagation 
theoretical computer science 
sb ste en 
model checking context free processes 
concur concurrency theory lncs pages 
springerverlag 
sch schmidt 
data ow analysis model checking interpretation 
popl principles programming languages pages 
acm press 
som somenzi 
colorado university decision diagram package 
ftp vlsi colorado edu pub university colorado boulder 
sp sharir pnueli 
approaches interprocedural data analysis 
program flow analysis theory applications pages 
prentice hall 
