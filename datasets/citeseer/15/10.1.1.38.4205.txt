arpack users guide solution large scale eigenvalue problems implicitly restarted arnoldi methods 
sorensen yang draft july contents arpack important features 
getting started 
reverse communication interface 
availability 
installation 
documentation 
dependence lapack blas 
expected performance 

trouble shooting problems 
research funding arpack 
getting started arpack directory structure contents 
getting started 
example symmetric eigenvalue problem 
reverse communication interface 
post processing eigenvalues eigenvectors 
setting problem 
storage declarations 
stopping criterion 
initial parameter settings 
setting starting vector 
trace debugging capability 
general arpack naming conventions precisions types 
shift invert spectral transformation mode 
hermitian positive definite 
hermitian positive semi definite 
reverse communication structure shift invert 
contents shift invert generalized eigen problem 
computational modes 
computational modes real symmetric problems 
post processing eigenvectors 
computational modes real non symmetric problems 
post processing eigenvectors 
computational modes complex problems 
post processing eigenvectors 
implicitly restarted arnoldi method structure eigenvalue problem 
krylov subspaces projection methods 
arnoldi factorization 
restarting arnoldi method 
generalized eigenvalue problem 
structure spectral transformation 
eigenvector null space purification 
stopping criteria 
computational routines arpack subroutines 









lapack routines arpack 
blas routines arpack 
templates driver routines symmetric drivers 
selecting symmetric driver 
identify op driver 
reverse communication interface 
modify problem dependent variables 
postprocessing accuracy checking 
real nonsymmetric drivers 
selecting non symmetric driver 
identify op driver 
draft july contents reverse communication interface 
modify problem dependent variables 
postprocessing accuracy checking 
complex drivers 
selecting complex arithmetic driver 
identify op driver modified 
reverse communication interface 
modify problem dependent variables 
post processing accuracy checking 
band drivers 
selecting band storage driver 
store matrix correctly 
modify problem dependent variables 
modify variables necessary 
accuracy checking 
singular value decomposition 
svd drivers 
tracking progress arpack arpack routines dsaupd 
dnaupd 
znaupd 
draft july list figures example reverse communication interface arpack 
arpack directory structure 
reverse communication interface example program 
post processing eigenvalues eigenvectors 
storage declarations needed arpack subroutine dsaupd 
initiate trace debugging capability arpack 
output debug session dsaupd 
reverse communication interface shift invert 
reverse communication interface shift invert 
calling arpack subroutine dnaupd 
calling arpack subroutine dsaupd 
post processing eigenvectors 
calling arpack subroutine dnaupd 
post processing eigenvectors 
calling arpack subroutine znaupd 
post processing eigenvectors 
implicitly restarted arnoldi iteration implemented arpack 
algorithm implicitly shifted qr iteration 
algorithm step arnoldi factorization 
algorithm implicitly restarted arnoldi method iram 
set rectangles represents matrix equation arnoldi factorization 
unshaded region right zero matrix gamma columns 
performing gamma implicitly shifted qr steps hm middle set pictures illustrates qm columns qm nonzero qr iteration 
implicitly restarted length arnoldi factorization results discarding gamma columns 
high level implementation iram arpack 
list figures outline algorithm subroutine compute schur vectors possibly eigenvectors 
reverse communication structure 
compute av blocks 
draft july list tables list simple drivers illustrating arpack 
parameters top level arpack routines 
available precisions data types arpack 
double precision top level routines arpack subdirectory src 
various settings argument 
various settings argument 
description auxiliary subroutines arpack 
description lapack computational routines arpack 
description lapack auxiliary routines arpack 
description level blas arpack 
description level blas arpack 
description level blas arpack 
functionality symmetric drivers 
operators op 
eigenvalues interest symmetric eigenvalue problems 
functionality non symmetric drivers 
operators op 
eigenvalues interest non symmetric eigenvalue problems 
functionality complex arithmetic drivers 
operators op 
eigenvalues interest complex arithmetic eigenvalue problems 
band storage drivers symmetric eigenvalue problems 
band storage drivers non symmetric eigenvalue problems 
band storage drivers complex arithmetic eigenvalue problems 
sample output produced dsaupd 
description message level settings arpack 
chapter arpack arpack collection fortran subroutines designed solve large scale eigenvalue problems 
arpack stands arnoldi package 
arpack software capable solving large scale non hermitian standard generalized eigenvalue problems significant application areas 
software designed compute say eigenvalues user specified features largest real part largest magnitude delta storage 
auxiliary storage required 
set schur basis vectors desired dimensional eigen space computed numerically orthogonal working precision 
eigenvectors available request 
arnoldi process technique approximating eigenvalues corresponding eigenvectors general theta matrix 
appropriate large structured matrices structured means matrix vector product av requires usual floating point operations flops 
software algorithmic variant arnoldi process called implicitly restarted arnoldi method iram 
matrix symmetric reduces variant lanczos process called implicitly restarted lanczos method 
variants may viewed synthesis arnoldi lanczos process implicitly shifted qr technique suitable large scale problems 
standard problems matrix factorization required 
action matrix vector needed 
chapter give overview package 
chapter explains user quickly start arpack chapter gives comprehensive description utilize full capabilities arpack 
overview theory krylov subspace projection methods underlying algorithms implemented arpack subject chapter 
final chapter discusses implementation details main computational routines arpack 
appendix guide example driver routines templates 
experienced users familiar large scale eigenvalue computations may find productive go directly appendix locate suitable driver modify partic 
important features ular application 
appendix describes trace debugging capability easily turned order monitor progress output important intermediate computed quantities 
checkpointing guard loss intermediate computational results due system hardware failure possible 
description recover restart event fault provided appendix important features important features arpack ffl reverse communication interface 
ffl ability return eigenvalues satisfy user specified criterion largest real part largest absolute value largest algebraic value symmetric case standard problems action matrix vector av needed 
ffl fixed pre determined storage requirement suffices computation 
usually delta number eigenvalues computed order matrix 
auxiliary storage interaction devices required course computation 
ffl sample driver routines included may templates implement various spectral transformations enhance convergence solve generalized eigenvalue problem 
ffl special consideration generalized problem ax mx singular ill conditioned symmetric positive semi definite ffl eigenvectors schur vectors may computed request 
schur basis dimension computed 
schur basis consists vectors numerically orthogonal working accuracy 
computed eigenvectors symmetric matrices numerically orthogonal 
ffl numerical accuracy computed eigenvalues vectors user specified 
residual tolerances may set level working precision 
working precision accuracy computed eigenvalues vectors consistent accuracy expected dense method implicitly shifted qr iteration 
ffl multiple eigenvalues offer theoretical computational difficulty additional matrix vector products required expose multiple instances 
possible implementation deflation techniques similar employed implicitly shifted qr algorithm robust practical 
block method required user need draft july chapter 
arpack guess correct block size needed capture multiple eigenvalues 
getting started easy sample driver routines available 
simple drivers constructed illustrate arpack simplest cases finding eigenvalues corresponding eigenvectors largest magnitude 
simple drivers precisions data types provided may templates easily arpack 
chapter describes get started example driver programs 
reverse communication interface reverse communication interface important aspects design arpack 
interface avoids having express matrix vector product subroutine fixed calling sequence 
means user free choose convenient data structure matrix representation 
matrix available explicitly user free express action matrix vector subroutine call code segment 
necessary conform fixed format subroutine interface need communicate data common 
typical usage interface illustrated example 
usual reverse communication control returned calling program interaction matrix required 
action requested calling program simply perform task indicated reverse communication parameter ido case multiply vector held array workd location ipntr inserting result array workd location ipntr 
note call subroutine code segment simply meant indicate matrix vector operation place 
user free available mechanism subroutine accomplish task 
particular specific data structure imposed explicit representation matrix required 
needs supply action matrix specified vector 
availability codes available anonymous ftp ftp rice edu connecting directly url ftp ftp rice edu pub software arpack draft july 
installation continue call ido bmat workd info ido eq 
call workd ipntr workd ipntr return endif go example reverse communication interface arpack 
get software anonymous ftp connect ftp ftp rice edu login anonymous 
change directories pub people software arpack connect directly url described follow instructions readme file directory 
arpack software available netlib directory 
installation instructions readme file explain retrieve compressed tar file file 
options available 
retrieve file dist tar issue instruction dist tar tar automatically create directory named arpack 
directory contents blas documents examples lapack readme src util makefile draft july chapter 
arpack instructions proceed arpack readme file 
minor modifications file makefile issuing command lib compile subroutines create archive platform arpack directory 
platform 
denotes environment arpack library built 
example done sun sparc library archived sun instructions readme explain proceed 
disk storage requirements directory structure shown just megabytes 
documentation addition user guide complete documentation usage data requirements error warning conditions provided header source code subroutine 
sufficient documentation included readme files documents directory headers codes src examples subdirectories arpack 
user guide intended explain supplement documentation 
addition detailed description capabilities structure usage arpack document intended provide cursory overview implicitly restarted arnoldi lanczos method software 
goal provide understanding underlying algorithm expected behavior additional capabilities limitations software 
dependence lapack blas arpack dependent number subroutines lapack blas 
necessary routines distributed arpack software 
possible blas routines optimized machine place ones provided arpack 
list routines required sources available chapter 
local installations blas lapack available corresponding arpack subdirectories may deleted local installations may pointed 
care taken verify consistency version dates local installations version dates blas lapack routines provided arpack 
note lapack library system public release 
current release version 
certain public release installed strongly recommend compile link subset lapack included arpack 
expected performance arpack designed straightforward adaptation variety high draft july 
formance architectures including vector super scalar parallel machines 
intended portable efficient wide range computing platforms 
computationally intensive kernels expressed blas operations number remains fixed increases performance scale asymptotically level blas operation 
computational rates near maximum achievable peak possible multi vector processors cray workstation clusters sgi power challenge 
package written ansi standard fortran language exception 
include files exception 
associated trace debugging facility provided arpack 
arpack subroutines include files debugging timing purposes see appendix 
may easily deleted incompatible system 
parallel version arpack library available 
message passing layers currently supported mpi 
parallel arpack provided extension current arpack library 
installed cray intel delta paragon ibm sp sgi cluster network sun workstations 
package runs efficiently environments 
detailed information parallel arpack available report sorensen 
trouble shooting problems date list known problems available pub people sorensen arpack difficulties software reported arpack rice edu research funding arpack financial support provided part national science foundation cooperative agreement ccr arpa contract number daal administered army research office 
draft july chapter getting started arpack chapter describe basic structure arpack computing eigenvalues eigenvectors symmetric matrix 
difficult problems generalized problems require shift invert strategy sparse direct matrix factorization 
sophisticated modes operation described chapter 
example driver routines constructed problem type computational mode data type precision 
drivers may templates construct code specific application substituting appropriate data structures matrix factorizations solvers matrix vector products 
explanation drivers templates modify appendix templates driver routines 
various drivers provided address typical situation arising significant applications eigenvalue calculations 
description arpack directory structure 
sample drivers illustrate arpack simplest mode operation 
directory structure contents arpack software described chapter directory structure created 
top level directory named arpack 
directory structure pictured 
subdirectory contains sample files machine specific information needed building arpack library 
blas lapack subdirectories contain necessary codes respective software libraries 
documents subdirectory contains files example templates invoke different computational modes offered arpack 
example driver programs illustrate computational modes data types precisions may examples directory 
programs banded complex nonsymmetric symmetric eigenvalue problems singular value decomposition may directories 
getting started band complex sym svd respectively 
look readme files subdirectory information 
src subdirectory contains arpack source codes 
util subdirectory contain various utility routines needed printing results timing execution arpack subroutines 
archived library platform created completion installation instructions 
platform 
denotes environment arpack library built 
subroutines examples directory compiled archived platform aware blas lapack directories contain subset routines packages require additional megabyte memory compiled archived 
packages available system may delete blas lapack directories provided point ones installed system 
easily done modifying file described readme file top level directory arpack 
get started recommend user enter simple subdirectory issue commands output compile link execute program 
sample driver reverse communication interface arpack routine dsaupd finds eigenvalues eigenvectors symmetric matrix 
chapter discusses computing eigenvalues eigenvectors symmetric matrix simplest computational mode 
additional drivers available computational modes data types precisions 
additional driver programs examples subdirectories 
self contained may compiled executed similar manner described readme files 
driver serve template enable user create program dsaupd specific problem simplest computational mode 
driver programs various examples subdirectories intended way 
simple programs extensive documentation aid understanding conversion essentially principle structure apply driver programs 
getting started collection driver programs mentioned constructed illustrate arpack straightforward way solve frequently occurring eigenvalue problems 
purpose section corresponding simple codes provide means get started arpack quickly possible 
codes may templates easily altered solve new draft july chapter 
getting started arpack arpack directory structure 
arpack blas documents lapack src util examples simple band svd sym complex table list simple drivers illustrating arpack 
name purpose real symmetric driver real non symmetric driver complex hermitian general problems straightforward changes 
available simple drivers listed table 
codes may examples simple directory 
example symmetric eigenvalue problem section simple code discussed 
example drivers similar nature 
particular example program illustrates simplest computational mode arpack considerable detail 
shows arpack find eigenvalues corresponding eigenvectors standard eigenvalue problem ax real symmetric matrix 
main points illustrated ffl declare sufficient memory find nev eigenvalues 
set find nev eigenvalues largest magnitude lm 
may reset additional options sm la sa find eigenvalues interest 
draft july 
example symmetric eigenvalue problem ffl illustration reverse communication interface needed utilize top level arpack routine dsaupd 
routine computes quantities needed construct desired eigenvalues corresponding eigenvectors 
ffl extract desired eigenvalues eigenvectors quantities computed dsaupd arpack routine 
program driver subroutine dsaupd set solve problem ffl solve ax regular mode 
regular mode uses matrix vector products involving ffl matrix example derived central difference discretization dimensional laplacian unit square zero dirichlet boundary conditions 
ffl goal compute nev eigenvalues largest magnitude corresponding eigenvectors 
thing supplied order routine problem change array dimensions supply means compute matrix vector product av request dsaupd 
selection eigenvalues compute may altered changing parameter 
usage dsaupd simplest mode understood may wish explore available options solving generalized eigenvalue problems shift invert computational mode 
additional modes described sections chapter file ex sym doc documents directory 
reverse communication interface easiest way describe reverse communication interface example code segment shown 
storage declared input parameters initialized reverse communication loop fig 
entered repeated calls dsaupd 
return parameter ido indicate action taken 
simple example action taken matrix vector product see call av code segment 
sophisticated shift invert computational modes require complicated actions basic idea remains 
draft july chapter 
getting started arpack reverse communication loop continue repeatedly call routine dsaupd take actions indicated parameter ido convergence indicated exceeded 
call dsaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info ido eq 

ido eq 
perform matrix vector multiplication op user supply matrix vector multiplication routine takes workd ipntr input return result workd ipntr 
call av nx workd ipntr workd ipntr call dsaupd 
go reverse communication interface example program 
draft july 
example symmetric eigenvalue problem table parameters top level arpack routines 
ido reverse communication flag 
nev number requested eigenvalues compute 
ncv number lanczos basis vectors course computation 
bmat indicates problem standard bmat generalized bmat 
specifies eigenvalues computed 
tol specifies relative accuracy eigenvalues computed 
iparam specifies computational mode number iram iterations implicit shift strategy outputs various informational parameters completion iram 
post processing eigenvalues eigenvectors dsaupd indicates convergence taken place various steps may taken recover results useful form 
done subroutine illustrated 
setting problem set problem user needs specify number eigenvalues compute eigenvalues interest number basis vectors problem standard generalized 
items controlled parameters listed table 
simple codes described chapter set solve standard eigenvalue problem matrix vector products av 
generalized eigenvalue problems require selection mode 
addressed chapter 
value ncv nev setting ncv delta nev recommended 
options available include la sa algebraically largest smallest eigenvalues lm sm eigenvalues largest smallest magnitude simultaneous computation eigenvalues ends spectrum 
problem options may converge rapidly due approximation properties distribution eigenvalues convergence behavior quite different draft july chapter 
getting started arpack fatal errors occurred 
post process 
computed eigenvalues may extracted 
eigenvectors may computed desired 
indicated true 
routine called post processing modes may require complicated post processing mode 
true 
call select ldv sigma bmat nev tol resid ncv ldv iparam ipntr workd workl ierr eigenvalues returned column dimensional array corresponding eigenvectors returned iparam columns dimensional array requested 
orthogonal basis invariant subspace corresponding eigenvalues returned post processing eigenvalues eigenvectors 
draft july 
example symmetric eigenvalue problem various settings parameter 
example matrix indefinite setting sm require interior eigenvalues computed lanczos process may require steps resolved 
ncv computational required proportional delta ncv flops 
setting nev ncv optimal performance problem dependent 
possible best avoid setting nev way split clusters eigenvalues 
example smallest eigenvalues positive order gamma sixth smallest eigenvalue order gamma better ask nev nev smallest ones interest 
setting optimal value ncv relative nev completely understood 
choice depends underlying approximation properties distribution eigenvalues rule thumb ncv delta nev reasonable 
tradeoffs due cost user supplied matrix vector products cost implicit restart mechanism cost maintaining orthogonality lanczos vectors 
user supplied matrix vector product relatively cheap smaller value ncv may lead user matrix vector products decrease computation time 
chapter discuss issues detail 
storage declarations program set setting parameters maxn automatically declare space needed run dsaupd problem 
declarations allow problem size maxn computation nev eigenvalues ncv lanczos basis vectors 
user may override default settings example problem modifying maxn parameter statement 
integer maxn ldv parameter maxn ldv maxn parameters code segment listed declaring output arrays needed arpack subroutines dsaupd 
stopping criterion stopping criterion determined user specified parameter tol 
default value tol machine precision ffl things consider setting parameter 
absence considerations expect computed eigenvalue satisfy gamma tol delta draft july chapter 
getting started arpack local arrays double precision ldv workl workd maxn resid maxn ax maxn logical select integer iparam ipntr storage declarations needed arpack subroutine dsaupd eigenvalue closet typically smaller value tol required satisfy stopping criterion 
setting tol large may cause eigenvalues missed multiple tightly clustered 
possible set tol small convergence occurs 
may complications matrix non normal eigenvalues interest clustered near origin 
details provided chapter 
initial parameter settings reverse communication flag denoted ido 
parameter initially set call dsaupd 
course ido indicate action taken user control returned program calling dsaupd 
various algorithmic modes may selected settings entries integer array iparam 
important value iparam specifies computational mode 
selection simple example iparam indicating mode requires products 
convergence greatly enhanced shift invert computational modes provided 
additional modes described chapter 
addition iparam specifies shift selection strategy implicit restarting mechanism described chapter 
setting iparam example specify called exact shift strategy 
exact shifts recommended user reason priori information expert knowledge underlying specify alternative 
maximum number iterations allowed specified iparam 
specifying parameter user keep mind iteration draft july 
example symmetric eigenvalue problem include debug initiate trace debugging capability arpack 
costs approximately ncv gamma nev user supplied matrix vector products 
addition delta delta ncv delta ncv gamma nev flops needed associated iteration 
integer argument sets length array workl 
value set ncv delta ncv setting starting vector parameter info set initial call dsaupd user wants supply starting vector initializes 
normally default reasonable choice 
eigenvalue calculation sequence closely related problems convergence may accelerated suitable starting vector specified 
typical choices situation final value starting vector previously converged eigenvalue calculation vector column construct starting vector linear combination computed eigenvectors previously converged eigenvalue calculation 
starting vector supplied placed array resid info set entry dsaupd 
completion parameter info may contain value indicating iteration successful may contain nonzero value indicating error warning condition 
meaning nonzero value returned info may header comments subroutine dsaupd 
trace debugging capability arpack provides means trace progress computation proceeds 
various levels output may specified output level voluminous draft july chapter 
getting started arpack level 
code segment listed gives example statements may calling program initiate request output 
include statement sets storage declarations solely associated trace debugging feature 
parameter specifies number decimal digits width output lines 
positive negative value specifies columns respectively output 
parameter specifies logical unit number output file 
values remaining parameters indicate output levels indicated routines 
example indicates level output requested subroutine 
configuration give breakdown number matrix vector products required total number iterations number re orthogonalization steps estimate time spent routine phase computation 
displays output produced settings 
user encouraged experiment settings familiarity gained routines 
see appendix detailed discussion trace debugging capabilities 
draft july 
example symmetric eigenvalue problem symmetric implicit arnoldi update code version number version date summary timing statistics total number update iterations total number op operations total number operations total number reorthogonalization steps total number iterative refinement steps total number restart steps total time user op operation total time user operation total time arnoldi update routine total time routine total time basic arnoldi iteration loop total time reorthogonalization phase total time re start vector generation total time eigenvalue subproblem total time getting shifts total time applying shifts total time convergence testing output debug session dsaupd 
draft july chapter general arpack chapter describe complete structure reverse communication interface arpack codes 
numerous computational modes available including shift invert strategies designed accelerate convergence 
sophisticated modes described detail 
remaining ones quite similar principle require slightly different tasks performed reverse communication interface 
chapter structured follows 
naming conventions arpack data types precisions available described 
spectral transformations discussed 
spectral transformations usually extremely effective number problem dependent issues determine 
describe reverse communication interface needed exercise various shift invert options 
shift invert option specified computational mode summarized remaining sections 
subsection problem type sections quite similar repetitive 
basic idea understood probably best turn directly subsection describes problem setting interesting 
easiest way rapidly acquainted modes arpack run example driver routines see appendix supplied modes 
may templates adapted solve specific problems 
naming conventions precisions types user interface subroutines needed arpack 
implicitly restarted arnoldi method computing orthogonal basis selected invariant subspace set eigenvectors convergence 
spectral transformation transforms computed eigenvalues problem ax mx available combination problem type symmetric nonsymmetric data type real com 
shift invert spectral transformation mode table available precisions data types arpack 
letter precision data type single real double real single complex double complex plex precision single double 
letter denotes precision data type 
second letter denotes problem symmetric nonsymmetric 
table lists possibilities 
dnaupd routine problem double precision nonsymmetric standard generalized problem post processing routine conjunction dnaupd recover eigenvalues eigenvectors original problem convergence 
complex matrices letter regardless problem hermitian non hermitian 
table lists double precision routines available 
shift invert spectral transformation mode general problem may solved arpack compute selected eigenvalues corresponding eigenvectors ax mx real complex theta matrices 
shift invert spectral transformation enhance convergence desired portion spectrum 
generalized eigen pair oe gamma oem gamma mx gamma oe transformation effective finding eigenvalues near oe nev eigenvalues gamma oem gamma largest magnitude correspond nev eigenvalues original problem nearest shift oe absolute value 
transformed eigenvalues largest magnitude precisely eigenvalues easy compute krylov method 
may transformed back eigenvalues original problem 
direct relation oe draft july chapter 
general arpack table double precision top level routines arpack subdirectory src 
routine description dsaupd top level reverse communication interface solve real double precision symmetric problems 
post processing routine compute eigenvectors associated computed eigenvalues 
requires output converged application dsaupd 
dnaupd top level reverse communication interface solve real double precision non symmetric problems 
post processing routine compute eigenvectors schur vectors corresponding invariant subspace associated computed eigenvalues 
requires output converged application dnaupd 
znaupd top level reverse communication interface solve double precision complex arithmetic problems 
routine hermitian non hermitian problems 
post processing routine compute eigenvectors schur vectors corresponding invariant subspace associated computed eigenvalues complex arithmetic 
requires output converged application znaupd 
draft july 
shift invert spectral transformation mode eigenvector associated transformed problem generalized eigenvector original problem corresponding usually iram rapidly obtain approximations eigenvalues largest magnitude 
implement transformation provide means solve linear systems involving gamma oem matrix factorization iterative method 
general non hermitian hermitian 
easily remedied 
assumption hermitian positive definite implies bi linear form inner product 
positive semi definite singular semi inner product results 
easy show hermitian self adjoint respect inner product defined 
symmetry preserved force computed basis vectors orthogonal semi inner product 
implementing orthogonality requires user provide matrix vector product mv request application sections shall discuss familiar transformations standard eigenproblem 
positive semi definite recommend shift invert spectral transformation inner products possible 
far robust transformation ill conditioned singular 
little extra manipulation provided automatically semi inner product induced prevents corruption computed basis vectors roundoff error associated presence infinite eigenvalues 
ill conditioned eigenvalues generally associated singular highly ill conditioned detailed discussion theory may chapter 
shift invert spectral transformations effective standard problems possible 
particularly true interior eigenvalues sought desired eigenvalues clustered 
generalized problem provide way solve linear systems linear combination matrices order arpack 
possible user probably sparse direct method factor appropriate matrix 
iterative method linear system solves accuracy solutions commensurate convergence tolerance arpack 
usually slightly stringent tolerance required iterative linear system solves relative desired accuracy eigenvalue calculation 
main drawback shift invert spectral transformation coefficient matrix gamma oem typically indefinite hermitian case interior convex hull spectrum non hermitian case 
typically difficult situations iterative method sparse direct method parallel setting 
decision spectral transformation standard draft july chapter 
general arpack problem simple modes described chapter problem dependent 
simple modes advantage need supply matrix vector product av 
approach usually successful problems extremal non clustered eigenvalues sought 
non problems extremal means eigenvalues near extreme points vertices convex hull spectrum hermitian problems extremal means eigenvalues left right point spectrum notion non clustered separated difficult define going considerable detail 
simplistic notion separated eigenvalue hermitian problem gamma gamma 
ffl matrix vector product quite difficult code extremely expensive computationally probably worth trying simple mode seeking extremal eigenvalues 
remainder section discusses additional transformations may applied convert generalized eigenproblem standard eigenproblem 
appropriate conditioned hermitian non hermitian 
hermitian positive definite hermitian positive definite conditioned kmk delta km gamma modest size computing cholesky factorization ll converting equation gamma gammat provides transformation standard eigenvalue problem 
case request matrix vector product satisfied steps 
solve 
matrix vector multiply az 
solve lw convergence computed eigenvector gamma gammat converted eigenvector original problem solving triangular system transformation appropriate hermitian hermitian positive definite extremal eigenvalues sought 
gamma gammat hermitian symmetric positive definite smallest eigenvalues sought best reverse roles description ask largest algebraic eigenvalues largest magnitude 
convergence computed eigenvalue converted eigenvalue original problem relation draft july 
reverse communication structure shift invert hermitian positive semi definite hermitian positive semi definite direct transformation standard form required 
simple way obtain direct transformation equation standard eigenvalue problem cx multiply left gamma results gamma course perform transformation explicitly convert sparse problem dense 
possible obtain direct factorization matrix vector product involving called may accomplished steps 
matrix vector multiply av 
solve mw problem dependent issues may modify strategy 
singular interested eigenvalues near point oe user may choose gamma oem gamma inner products discussed previously 
case user transform converged eigenvalues eigenvalues original problem 
reverse communication structure shift invert reverse communication interface routine problem types 
eigenvalue problem double precision non symmetric subroutine dnaupd 
reverse communication loop structure described details nuances problem set discussed 
shall symbol op operator applied vectors arnoldi lanczos process stand matrix weighted inner product described previously 
shift invert spectral transformation mode op denotes gamma oem gamma denotes stand different matrices various modes 
basic idea set loop repeatedly calls 
return apply op specified vector exit loop depending value returned reverse communication parameter ido 
shift invert generalized eigen problem code segments shown figures illustrate reverse communication loop dnaupd shift invert mode generalized nonsymmetric eigenvalue problem 
loop structure identical symmetric problem 
change needed replace dnaupd dsaupd 
loop structure identical complex arithmetic subroutine znaupd 
draft july chapter 
general arpack call routine fac factor matrix sigma 
routine mv called repeatedly form mv 
routine solve repeatedly solve sigma single lu factorization provided fac 
call fac sigma reverse communication continue repeatedly call routine dnaupd take actions indicated parameter ido call dnaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info ido eq 
perform op inv sigma force starting vector range op 
workd ipntr workd ipntr call mv workd ipntr workd ipntr reverse communication interface shift invert 
draft july 
reverse communication structure shift invert call solve workd ipntr call dsaupd 
go ido eq 
perform op inv sigma saved workd ipntr 
workd ipntr workd ipntr 
call workd ipntr workd ipntr call solve workd ipntr call dsaupd 
go ido eq 
perform workd ipntr workd ipntr call mv workd ipntr workd ipntr call dsaupd 
go reverse communication interface shift invert 
draft july chapter 
general arpack example shown figures matrix assumed symmetric positive semi definite 
structure user supply routine fac obtain matrix factorization gamma oem may repeatedly solve linear systems 
routine needs provided place mv perform matrix vector product mv routine place solve solve gamma oem resulting linear systems previously computed factorization 
convergence taken place indicated ido reverse communication loop exited 
post processing arpack subroutine done recover eigenvalues corresponding eigenvectors original problem 
operating shift invert mode eigenvalue selection parameter normally set lm 
routine convert converged eigenvalues op eigenvalues original problem 
singular ill conditioned routine takes steps purify eigenvectors rid numerical corruption eigenvectors corresponding near infinite eigenvalues 
procedures done automatically routine operating computational modes described chapter 
user may wish construct alternative computational modes spectral transformations addressed modes specified chapter 
reverse communication interface easily accommodate modifications 
necessary construct explicit transformations eigenvalues op eigenvalues original problem situations 
computational modes problem set similar available computational modes 
previous section detailed description reverse communication loop specific mode shift invert real non symmetric generalized problem 
modes listed user strongly urged modify driver routine templates described appendix thing decide nature eigenvalues computed spectral transformation required compute 
formulate efficient means implement action operator op vector order accomplish spectral transformation 
decide weighted inner product advantageous 
relation eigenvalues op eigenvalues original problem understood order appropriate specification order recover eigenvalues interest original problem 
user specify number eigenvalues compute eigenvalues interest number basis vectors problem standard generalized 
items controlled parameters listed table chapter 
draft july 
computational modes call dnaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info 
calling arpack subroutine dnaupd 
setting nev ncv optimal performance problem dependent 
possible best avoid setting nev way split clusters eigenvalues 
rule thumb ncv delta nev reasonable 
tradeoffs due cost user supplied matrix vector products cost implicit restart mechanism 
user supplied matrix vector product relatively cheap smaller value ncv may lead user matrix vector products ira iterations decrease computation time 
convergence behavior quite different various settings parameter 
arnoldi process tends converge readily extreme points convex hull spectrum 
implicit restarting effective focusing isolating selected set eigenvalues near extremes 
principle implicit restarting isolate eigenvalues interior practice difficult usually unsuccessful 
interested eigenvalues near point oe interior convex hull spectrum shift invert strategy usually required reasonable convergence 
call dnaupd listed 
integer ido reverse communication flag specify requested action return dnaupd 
character parameter bmat specifies standard bmat generalized bmat problem 
integer specifies dimension problem 
character parameter specifies nev eigenvalues computed 
options differ depending hermitian non hermitian eigenvalue problem solved 
tables list different selections possible 
specification problem type described separately reverse communication interface loop structure type basic modes regular regular inverse shift invert standard generalized 
additional specialized modes symmetric problems buckling cayley real non symmetric problems complex shifts applied real arithmetic 
user encouraged examine sample driver routines modes 
integer nev indicates number eigenvalues compute tol specifies accuracy requested 
integer array iparam eleven entries 
input iparam set user wishes supply shifts implicit restarting default exact shift strategy requested 
entry iparam set user great deal knowledge spectrum iram underlying theory 
entry iparam set maximum number implicit restarts allowed 
cost implicit restart draft july chapter 
general arpack call dsaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info calling arpack subroutine dsaupd 
table various settings argument description la largest algebraic eigenvalues 
sa smallest algebraic eigenvalues 
lm eigenvalues largest magnitude 
sm eigenvalues smallest magnitude 
compute nev eigenvalues half spectrum 
nev odd compute high low 
step major iteration order delta ncv gamma nev flops dense matrix operations ncv nev matrix vector products av matrix output iparam contain number implicit restarts taken computation 
respect shift invert modes entry iparam important 
remaining entries iparam longer referenced output parameters 
legitimate values iparam differ problem type listed 
computational modes real symmetric problems reverse communication interface subroutine symmetric eigenvalue problems dsaupd 
subroutine called shown 
argument may settings listed table 
list spectral transformation options symmetric eigenvalue problems 
list specification op various modes 
iparam bmat settings listed name sample driver mode 
sample drivers listed may examples sym subdirectory 
draft july 
post processing eigenvectors 
regular mode iparam bmat 
driver dsdrv 
solve ax regular mode 
op 
shift invert mode iparam bmat 
driver dsdrv 
solve ax shift invert mode 
op gamma oei gamma 
regular inverse mode iparam bmat 
driver dsdrv 
solve ax mx regular inverse mode 
op gamma 
shift invert mode iparam bmat 
driver dsdrv 
solve ax mx shift invert mode 
op gamma oem gamma 
buckling mode iparam bmat 
driver dsdrv 
solve kx buckling mode 
op gamma gamma 
cayley mode iparam bmat 
driver dsdrv 
solve ax mx cayley mode 
op gamma oem gamma oem post processing eigenvectors final return dsaupd indicated ido error flag info checked 
info fatal errors occurred time postprocess get eigenvalues original problem corresponding eigenvectors desired 
case shown shift invert generalized subtleties recovering eigenvectors ill conditioned 
process called eigenvector purification 
prevents eigenvectors corrupted noise due presence eigenvectors corresponding near infinite eigenvalues see chapter 
operations completely transparent user 
general calling sequence shown 
input parameters bmat delta delta delta info precisely parameters appear calling sequence dsaupd 
important parameters altered final return dsaupd subsequent call 
draft july chapter 
general arpack fatal errors occurred 
post process 
computed eigenvalues may extracted 
eigenvectors may computed desired 
indicated true 
true 
call select ldv sigma bmat nev tol resid ncv ldv iparam ipntr workd workl ierr post processing eigenvectors 
negligible additional cost obtain eigenvectors 
orthonormal lanczos basis computed 
example basis overwritten eigenvectors array basis sets may obtained desired additional storage cost delta nev requested case separate nev array supplied 
approximate eigenvalues original problem returned ascending algebraic order array desirable retain lanczos basis storage issue user may elect call routine desired eigenvector store peripherally 
option computing selected set vectors single call 
input parameters specified ffl logical variable true 
eigenvectors requested false 
eigenvalues desired 
ffl character parameter specifies eigenvectors desired 
compute nev eigenvectors compute eigenvectors specified logical array select 
ffl sigma contain value shift iparam 
referenced iparam 
draft july 
computational modes real non symmetric problems call dnaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info calling arpack subroutine dnaupd 
table various settings argument description lm eigenvalues largest magnitude 
sm eigenvalues smallest magnitude 
lr eigenvalues largest real part 
sr eigenvalues smallest real part 
li eigenvalues largest imaginary part 
si eigenvalues smallest imaginary part 
computational modes real non symmetric problems subroutines solve non symmetric generalized eigenvalue problems real arithmetic 
routines appropriate general non symmetric matrix symmetric positive semi definite 
reverse communication interface routine non symmetric double precision eigenvalue problem dnaupd 
routine called shown 
specification nev eigenvalues controlled character argument 
table lists choices available 
different shift invert modes non symmetric eigenvalue problems 
modes specified setting parameter entry iparam mode mode 
list specification op various modes 
iparam bmat settings listed name sample driver mode 
sample drivers listed may examples subdirectory 

regular mode iparam bmat 
driver dndrv 
solve ax regular mode 
draft july chapter 
general arpack op 
shift invert mode iparam bmat 
driver dndrv sigma real shift 
solve ax shift invert mode 
op gamma oei gamma 
regular inverse mode iparam bmat 
driver dndrv 
solve ax mx regular inverse mode 
op gamma 
shift invert mode iparam bmat 
driver dndrv sigma real shift 
solve ax mx shift invert mode 
op gamma oem gamma 
complex shift invert mode iparam bmat 
driver dndrv sigma complex shift 
factor gamma oem complex arithmetic 
solve ax mx complex shift real arithmetic 
op gamma oem gamma mg 
complex shift invert mode iparam bmat 
driver dndrv sigma complex shift 
factor gamma oem complex arithmetic 
solve ax mx complex shift real arithmetic 
op gamma oem gamma mg note shift invert modes complex shifts see dndrv dndrv 
oe complex require factorization matrix complex arithmetic real 
advantage option standard shift invert mode complex arithmetic routine znaupd internal operations iram executed real arithmetic 
results factor savings storage factor savings arithmetic 
additional post processing somewhat complicated modes order get eigenvalues eigenvectors original problem 
modes recommended storage extremely critical 
draft july 
post processing eigenvectors fatal errors occurred 
post process 
computed eigenvalues may extracted 
eigenvectors may computed desired 
indicated true 
real part eigenvalue returned column dimensional array imaginary part returned second column corresponding eigenvectors returned nev columns dimensional array requested 
orthogonal basis invariant subspace corresponding eigenvalues returned true 
call select ldv sigmai bmat nev tol resid ncv ldv iparam ipntr workd workl ierr post processing eigenvectors 
post processing eigenvectors final return dnaupd indicated ido error flag info checked 
info fatal errors occurred time postprocess get eigenvalues original problem corresponding eigenvectors desired 
case shown shift invert generalized subtleties recovering eigenvectors ill conditioned 
process called eigenvector purification 
prevents eigenvectors corrupted noise due presence eigenvectors corresponding near infinite eigenvalues see chapter 
operations completely transparent user 
general calling sequence shown 
input parameters bmat delta delta delta info precisely parameters appear calling sequence dnaupd 
important parameters altered final return dsaupd subsequent call 
approximate eigenvalues original problem returned real part draft july chapter 
general arpack array dr imaginary part array di 
problem real complex eigenvalues come complex conjugate pairs 
negligible additional cost obtain eigenvectors 
orthonormal schur basis invariant subspace corresponding converged approximate eigenvalues computed 
example basis overwritten eigenvectors array eigenvectors corresponding complex conjugate pair computed real imaginary parts vector associated eigenvalue positive imaginary part columns respectively 
basis sets may obtained desired additional storage cost delta nev requested case separate nev array supplied 
cases may desirable basis sets 
eigenvector basis ill conditioned computed eigenvalues ill conditioned 
corresponding schur basis conditioned orthogonal basis approximate invariant subspace 
desirable retain schur basis storage issue user may elect call routine desired eigenvector store peripherally 
option computing selected set vectors single call 
input parameters specified ffl logical variable true 
eigenvectors requested false 
eigenvalues desired 
ffl character parameter specifies eigenvectors desired 
compute nev eigenvectors compute nev schur vectors compute eigenvectors specified logical array select 
ffl sigmai contain real imaginary portions respectively shift iparam 
referenced iparam 
computational modes complex problems section describes solution complex eigenvalue problems 
reverse communication interface subroutine double precision complex eigenvalue problem znaupd 
routine hermitian non hermitian problems 
routine called shown 
noted calling sequences znaupd differ slightly dnaupd 
main difference additional array required znaupd required 
occasionally znaupd complex hermitian problem eigenvalues returned small non zero imaginary part due unavoidable round draft july 
computational modes complex problems call znaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info calling arpack subroutine znaupd 
errors 
ignored significant respect eigenvalues largest magnitude computed 
little computational penalty non hermitian routines case 
additional cost compute eigenvalues hessenberg tridiagonal matrix 
problem configurations software designed solve size matrices small differences computational cost negligible compared major required 
integer ido reverse communication flag specifies requested action return dnaupd 
character parameter bmat specifies standard bmat generalized bmat problem 
integer specifies dimension problem 
character parameter possible values subroutine dnaupd listed table 
shift invert modes complex problems 
modes specified setting parameter entry iparam mode mode 
list specification op various modes 
iparam bmat settings listed name sample driver mode 
sample drivers listed may examples complex subdirectory 

regular mode iparam bmat 
driver 
solve ax regular mode 
op 
shift invert mode iparam bmat 
driver 
solve ax shift invert mode 
op gamma oei gamma 
regular inverse mode iparam bmat 
driver 
solve ax mx regular inverse mode 
op gamma 
shift invert mode iparam bmat 
driver 
solve ax mx shift invert mode 
op gamma oem gamma draft july chapter 
general arpack fatal errors occurred 
post process 
computed eigenvalues may extracted 
eigenvectors may computed desired 
indicated true 
true 
call select ldv sigma bmat nev tol resid ncv ldv iparam ipntr workd workl ierr post processing eigenvectors 
post processing eigenvectors final return znaupd indicated ido error flag info checked 
info fatal errors occurred time postprocess get eigenvalues original problem corresponding eigenvectors desired 
case shown shift invert generalized subtleties recovering eigenvectors ill conditioned 
process called eigenvector purification 
prevents eigenvectors corrupted noise due presence eigenvectors corresponding near infinite eigenvalues see chapter 
operations completely transparent user 
general calling sequence shown 
input parameters bmat delta delta delta info precisely parameters appear calling sequence znaupd 
important parameters altered final return znaupd subsequent call 
negligible additional cost obtain eigenvectors 
orthonormal schur basis invariant subspace corresponding converged approximate eigenvalues computed 
example basis overwritten eigenvectors array basis sets may obtained desired additional storage cost delta nev requested case separate nev array supplied 
cases may desirable basis sets 
eigenvector basis ill conditioned computed eigenvalues ill conditioned 
corresponding schur basis draft july 
post processing eigenvectors conditioned orthonormal basis approximate invariant subspace 
desirable retain schur basis storage issue user may elect call routine desired eigenvector store peripherally 
option computing selected set vectors single call 
input parameters specified ffl logical variable true 
eigenvectors requested false 
eigenvalues desired 
ffl character parameter specifies eigenvectors desired compute nev eigenvectors compute nev schur vectors compute eigenvectors specified logical array select 
ffl sigma contain value complex shift iparam referenced iparam 
draft july chapter implicitly restarted arnoldi method chapter presents overview theory krylov subspace projection underlying algorithms implemented arpack 
basic implicitly restarted arnoldi method iram quite simple structure closely related implicitly shifted qr algorithm dense problems 
discussion intended give broad overview theory develop high level description algorithms 
specific implementation details concerned efficiency numerical stability treated chapter 
information may 
basic iteration iram outlined familiar krylov subspace methods basic dense eigenvalue methods 
iteration shown hm theta upper hessenberg matrix vm residual vector orthogonal columns vm remainder chapter develop background understand origins motivation expected behavior algorithm 
discussion begins brief review structure algebraic eigenvalue problem basic numerical methods influence play direct role ira method 
basic disadvantages simple power method motivates krylov subspaces important projection idea related approximation properties 
lanczos arnoldi factorization introduced concrete way construct orthogonal basis krylov subspace provides means implement projection numerically 
implicit restarting introduced efficient way overcome intractable storage computational requirements original lanczos arnoldi method 
new technique turns truncated form powerful implicitly shifted qr algorithm implementation issues ultimate behavior closely tied understood method 
reduced storage requirements technique suitable large scale eigenvalue problems 
implicit restarting provides means approximate 
structure eigenvalue problem implicitly restarted arnoldi iteration implemented arpack 
ffl start build length arnoldi factorization avm starting vector ffl iteration convergence 
compute eigenvalues delta delta delta mg hm sort eigenvalues user selection criterion wanted set delta delta delta kg unwanted set delta delta delta mg 
perform gamma steps qr iteration unwanted eigenvalues delta delta delta mg 
shifts obtain 
restart length arnoldi factorization matrix consisting leading columns qm obtain length arnoldi factorization leading principal submatrix order set 
extend length arnoldi factorization length factorization 
eigenvalues user specified properties space proportional delta number eigenvalues sought 
generalized eigenvalue problems discussed detail 
arise naturally pde applications number subtleties respect numerically stable implementation spectral transformations 
spectral transformations context generalized problem means improve performance krylov methods 
structure eigenvalue problem brief discussion mathematical structure eigenvalue problem necessary fix notation introduce ideas lead understanding behavior strengths limitations algorithm 
discussion real complex number fields denoted respectively 
standard dimensional real complex vectors denoted symbols thetan thetan denote real complex matrices rows columns 
scalars denoted lower case greek letters vectors denoted lower case latin letters matrices capital latin letters 
transpose matrix denoted conjugate transpose symbol delta denote euclidean norm vector 
standard basis denoted set fe set numbers oe rank gamma called spectrum elements discrete set eigenvalues may draft july chapter 
implicitly restarted arnoldi method characterized roots characteristic polynomial det gamma 
corresponding distinct eigenvalue oe nonzero vector ax vector called right eigenvector corresponding eigenvalue pair called eigenpair 
nonzero vector called left eigenvector 
multiplicity root characteristic polynomial algebraic multiplicity dimension null gamma geometric multiplicity matrix defective non defective 
eigenvalue simple subspace thetan called invariant subspace ae straightforward show thetan thetak thetak satisfy ax xb range invariant subspace full column rank columns form basis subspace oe ae oe 
oe oe said similar similarity transformation similar diagonal matrix property equivalent non defective 
invariant subspaces central methods developed 
invariant subspaces generalize notion eigenvectors 
ax range span dimensional invariant subspace generally ax delta delta delta put delta delta delta range invariant subspace ax diag delta delta delta 
unitary upper triangular standard qr factorization aq qr gamma upper triangular matrix eigenvalues diagonal 
large condition number rkk gamma indicate eigenvalues invariant subspace sensitive perturbations introduced roundoff error finite precision computation 
story 
separation eigenvalues angles invariant subspaces come play 
symmetric hermitian case invariant subspaces corresponding distinct eigenvalues orthogonal completely decouple action matrix operator non symmetric case decoupling generally possible 
nature coupling completely described jordan form form usually extremely sensitive perturbations unsuitable basis computational algorithm 
schur decomposition provide means express coupling provides foundation development numerical algorithms 
states square matrix similar upper triangular matrix 
words linear operator unitary basis operator upper triangular matrix representation 
draft july 
structure eigenvalue problem theorem schur decomposition 
thetan unitary matrix upper triangular matrix aq qr diagonal elements eigenvalues schur decomposition fundamental structure hermitian normal matrices easily exposed lemma matrix thetan normal aa qq thetan unitary thetan diagonal 
matrix thetan hermitian qq thetan unitary thetan diagonal 
case diagonal entries eigenvalues columns corresponding eigenvectors 
columns called schur vectors general eigenvectors normal 
purposes algorithmic development structure fundamental 
fact known implicitly shifted qr algorithm designed produce sequence unitary similarity transformations iteratively reduce upper triangular form 
algorithm begins initial unitary similarity transformation condensed form av vh upper hessenberg tridiagonal case 
iteration shown 
algorithm implicitly shifted qr iteration 
input av vh upper hessenberg convergence select shift factor qr gamma hq vq unitary upper triangular qr factorization gammai 
easy see similar course iteration 
iteration continued subdiagonal elements converge zero schur decomposition approximately obtained 
standard implicitly shifted qr iteration unitary matrix formed 
computed indirectly product theta givens theta householder transformations bulge chase process 
elegant details efficient stable implementation digression 
may 
convergence draft july chapter 
implicitly restarted arnoldi method behavior iteration fascinating 
columns converge schur vectors various rates 
rates fundamentally linked simple power method rapidly convergent variant inverse iteration 
despite extremely fast rate convergence efficient storage implicitly shifted qr method suitable large scale problems proved extremely difficult parallelize 
large scale problems typically sparse structured matrix vector product av may computed time storage proportional method full similarity transformations quickly destroys structure 
storage operation counts iteration order considerable motivation methods require matrix vector products original power method provides simple means find dominant eigenvalue matrix performing matrix factorizations dense similarity transformations 
drawback eigen pair may convergence may slow non existent 
schemes block variants may employed overcome problem spectral transformations may accelerate convergence focus selected eigenvalues 
krylov subspaces projection methods methods underly arpack software derived class algorithms called krylov subspace projection methods 
methods intricate structure sequence vectors naturally produced power method 
examination behavior sequence vectors produced power methods suggests successive vectors may contain considerable information eigenvector directions corresponding eigenvalues largest magnitude 
expansion coefficients vectors sequence evolve structured way 
linear combinations vectors devised expose additional eigenvectors 
single vector power iteration simply ignores additional information sophisticated techniques may employed extract 
hopes obtain additional information various linear combinations power sequence natural formally consider krylov subspace span fv av gamma attempt formulate best possible approximations eigenvectors subspace 
reasonable construct approximate eigenpairs subspace imposing galerkin condition vector called ritz vector corresponding ritz value galerkin condition ax gamma draft july 
arnoldi factorization satisfied 
immediate consequences definition matrix columns form orthonormal basis ww denote related orthogonal projector define pap aw shown lemma quantities defined 
ritz pair ws bs 
gamma awk gamma wk gamma wk thetan mk ae 
ritz pairs minimum value gamma awk independent choice orthonormal basis facts valid dimensional subspace place additional useful properties may derived consequences fact form oe polynomial oe degree thorough discussion saad earlier papers 
facts important algorithmic consequences 
particular may shown invariant subspace vs av vr theta upper triangular matrix 
invariant subspace xs thetak ax diagonal 
algorithmic motivation seek convenient orthonormal basis wq provide means successively construct basis vectors 
possible construct theta unitary standard householder transformations bq upper hessenberg non negative subdiagonal elements 
possible show basis av vh fe fl follows galerkin condition turns det gamma 
observation shows possible obtain linear combination eigenvectors orthonormal basis invariant subspace ritz values oe ae oe corresponding ritz vectors eigenpairs second observation leads lanczos arnoldi process 
arnoldi factorization definition thetan relation form av draft july chapter 
implicitly restarted arnoldi method thetak orthonormal columns thetak upper hessenberg non negative subdiagonal elements called step arnoldi factorization hermitian real symmetric tridiagonal relation called step lanczos factorization columns referred arnoldi vectors lanczos vectors respectively 
development factorization purely consequences orthogonal projection imposed galerkin conditions 
straightforward illuminating derivation simply truncate reduction hessenberg form precedes implicitly shifted qr iteration equating columns sides complete reduction av vh alternative way write factorization av fi fi kf fi factorization may obtain approximate solutions linear system ax fi underlies gmres method 
purpose investigate factorization obtain approximate eigenvalues eigenvectors 
discussion previous section implies ritz pairs satisfying galerkin condition immediately available eigenpairs small projected matrix vector satisfies kax gamma av gamma sk jfi sj number jfi sj called ritz estimate ritz pair approximate eigenpair observe ritz pair ax rayleigh quotient assuming ksk associated rayleigh quotient residual ax gamma satisfies kr jfi sj hermitian relation may provide computable rigorous bounds accuracy eigenvalues approximations eigenvalues non hermitian possibility non normality precludes bounds say rayleigh quotient residual small jfi sj small information 
case ritz pairs exact eigenpairs step factorization may advanced step cost sparse product involving dense matrix vector products involving explicit steps needed form step arnoldi factorization listed draft july 
arnoldi factorization algorithm shown 
exact arithmetic columns form orthonormal basis krylov subspace orthogonal projection space 
finite precision arithmetic care taken assure computed vectors orthogonal working precision 
method proposed daniel kaufman stewart provides excellent way construct vector numerically orthogonal amounts computing correction gamma just step necessary 
simple test avoid correction needed 
algorithm step arnoldi factorization input put kv av ff put gamma ff ff fi kf fi fi av gamma dense matrix vector products step correction may accomplished level blas 
quite important performance vector parallel vector supercomputers 
level blas operation easily parallelized vectorized better ratio floating point computation data movement level blas operations 
information obtained process completely determined choice starting vector 
eigen information interest may appear gets large 
case intractable maintain numerical orthogonality basis vectors extensive storage required repeatedly finding eigensystem prohibitive cost flops 
failure maintain orthogonality leads numerical difficulties 
certain sense computation approximation projection indicated step way overcomes difficulties main source research activity krylov subspace projection methods 
computational difficulty stems fact kf columns span invariant draft july chapter 
implicitly restarted arnoldi method subspace nearly spans subspace kf small 
typically situation loss significant digits take place step numerical cancellation special care taken correction 
desirable kf small indicates eigenvalues eigenvalues perturbed matrix near easily seen re arnoldi relation gamma range invariant subspace perturbed matrix kek kf kf eigenvalues accurate approximations eigenvalues approximated eigenvalues insensitive perturbations conditioned 
convergence may lead loss numerical orthogonality updated basis care taken avoid 
subsequent arnoldi vectors forced orthogonal converged ones components converged directions re enter basis round effects quickly cause spurious copy previously computed eigenvalue appear repeatedly spectrum projected matrix treatment basic difficulty occupied number renowned researchers early 
context restarting proven important consequences development numerical software arnoldi method explored section 
restarting arnoldi method unfortunate aspect lanczos arnoldi process know advance steps required eigenvalues interest approximated ritz values 
particularly true problem wide range eigenvalues eigenvalues interest clustered 
spectral transformation lanczos steps required obtain selected eigenvalues 
order recover eigenvectors obliged store lanczos basis vectors usually peripheral device solve large tridiagonal eigenvalue problems step 
arnoldi process non hermitian case basis vectors stored cost hessenberg eigenvalue subproblem th step 
implicit restarting restarting alternative proposed saad polynomial acceleration scheme developed iterative solution linear draft july 
restarting arnoldi method systems 
saad proposed restart factorization vector preconditioned nearly dimensional invariant subspace interest 
preconditioning takes form polynomial applied starting vector constructed damp unwanted components eigenvector expansion 
iteration defined restarting current arnoldi factorization contains desired information 
saad ideas similar ones developed lanczos process paige cullum donath golub underwood 
appears karush proposed example restarted iteration 
arpack software approach restarting offers efficient numerically stable formulation 
approach called implicit restarting technique combining implicitly shifted qr mechanism step arnoldi lanczos factorization obtain truncated form implicitly shifted qr iteration 
numerical difficulties storage problems normally associated arnoldi lanczos processes avoided 
algorithm capable computing eigenvalues user specified features largest real part largest magnitude nk storage 
auxiliary storage required 
computed schur basis vectors desired dimensional eigen space numerically orthogonal working precision 
suitability method development mathematical software stems concise automatic treatment primary difficulties arnoldi lanczos process 
implicit restarting provides means extract interesting information large krylov subspaces avoiding storage numerical difficulties associated standard approach 
continually compressing interesting information fixed size dimensional subspace 
accomplished implicitly shifted qr mechanism 
arnoldi factorization length avm compressed factorization length retains eigen information interest 
accomplished qr steps apply shifts implicitly 
stage shift process results av delta delta delta orthogonal matrix associated shift may shown gamma entries vector zero oee 
equating columns sides yields updated arnoldi factorization av updated residual form fi oe 
starting point possible apply additional steps arnoldi process return original step form 
draft july chapter 
implicitly restarted arnoldi method shift cycles results implicit application polynomial degree starting vector 
gamma roots polynomial shifts qr process may selected filter unwanted information starting vector arnoldi factorization 
full details may 
choice shifts construction polynomial motivated fact starting vector fl ax av provide orthonormal basis invariant subspace range oe delta delta delta algorithm implicitly restarted arnoldi method iram 
input avm step arnoldi factorization convergence compute oe select set shifts oe information factor qr hm gamma hm vm fi oe vm hm step arnoldi factorization av apply additional steps arnoldi process obtain new step arnoldi factorization avm repeated update starting vector implicit restarting designed enhance components vector directions wanted eigenvectors damp components unwanted directions 
expansion linear combination eigenvectors fx effect polynomial restarting illustrated follows fl fl draft july 
restarting arnoldi method polynomial shifts applied time iterations th original expansion coefficient essentially attenuated factor eigenvalues ordered decreasing values leading eigenvalues dominant expansion remaining eigenvalues significant iteration proceeds 
adaptive choices shifts enhance isolation wanted components expansion 
wanted eigenvalues approximated increasingly iteration proceeds 
basic iteration listed algorithm diagrams figures describe iteration proceeds schematically 
algorithm discussion follows notation denotes leading theta submatrix observe iteration precisely implicitly shifted qr iteration 
columns vm hessenberg submatrix hm mathematically equivalent matrices appear full implicitly shifted qr iteration shifts sense implicitly restarted arnoldi method may viewed truncation implicitly shifted qr iteration 
fundamental difference standard implicitly shifted qr iteration selects shifts drive subdiagonal elements zero bottom shift selection implicitly restarted arnoldi method drive subdiagonal elements hm zero top 
important implementation details concerning deflation setting zero subdiagonal elements hm purging unwanted converged ritz values scope discussion 
details extremely important success iteration difficult cases 
complete details numerical refinements may 
iteration apply known polynomial restart 
roots polynomial known alternative implementation requires compute hm desired degree polynomial 
sequence householder transformations may developed form unitary matrix qe hm upper hessenberg 
details follow standard developments implicitly shifted qr iteration omitted 
shift selection strategy proved successful practice default arpack called exact shift strategy 
strategy computes oe sorts disjoint sets omega omega ritz values set omega regarded approximations wanted eigenvalues ritz values set omega taken shifts interesting consequence exact arithmetic step spectrum step draft july chapter 
implicitly restarted arnoldi method set rectangles represents matrix equation arnoldi factorization 
unshaded region right zero matrix gamma columns 
performing gamma implicitly shifted qr steps hm middle set pictures illustrates qm columns qm nonzero qr iteration 
implicitly restarted length arnoldi factorization results discarding gamma columns 
draft july 
generalized eigenvalue problem oe omega updated starting vector particular linear combination ritz vectors associated ritz values 
words implicit restarting scheme exact shifts provides specific selection expansion coefficients fl new starting vector linear combination current best estimates ritz vectors wanted eigenvectors 
implicit scheme costs matrix vector products explicit scheme require 
exact shift strategy viewed means damp unwanted components starting vector directly forcing starting vector linear combination wanted eigenvectors 
see information convergence iram possible shift strategies 
generalized eigenvalue problem typical source large scale eigenproblems discrete form continuous problem 
resulting finite dimensional problems large due accuracy requirements spatial dimensionality 
typically takes form ax mx finite dimensional approximation continuous operator obtained finite difference approximations spatial grid restriction operator finite dimensional subspace 
finite element case entries inner products respective basis functions finite dimensional space basis functions usually chosen entries typical row nonzero 
structures problems called stiffness matrix called mass matrix 
chemistry physics referred overlap matrix 
nice feature finite element approach discretization boundary conditions naturally incorporated discrete problem 
self adjoint case rayleigh principle preserved continuous discrete problem 
particular ritz values rayleigh quotients assures smallest ritz value greater smallest eigenvalue original problem 
basis functions provide sparsity usually orthogonal natural inner product usually diagonal 
typical large scale eigenproblems arise generalized standard problems positive semi definite 
matrix generally symmetric underlying continuous operator self adjoint non symmetric 
number ways convert generalized problem standard form 
motivation preserve symmetry 
positive definite factor ll eigenvalues gamma gammat eigenvalues eigenvectors obtained solving eigenvector standard transformation fine draft july chapter 
implicitly restarted arnoldi method wants eigenvalues largest magnitude preserves symmetry symmetric 
ill conditioned dangerous transformation leading numerical difficulties 
matrix factorization done anyway may formulate spectral transformation 
structure spectral transformation spectral transformations closely related inverse power inverse iteration techniques 
typically designed enhance convergence eigenvalues near selected point oe complex plane 
example interested computing smallest eigenvalues symmetric positive definite matrix oe reasonable choice 
convenient way provide spectral transformation note ax mx gamma oem gamma oe mx gamma oem gamma mx gamma oe symmetric maintain symmetry arnoldi lanczos process inner product easy verify operator gamma oem gamma symmetric respect inner product symmetric 
arnoldi lanczos process matrix vector product av replaced gamma oem gamma mv step replaced mf 
symmetric matrix symmetric tridiagonal 
process defined singular important consequences nonsymmetric 
shall refer process arnoldi process 
singular operator gamma oem gamma non trivial null space bilinear function semi inner product semi norm 
gamma oem assumed nonsingular null null vectors generalized eigenvectors corresponding infinite eigenvalues 
typically interested finite eigenvalues correspond non zero eigenvalues invariant subspace corresponding non zero eigenvalues easily corrupted components vectors arnoldi process 
arnoldi process refinements provide solution 
order better understand situation convenient note positive semi definite orthogonal matrix draft july 
generalized eigenvalue problem positive definite diagonal matrix order say 
sq square matrix order theta matrix original order observe non zero eigenvalue satisfies sx gamma hold 
note eigenvector leading vector eigenvector block triangular oe oe oe 
assuming full rank follows zero eigenvalue corresponding eigenvector implied 
zero eigenvalue algebraic multiplicity zero eigenvalue algebraic multiplicity geometric multiplicity course similar statements hold 
eigenvector null space purification observations hand possible see virtue arnoldi steps arnoldi sv vh fe mv mf introducing similarity transformation gives vh mq mq partitioning consistent blocking gives dv df side condition holds exact arithmetic zero eigenvalue appear converged ritz value argument shows arnoldi time doing arnoldi avoiding convergence zero eigenvalues 
round error due finite precision arithmetic cloud situation usual 
clear goal prevent components corrupting vectors starting vector form sv final approximate eigenvector components may purged replacing sx normalizing 
see effect note implies sx draft july chapter 
implicitly restarted arnoldi method components form purged 
final application may done implicitly ways 
note vs hs sx vhs fe fe approximate eigenvector replaced improved approximation fe kx fe sk fi correction originally suggested ericsson ruhe mean performing formal step power method residual error computed ritz vector respect original problem kax gamma je sj oe keeping mind spectral transformation usually quite large estimate indicates greater accuracy expected usual estimate 
purification arpack 
suggestion due spence implicit restarting zero shift 
recall implicit restarting zero shifts equivalent starting arnoldi process starting vector resulting ritz vectors multiplied 
applying implicit shifts leading submatrix order gamma provide updated ritz values 
additional explicit matrix vector products required 
ability apply zero shifts multiply implicitly important zero eigenvalues 
order completely components multiply equal dimension largest jordan block corresponding zero eigenvalue may incorporated arpack date 
spectral transformations studied extensively ericsson ruhe eigenvector purification strategy developed 
shift invert techniques play essential role block lanczos code developed grimes lewis simon nuances technique practical applications discussed thoroughly 
development eigenvector purification implicit restarting due spence 
stopping criteria section considers important question determining length arnoldi factorization computed approximate eigenvalues acceptable accuracy 
draft july 
stopping criteria hm ksk vm ka gamma gamma sk kf je sj suggests ritz pair approximation eigenpair component eigenvector hm small 
upper hessenberg matrix unreduced zero subdiagonal elements standard results imply je sj quantity quite small subdiagonal element far zero 
usually convergence takes place possible small 
quantity kf small eigenvalues hm approximations eigenvalues hermitian case estimate residual turned precise statement accuracy ritz value approximation eigenvalue nearest 
analogous non case possible information concerning non 
shall develop crude effective assessment accuracy estimate 
far sophisticated analysis available symmetric problem non symmetric case 
easily shown gamma ritz pair exact eigenpair nearby problem kf je sj small relative kak 
advantage ritz estimate kf je sj avoid explicit formation direct residual gamma accessing numerical accuracy approximate eigenpair 
hermitian case small residual implies accurate answer 
non hermitian case small kek necessarily imply ritz pair accurate approximation eigenpair theorem indicates accuracy expected ritz value approximation eigenvalue theorem suppose simple eigenvalue nearest eigenvalue denote left right eigenvectors respectively unit length 
gamma kek jy xj kek proof see wilkinson page 
number jy xj cosine angle determines conditioning nearly orthogonal eigenvalue highly sensitive perturbations nearly parallel insensitive perturbations 
hermitian matrices jy xj excellent approximation left right eigenvectors nearly orthogonal kek ffl kak ffl machine precision may draft july chapter 
implicitly restarted arnoldi method contain digits accuracy 
roughly rule thumb jy xj gammad ffl gammat leading gamma decimal digits agree question close ritz vector complicated fact eigenvector unique quantity 
scaling eigenvector nonzero complex number eigenvector 
reason better estimate positive angle eigenvector approximation 
theorem suppose aq schur form simple eigenvalue nearest eigenvalue corresponding eigenvectors 
positive angle kek sep kek proof see 
definition quantity sep theorem sep min kz gamma kzk norm kek trace frobenius norm 
refined indicator eigenvector sensitivity accounts clustering eigenvalues 
shows sep min oe gamma sep kr jy xj gamma jy xj bound defined nonzero conditioning eigenvector problem depends distance eigenvalues sensitivity notes upper bounds may significant estimates 
note symmetric may shown bound equality 
multiple eigenvalues clusters eigenvalues cause complications 
estimates may extended cases conditioning invariant subspaces angles invariant subspaces 
draw eigenvalues nonsymmetric matrix may sensitive perturbations introduced round error 
sensitivity tied departure normality matrix 
classic example matrix extremely ill conditioned eigensystem jm ffle jm bi diagonal number diagonal ones super diagonal 
eigenvalues perturbed jordan matrix satisfy gamma ffl quite contrary behavior eigenvalues normal draft july 
stopping criteria matrices 
knowledge nearness matrix nonnormal content stopping criterion assures small backward error non case 
strategy arpack ritz pair considered converged kf je sj max ffl tol delta satisfied 
kak implies satisfied kek test invariant scaling multiplication nonzero scalar 
backward error defined smallest norm perturbation deltaa ritz pair eigenpair deltaa 
study presents thorough discussion issues involved determining stopping criteria nonsymmetric eigenvalue problem 
arpack stringent just asking small backward error relative kak 
ask small backward error relative projected matrix hm draft july chapter computational routines chapter discuss implementation details main computational routines arpack 
give outline code structure 
shows implicitly restarted arnoldi lanczos method described algorithm chapter modularized 
basic steps described algorithm defines subroutine module computational routine 
basic tasks salient implementation details computational routines 
arpack relies heavily number basic operations algorithms provided blas lapack 
contributed greatly robustness accuracy computational performance arpack 
important respect performance blas subroutine 
fixed number nev requested eigenvalues fixed length ncv arnoldi basis computational cost scales linearly order matrix 
rate execution flops ira iteration asymptotic rate execution 
outline implementation described theta upper hessenberg matrix bv residual vector orthogonal columns op defined respect computational modes described chapter 
integer denotes desired number eigenvalue approximations may times greater users request nev approximations 
integer ncv largest size factorization constructed 
eigenvalue called ritz value op called ritz vector normalization ksk assumed 
high level implementation iram arpack ffl entering initially perform basic error checking partition internal workspace respect input parameters 
set nev ncv 
ffl enter 
generate random initial vector vme calling initial vector provided caller 
ffl call compute initial arnoldi lanczos factorization fk length nev ffl iter 
call extend length arnoldi lanczos factorization length factorization 
reverse communication performed compute matrix vector products op possibly 
compute eigenvalues hm associated error bounds 
call symmetric eigenvalue problem 

call partition eigenvalues sets omega omega eigenvalues set omega desired approximations remaining eigenvalues set omega shifts 

call determine wanted ritz values satisfy convergence tolerance 

exit loop eigenvalues omega satisfy convergence criterion iter 
possibly increment determine gamma shifts exact shift strategy eigenvalues omega shifts shifts provided reverse communication interface 
exit loop 

implicitly restart arnoldi lanczos factorization calling 
perform steps implicitly shifted qr algorithm hm resulting qm upper hessenberg orthogonal matrices respectively 
qk denote matrix consisting columns qm leading principal submatrix order update obtain new length arnoldi factorization mh see algorithm chap 

ffl ffl call computing ritz schur vectors transforming ritz values op spectral transformation 
draft july chapter 
computational routines arpack subroutines table lists auxiliary subroutines arpack 
naming convention xy mnemonic 
letter letter denotes data type follows single precision real arithmetic double precision real arithmetic single precision complex arithmetic double precision complex arithmetic 
second letter occurs letters denote type eigensystem follows non symmetric symmetric 
subroutines listed table start data types available 
top level subroutine provides reverse communication interface ira irl iterations 
user directly calls subroutine reverse communication modes compute eigenvalues linear operator defined op required computational mode selected user 
time operation involving op needed prompts user provide action op vector re enter 
reverse communication interface 
initial call subroutine error checking performed input arguments 
workspace provided partitioned various counters pointers initialized 
subroutine implements algorithm see chapter 
decision terminate iram 
iteration terminated requested number wanted ritz values satisfy convergence criterion specified maximum number iterations exceeded 
situations exited complete length arnoldi lanczos factorization number ritz values satisfy convergence criterion stored 
allows user call compute eigenvalues eigenvectors schur vectors converged requested tolerance 
step may increased reasons 
primary reason occurs exact shift strategy 
case number shifts apply draft july 
arpack subroutines table description auxiliary subroutines arpack 
routine description top level subroutine implements iram 
routine computes eigenvectors schur vectors computed eigenvalues 
intermediate level interface called performs iteration 
initial vector generation subroutine 
arnoldi factorization subroutine 
compute ritz values error bounds subroutine non symmetric non hermitian eigenvalue problems 
compute ritz values error bounds subroutine symmetric eigenvalue problem 
sort ritz values corresponding error bounds 
determines ritz values satisfy convergence criterion 
application implicit shifts routine 
sorting routines complex vectors 
sorting routine real vectors 
compute eigenvalues components schur vectors upper hessenberg matrix 
compute eigenvalues components eigenvectors symmetric tridiagonal matrix 
draft july chapter 
computational routines decreased wanted ritz value omega satisfies convergence criterion 
gamma easily achieved increasing value scheme helps prevent stagnation iram 
held fixed original value nev polynomial restarting effective number converged wanted ritz values approaches nev linear rate convergence related directly ratios restart filter polynomial evaluated wanted eigenvalues unwanted eigenvalues see chapter 
ratios unfavorable wanted eigenvalues close convex hull zero set filter polynomial 
increasing artificially increases distance wanted eigenvalues zero set filter polynomial consequence improves decreases ratios decreases linear convergence factor 
check performed exceeds ncv nev 
second reason increase unwanted ritz value omega converged point computed zero error estimate 
value incremented instance 
prevents attempting implicitly shift converged unwanted ritz value located leading submatrix hm split active portion iteration 
third way may increased occur 
complex conjugate pairs ritz values classified members unwanted set omega wanted set omega pair split sets value increased included wanted set omega user decided provide shifts implicit restarting reverse communication manner may decreased gamma second third reasons 
example shifts user may wish provide set roots chebyshev polynomial degree constructed small magnitude elliptical region approximately encloses unwanted eigenvalues 
typically ellipse encloses set omega excludes set omega constructed chebyshev polynomial degree small ellipse specified 
subroutine responsible associated building needed factorization 
implements algorithm chapter classical gram schmidt procedure possible re orthogonalization scheme 
step residual vector computed numerically orthogonal columns kf sin kav step re orthogonalization performed order produce updated residual angle successive residual vectors greater orthogonalization successful replaced column updated 
re orthogonalization step required 
repeated time 
draft july 
arpack subroutines third re orthogonalization necessary original av lies numerical span columns event third re orthogonalization necessary special action taken 
occurs means component original av orthogonal range roundoff error 
numerically columns form basis invariant subspace consequently corresponding subdiagonal element fi set zero 
order continue building arnoldi factorization desired length arbitrary nonzero vector generated orthogonal existing columns accomplished generating random vector columns get new basis vector non symmetric case st column new residual vector obtained applying gram schmidt procedure orthogonalize av columns subroutine responsible generating starting vectors 
called construct initial arnoldi lanczos vector option requested 
called generate new basis vector re orthogonalization scheme calls invariant subspace encountered early construction arnoldi factorization 
case vector returned orthogonalized existing set basis vectors 
case shift invert computational mode calls vector forced range op 
lapack subroutine generate random vectors 
subroutine called 
subroutine neigh calls arpack subroutine 
routine modified version lapack subroutine computing real schur form upper hessenberg matrix 
subroutine computes upper quasi triangular schur matrix just computes components associated schur vectors needed error estimates 
complex arithmetic subroutine neigh computes complete schur decomposition projected matrix hm lapack subroutine 
subroutine neigh calls lapack subroutine compute eigenvectors upper quasi triangular schur matrix 
just real arithmetic case components eigenvectors needed computing error estimates 
draft july chapter 
computational routines subroutine calls arpack subroutine computes eigenvalues components corresponding eigenvectors real symmetric tridiagonal matrix 
modification lapack subroutine 
performs task equivalent neigh takes advantage symmetry 
subroutine declares ritz value acceptable approximation eigenvalue op kf je sj max ffl tol delta satisfied 
subroutine performs checks directly code 
value tol defined user default machine precision ffl gamma kf je sj arpack avoids computation direct residual gamma accessing numerical quality ritz pair 
caution symmetric hermitian eigenproblems may user assume computed ritz value accurate approximation eigenvalue op 
chapter explained determining iram computes accurate eigenvalues non symmetric non hermitian eigenproblems depends sensitivity eigenproblem 
note op shift invert spectral transformation eigenvector purification step performed result smaller residuals original problem obtained op see chapter 
subroutine applies shifts implicitly shifted qr mechanism projected matrix hm shift complex employs double implicit shift application complex conjugate shift applied simultaneously 
allows implicit shift application take place real arithmetic 
updates current arnoldi lanczos basis obtain new length factorization hessenberg matrices set zero satisfy criterion standard implementation qr algorithm 
amounts checking subdiagonal hm product machine precision sum adjacent diagonal elements hm purpose obtain requested eigenvalues eigenvectors schur basis vectors original problem ax mx information computed linear operator op 
regardless spectral transformation eigenvectors remain unchanged transforming back original problem 
spectral transformation subroutine draft july 
arpack subroutines outline algorithm subroutine compute schur vectors possibly eigenvectors 

compute partial schur form converged wanted ritz values computed located diagonal upper triangular matrix rk order 
compute approximate schur vectors forming placing columns vm denote matrix consisting columns vk 
eigenvectors desired compute eigendecomposition compute ritz vectors forming compute eigenvalues op subroutine maps ax mx cases 
exceptions occur complex shift oe op real gamma oem gamma op imag gamma oem gamma note oe real shift recover eigenvalues op real op real eigenvalues recovered user converged ritz vectors computing rayleigh quotients original problem 
hope automate step release 
eigenvectors desired orthonormal basis invariant subspace corresponding converged ritz values computed 
vectors orthonormal basis called approximate schur vectors outlines strategy 
refer definitions quantities discussed remainder section 
symmetric eigenvalue problems need step schur vectors eigenvectors 
special routine required re order schur form diagonal matrix real eigenvalues 
real non symmetric eigenvalue problems uses real schur form 
upper quasi triangular matrix diagonal blocks diagonal block diagonal elements equal diagonal elements opposite sign 
associated diagonal block complex conjugate pair eigenvalues 
real eigenvalues stored diagonal similarly block diagonal matrix 
eigenvalue complex complex eigenvector associated eigenvalue positive imaginary part stored consecutive columns column holds real part eigenvector second column holds imaginary part 
eigenvector associated eigenvalue negative imaginary part simply complex conjugate eigenvector associated positive imaginary part 
computed ritz vectors stored manner 
computation partial schur form needed step performed calling appropriate lapack subroutine computes full schur decomposition hm lapack subroutine re orders computed schur draft july chapter 
computational routines table description lapack computational routines arpack 
routine description re orders schur form matrix 
diagonalize symmetric tridiagonal matrix 
computes eigenvectors matrix upper triangular form 
computes eigenvectors matrix upper quasi triangular form 
form obtain approximate schur vectors formed computing qr factorization vm factored form 
avoids need additional storage necessary computed directly 
appropriate lapack subroutines compute apply qr factorization factored approach described extremely stable efficient numerically orthogonal matrix 
exact arithmetic need perform reordering sorting symmetric eigenvalue problem 
theory implicit restarting mechanism obviate need 
computing finite precision arithmetic usual complicates issue final reorderings mandatory 
see chapter information 
ritz vectors required lapack subroutine called compute decomposition upper quasi triangular matrix product easily formed level blas subroutine 
lapack routines arpack arpack uses variety lapack auxiliary computational subroutines 
auxiliary routine performs basic computation unblocked form algorithm 
hand computational routine typically implements block version algorithm 
example computational subroutine determines eigenvalues schur decomposition upper hessenberg matrix qr algorithm 
auxiliary routine implements standard double shift form qr algorithm determining eigenvalues schur decomposition 
details information see chapter appendices 
tables list lapack routines arpack 
current release lapack version 
draft july 
lapack routines arpack table description lapack auxiliary routines arpack 
routine description computes schur decomposition upper hessenberg matrix 
computes qr factorization matrix 
sorm applies real orthogonal matrix factored form 
applies complex orthogonal matrix factored form 
scales matrix stably 
compute various matrix norms hessenberg matrix 
perform matrix copy 
determine various machine parameters 
determines underflow limits 
compute stably 
generates plane rotation 
generates real elementary reflector 
applies real elementary reflector real matrix 
initialize matrix 
draft july chapter 
computational routines table description level blas arpack 
routine description matrix times upper triangular matrix 
table description level blas arpack 
routine description matrix vector product 
ger rank update real matrix 
rank update complex matrix 
blas routines arpack tables list blas subroutines called arpack directly 
blas subroutines needed arpack called lapack routines 
draft july table description level blas arpack 
routine description compute vector triad 
scale vector 
dot compute real inner product 
compute complex inner product 
scale vector real constant 
computes euclidean norm real vector 
sc dz computes euclidean norm complex vector 
copy vector 
swap vectors appendix templates driver routines addition simple drivers described chapter set example drivers demonstrate arpack solving standard generalized eigenvalue problems various modes provided 
drivers subdirectories examples directory 
directory listed 
sym real symmetric eigenvalue problems 
real non symmetric eigenvalue problems 
complex complex eigenvalue problems 
band eigenvalue problems matrices stored lapack band form 
svd singular value decomposition svd problems 
drivers intended templates constructing user interface arpack computational routines 
driver illustrates variables declared reverse communication communication interface particular computational mode check accuracy computed results 
appendix provides guidance deciding driver select effectively 
order process building user application code drivers efficient discuss necessary steps followed process 
steps may summarized follows ffl selecting appropriate driver 
ffl identifying constructing linear operator op matrix driver 
ffl substituting constructed linear operator op matrix reverse communication interface 
ffl modifying problem dependent variables 

symmetric drivers table functionality symmetric drivers 
driver problem solved dsdrv standard eigenvalue problem bmat regular mode iparam 
dsdrv standard eigenvalue problem bmat shift invert mode iparam 
dsdrv generalized eigenvalue problem bmat regular inverse mode iparam 
dsdrv generalized eigenvalue problem bmat shift invert mode iparam 
dsdrv generalized eigenvalue problem bmat buckling mode iparam 
dsdrv generalized eigenvalue problem bmat cayley mode iparam 
ffl checking accuracy computed results 
procedure discussed xx solution symmetric nonsymmetric complex arithmetic eigenvalue problems arpack 
symmetric drivers drivers symmetric eigenvalue problem 
named form character specifies precision follows single precision double precision 
character number indicating type problem solved mode 
number associated unique combination bmat iparam variables 
table lists problem solved double precision driver 
drivers commonly 
drivers special spectral transformations may accelerate convergence particular problems 
draft july appendix templates driver routines selecting symmetric driver drivers may solve problem 
driver may appropriate may easier modify 
decision typically depends nature application portion spectrum computed 
see chapter discussion issues considered deciding spectral transformation 
standard mode driver dsdrv solves standard eigenvalue problem ax mode requires matrix vector products appropriate computing extremal non clustered eigenvalues 
shift invert mode driver dsdrv uses shift invert mode find eigenvalues closest shift oe 
compute interior eigenvalues clustered extremal eigenvalues 
discussion shift invert mode see chapter 
dsdrv user required supply action gamma oei gamma typically accomplished factoring matrix gamma oei solving resulting linear system 
generalized eigenvalue problem generalized eigenvalue problem ax mx solved drivers dsdrv dsdrv dsdrv dsdrv 
may factored generalized eigenvalue problem may converted standard eigenvalue problem described inx chapter regular inverse mode driver dsdrv uses regular inverse mode solve generalized eigenvalue problem 
mode symmetric positive definite feasible compute sparse direct cholesky factorization ll draft july 
symmetric drivers appropriate factored reason think ill conditioned 
dsdrv user supply action gamma av mv action gamma typically done iterative solver pre conditioned conjugate gradient 
inner products restores symmetry 
factored direct conversion standard problem recommended 
shift invert mode driver dsdrv uses shift inverse mode solve generalized eigenvalue problem 
eigenvalues closest shift oe obtained computing eigenvalues largest magnitude gamma oem gamma mx eigenvalue original problem related oe dsdrv user required supply matrix vector operations gamma oem gamma mv oe shift defined user 
typically matrix operation performed factoring gamma oem solving resulting linear system 
buckling mode driver dsdrv implements buckling transformation 
eigenvalues closest shift oe obtained computing largest eigenvalues gamma oem gamma ax mode assumes symmetric semi definite matrix 
note operator op symmetric respect semi inner product defined eigenvalue original problem related oe gamma note oe mode 
operations gamma oem gamma mv required order driver 
draft july appendix templates driver routines table operators op driver op dsdrv dsdrv gamma oei gamma dsdrv gamma dsdrv gamma oem gamma dsdrv gamma oem gamma dsdrv gamma oem gamma oem cayley transformation mode driver dsdrv implements cayley spectral transformation 
eigenvalues closest shift oe obtained computing largest eigenvalues gamma oem gamma oem note op symmetric respect semi inner product defined eigenvalue original problem related oe gamma note transformation ill defined oe 
limit better shift invert mode oe 
slightly different properties standard shift invert spectral transformation drivers dsdrv dsdrv 
driver operations gamma oem gamma oem required 
identify op driver step identify linear operator op matrix associated driver 
eigenvalues op computed computational routine dsaupd 
eigenvalues converted post processing routine 
lanczos vectors generated dsaupd orthogonal respect inner product defined imperative operations bv computed correctly 
table summarizes operators op defined driver 
draft july 
symmetric drivers reverse communication interface arpack construction bv left completely user 
means user free choose convenient data structure matrix representation 
matrix available user free express action matrix vector subroutine call code segment 
reverse communication interface reverse communication interface regular shift invert modes illustrated chapter respectively 
general structure reverse communication loop 
specific actions taken loop varies drivers 
action corresponds ido value returned call dsaupd 
actions involve matrix vector operations bv matrix vector operation performed correct portion array workd 
discuss details matrix vector operation performed driver 
driver dsdrv action av taken driver 
indicated ido 
matrix vector multiplication av takes workd ipntr input output returned array workd ipntr 
driver dsdrv action gamma oei gamma taken driver 
indicated ido ido 
action requires linear systems gamma oei solved 
linear solve takes workd ipntr righthand side input output solution returned array workd ipntr 
driver dsdrv actions listed taken 
actions indicated ido ido involve matrix vector operation gamma av ido starting vector multiplied op gamma occur 
matrix vector multiplication av takes workd ipntr input 
intermediate vector overwrite workd ipntr 
right hand side linear system mw solution linear system returned workd ipntr 
ido action mv takes workd ipntr input 
result returned workd ipntr 
draft july appendix templates driver routines reverse communication loop continue repeatedly call routine dsaupd take actions indicated parameter ido convergence indicated exceeded 
call dsaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info ido eq 
op call dsaupd 
go ido eq 
op call dsaupd 
go ido eq 
call dsaupd 
go reverse communication structure draft july 
symmetric drivers driver dsdrv actions listed taken 
actions indicated ido ido involve matrix vector operation gamma mv ido starting vector projected range op gamma oem gamma occur 
matrix vector multiplication mv workd ipntr input performed ido 
matrix vector multiplication mv needed ido computed saved workd ipntr ido 
ido linear system gamma oem uses workd ipntr right hand side 
action indicated ido mx takes workd ipntr input returns result workd ipntr 
driver dsdrv actions taken driver similar dsdrv different op actions indicated ido ido involve matrix vector operation gamma oem gamma av ido starting vector projected range op gamma oem gamma occur 
matrix vector multiplication av workd ipntr input performed ido 
intermediate vector right hand side gamma oem solution returned workd ipntr 
matrix vector multiplication av needed ido computed saved workd ipntr ido 
linear system equation simply uses workd ipntr right hand side 
solution returned array workd ipntr 
action ax indicated ido takes workd ipntr input returns result workd ipntr 
driver dsdrv actions taken driver similar dsdrv different op actions indicated ido ido involve matrix vector operation gamma oem gamma oem ido starting vector projected range op gamma oem gamma oem occur 
matrix vector multiplications mv av workd ipntr input performed ido 
vector oey right hand side gamma oem solution returned workd ipntr 
ido matrix vector multiplication av needed mv computed saved workd ipntr ido 
vector combined workd ipntr draft july appendix templates driver routines table eigenvalues interest symmetric eigenvalue problems 
eigenvalues la largest algebraic eigenvalues 
sa smallest algebraic eigenvalues 
lm largest eigenvalues magnitude 
sm smallest eigenvalues magnitude 
eigenvalue ends 
nev odd compute high low 
form right hand side 
solution equation returned workd ipntr 
matrix vector product mx indicated ido takes workd ipntr input returns resulting matrix vector product workd ipntr 
modify problem dependent variables variables include dimension problem 
nev number eigenvalues needed 
ncv length arnoldi factorization 
represents maximum number arnoldi vectors 
eigenvalues interest 
info set randomly generated starting vector 
user decides starting vector value set starting vector provided array resid 
sigma shift spectral transformation employed 
variable nev may set value larger number eigenvalues desired avoid splitting eigenvalue cluster 
restriction nev ncv 
initial choice ncv ncv delta nev recommended 
user encouraged experiment nev nev choices available input variable listed table 
spectral draft july 
symmetric drivers transformation employed selections lm la sa 
variables modified storage declarations integer maxn ldv parameter maxn ldv maxn adjusted conditions maxn nev ncv nev ncv satisfied 
variables variables set drivers 
usage described chapter 
cases need changed 
size array workl dsaupd 
set ncv ncv 
tol convergence criterion 
default set value machine precision 
changed depending accuracy desired 
typically smaller value required satisfy stopping criteria 
setting value large may cause eigenvalues missed multiple clustered eigenvalue 
ido reverse communication flag 
set entering dsaupd 
bmat designates standard bmat generalized eigenvalue bmat problem iparam shifting strategy implicitly restarted portion 
user expert understanding exact shifting strategy selected setting iparam 
iparam maximum number iterations allowed 
iparam indicates algorithmic mode arpack 
indicates eigenvectors needed 
eigenvectors interest true 
set false 

draft july appendix templates driver routines postprocessing accuracy checking eigenvalues eigenvectors extracted postprocessing routine user may check accuracy result computing direct residuals kax gamma xk kax gamma standard generalized eigenvalue problems respectively 
order compute quantities matrix vector product routines ax mx supplied reverse communication loop 
residual checking provided drivers 
real nonsymmetric drivers drivers nonsymmetric eigenvalues problem 
named form character specifies precision single precision double precision character number indicating mode 
number associated combination bmat iparam sigmai variables driver 
table summarizes features double precision drivers 
drivers ones commonly 
drivers complex shift shift invert mode nonzero imaginary part 
dndrv dndrv may modified solve standard eigenvalue problem shift invert mode complex shift 
amount storage complex arithmetic prohibitive complex drivers 
procedure modifying nonsymmetric driver outlined 
similar symmetric drivers 
selecting non symmetric driver drivers may solve problem 
driver may better may easier modify depending nature application 
decision type problem solved part spectrum interest 
see chapter discussion issues considered deciding spectral transformation 
standard mode standard eigenvalue problem ax driver dndrv computes eigenvalues largest smallest magnitude real part imaginary part 
operation gamma easily formed draft july 
real nonsymmetric drivers table functionality non symmetric drivers 
driver problem solved dndrv standard eigenvalue problem bmat regular mode iparam 
shift needed driver 
dndrv standard eigenvalue problem bmat shift invert mode iparam 
shift real sigmai dndrv generalized eigenvalue problem bmat regular inverse mode iparam 
shift needed driver 
dndrv generalized eigenvalue problem bmat shift invert mode iparam 
real shift sigmai dndrv generalized eigenvalue problem bmat shift invert mode iparam 
shift nonzero imaginary part sigmai 
dndrv solve generalized eigenvalue problem bmat shift invert mode iparam 
shift nonzero imaginary part sigmai 
draft july appendix templates driver routines shift invert driver dndrv zero shift probably effective way compute eigenvalues smallest magnitude 
shift invert mode driver dndrv uses shift invert mode find eigenvalues closest real shift oe compute interior eigenvalues 
dndrv user required supply action gamma oei gamma desired shift nonzero imaginary part dndrv dndrv modified solve problem 
eigenvalue problems additional storage needed prohibitive complex shift invert driver 
generalized nonsymmetric eigenvalue problem generalized eigenvalue problem ax mx solved convert standard eigenvalue problem described chapter dndrv dndrv dndrv dndrv designed specifically generalized problem 
regular inverse mode driver dsdrv uses regular inverse mode solve generalized eigenvalue problem 
mode symmetric positive definite possible factor cholesky factorization ll reason think ill conditioned 
dsdrv user supply action gamma av mv action gamma typically done iterative solver pre conditioned conjugate gradient 
factored direct conversion standard problem recommended 
spectral transformations non symmetric eigenvalue problems interior eigenvalues sought shift invert driver dndrv dndrv dndrv may 
driver dndrv shift zero imaginary part 
dndrv dndrv 
drivers required supply action gamma oem gamma mv draft july 
real nonsymmetric drivers table operators op driver op dndrv dndrv gamma oei gamma dndrv gamma dndrv gamma oem gamma dndrv real gamma oem gamma dndrv imag gamma oem gamma sigma may nonzero imaginary part complex factorization routine complex iterative solver may required 
case vector general complex vector 
real imaginary part passed dnaupd 
identify op driver driver chosen step identify op associated driver 
eigenvalues op computed computational routine dnaupd 
eigenvalues converted post processing routine 
arnoldi vectors generated dnaupd orthonormal 
important construct matrix vector operations bv correctly 
table summarizes operators op drivers 
notation real real denote real imaginary parts complex matrix respectively 
reverse communication interface arpack construction bv left completely user 
means user free choose convenient data structure matrix representation 
matrix available user free express action matrix vector subroutine call code segment 
reverse communication interface basic structure reverse communication loop nonsymmetric drivers similar symmetric driver dsaupd replaced dnaupd 
see draft july appendix templates driver routines 
actions taken dndrv dndrv dndrv dndrv exactly dsdrv dsdrv dsdrv dsdrv 
completeness repeat discussion 
operator op defined dndrv dndrv unique real nonsymmetric problems actions taken drivers completely different dsdrv dsdrv 
driver dndrv action av taken driver 
indicated ido 
matrix vector multiplication av takes workd ipntr input output returned array workd ipntr 
driver dndrv action gamma oei gamma taken driver 
indicated ido 
action requires solution linear system gamma oei typically accomplished factoring gamma oei iterative solver 
driver dndrv actions listed taken 
actions indicated ido ido involve matrix vector operation gamma av 
ido starting vector projected range op gamma occur 
matrix vector product av takes workd ipntr input 
intermediate vector overwrite workd ipntr 
right hand side linear system mw solution linear system returned workd ipntr 
ido action mv takes workd ipntr input 
result returned workd ipntr 
driver dndrv actions listed taken 
actions indicated ido ido involve matrix vector operation gamma oem gamma mv ido starting vector projected range op gamma oem gamma occur 
matrix vector multiplication mv workd ipntr input performed ido 
matrix vector multiplication needed ido mv computed saved workd ipntr ido 
ido linear system gamma oem uses workd ipntr right hand side 
action indicated ido mx takes workd ipntr input returns matrix vector product workd ipntr 
draft july 
real nonsymmetric drivers driver dndrv actions listed taken 
actions indicated ido ido involve matrix vector operation real gamma oem gamma mv ido starting vector projected range op real gamma oem gamma occur 
matrix vector multiplication mv workd ipntr input performed ido 
intermediate vector right hand side complex linear system gamma oem real part solution returned array workd ipntr 
ido matrix vector multiplication needed mv computed saved workd ipntr ido 
linear system uses workd ipntr right hand side real part solution returned workd ipntr 
ido matrix vector multiplication mx performed workd ipntr result returned array workd ipntr 
driver dndrv actions listed taken 
actions indicated ido ido involve matrix vector operation imag gamma oem gamma mv ido starting vector projected range op imag gamma oem gamma occur 
matrix vector multiplication mv workd ipntr input performed ido 
intermediate vector right hand side complex linear system 
imaginary part solution returned array workd ipntr 
ido matrix vector multiplication needed mv computed saved workd ipntr ido 
linear system uses workd ipntr right hand side imaginary part solution returned workd ipntr 
ido matrix vector multiplication mx performed workd ipntr result returned workd ipntr 
modify problem dependent variables variables include dimension problem 
nev number eigenvalues needed 
ncv length arnoldi factorization 
represents maximum number arnoldi vectors 
eigenvalues interest 
draft july appendix templates driver routines table eigenvalues interest non symmetric eigenvalue problems 
eigenvalues lm largest magnitude sm smallest magnitude lr largest real parts sr smallest real parts li largest imaginary parts si smallest imaginary parts info set randomly generated starting vector 
user decides starting vector value set starting vector provided array resid 
real part shift spectral transformation employed 
sigmai imaginary part shift spectral transformation employed 
variable nev may set value larger number eigenvalues desired avoid splitting eigenvalue cluster 
restriction nev ncv 
initial choice ncv ncv delta nev recommended 
user encouraged experiment nev nev choices available input variable listed table 
spectral transformation selection sm avoided 
variables modified storage declarations integer maxn ldv parameter maxn ldv maxn adjusted conditions maxn nev ncv nev ncv satisfied 
condition nev follows complex conjugate pairs eigenvalues kept 
draft july 
real nonsymmetric drivers variables variables set drivers 
usage described chapter 
cases need changed 
size array workl dnaupd 
set ncv ncv 
tol convergence criterion 
default set value machine precision 
changed depending accuracy desired 
typically smaller value required satisfy stopping criteria 
setting value large may cause eigenvalues missed multiple clustered eigenvalue 
ido reverse communication flag 
set entering dsaupd 
bmat designates standard bmat generalized eigenvalue bmat problem iparam shifting strategy implicitly restarted portion 
user expert understanding exact shifting strategy selected setting iparam 
iparam maximum number iterations allowed 
iparam indicates algorithmic mode arpack 
indicates eigenvectors needed 
eigenvectors interest true 
set false 

postprocessing accuracy checking eigenvalues eigenvectors extracted call drivers dndrv dndrv 
eigenvalues computed op drivers dndrv dndrv related eigenvalues ax mx gamma oe oe gamma oe oe respectively 
equations unique solution appears difficult match correct solution eigenvector 
rayleigh quotient ax mx formed user obtain eigenvalue draft july appendix templates driver routines table functionality complex arithmetic drivers 
driver problem solved standard eigenvalue problem bmat regular mode iparam 
standard eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat regular inverse mode iparam 
generalized eigenvalue problem bmat shift invert mode iparam 
corresponding eigenvector done automatically release arpack 
converged eigenvalues eigenvectors obtained user may check accuracy results computing direct residuals kax gamma xk kax gamma standard generalized eigenvalue problems 
residual checking provided drivers 
complex drivers drivers complex date type problems 
named form character specifies precision follows single precision complex double precision complex character number indicating type problem solved mode 
number associated unique combination bmat iparam value 
table summarizes features double precision complex arithmetic driver 
procedure modifying complex driver similar symmetric drivers 
selecting complex arithmetic driver drivers may solve problem 
driver may better may easier modify depending nature application 
decision type problem solved part spectrum interest 
see chapter draft july 
complex drivers discussion issues considered deciding spectral transformation 
standard eigenvalue problems standard eigenvalue problem ax driver computes eigenvalues largest smallest magnitude real part imaginary part 
operation gamma easily formed shift invert driver zero shift probably effective way compute eigenvalues smallest magnitude 
shift invert spectral transformation driver uses shift invert spectral transformation mode find eigenvalues closest shift oe order user required supply action gamma oei gamma generalized eigenvalue problems generalized eigenvalue problem ax mx solved convert standard eigenvalue problem described chapter employ designed specifically generalized problem 
driver uses regular inverse mode 
find eigenvalues largest smallest magnitude 
interior eigenvalues sought shift invert driver 
user required supply action gamma oem gamma oe shift defined user 
identify op driver modified driver chosen 
step identify op associated driver 
eigenvalues op computed computational routine znaupd 
eigenvalues converted post processing routine 
arnoldi vectors generated znaupd orthonormal 
important construct operation bv correctly 
list summarize operator op defined driver 
draft july appendix templates driver routines table operators op driver op gamma oei gamma gamma gamma oem gamma reverse communication interface arpack construction bv left completely user 
means user free choose convenient data structure matrix representation 
matrix available user free express action matrix vector subroutine call code segment 
reverse communication interface basic reverse communication loop complex driver exactly symmetric driver dsaupd replaced znaupd 
actions taken loop vary driver 
drivers may take actions listed 
action corresponds ido value returned call znaupd 
actions involve matrix vector operations bv matrix vector operation performed correctly correct portion array workd workd ipntr workd ipntr 
output returned correct portion workd workd ipntr workd ipntr loop goes back call znaupd 
completeness restate matrix vector operation performed driver 
driver action av taken driver 
indicated ido 
matrix vector multiplication av takes workd ipntr input output returned array workd ipntr 
driver action gamma oei gamma taken driver 
indicated ido 
action requires linear system gamma oei solve 
draft july 
complex drivers done factoring gamma oei iterative solver 
structure reverse communication loop dsdrv driver actions listed taken 
actions indicated ido ido involve matrix vector operation gamma av 
ido starting vector projected range op gamma occur 
matrix vector multiplication av takes workd ipntr input 
intermediate vector overwrite workd ipntr 
right hand side linear system mw solution linear system returned workd ipntr 
ido action mv takes workd ipntr input 
result returned workd ipntr 
driver actions listed taken 
actions indicated ido ido involve matrix vector operation gamma oem gamma mv ido starting vector projected range op gamma oem gamma occur 
matrix vector multiplication mv workd ipntr input performed ido 
matrix vector multiplication needed ido mv computed saved workd ipntr ido 
ido linear system gamma oem uses workd ipntr right hand side 
action indicated ido mx takes workd ipntr input returns matrix vector product workd ipntr 
modify problem dependent variables variables include dimension problem 
nev number eigenvalues needed 
ncv length arnoldi factorization 
represents maximum number arnoldi vectors 
eigenvalues interest 
info set randomly generated starting vector 
user decides starting vector value set starting vector provided array resid 
sigma shift spectral transformation employed 
draft july appendix templates driver routines table eigenvalues interest complex arithmetic eigenvalue problems 
eigenvalues lm largest magnitude sm smallest magnitude lr largest real parts sr smallest real parts li largest imaginary parts si smallest imaginary parts variable nev may set value larger number eigenvalues desired avoid splitting eigenvalue cluster 
restriction nev ncv 
initial choice ncv ncv delta nev recommended 
user encouraged experiment nev nev choices available input variable listed table 
spectral transformation selection sm avoided 
variables modified storage declarations integer maxn ldv parameter maxn ldv maxn adjusted conditions maxn nev ncv nev ncv satisfied 
variables variables set drivers 
usage described chapter 
cases need changed 
size array workl znaupd 
set ncv ncv 
tol convergence criterion 
default set value machine precision 
changed depending accuracy desired 
typically smaller value required draft july 
band drivers satisfy stopping criteria 
setting value large may cause eigenvalues missed multiple clustered eigenvalue 
ido reverse communication flag 
set entering dsaupd 
bmat designates standard bmat generalized eigenvalue bmat problem iparam shifting strategy implicitly restarted portion 
user expert understanding exact shifting strategy selected setting iparam 
iparam maximum number iterations allowed 
iparam indicates algorithmic mode arpack 
indicates eigenvectors needed 
eigenvectors interest true 
set false 

post processing accuracy checking eigenvalues eigenvectors extracted post processing routine user may check accuracy result computing direct residuals kax gamma xk kax gamma standard generalized eigenvalue problems respectively 
band drivers matrix stored lapack band form band drivers may 
band drivers named form character specifies precision data type single precision double precision single precision complex double precision complex second character indicates symmetry property problem symmetric problem nonsymmetric problem draft july appendix templates driver routines table band storage drivers symmetric eigenvalue problems band driver problem solved standard eigenvalue problem bmat regular mode iparam 
standard eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat regular inverse mode iparam 
generalized eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat buckling mode iparam 
generalized eigenvalue problem bmat cayley mode iparam 
third character number indicating type problem solved mode 
number associated combination bmat iparam sigmai values driver 
tables list summarizes double precision band storage drivers 
special drivers complex hermitian problem 
complex hermitian problems solved 

drivers call band eigenvalue computation routine character specifies precision data type listed second character indicates symmetry property problem solved routine 
reverse communication interface implemented computational routines users need provide matrix modify variables drivers solve problem 
procedure modifying drivers 
selecting band storage driver drivers may solve problem 
driver may better may easier modify depending nature application 
decision type problem solved part spectrum interest 
typically regular mode drivers find extremal eigenvalues shift invert drivers find interior eigenvalues extremal eigenvalues clustered 
draft july 
band drivers table band storage drivers non symmetric eigenvalue problems band driver problem solved standard eigenvalue problem bmat regular mode iparam 
standard eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat regular inverse mode iparam 
generalized eigenvalue problem bmat shift invert mode iparam 
standard eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat shift invert mode iparam 
table band storage drivers complex arithmetic eigenvalue problems 
band driver problem solved standard eigenvalue problem bmat regular mode iparam 
standard eigenvalue problem bmat shift invert mode iparam 
generalized eigenvalue problem bmat regular inverse mode iparam 
generalized eigenvalue problem bmat shift invert mode iparam 
draft july appendix templates driver routines store matrix correctly band routines assume matrix stored lapack band form 
ab mb denote stored band form 
matrix kl ku element ij stored ab kl ku gamma max gamma ku min kl 
example band matrix kl ku illustrated 
ab elements marked matrix ab need set 
modify problem dependent variables variables include dimension problem 
nev number eigenvalues needed 
ncv length arnoldi factorization 
part spectrum interest 
sigma real shift complex shift 
real part shift real nonsymmetric shift invert mode driver 
sigmai imaginary part shift real nonsymmetric shift invert mode driver 
set zero dndrv 
modify variables necessary variables set drivers 
usage described chapters 
cases need changed 
set ncv ncv ncv 
draft july 
singular value decomposition tol usually set zero 
changed depending accuracy desired 
typically smaller value required satisfy stopping criteria 
setting value large may cause eigenvalues missed multiple tightly clustered 
ido set entering dnaupd 
info usually set 
case random starting vector generated start arnoldi iteration 
user decides starting vector value set starting vector provided array resid 
bmat depending problem solved 
variable set appropriately driver 
user change value 
iparam usually set 
indicates exact shift strategy computation 
discussion shift strategy see chapter 
iparam maximum iterations allow 
set drivers 
reset reasonable value 
iparam indicate algorithmic mode 
variable set appropriately driver 
user change value 
indicate eigenvector needed 
set true 
drivers 
eigenvector needed may set false 
accuracy checking eigenvalues eigenvectors obtained user may check accuracy result computing direct residuals kax gamma xk kax gamma standard generalized eigenvalue problem respectively 
singular value decomposition rectangular matrix thetan may factored form usv matrices orthonormal columns matrix diag oe oe delta delta delta oe 
numbers oe oe delta delta delta oe called singular values columns left singular vectors columns right singular vectors called short form singular value svd draft july appendix templates driver routines compute av blocks initialize read block cv relationship may manipulated orthogonality reveal vs avs gamma oe 
selected singular values corresponding right singular vectors may computed finding eigenvalues vectors theta matrix applications computing say largest singular values corresponding vectors 
denote leading columns respectively denotes leading principal submatrix best rank approximation norm frobenius norm 
small suffice approximate important features original approximately solve squares problems involving partial svd may computed efficiently arpack subroutine mode la op course action computed steps 
matrix vector multiply av 
matrix vector multiply note matrix huge stored peripheral device may read blocks achieve action fact delta delta delta obtain loop shown 
drivers illustrate compute leading terms svd just described 
left singular vectors right singular vectors 
draft july 
singular value decomposition long largest singular values multiple tightly problem obtaining numerically orthogonal left singular vectors computed right singular vectors 
way get left right singular vectors directly 
define op utilize fact extract columns components converged eigenvectors op columns remaining components 
provide approach arpack drivers 
mention case matrix replace discussion reverse roles svd drivers drivers computing singular value decomposition form denotes precision data type single precision double precision 
course svd defined complex matrices straightforward matter convert real arithmetic driver corresponding complex arithmetic driver 
drivers may easily modified estimate norm condition number oe oe setting 
ask smallest largest singular values simultaneously 
condition number estimated ratio largest smallest singular values 
drivers simply special cases dsdrv parameter settings described 
cautionary note parameter may set sa desired recommended expected nearly rank deficient 
draft july appendix tracking progress arpack arpack provides means trace progress computation proceeds 
various levels output may specified output level voluminous level 
statements may calling program initiate request output 
include debug parameter specifies logical unit number output file 
parameter specifies number decimal digits width output lines 
positive value specifies columns output negative value specifies columns 
values remaining parameters indicate output levels indicated routines 
example indicates level output requested subroutine 
configuration give breakdown number matrix vector products required total number iterations number re orthogonalization steps estimate time spent routine phase computation 
output displayed table produced 
user encouraged experiment settings familiarity gained routines 
include statement sets storage declarations solely associated trace debugging feature 
debug structure table sample output produced dsaupd 
symmetric implicit arnoldi update code version number version date summary timing statistics total number update iterations total number op operations total number operations total number reorthogonalization steps total number iterative refinement steps total number restart steps total time user op operation total time user operation total time arnoldi update routine total time routine total time basic arnoldi iteration loop total time reorthogonalization phase total time re start vector generation total time eigenvalue subproblem total time getting shifts total time applying shifts total time convergence testing draft july appendix tracking progress arpack sccs information file debug sid date sid release see debug doc documentation integer common debug parameters symmetric codes nonsymmetric codes complex arithmetic codes 
comprehensive break parameter listed table 
draft july table description message level settings arpack 
routine level description print total number iterations taken number converged ritz values ritz values corresponding ritz estimates various timing statistics 
exit print number converged ritz values ritz values corresponding ritz estimates 
print current iteration number length arnoldi factorization extended norm residual vector 
print nev np ritz values associated ritz estimates iteration norm residual compressed factorization 
print real imaginary parts ritz values associated ritz estimates nev np 
print shifts 
exact shift strategy print associated ritz estimates shifts 
notification restart 
print number arnoldi vector generated norm current residual 
print columns hessenberg matrix generated reorthogonalization iterative refinement information final upper hessenberg matrix order nev bf kf print row schur matrix row eigenvector matrix print entering upper hessenberg matrix computed eigenvalues associated ritz estimates 
print information deflation occured 
print order final hessenberg matrix final compressed upper hessenberg matrix 
print implicit application shift number real imaginary part shift indices submatrix shift applied 
print number converged ritz values norm residual ncv ritz values error bounds 
print final upper hessenberg matrix computed 
ritz vectors requested print real imaginary parts eigenvalues row schur vectors computed 
ritz vectors requested print threshold eigenvalue re ordering number eigenvalues reorder number converged ritz values 
draft july appendix arpack routines appendix exhibit headers main computational routines dsaupd dnaupd znaupd 
codes nearly identical structure usage number differences problem dependent 
listed separately 
information calling sequence input output parameters storage data types may 
error flags warnings listed 

dsaupd dsaupd name dsaupd description reverse communication interface implicitly restarted arnoldi iteration 
symmetric problems reduces variant lanczos method 
method designed compute approximations eigenpairs linear operator op real symmetric respect real positive semi definite symmetric matrix op op way express condition bw standard eigenproblem identity matrix 
denotes transpose computed approximate eigenvalues called ritz values corresponding approximate eigenvectors called ritz vectors 
dsaupd usually called iteratively solve problems mode lambda symmetric op mode lambda symmetric symmetric positive definite op inv factored see mode lambda symmetric symmetric positive semi definite op inv sigma shift invert mode mode lambda kg symmetric positive semi definite kg symmetric indefinite op inv sigma kg buckling mode mode lambda symmetric symmetric positive semi definite op inv sigma sigma cayley transformed mode note action inv sigma inv accomplished direct method sparse matrix factorization solving sigma iterative method solving systems 
iterative method convergence test stringent accuracy requirements eigenvalue approximations 
usage call dsaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info arguments ido integer 
input output reverse communication flag 
ido zero call dsaupd 
ido set internally indicate type operation performed 
control back calling routine responsibility carry requested operation call dsaupd result 
operand workd ipntr result put workd ipntr 
mode see ido call reverse communication interface ido compute op ipntr pointer workd ipntr pointer workd initialization phase force starting vector range op 
ido compute op ipntr pointer workd ipntr pointer workd ipntr pointer workd ido compute ipntr pointer workd ipntr pointer workd ido compute iparam shifts ipntr pointer workl placing shifts 
see 
ido done initialization phase routine shift invert mode cayley transform mode vector available need recomputed forming op bmat character 
input bmat specifies type matrix defines semi inner product operator op 
standard eigenvalue problem lambda generalized eigenvalue problem lambda integer 
input dimension eigenproblem 
draft july appendix arpack routines character 
input specify ritz values op compute 
la compute nev largest algebraic eigenvalues 
sa compute nev smallest algebraic eigenvalues 
lm compute nev largest magnitude eigenvalues 
sm compute nev smallest magnitude eigenvalues 
compute nev eigenvalues half spectrum 
nev odd compute high low 
see nev integer 
input number eigenvalues op computed 
nev tol double precision scalar 
input stopping criterion relative accuracy ritz value considered acceptable bounds le 
tol abs ritz 
tol le 

passed default set default eps machine precision computed lapack auxiliary subroutine 
resid double precision array length 
input output input info eq 
random initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
output resid contains final residual vector 
ncv integer 
input number columns matrix equal 
indicate lanczos vectors generated iteration 
startup phase nev lanczos vectors generated algorithm generates ncv nev lanczos vectors subsequent update iteration 
cost generating lanczos vector matrix vector product op 
see 
double precision ncv array 
output ncv columns contain lanczos basis vectors 
ldv integer 
input leading dimension exactly declared calling program 
iparam integer array length 
input output iparam method selecting implicit shifts 
shifts selected iteration restart arnoldi iteration implicit fashion 
shifts provided user reverse communication 
ncv eigenvalues current tridiagonal matrix returned part workl array corresponding ritz 
see 
exact shifts respect reduced tridiagonal matrix equivalent restarting iteration starting vector linear combination ritz vectors associated wanted ritz values 
iparam longer referenced 
see 
iparam input maximum number arnoldi update iterations allowed 
output actual number arnoldi update iterations taken 
iparam nb blocksize recurrence 
code currently works nb 
iparam number converged ritz values 
represents number ritz values satisfy convergence criterion 
iparam longer referenced 
implicit restarting 
iparam mode input determines type eigenproblem solved 
see description dsaupd modes available 
iparam np ido user provides shifts reverse communication iparam dsaupd returns np number shifts user provide 
np ncv nev see 
iparam iparam iparam output total number op operations total number operations bmat total number steps re orthogonalization 
ipntr integer array length 
output pointer mark starting locations workd workl arrays matrices vectors lanczos iteration 
ipntr pointer current operand vector workd 
ipntr pointer current result vector workd 
ipntr pointer vector workd shift invert mode 
ipntr pointer available location workl untouched program 
ipntr pointer ncv tridiagonal matrix workl 
ipntr pointer ncv ritz values array workl 
ipntr pointer ritz estimates array workl associated draft july 
dsaupd ritz values located ritz workl 
note ipntr referenced 
see 
ipntr pointer ncv ritz values original system 
ipntr pointer ncv corresponding error bounds 
ipntr pointer ncv ncv matrix eigenvectors tridiagonal matrix referenced true 
see remarks 
note ipntr referenced 
see 
ipntr pointer np shifts workl 
see 
workd double precision array length 
reverse communication distributed array basic arnoldi iteration reverse communication 
user workd temporary workspace iteration 
termination workd contains resid 
ritz vectors desired subroutine uses output 
see data distribution note 
workl double precision array length 
output workspace private replicated array pe array allocated front 
see data distribution note 
integer 
input ncv ncv info integer 
input output info eq 
randomly initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
error flag output 
normal exit 
maximum number iterations taken 
possible eigenvalues op 
iparam returns number wanted converged ritz values 
longer informational error 
deprecated starting release arpack 
shifts applied cycle implicitly restarted arnoldi iteration 
possibility increase size ncv relative nev see 
positive 
nev positive 
ncv greater nev equal maximum number arnoldi update iterations allowed greater zero 
lm sm la sa 
bmat 
length private array workl sufficient 
error return 
eigenvalue calculation error lapack routine 
starting vector zero 
iparam 
iparam bmat 
iparam equal 
nev 
build arnoldi factorization 
iparam returns size current arnoldi factorization 
user advised check workspace array storage allocated 
remarks 
converged ritz values returned ascending algebraic order 
computed ritz values approximate eigenvalues op 
selection mind mode 
convergence approximate eigenvalues original problem may obtained arpack subroutine 

ritz vectors corresponding converged ritz values needed user call immediately completion dsaupd 
new starting version arpack 

factored cholesky factorization ll mode selected 
mode op inv inv 
appropriate triangular linear systems solved computing inverses 
convergence approximate eigenvector original problem recovered solving ritz vector op 

priori analysis guide selection ncv relative nev formal ncv nev recommended ncv ge 
nev problems type solved experiment increasing ncv keeping nev fixed test problem 
usually decrease required number op operations increases storage required maintain orthogonal basis vectors 
optimal cross respect cpu time problem dependent determined empirically 

iparam reverse interface user 
ido op computed 
iparam op inv computing user overwrite solution linear set equations 
iparam ido user needs provide np iparam shifts locations workl ipntr workl ipntr np workl ipntr np 
eigenvalues current tridiagonal matrix located workl ipntr workl ipntr ncv 
order defined 
associated ritz estimates located draft july appendix arpack routines workl ipntr workl ipntr 
workl ipntr ncv 
dnaupd name dnaupd description reverse communication interface implicitly restarted arnoldi iteration 
subroutine computes approximations eigenpairs linear operator op respect semi inner product defined symmetric positive semi definite real matrix may identity matrix 
note linear operator op real symmetric respect real positive semi definite symmetric matrix op op subroutine 
computed approximate eigenvalues called ritz values corresponding approximate eigenvectors called ritz vectors 
dnaupd usually called iteratively solve problems mode lambda op mode lambda symmetric positive definite op inv factored see mode lambda symmetric semi definite op inv sigma shift invert mode real arithmetic op lambda sigma lambda sigma 
note sigma real imaginary part sigma zero inv sigma inv sigma lambda sigma 
mode lambda symmetric semi definite op inv sigma shift invert mode real arithmetic op lambda sigma lambda sigma 
mode give enhancement eigenvalues close complex shift sigma 
lambda goes infinity operator op mode eigenvalues strongly op defined mode 
note action inv sigma inv accomplished direct method sparse matrix factorization solving sigma iterative method solving systems 
iterative method convergence test stringent accuracy requirements eigenvalue approximations 
usage call dnaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info arguments ido integer 
input output reverse communication flag 
ido zero call dnaupd 
ido set internally indicate type operation performed 
control back calling routine responsibility carry requested operation call dnaupd result 
operand workd ipntr result put workd ipntr 
ido call reverse communication interface ido compute op ipntr pointer workd ipntr pointer workd initialization phase force starting vector range op 
ido compute op ipntr pointer workd ipntr pointer workd ipntr pointer workd ido compute ipntr pointer workd ipntr pointer workd ido compute iparam real imaginary parts shifts pointer workl placing shifts 
see 
ido compute op ido done initialization phase routine shift invert mode vector available need recomputed forming op bmat character 
input bmat specifies type matrix defines semi inner product operator op 
bmat standard eigenvalue problem lambda draft july 
dnaupd bmat generalized eigenvalue problem lambda integer 
input dimension eigenproblem 
character 
input lm want nev eigenvalues largest magnitude 
sm want nev eigenvalues smallest magnitude 
lr want nev eigenvalues largest real part 
sr want nev eigenvalues smallest real part 
li want nev eigenvalues largest imaginary part 
si want nev eigenvalues smallest imaginary part 
nev integer 
input number eigenvalues op computed 
nev 
tol double precision scalar 
input stopping criterion relative accuracy ritz value considered acceptable bounds le 
tol abs ritz abs ritz magnitude ritz complex 
default eps machine precision computed lapack auxiliary subroutine 
resid double precision array length 
input output input info eq 
random initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
output resid contains final residual vector 
ncv integer 
input number columns matrix ncv satisfy inequalities ncv nev ncv indicate arnoldi vectors generated iteration 
startup phase nev arnoldi vectors generated algorithm generates approximately ncv nev arnoldi vectors subsequent update iteration 
cost generating arnoldi vector matrix vector operation op note ncv nev order complex conjugate pairs ritz values kept 
see double precision array ncv 
output contains final set arnoldi basis vectors 
ldv integer 
input leading dimension exactly declared calling program 
iparam integer array length 
input output iparam method selecting implicit shifts 
shifts selected iteration restart arnoldi iteration implicit fashion 
shifts provided user reverse communication 
real imaginary parts ncv eigenvalues hessenberg matrix returned part workl array corresponding 
see 
exact shifts respect current hessenberg matrix equivalent restarting iteration starting vector linear combination approximate schur vectors associated wanted ritz values 
iparam longer referenced 
iparam input maximum number arnoldi update iterations allowed 
output actual number arnoldi update iterations taken 
iparam nb blocksize recurrence 
code currently works nb 
iparam number converged ritz values 
represents number ritz values satisfy convergence criterion 
iparam longer referenced 
implicit restarting 
iparam mode input determines type eigenproblem solved 
see description dnaupd modes available 
iparam np ido user provides shifts reverse communication iparam dnaupd returns np number shifts user provide 
np ncv nev see 
iparam iparam iparam output total number op operations total number operations bmat total number steps re orthogonalization 
ipntr integer array length 
output pointer mark starting locations workd workl arrays matrices vectors arnoldi iteration 
ipntr pointer current operand vector workd 
ipntr pointer current result vector workd 
ipntr pointer vector workd shift invert mode 
ipntr pointer available location workl untouched program 
ipntr pointer ncv ncv upper hessenberg matrix draft july appendix arpack routines workl 
ipntr pointer real part ritz value array workl 
ipntr pointer imaginary part ritz value array workl 
ipntr pointer ritz estimates array workl associated ritz values located workl 
note ipntr referenced 
see 
ipntr pointer real part ncv ritz values original system 
ipntr pointer imaginary part ncv ritz values original system 
ipntr pointer ncv corresponding error bounds 
ipntr pointer ncv ncv upper quasi triangular schur matrix ipntr pointer ncv ncv matrix eigenvectors upper hessenberg matrix referenced true 
see 
note ipntr referenced 
see 
ipntr pointer np shifts workl 
see 
workd double precision array length 
reverse communication distributed array basic arnoldi iteration reverse communication 
user workd temporary workspace iteration 
termination workd contains resid 
invariant subspace associated converged ritz values desired see subroutine uses output 
see data distribution note 
workl double precision array length 
output workspace private replicated array pe array allocated front 
see data distribution note 
integer 
input ncv ncv 
info integer 
input output info eq 
randomly initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
error flag output 
normal exit 
maximum number iterations taken 
possible eigenvalues op 
iparam returns number wanted converged ritz values 
longer informational error 
deprecated starting release arpack 
shifts applied cycle implicitly restarted arnoldi iteration 
possibility increase size ncv relative nev see 
positive 
nev positive 
ncv nev equal maximum number arnoldi update iteration greater zero 
lm sm lr sr li si bmat 
length private array sufficient 
error return lapack eigenvalue calculation starting vector zero 
iparam 
iparam bmat 
iparam equal 
build arnoldi factorization 
iparam returns size current arnoldi factorization 
remarks 
computed ritz values approximate eigenvalues op 
selection mind mode 
convergence approximate eigenvalues original problem may obtained arpack subroutine 

basis invariant subspace corresponding converged ritz values needed user call immediately completion dnaupd 
new starting release arpack 

factored cholesky factorization ll mode selected 
mode op inv inv 
appropriate triangular linear systems solved computing inverses 
convergence approximate eigenvector original problem recovered solving ritz vector op 

priori analysis guide selection ncv relative nev formal ncv nev 
recommended ncv ge 
nev 
problems type solved experiment increasing ncv keeping nev fixed test problem 
usually decrease required number op operations increases storage required maintain orthogonal basis vectors 
optimal cross respect cpu time problem dependent determined empirically 
see chapter information 

iparam ido user needs provide np iparam real imaginary parts shifts locations real part imaginary part workl ipntr workl ipntr np workl ipntr workl ipntr np draft july 
znaupd np workl ipntr np workl ipntr np 
complex conjugate pairs shifts may applied pairs placed consecutive locations 
real part eigenvalues current upper hessenberg matrix located workl ipntr workl ipntr ncv imaginary part workl ipntr workl ipntr ncv 
ordered order defined 
complex conjugate pairs kept associated ritz estimates located workl ipntr workl ipntr 
workl ipntr ncv 
znaupd name znaupd description reverse communication interface implicitly restarted arnoldi iteration 
intended find eigenpairs complex linear operator op respect semi inner product defined hermitian positive semi definite real matrix may identity matrix 
note op real dsaupd dnaupd 
computed approximate eigenvalues called ritz values corresponding approximate eigenvectors called ritz vectors 
znaupd usually called iteratively solve problems mode lambda op mode lambda symmetric positive definite op inv factored see mode lambda symmetric semi definite op inv sigma shift invert mode op lambda sigma 
note action inv sigma inv accomplished direct method sparse matrix factorization solving sigma iterative method solving systems 
iterative method convergence test stringent accuracy requirements eigenvalue approximations 
usage call znaupd ido bmat nev tol resid ncv ldv iparam ipntr workd workl info arguments ido integer 
input output reverse communication flag 
ido zero call znaupd 
ido set internally indicate type operation performed 
control back calling routine responsibility carry requested operation call znaupd result 
operand workd ipntr result put workd ipntr 
ido call reverse communication interface ido compute op ipntr pointer workd ipntr pointer workd initialization phase force starting vector range op 
ido compute op ipntr pointer workd ipntr pointer workd ipntr pointer workd ido compute ipntr pointer workd ipntr pointer workd ido compute return shifts np locations workl 
ido compute op ido done initialization phase routine shift invert mode vector available need recomputed forming op bmat character 
input bmat specifies type matrix defines semi inner product operator op 
bmat standard eigenvalue problem lambda bmat generalized eigenvalue problem lambda integer 
input dimension eigenproblem 
character 
input lm want nev eigenvalues largest magnitude 
draft july appendix arpack routines sm want nev eigenvalues smallest magnitude 
lr want nev eigenvalues largest real part 
sr want nev eigenvalues smallest real part 
li want nev eigenvalues largest imaginary part 
si want nev eigenvalues smallest imaginary part 
nev integer 
input number eigenvalues op computed 
nev 
tol double precision scalar 
input stopping criteria relative accuracy ritz value considered acceptable bounds le 
tol abs ritz abs ritz magnitude ritz complex 
default eps machine precision computed lapack auxiliary subroutine 
resid complex array length 
input output input info eq 
random initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
output resid contains final residual vector 
ncv integer 
input number columns matrix ncv satisfy inequalities ncv nev ncv indicate arnoldi vectors generated iteration 
startup phase nev arnoldi vectors generated algorithm generates approximately ncv nev arnoldi vectors subsequent update iteration 
cost generating arnoldi vector matrix vector operation op note ncv nev order complex conjugate pairs ritz values kept 
see complex array ncv 
output contains final set arnoldi basis vectors 
ldv integer 
input leading dimension exactly declared calling program 
iparam integer array length 
input output iparam method selecting implicit shifts 
shifts selected iteration filter components unwanted eigenvector 
shifts provided user reverse communication 
ncv eigenvalues hessenberg matrix returned part workl array corresponding ritz 
exact shifts respect current hessenberg matrix equivalent restarting iteration updating starting vector linear combination ritz vectors associated wanted eigenvalues 
choice internal shift defined 
iparam longer referenced iparam input maximum number arnoldi update iterations allowed 
output actual number arnoldi update iterations taken 
iparam nb blocksize recurrence 
code currently works nb 
iparam number converged ritz values 
represents number ritz values satisfy convergence criterion 
iparam longer referenced 
implicit restarting 
iparam mode input determines type eigenproblem solved 
see description znaupd modes available 
iparam np ido user provides shifts reverse communication iparam returns np number shifts user provide 
np ncv nev iparam iparam iparam output total number op operations total number operations bmat total number steps re orthogonalization 
ipntr integer array length 
output pointer mark starting locations workd workl arrays matrices vectors arnoldi iteration 
ipntr pointer current operand vector workd 
ipntr pointer current result vector workd 
ipntr pointer vector workd shift invert mode 
ipntr pointer available location workl untouched program 
ipntr pointer ncv ncv upper hessenberg matrix workl 
ipntr pointer ritz value array ritz ipntr pointer projected ritz vector array ipntr pointer error bounds array workl 
note ipntr referenced 
see 
ipntr pointer ncv ritz values original system 
ipntr draft july 
znaupd ipntr pointer ncv corresponding error bounds 
ipntr pointer np shifts workl 
see 
workd complex array length 
reverse communication distributed array basic arnoldi iteration reverse communication 
user workd temporary workspace iteration see data distribution note 
workl complex array length 
output workspace private replicated array pe array allocated front 
see data distribution note 
integer 
input ncv ncv 
double precision array length ncv workspace private replicated array pe array allocated front 
info integer 
input output info eq 
randomly initial residual vector 
info ne 
resid contains initial residual vector possibly previous run 
error flag output 
normal exit 
maximum number iterations taken 
possible eigenvalues op 
iparam returns number wanted converged ritz values 
longer informational error 
deprecated starting release arpack 
shifts applied cycle implicitly restarted arnoldi iteration 
possibility increase size ncv relative nev see 
positive 
nev positive 
ncv nev equal maximum number arnoldi update iteration greater zero 
lm sm lr sr li si bmat 
length private array sufficient 
error return lapack eigenvalue calculation starting vector zero 
iparam 
iparam bmat 
iparam equal 
build arnoldi factorization 
user input error highly 
please check actual array dimensions layout 
iparam returns size current arnoldi factorization 
remarks 
computed ritz values approximate eigenvalues op 
selection mind mode 
operating mode setting lm compute nev eigenvalues original problem closest shift sigma convergence approximate eigenvalues original problem may obtained arpack subroutine 

basis invariant subspace corresponding converged ritz values needed user call immediately completion znaupd 
new starting release arpack 

factored cholesky factorization ll mode selected 
mode op inv inv 
appropriate triangular linear systems solved computing inverses 
convergence approximate eigenvector original problem recovered solving ritz vector op 

priori analysis guide selection ncv relative nev formal ncv nev 
recommended ncv ge 
nev 
problems type solved experiment increasing ncv keeping nev fixed test problem 
usually decrease required number op operations increases storage required maintain orthogonal basis vectors 
optimal cross respect cpu time problem dependent determined empirically 
see chapter information 

iparam ido user needs provide np iparam complex shifts locations workl ipntr workl ipntr 
workl ipntr np 
eigenvalues current upper hessenberg matrix located workl ipntr workl ipntr ncv 
ordered order defined 
associated ritz estimates located workl ipntr workl ipntr workl ipntr ncv 
draft july bibliography anderson bai bischof demmel dongarra du greenbaum hammarling mckenney sorensen 
lapack users guide 
siam philadelphia pa second edition 
arnoldi 
principle minimized iterations solution matrix eigenvalue problem 
quart 
applied mathematics 
bai demmel mckenney 
computing condition numbers nonsymmetric eigenproblem 
acm transactions mathematical software june 
lapack working note 
cullum 
simultaneous computation algebraically largest smallest eigenvalues large symmetric sparse matrix 
bit 
cullum donath 
block lanczos algorithm computing algebraically largest eigenvalues corresponding eigenspace large sparse symmetric matrices 
proceedings ieee conference decision control pages new york 
cullum 
computing eigenvalues large symmetric matrices implementation lanczos algorithm reorthogonalization 
journal computational physics 
daniel kaufman stewart 
reorthogonalization stable algorithms updating gram schmidt qr factorization 
mathematics computation 
dongarra duff sorensen van der vorst 
solving linear systems vector shared memory computers 
siam philadelphia pa 
dongarra duff hammarling 
set level basic linear algebra subprograms 
acm transactions mathematical software 
bibliography dongarra hammarling hanson 
extended set fortran basic linear algebra subprograms 
acm trans 
math 
software 
ericsson ruhe 
spectral transformation lanczos method numerical solution large sparse generalized symmetric eigenvalue problems 
mathematics computation october 
francis 
qr transformation part 
computer journal october 
francis 
qr transformation part 
computer journal january 
golub van loan 
matrix computations 
johns hopkins baltimore second edition 
golub underwood 
block lanczos method computing eigenvalues 
rice editor mathematical software iii pages new york 
academic press 
grimes lewis simon 
shifted block lanczos algorithm solving sparse symmetric generalized eigenproblems 
siam matrix analysis applications january 
karush 
iterative method finding characteristics vectors symmetric matrix 
pacific mathematics 
lanczos 
iteration method solution eigenvalue problem linear differential integral operators 
research national bureau standards october 
research 
lawson hanson kincaid krogh 
basic linear algebra subprograms fortran usage 
acm transactions mathematical software 

analysis implementation implicitly restarted iteration 
phd thesis rice university houston texas may 
available technical report tr dept computational applied mathematics 

restarting arnoldi reduction 
preprint mcs argonne national laboratory argonne il 
scott 
evaluation software computing eigenvalues sparse nonsymmetric matrices 
preprint mcs argonne national laboratory argonne il 
draft july bibliography sorensen 
deflation techniques implicitly restarted arnoldi iteration 
siam matrix analysis applications 
appear 

adaptive procedure estimating parameters nonsymmetric iteration 
numerische mathematik 
sorensen 
portable implementation arpack distributed memory parallel architectures 
proceedings copper mountain conference iterative methods april volume 
karl alastair spence 
implicitly restarted arnoldi purification shift invert transformation 
mathematics computation 
appear 
morgan 
restarting arnoldi method large nonsymmetric eigenvalue problems 
mathematics computation july 
parlett thomas ericsson paul jensen 
implement spectral transformation 
mathematics computation april 
paige 
computation eigenvalues eigenvectors large sparse matrices 
phd thesis university london london england 
parlett 
symmetric eigenvalue problem 
prentice hall englewood cliffs 
parlett poole 
geometric theory qr lu power iterations 
siam numerical analysis april 
parlett scott 
lanczos algorithm selective orthogonalization 
mathematics computation 
saad 
variations arnoldi method computing large unsymmetric matrices 
linear algebra applications 
saad 
chebyshev acceleration techniques solving nonsymmetric eigenvalue problems 
mathematics computation 
saad 
numerical methods large eigenvalue problems 
press 
saad schultz 
gmres generalized minimal residual algorithm solving nonsymmetric linear systems 
siam journal scientific statistical computing july 
draft july bibliography simon 
analysis symmetric lanczos algorithm reorthogonalization methods 
linear algebra applications 
sorensen 
implicit application polynomial filters step arnoldi method 
siam matrix analysis applications january 
sorensen 
implicitly restarted arnoldi lanczos methods large scale eigenvalue calculations 
keyes sameh editors parallel numerical algorithms dordrecht 
kluwer 
appear 

separation matrices 
siam journal numerical analysis april 
watkins 
convergence algorithms decomposition type eigenvalue problem 
linear algebra applications 
wilkinson 
algebraic eigenvalue problem 
clarendon press oxford uk 
draft july 
