revisiting structured storage transactional record store robert grimm michael swift henry levy university washington cs washington edu uw cse increasing number applications electronic mail servers web servers personal information managers handle large amounts homogeneous data 
data ectively represented records manipulated simple operations record reading writing searching 
unfortunately modern storage systems inappropriate needs applications 
side le systems store unstructured data byte strings limited reliability guarantees 
side relational databases store structured data provide concurrency control transactions relational databases slow complex dicult manage applications 
presents transactional record store directly addresses needs modern applications 
store combines simplicity manageability le system interface select features managing record oriented data 
describe principles guiding design transactional record store design 
prototype implementation performance evaluation 
success internet years seen proliferation networked data services electronic mail servers web servers personal information managers 
applications manage data regular structure easily represented records distinct elds contacts schedules user preferences customer orders 
electronic mail messages merchandise descriptions regular organized set de ned elds sender subject order number 
internet applications exhibit fairly simple workloads 
task sequentially access small number data sources example user browses merchandise descriptions server processes customer order 
result perform relatively simple set operations read modify search small records 
applications typically require replication availability reliability 
expect see increasing number data centric applications wider range computing devices running 
hardware side non traditional computing devices palm sized computers cell phones wide spread provide access user contacts messages 
newer devices pads commercially released 
software side services implement highly available scalable networked servers replication schemes speci cally designed mobile environment automate synchronization data remote mobile nodes :10.1.1.116.1182:10.1.1.116.6208:10.1.1.1.2034
despite diversity existing applications common data storage needs management persistent storage remains challenge 
currently application choices le systems databases fails meet application needs dimensions 
file systems typically store unstructured data provide limited failure atomicity making ill suited reliably storing large numbers homogeneous records 
object stores relational databases manage objects records respectively provide concurrency control reliability transactions 
object stores optimized maintaining heterogeneous objects linked relationships 
relational databases far complex dicult manage provide considerable functionality support query language joins batch processing 
functions overkill modern networked data services come high cost 
address lack appropriate storage solutions transactional record store combines simplicity manageability le system interface select features managing record oriented data 
records stored tables records table share eld names types 
records rows table elds columns 
tables turn organized directories resulting hierarchical name space similar le system 
simplify replication store exposes globally unique identi ers guids individual records tables directories 
ensure performance uses simple expressive hinting system 
provide reliability failures operations atomic transactions group operations atomic unit 
record storage system service new idea 
example ibm vsam compaq rms palm computing palm os provide record storage system level 
raises question necessary revisit topic structured storage 
believe record storage system service important reasons 
relatively new class applications discussed requires 
second common computing platforms er record storage 
result commercial applications ship application speci solution leading unnecessary application complexity considerable duplication functionality build top relational database performance cost complexity implications 
third important building viable record store hard obvious right trade scalability exibility complexity performance 
primary contribution thorough exploration trade rest structured follows 
section develops principles guiding design transactional record store section presents actual design 
section describes prototype implementation section re ects experiences building prototype performance 
section reviews related 
section concludes 
principles practical record store data centric applications meet requirements 
reliable operations atomic face failures 
particularly crucial economic signi cance internet services 
second record store scalable implementable wide range computing platforms wearable devices largescale clusters 
third ectively support application speci replication providing exibility performance replication mechanisms 
relational databases tables store large numbers records provide transactions reliability 
techniques implementing eciently known 
reason base record store tables transactions 
relational databases provide complex functionality query language joins batch processing limited networked data services 
furthermore databases typically implement replication internally lack ective support application speci replication schemes 
key issues record store features provide structure various interfaces 
guide design fundamental principles 
limit global knowledge 
knowledge locally generated managed possible 
primary purpose principle ensure ecient implementation scalability limiting need global coordination system state 

don hide power 
abstraction barrier applications record store hide expressive power 
primary purpose principle ensure record store provides sucient functionality 

separate independent concerns 
di erent design aspects data layout data access performance access control clearly separated distinct operations abstractions 
primary purpose principle ensure record store easy replicate 
principles clearly useful features may follow principle violate 
principles need carefully weighed requirements data centric applications discussed 
principles con ict typically favor limiting global knowledge aid scalability 
design design records stored tables collections identically structured records 
record table elds name type record eld needs store value 
operations tables ect table 
addition table distinct operations manage schema elds performance hints access control information data 
operations straight forward access modify table meta data data 
example schema operations allow application add change individual elds lookup eld name retrieve list table elds 
tables organized directories support typical directory operations entry lookup move 
directories facilitate logical grouping related tables resulting hierarchical name space provides convenient proven interface managing persistent storage 
adding les separate storage abstraction addition tables possible integrate record byte string storage single storage system 
aid manageability store supports symbolic links form aliases aliases directories tables automatically resolved lookup 
call aliases directories tables store objects 
provide reliability store operations atomic applications specify transaction group operations atomic unit 
provide consistency transactions fully serializable default 
transactions combine separate concerns atomicity concurrency control violates principles 
result applications need reliability singlethreaded contact manager running cell phone pay overhead concurrency control 
record store includes option set di erent isolation level individual transactions 
speci ed record store form set java interfaces exceptions 
speci cation rely features unique java simply serves concise description record store application programming interface api 
store consists interfaces represent simple descriptors elds queries hints total methods 
contains exceptions represent speci exceptional conditions subclasses class 
transactions rely jini transaction speci cation 
pro guid add guid list fields list data txn add new record guid data fields return guid 
null guid automatically generated 
void write guid list fields list data txn write data fields record guid list read guid list fields txn read fields record guid return data 
results query query list values txn instantiate query values perform instantiated query return iterator results 
void delete guid txn delete record guid methods accessing table records 
records added written read deleted time guid 
contrast queries search records application speci criteria return result 
applications group operations atomic unit passing transaction txn short transaction parameter 
methods may throw 
guids explained detail queries 
vides avor interfaces showing operations access table data 
rest section structured follows 
describe motivation globally unique identi ers followed queries hints access control 
conclude section summary design 
globally unique identi ers primary challenge implementing application speci replication scheme structured store identi cation records collections records node boundaries 
general database implementations require internal identi er uniquely name records record store formalizes identi er associates globally unique identi ers guids records store objects aliases directories tables 
guids represent attractive choice identi er speci cation guids includes algorithm generating autonomously node guaranteeing globally unique 
guids associated store objects records creation immutable 
applications record store create fresh guid explicitly specify guid 
typically applications allow record store create guid store object record originally created node 
specify corresponding guid store object record propagated replica 
principle limiting global knowledge record store enforces uniqueness guids limited scope 
particular store guarantees uniqueness guids records single table uniqueness guids store objects local name space 
store objects guids provide alternative name space store objects looked deleted name guid 
possible locate replicated store objects different nodes di erent names di erent nodes long store objects share common guid 
result store objects ectively replicated di erent nodes may di erent policies organizing local store 
records guids provide name space 
table eld representing records guids comparable primary key relational database 
shown records added written read deleted guid 
furthermore operations manipulate record time 
simplicity regularity operations simpli es logging replication 
believe represent undue limitation tasks need access small number records 
access records guid sucient applications external identi ers user names book titles need searched 
queries applications search records table queries example searching mail messages sent particular user 
query limited guid record access return record 
query parts select clause speci es records select possibly empty list sort clauses speci es sort order selected records list elds speci es elds return selected sorted records 
select clause consists compare eld value 
value may speci ed times query creation time query execution time 
case record store creates query template instantiated actual value execution time see 
comparisons may negated combined conjunctions disjunctions 
result query iterator selected sorted records 
challenge designing query facility record storage balance expressiveness implementation complexity performance 
consistent principle limiting global knowledge queries just operations tables restricted single table avoiding complexities associated supporting joins 
furthermore consistent principle hiding power queries support sort clauses templates 
sort clauses ensure query results ordered 
applications need sort returned data record store ectively schedule prefetching query results 
templates applications express structure common queries example resulting users lling search forms 
record store optimize table layout indexes performing queries 
hints application speci hints successfully optimize caching prefetching behavior le systems suggesting ective mechanism optimizing performance record storage 
le systems hints dynamically issued applications primarily control dynamic behavior le system cache 
perform record store needs optimize management cache optimize disk layout tables disk order records generation indexes elds generate indexes 
record store consequently uses sets hints characterize dominant access patterns tables 
hints explicitly created speci table statically associated 
expect change workloads change 
individual hints describe add write read query delete operation 
name simplify programmatic access weight specifying hint relative importance 
hints add write read operations specify elds added writ hint int type string name int weight list fields query create new hint type name weight 
fields specifies fields add write read hints 
specifies query query hints 
void list hints txn set table hints 
list txn get table hints 
table operations hints 
hints created speci table accessed set 
methods may throw may throw 
read 
hints queries specify query performed 
illustrates interface managing hints 
hints record store optimize creation indexes physical layout table 
example workload speci ed hints dominated reads record store create indexes elds searched queries 
time workload balanced reads writes create indexes frequently searched elds 
majority queries search particular eld sorted particular eld store records ordered eld 
access control choosing appropriate access control model record store dicult 
common le systems unix windows nt typically form access control list acl stored le meta data maintained le system 
time increasing number systems base access control name resource meta data 
example java security distributed virtual machines domain type enforcement rely central policy descriptions resource names 
similarly spki uses authorization certi cates specify name resource 
shown merging le system permission models dicult 
settling models developing viable want record store scale wide permission corresponding rights add add directory table 
write change directory record 
read read data meta data 
delete delete store object record 
control change store object record acl 
layout change table schema 
hint change table performance hints 
table permissions record store 
range computing platforms 
store chose specify standard interface external access controller implements platform speci access control model 
access controller interface supports name access control invoked record store operations 
tables provide access control granularity entire table individual records individual elds 
order keep access controller interface simple uses permissions represent individual record store operations shown table 
record store manages acls associated store objects records acl access control 
stores internal binary representation meta data lets applications access external object representation 
furthermore uses access controller convert representations 
newly created store objects automatically inherit copy parent directory acl 
similarly newly added records protected table acl 
complete interface access controller shown 
summary design records stored tables tables turn organized directories forming hierarchical name space similar le systems 
ensure scalability record store operations tables ect table 
ensure reliability operations atomic applications transactions group operations atomic unit 
simplify replication records associated guids accessed guid record time 
applications queries search records criteria 
furthermore applications provide hints record store optimize table access layout applications workload 
access public interface boolean return true access controller uses acls 
void check string name guid int perm byte acl check caller permissions perm store object name guid void check string path guid guid list fields int perm byte acl check caller permissions perm fields record guid table name guid 
acl convert byte acl convert binary representation acl object representation 
byte convert acl acl convert object representation acl binary representation 
interface access controller 
name argument check methods fully quali ed name contain aliases corresponding store object 
access controller uses acls record store passes acl protecting store object record corresponding check method 
check methods throw check fails 
control delegated external access controller perform checks acls names 
prototype implementation primary goal prototype implementation provide platform validating design meets needs modern data centric applications ectively supports replication 
decided implement prototype relational database backing store providing native implementation 
may strange decision assertion relational databases complex prototype relational database acts simply reliable persistent store support transactions 
implementation written java uses jdbc access underlying database 
consists classes lines documented code 
implementation maps record store database follows 
uses separate database table store record store table 
additionally uses database tables store meta data hierarchical name space eld descriptors record store tables hints record store tables 
minimize performance overhead caused database implementation extensive caching 
transactions implicit property database connections jdbc access database 
implementation maintains pool connections maps explicit transactions record store api corresponding database connections 
furthermore uses prepared statements operations record store tables caches reuse 
caches java objects representing store objects 
experiences order gain experience record storage interface implemented benchmark programs measured execution record store 
comparison implemented measured tests straight jdbc 
benchmark programs 
micro benchmark creates simple dictionary table mapping integer keys string values 

application implementing portion tpc benchmark commerce searches database books author 

application tpc benchmark implements user database supporting account additions account updating order 

simple mail server supports functions necessary responding imap requests 
layered mail server top replication module intercepts calls record store copies data peer machine 
writing programs allowed gauge usefulness record store api discover aws 
record store interface easier jdbc due clean design 
useful features turned automatic connection management simpli es multi threaded programming explicit transaction support proved simpler associating transactions connections 
furthermore experiences showed interface suciently powerful write real application simple implement replication top 
major drawback api turned verbosity perform operations take single line sql code requires lines build corresponding record store data structures 
api encourages re data structures complexity centralized 
programs demonstrated performance record store layered top jdbc seriously 
experimental setup goals evaluating prototype implementation 
rst sure implementation major impact performance relative jdbc 
second demonstrate record store performs workloads targets commerce electronic mail 
third show interface ectively support replication mechanism 
experiments sun hotspot server virtual machine version rc commercial relational database underlying storage layer 
performed commodity pcs mhz pentium iii processor mbyte ram ide hard disks connected mbps switched ethernet 
report average trials experiment 
micro benchmarks rst micro benchmark tests overhead introduced record store interface 
test table elds integer key string value populated data queried integer key nally updated guid 
size string varied bytes bytes near maximum bu er size jdbc 
throughput results show performance di erence greater add add add write write write query query query operation value size operations second jdbc record store performance comparison jdbc record store adding writing querying byte values 
bars represent throughput operations second 
occurs small data items stored bu er cache database 
represents worst case performance overhead record store interface amortized reading just bytes data 
larger data values overhead drops 
byte values performance writes better byte values due underlying database implementation 
test demonstrates overhead introduced record store relatively small severely compromise performance jdbc 
test simulates search author web interaction database operations tpc ecommerce benchmark 
test tables author table book table populated set author names book titles randomly generated tool provided benchmark speci cation 
book record contains eld identifying book author author id test program picks random author name queries books authors names start letters 
titles authors stored separate tables implementation top jdbc uses join operation author id tables 
record store interface implemented performing nested loop join rst program queries author nd author id book table queried nd books author 
ran test searching fty books 
results shown illustrate number books result jdbc record store performance comparison jdbc record store searching database books author 
bars represent throughput operations second books requested 
signi cant performance penalty interface relational operators 
results searching single book somewhat anomalous 
case data set small database bu er cache 
due bug jdbc record store iterate results query 
consequently jdbc implementation able satisfy searches single book memory record store forced go disk 
results searching books better demonstrate penalty supporting relations 
throughput results throughput jdbc results fast 
di erence accounted record store implementation issuing separate queries author sucient number results 
test demonstrates common web applications searching database returning small number results record store performs common order di erences database performance occur 
nal micro benchmark implements buy request web interaction tpc 
test uses table user accounts separate table addresses 
request session user logs existing account creates new user account address 
user may exit ordering case logon time account updated order causes account read account balance updated 
bench requests ordering new users requests second jdbc record store performance comparison jdbc record store simulating user sessions ecommerce site 
portion sessions resulting creation new user accounts varies 
similarly portion sessions resulting order varies 
bars represent throughput requests second 
mark intended highlight mixed read write performance 
order explore sensitivity record store mix read write operations varied percentage new users percentage users making order 
results shown illustrate performance record store causes negligible loss throughput drops performing disk intensive write operations 
test demonstrates realistic workload read write operations record store interface adds negligible overhead jdbc 
indicates native implementation perform equally better 
replication nal test implemented simple mail server program top record store inserted replication layer underneath mail server 
replication layer implements replication protocol porcupine cluster mail server designed ecient multi master replication small number peers :10.1.1.116.6208
protocol uses writer wins strategy resolving update con icts causes update rewrite object new contents 
appropriate mail server mail messages typically created deleted modi ed 
replication code written layer intercepts requests record store logs updates passing requests 
replication layer uses background thread read objects referenced replication log copy replication peers 
test mail server created client program generates requests send mail read mail particular user 
size messages sent chosen size distribution users reading mail chosen randomized round robin fashion :10.1.1.116.6208
clients randomly choose send mail read mail equal probability 
avoid overhead parsing mail protocols tests simpli ed rpc mechanism sends serialized java objects tcp connection 
experiments machines running clients machines running server depending data replicated 
shows results mail server replication handling requests clients servers replication handling requests number clients 
results demonstrate replication causes performance drop single client replication increases scalability mail system clients 
increased scalability reasons 
updates arrive replication user need authenticated mailbox need located 
second updates arrive batches overhead processing individual requests 
experiment shows replication readily implemented top record store increase application scalability client communication relatively expensive 
summary believe record store api considerably simpli es implementation applications 
furthermore implementation top relational database record store introduces small performance overhead applications 
provides ective platform application speci replication exposes small number simple operations modify data captured replication layer 
client clients clients number clients non replicated mail replicated mail performance comparison mail server replication 
clients randomly send mail retrieve mail users 
non replicated test uses single server multiple clients replicated test splits clients servers replicate data 
bars represent throughput mail system messages second 
related storage systems cover wide range design points space possible storage solutions aspects stand 
rst aspect data structured second storage system ensures reliability third abstraction level provided storage system 
traditionally storage systems store unstructured structured data 
side le systems recoverable virtual memory rvm manage basically unstructured data 
side record stores object stores tuple spaces relational databases manage records objects 
semi structured data notably xml just emerging alternative unstructured structured data 
time eciently storing querying semistructured data topic active research 
file systems nearly ubiquitous store unstructured data considerably complicates concurrent updates le replication 
furthermore orts explored providing failure atomicity le systems underlying disk system le systems limit failure atomicity meta data provide :10.1.1.42.420
rvm represents fault tolerant alternative managing application state providing transactional guarantees regions virtual memory 
memory les inherently unstructured rvm su ers similar problems 
data directly mapped application address space considerably complicates ective sharing applications replication 
record stores ibm vsam compaq rms provide record oriented storage api include support indexes 
record stores expose disk layout records lack high level mechanisms ensuring atomicity suitable underlying storage layer record store general storage abstraction applications 
palm computing palm os distinguish main memory persistent storage 
record storage limited providing possibly sorted list records represents lower level abstraction 
object stores thor provide persistent heap objects 
preserving structure application objects applications safely share data 
transactions provide concurrency control reliability failures 
object stores optimized storing heterogeneous objects maintaining relationships storing large collections homogeneous records 
tuple spaces javaspaces spaces emerging new kind network service 
tuple space stores objects supports basic operations write add object read return copy object matches template take remove return object matches template 
tuple spaces support collections homogeneous objects transactions reliability limited interface suited data centric applications frequently modify data 
relational databases speci cally designed store large collections records provide concurrency control reliability transactions support sophisticated queries access data 
widely underlying store server applications 
furthermore embedded databases increasingly storage substrate resource limited devices personal digital assistants 
level abstraction provided databases higher record store support relations query language replication resulting system overly complex requires signi cant management orts 
record store record stores relational databases manages record oriented data 
store provides operations atomic failures applications transactions group operations atomic unit 
compared systems described designed record store provide simple interface specifically tuned needs modern networked data services 
particular interface simpler record stores provides higher level abstraction hides disk layout data simpler relational databases support advanced features cleaner interfaces systems clearly separates di erent concerns provides separate operations abstractions represent 
record store system speci cally designed support application speci replication 
new generation networked data services appeared due part success internet 
applications store retrieve relatively simple data objects high demands availability reliability requires replication 
le systems databases provide match internet applications 
transactional record store better meets requirements modern data centric applications 
design record store principles limit global knowledge don hide power separate independent concerns 
store combines manageability le system interface select features managing record oriented data 
records stored tables organized hierarchical name space 
simplify replication store exposes globally unique identi ers individual records objects name space 
ensure performance store uses simple expressive hinting system 
provide reliability failures operations atomic applications transactions group operations single atomic unit 
implementation record store top relational database shows negligible overhead direct database access workloads dominated reads writes reasonable overhead workloads dominated relational operations 
furthermore implementation demonstrates record store ective platform implementing application speci replication 
considering extensions record store 
wish support basic type addition existing numeric string binary types 
applications speci records pair guids record table record 
principle hiding power suggests type formalized especially provide information data prefetch 
support raises question ensure integrity 
side relational databases provide referential integrity primary foreign keys help applications maintain consistency related records 
side referential integrity clearly violates principle limiting global knowledge 
consequently plan investigate networked data services may utilize order better understand requirements 
second emergence tuple spaces new kind network service raises question ectively implement 
tuple spaces lend storage table supporting multiple versions subclasses objects mapping non trivial 
consequently plan determine minimal feature set necessary implement tuple spaces directly record store integrate tuple record storage 
acknowledgments brian bershad input early discussions project 
david ely suzanne swift comments earlier versions 
agrawal el abbadi 
epidemic algorithms replicated databases 
proceedings th acm symposium principles database systems pages tucson arizona may 
arnold sullivan er waldo wollrath 
jini speci cation 
addisonwesley 
badger sherman walker 
practical domain type enforcement unix 
proceedings ieee symposium security privacy pages oakland california may 
bernstein harry sanders 
microsoft repository 
proceedings rd international conference large data bases pages athens greece aug 
bernstein pal 
prefetch implementing objects relations 
proceedings th international conference large data bases pages edinburgh scotland sept 
bey freeman mulder 
palm os sdk 
technical report palm computing santa clara california jan 
bray paoli sperberg mcqueen 
extensible markup language xml 
recommendation world wide web consortium cambridge massachusetts feb 
english jacobson stepanov wilkes 
mime high performance parallel storage device strong recovery guarantees 
technical report hpl csp rev hewlett packard nov 
anderson kazar mason sidebotham 
episode le system 
proceedings winter usenix conference pages san francisco california jan 
compaq 
record management services 
manual aa pv rc tk compaq computer houston texas jan 
crispin 
internet message access protocol version 
rfc internet engineering task force dec 
ellison lampson rivest thomas 
spki certi cate theory 
rfc internet engineering task force sept 
hightower anderson borriello 
century challenges data centric networking invisible computing 
proceedings fifth acm ieee international conference mobile computing networking pages seattle washington aug 
fox gribble chawathe brewer gauthier 
cluster scalable network services 
proceedings th acm symposium operating systems principles pages saint malo france oct 
freeman arnold 
javaspaces principles patterns practice 
addisonwesley 
ganger patt 
metadata update performance le systems 
proceedings st usenix symposium operating systems design implementation pages monterey california nov 
gong 
inside java platform security architecture api design implementation 
addison wesley june 
gray neil shasha 
dangers replication solution 
proceedings acm sigmod international conference management data pages montreal canada june 
gray reuter 
transaction processing concepts techniques 
morgan kaufmann 
greene 
microsoft new war oracle show 
seattle times page 
november 
grimm hsieh de jonge kaashoek 
atomic recovery units failure atomicity logical disks 
proceedings th ieee international conference distributed computing systems pages hong kong may 
hagmann 
reimplementing cedar le system logging group commit 
proceedings th acm symposium operating systems principles pages austin texas nov 
hitz allison hawley 
merging nt unix lesystem permissions 
proceedings nd usenix windows nt symposium pages seattle washington aug 
iso iec 
information technology database languages sql 
iso iec standard international standards organization international electrotechnical commission geneva switzerland 
keleher 
decentralized replicated object protocols 
proceedings th annual acm symposium principles distributed computing pages atlanta georgia may 
keller jensen agarwal 
persistence software bridging object oriented programming relational databases 
proceedings acm sigmod international conference management data pages washington dc may 
tomkins patterson bershad cao felten gibson karlin li 
trace driven comparison algorithms parallel prefetching caching 
proceedings nd usenix symposium operating systems design implementation pages seattle washington oct 
leach 
guids 
internet draft draft leach guids txt internet engineering task force feb 
liskov castro shrira adya 
providing persistent objects distributed systems 
guerraoui editor proceedings th european conference object oriented programming volume lecture notes computer science pages lisbon portugal june 
springer verlag 
lowell chen 
free transactions rio vista 
proceedings th acm symposium operating systems principles pages saint malo france oct 
mckusick ganger 
soft updates technique eliminating synchronous writes fast lesystem 
proceedings freenix track usenix annual technical conference pages monterey california june 
microsoft 
replication sql server 
white microsoft redmond washington dec 
www microsoft com sql replication htm 
mishra 
join processing relational databases 
acm computing surveys mar 
lesser 
vsam techniques system concepts programming procedures 
qed information sciences 
oracle 
oracle advanced replication 
technical white oracle redwood california feb 
www oracle com database documents adv replication pdf 
ortiz jr embedded databases come hiding 
ieee computer mar 
petersen spreitzer terry theimer demers 
flexible update propagation weakly consistent replication 
proceedings th acm symposium operating systems principles pages saint malo france oct 
rosenblum ousterhout 
design implementation log structured le system 
acm transactions computer systems feb 
saito bershad levy :10.1.1.116.6208
manageability availability performance porcupine highly scalable internet mail service 
proceedings th acm symposium operating systems principles kiawah island resort south carolina dec 
satyanarayanan kumar steere kistler 
lightweight recoverable virtual memory 
proceedings th acm symposium operating systems principles pages asheville north carolina dec 
sirer grimm gregory bershad 
design implementation distributed virtual machine networked computers 
proceedings th acm symposium operating systems principles pages kiawah island resort south carolina dec 
steere 
exploiting non determinism asynchrony set iterators reduce aggregate le latency 
proceedings th acm symposium operating systems principles pages saint malo france oct 
tpc 
tpc benchmark speci cation transaction processing performance council san jose california feb 
weiser 
computer rst century 
scienti american sept 
white fisher cattell hamilton 
jdbc api tutorial 
addison wesley second edition june 
widom 
data management xml research directions 
ieee data engineering bulletin sept 
lehman ford 
spaces 
ibm systems journal 
