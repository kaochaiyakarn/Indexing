journal visual languages computing representation design benchmarks design time aid vpl navigable static representations sherry yang margaret burnett moshe zloof department computer science oregon state university corvallis yang cs orst edu burnett cs orst edu hewlett packard labs box palo alto ca hpl hp com zloof hpl hp com received august revised march accepted april weakness interactive visual programming languages vpls static representations 
lack adequate static representation places heavy cognitive burden vpl programmers remember potentially long dynamic sequences screen displays order understand previously written program 
problem widely acknowledged research design better static representations interactive vpls infancy 
building cognitive dimensions developed programming languages cognitive psychologists green developed set concrete benchmarks vpl designers designing new static representations 
benchmarks provide design time information improve vpl static representation 
academic press limited 
visual programming languages vpls highly interactive 
languages process creating program incremental opportunities interactive visual feedback way 
place object screen experiment effects objects peer components object clicking watch dynamic behavior simply observing changes occur screen snippet program executes 
dynamic visual feedback integrates support rapid program construction continuous debugging feature provides advantages 
program constructed maintenance phase begins 
probably different original programmer understand previously written program able modify 
understanding previously written program involves tasks common creating new program maintenance process provide contextual information supported part hewlett packard national science foundation ccr nsf young investigator award 
vl academic press limited sherry yang inherent creation process 
example maintenance programmer need learn structure program need search identify relevant section program necessarily having seen trying pieces program exist affected changes 
dynamic mechanisms helpful program creation debugging tasks listed previous paragraph beg static view program allows programmer study logic relationships program heavy cognitive burden remembering fine grained dynamic sequences visual activity obtain needed information 
unfortunately lack adequate static representations long weakness interactive vpls 
numerous research descriptions taxonomies analyses counted static representation important largely unsolved issue vpls 
describe representation design benchmarks flexible set measurement procedures vpl designers designing new static representations languages 
benchmarks focus exclusively static representation part vpl provide designer yardstick measuring particular design fulfills design goals related static representation usefulness programmers 
benchmarks currently oregon state university hewlett packard laboratories design new static representations languages forms icbe 
representation design benchmarks concrete application cognitive dimensions programming systems researchers field cognitive psychology :10.1.1.22.1477
cognitive dimensions provide foundation appropriate cognitive issues representing programs provide increment formality previous ad hoc methods 
measures particular cognitive dimensions applied vpl static representations added kinds refinements provided concrete ways measuring cognitive dimensions design time directly focusing static representation part vpl 

related cognitive dimensions cds set terms describing structure programming language components relate cognitive issues programming :10.1.1.22.1477:10.1.1.22.1477
cds listed appendix provide framework assessing cognitive attributes programming system understanding cognitive benefits costs various features language environment 
dimensions intended high level discussion tools examine various aspects languages environments devised usable language designers non psychologists 
cds researchers evaluate cognitive aspects vpls broad comparisons cognitive aspects different vpls 
example green petre cds contrast cognitive aspects commercial vpls prograph labview see appendix excerpt 
cds evaluate pursuit research programming demonstration vpl ford cds evaluate general purpose visual programming representation design benchmarks system 
hendry cds evaluate cognitive aspects modification spreadsheet formula languages 
cds design time evaluation approaches applied vpls 
programming walkthrough 
programming walkthroughs conducted team includes language designer hci expert may include intended evaluation language respect suitability writing new programs 
emphasis evaluation done suite sample programming problems context language opposed language 
realm software metrics glinert introduced framework formulating software metrics compare visual computing environments 
attractiveness users visual computing environment measured attributes speed performance debugging facilities support animation multiple views 
framework deal cognitive issues program representation deals features environment appealing users 
cognitive evaluative techniques specific vpl evaluation directed graphically oriented software systems general help evaluating vpl static representation 
main reason techniques focus user interactions proposed implemented user interface presence information useful programmers representation 
goms pattern analysis heuristic evaluation layout appropriateness methods 
example goms detailed methodology giving quantitative time predictions user perform activities defined detailed sequence simple tasks delete word 
maximal repeating pattern analysis detects patterns user actions working application intention optimizing user interface commonly performed actions 
heuristic evaluation general evaluative technique rates user interface set usability principles simple natural dialogue speak user language minimize user memory load 
layout appropriateness metric aimed assisting designers organizing widgets user interfaces frequency different sequences actions users perform 
important difference evaluative techniques graphically oriented software representation design benchmarks focus system support fine grained user interactions measure representation ability useful information program programmers 

terminology overview problem intend representation design benchmarks contribute design better vpl static representations 
focus directly problem measure vpl static representation isolation rest vpl 
believe measuring static representation vpl rest vpl highly interactive dynamic necessary get clear view strengths weaknesses static representation 
precise exactly measured benchmarks vpl navigable static representation define 
sherry yang 
navigable static representations informally vpl static representation appearance visual program rest screen snapshot 
formally term static representation mean set item information program displayed simultaneously infinitely large piece screen 
supply expands flexibly accommodate size program printed computer display screen 
account accessibility static representations viewed display screen consider vpl set dynamic navigational devices menus scrollbars map static representation infinitely large screen finite physical screen 
term set devices take static representation input map subset static representation output navigational instrumentation 
define language navigable static representation tuple ni vpl static representation ni vpl navigational instrumentation 
remainder term representation read abbreviation cumbersome phrase navigable static representation 

applying definition example example consider programming displays static story board modifications demonstrated objects program 
suppose static dataflow view program may placed screen pull menu selection removed similarly 
consider dataflow view part vpl navigable static representation 
definition navigable static representations view navigable static representation ni 
static views fit definition dynamic navigation devices static dataflow view ni 
key point determining visible item information lies word simultaneously definition static representations 
order achieve screen lifetime item information curtailed programmer chooses remove 
returning example programmer dataflow view display time items displayed infinite screen view words adding availability dataflow view decreases story board view availability case accessed browser tool allowing view time view element views displayed simultaneously permanently multiple dynamic browser tools operate independently views elements vpl navigable static representation 

implications definition example demonstrates elements vpls ni 
examples include animations sound annotations alternative views remain indefinitely screen 
elements vpl ni representation design benchmarks measured benchmarks 
say elements valuable outside scope benchmarks devised help designer focus exclusively just portion vpl navigable static representation 
note definition navigable static representation distinguish language related versus environment related aspects vpl 
classifying item information language related environment related help determine navigable static representation 
representation design benchmarks focus availability quality information provided programmer piece vpl doing providing 

cognitive dimensions representation design benchmarks selected cds foundation approach conducive goal providing high level design time measures vpl designer designing language navigable static representation 
foundation derived set benchmarks obtain quantitative measurements navigable static representations follows 
started selecting cds applied considering characteristics denoted sc presence denoted sp elements static representation example closeness mapping cd pertains characteristics static representation elements sc considers characteristic programming language constructs compare entities particular domain 
hand progressive evaluation cd refers presence program answers programming environment answers shown static view cd applied possible element sp static representation 
narrowed selected dimensions focus solely navigable static representations 
example progressive evaluation cd relates dynamic display answers narrowed focus solely inclusion answers navigable static representation 
narrowed set cds devised quantitative sc sp measures 
addition sp benchmark devised corresponding coarse grained effort measure number steps navigational instrumentation ni requires programmer display element information map infinite screen finite screen way element visible 
conducted empirical study learn suitability benchmarks design aid 
benchmarks summarized table 
sections discuss relationships benchmarks corresponding cds apply section describes empirical study 

representation design benchmarks purpose representation design benchmarks provide set design time measures vpl designers measure improve design ideas navigable static representations languages 
wanted design time approach sherry yang table 
summary representation design benchmarks 
sc denotes measures characteristics elements sp denotes measures presence potential elements corresponding ni measure computation sc sp ni aspect representation benchmark name visibility dependencies sources dependencies explicitly depicted sources dependencies system worst case number steps required navigate display dependency information ps visibility program structure representation explicitly show parts program logically fit 
ps worst case number steps required navigate display program structure visibility program logic representation explicitly show element computed 
worst case number steps required program logic visible number sources generality display results possible see results displayed statically program program logic source code 
worst case number steps required display results 
sn secondary notation non semantic devices number secondary notational devices available optional naming layout devices semantic impact textual annotations comments static graphical annotations 
sn worst case number steps access secondary notations ag abstraction gradient number sources details abstracted away data details operation details details fine grained portions programs details ni devices 
representation design benchmarks ag worst case number steps away details ri accessibility related possible display related information side side 
information ri worst case number steps required navigate display related information 
screen real estate maximum number program elements displayed physical screen 
number non semantic intersections physical screen obtaining score closeness specific audience background number answers number questions questions general form representation element look object operation composition mechanism intended audience prerequisite background sherry yang approach lifecycle problems uncovered design time easier correct uncovered prototype built 
quality problem discovery process greater done design time 
example winograd points studying usability user provide substantive suggestions rough design polished prototype 
observation borne experiences point elaborate 
benchmarks step process 
designer determines aspect representation measured benchmark applies vpl identifies aspect language representation corresponds element characteristic measured benchmark 
example designer vpl intended tiny applications probably omit scalability benchmarks 
second designer computes measurements 
third designer interprets computation maps measurement subjective rating scale 
provided sample mapping appendix mapping necessarily reflects goals value judgments particular language designers expect different designers mappings different sample 

benchmarks detail discussing benchmarks show applied emerging designs navigable static representations forms icbe 
forms declarative form vpl aims achieve power traditional programming languages maintaining simplicity spreadsheet model 
icbe set oriented dataflow vpl strong emphasis systems database spreadsheets graphics aimed user professionals 

understandability benchmarks section describes benchmarks elements relate understandability program representation 
forms provide examples designers benchmarks section 
programs forms defined cells formulas forms 
cell formula defines value 
detailed demonstrate basic ideas forms 
complete description language burnett ambler 
representation design benchmarks intended help process design forms benchmark examples perspective forms designers design improved navigable static representation 
designate representation current implementation forms design new design creating help representation design benchmarks design 
design figures screen shots current implementation figures design emerges benchmarks course hand constructed sketches 
representation design benchmarks 
forms program maintains running analog clock commonly away graphical workstations 
program requires new cells form entitled clock access built cells representing internal clock graphics support 
program face programmer fills built circle specification form refers face formula 
pin specified way 
clock viewed local coordinate system pin origin divided quadrants 
minute hand simply line drawn positions appropriate quadrant internal clock time minutes 
hour hand calculated similarly 
clock formula generated direct manipulation demonstrate arrangement face hands pin snapshot face hands pin cells moved apart clarity see color plate 
visibility dependencies say dependency describe fact changing portion program changes values stored output reported portion 
arbitrary granularity individual variables large sections program 
dependencies essence common programming maintenance questions affected changed changes affect green petre noted hidden dependencies severe source difficulty understanding programs discussion hidden dependencies cd :10.1.1.22.1477
benchmarks cd 
sp benchmark measures dependencies explicitly depicted representation sherry yang 
forms design screen snapshot program compute factorial function selected formulas shown 
instances gray shaded inherit model cells formulas programmer explicitly provides different formula cell instance case cell background shown white fact ni benchmark measures easily information accessed supporting elements ni 
compute benchmark designer identifies dependencies vpl definition section subdividing groups sources dependencies 
example standard dataflow language source dependencies data flow spreadsheet sources cell formula dependencies macro effects cell 
second designer multiplies number sources account fact bidirectional source dependency unidirectional dependency sources direction tells affected portion program tells portions affects 
example digraph dependency information direction tells nodes reachable tells nodes paths 
designer divides number unidirectional dependency sources explicitly represented total number unidirectional dependency sources vpl 
benchmarks measured assumption infinite screen size 
benchmark accompanying ni benchmark measures cost mapping elements infinite screen finite screen 
dependencies ni benchmark simply count number steps needed navigate dependency information 
detailed example dependencies benchmarks design aid forms 
shows design representation scheme represents recursive solution factorial function 
cells formulas shown text box bottom cell 
representation design benchmarks prototypical formula specified cell form fact programmer receive concrete feedback 
solution involves forms form computes factorial desired similar form computes factorial 
form fact termed model fact copied fact modified instance fact 
benchmarks performed forms representation design design members forms design team 
bidirectional sources dependencies forms language dependencies due formulas dependencies due copying model form 
example program formula fact defines formula dependency cell cell fact 
fact cell dependent fact virtue fact fact copied model form fact 
changes model fact automatically propagate instances formulas programmer explicitly changed instance important dependency forms multiplying bidirectional sources gives unidirectional sources dependencies 
design direction copy dependencies shown name copied forms include name model 
allows programmer answer quest ion changes model form change form fact directly name fact 
direction shown answer question change form fact copies changed programmer manually search forms names start fact 
regarding formula dependencies design explicitly depicts half direction direct dependencies 
example cell ans upper right explicitly shows cells directly affect result cell ans explicitly show indirect effects fact fact ans find programmer search program 
show direction 
example explicitly show cells affected result ans programmer search program find 
forms design team somewhat see benchmark despite popularity spreadsheet formula displays impoverished depiction formula dependency information formulas displayed screen 
dividing total numerators number unidirectional sources dependencies gives benchmark 
measures steps navigate information bring physical display screen 
add cell formula display programmer pulls cell formula tab selects 
step cell total steps add cells formulas display number cells program 
mapping measurements subjective rating scale done individual designers design goals language 
forms designers rating scale appendix interpreted roughly fair scale 
design forms design team devised improvements increase sources dependencies shown reflected reduce number steps needed reflected 
design dependencies shown explicitly dataflow lines superimposed forms cells shown 
programmer sherry yang 
design changes represented forms design shown hand drawn additions current implementation 
dataflow lines superimposed cells 
rightmost window control panel 
programmer select cell time example cell selected 
option control panel show dependencies tailor amount information included display control panel 
design results possible information displayed 
number steps include desired dataflow lines representation including steps needed interact control panel 
takes step cell include desired dataflow lines done cell cell optionally programmer include lines cells step cells desired 
steps required include dataflow lines desired cells plus steps interact control panel 
roughly half number steps needed design 
steps required display formulas cell considered design dataflow lines sufficient show dependencies 
formulas needed understand program logic discussed visibility program logic section 
representation design dependencies visible cost design occupies real estate may add clutter 
occurrences problem designer adds features representation order solve deficiencies exposed benchmark may generate new problems reflected benchmarks 
characteristic process design surprising benchmarks 
particular trade offs reflected scalability benchmarks discussed section 

visibility program structure term program structure mean relationships modules program module collection program elements boundaries representation design benchmarks module determined language specific manner 
example languages module procedure function macro class method form storyboard 
examples relationships include caller callee relationships inheritance relationships dataflow relationships 
programmer standpoint depiction program structure answers questions modules program modules logically fit example depictions program structure include call graphs inheritance trees diagrams showing flow data program modules 
benchmarks group related role expressiveness cd 
role expressiveness cd describes easily programmer discern purpose particular piece program 
devices empirically shown help communicate role expressiveness commenting secondary notations meaningful identifiers structured modules 
benchmarks section consider representation structural role portion program benchmarks section secondary notation consider kinds role information 
benchmark ps shows presence absence program structure information benchmark ps measures number steps required programmer navigate information 
returning forms example forms module form design explicitly show forms relate 
dataflow wiring added previous section explicitly show program structure fine grained programmer search diagram manually looking sources sinks detect structure 
forms design team decided add optional view hierarchical dataflow forms 
representation form collapsed multi graph variant dataflow graphs useful describing relationships related forms 
design team elected vehicle depict program structure optional fine grained details context program structure follows 
default forms containing sources sinks represented collapsed icons programmer override display details collapsed icons 
sources sinks dataflow path circled 
addition design ps benchmark benchmark ps requires step add program view physical screen button main control panel 

visibility program logic fine grained logic program included static representation say program logic visible 
visibility program logic complete representation includes precise description computation program 
benchmark group benchmark groups derived visibility side side ability cd measures visibility 
group benchmarks cd focuses side side ability scalability section 
textual languages traditionally provide complete visibility fine grained program logic static source code listing vpls static view information 
view programmer efforts obtain information sherry yang 
forms design program structure view factorial function 
source sink dataflow circled 
forms contain sources sinks shown collapsed icons dynamic means add considerably amount required program language 
example study spreadsheet users experienced users spent time moving cursor inspect cell formulas 
benchmark measures provides visibility fine grained program logic benchmark measures number steps navigate 
benchmark sc benchmark focusing problem completeness visibility common vpls concrete examples accuracy statically depicting generality program logic 
example demonstration vpl programmer create box expansion routine demonstrating desired logic particular box 
static representation consists solely pictures particular box provide general information tell picture different sized box input 
forms program logic entirely specified cell formulas 
spreadsheets formulas desired displayed screen simultaneously cell values 
design programmer pull formula tab select displayed formula cause remain permanently display 
takes step cell include formula total steps include formulas benchmark 
representation design benchmarks 
forms design factorial function legend 
bold underlined form name fact indicates concrete form name just example general relationship 
clicking name causes legend attached formula display explaining generalized relationship form form represented fact forms design team decided reduce number steps reflected large programs making cells formulas visible burdensome 
design adds show hide option ni reduce number steps 
takes step toggle options control panel allows formulas displayed step allows subset program displayed steps 
change reduced number steps half 
compute designer counts sources generality 
forms design contains source concrete examples identify form instances 
example formula cell ans form fact appears fact ans refer particular instance fact computes factorial actuality formula refers generic instance fact computations defined relative value cell referring form 
design forms design team added legend provide complete information general relationship shown 
programmers include exclude legends representation desired 

display results program logic group benchmarks measures possible feasible see program partial results displayed program source code 
benchmarks group derived progressive evaluation cd 
idea original cd related dynamics interactive programming environments ability display fine grained results values variable frequent intervals allows fine grained testing program developed shown important debugging see green petre discussion 
projection notion navigable static representations consider results included including results navigable static representation sherry yang allow programmer study static display test data integrated static display accompanying program logic 
benchmark measures possible see results displayed statically program source code benchmark measures number steps required 
forms design partial program result cell value automatically displayed cell formula programmer chosen leave formula display 
action needed navigate partial results 
forms design team considered design scores excellent changes design 

secondary notation non semantic devices vpl secondary notation collection optional non semantic devices programmer include program 
collection non semantic devices changing instance secondary notation textual comment change program behavior 
benchmarks group derived secondary notations cd related role expressiveness cd discussed previously 
petre argues secondary notation crucial comprehensibility graphical notations 
example secondary notations labeling white space clustering allows clarifications emphases important information structure relationships 
group benchmarks focuses subset vpl secondary notational devices static 
benchmark sn simply measures presence notational devices benchmark sn measures number steps required navigate instances 
identified non semantic notational devices included vpl navigable static representation optional naming labeling non required ability attach name label portion program layout program ways semantic impact textual annotations comments static graphical means documenting program ability circle particular portion program draw arrow pointing 
time annotations animations sound definition part navigable static representation 
compute benchmark sn designer divides number secondary notational devices available representation total number secondary notational devices listed forms design includes notational devices 
textual annotations graphical annotations form 
layout entirely flexible allows non semantic spatial grouping related cells cell names optional provided programmers meaningful names provides additional non semantic information 
sn 
number steps required navigate secondary notations sn zero secondary notations automatically visible 
simply number able identify 
obviously case experience practice may turn additional kinds secondary notations case divisor increased 
alternative benchmark eliminate divisor raw count ratio experiences indicated benchmark useful alerting designers opportunities improvements computed ratio 
representation design benchmarks 
scalability benchmarks burnett vpl navigable static representation counted important aspect language scalability 
measuring factors pertinent representation ability display large programs benchmarks section reflect scalability representation influence vpl scalability 

abstraction gradient abstraction gradient cd term abstraction gradient mean vpl amount support abstraction 
applied vpl representations support abstraction means provide ability exclude selected collections details representation replacing collection detailed depiction collection details 
abstraction known device scalability programming languages usually reduces number logical details programmer understand order understand particular aspect program 
addition benefit support abstraction navigable static representation generally allows larger fraction program fit physical screen replacing collection details depiction saves space 
cognitive spatial ways representation abstraction gradient tied scalability 
benchmark ag measures sources details abstracted away representation benchmark ag measures number steps required 
secondary notations benchmark sn ag ratio raw count bring opportunities improvement 
denominator identified sources detail vpl abstracted away representation data operations fine grained portions program details navigational instrumentation devices control panels calculate benchmark ag designer divides sources detail abstracted away 
forms strong emphasis abstraction reflected design benchmark scores group 
design forms collapsed name icon 
data structures collapsed graphical images 
cells hidden excludes representation 
control panels part ni collapsed icons 
ag score reflecting fact forms design source detail abstracted away 
score true design features described 
turning ag number steps required collapse form control panel 
amount detail shown data structures hidden cells automatically controlled programmer interaction automatic maintenance information hiding constraints forms steps 
programmer may override automatic behavior desired cost step form steps program constant representing average number cells form 
sn coverage list complete 
recall definition navigable static representation tuple ni 
elements list cover particular portions third covers fourth element list covers ni 
sherry yang 
accessibility related information problem solving point view pieces information program related programmer thinks 
visibility side side ability cd benchmarks group measure programmer ability display desired items side side 
green petre argued viewing related information side side essential absence side side viewing amounts psychological claim problem solved independently problems 
benchmark ri measures possible include related information benchmark ri measures number steps navigate 
forms design possible view related cells side side ri 
cell dragged form needed navigational effort arises moving needed forms near screen 
way form icon visible involve manually moving things look icon 
ad hoc way scrolling form name control panel list forms clicking display button brings selected form visible portion screen 
counting time scroll list ri approach square number forms program number cells program average number cells form 
appeared dataflow lines added design altogether eliminate need programmers searching 
soon apparent dataflow lines eliminate need search lines long 
forms design team decided changes ni design reduce number steps search 
change include value referenced cells formula programmer merely interested values contribute new answer searching required 
change ni related cell different form clicking cell formula automatically bring form representation 
navigation mechanism reduces worst case score ri step form maximum steps 

screen real estate screen real estate denotes size physical display screen connotes fact screen space limited valuable resource 
benchmarks group sc benchmarks derived cd purposes 

forms design values displayed cells formula 
eliminates need programmer search cells find current values contributing value ans representation design benchmarks 
non semantic intersection examples vpl 
left line crossings 
middle unrelated boxes overlapping imply logical grouping 
right line label overlaps unrelated line provide measures information representation design physical screen obscuring logic program 
second bring important trade offs fore providing critical counterbalance benchmarks accounting screen real estate space costs design decisions 
aspects computer science designing vpl representations involve time space trade offs 
representation design time programmer time locate needed information screen navigate screen reconstruct memory displayed simultaneously needed information 
space physical screen space 
tension time space context information screen programmer time locate reduced screen space spent hand information displayed space spent programmer expend time locate reconstruct information 
time versus space trade considered representation design trade offs space versus quality presentation 
purchase pointed problem representation graphs line crossings 
way quality presentation deteriorates information placed screen fit non semantic intersections 
non semantic intersection spatial connection overlapping screen items intersection effect program behavior see 
benchmarks group relate physical screen space designer perform benchmarks physical screen representative language expected run 
example language intended low macintosh computers measured screen size commonly included purchased systems 
benchmark maximum number program elements laid physical screen 
term program element defined designer manner specific vpl measured 
performing benchmark designer may assume layout strategy long vpl programmers 
benchmark allows designer quantitatively compare alternative design ideas increase decrease screen space utilization 
benchmark number non semantic intersections counted layout chosen performing benchmark providing measure layout non semantic intersections 
returning forms example program elements cells 
performing design forms design team decided measure forms layout strategy minimized measuring maximum number sherry yang cells fit screen absence non semantic intersections 
approximating average cell size formula length maximum number cells fit physical screen unix graphical workstation terminal non semantic intersections formulas values shown 
approximately amount source code shown window lines textual language 
forms display includes intermediate values final outputs textual language require adding debugger window window show execution final results 
score points strength cell representation reasonably compact way combine presentation source code intermediate results final outputs avoiding non semantic intersections 
space non semantic intersection costs design features design compared design individually combination table 
surprisingly design allows program elements fit screen fewer intersections design design contains information design 
example trade offs benchmarks help bring 
forms design team decided space intersection costs design acceptable navigational instrumentation portion design allows programmer judge trade offs including excluding screen design features desired 

benchmarks audience specific vpls vpls special purpose languages designed limited kinds programming accessible particular audience 
target audience composed people want conventional programming languages kinds programming 
term audience specific vpls describe vpls 
examples audience specific vpls range coarse grained vpls scientists engineers visualizing data embedded vpls users automating repetitive editing tasks 
benchmarks previous sections apply vpls task hand programming new issue covered benchmarks described far arises audience specific vpl representation suited particular audience 
benchmarks section focus issue 
derived closeness mapping cd 
cd considers question programming language similar way audience solve problem hand real world 
question implications regarding audience language 
example nardi points number empirical studies indicating people consistently perform better solving problems couched familiar terms 
realm representation design issue narrows appearance vpl elements similar appearance corresponding elements audience experience background 
benchmarks benchmarks far ways 
difference compare representation elements prerequisite background expected vpl particular audience sense audience specific vpls 
second difference benchmarks representation design benchmarks table 
trade offs features added save programmer time versus real estate space costs apparent comparison real estate costs forms design features 
table shows design top row design supplemented individual feature design starting second row design row 
trade offs forms design team layouts optimized performing benchmarks 
variables represent numbers line crossings values vary actual dependencies program 
lines necessarily straight upper bound values variables relationships design options units cells units intersections base design formulas showing design dataflow lines change request small number selected cells design dataflow lines change request cells intersections superset intersections previous row 
design program structure approximately fewer view lines coarse grained view dataflow lines previous row 
design legends approximately fewer legend cell legend displayed design cell icons formulas approximately fewer design features approximately fewer sherry yang section performed way answering question representation element look object operation composition mechanism intended audience prerequisite background 

apply audience specific benchmarks audience specific benchmarks sc benchmarks objects operations spatial composition mechanisms respectively 
computing matter answering question previous paragraph element representation 
designer identify intended audience prerequisite background prerequisites audience expected fulfilled 
prerequisites include prior computer experience expected kinds knowledge expected 
example intended audience macro building vpl graphical editing expected know editing graphics computer everyday objects phenomena telephones flow water pipes gravity 
step identify objects operations depicted representation ways objects operations spatially composed 
critical importance particular element classified object operation composition mechanism measured way division groups simply way help organize identification process 
object operation composition mechanism identified designer notes appearance looks corresponding item audience prerequisite background 
compute designer asks object representation representation element look object intended audience prerequisite background divides total number answers total number objects 
computed way operations spatial composition objects operations 

detailed example audience specific benchmarks design aid icbe concrete examples applying audience specific benchmarks turn audience specific language icbe interpretation customization example 
icbe high level set oriented dataflow vpl users comfortable computers formal training programming 
goal allow users create custom applications combining gui objects built capabilities database querying plug objects virtual fax machines telephones applications spreadsheets graphics packages 
programming icbe matter simply connecting objects dataflow control flow lines 
see example 
icbe generalization kind term set oriented dataflow meant describe fact sets atomic values flow dataflow paths 
representation design benchmarks 
salesperson creating program contact management application icbe 
call salesperson highlight customer call list press retrieve button 
close gate complete circuit allowing highlighted list entry flow table 
completes selection criterion query results retrieval customer picture profile contact data 
salesperson pushes call button customer phone number automatically telephone plug object 
salesperson integrates word processing document system customer pushing fax button see color plate declarative example programming qbe complete description icbe zloof krishnamurthy krishnamurthy zloof 

icbe intended audience apply audience specific benchmarks icbe step identify intended audience precise fashion intended audience prerequisite background clear 
icbe intended power users users competent general office applications spreadsheets hypercard systems email 
assumption icbe users advanced capabilities systems example icbe users assumed able create spreadsheet macros program textually write shell scripts sherry yang 
icbe user interface primitives 
grid represents spreadsheet example interoperation object 
television telephone plug objects 
arrows represent ports red pointed arrows dataflow ports blue rounded arrows control flow ports bat files 
examples users include administrators 

benchmark objects objects icbe user interface primitives interoperation objects external plug objects flow ports 
examples shown 
user interface primitives include objects text fields buttons lists 
interoperation objects include external applications spreadsheets databases business graphics packages represented grids tables graphs 
external plug objects appear icons vendor supplied objects added system expand capabilities 
instances fourth kind object flow ports shown arrows attached kinds objects specify direction incoming outgoing dataflow control flow 
perform benchmark icbe design team answered questions object user interface primitives look user interface objects intended audience prerequisite background 
representations interoperation objects grids tables graphs look spreadsheets databases graphics packages intended audience prerequisite background 
plug objects icons look corresponding objects intended audience prerequisite background 
arrows look incoming outgoing information ports intended audience prerequisite background 
icbe design team answered 
answers icbe user interface primitives interoperation objects look user interface objects miniaturized windows common office packages expected part power users prerequisite representation design benchmarks 
icbe operations 
dataflow 
event control flow initiated pressing retrieve button 
control flow transfer control shown blue lines 
open gate interrupts dataflow 
trigger causes change button pushed automatically 
query slider data selection operator backgrounds 
potentially answer depends external vendors icon design skills 
icbe design team answered 
arrows common indicators directionality icbe users prerequisite backgrounds suggest arrows look information exchange ports icbe power users 
representation look information exchange ports different audience professional programmers commonly seen case tools component building software aimed professional programmers 
additionally styles arrows pointed rounded look particularly data directionality versus control directionality 
total score objects representation look objects intended audience prerequisite background 
high score reflects emphasis placed icbe designers language directly audience 
icbe designers rated score decided result benchmark study potential audience ability understand different kinds ports see different representation needed 

benchmark operations operations icbe dataflow event control flow transfer control call goto constructs interruption dataflow event triggers selection list database 
see 
dataflow shown red lines directed flow data objects system 
event control flow shown blue lines allows occurrences events button clicks key presses generate program activity 
call goto constructs transfer control part program variant control flow shown blue lines 
dataflow interrupted open gate path 
triggers icbe depicted gun icons generate events internally usually particular data condition arisen 
instance trigger attached database customer accounts monitor customer accounts 
customer encountered trigger cause warning dialog appear 
query sliders decision tables allow specification data selection criteria list database 
benchmark operations requires answering questions red line look conduit flow data intended audience prerequisite background 
sherry yang blue line look conduit event control intended audience prerequisite background 
blue line look conduit transfer control intended audience prerequisite background 
open gates look way interrupt dataflow intended audience prerequisite background 
gun trigger look mechanism triggering events intended audience prerequisite background 
decision tables query sliders look mechanisms data selection database list intended audience prerequisite background 
icbe designers answered red lines connected arrow objects discussed earlier look similar widely understood conduits directed flow water pipes map representations way streets 
answered blue lines look behave way electrical wires regarding designers noted blue line indicate transfer control overloads device representation 
impact score reflected score benchmark visibility program logic 
lines transferring control may familiar professional programmers seen flowcharts resemble prerequisite backgrounds icbe intended audience earned answer 
interrupting potential flow opening gate disconnect lines looks mechanism interrupt flow water traffic earned 
icbe designers gave questions devices familiar programmers engineers necessarily look devices icbe intended audience seen 
adding numerators dividing gives score 

benchmark spatial composition spatial composition elements language representation way arranged connected screen 
especially programs simulating physical environment aspect representation strong influence closely representation matches way problem appears audience prerequisite background 
icbe representation ways objects operations spatially composed layout connections lines placement containers grouping mechanism nesting containers containers constrained grouping mechanism 
shows example layout examples line connections shows container nested container 
measure spatial composition mechanisms representation mimic way objects operations fit intended audience prerequisite designers noted denoting difference water data lines electrical control lines colors red blue map generally accepted convention 
representation design benchmarks 
icbe containers 
blue inner container combines supplier list list possible quantities textual labels 
outer container turn combines inner container item list textual label 
nesting implies constrained relationship example value monitor keyboard contents nested container reflect supplier quantity keyboard order background icbe designers answered questions sq layout objects operations look way objects operations laid intended audience prerequisite background 
sq lines connecting objects operations look way objects operations connected intended audience prerequisite background 
sq container look way grouping objects intended audience prerequisite background 
sq nested container look way groupings nested intended audience prerequisite background 
icbe designers answered questions fourth 
sq somewhat qualified depends user chooses lay program 
icbe problem domain restricted particular kind simulation automatic layout mimicking particular physical environment icbe allows complete flexibility laying objects operations screen user match physical layout desired 
answers sq sq obvious lines known ways connecting objects operations office project management organization chart applications part power users prerequisite backgrounds 
putting objects containers shopping bags grouping mechanism everyday life 
icbe designers answer sq borderline case 
nested containers look way groupings nested everyday life constraining aspect nesting container exist everyday life nestings 
character sufficiently different icbe nested containers designers decided answer 
score spatial composition mechanisms look corresponding mechanisms audience prerequisite background 
sherry yang 
outcomes benchmarks icbe icbe designers representation design benchmarks audience specific benchmarks described section rest benchmarks described section identified previously unnoticed issues representation 
example audience specific benchmark pointed possible need new port representation 
audience specific benchmarks pointed fact representation elements familiar programmers engineers necessarily familiar intended audience icbe 
representation elements answers logical step audience testing determine lack familiarity audience particular elements affect icbe long term usability particular representation elements learned easily icbe intended audience seeing language action 

empirical study vpl designers considering usefulness representation design benchmarks designers question arises representation design benchmarks design process produce better representations 
unfortunately empirically arriving answer question probably feasible 
study require evaluating vpls dual implementations implementation vpl corresponding design created benchmarks corresponding design created benchmarks 
implementations language empirically compared usefulness programmers 
primary difficulty study finding different vpl design teams willing expend effort design implement dual versions representations 
useful insights gained question considering related questions tractable objective analysis usable representation design benchmarks vpl designers 
representation design benchmarks design process uncover problems issues overlooked 
learn answers questions conducted small empirical study goals 
goal goal uncover problems vpl designers benchmarks 
second goal goal learn vpl designers benchmarks doing useful uncovering problems designs navigable static representations 
hypothesis tested second goal subjects able benchmarks find problem change addition deletion representation designs direct result representation design benchmarks 
study helpful regarding goal goal results favorable usefulness benchmarks vpl designers 
representation design benchmarks 
subjects subjects study needed vpl designers midst designing vpl representation 
subjects normally hard find timed study recruit computer science graduate students process designing vpls navigable static representations graduate course taught authors burnett 
studies usability testing show test participants sufficient uncover approximately usability problems 
reports additional subjects reveal new information 
reasonable number subjects addressing goal finding usability problems forms icbe design teams missed 
liked larger number subjects second goal learning benchmarks useful vpl designers 
sample size fairly typical studies relating non traditional programming languages due difficulties finding suitable subjects 
procedure subjects process designing small vpl 
test goal hypothesis chose subject experimental design benchmarks design task benchmarks design task 
tasks provided information needed achieve goal finding usability problems 

benchmarks subjects benchmarks task submit design viewable aspects vpls 
task served purposes provided baseline data designs created benchmarks served training function help understand navigable static representation 
purpose training task collection baseline data important sure subjects reporting designs complete omit important information misunderstandings part navigable static representation 
avoided potential problem having include viewable task 
training purpose accomplished having subjects classify elements design categories static representation navigational instrumentation ni dynamic representations vpl ni animations balloon help received feedback correctness classifications 
give incentive best devising representation benchmarks task set graded project 
subjects week perform task 
students gradually prepared task term 
course reading papers vpls writing programs variety see example study vpl labview subjects study vpl subjects study generic petri net language subjects 
sherry yang vpls discussing research problems associated vpls including static representation 
just asked perform task defined navigable static representation motivated importance introduce benchmarks 

benchmarks task completed subjects lecture representation design benchmarks 
asked perform second task measure navigable static representation part vpl design benchmarks allowed modifications thought necessary 
purposes task find usability problems individual benchmarks goal test hypothesis able benchmarks doing find problems changes designs result benchmarks goal 
subjects instructed measure designs follows 
start representation design previous task 
measure benchmarks 
outcome benchmark pointed problems permitted change design solve problem re measure 
period students designing vpls 
subjects turned results benchmarks task weeks assignment 
purposes motivation graded assignment grade quality designs 
grading task raised question set grading criteria define designed representation 
decided follow sample mapping measurements ratings shown appendix meant grades determined design benchmarks mapped ratings 
avoid results forcing design changes grading criteria ratings benchmarks deemed important subject particular vpl included grading criteria 
benchmark eliminated subject explained important measure language goals 
subjects turned completed representation design rating information 
turned information time class list problems benchmarks annotate design pointing changes result representation design benchmarks distinguished changes reasons 

results discussion goal subjects able complete benchmarks training task trouble categorizing viewable elements correctly categories static navigational aids dynamic 
clarified definition navigable static representations partially address problem 
addition inclined infer evidence isolating navigable static representation rest vpl academic exercise come naturally interactive vpls omitted absence benchmarks 
poor track representation design benchmarks record static representations interactive vpls lends support conjecture 
believe isolation important designer obtain clear understanding representation strengths weaknesses view advantage benchmarks 
subjects completed benchmarks task reported problems understanding obtain measurements 
subjects successful ni benchmarks difficulties sp sc benchmarks 
time study benchmarks measuring ni benchmarks measuring explicitly separated 
screen real estate benchmarks test suite time subjects able perform benchmarks accuracy 
subjects suggested benchmarks better reflect trade offs adding new features representation versus space navigational effort required additional features 
result usability issues subjects benchmarks task changes incorporated benchmarks described 
explicit separation ni benchmarks versus benchmarks measuring aspects sc 
revised screen real estate benchmarks measure characteristics representation characteristics test programs include measure general space characteristics 
added new ni benchmarks benchmark groups sure trade offs adding features navigational effort imposed additional features represented 

results discussion goal subjects reported representation design benchmarks useful 
subjective reports benchmarks helped think design precisely focusing problems overlooked prior benchmarks 
goal hypothesis verified subjects able complete benchmarks task subjects problems additions changes designs direct result benchmarks 
previously incentives time best design benchmarks expected changes benchmarks task direct result benchmarks 
fact verified annotations design documents identified changes resulting benchmarks 
problems designs changes summarized table 
design time 
discussed usefulness benchmarks design time aid shown evaluate single design compare alternative design ideas 
notion benchmarks design aid somewhat unusual question naturally arises representation design benchmarks conventional way sherry yang objective evaluations comparisons representation schemes different post implementation vpls 
experimented purposes suspect certain features representation design benchmarks needed usefulness design time aid compatible features needed objective comparisons 
recall benchmarks tailorable process including objective step obtaining actual measurements subjective steps selecting benchmarks applicable particular language goals interpreting implications resulting scores light language goals 
objective step designers determine exactly features particular vpls pertain individual benchmark order calculate measurements 
kinds flexibility necessary useful designer tasks evaluating design ideas respect designer goals may introduce subjectivity allow truly objective comparisons different languages 
observation relevant issue timing 
designers observed representation design benchmarks evaluate representation schemes implementation tended interested justifying past manipulating tailorable aspects accomplish finding ways improve design 
surprising design completed conflict interest arises designer considers design finished powerful find wrong 
observation runs vein winograd table 
problems corrections resulted representation design benchmarks reported subjects benchmark group problems changes subjects dependencies subject half dependencies explicitly visible representation 
fixed final design 
program logic subjects changes representation program logic subject improved representation program logic visible 
subject corrected generality representation 
display results subject reduced number steps required display program logic results program logic 
secondary notation subjects changes secondary notational devices available subject surprised see original design omitted comments changed design allow textual comments 
subject added devices secondary notation 
abstraction gradient subjects added powerful navigational devices order reduce number steps required navigate levels abstraction supported 
accessibility related subject added navigational aids reduce number information steps access related information 
screen real estate subject reduced number screen windows reduce non semantic intersections 
representation design benchmarks observation mentioned earlier uncovering substantive problems occur early design stages lifecycle 
winograd observation users experience designers 
surmise possible representation design benchmarks non design oriented purposes language designers amount useful information obtainable benchmarks greatest design stage 

vpl researchers continually making advances devising new ways create programs kinds programs professional programmers create kinds component macro building users 
provide advances vpls innovative capabilities today graphical workstations including graphics color animation 
design advances related vpls dynamic aspects result static representations vpls achilles heel 
unfortunately deficiency seriously handicap vpls suitability certain tasks arise programming working understanding program written 
representation design benchmarks approach devised specifically help vpl designers address deficiency 
extending cognitive dimensions programming systems benchmarks allow designer see navigable static representation design features impact accessibility usefulness information available program 
representation design benchmarks experienced vpl designers designing navigable static representations interactive vpls forms oregon state university icbe hewlett packard laboratories student subjects small empirical study 
indications uses benchmarks measurable difference helping vpl de signers discover problems designs 
key characteristics representation design benchmarks provide concrete way vpl designers apply hci principles cognitive aspects programming set measurement procedures set guidelines focus directly exclusively vpls navigable static representations 
characteristics provide practical means measure vpl navigable static representation isolation dynamic aspects vpl helping designer obtain clear view proposed navigable static representation strengths weaknesses 
way representation design benchmarks help vpl designers combine flexibility responsiveness supported vpl dynamic aspects easy access large amounts program information ensues designed navigable static representation 
acknowledgments judith hays eric wilcox assistance john atwood sherry yang luca rebecca walpole members forms icbe design teams help research led 
especially thomas green helpful comments 
appendix cognitive dimensions table lists dimensions thumb nail description shows example cds contrast vpls prograph labview 
relation dimension number empirical studies psychological principles authors carefully point gaps body underlying evidence 
words framework cognitive dimensions consists small number terms chosen easy non specialists comprehend capturing significant amount psychology hci programming 
table 
cognitive dimensions extracted green petre abstraction gradient minimum maximum levels abstraction 
fragments encapsulated 
closeness mapping programming games need learned 
consistency language learnt rest inferred 
symbols graphic entities required express meaning 
error proneness design notation induce careless mistakes 
hard mental operations places user needs resort fingers annotation keep track happening 
hidden dependencies dependency overtly indicated directions 
indication perceptual symbolic 
premature commitment programmers decisions information need 
progressive evaluation partially complete program executed obtain feedback am doing 
role expressiveness reader see component program relates 
secondary notation programmers layout color cues convey extra meaning official semantics language 
viscosity effort required perform single change 
visibility part code simultaneously visible assuming large display possible compare parts side side 
code dispersed possible know order read 
representation design benchmarks application contrast text languages box line representation data flow really local level lines making local data dependencies clearly visible 
labview prograph avoiding problem 
labview uses virtually variables prograph act global variables 
different positions design space 
prograph position presumably globals allowed program get cluttered lines 
local dependencies visible long range data dependencies different issue 
prograph extraordinarily large number long range hidden dependencies created combination deep nesting lack overview nesting structure 
programmer quickly navigate call graph clicking method icons open window clicking icons way proceed call graph way 
general discover method calls method determine preconditions require extensive search 
alleviate difficulty searching tool provided interesting know successful tool expert users 

cds geared high level discussion cognitive aspects vpls 
example hidden dependencies dimension evaluate prograph labview extracted green petre appendix sample interpretation benchmark results designer interprets benchmark results particular design goals 
useful way go devise table interpretation schemes table results 
table tracking improvements come different design alternatives straightforward 
table 
designer mapping benchmark results subjective ratings 
benchmarks rated designer simply provide data points comparison data points natural mapping subjective ratings benchmark ni aspect representation example rating scale sherry yang table 
continued benchmark ni aspect representation example rating scale 
myers taxonomies visual programming program visualization 
journal visual languages computing 

cypher characterizing pbd systems 
watch programming demonstration cypher ed 
mit press cambridge ma 

burnett baker carlson yang van zee scaling visual programming languages 
ieee computer 

burnett ambler interactive visual data abstraction declarative visual programming language 
journal visual languages computing 

zloof krishnamurthy ic example empowering construct database applications 
technical report hewlett packard laboratories 

krishnamurthy zloof rbe rendering ex ample 
eleventh international conference data engineering taipei taiwan pp 


green describing information artifacts cognitive dimensions structure maps 
people computers vi diaper hammond eds 
cambridge university press cambridge 

green petre usability analysis visual programming environments cognitive dimensions framework 
journal visual languages computing 

cox giles prograph step programming textual conditioning 
ieee workshop visual languages rome italy pp 


visual programming structured data flow 
ieee workshop visual languages kobe japan pp 


green myers visual programming visual domain case study cognitive dimensions 
people computers ix cockton draper weir eds 
cambridge university press cambridge uk 

ford reducing cognitive requirements visual programming 
ieee symposium visual languages boulder pp 


hendry display problems spreadsheets critical incident design remedy 
ieee symposium visual languages darmstadt germany pp 

bell evaluation visual programming languages environments 
technical report cti centre chemistry university liverpool 
representation design benchmarks 
bell rieman lewis usability testing graphical programming system things missed programming walkthrough 
acm sigchi 
acm press new orleans pp 


bell lewis rieman weaver wilde zorn programming walkthrough aid programming language design 
software practice experience 

glinert software metrics visual programming 
international journal man machine studies 

card moran newell psychology human computer interaction 
erlbaum hillsdale nj 

hix study computer supported user interface evaluation maximal repeating pattern analysis 
acm sigchi new orleans la pp 


nielsen heuristic evaluation user interfaces 
acm sigchi seattle washington pp 


nielsen finding usability problems heuristic evaluation 
acm sigchi pp 


sears layout appropriateness metric evaluating user interface widget layout 
ieee transactions software engineering pp 


winograd programming environments environments designing 
communications acm 

yang burnett concrete forms generalized abstractions perspective oriented analysis logical relationships 
ieee symposium visual languages st louis mo pp 


brown gould experimental study people creating spreadsheets 
acm transactions office information systems 

petre looking isn seeing readership skills graphical programming 
communications acm 

purchase cohen james validating graph drawing aesthetics 
lecture notes computer science brandenburg ed 
springer berlin 
nardi small matter programming perspectives user computing 
mit press cambridge ma 

zloof query example data base language 
ibm systems journal 

zloof qbe language office business automation 
computer 

refining test phase usability evaluation subjects 
human factors 

green petre bellamy comprehensibility visual textual programs test match mismatch conjecture 
empirical studies programmers fourth workshop koenemann moher robertson eds 
ablex publishing norwood nj 

moher mak blumenthal comparing comprehensibility textual graphical programs case petri nets 
proc 
empirical studies programmers fifth workshop 
palo alto ca ablex publishing norwood nj 
