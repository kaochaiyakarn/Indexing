formal approach recovery compensating transactions henry korth levy abraham silberschatz department computer sciences university texas austin austin tx compensating transactions intended handle situations required undo committed uncommitted transactions affect transactions resorting cascading aborts 
stands sharp contrast standard approach transaction recovery cascading aborts avoided requiring transactions read committed data committed transactions treated permanent irreversible 
argue standard approach recovery suitable wide range advanced database applications particular applications incorporate long duration nested transactions 
show compensating transactions effectively handle types applications 
model allows definition variety types correct compensation 
types compensation range traditional undo extreme application dependent special purpose compensating transactions extreme 
concept transaction atomicity cornerstone today transaction management systems 
atomicity requires aborted transaction effect state database 
common method achieving maintain recovery log provide undo operation restores data items updated value just prior execution transaction read data values written undoing sufficient 
indirect effects removed aborting aborting affected transaction may trigger aborts 
undesirable phenomenon called cascading aborts result transactions forced abort transaction happened abort 
committed transaction definition abort required transaction reads values data items written transaction commit commits 
system ensures property said recoverable bhg 
way avoiding cascading aborts ensuring recoverability prohibit transactions reading uncommitted data values produced transactions partially supported ibm nsf iri 
committed 
principle formed basis standard recovery contemporary database systems 
unfortunately large range database applications standard recovery approach excessively restrictive appropriate 
common denominator applications need allow transactions read uncommitted data values 
general indicated gray gra early exposure uncommitted data essential realm long duration nested transactions 
applications incorporating transactions nature accommodated standard recovery approach executions entail cascading aborts non recoverable 
example consider database system uses locks enforce concurrency control 
externalization uncommitted data amounts releasing exclusive locks transaction 
long duration transactions early release locks necessity delay incur retaining locks long periods time intolerable gra gms 
shortening time periods transactions hold locks worthwhile goal right 
releasing locks early enhances concurrency increasing system throughput 
nested transactions applications set subtransactions assigned single coherent task requires interaction cooperation subtransactions hr 
instance nested transactions may represent long duration design activities 
design efforts usually collaborative nature essential certain cases design subtransaction see uncommitted data written design subtransaction 
additional restriction imposed standard recovery inability undo committed transaction 
suppose transaction committed erroneously 
committed erroneously mean system point view wrong committed transaction 
external reasons discovered rendered decision commit transaction erroneous 
standard recovery approach support undoing transactions 
need mechanism support undoing committed transactions established lag 
presents method compensating transactions recovery mechanism applications exposure uncommitted data undoing committed transactions facilitated 
goals develop better understanding compensation really possible employ implications correctness executions compensation 
remainder organized follows 
give informal compensating transactions section 
section transaction model suitable study compensation 
model section define criteria reasonable compensation 
illustrating definitions examples section examine theoretical consequences model section 
implementation issues discussed section related described section 
overview compensating transactions updates committed uncommitted transaction read transaction say externalized 
sole purpose compensation handle situations want undo externalized transaction refer compensated transaction 
transactions affected reading data values written referred dependent transactions referred set notation dep 
key point recovery paradigm leave effects dependent transactions intact preserving consistency database undoing compensated transaction 
compensation broadens scope recovery encompass undoing externalized transactions resorting cascading aborts 
compensated transaction may committed compensation allows undoing committed transactions stands sharp contrast standard approach recovery 
similarly traditional transaction undo compensation method automatically undoing transactions 
traditional transaction undo applies simple special case externalized needs done restore database state just prior 
compensation applicable general case may externalized guarantee erasing direct indirect effects 
compensation undoes effects semantic manner physically restoring prior state 
guaranteed compensation consistent state established semantic information 
state may identical state reached compensated transaction taken place 
propose notion compensating transactions vehicle carrying compensation 
notation ct denote compensating transaction transaction compensating transaction fundamental properties transaction special characteristics 
appears atomic concurrently executing transactions transactions observe partially compensated states conforms consistency constraints effects durable 
compensating transaction special type transaction 
certain circumstances required restore consistency merely preserve 
durable strong sense decision initiate compensation compensating transaction complete sense abort 
special characteristics 
compensating transaction exist right regarded context compensated transaction 
executed compensated transaction 
actions derivative actions compensated dependent transactions 
situations actions compensating transaction extracted automatically program compensated transaction current state database current state log 
situations system programmer responsibility pre define compensating transaction 
case compensating transaction needs accomplish function execution compensated transaction 
user may invoke compensating transaction explicitly order cancel effects externalized transaction manner regular transactions invoked 
alternatively compensating transaction invoked internally recovery manager consequence abortion externalized uncommitted transaction 
mundane example taken real life exemplifies characteristics compensation 
consider database system deals transactions represent purchasing goods 
consider act customer returning goods sold 
compensated transaction case particular purchase compensating transaction encompasses activity caused cancellation purchase 
compensating transaction bound compensated transaction details particular sale price method payment date purchase 
effects purchasing transaction externalized different ways 
instance triggered dependent transaction issued order supplier attempt replenish inventory sold goods 
furthermore customer added store mailing list result particular sale 
actual compensation depends relevant policy 
example customer may store credit full refund 
cancel order supplier retain customer mailing list application dependent issues compensating transaction deal 
crucial understand compensation semantically rich recovery activity 
defining compensating transaction needs achieve concretely depends heavily semantics application hand 
observation guide construction model capture semantics applications easily 
model allows definition variety types correct compensation 
types compensation range traditional undo extreme application dependent special purpose compensating transactions extreme 
return study characteristics compensating transactions depth introduce model section 
transaction model classical transaction model pap bhg transactions viewed sequences read write operations map consistent database states consistent states executed isolation 
correctness criterion model called serializability 
concurrent execution set transactions represented interleaved sequence read write operations said serializable equivalent serial non concurrent execution 
approach poses severe limitations compensation 
sequences uninterpreted reads writes little semantically rich activity compensation considered 
second serializability isolates transaction concurrently executing transactions compensation relevant especially transactions allowed interact cooperate 
section describe semantics transaction model section define executions model discuss corresponding correctness criteria 
transactions programs transaction sequence operations generated result execution program 
exact sequence program generates depends database state seen program gra 
classical transaction model sequences dealt programs abstracted little 
concurrent execution set transactions interleaved sequence operations compensation transactions modeled attempt cancel operations leaving rest sequence intact 
validity remains execution serious doubt originally transactions read data items updated acted accordingly operations vanished indirect impact dependent transactions apparent 
formal way examine compensated execution comparing hypothetical execution dependent transactions compensated transaction 
comparison compensated execution hypothetical execution include compensated transaction key criterion exposition 
generating hypothetical execution studying requires transactions programs indispensable purposes 
transaction program defined high level programming language 
restrict attention pascal assignments conditional statements 
programs local private variables 
order support private non database state space programs define concept augmented state 
augmented state space database state space unioned private state spaces transactions programs 
provision augmented state allows treat reading updating database state similar manner 
reading database state translated update augmented state modeling storage value read local variable 
database denoted db set data entities 
augmented database denoted adb set entities superset database db ae adb 
entity set adb db called private entity 
entities identifying names corresponding values 
state mapping entity names entity values 
distinguish database state state augmented database referred augmented state 
notation denote value entity state symbols primed versions denote state entity respectively 
deviation classical transaction model semantically richer operations primitive read write 
example object oriented databases data type techniques define data objects support specific complex operations see zm 
having operations allows refining notion conflicting versus commutative operations br wei 
possible examine operations commute conflict executed concurrently 
contrast classical model scope considerations write operation conflicts operation entity 
stressed earlier compensation possible semantics database application hand explicit 
features semantics model ability deal rich set complex operations 
operation function augmented states augmented states restricted follows ffl operation updates entity private database entity ffl operation reads database entity may read arbitrary number private entities ffl operation update read database entity 
shorthand notation single operation 

say updates entity reads entities 
arguments operation entities reads 
special termination operations commit abort effect augmented state 
operations assumed executed atomically 
implicitly assumed arguments operation meaningful change value cause change value computed operation 
observe defining operations contradictory goals 
want capture complex semantically rich operations 
second want adhere principles practicality operations primitives fine granularity 
operations model reconcile contradictory goals 
hand operations functions augmented states augmented states giving flexibility define complex operations 
hand mappings restricted database entity accessed operation making feasible allow atomic execution operation 
database entity may accessed operation local variables private entities needed may arguments mapping associated operation 
having private entities arguments operations adds semantics operations 
having functions operations allows conveniently compose operations functional composition making sequences operations functions 
entities scheme arbitrary granularity complexity 
examples entities pages data index files data types stacks queues 
accordingly sample reading operations read page stack top empty queue sample updating operations write page stack push pop insertion queue 
notice sample reading operations read database state updating 
hand blind write updates database state read 
assuming integer type entities increment operation reads updates integer entity 
position introduce notion transaction program 
transaction program sequence program statements ffl operation 
ffl condition form ss ss ss ss sequences program statements predicate mentions private entities constants 
impose restrictions operations specified statements ffl set private entities partitioned transaction programs 
operation program read update private entity partition ffl private entities updated ffl operation reads private entity operation updated entity 
example 
consider sets entities db fa cg adb db fu wg transaction programs observe operation updates reads entity demonstrates operations read entities 
histories correctness serializability correctness criterion applications demand interaction cooperation possibly long duration transactions questioned concurrency control ks fo 
target compensation recovery mechanism kind applications model rely serializability correctness notion 
framework alternative correctness notions set forth ks 
explicit input output predicates database state associated transactions 
input predicate pre condition transaction execution hold state transaction reads 
output condition postcondition transaction guarantees database state transaction provided concurrency database state seen transaction satisfies input condition 
standard model transactions assumed generated correct programs responsibility correct concurrent execution lies concurrency control protocol 
observe input output predicates excellent means capturing semantics database system 
convention predicates semantics associated set transactions similarly way predicates associated nested transactions ks 
set transactions supposed collectively establish desirable property complete coherent task 
convention useful domains long duration nested transactions assigned single complex task 
elaborate generation interleaved concurrent executions sets transaction programs central understanding results 
notion history result interleaving central concept model 
history sequence operations defining total order operations function augmented states augmented states functional composition operations 
notation 

fn denote history operation precedes alternatively functional composition symbol ffi compose operations functions 
ffi 
ffi fn denotes function augmented states augmented states defined history upper case letters alphabet denote sequence function history defines 
equivalence symbol denote equality histories functions 
histories means augmented states 
observe histories operations alike functions function composition symbol ffi compose histories operations 
concurrent execution set transaction programs initiated state generates history say history initial state example 
consider transaction program example 
conditional branch histories generated executed isolation 
list histories sequences operations database state initial state 
consider concurrent execution previous example 
possible histories 
show histories initial state 
operation prefixed name transaction issued 
observe observe key notion treatment compensation commutativity 
say sequences operations commute ffi ffi 
operations conflict commute 
observe defining operations functions regardless read update database leads simple definition key concept commutativity 
compare definition wei br example 
typically operation updates entity operation reads commute 
part orderings implied total order operations composed form history arbitrary conflicting operations totally ordered 
essence equivalence notion restricted database state similar final state equivalence pap 
follows shall need equate histories necessarily set transactions contrast final state equivalence familiar equivalence notions 
projection history entity subsequence consists operations updated denote projection notation projection set entities 
impose weak constraints concurrent executions order exclude executions possible consideration 
consider types histories ffl history serial transactions appear operations appear operations vice versa 
ffl history serializable sr exists serial history ffl 
predicate database state 
conjunct denote set database entities mentioned history predicate wise serializable respect predicate set entities exists serial history ffl history entity wise serializable entity exists serial history definition histories adapted 
shall see shortly histories going quite useful 
lemma proof 
lemma 
predicate mentions database entities sr denote set histories histories sr histories respectively 
sr ae ae 
denote sequence operations transaction history involving possibly transactions 
notation sets transactions 
xt projected entity resulting sequence denoted xt compensating transactions aid tools developed section position define compensation formally 
guidelines defining compensating transactions compensation application dependent activity certain guidelines compensating transaction adhere 
introducing notation conventions specification constraints defining compensating transactions 
constraints provide broad framework defining concrete compensating transactions concrete applications thought generic specification compensating transactions 
say transaction dependent transaction history exists entity ffl reads updated ffl abort reads ffl transaction updates time updates reads aborted reads definition adapted bhg 
transaction depended transaction may committed transaction active transaction 
case want support undo corresponding compensating transaction ct pre defined 
key point admitting non recoverable histories supporting undo committed transactions predicated existence compensatory mechanisms needed handle undoing externalized transactions 
rest denotes compensated transaction ct denotes corresponding compensating transaction dep denotes set transactions dependent set dependent transactions regarded set related sub transactions perform coherent task 
constraint 
histories ffix ct contiguous subsequence ffix ct identity mapping 
simplest interpretation constraint entities updated read transaction xct follows xt history ct amounts simply undoing consequently transactions depend transaction reads updated data entities ct just traditional undo 
fact ct just undo crucial effects compensation depend span history execution compensated transaction till initiation 
span exists dependent transactions effects compensation may vary different undoing instance compensation may include additional activity directly related undoing 
example cancellation reservation airline reservation system handled compensating transaction causes transfer pending reservation waiting list confirmed list 
certain operations certain entities undone compensated form inverting state 
gra type operations entities termed real dispensing money firing missile 
simplicity sake omit discussion entities 
constraint 
history involving ct exist subsequences transaction operations ffi xct ffi constraint represents atomicity compensation 
transaction see database state affected ct see state ct termination 
precisely transactions operations conflict ct operations scheduled ct operations ct operations 
responsibility concurrency control protocol implement constraint see section implementation discussion 
follows notation denote output input predicate transaction respectively 
notation set transactions 
predicates predicates database state 
constraint 
predicate defined database state dep oct constraint appropriate general consistency constraint specific predicate established dep collective tasks transactions dep true 
informally constraint says established dep violated undoing preserved ct constraints semantics compensation imposing restrictions output predicate compensating transaction 
observe assumption holds initially crucial effects undone ct predicates established preserved dep persist compensation 
responsibility defines ct enforce constraint 
constraints assumed hold compensating transactions 
constraint intricate captures semantics compensation discussed section 
types compensation mentioned earlier compensation really application dependent activity 
ways define compensation supposed accomplish 
important criterion exists range possibilities 
applications acceptable execution dependent transaction compensated compensating transactions produce different results produced execution compensation 
hand applications forbid compensation outcome executions 
explicit criterion distinguishes types compensation defining notion compensation soundness 
definition 
history ct dep initial state history transactions dep initial state history sound 
history history dep 
far definition goes different sets sub transactions dep may commit conflicting operations may ordered differently 
key point 
history sound compensation disturb outcome dependent transactions 
database state compensation state execution dependent transactions dep 
direct indirect effects compensated transaction erased compensation 
transactions dep see different database states ct executed generate history totally different history distinction histories essence important notion soundness possible viewed transaction merely sequence operations program 
delicate point arises regard soundness satisfy dep situations may occur establishes dep dep manner dep follow history 
compensated history dep satisfy soundness requirement 
model situations postulating dep hold results special state equal state undefined state sound 
illustrate definition considering histories read write operations notation denotes reading similarly write commit history recoverable 
history recoverable 
ct defined aborted 
extend operations ct call extended history sound provided generated program value written run isolation starting initial state key notion context compensation defined commutativity compensating operations operations dependent transactions 
significant attention devoted effects commutative operations concurrency control kor wei br 
parallels results exploits commutativity respect recovery 
theorems prefer impose commutativity requirements ct ct exposed users constraining constraining preferable 
predicated commutativity operations compensated transaction corresponding compensatory operations brought cancel effects enforcement constraint ensuring sound histories 
theorem formalizes idea 
theorem 
history involving dep ct operations dep commutes operations xct sound 
omit proof theorem central exposition 
illustrate simple example example 
ct compensated transaction dependent transaction compensating transaction respectively 
programs transactions include condition statements sequences operations 
give history operation prefixed name issuing transaction 

ct 
clearly operation commutes operation ct sound history demonstrates soundness simply 

clear section fact condition statements appear important 
main emphasis liberal forms compensation soundness results executing dependent transactions isolation may different results presence compensated compensating transactions 
way characterizing weaker forms soundness qualifying set entities equality definition holds 
section define type compensating transaction ensures sound compensation respect set entities 
alternatively section investigate weak forms soundness approximate pure soundness 
compensation examples applications section examples illustrate various concept introduced far 
section symbols dep ct denote compensated transaction compensating transaction corresponding set dependent transactions history transactions history initial state respectively 
generic compensating transaction example generic compensation definition 
update denote set database entities updated history notation set transactions 
definition 
ffi xct constraint 
define generic compensating transaction ct characterizing entities update dep update dep update dep update dep update proceed informally explain meaning type compensation 
ffl dependent transaction updates entity updates ct undoes updates entity 
ffl value entities updated dependent transactions left intact 
ffl value entities updated dependents reflect dependents updates 
certain subtlety second case definition illustrated 
assume updated modified read transaction dep value read determines transaction updates compensation initial value restored case definition indirect effect left intact second case definition 
definition precise specification ct accomplish 
illustrate type compensation just described give concrete example 
consider airline reservation system entity seats denotes total number seats particular flight entity rs denotes number reserved seats flight entity reject counts number transactions reservations flight rejected 
reserve simplified seat reservation transaction seats defined rs seats rs rs reject reject consistency constraint case iff rs seats 
assume rs rejects reserve dep history ffi dep ffi xct ct defined definition 
frs rejects reservations canceled running ct dep reservations rejected 
exactly get definition 
observe reservations canceled indirect impact rejects persists caused dep reservations rejected 
example demonstrates history sound intuitively acceptable 
transaction dep executed result successful reservations 
notice example operation ct implemented inverse operation addition subtraction 
interesting case seats accommodate dep fits nicely 
case ct subtraction entity seats commutes dep addition entity 
storage management examples applications example mgg notion compensation 
consider transactions adds new tuple relation relational database 
assume tuples added different keys 
tuple addition processed allocating filling slot relation tuple file adding key slot number separate index 
assume slot updating index insertion steps implemented single page read followed single page write written tp tp tuple file page ip ip index file page 
consider history regarding tuple pages tq tr index page ip tq tq tr tr ip ip ip ip serial execution equivalent serial history executing assume want abort index insertion seen page written index insertion step 
way abort aborting compensate fortunately natural compensation ct delete key operation 
observe delete operation compensation satisfies constraint commutes insertion tuple different key encapsulates composite compensation slot updating index insertion 
resulting history sound 
entire class applications compensation similar example context storage management database system 
difficult isolate effects operation storage management level 
effects exposed transactions 
list specific examples illustration compensated transaction extends file allocated storage additional space transactions compensated transaction frees space allocated transactions compensated transaction inserts record tree causes split node transactions new nodes compensated transaction updates free space information mechanism storage manager percentage occupied space page transactions update information 
note storage management examples effects exposed transactions exposed users 
undoing operations referred logical undoing supported logical logging hr 
transaction undone logical manner semantic point view 
physical level leave traces 
clearly physical logging images restored blindly object affected undone transaction question cases 
propose define compensatory actions type storage management actions 
compensation amounts simply leaving effects 
point traditional physical undoing properly context 
approximating compensation soundness section introduce weak forms compensation soundness results execution includes compensation approximate results executing dependent transactions isolation 
denote history transactions dep ct history compensation history dep approximated form soundness final state related final state relation equality pure soundness 
relation serve constrain ct prevent violating consistency constraints desirable predicates established dep 
relation goodness properties instance consistency constraint predicate holds final state hold final state 
achieving approximated soundness intricate problem histories non serializable allow 
obstacle mentioned programs transactions dep see different database states ct executed may generate history totally different original history may related required 
state theorems formalize interplay approximated soundness notion concurrency control constraints restrictions programs dependent transactions commutativity 
theorem followed simplified example serves illustrate part theorem premises consequences 
proofs theorems appendix 
section assume compensating transaction complies constraints section 
constraints proofs explicitly mentioning premises 
start definitions weaker forms commutativity weaker forms compensation soundness 
definition 
sequences operations commute respect relation augmented states short commute augmented states ffi ffi 
observe equality relation regular commutativity 
definition 
history dep ct initial state reflexive relation augmented states 
history sound respect short sound exists history dep initial state 
observe regular soundness special case soundness equality relation 
reflexive empty history sound regardless choice motivate definitions considering adequate relations context commutativity soundness 
predicate database states dep regarded consistency constraint desired predicate established dep similarly predicate constraint 
guarantee compensation violate define context follows iff sound history advantageous property predicates violated compensation 
sound histories yield states approximate states yielded sound histories sense states satisfy desirable predicates 
definition spirit cad systems final result execution importance order recovery related actions execution 
examples follow theorems relations form 
definition 
relation states denote values arbitrary entity define relations values entity follows iff definition 
history dep ct initial state reflexive relation augmented states 
history partially sound exists history dep initial state db 
definition 
program transaction fixed sequence operations private entities arguments 
program fixed conditional branches 
local variables store values subsequent referencing 
sequence operations operation reads updates single database entity storing values local variables fixed transaction 
transaction uses single operation give raise certain employee recorded salary management database example fixed transaction 
theorem 
history dep ct initial state histories dep xct commute programs transactions dep fixed partially sound 
example 
consider database system entities parametric operations reflexive relation db fa integer iff predicates demonstrate partial soundness 
emphasize atomic operations 
history follows need give program dep fixed 
dep dep ct ct observe dep xct commute commute relation initial state fa 
fa fa partially sound 
theorem quite weak restricts programs dep severely guarantees partial 
inherent problem proofs compensation soundness fact equate histories set transactions contrast equivalence notions traditional theory concurrency control 
obstacle history may generated different executions programs dep may totally different dep just syntactic derivative history theorem problem solved dep fixed see proof appendix 
obstacle removed posing assumptions done 
definition 
transaction serialization point history ffi ffi observe restrictions imposed notice compensating transaction serialization point implied constraint 
theorem 
history dep ct history transactions dep ct dep ffi zct states histories exists history dep zct ffi dep ffi zct history serialization point sound 
note required dep programs executing ct dep result state related state resulting executing dep ct observe requirement stronger commutativity 
theorem quite useful specifies concurrency control policy guarantees soundness 
need ensure potential compensated transaction isolated serialization point order guarantee soundness case compensation 
example 
consider set entities example addition private entity belongs transaction dep 
programs dep ct relation defined follows dep ct iff dep history branch differently run presence ct different histories produce final states related definition 
program transaction linear sequence operations 
programs sequences allow operations read multiple entities local variables 
programs may fixed 
example linear transaction program program gives raise employees raise aggregated computation instance minimum salary 
definition 
reflexive relation augmented states 
operation updates preserves adb theorem 
history dep ct initial state histories dep xct commute programs transactions dep linear transitive operations dep preserve partially sound 
example 
consider set entities example addition private entity belongs transaction dep 
relation iff 
history follows 
dep dep ct observe xct dep commute commute dep linear fixed partially sound 
lemma section derive corollary 
corollary 
theorems hold sr 
requirements dependent transactions theorems quite severe 
commutativity requirement imposed operations dependent transactions restrictions shape programs fixed linear programs theorems premises 
clearly practical systems transactions stand criteria 
practical ramification observation externalization uncommitted data items done controlled manner degree soundness importance 
uncommitted data externalized transactions satisfy requirements specified premises theorems 
context locks locks released qualified transactions transactions satisfy requirements 
transactions delayed subject standard concurrency control recovery policies 
implementation compensating transactions section discuss implementation issues need considered order compensation practical 
useful component recovery system supports compensation log 
log source crucial information actual sequence operations generated transaction identity dependent transactions logical logging scheme operation level hr conjunction compensation 
log record scheme contains operation name issuing transaction name name entity operation updates values arguments 
scheme provides semantic information physical logging hr 
envision compensating transaction driven scan log starting record compensated transaction transaction log record 
important provide convenient line access log information purposes 
suitable logging architecture accesses translate traffic interrupt sequential log performed behalf executing transactions 
related problem concerned supporting compensation long duration transactions log records span lengthy log interval causing difficulties terms reusing log space efficient access distant log records 
currently investigating issue efficient log access recovery purposes 
subtle ramifications concurrency control discussed context locking 
required ct execution serializable respect concurrent transactions 
constraint 
reasonably assumed update ct update leads compensating transaction dependent transactions follow phase locking protocol bhg respect entities update 
possible violate constraint 
viable strategy simplify matters implementation follows 
ct invoked entities update identified analyzing log ct exclusively lock entities set 
performing necessary updates ct release locks 
recovery issues compensating transactions considered 
noted earlier disallow compensating transaction aborted voluntarily 
choice abort commit original transaction 
compensating transaction offers ability reverse choice go providing capability abort compensation 
forms transaction failures opposed system failures avoided 
compensating transaction chosen victim deadlock resolution scenario 
running compensating transaction time avoiding cycle compensating transactions solve problem similarly golden transactions system gm 
problem system failures 
think preferred way handle problem resume uncompleted compensating transactions undoing 
accomplish need resume compensating transaction point internal state saved necessary concurrency control information refer gm discussion save points saving locking status 
emphasize principle recovery compensating transaction transaction record ct appears stable storage ct completed 
technique logging undo activity discussed length 
implementation lines aries system support persistence compensating transactions system crashes 
aries undo activity logged compensating log records clrs 
clr points directly indirectly regular log record undone 
technique guarantees actions undone undo actions undone undo transaction interrupted system crash 
related idea compensating transactions semantically rich recovery mechanism mentioned referred papers 
best knowledge formal comprehensive treatment issue ramifications lacking 
strong motivation gray early gra 
compensating transactions mentioned informally post facto transactions means alter committed effects 
compensation mentioned possible remedy limitations current transaction model 
early db dc database system bjo dav idea semantic undoing 
notion compensation mentioned context histories preserve consistency serializable gm fo 
noted gm running undo steps necessarily return database initial state observation elaborate 
difficulty designing raised drawback compensation problem address 
compensating transactions mentioned context saga long duration transaction broken collection subtransactions interleaved way transactions gms 
saga execute subtransactions compensating transactions amend partial execution sagas 
gms gm idea compensating transaction voluntarily abort introduced 
low level details store reliably code compensating transactions record identity log records saga subtransactions discussed 
noteworthy approach classified simple type compensation employed xprs system 
notion failure commutativity defined complete transactions 
transactions failure commute commute succeed unilateral abort transaction cause abort 
transactions classified failure commutative run concurrently conflicts 
handling abort transaction done log special undo function special case compensation define 
theoretic class related commutativity properties data type operations 
br semantics operations data types define recoverability weaker notion commutativity 
conflict relations recoverability commutativity 
consequently concurrency enhanced potential conflicts reduced 
operation recoverable respect uncommitted operation operation executed commit dependency forced operations 
dependency affects order operations commit commit 
operation aborts commit avoiding cascading aborts 
type conservative sense narrows domain interest serializable histories 
results offer notions weaker standard recoverability applicable wider domain includes non serializable non recoverable histories 
explicitly allows handles situations exposed dirty data offers extra flexibility cases need arises 
discussed consequences early exposure uncommitted data 
argued concept useful database applications employing long duration nested transactions 
compensating transactions proposed means recovery management presence early externalization 
framework understanding design semantics application dependent compensatory activities established 
types compensation soundness criteria introduced predicated notions commutativity 
approximated forms soundness guarantee compensation results desirable consequences dependent transactions outcome 
semantically rich model adequate dealing non serializable non recoverable histories set offered viable tool understanding intricate histories compensation issues 
believe database applications require rethinking traditional transaction model founded serializability permanence commitment 
contemporary applications domains cad case cim domains require long durations nested transactions exemplify belief 
step establishment new model 
bhg bernstein hadzilacos goodman 
concurrency control recovery database systems 
addison wesley reading ma 
bjo 
recovery scenario db dc system 
proceedings acm annual conference atlanta pages 
br badrinath 
semantic concurrency control commutativity 
proceedings third international conference data engineering los angeles 
dav davies 
recovery semantics db dc system 
proceedings acm annual conference atlanta pages 
fo 
semantic knowledge transactions increase concurrency 
acm transactions database systems december 
gm gray mcjones recovery manager system database manager 
acm computing surveys 
gm garcia molina 
semantic knowledge transaction processing distributed database 
acm transactions database systems june 
gms garcia molina salem 
sagas 
proceedings acm sigmod international conference management data san francisco pages 
gra gray 
transaction model 
lecture notes computer science automata languages programming pages 
springer verlag berlin 
gra gray 
transaction concept virtues limitations 
proceedings seventh international conference large databases cannes pages 
hr reuter 
principles transaction oriented database recovery taxonomy 
acm computing surveys december 
hr rothermel 
concepts transaction recovery nested transactions 
proceedings acm sigmod international conference management data san francisco pages 
korth kim bancilhon 
long duration cad transactions 
information sciences october 
kim lorie 
nested transactions engineering design databases 
proceedings tenth international conference large databases singapore pages 
kor korth 
locking primitives database system 
journal acm january 
ks korth 
formal model correctness serializability 
proceedings acm sigmod international conference management data chicago pages june 
lag directions dbms research 
report summarizes laguna beach workshop 
mgg moss graham 
abstractions recovery management 
proceedings acm sigmod international conference management data washington pages 
mohan lindsay pirahesh schwarz 
aries transaction recovery method supporting fine granularity locking partial rollbacks write ahead logging 
technical report rj ibm research 
appear acm transactions database systems 
pap papadimitriou 
theory database concurrency control 
computer science press rockville maryland 
stonebraker katz patterson ousterhout 
design xprs 
proceedings fourteenth international conference large databases los angeles pages 
wei weihl 
commutativity concurrency control data types 
ieee transactions computers december 
zm maier 
readings object oriented database systems 
morgan kaufmann san mateo california 
model definitions notation going formal proofs 
projection entity applied state interested resulting value particular entity 
shorthand 
astute reader may noticed defined particular necessarily equal 
includes operations update private entities updated value private entities undefined histories projected database entities applied state 
rectify anomaly define function ex database states histories augmented states follows 
database state history ex ae db adb db noted third case definition dep dep ex sake simplicity 
illustrate function ex example example 
adb db fa bg db 
consider history 

undefined value 

ex ex 
essentially augmented state ex represents view pap operations database history applied state lemma easily proven induction length aid restriction private entities updated 
lemma 
histories adb ex 
proofs section proofs theorems 
need state lemmas proofs omitted brevity 
lemma 
histories commute augmented states exists augmented state ffl ffi ffi ffl db restrictions database states coincide 
lemma 
history dep ct initial state entities updated dep 
dep ffi ffi xct 
ffi dep ffi xct proof theorem proof 
history transactions dep includes operations dep order legitimate history dep programs fixed 
prove stronger claim proof obligation show entities rest 
dep fixed database states dep 
proceed examining equivalences established lemma 
case entity updated dep trivial 
case equivalence holds constraint xt xct cancel ex dep ex 
dep programs fixed dep ex ex claim proved case 
case equivalence holds observe dep ffi xct ex 
apply commutativity assumption lemma observe xct ffi dep xt 
coincides database entities lemma 
dep enforcing constraint 
dep transactions fixed programs coincide database entities holds ex 
case 
proof theorem proof 
history serialization point initial state 
ct serialization points ffi dep ffi xct dep ffi xct xt 
assumption exists history dep xct ffi xt equality constraint 
observe ffi xct ffi history involves dep 
proof theorem proof 
lemma commutativity assumption reflexivity show db dep coincides database state 
similar proof theorem 
history transactions dep includes operations dep order legitimate history dep programs linear 
show db ex dep transitivity complete proof 
programs dep linear treat merely sequence operations regardless issuing transactions 
ffi ffi sequence operations dep order appearance 
show adb ex dep coincides database state induction adb dep ex 
inductive step transform adb 
final value database entities computed sequence operations 
apply hypothesis induction get adb ex dep 
focus 
say ex dep fn 
argument computed operations apply hypothesis induction get adb 
fn preserves completed proof 

