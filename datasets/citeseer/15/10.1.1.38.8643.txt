languages automata logic wolfgang thomas may bericht institut fur informatik und praktische mathematik der christian universitat zu kiel kiel mail wt informatik uni kiel de supported esprit bra working group algebraic syntactic methods computer science deutsche forschungsgemeinschaft dfg th 
survey logical aspects finite automata 
central points connection finite automata monadic second order logic ehrenfeucht fraiss technique context formal language theory finite automata words determinization self contained proof rabin tree theorem 
sections contain material lecture series final winter school palermo february 
modified version chapter handbook formal language theory edited rozenberg salomaa appear springer verlag 
keywords finite automata monadic second order logic order logic regular languages star free languages tree automata ehrenfeucht fraiss game automata temporal logic buchi automata rabin tree automata determinacy decidable theories 
contents models formulas words trees graphs models 
order logic 
monadic second order logic 
automata mso logic finite words trees mso logic words 
mso logic traces trees 
order definability ehrenfeucht fraiss game 
locally threshold testable sets 
star free languages 
automata mso logic infinite words automata 
determinization automata 
applications definability decision problems 
automata mso logic infinite trees automata infinite trees 
determinacy complementation 
applications decision problems mso logic 
acknowledgment subject chapter study formal languages languages recognizable finite automata framework mathematical logic 
connection automata logic goes back buchi bu elgot showed finite automata monadic second order logic interpreted finite words expressive power transformations formulas automata vice versa effective 
buchi bu mcnaughton mcn rabin rab equivalence shown finite automata monadic second order logic infinite words trees 
research initiated decision problems restricted systems arithmetic problem synthesizing circuits nonterminating behaviour logic specifications chu tb 
reduction formulas finite automata key solution problems monadic second order theories respectively successor functions shown decidable bu rab leading decidability results interesting mathematical theories logics programs 
furthermore turned buchi landweber bl circuit synthesis problem respect specifications solvable effectively gave new perspective automatic construction nonterminating programs 
eighties bridge descriptive formalism monadic second order logic computational operational model finite automaton refined extended allow practical 
temporal logics fixed point logics took role specification languages replacing classical systems order logic monadic second order logic efficient transformations logic formulas automata 
led powerful algorithms software systems verification finite state programs model checking 
area developed subject built extensive literature covered detail monographs field mention mcm arn kur 
equivalence automata logical formalisms started new tracks research language theory 
example classification theory formal languages deepened including logical notions techniques logical approach helped generalizing language theoretical results domain words general structures trees partial orders 
logical description behaviour computational models taken complexity theory 
starting fagin fag shown complexity classes np pspace characterized different versions second order logic involving example fixed point operators transitive closure operators 
theory forms core subject finite model theory specifically descriptive complexity theory refer reader ef comprehensive exposition 
topic chapter finite automata considered resource bounded turing machines may called descriptive theory recognizability 
logical framework corresponds restricting secondorder logic describing classical complexity classes monadic order fragment 
surprising merge techniques results automata theory logic complexity achieved circuit complexity theory computational power boolean circuits studied regarding restrictions size depth types allowed gates 
turned natural families circuits bounds size depth described generalized models finite automata appropriate systems order logic 
book str results developed detail including algebraic aspects concerning varieties monoids associated regular languages 
main objective survey explain precise relation finite automata monadic second order logic give self contained proofs fundamental results 
include certain difficult automata theoretic constructions infinite words trees safra determinization automata saf rabin tree theorem rab accessible textbooks surveys short exposition iss game technique applications concerning order logic formal language theory 
complementary material related survey th 
hand short remarks neighbour subjects mentioned reader refer cited monographs 
models formulas start simple example explain description formal languages logical formulas 
finite automaton accepts words alphabet fa cg succeeded succeeded letter 
conditions expressed order formula variables letter positions formula indicate position succeeds formalize position carries letter ys note ys expresses letter position word consideration 
example shows variables ranging sets positions corresponding atomic formulas meaning useful 
consider set words fa bg occurrences occurs separated block odd number letters suffices express occurrences set positions containing position second position position 
remainder section introduce framework definition formal languages precisely 
include general structures words particular labelled trees graphs 
words trees graphs models finite alphabet gamma word word represented relational structure dom called word model dom gamma set letter positions domain successor relation dom gamma natural order dom unary predicates collecting label letter positions carry fi dom ag 
word model viewed vertex labelled graph edge relation induces linear ordering 
relations called numerical unary relations called letter predicates 
framework easily adapted words alphabet sequences ff corresponding structures ff form ff ff ff ff domain fixed set natural numbers 
generalization include trees 
shall restrict proper binary trees node leaf successors ordered left right successor 
saves notation covers typical features arising trees 
nodes trees represented finite words alphabet means branch left means branch right tree domains prefix closed subsets word belong tree alphabet map dom dom tree domain 
corresponding relational structure form dom left respectively right successor relations dom dom proper prefix relation dom fu dom ag 
say tree finite domain finite infinite trees shall consider full binary trees maps denote ta set finite trees set infinite full binary trees step generalization consider vertex edge labelled directed graphs 
usually vertex labels alphabet edge labels alphabet vertex set partitioned sets collecting vertices label respectively edge set partitioned sets collecting edges labelled respectively 
graphs represented form disjoint sets disjoint subsets theta acyclic graphs partial order reflexive transitive closure may added 
tree models word models arise special cases trees tree domain labels edges indicating transition left right successor words label edge relation coincides successor relation 
confusion arises cancel superscripts ff relations just speak instance successor relation ordering 
versions graphs important generalized theory formal languages mazurkiewicz trace graphs dr texts er 
trace graphs arise words dependence relation alphabet texts obtained words introducing second successor relation 
details chapter connection results related structures 
order logic properties words trees graphs formalized logical languages 
order language 
consider word models alphabet corresponding order language variables ranging positions word models built atomic formulas form means connectives quantifiers 
set relation symbols called signature order language 
equality sign tacitly assumed 
notation indicates formula variables occur free scope quantifier 
sentence formula free variables 
positions dom means satisfied interpreted equality respectively serve interpretations respectively 
empty model usually excluded framework mathematical logic 
sequel allow empty word ffl member formal languages admit empty model interpretation sentences 
natural convention ffl satisfies universal sentences satisfy existential sentences fixes satisfaction relation ffl sentences 
language defined sentence fw 
similarly language defined 
fff ff 
example sentence section 
contains words fa bg successive occurrences odd number letters say language resp 
language fo definable order definable order sentence exists resp 

similarly fo definability mean existence sentence 
note case may drop symbol successor expressed terms formula 
definition word properties convenient allow predicates apply respectively position exists word model 
stand formulas ys ys respectively 
replace 
nonempty words considered alternative introduce special constants min max denoting respectively element word model exist non emptiness assumption 
analogous way order formulas tree models graph models introduced 
signature adapted accordingly interpretation relation symbols 
binary trees relation symbols successor relations stands partial order proper prefix relation tree domains 
resp 

denote set finite resp 
infinite trees alphabet satisfy sentence 
convenient function symbols relation symbols example symbols suc suc suc successor functions introduced 
allows shorter formalizations especially compositions functions considered 
example write suc suc suc 
general considerations complicated function symbols convention necessary assignment successor position word alternatively partial functions admitted 
possible eliminate function symbols terms relation symbols graphs functions consideration shall restrict relational case sequel 
graphs edge relation symbols take role successor relation symbols label alphabets vertices edges atomic formulas associated order language 
shall standard results quantifier logic especially prenex normal form order formula transformed 
prefix quantifiers precedes quantifier free kernel 
successive quantifiers type grouped blocks say existential quantifiers formula form tuples variables quantifier free formula called sigma formula 
pi formula mean dual case formula alternating blocks quantifiers block universal quantifiers 
laws quantifier logic negation sigma formula written pi formula 
boolean combinations sigma formulas called sigma formulas 
superscript indicates classification order quantifiers considered may omitted context clear superscript refers classification second order quantifiers 
monadic second order logic extend logical formalism second order variables range sets elements models sets letter positions sets tree nodes sets graph vertices 
corresponding atomic formulas introduced intended meaning belongs belongs sets monadic second order objects contrast relations higher arity polyadic resulting system called monadic second order logic short mso logic 
second order formulas prenex normal form exists 
shift second order quantifiers front order quantifiers singletons representations elements 
example equivalent 
sigma formula formula prefix second order quantifier blocks starting existential quantifiers precedes formula order quantifiers occur 
sigma formulas mso logic called existential monadic second order formulas short formulas 
note mso logic order relation words definable terms successor word models equivalence obtain fo definable word language mso definable henceforth just say mso definable 
trees similar definition terms partial tree order 
proper prefix relation dom tree 
study monadic second order logic shall modified logical system expressive power call mso logic 
simpler syntax order variables cancelled 
prenex normal form mso formulas idea simulate quantifiers elements quantifiers singletons 
fxg replace 
new atomic formulas mso logic label alphabet sing suc meaning subset singleton singletons fxg fyg subset respectively 
translation mso mso logic easy induction construction mso formulas 
example rewritten sing sing suc trees graphs formulas suc suc 
mso formula free variables interpreted word model tree model graph designated subsets model represents word tree graph expanded alphabet theta label position node vertex indicates carries label belongs iff 
instance word model ff ff set numbers set prime numbers identified word fa bg theta letters written columns ff delta delta delta sequel shall identification set expansions models models extended alphabets 
worth mentioning logical framework essential difficulty transferring definability notions domain words extended domains trees graphs transition finite models infinite models involve conceptual problem 
necessary adapt signature consideration change class admitted models 
definability notions formal language theory automata grammars regular expressions generalizations involved possible additional conventions need special justification 
sense logical approach may serve support guideline generalizing classical formal language theory 
automata mso logic finite words trees mso logic words specify recognizable regular languages refer nondeterministic automata alphabet form delta finite state set input alphabet initial state delta theta theta transition relation set final states 
word gamma accepted successful run sequence ae ae ae states ae ae ae delta ae language recognized collects words accepted theorem buchi bu elgot language finite words recognizable finite automaton iff mso definable conversions automata formulas vice versa effective 
proof 
show direction left right delta finite automaton 
assume kg 
find monadic second order sentence expresses word model accepts word gamma sentence state existence successful run delta may code state sequence gamma tuple pairwise disjoint subsets gamma contains positions state assumed 
efficient coding correspondence states vectors suitable length allows describe run states tuple subsets word domain 
state gamma automaton able reach final state word letter gamma accepts nonempty word iff delta delta empty word satisfies sentence 
accept ffl corresponding clause added 
show direction right left 
refer mso formulas introduced previous section show claim induction formulas 
exhibit formula finite automaton accepts precisely words theta satisfy 
recall words represented word models 
easy finite automata recognize sets defined atomic formulas sing suc finite automaton checking holds theta verify occurs th additional component occurs th additional component 
inductive step suffices consider connectives existential set quantification connectives universal set quantifier definable terms 
turn amounts proof class recognizable languages shares known closure properties closure complement union projection 
discuss case assuming language defined formula alphabet theta recognized automaton exhibit automaton corresponding formula gamma 
required automaton theta gamma just guess nondeterminism sequence define th additional components extended word theta formula proof describing acceptance underlying word model automaton formula special type 
invoking second part proof see provides normal form mso formulas buchi terminology automata normal form 
corollary mso formula written formula 
th shown single existential set quantifier suffices formulas defining recognizable languages 
automata theoretic approach monadic second order logic yields form quantifier elimination visible reduction arbitrary formulas mentioned automata normal form 
classical logic derives decidability results 
quantifiers eliminated normal form reached existential set quantifiers kernel universal order quantifiers appear 
predicates expanded order quantifier alternation added 
advantages normal form strong closure properties boolean operations projection algorithmic operational meaning 
potential eliminate quantifiers rests simultaneous closure class recognizable languages projection corresponding existential quantification complement allowing treat dual universal quantification automata theoretic framework usually shown reduction nondeterministic automata yield projection easily deterministic automata yield complementation easily 
successive alternations quantifiers amount successive applications powerset construction automata 
means straightforward approach quantifier alternation induces exponential blow size corresponding finite automata 
results meyer stockmeyer see ahu follows regarding computation time blow avoided time complexity algorithm converting mso formulas fo formulas equivalent finite automata bounded elementary function iterated exponential form length formula 
remarkable conversion algorithm implemented allows nontrivial practical applications hardware verification bk 
corresponding reduction mso logic finite automata infinite words infinite trees determinization complementation results difficult treated sections 
natural generalization mso logic admit second order variables higher arity variables ranging relations quantifiers 
leads larger language class class regular languages theorem fagin fag language belongs complexity class np iff definable general existential second order logic 
follows full second order logic covers languages polynomial time hierarchy 
second order concepts fixed point operator transitive closure operator lead logics characterize complexity classes nlogspace pspace 
results descriptive complexity theory reader consult ef 
binary relations admitted restricted called matchings lst characterization context free languages obtained 
relation gamma called matching contains pairs position belongs pair crossings pairs implies 
typically kind binary relation serves define dyck languages connecting positions matching letters occur 
theorem schwentick th lst language context free iff definable existential second order logic second order variables range matchings 
turn applications theorem decision problems results concerning definability sets relations finite words 
buchi elgot result derive decidability weak monadic second order theory successor denoted ws consists mso sentences true structure provision set quantifiers range finite sets 
mso sentence interpretation equivalent input free finite automaton finite words truth amounts existence successful run automaton easily checked 
bu noted decidability ws decidability presburger arithmetic inferred set true order sentences structure 
idea represent numbers binary words view word characteristic function finite set 
convenient write binary representations reversed order puts th bit expansion sigma position yielding word example number reversed binary representation corresponds finite set 
easy write formula expresses finite sets represent numbers describes addition algorithm proceeds digit digit successor proceed digit existence auxiliary set carries 
way order formula signature inductively transformed corresponding weak mso formula finite set quantifiers place firstorder quantifiers numbers 
decidability presburger arithmetic follows applying translation order sentences signature free variables invoking decidability ws 
translating presburger formulas weak mso logic proceed directly finite automata 
input automaton word alphabet stands tuple numbers sequence th components reversed binary representation length word determined highest digit carrying highest nonzero digit say position occurs representations km filled highest nonzero digit zeroes position finite automaton scans word viewed acceptor reading head component heads move synchronously input 
calls word relations recognized automata synchronized rational relations fs 
context numbers represented base speaks recognizable relations natural numbers 
buchi bu question considered extension presburger arithmetic allow define precisely recognizable sets natural numbers 
words extend presburger arithmetic translation back weak mso logic finite automata 
buchi suggested adjoin predicate power turned slightly stronger arithmetical means necessary fact function appropriate associates number greatest power divides general considers ary representations natural numbers associated notion recognizable relation automata working alphabet gamma relation ary 
recognizable sets numbers ultimately periodic ones 
logical side defines function greatest power divides 
equivalence result holds theorem cf 
relation natural numbers recognizable iff order definable structure formula relation ary 
deep theorem due connects notions recognizability different set natural numbers recognizable multiplicatively independent recognizable ultimately periodic see 
numbers called multiplicatively independent powers coincide 
generalization theorem relations sets numbers obtained elegant proof muchnik comprehensive expositions see lucid survey mv 
interesting note expressive power finite automata recognize relations asynchronous manner reading heads different components may apart arbitrary distances greater synchronous case 
instance class synchronized rational relations captured weak mso logic successor closed boolean operations projection application boolean operations projection asynchronously recognized relations leads nonrecursive relations exhaust way arithmetical hierarchy word relations languages sei 
hand distance reading heads uniformly bounded reduction synchronized mode possible infinite input words fs 
mso logic traces trees mathematical core theorem fact model finite automaton closed operations complementation projection logical terms negation existential quantification 
natural ask generalized structures finite words similar theory finite automata possible aiming corresponding logical consequences 
section discuss basic classes structures generalization possible 
class dependency graphs mazurkiewicz traces cf 
dr dm 
traces formed dependence alphabet pair alphabet reflexive symmetric dependency relation theta note letter considered dependent 
view traces special acyclic partially ordered graphs vertices labelled edge relation respects sense edges connect vertices carrying dependent letters vertices labelled dependent letters connected path 
reflexivity antichain trace graph set vertices pairwise unrelated partial order jaj elements 
order obtain canonical representation keep edge set edges hasse diagram partial order generated transitive closure edges include generated partial order 
trace graph form mentioned conditions vertices dependent letters satisfied 
trace language identified set trace graphs dependency alphabet 
notion mso definability trace languages canonical 
hand nontrivial set model finite automaton works accordance idea dependency independency inherent definition traces alphabet 
zielonka suggested zie model asynchronous finite automaton 
idea decompose dependency alphabet possibly overlapping maximal cliques dependence relation clique called process 
example fa dg dependency relation generated pairs pairs form processes 
run asynchronous automaton trace fixed associating number states vertex vertex labelled state process letter belongs listed 
transition relation defines state assignments vertex possible account label state assignments occurrences vertices partial order processes involved 
deterministic asynchronous automata state assignment uniquely determined state assignments preceding vertices 
initial condition vertices respect final condition ones 
turns recognizability asynchronous automata matches algebraic definition recognizability provides robust natural notion cf 
dr 
fundamental result asynchronous automata states nondeterministic deterministic version expressively equivalent zie 
proof method theorem applied obtains result shown dr theorem set traces recognizable asynchronous automaton iff mso definable 
certain rational trace languages transcend class recognizable trace languages cg logical characterization extending mso logic formulas allow compare cardinalities sets 
trees situation somewhat easier referring theory finite tree automata see gs chapter tree languages handbook consider tree automata working bottom frontier root mode 
transition relation node merge information provided states assumed son nodes 
points information kept diverging branches may join may happen trace graphs 
definition tree automaton form delta finite delta theta theta theta transition allows proceed states successor nodes node state reading letter label run input tree built canonical way map ae dom initialized leaf labelled transition leads assignment ae 
run ae called successful ae ffl tree accepted successful run exists 
tree language recognized consists trees accepted classical subset construction works essential change tree automata form shows trees nondeterministic deterministic automaton model frontier root mode equivalent 
method theorem applied theorem thatcher wright tw don set finite trees recognizable finite tree automaton iff mso definable 
argument mso logic words finite trees mso logic equivalent expressive power logic 
proof theorem seemingly weaker quantifiers ranging arbitrary subsets tree domains suffice 
call antichain subset tree domain distinct nodes incomparable prefix relation 
belong common path 
antichain logic restriction monadic second order logic set quantifications range antichains 
note proper binary trees node successors leaf inner nodes mapped set leaves inner node follow path branches right branches left leaf reached 
set inner nodes coded set leaves antichain 
idea quantifiers subsets proper binary trees simulated quantifiers antichains proposition pt set proper trees unary branching recognizable finite tree automaton iff definable antichain logic 
similarly chain logic introduced allows set quantifiers ranging sets elements related partial prefix order 
shown th system strictly weaker mso logic 
theorem allows obtain decidability results tree theories theorem theories successor fragments arithmetic 
tw don weak monadic theory binary infinite tree shown decidable decidability emptiness problem tree automata 
dauchet tison dt applied tree automata spirit decidability proof presburger arithmetic discussed previous section 
ary relation finite trees label alphabet captured set trees alphabet possibly extended dummy label individual components tuples trees different domains handled 
analogy case word relations th components code th tree tuple 
relations trees considered dt finite tree rewriting system ground rewriting system relation collects tree pairs obtained application rule second relation contains pairs rewriting steps applied parallel third transitive closure order theory ground rewrite system defined set order sentences signature relations true domain trees relations determined explained 
inductively order formula language transformed tree automaton accepting tuples trees satisfy 
result obtained theorem dt order theory ground rewrite system decidable 
interesting issue research problem finding general domains graphs automata theoretic approach mso logic works 
attempts subject limitations instance regarding decidability results natural classes acyclic labelled graphs satisfiability formulas undecidable 
basic example class pictures dimensional words rectangular arrays labelled vertices connected successor relations horizontal vertical 
easy show halting problem turing machines reducible satisfiability formulas pictures turing machine write sentence describing pictures code halting computation starting empty tape 
picture say alphabet represents halting computation form dimensional space time diagram points visited belong picture 
existential quantifiers sets serve express appropriate assignment values picture points exists local conditions neighbour letters fixed turing machine instructions expressible order logic 
satisfiability domain pictures amounts existence halting computation starting empty tape satisfiability sentences pictures undecidable 
detailed discussion picture languages see gr 
class pictures facts fail familiar domain words trees 
logic turns strictly weaker mso logic pictures example set theta dimensional pictures composed identical square pictures mso definable definable cf 

closely related fact powerset construction fails canonical models finite automata pictures acyclic graphs see pst claim ks concerning applicability powerset construction corrected 
domain arbitrary finite graphs mso logic separated logic connectivity graph property definable logic cf 
fsv 
classes graphs classical technique connecting mso logic notions recognizability applied usually depends possibility describe graph properties terms certain tree properties 
example mention properties texts structure introduced er 
text word second ordering natural ordering letters 
alternatively text word permutation positions example form 
text built structured way combining parts form tree structure called shape 
pas showed hp natural algebraic notion recognizability definability mso logic coincide text languages tree representations involve trees bounded arity handled finite tree automata 
general framework definability graph properties implicitly involves terms trees unbounded arity developed courcelle cou 
construction graphs sorted graph algebra leads algebraic notion recognizability graph sets strictly expressive mso logic 
finitary framework mso logic tree automata exceeded admission infinitely sorts graph algebra feature necessary example definition picture languages 
characterization classes graphs share desirable properties classical theory decidable satisfiability problem validity problem mso formulas equivalence mso logic existential part logic mso logic finitestate acceptors 
interesting class question open graphs bounded tree width see cou see detailed treatment partial results complementary approaches 
general method construct sets graphs sets trees apply monadic second order interpretations 
interpretation describes relational structure say graph structure say tree providing defining formulas 
formula free variable defines copy domain formulas provided define relations relations part represents see applies interpretations graphs trees uses tree automata theory obtain decidability results upper time bounds computational graph problems 
cou related notion monadic second order graph transduction studied 
sets graphs generated different versions contextfree graph grammars shown presentable images recognizable tree languages mso definable graph transductions 
detailed exposition results applications survey cou 
order definability ehrenfeucht fraiss game limited expressive power finite automata mso logic words trees verified conveniently pumping lemmas related combinatorial arguments 
order logic situation involved 
versatile method show non definability systems order logic ehrenfeucht fraiss game applied characterizations classes order definable languages 
give main facts brief overview background eft ef 
sequel consider order language equality signature sig unary relation symbols binary relation symbols restriction unary binary relations inessential saves notation purposes 
letters indicate unary resp 
binary relation symbols 
structures signature sig form structure universe theta expand structure designated elements universe 
example tuple elements formula variables occur free indicates holds interpreting quantifier depth qd formulas maximal number nested quantifiers 
structures universes designated tuples elements respectively called equivalent written jm sig formulas quantifier depth case empty sequences means structures satisfy sentences formulas free variables quantifier depth ehrenfeucht fraiss game short ef game allows verify claim jm 
preparation need notion partial isomorphism 
sig structures universes indicate finite relation theta 
relation called partial isomorphism assignment 
determines injective partial function domain consists elements preserves relations consideration sense symbols sig domain describe play ef game 
game gm played players called spoiler duplicator suggested fsv structures 
rounds carried follows initial configuration relation 
configuration round composed moves spoiler picks element duplicator reacts choosing element structure choosing resp 
new configuration rounds duplicator won final configuration partial isomorphism spoiler won 
note happen intermediate configuration partial isomorphism 
duplicator aims partial isomorphism spoiler tries avoid 
say duplicator wins game gm duplicator strategy win play skip formal definition strategy 
example consider game word models including linear ordering letter positions 
duplicator looses game spoiler pick positions letters duplicator respond picking positions order preserve relations order positions preserved constructed correspondence partial isomorphism 
example consider game word models signature successor relation letter predicates 
duplicator winning strategy spoiler picks position position adjacent duplicator reacts accordingly word remaining cases spoiler picks position duplicator word 
easy check second move duplicator able respond building partial isomorphism respecting letter predicates successor relation 
duplicator wins game 
example consider word models labelled linear orderings successor relation identify word structure dom 
format word models assuming trivial alphabet fag duplicator wins game aaa round spoiler may pick position position non border position words duplicator reacts accordingly 
allows duplicator respond correctly order preserving second round 
consider rounds game round decompositions words form aa aa reached displayed letters representing positions chosen round 
remembering rounds game duplicator win similarly clearly duplicator reach decomposition round general rounds ahead duplicator needs ensure corresponding letter blocks delimited chosen positions length gamma length 
way sees duplicator wins gm gamma slightly generalized argument verifies duplicator wins gm word gamma 
verify general duplicator wins game gm 
simple approach specify set partial isomorphisms describing configurations duplicator allow win rounds ahead 
course 
belong partial isomorphisms sets extend 
way continue play configuration lead configuration gamma precisely nonempty sets partial isomorphisms extending 
properties hold ffl back property gamma ffl forth property gamma sequence properties exists write 
induction verifies condition holds iff duplicator wins gm 
fraiss showed relations jm coincide relational structures finite signature ehrenfeucht introduced game theoretical formulation theorem ehrenfeucht fraiss theorem jm iff iff duplicator wins gm proof 
second equivalence explained 
step equivalence jm equivalence easy induction converse sufficient describe class formula quantifier depth precisely structure formula quantifier depth holds precisely structures equivalent 
definition proceeds induction giving formalization equivalence partial isomorphism extension properties back forth atomic atomic justify definition case structure infinite observe due finite signature finitely atomic formulas involving variables verified induction number logically formulas finite length tuples 
disjunction conjunction definition range finitely formulas specify order formulas 
reconsider examples 
ehrenfeucht fraiss theorem says duplicator wins round game word models iff distinguished sentences quantifier depth recalling example concerning spoiler wins see sentence quantifier depth signature distinguishes 
hand seen second example theorem sentence quantifier depth successor relation numerical relation distinguish coming back example conclude proposition language fa order definable 
proof 
supposing defining order sentence exists eliminate successor relation terms obtain sentence say quantifier depth sentence satisfied example theorem jm satisfied word odd length gives contradiction 
general order definable language shares strong pumping property sufficiently large words alphabet consideration uv iff uv algebraic terms means syntactic monoid order definable language aperiodic 
locally threshold testable sets section determine expressive power order logic successor structures generally graphs bounded degree 
graph edge relation degree vertex vertices special cases binary tree models word models successor relation 
ef games show firstorder logic graphs bounded degree limited power express statements saying local neighbourhoods vertices appear graph counted fixed threshold neighbourhood may occur 
specify neighbourhoods say graph sphere radius induced subgraph vertices distance 
assume edges may traversed directions 
subgraph designated center denoted 
consider graphs degree finite number possible isomorphism types spheres 
isomorphism type oe spheres occ oe number occurrences spheres type oe show order formula equivalent graphs degree statement occurrence numbers finitely types oe 
formula values occ oe relevant certain threshold definition isomorphism type oe spheres radius numbers occ oe occ oe larger threshold number coincide 
set graphs locally threshold testable union equivalence classes finite union degrees graphs consideration bounded 
theorem states equivalence suitable fine capture equivalence indistinguishability formulas quantifier depth 
general formulations possible simplicity stay case graphs degree bounded theorem sphere theorem hnf graphs finite infinite degree jm proof 
theorem suffices ensure suitably chosen set delta maximal size sphere 
required sequence sets partial isomorphisms defined follows gammak 
gammak belong iff gammak gamma sph gammak gamma sph induced subgraphs formed spheres resp 
isomorphic 
verify forth property assume condition holds gamma gamma find gamma gamma gamma gamma gamma gamma sph gamma gamma gamma gamma sph delta may choose delta correspondingly note gamma contained gamma 
gamma gamma holds 
gamma say type oe disjoint gamma suffices find sphere type oe disjoint spheres gamma 
possible number occurrences spheres type oe large 
guaranteed view number spheres assumption consequence note result theorem order definable set graphs bounded degree locally threshold testable 
order logic words trees graphs bounded degree express local properties statements occurrences local neighbourhoods 
precisely order formula equivalent boolean combination statements sphere oe occurs times oe radius conditions fix class structure belongs 
statement sphere oe elements occurs times expressed sentence form gamma tuple variables formula states pairwise distinct centers spheres elements pairwise distinct building graph isomorphism type oe expressed conjunction atomic formulas negations hold elements form sphere type oe element distinct distance greater adjacent elements chosen distance 
written prenex normal form sentence sigma form 
corollary graphs bounded degree order sentence equivalent boolean combination sigma sentences 
strong reduction quantifier complexity formulas shows weakness order logic graphs 
domain words see language fo definable iff locally threshold testable th 
locally threshold testable word languages usually introduced slightly different equivalent way 
note prefixes suffixes words may specified spheres center predecessor respectively successor 
spheres replaced just word segments designated center usually done language theory prefixes suffixes treated separately word alphabet word oe number occ oe number occurrences oe number furthermore pref suf segment resp 
letters jwj 
define words segments oe length occ oe occ oe pref pref suf suf 
language called locally threshold testable union equivalence classes example consider language defined regular expression ba ca finds number ba ca ca ba accordance example ef games 
word belongs second locally threshold testable fo definable 
theorem applied obtain linear time bounds order expressible graph problems see 
furthermore yields new proof reduction logic finite automata formula defines projection order definable set theorem projection locally threshold testable set 
locally threshold testable languages recognized finite automata projections nondeterminism 
th approach considered graphs bounded degree taken starting point introduce finite state graph acceptors 
framework pictures rectangular arrays symbols horizontal vertical successor relation graph acceptors turn equivalent tiling systems cf 
gr 
star free languages language sigma called star free constructed finite languages applications boolean operations concatenation 
accordingly star free expressions alphabet built constants ffl denoting empty set singleton empty word set fag respectively means operations complement concatenation dot delta 
expression admitted abbreviation 
natural correspondence operations logical connectives easy transform star free expressions order formulas 
example fa cg expression delta delta delta delta delta defines language analysis order definability shows converse theorem mcnaughton papert mcnp language star free iff order definable signature 
proof 
translation order formulas star free expressions follow approach lad th pp applying ehrenfeucht fraiss technique 
proceed induction quantifier depth sketch induction step 
consider order formula quantifier depth simplicity assume implies shall reformulate disjunction normal formulas quantifier depth speak segments enclosed speaks segment excluding formula speaks segment enclosed speaks segment word 
formally ensured allowing relativized quantifiers quantifiers 
reduction disjunctions normal formulas induction easy induction step formula written disjunction normal formulas equivalent star free expressions exist induction hypothesis 
equivalent corresponding union expressions delta delta achieve reduction formulas disjunctions normal formulas facts equivalence word models verified ehrenfeucht fraiss game technique description jm class word model designated positions formula pn cf 
proof theorem secondly congruence lemma equivalence lemma jm jm delta delta jm delta delta proof 
ehrenfeucht fraiss theorem 
assumption tells duplicator winning strategies games gm gm 
obvious composition strategies segments strategy segments second strategy guarantees duplicator win game gm delta delta delta delta 
order formula quantifier depth assuming transformed normal formula follows 
definition equivalence jm class word models satisfy finite union jm classes described formula pn representative respective class 
equivalent disjunction formulas pn suffices express formula disjunction normal formulas 
lemma jm class fixed jm classes segments delimited positions letters associated collect conjunctions corresponding formulas conjunction describing sequence conjunctions imply pn 
altogether obtain formula equivalent disjunction conjunctions formulas 
disjunction normal formulas reached 
theorem starting point rich definability theory star free languages 
significance class star free languages supported schutzenberger fundamental characterization sch terms finite aperiodic monoids 
verified prop erty order definable languages proposition converse difficult relies nontrivial results concerning decomposition monoids see 
framework minimal deterministic automata property amounts lack words induce nontrivial permutation subset state space 
property decidable equivalently syntactic monoid regular language contains nontrivial group schutzenberger theorem theorem provides algorithm decide regular language order definable 
language classes characterized special types regular expressions restrictions variants order formulas structural properties automata corresponding properties syntactic monoids 
class locally threshold testable languages considered previous section example adaptations ehrenfeucht fraiss method usually applied fixing logical part characterizations 
field surveys books pin str 
list small selection results 
shall consider languages words fact difficult characterize order logic trees structural properties tree automata partial results direction see pot 
class star free languages hierarchy language classes built levels measure concatenation depth defining expressions 
fixing alphabet letters sets class consisting languages class boolean combinations languages delta delta delta delta levels hierarchy natural characterization terms quantifier prefixes order formulas 
appears numerical relation theorem cf 
pp star free language belongs class iff definable sigma sentence order logic 
level hierarchy gives class piecewise testable languages simon sim 
shown form strictly increasing hierarchy logical framework ef game may applied hierarchy proof th 
analogous results proved closely related dot depth hierarchy th th 
finer classification distinguishing formulas number quantifier alternations lengths quantifier blocks studied bs 
open problem theory question smallest star free language belongs computed effectively 
elementary examples languages order definable modular counting instances set words length language parity fa bg consisting words number occurrences cf 
proposition 
kinds extensions order logic considered obtain stronger frameworks expressive range mso logic languages definable adjunction stronger quantifiers similar operators general numerical relations successor order 
properties involve modular counting conveniently described modular quantifiers read exactly elements modulo 
stt shown languages definable extension order logic modular quantifiers syntactic monoid finite contains groups solvable 
consequence class properly included class regular languages membership regular language decidable 
certain properties concerning modular counting captured special numerical predicates particular unary predicates containing numbers word models positions congruent modulo predicates suggested mcnp successor order constitute regular numerical predicates 
set words length definable parity definable order logic regular numerical predicates 
extensions fo logic additional numerical relations closely connected circuit complexity classes 
mention fundamental theorems entrance fascinating developing theory language definable order logic arbitrary numerical relations iff belongs circuit complexity class ac defined family circuits bounded depth gates gates unbounded fan imm 
shown bcst intersection ac class regular languages contains precisely languages definable order logic regular numerical predicates 
reader consult book str proofs results intriguing open problems 
section discussed typical applications iss technique order definable formal languages confinement fo logic definition local properties theorems inability fo logic specify conditions modular counting proposition compatibility fo definability concatenation congruence lemma 
important application model theoretic games theory automata transition systems discuss notion bisimulation 
bisimulations viewed special families partial isomorphisms corresponding restricted type ef game 
game played tree structures arising transition systems play game required proceed downward trees consideration starting roots 
corresponding logics systems modal logic process logic equivalent fragments order logic 
overview subject see mil sti 
automata mso logic infinite words bu buchi showed mso logic words equivalent finite automata equipped natural acceptance conditions infinite words 
founded beautiful branch definability theory properties infinite sequences complementing earlier results descriptive set theory recursion theory 
section central logical aspects automata reviewed 
information chapter languages handbook surveys hr sta th tl 
automata acceptance condition automata finite words canonical possibilities defining acceptance infinite words 
acceptance condition restricts occurrences states run ae consideration 
usually refers states occur infinitely ae fixed acceptance component automaton 
definition finite automaton form delta acc finite state set input alphabet initial state transition relation delta theta theta acceptance component acc 
run input word ff ff ff ff sequence ae ae ae ae ae ff ae delta 
deterministic automata transition relation replaced transition function ffi theta run satisfy ae ffi ae ff 
introduce standard acceptance modes 
write quantifier exist infinitely consider set ae fq ae qg frequently acceptance conditions requirements ae called inventors ffl buchi condition bu ae set final states requiring final state occurs infinitely run ae 
ffl muller condition mul ae family final state sets requiring set states assumed infinitely run ae forms set ffl rabin condition pairs condition rab rab ae ae sequence omega accepting pairs requires states visited finitely ae excluded point onwards state final state visited infinitely 
ffl streett condition complemented pairs condition dual rabin condition st ae ae sequence omega pairs subsets represents fairness condition read state visited infinitely state visited infinitely 
automaton delta buchi acceptance condition called buchi automaton similarly speak muller automata delta rabin automata streett automata delta omega gamma respectively acceptance component 
language called buchi muller rabin streett recognizable consists words considered alphabet accepted buchi muller rabin streett automaton respectively 
useful compare acceptance conditions simple case 
example consider language fa cg consisting words ff satisfy condition occurs infinitely ff 
convenient option streett automaton defining states visited reading respectively 
acceptance component omega just contains pair fq fq 
corresponding muller automaton state graph acceptance component contains sets implication holds 
obtaining suitable rabin automaton note ff iff occurs infinitely ff occur finitely 
accepting pairs suffice state graph fq fq fq 
obtain suitable buchi automaton capture disjunction infinitely finitely nondeterminism introduce extra sink state 
reached letter transition 
exists back 
may set fq 
set final states 
exercise simulation shows example typical proposition nondeterministic buchi muller rabin recognize class languages 
proof 
buchi rabin streett automaton easily simulated muller automaton collecting acceptance component state sets lead acceptance automaton 
turn muller automaton acceptance component corresponding buchi automaton guesses advance set states visited infinitely guesses point input ff onwards states seen 
suffices check visited states fill set 
signalled buchi acceptance condition 
follows mcnaughton theorem see section deterministic automata obtained muller rabin streett acceptance 
complexity analysis transformations acceptance condition see saf saf kpb 
general framework acceptance conditions consider case mere occurrence states runs restricted infinite occurrence 
run ae considers set oc ae fq ae qg may form analogous expressions oc ae set states oc ae system state sets 
called staiger wagner acceptance introduced sw captures general case condition set visited states run determines input accepted 
classification execution sequence properties nonterminating programs case described term obligation property cf 
mp 
flexible framework obtained logical setting consider acceptance components boolean combinations formulas ae ae state sets automaton 
conditions mentioned formulated way 
natural classification leads classes mentioned atomic conditions negations boolean combinations resp 
second type atomic formula 
boolean combinations conditions ae characterize acceptance mode muller acceptance described boolean combinations conditions ae 
complete analysis expressiveness acceptance conditions transfer automata arbitrary storage types pushdown store staiger sta engelfriet eh 
connect buchi recognizable languages standard notion regular sets finite words 
suppose buchi automaton delta accepts word ff say run reaches final state revisits final state 
regular sets words allow pass resp 
word ff decomposed ff uv short ff delta 
delta difficult show form languages characterizes buchi recognizability language buchi recognizable iff finite union sets delta regular sets finite words 
speaks regular languages 
sequel focus buchi recognizable regular languages logical description 
key result due buchi bu states language buchi recognizable iff mso definable 
nontrivial step proof show closure class buchi recognizable sets complement 
original approach bu uses representation buchi recognizable sets form delta classes sufficiently fine congruence finite index applies combinatorial argument form ramsey theorem guarantee complement representation 
alternative proceed deterministic automata 
approach buchi acceptance condition employed 
example deterministic buchi automaton recognizes set words fa bg infinitely occurrences deterministic buchi automaton recognizes complement set 
turns deterministic muller automata equivalent expressive power nondeterministic buchi automata 
complementation result follows class languages recognized deterministic muller automata clearly closed complement 
automaton state set system final state sets proceed subsections give proof determinization theorem discuss logical applications 
determinization automata purpose section show key theorem theory finite automata theorem mcnaughton theorem mcn buchi automaton transformed effectively equivalent deterministic muller automaton 
shall follow safra proof saf intricate refinement classical subset construction determinization automata finite words 
outline main ideas preparations 
delta buchi automaton 
classical subset construction uses sets states call gamma macrostates states desired deterministic automaton macrostate declared final contains state starting fq subset automaton assume finite input word macrostate consisting states reachable acceptance word captured construction instance assume fqg reach prefix ff run continued input word continued reachable states 
success signalled macrostate run subset automaton macrostates infinite run input exists occurs infinitely 
safra construction thread macrostates split final states encountered 
different macrostates handled simultaneously organized tree structure called safra tree 
safra trees serve states deterministic automaton constructed 
root macrostate safra tree collects momentary reachable states automaton classical subset automaton 
splitting threads realized simple rule macrostate occurring safra tree final states say states fm introduce ff fmg new son macrostate precisely youngest son order sons 
proceed safra tree run apply usual subset construction macrostate wise macrostate safra tree including newly created son macrostates compute set states reachable respective macrostate input letter consideration 
note way union son macrostates initialized henceforth kept subset corresponding parent macrostate 
process merging macrostates construction lead trees unbounded size 
obtain finite bound size safra trees merge operations performed call horizontal vertical referring usual display trees 
horizontal merge causes deletion state macrostates older brother macrostate exists 
empty macrostates arising way deleted safra tree 
brother macrostates disjoint allowing jqj sons parent 
vertical merge need extra justification causes deletion sons macrostate descendants union son macrostates equals parent macrostate 
happens say breakpoint reached parent macrostate 
due vertical merge union brother macrostates safra trees proper subset associated parent macrostate height length longest path safra trees bounded jqj gamma 
analyze role breakpoints context subset construction 
assume input word start macrostate reach reading input macrostate contains nonempty subset continuing run starting son reach reading breakpoint reach set set clearly situation state reachable state intermediate visit 
suppose continue way indicated 
gamma obtains inductively reaches state passing times segments breakpoints son macrostates final states created just claim holds argument 
note interesting consequence suppose macrostate sequence obtained starting fq applying subset construction th breakpoint macrostate reached input respectively 
exists successful run word proof 
pick run passes times segments shown 
finite runs form tree finitely branching infinite 
application konig lemma yields infinite run infinitely visits infinite sequence breakpoints serve detect successful run 
seen method detect successful runs complete 
proof mcnaughton theorem 
buchi automaton delta desired muller automaton ffi defined follows set safra trees ordered trees labelled macrostates brother macrostates disjoint union proper subset respective parent macrostate 
allow macrostate safra tree may marked say 
indicate occurrence breakpoints 
formally distinguishes node safra tree named positive natural number label macrostate pair macrostate mark 
names deleted nodes may reused 
nodes safra trees consideration names set mg sufficient extra names handle interplay deletion creation nodes correctly sequence successive safra trees input node name appears tree say labelled macrostate respectively shall need thread states represents run considered input 
node names reused immediately deletion due horizontal merge new node created due visits final states runs confused 
keep names nodes stay take newly created node name occur previous safra tree necessary reservoir extra names 
initial state takes safra tree consisting just root macrostate fq safra tree input letter value ffi transition function ffi determined stages mentioned 
macrostate states add node youngest son labelled macrostate 
apply subset construction replace macrostate set fq deltag 
apply horizontal vertical merge explained marking parent macrostate sons deleted vertical merge 
set safra trees system final state sets node appears safra trees marked proof finished showing 


accepts word ff definition successful run safra trees node stays marked infinitely 
argument applied sequence macrostates labels indicated breakpoints shows run exists ff infinitely visits accepts ff 
conversely suppose accepts ff say run ae passes state infinitely 
consider safra tree run ff 
root macrostate safra tree run nonempty root macrostate th safra tree contains ae 
root marked infinitely call easy case accepts definition done 
occurrence mark root marks existed state reached point visited infinitely ae put son macrostate root 
point onwards states run ae appear macrostates son due horizontal merge operations get associated older brothers son 
shift older brother happen finite number times states ae associated fixed son root note deletion son vertical merge possible breakpoint root passed 
son marked done easy case 
proceed son occurs infinitely way root consequence occur infinitely macrostates fixed root 
continuing way easy case acceptance apply eventually height safra trees increase bound jqj gamma impossible 
accepts ff 
deterministic automaton resulting safra construction concisely refers rabin acceptance condition 
acceptance condition formulated requiring node name missing finitely occurs marked infinitely 
get deterministic rabin automaton accepting pairs contains safra trees node name contains safra trees node name marked 
proposition verify number safra tree nodes may bounded number states buchi automaton yields tight complexity bound determinization proposition safra construction converts buchi automaton states deterministic rabin automaton states accepting pairs 
proof 
suppose buchi automaton state set fq 
step verify inductively height safra trees number nodes safra tree bounded 
trivial height induction step observe sons root define safra trees lower height disjoint sets states 
induction hypothesis cardinality safra tree bounded sigma jq jqj proper subset 
consequently mentioned proof numbers sufficient node names safra trees constructed rabin automaton accepting pairs 
second step note state occurring safra tree belongs macrostates unique path prefix starting root node safra tree determined node associated dummy value occur furthermore parent function brother function function set nodes known 
functions associate node parent node older brother exists indicator presence absence respectively 
altogether safra tree described maps fq ng ng ng 
number combinations maps number possible safra trees bounded delta complexity bound optimal sense theorem cf 
saf conversion buchi automata states deterministic rabin automata states accepting pairs 
proof elegant unpublished example michel mic concerning complexity complementing nondeterministic buchi automata 
giving proof theorem 
theorem mic family languages recognized buchi automaton states buchi automaton recognizing complement 
states 
proof 
shall define alphabet consider complementation relative easy coding letter adapt construction fixed alphabet resulting language recognized buchi automaton number states linear complement buchi recognizable states 
language recognized buchi automaton transitions final state passed infinitely successful run easily shown ff iff cycle letter pairs letter pair occurs infinitely segment ff 
consequently word belong permutation 
buchi automaton accepts complement language consider distinct permutations accepts words ff fi choose successful runs ff fi suppose run ff automaton loops set states final state say run fi loops set states 
suffices show disjoint 
pairwise disjoint loops exist 
contradiction assume runs build new run reaches loops input segment traversed final state visited comes back loops input segment traversed comes back alternation run accepting infinitely visits corresponding input fl contains show cycle described characterization accepts word gives desired contradiction 
verify existence cycle consider entries permutations distinct 
appears appears claimed cycle occurring infinitely fl may chosen gamma gamma gamma gamma 
proof theorem 
assume conversion buchi automata deterministic rabin automata transforms buchi automata states deterministic rabin automata states accepting pairs 
consider deterministic rabin automata obtained way buchi automata recognizing languages shall convert deterministic rabin automaton say states accepting pairs kn nondeterministic buchi automaton recognizes complement states contradicting previous theorem 
automaton states form state sets indices 
component triple serves simulate test acceptance condition fails 
means streett condition holds infinitely visits finitely visits words infinitely visits imply infinitely visits nondeterminism guesses point finitely visited states run passed infinity point 
implemented switching states states 
collects component indices visits occur similarly component indices visits occur 
anytime holds components reset 
happens infinitely infinity point iff infinitely visits imply infinitely visits checked 
states claim proved 
applications safra determinization construction obtaining essentially optimal complexity bounds logics programs ej 
saf safra achieved transformation nondeterministic streett automata deterministic rabin automata asymptotic blow nondeterministic buchi automata precisely nondeterministic streett automaton states pairs acceptance component converted deterministic rabin automaton nh nh states nh pairs 
generalization safra construction asynchronous finite automata accepting infinite mazurkiewicz traces kms 
applications definability decision problems consequence mcnaughton theorem note equivalence buchi automata mso logic infinite words originally shown buchi deterministic automata 
theorem buchi theorem bu language buchi recognizable iff mso definable transformation buchi automata mso formulas conversely effective 
proof 
buchi automaton straightforward formulate acceptance input word formula proof theorem changed acceptance part conjunctive clause express infinitely final state occurs 
converse proof theorem easily copied mcnaughton theorem complementation step 
corollary bu theory mso sentences true structure decidable 
proof 
theorem mso sentence letter predicates effectively transformed input free buchi automaton true iff successful run 
decidable successful run exists iff state reachable initial state reachable nonempty path 
look closely formulas arise proof application mcnaughton theorem 
consider alphabet defining mso formula interpreted words alphabet 
theorem rewritten formula describes acceptance buchi automaton form formula boolean combination formulas constant convenience similarly boolean combinations indicated atomic formulas 
obtain formula terminology prefix normal forms sigma formula 
mcnaughton theorem yields additional reduction mso logic weak mso logic set quantifiers range finite sets 
simplicity apply mcnaughton theorem form yields buchi automaton described formula deterministic rabin automaton say list omega accepting pairs em fm 
resp 
consider usual finite automaton resp 
transition graph final state set resp 

write formula expresses word model ff prefix ff excluding accepted simply relativize quantifier occurring automata normal form segment 
formally replaces quantifier called bounded similarly obtain bounded result proposition mso formula equivalent words formula bounded proof 
suffices note introduced deterministic state graphs formulas speak run input word disjunction expresses accepts input word consideration 
quantifier complexity measured terms unbounded quantifiers result yields reduction sigma formulas arising buchi automata boolean combinations sigma formulas 
furthermore observe set quantifiers refer finite 
runs range finite sets 
corollary mso formula equivalent words weak mso formula 
proposition interpreted topological terms referring cantor topology space words alphabet see chapter languages handbook mos tl definitions 
recognition language nondeterministic buchi automaton shows projective recognition deterministic muller rabin automaton puts boolean closure second level borel hierarchy 
disjunctions proposition lead classification languages complexity formulas parameter connected structural properties deterministic muller automata 
theory initiated landweber lan continued staiger wagner sw culminated deep structure theory automata wagner wag 
wagner showed deterministic muller automata accepting fixed language share structural invariant refers chains strongly connected subsets transition graphs ordered set inclusion maximal number alternations accepting sets chain 
take simple example formula proposition describes deterministic buchi automaton means part formula corresponding muller automata systems final strongly connected state sets upward closed respect set inclusion strongly connected sets ae consequence theory rabin index regular language effectively computable minimal disjunction length proposition defines efficient procedures determine rabin index developed wy kpb 
proposition replace quantifiers formulas arise characterize staiger wagner recognizable languages 
beautiful result sw states membership regular language class decidable languages precisely sets complement recognized deterministic buchi automata 
variant formulas proposition obtained boolean combinations statements segments infinitely segments 
theory classical formal languages languages defined statements called locally threshold testable finitely locally threshold testable conditions second type excluded 
finite words finitely locally threshold testable languages coincide definable fo logic order logic successor 
wilke showed wil language finitely locally threshold testable iff locally threshold testable staiger wagner recognizable 
properties decidable bp sw may conclude decide effectively regular language definable fo logic 
buchi theorem refined extended ways 
example transfer words infinite mazurkiewicz traces achieved em 
sequel discuss little detail logical systems applied verification nonterminating finitestate programs propositional temporal logic monadic second order logic timed words 
propositional temporal logic ptl version order logic word models quantifiers positions time instances captured temporal operators 
obtains variable free notation reflecting fact quantified positions restricted 
standard operators eventually 
built inductively propositional variables application boolean connectives unary temporal operators binary operator propositional variables resulting formulas interpreted words alphabet give idea semantics ptl formulas consider example example property words defined condition letter component appears letter component letters second component occur formalized ptl formula 
general introduce semantics ptl formulas propositional variables concisely associating certain order formulas interpreted words position onwards 
detailed standard see em mp 
boolean connectives handled usual 
ptl formulas set ffl ffl ffl ffl 
say word ff satisfies ff language called ptl definable iff ptl formula propositional variables set contains precisely words satisfy 
definition ptl definable language order definable 
difficult technical result states converse true theorem kamp kam see ghr language ptl definable iff order definable signature 
despite practical advantage short formalizations interesting properties see example certain weakness temporal framework fact implicit quantifications unbounded infinity bounded quantification appearing operator 
hard formalize properties finite segments words finite prefixes 
remedy past operators word position point refer back prefix point 
analogy operators introduced introduce past operators previous allow express order properties prefixes easily 
temporal operators referring past speaks past formula mp 
past formulas possible put ptl formulas normal form proposition 
order framework analogue normal form holds th turns ptl formula written disjunction formulas fg gf past formulas 
mp applications representation finite state program verification studied 
classification ptl definable properties obtained cancelling certain temporal operators 
operator admitted instance stutter invariant languages definable words distinguished equal shrinking extending nonzero blocks identical letters 
interesting class languages arises cancelling operator ptl automata theoretic semigroup theoretic analysis restricted temporal logic rtl carried cpp 
infinite hierarchy nesting operators established ew providing characterizations restricted temporal logics structural properties corresponding automata 
unidirectional way character ptl operators infinity useful translation ptl formulas automata essentially automata way mode 
ptl direct construction possible general mso formulas general order formulas 
necessary follow inductive structure formula particular apply determinization negation step causes exponential blow time negation applied existential quantification 
ptl formulas build buchi automaton keeps track satisfaction subformulas formula simultaneously reading input word 
set subformulas formula called fischer ladner closure construction model truth values subformulas hintikka structure 
state space essentially set truth value vectors component refers specific subformula formula 
instance components referring complementary subformulas complementary values position run 
nondeterminism applied guess claims correctly subformula true obligations verified points run 
book keeping necessary means auxiliary truth value components added subformulas 
altogether result obtained theorem cf 
vw ptl formulas length translated effectively equivalent buchi automata states time consequently satisfiability problem ptl solvable exponential time 
powerful logics allow basic construction example extension ptl automaton operators increase expressive power capture full mso logic buchi automata 
complexity satisfiability ptl formulas pspace hard sc sense bound theorem optimal 
program verification result applied ptl model checking means check computation paths finite state program satisfy ptl formula 
automata theoretic terms checks language computation paths contained language defined 
translation achieved time polynomial size number states exponential length 
details applications practical verification tasks reader consult specific surveys monographs em mcm cgl kur em var 
practice verification nonterminating systems requires check complex computation properties simply correct order events states time expressible ptl mso logic 
specification program involves conditions admissible time intervals durations states 
large number logics automata models incorporate aspects timed automata alur dill ad 
overview field see ah 
underlying models timed words extending classical words 
timed word sequence letters states sequence strictly increasing non negative real numbers th number indicates lifetime th state 
framework natural extension buchi theorem wilke wil offers logic time bounds natural numbers expressible statements type time instance belonging set time interval greatest instance bounded 
order monadic second order quantifications allowed exception set variables statements type appear leading block existential set quantifiers 
wilke showed mso logic relative distance characterizes expressive power timed automata sense alur dill ad decidability emptiness problem automata implies satisfiability problem timed mso logic decidable 
automata mso logic infinite trees rabin showed rab correspondence automata lifted domain infinite words domain infinite trees 
consequence monadic second order theory successor functions turned decidable 
intricate proof main decidability powerful theory served starting point papers clarified relation logic automata obtained applications areas 
core rabin complementation theorem nondeterministic finite automata infinite trees 
parts section give fairly self contained proof follows game theoretical approach suggested buchi bu bu gurevich harrington gh uses ej mst mcn th zie 
section presents logical applications 
automata infinite trees shall consider finite tree automata working top infinite input trees 
transitions form allowing pass state node input tree label states successor nodes respectively 
way run built 
acceptance condition requirement state sequences paths run format automata 
different types acceptance conditions possible 
sequel shall start muller acceptance condition 
definition muller tree automaton form delta sequential muller automata delta theta theta theta transition relation 
run tree tree ae satisfying ae ffl ae ae ae delta run ae successful path aej path ae muller acceptance condition satisfied 
automaton accepts tree successful run tree language recognized set 
ft accepts tg 
acceptance conditions known automata buchi condition rabin condition streett condition introduced accordingly 
turns muller rabin streett tree automata expressive power 
approach acceptance conditions infinite trees studied bn requirement paths run successful replaced condition cardinality set successful paths instance infinite uncountable 
look simple examples show buchi tree automata strictly weaker muller tree automata 
example describe muller tree automaton recognizes set ft fa bg path carries infinitely bg muller tree automaton states serve guess path input tree signals seen seen 
nodes outside guessed path state assumed 
list transitions 
system final state sets consist sets fq fq fq buchi acceptance condition suffices specify fq final state set 
see complement recognizable muller tree automaton buchi tree automaton rab 
example tree language ft fa bg path carries finitely bg muller recognizable rabin recognizable buchi recognizable appropriate deterministic muller tree automaton states signal resp 
seen transitions 
system final state sets consists fq contradiction suppose recognized buchi tree automaton say states final state set consider input tree fa bg label exactly nodes label occurs left successor taken sequence right successors allowing left turns 
clearly belongs consider successful run ae final state visited infinitely path ae may pick ae similarly path infinitely visits occur may pick ae continuing way obtain visit nodes mn state repetition occur say nodes set 
construction finite path segment label occurs left turn 
form new input tree repeating finite path segment inclusive exclusive indefinitely copying subtrees roots path segment 
infinite path constructed segments label occurs infinitely automaton accepts successful run easily constructed ae coincidence states nodes contradicts assumption recognizes turn complementation problem automata infinite trees 
solution simplified considerably seemingly complicated acceptance condition rabin chain condition introduced mostowski mst mst called parity condition introduced independently emerson jutla ej 
idea fix final state sets listing states separately case uniform scheme global indexing states 
minimal index state set states determines set accepting 
definition rabin chain tree automaton parity tree automaton form delta omega gamma delta muller tree automata omega ae ae ae ae ae ae strictly increasing chain sets states run ae automaton successful path aej aej 
equivalently states gamma indexed gamma states set aej states accepting path iff minimal index states aej parity condition 
rabin chain tree automata easily converted muller tree automata rabin chain tree automaton acceptance component omega gamma fix system final state sets including sets satisfy rabin chain condition applied place aej 
converse true mst car 
give simple proof data structure buchi bu 
theorem muller tree automaton construct equivalent rabin chain tree automaton 
proof 
delta muller tree automaton assuming loss generality ng 
states desired rabin chain tree automaton permutations index ng 
data structure introduced buchi bu name order vector hit 
idea keep record states order visits appearance record lar gurevich harrington gh pointer position change record occurred hit position 
sequel indicate order vector hit form concisely permutation 
explain data structure example 
assume sequence states built looping state set 
start order vector state indicating run begins arbitrary say 
vector obtained shifting new momentary state right setting hit position previous vector state taken 
example obtain starting vectors clear case point onwards states visited remain positions order vector hit assume positions infinitely hit penultimate position states order listed onwards 
general verifies claim allows extract set infinitely visited states information provided order vectors hit positions sequence states ng corresponding sequence order vectors hit positions 
say jf iff sequence satisfies 
finitely hit 
gamma 
infinitely hit gamma order vector entries positions gamma form set motivates definition desired rabin chain tree automaton set order vectors hit indexing states hit amounts indexing final state sets cardinality supplies scale needed introducing rabin chain acceptance condition 
state set set order vectors ng hit position initial state 
delta transitions form put transition relation delta gamma gamma gamma gamma gamma obtained gamma shifting resp 
right position gamma position gamma 
rabin chain acceptance condition chain omega ae ae ae ae set order vectors hit order vectors hit entries position onwards form set hand union set order vectors hit entries position onwards form set may happen difference sets empty drop sets respectively ensure rabin chain proper 
easy check accepts trees determinacy complementation section show class rabin chain recognizable tree languages closed complement 
game theoretic view tree automata acceptance 
tree automaton delta omega gamma input tree associates infinite person game gamma played players named automaton pathfinder gh tree play game infinite sequence actions performed players alternation automaton picks transition delta serve start run root input tree pathfinder decides direction left right proceed son root automaton chooses transition node compatible transition input tree pathfinder reacts branching left right momentary node sequence transitions state sequence built path chosen pathfinder 
automaton wins play constructed state sequence satisfies acceptance condition pathfinder wins 
player automaton tries realize acceptance condition pathfinder tries avoid 
formally convenient describe play sequence game positions 
game position automaton act triple form tree node tree label state 
choice transition form game position pathfinder reached triple tree node tree label transition 
pathfinder choice direction re establish game position automaton consisting tree node corresponding tree label new state respectively induced transition chosen 
standard initial position play automaton position ffl ffl 
game gamma presentable infinite graph consisting game positions vertices edge connects position position admissible action transforms automaton pathfinder imagined move alternation token infinite graph edges building infinite play 
strategy position player automaton respectively pathfinder function finite path position automaton respectively pathfinder gives value position reachable edge 
winning strategy automaton respectively pathfinder strategy leads win play actions chosen adversary pathfinder respectively automaton 
successful run immediately yields winning strategy automaton gamma path suitable choice transitions fixed run 
conversely winning strategy automaton gamma clearly provides method build successful run reach game theoretic formulation tree automaton acceptance tree automaton accepts input tree iff game gamma winning strategy player automaton initial position ffl ffl 
complementation tree automata means express condition automaton accept acceptance automaton 
view means conclude nonexistence winning strategy automaton gamma existence winning strategy automaton different game gamma depends 
shall proceed steps show automaton winning strategy gamma pathfinder winning strategy standard initial position 
secondly pathfinder strategy converted automaton strategy 
step means prove games gamma determined player winning strategy position 
simple kind winning strategy suffice tree automaton accepts rabin chain condition assumed 
turn memoryless winning strategies 
function called memoryless strategy values depend positions finite initial plays arguments 
graph theoretic framework memoryless strategy say automaton simply subset game graph edge set exactly outgoing edge remains automaton positions 
mentioned step complementation tree automata result memoryless determinacy rabin chain games proved detail section 
theorem determinacy rabin chain tree automata games ej mst rabin chain tree automaton input tree gamma game position automaton pathfinder memoryless winning strategy 
apply theorem establish complementation rabin chain tree automata 
involve step pathfinder strategy automaton strategy 
theorem complementation rabin chain tree automata rabin chain tree automaton alphabet construct effectively muller tree automaton rabin chain tree automaton recognizes 
proof 
delta omega gamma rabin chain tree automaton 
find muller tree automaton accepting precisely trees accepted start equivalences tree accept iff automaton winning strategy initial position ffl ffl gamma iff theorem gamma pathfinder memoryless winning strategy ffl ffl 
reformulate form accepts tree automaton start observation pathfinder strategy function set theta theta delta game positions set directions 
decompose function family theta delta local instructions parametrized set possible local instructions theta delta finite pathfinder winning strategy coded labelled tree fw corresponding theta labelled tree equivalent labelled tree sequences transitions chosen automaton fact unique determined strategy coded generated state sequence violates rabin chain condition omega gamma reformulation yields labelled tree satisfies delta sequence sj local instructions applied sequence tree labels tj transition sequence produces path state sequence determined violates omega gamma condition describes property words theta theta delta theta obviously checked sequential muller automaton independently condition describes property words theta theta results universal quantification equivalently negation projection negation 
established closure properties muller recognizable languages checked sequential deterministic muller automaton condition defines property theta labelled trees checked deterministic muller tree automaton simulating path 
note determinism runs different paths theta labelled tree agree respective common prefix merged run applying nondeterminism muller tree automaton built checks condition guessing tree input tree working note construction depend tree consideration 
accepts precisely trees accept shown 
remains verify determinacy theorem 
refer setting countable game graphs terminology ideas gh mcn th zie 
players named automaton pathfinder 
definition game graph form disjoint countable sets vertices set case theta theta edge relation vertex set outgoing edges nonempty finite 
furthermore map called coloring finite set colors 
game pair win consisting game graph language win called winning set 
set intended set game positions turn player move 
play sequence fl fl fl 
player wins play fl associated word fl fl colors belongs win 
condition vertex outgoing edge serves avoid deadlocks plays 
notions strategy winning strategy defined 
recall memoryless strategy say player subset edge set leaves precisely edge vertex example rabin chain tree automaton delta omega gamma game gamma form take automaton player pathfinder player specify game graph follows set triples theta theta set triples theta theta delta 
fix edge relation natural way succeeding game positions match compatible define color triple resp 
state winning set collects state sequences satisfy omega gamma example input free rabin chain tree automaton delta omega gamma delta theta theta define simpler game gamma tree parameter game positions suppressed delta fix analogy previous example collecting edges delta 
coloring identity maps transition winning set consists state sequences satisfy omega gamma game graph finite speaks finite state game 
obtain player automaton winning strategy gamma position iff automaton admits successful run 
theorem memoryless determinacy rabin chain games game graph win winning set specified rabin chain condition referring chain omega ae ae ae ae ff win iff ff ff 
vertex player player memoryless winning strategy 
application result games gamma yields determinacy theorem desired complementation rabin chain tree automata 
turning proof study simple case win play vertex set suffices reach certain vertex just 
subset player attractor set attr set vertices player force visit vertex finitely steps 
suggestive terminology attractor sets traps due zielonka zie 
easy lemma shows form attractor set build memoryless strategy enforces visit state player definition player dual 
idea collect inductively vertices player force visit steps 
lemma attractor lemma game graph vertex set edge relation suppose define sequence fu fu attr memoryless strategy player enforce visit just obtained choosing vertex edge vertex exists construction 
finite attr computable corresponding strategy enforce visit 
illustrates situation 
vertices indicated circles vertices boxes 
arrows denote edges dashed arrows denote edges may 
trap attr clear player outside attr force transition attr inside attr 
complement set attr trap player edges go back gammai edge goes back complement set vertex outgoing edge back statement complement attractor set game graph defines induced subgraph game graph short complements attractor sets induce subgames 
proof determinacy theorem 
game graph win defined rabin chain condition chain omega ae ae ae ae 
claim proved induction number nonempty entries omega gamma entry exists player wins trivially 
assume switch role players remainder proof 
note smallest set chain omega gamma infinitely visits colored vertices short vertices cause win player way cause win player visiting states 
set vertices player memoryless winning strategy 
aim show vertex player memoryless winning strategy 
preparation merge different memoryless strategies different vertices single memoryless strategy applies uniformly vertices note memoryless strategy player representable graph eu eu theta eu just outgoing edge vertex invoking ordering set graphs eu constitute winning strategies player may index strategy graphs ordinal numbers 
desired uniform strategy defined union domains strategy graphs forming set vertex chosen edge determined unique strategy graph eu containing smallest ordinal index 
follow choice edges play moment index strategy stays equal decreases 
proper decrease ordinals possible finite number times ultimately relevant index stays constant fixed winning strategies applied guarantees player wins uniform strategy 
readers prefer application axiom choice orderings argument starts choosing strategy graph vertex set countable graphs indexed natural numbers uniform strategy may defined unique edge determined strategy graph containing minimal index 
referring uniform strategy see complement trap player defines subgame denoted short 
note definition attr applies 
assume vertices colored minimal set rabin chain 
induction hypothesis gives claim theorem easily 
form set attr collecting vertices subgame player force visit subgame 
complement defines subgame complement attractor set disjoint vertices induction hypothesis applied obtain partition vertices player resp 
player wins memoryless strategies 
vertices player wins player win relative original game contradicting fact disjoint vertex player memoryless strategy subgame strategies merged uniform strategy strategy player lifted yield memoryless winning strategy player vertices nw vertices attractor set memoryless attractor strategy force visit vertex applied 
vertex reached player sure continue edge back recall trap player 
possibilities player allowed stay moment onwards strategy supplied induction hypothesis suffices 
left infinitely player forces visits vertices infinitely mentioned memoryless attractor strategy causes player win 
determinacy result holds games winning set defined muller rabin streett condition 
cases winning strategy player needs general memory uniformly bounded finite size construction strategies involved 
strategy constructions gh developed yy muc kla 
kla essentially optimal complexity bounds complementation streett tree automata 
approach alternating tree automata developed muller schupp ms ms 
alternating automata generalization nondeterministic automata transitions defined expressions expressions nondeterministic automata 
self dual framework alternating automata complementation easy projection nontrivial step 
natural self dual calculus show complementation rabin tree automata developed arnold arn involves operators definition greatest fixed points powerset set tree nodes 
definitions winning strategies fixed point calculi ej wal 
fixed point expressions allow compact representations desired vertex sets player respectively player wins difficult read 
standard graph theoretic presentation style mcn owing lot zielonka zie 
exposition problem introducing memory settled advance th reduction muller tree automata rabin chain tree automata theorem expands state space order vectors appearance records may viewed supplying sufficient memory game graphs 
relative expanded game graphs simple construction memoryless strategies suffices 
game graph finite determinacy result sharpened effectiveness claim 
content buchi landweber theorem bl case rabin chain winning condition memoryless strategies classical muller condition finite memory strategies 
proof simple presence determinacy theorem 
theorem effective determinacy finite state games bl win game finite win rabin chain form preceding theorem 
sets vertices player respectively wins memoryless strategy exhaust vertex set effectively computable corresponding memoryless winning strategies specified subsets edge set 
proof 
theorem vertex belongs verify property vertex belong np course decidable vertex guesses subset edge set defines strategy player vertex precisely outgoing edge vertex keeps outgoing edges vertices contains edge source checks strategy graph player win 
means player starting choose edges allow reach repeatedly loop cycle violates winning condition win 
clearly tested polynomial time 
test detection corresponding winning strategies analogous players exchanged 
theorem complement property 
membership membership problem np gamma np 
open polynomial time algorithm exists 
question equivalent problem polynomial time model checking algorithm modal calculus ejs em 
possible avoid determinacy theorem construct sets corresponding winning strategies directly 
approach difficult original proof buchi landweber finite state games muller winning condition bl see tb 
rabin chain winning condition allows simpler construction induction size game graphs see mcn sect 
th 
theorem provides solution church problem chu asked automatic synthesis reactive finite state programs automaton specifications mso specifications invoking translation automata 
easy application theorem shows emptiness problem automata infinite trees decidable rabin chain acceptance condition 
preparation introduce notion regular tree alphabet definition tree called regular finitely generated generated deterministic finite automaton ffi equipped output function label tree node ffi output reading input equivalent definition terms input free deterministic tree automata acceptance condition 
idea capture inputs directions branchings tree automaton transitions 
finite word automaton derive deterministic tree automaton theta delta setting ffi ffl allowing transition delta iff ffi ffi clearly unique run generates component tree generated word automaton conversely input free tree automaton induces canonically word automaton generates regular tree 
theorem rabin basis theorem cf 
rab rabin chain tree automata emptiness problem 
decidable nonempty set 
contains regular tree generating automaton obtained effectively 
proof 
rabin chain tree automaton delta omega gamma proceed input guessing input free tree automaton theta fq theta delta omega nondeterministically generates input tree initial states transitions works appropriate definition delta omega 

iff successful run 
consider finite state game gamma associated example 
game theoretical formulation acceptance successful run iff gamma player automaton wins initial position 
holds checked effectively theorem yields decidability claim 
assume 
admits successful run 
gamma player automaton wins initial position theorem means memoryless strategy 
strategy induces deterministic tree automaton subautomaton state game position automaton transition exists move automaton continuation run 
deterministic tree automaton generates regular tree 
construction regular tree belongs tree language recognized theorem applied effective determinacy result 
rabin converse approach rab gave direct proof basis theorem tree automata rabin acceptance condition existence regular trees show finite state winning strategies exist games finite graphs see th 
ej see em proved non emptiness problem rabin tree automata states accepting pairs solvable time mn 
furthermore polynomial time reduction propositional satisfiability problem sat non emptiness problem rabin tree automata shows np complete 
applications decision problems mso logic complementation theorem tree automata central step connecting mso formulas tree automata 
consider monadic second order formulas interpreted structure binary tree th successor relation holds iff ui 
set sentences corresponding language successor relation symbols true form theory second order theory successors 
monadic secondorder formulas free set variables interpreted expanded structures 
explained section tree structure identified corresponding infinite tree node iff equivalence mso logic tree automata rests statement theorem formula monadic second order language signature construct effectively muller tree automaton accepts tree iff satisfies 
proof 
follow pattern theorem consider modified equivalent logic mso order quantifiers simulated second order quantifiers singletons 
induction formulas logic constructs corresponding tree automata 
case atomic formulas easy induction steps concerning nondeterminism 
complementation step clear theorem 
formalizing muller rabin streett acceptance condition tree automata mso logic tree automata mso formulas converted equivalent sigma formulas sequence existential set quantifiers expresses existence run condition run successful requires universal quantifier paths universal set quantifier followed order formula 
refined results tree language definability obtained restricted mso formulas considered 
example weak second order quantifiers admitted ranging finite sets tree nodes proper subclass mso definable tree languages class weakly definable tree languages obtained 
shown rabin rab tree languages sets complement recognizable buchi tree automata 
classification weak second order formulas quantifier alternation prenex normal form yields infinite hierarchy th 
hierarchy built classifying rabin recognizable tree languages number disjunction members rabin acceptance condition 
niwi nski proved hierarchy infinite sharpening considerably separation buchi rabin recognizability explained example 
detailed synopsis classification rabin recognizable tree languages refer reader concluding section tl 
connections fixed point logics constitute fascinating chapter definability theory developed arnold niwi nski 
turn decidability results monadic second order theories 
application theorem mso sentence yields input free tree automaton admits successful run iff true tree structure existence successful run decided effectively theorem 
obtain celebrated theorem rabin tree theorem rab theory decidable 
mathematical theories shown decidable interpretation examples rab 
particular decidability extends tree models arbitrary finite countable branching trees easily embedded binary tree 
type application decidability modal logics program logics models propositional kripke structures countable directed graphs vertices propositional models 
propositional model say propositional variables coded vector giving truth value assignment kripke structure induces unravelling valued tree embedding tree binary tree possible preserving prefix relation tree nodes 
reach node root root th successor th successor reaching th successor code node binary tree 
embedding described range set kripke structure propositional variables coded binary tree model assume formula propositional variables modal logic translated formula kripke structure satisfies iff corresponding tree model satisfies 
satisfiability formulas reducible question holds turn decidable rabin tree theorem 
modal temporal logics proved decidable line examples modal calculus computation tree logic ctl see th ej detailed explanation jw automata theoretic study modal calculus 
formula logic satisfiable binary tree model exists corresponding mso formula rabin basis theorem regular tree model guaranteed 
regular models originate finite graphs generating automata 
respective modal logic called finite model property 
tree automata applied obtain solution model checking problem branching time logics satisfaction model tested satisfiability see kg study 
process unravelling basis interesting generalization rabin tree theorem 
consider relational structure pm subsets binary relations 
restriction unary binary relations essential assumed notational convenience 
tree structure structure set nonempty sequences ffl iff ffl iff ffl iff 
unpublished stu shown decidability monadic second order theory structure transferred rabin tree theorem amounts case element structure clearly decidable monadic second order theory 
unravelling structure step state transition graph tree execution sequences construction provide information connecting successive tree levels binary relation theta need relation theta contains pairs 
relation definable presence additional unary predicate clone predicate defined fx mg unravelling structure related notion unravelling giving computation trees deterministic transition systems developed cou 
unpublished muchnik see sem cou general form wal shown translate sentence monadic second order language sentence language original structure iff 
yields powerful transfer theorem decidability theories theorem muchnik cf 
wal monadic second order theory decidable monadic second order theory different kind generalization rabin tree theorem concerned monadic second order theory infinite graphs regular modifications trees 
result direction proved muller schupp ms showed monadic second order theory context free graph decidable 
graphs obtained transition graphs pushdown automata vertex word qv delta state set pushdown alphabet 
binary tree arises special case pushdown automaton single state transitions allowing add top pushdown store content say initial configuration 
general classes graphs decidable monadic second order theory obtained courcelle cou 
discuss graphs considered specified concrete language theoretical description 
vertices represented words alphabet edges labelled letters alphabet graph edge set subset theta theta mentioned graphs formed stages notions recognizable graph right closure graph rational restriction graph definition graph set triples theta theta called recognizable finite union sets theta fbg theta regular right closure written obtained including edge uw vw belongs rational restriction graph vertices regular language obtained keeping vertices forming induced subgraph class contain graphs rational restrictions right closures recognizable graphs 
example transition graph pushdown automaton belongs choose alphabet union state set pushdown alphabet terminal alphabet finite transition table determines finite recognizable graph edge set contained delta theta theta delta transition graph right closure restricted vertices delta reachable designated initial configuration rules generating vertices form uw form prefix rewriting system regular canonical system sense buchi bu known generate regular language 
shows belongs shown graphs obtained full binary tree operations inverse rational substitution version rational restriction certain analogy generation context free languages dyck languages inverse morphisms intersection regular sets 
operations preserve decidability monadic secondorder theory 
rabin tree theorem holds theorem graph class rational restriction right closure recognizable graph decidable monadic second order theory 
possible include nonregular features graphs keep decidability monadic theory 
example shown elgot rabin er nonregular sets natural numbers set squares set powers set factorial numbers structure natural numbers successor expanded decidable monadic second order theory 
slight generalizations operations leading theorem produce graphs undecidable monadic second order theory example infinite grid edges 
theorems exhaust class infinite graphs monadic second order theory decidable 
acknowledgment colleagues friends esprit working group contributed helpful questions remarks 
special due niwi nski walukiewicz zielonka sending unpublished papers useful hints 
constructive comments arnold courcelle klarlund walukiewicz zielonka pre final version contributed lot improve text 
members theory group kiel efficient help support rozenberg encouragement write finish 
ad alur dill theory timed automata theor 
comput 
sci 

ah alur henzinger real time logics complexity expressiveness information computation 
ahu aho hopcroft ullman design analysis computer algorithms addison wesley reading mass 
arnold niwi nski fixed point characterization weak monadic logic definable sets trees tree automata languages nivat podelski eds elsevier science publishers amsterdam pp 

arn arnold finite transition systems masson paris prentice hall hemel 
arn arnold initial semantics calculus trees rabin complementation theorem theor 
comput 
sci 

bcst barrington compton th regular languages nc comput 
system sci 

ere hansel logic recognizable sets integers bull 
belg 
math 
soc 
simon 
bk basin klarlund hardware verification monadic second order logic computer aided verification wolper ed lecture notes computer science springer verlag berlin pp 

bl buchi landweber solving sequential conditions finite state strategies trans 
amer 
math 
soc 

bn niwi nski automata infinite trees counting constraints information computation 
bp 
pin factors words automata languages programming proc 
th icalp ausiello eds lecture notes computer science springer verlag berlin pp 

bs blanchet sadri logical characterizations dot depth hierarchy applications comput 
system sci 

bu buchi weak second order arithmetic finite automata math 
logik 
math 

bu buchi decision method restricted second order arithmetic proc 
int 
congr 
logic methodology philosophy science stanford univ press stanford pp 

bu buchi regular canonical systems arch 
math 
logik 
bu buchi determinacy eliminate quantifiers fundamentals computation theory karpinski ed lecture notes computer science springer verlag berlin pp 

bu buchi state strategies games ffioe symb 
logic 
car chain automata technology applications information processing vol 
simon eds ifip north holland amsterdam pp 

infinite transition graphs having decidable monadic theory automata languages programming proc 
icalp meyer auf der heide monien eds lecture notes computer science springer verlag berlin appear 
chu church logic arithmetic automata proc 
intern 
congr 
math 
almqvist uppsala pp 

cg logical definability rational trace languages math 
syst 
theory 
cgl clarke grumberg long verification tools finite state concurrent systems decade concurrency de bakker eds lecture notes computer science springer verlag berlin pp 

cpp cohen perrin pin expressive power temporal logic comput 
system sci 

cou courcelle monadic second order logic graphs recognizable sets finite graphs inform 
comput 

cou courcelle monadic second order theory graphs closing gap definability recognizability theor 
comput 
sci 

cou courcelle monadic second order definable graph transductions survey theor 
comput 
sci 

cou courcelle monadic second order theory graphs ix machines behaviours theor 
comput 
sci 

cou courcelle expression graph properties graph transformations monadic second order logic handbook graph transformations vol 
foundations rozenberg ed world scientific singapore 
dm partial commutation traces handbook formal language theory vol 
iii rozenberg salomaa eds springer verlag new york appear 
don tree acceptors applications comput 
system sci 

dr rozenberg eds book traces world scientific singapore 
dt dauchet tison theory ground rewrite systems decidable proc 
th ieee symp 
logic computer science pp 

ef ebbinghaus flum finite model theory springer verlag new york 
eft ebbinghaus flum thomas mathematical logic nd ed springer verlag new york 
eh engelfriet automata words theor 
comput 
sci 

ej emerson jutla complexity tree automata logics programs proc 
th ieee symp 
foundations computer science pp 

ej emerson jutla tree automata mu calculus determinacy proc 
nd ieee symp 
foundations computer science 
ejs emerson jutla sistla model checking fragments calculus computer aided verification courcoubetis ed lecture notes computer science springer verlag berlin pp 

elgot decision problems finite automata design related arithmetics trans 
amer 
math 
soc 

em emerson temporal modal logic handbook theoretical computer science vol 
leeuwen ed elsevier science publishers amsterdam pp 

em emerson automated temporal reasoning reactive systems logics concurrency structure versus automata moller birtwistle eds lecture notes computer science springer verlag berlin pp 

em logical definability infinite traces theor 
comput 
sci 

er elgot rabin decidability second order theory generalized successor symbolic logic 
er ehrenfeucht rozenberg structures functions texts theor 
comput 
sci 

ew th 
wilke hierarchy temporal logic proc 
th ieee symp 
logic computer science appear 
fag fagin generalized order spectra polynomial time recognizable sets complexity computation karp ed siam ams proceedings pp 

fs synchronized rational relations finite infinite words theor 
comput 
sci 

fsv fagin stockmeyer 
vardi monadic np vs monadic np information computation 
ghr gabbay hodkinson reynolds temporal logic vol 
clarendon press oxford 
gh gurevich harrington trees automata games proc 
th acm symp 
theory computing pp 

gr restivo dimensional languages handbook formal language theory vol 
iii rozenberg salomaa eds springer verlag new york appear 
restivo thomas monadic secondorder logic rectangular pictures recognizability tiling systems information computation 
gs tree automata akad budapest 
hnf model theoretic methods study elementary logic theory models addison henkin suppes eds northholland amsterdam pp 

hp pas mso definable text languages mathematical foundations computer science pr eds lecture notes computer science springer verlag berlin pp 

hr rozenberg infinitary languages basic theory applications concurrent systems current trends concurrency de bakker eds lecture notes computer science springerverlag berlin pp 

imm immerman languages capture complexity classes siam comput 

jw janin walukiewicz automata modal calculus related results math 

comput 
sci 
eds lecture notes computer science springer verlag berlin pp 

kam kamp tense logic theory linear order ph 
thesis univ california los angeles 
kg kupferman grumberg branching time temporal logic tree automata information computation 
kla klarlund progress measures immediate determinacy subset construction tree automata ann 
pure appl 
logic 
kms klarlund mukund buchi asynchronous automata foundations software technology theoretical computer science thiagarajan ed lecture notes computer science springer verlag berlin pp 

kpb krishnan puri brayton structural complexity automata stacs mayr puech eds lecture notes computer science springer verlag pp 

ks parallel way automata directed ordered acyclic graphs inform 
contr 

kur kurshan computer aided verification coordinating processes princeton university press princeton 
lad ladner application model theoretic games discrete linear orders finite automata information control 
lan landweber decision problems automata math 
systems theory 
lichtenstein pnueli zuck glory past logics programs parikh eds lecture notes computer science springer verlag berlin pp 

lst th 
schwentick th logics context free languages computer science logic tiuryn eds lecture notes computer science springer verlag berlin pp 

mcm mcmillan symbolic model checking kluwer dordrecht 
mcn mcnaughton testing generating infinite sequences finite automaton inform 
contr 

mcn mcnaughton infinite games played finite graphs ann 
pure appl 
logic 
mcnp mcnaughton papert counter free automata mit press cambridge mass 
mic michel complementation difficult automata infinite words manuscript cnet paris 
mil milner operational algebraic semantics concurrent processes handbook theoretical computer science leeuwen ed elsevier science publ amsterdam pp 

mos moschovakis descriptive set theory north holland amsterdam 
mp manna pnueli temporal logic reactive concurrent programs springer verlag berlin heidelberg new york 
ms muller schupp theory ends pushdown automata second order logic theor 
comput 
sci 

ms muller schupp alternating automata infinite trees theor comput 
sci 

ms muller schupp simulating alternating tree automata nondeterministic automata new results new proofs theorems rabin mcnaughton safra theor 
comput 
sci 

mst mostowski regular expressions infinite trees standard form automata ed computation theory lecture notes computer science springer verlag berlin pp 

mst mostowski games forbidden positions preprint gda nski 
mst mostowski hierarchies weak automata weak monadic formulas theor 
comput 
sci 

muc muchnik games infinite trees automata dead ends 
new proof decidability monadic second order theory successors bull 
eatcs russian version semiotics information 
mul muller infinite sequences finite machines proc 
th ieee symp 
switching circuit theory logical design pp 

mv presburger arithmetic recognizability natural numbers automata new proofs theorems ann 
pure appl 
logic 
niwi nski fixed points vs infinite generation proc 
rd ieee symp 
logic computer science pp 

niwi nski fixed points characterization infinite behaviour finite state systems theor 
comput 
sci 
appear 
perrin finite automata handbook theoretical computer science vol 
van ed elsevier science publishers amsterdam pp 

pin 
pin varieties formal languages plenum new york 
pp perrin 
pin order logic star free sets comput 
system sci 

pot order logic finite trees tapsoft mosses eds lecture notes computer science springer verlag berlin pp 

pst thomas nondeterminism versus determinism finite automata directed acyclic graphs bull 
belg 
math 
soc 
simon 
pt thomas regular tree languages unary symbols star free fundamentals computation theory ed lecture notes computer science springer verlag berlin pp 

rab rabin decidability second order theories automata infinite trees trans 
amer 
math 
soc 

rab rabin weakly definable relations special automata mathematical logic foundations set theory bar hillel ed northholland amsterdam pp 

rab rabin automata infinite objects church problem amer 
math 
soc providence ri 
saf safra complexity automata proc 
th ieee symp 
foundations computer science pp 

saf safra exponential determinization automata acceptance condition proc 
th acm symp 
theory computing pp 

sc sistla clarke complexity propositional linear time logics assoc 
comput 
mach 

sch schutzenberger finite monoids having trivial subgroups information control 
see interpretability tree automata simple way solve algorithmic problems graphs closely related trees tree automata languages nivat podelski eds elsevier science publishers pp 

see linear time computable problems order descriptions math 
struct 
comp 
sci 

sei quantifier hierarchies word relations computer science logic borger eds lecture notes computer science springer verlag berlin 
sem decidability monadic theories proc 
mfcs eds lecture notes computer science springer verlag berlin pp 

sim simon piecewise testable events proc 
nd gi conf springer lncs 
st streett propositional dynamic logic looping converse inform 
contr 

sta staiger research theory languages inf 
process 
cybern 
eik 
sta staiger languages handbook formal language theory vol 
rozenberg salomaa eds springer verlag new york appear 
sti stirling modal temporal logics processes logics concurrency structure versus automata moller birtwistle eds lecture notes computer science springer verlag berlin pp 

str finite automata formal logic circuit complexity birkhauser boston 
stu lattice model recursive original model manuscript hebrew univ jerusalem 
stt th thomas regular languages defined generalized quantifiers information computation 
sw staiger wagner und klassen 
kybernetik eik 
tb trakhtenbrot barzdin finite automata north holland amsterdam 
th thomas combinatorial approach theory automata information control 
th thomas classifying regular events symbolic logic comput 
syst 
sci 

th thomas hierarchy sets infinite trees theoretical computer science cremers kriegel eds lecture notes computer science springer verlag berlin pp 

th thomas application ehrenfeucht fraiss game formal language theory bull 
soc 
math 
france mem 

th thomas logical aspects study tree languages ninth coll 
trees algebra programming courcelle ed cambridge univ press pp 

th thomas concatenation game dot depth hierarchy computation theory logic borger ed lecture notes computer science springer verlag berlin pp 

th thomas automata infinite objects handbook theoretical computer science vol 
leeuwen ed elsevier science publishers amsterdam pp 

th thomas logics tilings automata automata languages programming leach eds lecture notes computer science springer verlag berlin pp 

th thomas synthesis strategies infinite games stacs mayr puech eds lecture notes computer science springer verlag berlin pp 

tl thomas logical specifications infinite computations decade concurrency de bakker eds lecture notes computer science springer verlag berlin pp 

tw thatcher wright generalized finite automata application decision problem second order logic math 
syst 
theory 
var vardi automata theoretic approach linear temporal logic logics concurrency structure versus automata moller birtwistle eds lecture notes computer science springer verlag berlin pp 

vw vardi wolper reasoning infinite computations information computation 
wag wagner regular sets inform 
contr 

wal walukiewicz monadic second order logic tree structures stacs puech reischuk eds lecture notes computer science springer verlag berlin pp 

wil th 
wilke locally threshold testable languages infinite words stacs finkel wagner eds lecture notes computer science springer verlag berlin pp 

wil th 
wilke specifying timed state sequences powerful decidable logics timed automata formal techniques real time fault tolerant systems langmaack eds lecture notes computer science springer verlag berlin pp 

wy th 
wilke yoo computing wadge degree lifschitz degree rabin index regular language infinite words polynomial time tapsoft mosses eds lecture notes computer science springer verlag berlin 
yy extension gurevich harrington restricted determinacy theorem criterion winning player explicit class winning strategies ann 
pure appl 
logic 
forgetful determinacy logic computation 
zie zielonka notes finite asynchronous automata rairo inform 
th eor 
appl 

zie zielonka infinite games finitely coloured graphs applications automata infinite trees rep labri univ de bordeaux appear theor 
comput 
sci 

