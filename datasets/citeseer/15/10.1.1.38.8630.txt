adept flex supporting dynamic changes workflows loosing control manfred reichert peter dadam university ulm dept databases information systems ulm germany email reichert dadam informatik uni ulm de 
today workflow management systems wfmss applicable secure safe manner business process bp supported structured need ad hoc deviations runtime 
bps static sense significantly limits applicability current workflow wf technology 
hand support dynamic deviations task sequences mean responsibility avoidance consistency problems run time errors completely shifted naive user 
formal foundation support dynamic structural changes running wf instances 
formal wf model adept define complete minimal set change operations adept flex support users modifying structure running wf maintaining structural correctness consistency 
correctness properties defined adept determine specific change applied wf instance 
properties violated change rejected correctness restored handling exceptions resulting change 
discuss basic issues respect management changes undoing temporary changes instance level 
started design implementation adept workflow adept workflow engine change facilities 
keywords workflow management exception handling dynamic change adaptive workflows 
process oriented workflow management systems wfmss georgakopoulos hsu leymann offer promising approach development business applications directly follow execution logic underlying business process bp 
separation application control structures implementation task programs contributes simplify speed application development enables run time system assist users coordinating scheduling tasks bp 
current process oriented wfmss applicable reliable secure manner bp supported structured need ad hoc deviations dynamic extensions run time see wainer ellis reichert dadam 
bps static sense significantly limits benefit applicability current workflow wf technology 
example consider bps clinical domain see reichert convenient cost effective capture possible task sequences advance 
reasons firstly wfs planning execution overlap dynamically evolving wf completely specified run time ad hoc wf secondly unplanned events exceptions frequently occur leading ad hoc deviations wfs 
exceptions cover cases requests deviate standard processes due external event case acute emergency failed tasks prerequisites medical intervention violated incomplete erroneous information task inputs outputs incomplete medical orders situations arise mismatches real processes organization computerized counterparts due incomplete faulty wf specifications due organizational changes strong miller meyer 
wf designers generally capable predict possible exceptions events capture design wf wfms sufficient knowledge handle situations 
user involvement required order resolve exceptions deal unplanned events 
resulting requirements far challenging faced standard transaction technology advanced transaction models sheth 
basic step flexibility effective efficient support ad hoc modifications extensions processes execution 
wfms provide functions adding deleting tasks task blocks changing predefined task sequences allowing users skip tasks finishing tasks conditions execution completely satisfied serialize tasks previously allowed run parallel 
ad hoc changes may concern single attributes wf object task 
examples reassignment accepted publication journal intelligent information systems special issue workflow process management 
task modification task deadline 
changes critical handle structural changes consider 

problem description allow users deviate task sequences wf run time edge sword 
hand captures natural freedom process participants bp deal exceptional situations unplanned events 
hand unrestricted changes structure long running program possibly midst execution difficult system behave predictable correct manner 
reason supporting dynamic wf changes mean responsibility avoidance consistency problems run time errors completely shifted naive user application programmer 
correctness consistency criteria required order enable run time system adequately assist users applying structural changes 
system guarantee consistency constraints ensured prior dynamic change ensured wf instance modified 
requires types structural dependencies tasks control data temporal dependencies taken consideration wf instance restructured 
changes deletion addition task may cause severe inconsistencies unintended lost updates run time errors program crashes due invocation task modules invalid missing parameters changes consider state wf instance 
example possible delete task change attributes completed 
convenient rules appear restrictive users defined order avoid improper uncontrolled change operations 
security reasons possible restrict change operations selected users respectively user roles specific wf types regions wf graph single task certain states wf combination 
normally instances specific wf type active time 
changes different kinds may applied instances execution issues addressed 
wf instances type starting schema may represented different execution graphs 
secondly run time system manage changes different nature concerning durability 
especially important long running processes applied changes may permanent temporary 
permanent changes preserved completion process 
contrast temporary changes may undone control wf passed back previous point control new iteration loop entered 
consequently technical challenge represent manage different types changes undo temporary changes correct manner 
requires sophisticated mechanisms change management close integration change operations core services wfms 
changes fly loss run time performance disturbing process participants actively involved change 
summary dynamic structural changes represent serious interventions control wf handled extensive system support 
providing support dynamic wf changes process administrator form process participants crucial facilities manageable usable proper secure manner 

contribution formal foundation support dynamic changes running wf instances 
concentrate structural changes respective modification operations 
implementation issues concerning transactional execution changes outside scope 
fundamental approach conceptual graph wf model adept formal foundation syntax operational semantics 
model develop complete minimal set change operations support users modifying structure running wf instances preserving correctness consistency adept flex 
change leads violation correctness properties rejected correctness wf graph concerning flow data restored handling exceptions resulting change possibly leading concomitant changes 
furthermore show temporary permanent structural changes wf instances managed precautions taken enable run time system undo temporary changes case backward operations 
contribution demonstrating principle feasibility approach giving insights fundamental research issues related dynamic wf changes 
includes results demonstrate suitability wf model wf specification support dynamic structural changes show complex dynamic structural changes applied wf instance execution precautions secure correct manner discuss technical challenges possible solutions concerning management temporary permanent changes point prototype running supports basic concepts change operations 
remainder concentrate ad hoc structural changes applied individual wf instances 
explicitly consider changes schema level propagation wfs execution started old schema see casati ellis :10.1.1.45.6317
concepts applied type change 
section gives overview adept wf model 
section complete minimal set change operations modify structure wf execution 
section addresses issues concerning management changes undoing case backward operations 
section discusses related 
conclude summary overview related issues addressed outlook section 
fundamentals adept workflow model variety wf description languages discussed literature 
formal models high level petri nets ellis nutt ellis leymann state weikum temporal logic manna pnueli attie process algebra hennessy 
strength formal approaches lies offered mechanisms specifying analyzing verifying properties static wf structures regarding state transitions deadlocks reachability states 
adequate mechanisms modifying structures run time missing part cf 
ellis 
support dynamic wf changes formal model 
reasons believe generalpurpose models mentioned build right basis 
firstly generality analysis complex wf models extremely costly cf 
hofstede may cause significant overhead complex structural changes necessary run time 
secondly effective support users possibly non computer experts performing dynamic changes wf model allow intuitive structured representation bp hard achieve models 
adept model section follows structured approach 
essential specification execution wfs concept symmetrical control structures known structured programming cf 
task sequences branchings different split join semantics loop backs specified symmetrical blocks defined start nodes 
blocks may arbitrarily nested allowed overlap nesting regular 
addition adept provides support synchronization tasks parallel branches wf graph 
detailed description adept model scope 
restrict considerations basic concepts provided specification control data flow wf 
important aspects modeling temporal organizational aspects mechanisms dynamic adaptation described grimm kirsch 

workflow modeling section informally introduce basic modeling concepts offered adept 
wf schema comprises set tasks control data dependencies 
restrict considerations simple tasks activities divided execution requested external necessarily human agents 
flow control represent control flow wf directed structured graph 
tasks abstracted set nodes different types nt control dependencies set directed edges different types 
nodes edges meet restrictions describe 
wf schema unique start node nt unique node nt 
start node predecessor node successor 
nodes preceded succeeded node 
sequential execution tasks modeled connecting control edge control 
modeling branches depicted fig 

branches start split node synchronized symmetrically unique join node 
adept supports types branching parallel processing split join conditional routing split join parallel branching final selection split join 
routing decision conditional branching see fig 
may value users 
case successors split node triggered fires 
soon tasks selected execution items removed corresponding worklists 
allows model situations tasks activated may executed 
split node parallel branching final selection see fig 
fires successor branches triggered may worked concurrently 
contrast parallel processing flow may proceed join node soon branches completed 
depending current state tasks branches removed corresponding worklists aborted undone 
undoing branch necessarily lead execution compensation tasks 
case corresponding tasks reset state see section effects data elements wf see undone 
important extension branch may completed 
case winner selected authorized user flow proceed 
considered non cyclic wf graphs 
adept repetitive execution set tasks modeled loops 
branching loop corresponds symmetrical block unique start node nt unique node nt endloop connected loop edge loop 
addition node associated loop condition evaluated time node triggered 
see section loops raises challenging issues connection dynamic changes 
inserting new task loop body instance clear insertion valid current iteration loop iterations 
take provisions task failures modeling level adept provides second type backward edge failure edge failure connects task failure preceding node restart 
run time edge signals execution task failure fails 
consequence nodes succeeding restart incl 
restart preceding failure incl 
failure reset state 
contrast loop iteration effects corresponding tasks data elements wf instance see undone 
flow proceeds execution restart note symmetrical structuring regular nesting apply failure edges task may outgoing failure edges possibly linking nodes different branches preceding parallel branching 
restriction added node restart contained loop body branch join body branch contain node failure failure edges possible connection control structures support dynamic rollback wfs 
generally state wf reset arbitrary previous state 
expressive power control structures far sufficient modeling wfs long running concurrent executions 
support synchronizations tasks different branches parallel processing types synchronization edges sync edges supported soft synchronization soft sync specify delay dependency tasks may executed completed triggered anymore 
type synchronization necessarily require successful completion hand strict synchronization strict sync requires successfully completed allowed start 
strict synchronization may synchronize tasks conditional branching tasks parallel branching final selection 
sync edges meet certain constraints order avoid redundant control dependencies tasks cycles termination problems wf 
case nodes different branches parallel processing join may synchronized sync edges 
furthermore sync edge may connect node inside loop body node contained 
parallel processing conditional branching parallel branching final selection 
example 
fig 
shows example soft synchronization task triggered completed completed skipped corresponding branch selected execution 
flow data input output data tasks flow data important functional aspect wfms 
modeling data flow exchange structured data tasks wf poorly supported today wfmss sheth 
leaves significant complexity application developers impossible provide system support verifying correctness data flow schema adjusting structural changes applied wf 
model exchange data tasks global wf variables wf schema associated set data elements element unique identifier id domain dom data flow tasks defined connecting parameters elements simplification input output parameters wf schema logically treated output input parameters start node 
practice great differences format representation data output task input 
order avoid hard wired adjustments task modules task node associated set called auxiliary services execution services closely connected execution task 
auxiliary service prec succ triggered started prec terminated succ appear separate item worklist 
services set prec may request incomplete missing input data task user initiating turned important context see section 
furthermore task respectively application program associated may executed services prec successfully completed 
hand task fails undone effects associated services global data elements undone 
definition data flow schema 
control flow graph wf schema denote finite set data elements associated pars denote set parameters associated task respectively service pars 
data link df parameter par df data element df described tuple df df df par df access mode df df df par df pars df access mode df read write set data links df connecting task service parameters global data elements called data flow schema data links connecting service parameters data elements form key part data flow schema 
intuitive meaning link read df value read task started 
hand data link write expresses value output parameter written successful completion section introduce properties correctness data flow schema properties constitute basis detecting possible exceptions resulting change adjusting data flow schema wf restructured 
respect data management follow approach similar described reuter 
task service updates data element current value overwritten 
new version created may accessed succeeding tasks services 
allows restore previous values data elements case partial rollback possible tasks different branches parallel processing join different copies data element nt nt nt node type edge type loop condition soft sync nt nt endloop loop 
example simple wf model 
example 
example simple data flow schema depicted fig 

note output parameter input parameter start node node corresponds input parameter output parameter wf 
assume read access data element task may write started value visible may access value written start node flow 
generally task may read values data element written task service preceding flow control 
summary wf schema described tuple df finite non empty sets tasks directed edges 
denotes set services preceding succeeding execution tasks 
denotes set data elements df defines set data links connecting task service parameters elements 
workflow execution state wf instance major criteria deciding specific structural change applied 
example consider deletion task allowed task completed 
furthermore applying structural changes wf graph concomitant changes states nodes edges may necessary order proceed flow control 
state newly inserted task instance may changed depending states predecessors 
adept defined operational semantics support 
state wf instance defined current marking nodes edges values stored data elements possibly different versions execution history 
state single task described current marking ns node ns activated activated running completed failed skipped total number previous executions relevant data 
edge wf execution graph states es signaled false signaled true signaled 
wf instance created graph starting schema df initialized 
state nodes set activated edges marked signaled 
furthermore wf input data stored corresponding data elements 
wf started start node graph marked completed outgoing control edge set true signaled 
time edge arbitrary type marked state destination node reevaluated execution rules defined adept 
executions rules describe conditions node may activated routed corresponding worklists 
node corresponds join instance set state activated conditions met marked activated ingoing control edges control marked true signaled 
furthermore sync edges strict sync marked true signaled sync edges soft sync marked true signaled false signaled see section 
corresponding execution rules exist node types wf incl 
start nodes loops 
completion task leads signaling outgoing control outgoing sync edges 
marking edges follows defined signaling rules operational semantics different control structures 
successful completion split node example outgoing edges set true signaled 
turn may trigger activation succeeding tasks 
hand task skipped activated anymore 
case example task belongs branch conditional branching chosen execution ingoing sync edge task strict sync marked false signaled 
task node marked par data element data link soft sync nt nt nt node type edge type input 
df par write par read par write par write par write par write par read par read par par par par par par par 
example simple data flow schema 
skipped outgoing edges set false signaled may lead skipping succeeding nodes 
wf instance terminates successfully ingoing control edge node set true signaled 
omit details examples 
example 
fig 
shows execution signaling rules connection loop 
completed loop condition evaluated true loop edge set true signaled see fig 

turn triggers execution start node loop states nodes edges loop body incl 
loop node loop edge reset activated see fig 

ns activated es true signaled ns completed es false signaled loop condition nt nt endloop loop nt node type edge type loop condition 
application execution signaling rules connection loop 
example 
second example consider fig 

assume receiving node termination event outgoing control edge signals true edge signals false 
turn leads reevaluation nodes activated respectively skipped 
skipping outgoing control outgoing sync edges set false signaled 
consequently state reevaluated set activated see fig 


correctness consistency properties motivated section formal criteria needed identify possible exceptions resulting structural wf change provide support handling 
section give overview correctness properties defined adept 
focus flow data 
properties regarding correctness control flow sketched section 
flow control control flow graph meet certain constraints order ensure correct execution wf run time 
node reachable wf start node 
valid sequence signaling events leading initial marking wf graph activation see section 
furthermore require reachable state wf final state reached valid es true signaled es false signaled ns completed ns skipped ns activated edge type soft sync ns running 
synchronizing nodes different branches parallel processing 
sequence signaling events leading current marking wf graph activation node 
non cyclic wf graphs task sequences symmetrical branchings properties satisfied construction 
apply wf graph control structures contain backward sync edges 
example sync edges lead cycles termination problems flow 
presentation conditions graph satisfies properties algorithms analysis outside scope 
flow data simplistically assume correct execution action task program respectively auxiliary service assigned task input parameters supplied successful completion output parameters written 
adept imposes set restrictions govern nature correct data flow schema 
data link df df cf 
definition domains df par df type compatible 
addition parameter action appear exactly data link df df 
order avoid invocation actions missing incomplete input data constraint added rule df 
df schema wf 
denote set valid action sets incl 
tasks services elements precede flow control completed started 
require reads writes predicate reads respectively writes expresses input parameter respectively output parameter connected data link df df 
rule ensures input parameters action supplied may executed 
trivially task nt reads data element rule df satisfied written start node wf written preceding auxiliary service prec furthermore rule guarantees output parameters wf input parameters node completely supplied 
order avoid unintended lost updates data elements second constraint describe informally 
details interested reader refered appendix rule df 
tasks different branches parallel processing join allowed write access data element synchronized sync edge 
write write conflicts occur succeeding tasks write access data element read access occurs see appendix 
algorithm checking correctness data flow schema respect rules df df 
algorithm symmetrical structuring wf graphs considers synchronizations tasks parallel branches 
basic understanding example suitable 
example 
wf graph depicted fig 
may read data elements allowed read written task sets 
task may read data elements written task sets cf 
rule df 
allowed write data element may written concurrent task cf 
rule df 
course constraints definitions rules df df relaxed respects 
current implementation follow flexible approach distinguishes optional mandatory task parameters 
extensions important input parameters task necessarily required correct processing task program 
distinguish parameters supplied corresponding auxiliary service 
enrich interface descriptions semantic information parameters provide support referenced data documents database objects 
concurrent write operations data element allowed certain conditions connection data elements type set list 
simplification omit extensions remainder 
note structural changes wf may violate rules precautions 
deletion task instance accompanied deletion data links connecting output parameters elements turn may lead missing parameter data succeeding steps violation rule df 
hand dynamic insertion task addition new data links connecting output parameters elements may lead lost updates violation rule df 
come back section 

adequacy adept model glance adept model somewhat limited compared wf models 
structural limitations offer advantages respects symmetrical control structures provides basis syntax driven design wf cf 
kirsch efficient analysis structural properties bp model cf 

believe crucial support dynamic wf changes especially want ensure applied changes correct 
experience adept offers compromise trade existing expressive power wf model hand complexity model checking hand 
respect clinical bps nature processes probably complex bps application areas proven modeling power adept adequate 
note specification complex bps sync edges failure edges null tasks cf 
section helpful 
addition working extensions adept wf model regarding concepts support time time dependencies increase modeling power 

dynamic structural changes workflows adept model developed set operations adept flex serves framework dynamic structural changes wfs 
main emphasis designing operations put correctness consistency issues application change operation specific wf instance result wf syntactically correct schema legal state change cause inconsistencies run time errors 
furthermore set change operations complete minimal sense able realize possible form correct consistent restructuring wf graph minimal mean number change operations needed achieve completeness kept minimal possible 
design goals discuss detail concern efficiency security issues ease 
summary adept flex comprises operations inserting tasks task blocks wf graph deleting fast forwarding progress wf skipping tasks jumping currently inactive parts wf graph serializing tasks previously allowed run parallel vice versa dynamic iteration dynamic rollback wf respectively wf region incl 
undoing temporary changes 
operations turn provide basis implementing higher level operations replacement certain wf region new 
insert operation shall serve illustrative example discussed detail section 
operations sketched section 

dynamic insertion tasks addition new task wf execution may necessary due reasons 
support dynamically evolving wfs unplanned events missing incomplete data name examples 
dynamic addition task wf somewhat comparable addition new procedure program midst execution 
task inserted wf graph new nodes edges including data links added maintaining correctness consistency wf 
current state art systems provide sufficient level flexibility consistency respect operation 
typically allow addition activity completion task activation successors hsu casati vogel :10.1.1.45.6317
issues concerning data integrity ignored leading problems mentioned section 
flexible support bps generic approach required 
generally possible add new tasks task blocks wf point time execution synchronize execution inserted task execution tasks wf graph insert tasks wf regions entered dynamically map parameters added task existing newly generated data elements problem provide operation inserting new task direct predecessor successor node adding task new branch split node corresponding join node 
yield satisfactory solution reconcile design goals minimality ease 
supporting dynamic addition tasks raises challenge find single generic operation complete sense able realize possible form insertion 
obviously addition task direct successor task weak meet requirements 
follow generic approach new task associated services data elements data links df may inserted graph wf instance synchronizing execution node sets execution triggered soon tasks set completed worked anymore tasks defined delay execution allows synchronize preceding tasks different branches wf graph 
hand tasks may activated completing addition new task transforms schema df state ns es wf new schema df new state ns es see fig 

graph transformation result wf syntactically correct schema incl 
flow data legal state 
order ensure constraints regarding definition sets df structure state wf 
discuss detail sketch steps necessary inserting new task wf graph 
concentrate restructuring control flow 
discuss relevant issues regarding adjustment data flow 
graph substitution syntactical correct control flow graph wf instance 
steps carried order insert new task node sets 
find minimal closed subgraph contains nodes denote start node denote node 
insert split node direct predecessor node insert corresponding join node direct successor node supposed null tasks nt null task nodes associated actions 
embedding node wf graph takes input output firing behavior ingoing outgoing control edges node 

insert new node representing branch nodes synchronize tasks add sync edge add sync edge soft sync 
apply reduction rules reevaluate state nodes edges see mentioned application steps lead syntactically correct wf graph 
ensure constraints firstly node precede flow control 
secondly region covered nodes incl 
nodes sets may contain complete loop control structures 
avoid insertion unnecessary synchronization edges nodes respectively succeed flow control 
show insertion new task violate syntactical correctness graph lead termination problems conditions satisfied 
details interested reader refered appendix omit example 
example 
example depicted fig 
shows task inserted sets nodes 
minimal block contains nodes set determined see fig 

step split node representing null task inserted predecessor start node block 
way corresponding join node added 
inserted new branch df insert sx dx dfx ns running process instance inserting process instance inserting df ns es ns es example insert insert par read 
dynamic insertion new task associated auxiliary services sx data elements dx data links dfx task sets synchronized nodes adding soft sync edges see fig 

easily see symmetrical structuring wf graph preserved insertion sync edges influence termination behavior wf cf 
section 
example shows null tasks sync edges added wf graph necessarily required achieve desired execution semantics 
nodes edges may removed resulting graph applying set defined reduction rules 
examples rules depicted fig 

reduction rules may applied null tasks originating insertion task direct successors predecessors 
application change wf execution behavior set valid task sequences remains unchanged 
effect application wf fig 
shown fig 


find lock containing insert 
apply reduction rules 
insert block 
insert synchronize soft sync nt null 
insertion new task sets nodes 
reduction rule nt null soft sync reduction rule reduction rule nt null reduction rule nt null reduction rule nt null reduction rule nt null nt null 
examples reduction rules 
state constraints applicability insert operation depends state wf graph 
order avoid insertion new task predecessor running terminated task require elements states activated activated 
task activated routed worklists corresponding items removed worklists insertion takes place 
nodes may arbitrary state 
adding new nodes edges wf graph state reevaluated 
reevaluation execution signaling rules section 
newly inserted task activated immediately depends current state wf graph 
case insertion time nodes final state completed skipped 
note insertion new task necessarily mean activated sure 
task inserted region wf graph entered execution may depend routing decisions 
example 
simple example consider graph shown fig 
assume new task shall inserted split corresponding join graph substitution steps applying reduction rule cf 
fig 
reevaluating wf state expected result obtained see fig 

note possible add new branch successors split nodes completed respectively started 
furthermore looking wf graph fig 
new task may inserted nodes order insert new task execution aborted user 
adjusting data flow schema mentioned new task may plugged wf graph associated data elements auxiliary services data links df task added wf schema df lead modification control flow graph state generally requires extensions sets df 
case ensured resulting wf schema df meets correctness properties defined section 
input parameters newly inserted task supplied may executed cf 
rule df 
simple approach achieve request necessary input data user initiating connected preceding provider service see section output parameters logically correspond input parameters 
current prototype implementation service supported dynamic generation dynamic processing electronic form interface description procedure depicted table shows sets df adapted order obtain syntactically correct data flow schema satisfying rule df 
obviously original wf schema df satisfies rule df applies schema df df df df practice simple approach yield satisfactory solution unnecessary redundant data entries may result course wf execution potentially leading data inconsistencies 
intelligent support possible dynamically map parameters inserted task existing data 
find minimal block containing 
insert block 
insert new branch synchronize 
apply reduction rule reevaluate workflow state es true signaled es false signaled insert ns activated ns completed ns skipped ns running 
adding new task split corresponding join elements raises variety challenging issues respect dynamic parameter mapping sketched 
data elements input parameters may potentially mapped identified 
rule df cf 
section obtain writes 
example 
example consider wf graph depicted fig 

assume task inserted nodes obtain 
note definition set independent state wf 
ensures data elements supplied activated independently previously routing decisions 
hand scenarios useful relax assumption consider state wf extend set data elements input parameters may linked pred ns completed writes example 
example take insertion shown fig 
assume task writes data element completed time added input parameters may potentially mapped data element contained set see fig 

approach necessary undo insertion case backward operation 
see section context big difference executed temporary insertion insertion valid completion wf permanent insertion 
set respectively describes data elements may considered input parameters mapped elements specific input parameter may linked data element respectively domains correspond 
course purely syntactical approach insufficient practice leave significant complexity user 
sophisticated approach aims semi automatic mapping parameters data elements 
basic controlled vocabulary naming data elements task parameters respectively data structures built 
vocabulary organized semantic network considers semantic relationships concepts data elements parameters built 
deal problem heterogeneous structures formats parameter data different tasks 
df create provider service par create data element dp id dp id dom dp dom par dp create parameter id id par dom dom par dir df df dp write dp par read prec table 
adjusting data flow schema adding new data links es true signaled es false signaled ns activated ns completed ns skipped data element data link write read ns running 
linking inserted task existing data elements 
similar reflections regarding linkages output parameters inserted task existing newly inserted data elements 
order avoid unintended lost updates output parameter may linked data element rule df satisfied 
wf graph shown fig 
instance output parameters newly inserted task may mapped data element issues far concentrated correctness consistency issues regarding dynamic addition task graph wf instance 
sake completeness important aspects addressed mentioned 
experience turned important allow process participants fix date deadline execution inserted task 
necessary extensions described grimm 
secondly security reasons adept flex allows wf designers selected process participants restrict insert operation specific wf types wf categories selected users respectively user roles specific regions wf graph task block selected wf states specific activity types categories combination 
generally require user adds task wf subsequently 
provides additional flexibility process participants allowed add tasks wf execution explicitly implicitly delegated process participants 
requires powerful meta model capturing organizational entities relationships 
implementation client applications worklist handlers corresponding set generic api calls offered application programmers 
provided functions obtain information context insertion applied 
application insert operation described covers broad spectrum applications allows variety user friendly operations 
summarized table 
insertion choice intermediate step node successors may split node arbitrary type succ intermediate step preceding execution task pred new branch parallel branching split node sp join node sp new task additional synchronization table 
examples insert operation 
succ respectively pred denotes set direct successors task insert operation serves basis composing higher level operations 
example instantiations task type dynamic task realized repetitive change operation 
generality provides basis ad hoc definition wfs wf starts single node start node wf graph may dynamically extended repetitive application insert operation 
interesting aspect insert operation internal exception handling 
example deletion task leads incomplete missing parameter data succeeding data dependent tasks corresponding provider task data links may plugged graph synchronized tasks see section examples demonstrate approach able support large variety different application scenarios 
section sketch change operations interesting issues related 

overview change operations said adept flex comprises set basic change operations allow authorized users add tasks wf delete tasks wf skip execution tasks jump forward wf regions activated serialize tasks previously allowed run parallel perform backward operations wf graph incl 
undoing temporary changes 
due space limitations omit presentation set operations 
deal interesting issues related deletion tasks dynamic modification task sequences 
dynamic deletion tasks individual tasks task sequences may skipped removed conditions execution unnecessary 
course deletion tasks allowed 
firstly nodes integral part wf structure start node wf deleted 
secondly wf designers may customize wf schema order disallow deletion individual tasks tasks specific wf regions 
deletion task running wf instance possible state activated activated 
case items associated removed corresponding worklists 
tasks state running completed failed skipped may deleted 
concerning adjustment control flow graph delete operation realized substituting null task see section task deleted 
approach handled simple effective manner node deleted task associated control edges part wf structure 
see section facilitates undoing task deletions 
task deleted associated auxiliary services data links removed set respectively set df 
lead missing incomplete input data succeeding data dependent steps violation rule df cf 
section 
succ denote set tasks input parameters completely supplied due deletion exception handling policies applied adept flex deal cases regain correct consistent wf graph concomitant deletion tasks set turn may require deletion tasks cascading delete 
dynamic insertion provider task prox flow control 
prox takes data links deleted task completed task set may triggered 
dynamic addition corresponding provider services dynamically generated forms sets prec see section lead violation rule df 
abortion delete operation course policies may combination 
order relieve users performing necessary adjustments data flow schema manually adept supports specification success dependencies succeeding tasks 
task deleted wf graph run time succeeding tasks success dependent deleted 
turn may lead cascading deletion tasks 
concerning flow data approach require additional exception handling task set success dependent steps corresponds data dependent steps 
note approach similar concept spheres control proposed davis jr leymann applied structure wf 
changing task sequences run time mentioned section changes task sequences frequently necessary exceptional situations 
wf designers generally capable predict possible deviations advance operations required allow users dynamically skip execution tasks finishing tasks execution conditions satisfied 
example 
example take wf graph depicted fig 
assume authorized user wants jump forward task proceed flow control node ingoing edges task marked 
assume steps finished respectively worked concurrently completed task may triggered 
order achieve wf graph restructured shown fig 

note restructuring leads parallelization tasks previously constrained executed serially 
generally possible pass control jump forward node target may activated ns activated 
adept flex supports different policies dealing uncompleted tasks preceding node target flow control jump operation performed pred target ns activated activated running tasks set may aborted omitted example worked 
case execution synchronized successors target example tasks completed node may activated 
changes task sequences may lead incorrect data flow schema precautions taken 
rules section contribute identify cases provide adequate mechanisms exception handling 
due lack space aspect discussed 
conclude user friendly operations providing elegant efficient support dynamic structural changes operations 

change management instances specific wf type may active time 
changes different kinds may applied aspects considered wf instances type starting schema logically represented different wf graphs 
changes applied individual wf instance may depend previous changes wf 
structural wf changes may require concomitant modifications order preserve correctness consistency wf graph see section necessary graph adaptations carried transaction order allow forward recovery presence failures 
possible undo structural changes wf certain conditions 
management structural wf changes big difference applied change preserved completion wf permanent change temporary nature temporary change 
division particularly important support long running bps changes may affect wf regions entered times due loop iterations due partial rollback wf 
task inserted body loop instance specified insertion valid current iteration loop iterations 
case added task executed structural change undone iteration loop entered inserted task removed associated data links services 
remainder section simplistically assume durability change temporary vs permanent specified time applied wf instance 
change history ideally undoing temporary changes necessary adjustments wf graph completely handled system level costly user interactions 
order achieve run time system precise information previously changes 
approach maintain information wf instance wf graph reflecting current structure current state graph considers changes applied wf instance temporary permanent ones 
ns running es true signaled ns completed target ns activated soft sync nt null 
parallelization tasks previously constrained executed serially due jump forward operation 
wf graph perm resulted applying permanent changes starting schema temporary changes state considered graph 
change history analogously wf execution history records data changes applied chronologically ordered list 
data may undo changes 
history entry contains information type change operation insertion deletion task incl 
call parameters durability change temporary vs permanent initiator change start region change set nodes runtime system decide temporary change undone backward operation applied see list concomitant modifications addition auxiliary services cascading deletion data dependent tasks see section list change primitives incl 
call parameters applied perform change change operation mapped set graph modifications primitives addition deletion individual nodes edges data elements data links execution wf graph logically graph kept wf instance different kinds ad hoc changes may applied wf instances type starting schema 
require additional graph perm order ensure permanent changes remain correct temporary modifications undone 
example permanently inserted task data dependent temporarily inserted 
undoing temporary insertion leads incorrect data flow schema may cause severe run time errors 
order avoid dependencies application permanent change wf instance requires additional checks graph perm see 
applying temporary permanent changes temporary permanent changes wf instance requires different procedures 
order perform temporary change check applied maintaining correctness consistency wf graph cf 
section 
unresolvable exceptions occur change operation aborted 
applied corresponding entry added change history note temporary change may previously temporary changes permanent changes 
addition may consider state wf cf 
section 
permanent change requires additional checks 
verify application perm violate correctness graph 
contrast temporary changes verification performed independently state temporarily applied changes 
may wrong assumptions cause severe problems state reset temporary change undone due backward operation 
example take insertion task fig 
cf 
example change previously routing decision applied temporarily 
generally change correct respect perm check applicability graph 
checks successful applied perm corresponding entry added change history undoing temporary changes described changes managed put effect 
sketch necessary steps undoing temporary changes removing wf graph control wf passed back previous task restart due lack space restrict considerations dynamic insertion deletion tasks cf 
section undoing 
important points decision changes undone durability change temporary vs permanent start regions kept entry change history 
start region insert operation defined set cf 
section start region delete operation consists null task replacing removed task cf 
section 
simplification require temporary change undone node start region final state ns completed skipped failed contained backward region 
backward region comprises nodes graph state reset due backward operation 
case loop iteration corresponds nodes loop body see section backward region rollback operation comprises successors restart state different activated cf 
section 
problem find corresponding entries change history undo modifications associated 
simple approach yield satisfactory solution temporary changes may exist modifications dependent start region covered backward region 
dependent changes undone order preserve correctness note dependencies temporary changes quite usual may explicitly desired users 
taken account temporary changes undone 
mind assumptions steps performed backward operation applied 
find entry undone due backward operation oldest entry change history start region covered backward region 
entry exists omit steps 

traverse inverse order latest change reached 
visited entry remove corresponding change temporary permanent wf graph change removed undoing previously applied modification primitives reversed order 

traverse forward direction visited entry corresponds permanent change reapply case temporary change check start region covered backward region 
case change redone removed try redo change making information stored corresponding change entry incl 
information concomitant changes 
correctness consistency preserved due dependencies removed changes redo performed initiator change informed 
example 
graph depicted fig 
illustrate principle feasibility approach 
fig 
shows wf graph flow proceeded nodes temporarily inserted graph data element corresponding data links node permanently deleted 
fig 
shows resulting graph applying backward operation undoing temporary changes 
start region contained backward region change undone dependent temporary changes insertion insertion permanent change cp deletion applying steps algorithm restart es true signaled ns running ns completed applying step algorithm failure ns activated fails failure edge signaled 
ns failed backward region null 
undoing temporary changes failure edge signaled true 
entries change history precede arc correspond changes currently applied graph assumptions section may relaxed 
example cases desirable preserve temporary change rollback operation applied undo new iteration loop entered 
interesting aspect change history contributes increase user friendliness system structural changes undone undo structural changes user initiator change long influenced execution wf long changes 
summary support dynamic structural changes great demands wf engine change management 
concentrated conceptual issues related dynamic wf changes 
variety important implementation issues addressed high importance management dynamic changes workflow enactment level internal representation persistent storage wf instances underlying data structures transactional execution possibly long running change operations wf recovery synchronization concurrent change transactions resolution conflicting implementation goals performance vs flexibility dynamic changes wfs controlled different distributed wf servers name examples 

related widely recognized state art wf technology provide rudimentary support exception handling dynamic structural changes running wf instances see wainer ellis reichert sheth kochut 
research commercial wfmss directions try overcome limitations 
approaches focus provision services exception handling ad hoc structural changes support wf designers modifying schema wf propagating applied changes running wf instances started old schema wf schema evolution integration wfmss groupware technology combine formal structured processes informal group processes exception handling ad hoc structural changes wfmss mainly interested process oriented wf technology opposed lotus notes ott 
current process oriented wfmss flowmark leymann domino address small part issues discussed 
allow online modification task staff definitions exchange program modules wf execution weak respect exception handling dynamic structural changes 
approaches exist address issues 
proposals han vogel hsu wide casati mobile dynamite worth mentioning 
han 
suggest petri net model adaptive wfs 
basic idea mechanisms binding software components wf models may dynamically hierarchically combined run time 
support dynamic changes narrower sense 
structural changes wf model possible bound net transition 
authors talk correctness issues 
representative wfmss object migration model see 
wf definition regarded object electronic circulation folder sent user user modeled control flow 
user currently charge folder may change flow adding intermediate task 
potential weakness simplicity wf model parallel iterative executions explicitly supported lack clear theoretical basis 
offered change operations consider control flow ignore structural components wf specification 
data flow limited exchange files tasks wfms minimal control 
leaves significant complexity application programmers ensure correctness data flow wf restructured 
comparable functionality offered hsu uses constrained petri net model 
users may temporarily change course flow add intermediate tasks 
addition supports dynamic tasks multiple concurrent instantiation task type specific point wf 
limited mechanism exception handling offered actions necessary handle abnormal events explicitly modeled additional paths wf graph 
user detects exception abort active tasks modify flow structure transfer control exception handling path 
approach may lead complex wf models offered modeling constructs highlevel ellis nutt 
wide wf model offers trigger approach exception handling casati 
exception handlers ehs installed handle events cancellation task break normal flow 
contrast wf may proceed exception handled 
type exception wide provides default eh user notification may overwritten wf programmer 
lies responsibility programmers avoid inconsistencies errors complicates application development may introduce new errors exceptions model 
mobile wf model allows incomplete sub process models predefined points nodes wf 
incomplete models described terms goals partially defined process patterns completed run time 
authors indicate users supported changing incomplete model operations available 
correctness issues addressed 
competitive approach offered dynamite 
dynamite aims support software development process highly dynamic planning execution tasks may overlap 
dynamite uses dynamic task nets built modified incrementally process execution 
formally task nets graph rewriting system 
tasks shall dynamically added task net predefined process schema 
significantly limits dynamics approach 
operations changing task sequences deleting tasks available correctness issues discussed authors 
holds transactional wfs emphasis strength lie different areas reliability forward recovery presence failures alonso attie kamath ramamritham hsu hsu sheth 
transactional wfs apply concepts advanced transaction models pretty handling task failures abnormally terminated wfs eder liebhart 
concepts spheres compensation leymann davis jr contribute simplify speed application development wf applications reliable 
transactional wfs meet small part issues discussed 
wf engine generally knowledge detect handle possible failures exceptions dynamic changes typically require user involvement 
transactional wfs address issues concerning transactional execution structural changes synchronization 
wf schema evolution approaches address correctness issues connection dynamic structural changes 
notable exceptions come ellis 
casati 

contrast adept flex concentrates ad hoc changes individual wf instances approaches deal changes wf schema propagation running wf instances execution started old schema 
support types changes complex unsolved problem related issues identified respects ad hoc modifications intricate problematic may performed users 
adept flex approaches conceptual wf model 
restrict considerations dynamic changes control flow relevant aspects left aside 
ellis 
propose mathematical model constrained petri nets 
change corresponds replacement subnet wf graph new subnet said correct corresponding wf instances executed old schema new 
emphasis strength approach lie formal foundation 
casati 
address problem wf schema evolution static dynamic point view 
contrast ellis 
go line approach 
dynamic structural changes set modification primitives application violate correctness criteria 
proposed change primitives offer limited semantics compared approach 
strength lies variety policies offered managing evolution running wf instances including support version management 
formal criteria introduced order determine wf instances transparently migrated new version 
integrate dynamic structural changes schema level ad hoc changes instance level outstanding research issue 
looking proposal ellis 
example implicitly assumed execution instances specific wf type net 
assumption maintained ad hoc structural changes instance level considered 
proposals section considered step solution problem 
integration wf technology groupware approaches proposals combine formal structured processes informal group processes 
communication oriented models speech act conversation model winograd flores reduces organizational processes networks commitment loops process par 
approaches follow goal models blumenthal nutt circulation folders 
approaches share disadvantage achieved flexibility paid harder formalization simple repetitive processes 
research groups try combine advantages offered wf technology groupware gw systems supporting unstructured activities specific points wf blumenthal nutt sheth kochut weber 
group task corresponds node wf graph 
details done described terms goals guidelines 
approach combination model 
addressed issues include integration wfmss gw technology exchange data management contextual information blumenthal nutt weber 
authors doubt suitability approach 
potential disadvantage consider break structured unstructured parts resulting combined wf gw technology 
important features auditing rollback security consistency may lost unstructured group tasks controlled wfms 

summary outlook concentrated issues regarding dynamic structural changes wf instances execution 
argued changes norm computerized processes adequate support form key part process flexibility wfmss 
shown dynamic change problem facets worthwhile area study 
introduced basic concepts adept wf model 
demonstrated suitability precise specification wfs verification testing correctness wf specifications execution wfs 
argued adept model offers compromise trade expressive power wf model complexity algorithms needed model checking especially contrasting general purpose models petri nets 
believe crucial efficient support complex dynamic structural changes 
adept flex model adept adequacy respect dynamic structural changes demonstrated 
adept flex comprises complete minimal set change operations ensure correctness consistency resulting wf graph construction 
dynamic addition tasks example demonstrated correctness properties adept model set preconditions defined type change operation constitute basis 
discussed deal changes meet correctness criteria 
believe hard wired mechanisms hand solutions satisfactory practice 
proposed flexible approach offering policies dealing exceptions resulting change 
compared model wf models shown semantics offered change facilities adept flex captures models far 
addressed issues regarding management temporary permanent changes undoing temporary changes backward operations applied 
motivated variety organizational studies analyses processes clinical domain kuhn meyer reichert ad hoc changes dynamically evolving wfs usual exceptions frequently occur 
implemented complex processes university women hospital applying current wf technology reichert 
result today wfmss offer perspectives far away providing flexibility needed clinical users 
role application developers users handling exceptions changing structure wfs understood poorly integrated today wfmss 
believe wf technology potential lead completely different kind application programming 
development complex distributed application systems may reduce reuse process templates repository customization templates insertion application components style plug play 
broadly applicable wf technology provide high flexibility user assistance human centric approaches include integral support exception handling dynamic structural changes 
progress achieved lot done 
topics addressed specific areas warrant attention currently working support simultaneous changes individual wf instances application dynamic changes wfs schema decomposed parts may kept controlled different wf servers bauer dadam weikum intelligent support wf ensembles dynamically evolving collections loosely coupled wfs 
requirements identified far challenging faced concurrency control standard database technology dadam 
development general concepts integration dynamic structural changes schema level casati ellis changes instance level proposed provision intelligent interfaces application programmers users adding functionality current wf technology understanding programmer user able utilize certainly helpful :10.1.1.45.6317
case dynamic changes possible minimum cost application programmers users 
believe dynamic wfs field benefit intense study research community 
years developed series small prototypes concentrating single aspect modeling component support temporal constraints support dynamic changes order better understand user related issues implementation aspects grimm kirsch 
started design implementation adept workflow adept workflow engine integrate features described system 
acknowledgments grateful clemens thomas bauer christian birgit numerous interesting discussions topics related research 
notes 
adept stands application development encapsulated process templates 
necessarily mean value input parameter aggregated values data elements cf 


algorithm extended user wants insert new task start node loop arbitrary node contained loop body 

defined follows contains nodes excl 
start node node wf graph unique start node 
furthermore node node corresponds start node loop loop node contained vice versa 
constraints apply branchings 

adopted notion casati 

null task correspond action real world 
null task triggered outgoing edges marked immediately 

set pred corresponds transitive closure nodes preceding flow control cf 
appendix 
simplistically omitted write operations elements definition set 

succ comprises nodes reachable control sync edges cf 
appendix 

note primitives modify sets df 
generally individual application wf graph preserve syntactical correctness consistency 

rare cases possible redo permanent change 
due lack space discuss aspect 
alonso agrawal abbadi el kamath mohan 

advanced transaction models workflow contexts 
proc 
th int 
conf 
data engineering 
new orleans louisiana ieee computer society press 


formal processes augmenting workflow group interaction techniques 
proc 
conf 
organizational computing systems 
new york acm press 
attie singh sheth rusinkiewicz 

specifying enforcing intertask dependencies 
proc 
th int 
conf 
large databases pp 

dublin ireland morgan kaufmann publishers 
wainer 

workflow systems definitions suggestions 
proc 
conf 
organizational computing systems pp 

new york acm press 
bauer th 
dadam 

distributed execution environment large scale workflow management systems subnets server migration 
proc 
nd ifcis conf 
cooperative inf 
sys 
pp 

kiawah island south carolina usa ieee computer society press 


composing processes reuse application components german 
master thesis 
university ulm germany 
blumenthal nutt 

supporting unstructured workflow activities bramble icn system 
proc 
conf organizational computing systems pp 

new york acm press 
casati ceri pernici pozzi 

workflow evolution 
proc 
th int 
conf 
conceptual modeling pp 

cottbus germany springer 
casati grefen pernici pozzi 

wide workflow model architecture 
technical report university milano italy 
davis jr 

data processing spheres control ibm systems journal 
eder liebhart 

workflow activity model wamo 
proc 
rd int 
conf 
cooperative inf 
sys 
pp 

vienna austria 
ellis nutt 

modeling enactment workflow systems 
proc 
th int 
conf 
application theory petri nets pp 

chicago wa springer 
ellis keddara rozenberg 

dynamic change workflow systems 
proc 
conf 
organizational computing systems pp 

new york acm press 

ed 

database transaction models advanced applications 
morgan kaufmann publishers 
georgakopoulos hornick sheth 

overview workflow management distributed parallel databases 
grimm 

adept time dealing temporal dependencies flexible wfmss german 
master thesis university ulm germany 
han schaaf 

management workflow resources support runtime adaptability system evolution 
proc 
int 
conf 
practical aspects knowledge management 
basel switzerland 
westfechtel 

dynamite dynamic task nets software process management 
proc 
th int 
conf 
software engineering pp 

berlin germany 
schuster stein 

von ad hoc workflows im mobile workflow modell 
proc 
automation und kommunikation pp 

munich germany 
dadam 

interaction expressions powerful formalism describing inter workflow dependencies 
technical report department computer science university ulm germany 
hennessy 

algebraic theory processes 
cambridge mit press 


adept flex dynamic modification workflows exception handling wfmss german 
master thesis university ulm germany 
hofstede orlowska 

verification problems conceptual workflow specifications 
proc 
th int 
conf 
conceptual modeling pp 

cottbus germany springer 
hsu 

process management infrastructure distributed parallel databases 
hsu 
ed 

special issue workflow extended transaction systems ieee bulletin technical data engineering 
hsu 
ed 

special issue workflow systems ieee bulletin technical data engineering 
kamath ramamritham 

bridging gap transaction management workflow management 
proc 
nsf workshop workflow process automation inf 
sys 
athens georgia 
weiss 

support cooperative electronic circulation folders bulletin 
kirsch 

design implementation graphical tool modeling animation flexible workflows german 
master thesis university ulm germany 
hinrichs klein 

experiences domino office procedure system 
proc 
nd european conf 
cscw pp 

amsterdam netherlands 
kuhn reichert dadam 

infrastructure cooperation communication advanced clinical information system 
proc 
th symp 
comp 
med 
care pp 

washington hanley belfus medical publisher 
leymann 

managing business processes information resource ibm systems journal 
leymann 

supporting business transactions partial recovery workflow management systems 
proc 
bro technik und wissenschaft pp 

dresden germany springer 
manna pnueli 

temporal logic reactive concurrent systems specification 
springer 
meyer 

requirements wfmss flexibility exception handling dynamic changes clinical processes german 
master thesis university ulm germany 
ott 

und analyse im bereich zwischen und technical report workgroup computing competence center paderborn university paderborn germany 
reichert kuhn dadam 

process reengineering process automation clinical application environments german 
proc 
pp 

bonn germany verlag 
reichert dadam 

framework dynamic changes workflow management systems 
proc 
th int 
workshop database expert systems applications pp 

toulouse france ieee computer society press 
reichert dadam 

experiences development process oriented clinical application systems process oriented workflow technology german 
proc 
pp 

ulm germany verlag 


workflow management verteilten systemen 
stuttgart teubner 
reuter 

contracts low level mechanism building general purpose workflow management systems ieee bulletin technical committee data engineering 
sheth georgakopoulos rusinkiewicz scacchi wileden wolf 

report nsf workshop workflow process automation information systems technical report 
uga cs tr university georgia 
sheth kochut 

workflow applications research agenda scalable dynamic coordination collaboration systems 
proc 
nato advanced study institute wfmss interoperability 
istanbul turkey 


adaptive workflow german public administration 
proc 
st int 
conf 
practical aspects knowledge management workshop adaptive workflow 
basel switzerland 
strong miller 

exceptions exception handling computerized information processes acm transactions inf 
sys 
vogel 

backtracking office procedures 
proc 
th int 
conf 
database expert systems pp 

valencia spain springer 
weber schweitzer schneider 

flexible real time meeting support workflow management systems 
proc 
th int 
conf 
system sciences 
maui hawaii ieee computer society press 
winograd flores 

understanding computers cognition new foundation design norwood nj ablex publishing 
weikum 

formal foundation distributed workflow execution state charts 
proc 
int 
conf 
database theory 
delphi greece 
sheth 

transactions transactional workflows 
jajodia kerschberg 
eds advanced transaction models architectures kluwer academic publishers 
appendix correctness data flow schema definition successor 
define succ succ control soft sync strict sync succ succ succ succ succ succ comprises set direct successors node set nodes destination control sync edge source succ denotes transitive closure function 
succ comprises tasks wf graph reachable control sync edges 
hand set succ succ comprises nodes reachable control edges 
meaning corresponding predecessor functions transitive closures intuitive omit definition 
example 
wf graph shown fig 
succ succ 
rule df 
df schema wf 
writes writes require succ succ succ succ succ succ succ pred reads simplistically omitted write operations elements presentation rule 
write access data element succeed flow control belong different branches branching inner join cf 

tasks different branches parallel processing join may write access data element serialized sync edge 
rule aims avoiding write write conflicts succeeding tasks 
appendix correctness graph substitution adding new tasks theorem syntactical correctness termination behavior adding new task 
syntactically correct control flow graph wf schema node reachable start node reachable state final state reached 
furthermore disjoint sets succ require precedes flow control region covered nodes set succ pred may contain complete loop control structures application insert algorithm add new task sets cf 
section results syntactically correct control flow graph satisfies properties 
proof sketch 
sketch idea proof theorem considering reduction rules 
insert operation substitutes logical block graph symmetrical block parallel branching inserted task branches 
symmetrical structuring graph preserved insertion null tasks influence termination behavior wf 
restrictions sync edges see section satisfied added edges synchronize tasks different branches parallel branching task tasks synchronize node contained loop body inserted task condition lead cycles termination problems 
guaranteed ordering tasks sets condition 
properties valid starting graph easily show satisfies properties 
note sync edges type soft sync 

