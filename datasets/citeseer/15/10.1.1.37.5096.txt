fl kluwer academic publishers boston 
manufactured netherlands 
simple imperative polymorphism andrew wright wright cs rice edu department computer science rice university houston tx editor ian mason 
describes simple extension hindley milner polymorphic type discipline call value languages incorporate imperative features exceptions continuations 
extension sacrifices ability type purely functional expression typable hindley milner system 
return assigns type functional imperative implementations abstraction 
module system separates specifications implementations imperative features freely implement polymorphic specifications 
study number ml programs shows inability type hindley milner typable expressions seldom impacts realistic programs 
furthermore programs rendered untypable new system easily repaired 
keywords continuations functional programming polymorphism state 
polymorphism imperative features modules hindley milner polymorphic type discipline elegant flexible type system functional programming languages 
call value languages include imperative features exceptions continuations facilitate concise efficient programs 
solutions integrating imperative features polymorphism call value languages devised 
solutions range complexity tofte relatively simple method standard ml adopted talpin sophisticated system infers types regions effects 
solutions assign types purely functional expressions typable hindley milner system henceforth called hm typable expressions 
assign different types imperative functional polymorphic procedures implement mathematical abstraction 
example standard ml may define polymorphic procedure sorts lists kind ordering function elements val sort fn fn list sort functional implementation procedure type ff ff ff bool 
ff list 
ff list ordinary hindley milner type system 
imperative implementation sort places elements list temporary cell array may efficient research supported part united states department defense national defense science engineering graduate fellowship 
concise 
imperative version sort imperative types tofte system macqueen system leroy system ff ff ff bool 
ff list 
ff list tofte ff ff ff bool 
ff list 
ff list macqueen ff ff bool 
ff list 
ff list leroy fff ff ff bool pg case extra annotations procedure type reveal imperative features implementation 
revealing imperative nature procedure type serious consequences module system separates specifications implementations 
imperative procedures supplied implementations functional polymorphic specifications 
standard ml signature specifies interface sorting module signature sort sig val sort ff ff ff bool 
ff list 
ff list functional version sort supplied implementation signature 
imperative version sort correct type 
consequently specifications implemented imperative procedures imperative type 
extra annotations imperative types clutter specifications 
imperative types restrict applicability procedures ways peculiar type system difficult programmers predict 
simple solution typing imperative features sacrifices ability type hm typable expressions 
return solution assigns types imperative functional implementations abstraction 
enables modules implementing polymorphic specifications freely imperative features 
study lines ml code empirical evidence type system seldom rejects realistic ml programs inability type hm typable expressions 
furthermore program rejected reason simple syntactic changes expansion usually suffice restore typability 
section outlines difficulty incorporating imperative features hindley milner type system discusses previous solutions 
assume familiarity ordinary hindley milner typing 
section presents solution studies impact realistic programs 
fourth section discusses related 

polymorphism pointers illustrate difficulty typing imperative features hindley milner setting standard ml examples 
discussion applies equally exceptions continuations 
call value functional language imperative features may explain polymorphic expression val abbreviation expansion capture avoiding substitution free 
semantically expressions equivalent 
expansion subexpression evaluated discarded ensure expansion diverges expression 
expressions type 
expansion mimics polymorphism replicating subexpression occurrence expansion may assigned different type 
hindley milner type system mimics typing expressions expansions requiring type checker expand expressions 
simple explanation polymorphism fails language imperative features expression expansion may semantically equivalent 
example may create cell shared uses expansion capture sharing 
expression val ref equivalent expansion ref ref ref expression subexpression ref allocates cell containing 
subexpression replaces contents cell extracts cell contents returns 
expansion hand creates distinct cells returns 
ignoring semantic difference typing cells leads trouble 
naive attempt introduce merely adds ref primitive procedures polymorphic types ref ff ff 
ff ref ff ff ref ff ff ff ref ff unit consider known counter example val ref fn fn true types cell operators subexpression ref fn line type fi fi ref type fi 
generalizing fi obtain polymorphic type fi fi fi ref line assigns occurrence type int int ref type valid instance polymorphic type obtained instantiating fi int 
line assigns occurrence type bool bool ref valid instance polymorphic type 
expression typable 
evaluating expression leads type error true 
naive attempt type cells unsound 
example generalizing fi incorrect fi appears type cell shared expression body 
fi generalized occurrences forced type 
impossible expression rejected 
uses cells expression prevent generalization 
expression semantically equivalent expansion indicated generalization occur usual 
imperative function reverses list linear time val fn list val left ref list right ref left right hd left right left tl left right cells left right type fi list ref outer expression body allocates new cells 
fi generalized outer expression yield polymorphic type fi fi list 
fi list general type variables appear types cells may generalized expression may 
exactly type variables generalized undecidable 
sound solution typing cells avoid generalizing type variables appear types shared cells 

conservative solutions solutions devised date conservative extensions hindley milner type system 
assign types hm typable expressions 
conservative solutions require determining degree expression binding uses imperative features 
solutions record information uses imperative features expression type 
standard ml standard ml adopts tofte solution 
solution assigns type ff ff 
ref operator ff imperative type variable 
imperative type variables indicate values may placed cells 
contagious value stored cell variables value type imperative 
imperative variables generalized expressions binding syntactic shape guarantees creates new cells 
standard ml function defined type ff ff list 
ff list 
weak types system proposed macqueen standard ml new jersey years 
approximations formalized mitchell viswanathan greiner 
methods extend tofte method assigning weakness numbers type variables 
weakness type variable indicates arguments supplied curried procedure allocates containing type variable 
example imperative implementation sort section type ff ff ff bool 
ff list 
ff list procedure applied arguments allocates cell containing value type ff 
weak types allow partial applications imperative polymorphic procedures rejected tofte system 
closure typing leroy weis observed necessary prohibit generalization type variables appear types cells reachable binding evaluated cells reclaimed garbage collection point 
cells may reachable free identifiers closures system records types free identifiers procedure procedure type 
imperative implementation sort type ff ff bool 
ff list ff list fff ff ff bool pg 
leroy original closure typing system type hm typable expressions dissertation corrects oversight 
damas damas proposed earliest systems typing 
system assigns type set delta expression 
set delta finite set types cells may allocated evaluating expression 
polymorphic procedure types augmented similar set delta outermost arrow indicates types cells procedure may allocate applied 
imperative version sort type ff ff ff bool 
ff list delta 
ff list delta fffg 
effects systems typing effect inference proposed 
system proposed author extends damas system attach effect sets delta function type arrows 
system assigns type ff ff ff bool 
ff list ff gamma 
ff list imperative version sort 
sophisticated system devised talpin jouvelot infers types effects effect regions expressions 

simple solution conservative solutions need identify uses imperative features expression type stems desire admit hm typable expressions 
assign types imperative functional implementations abstraction sacrifice ability 

limiting polymorphism values solution limits polymorphism expressions binding syntactic value 
expression val assigns polymorphic type syntactic value 
value uses type 
precise definition syntactic value flexible 
ml take syntactic values constants variables expressions constructors applied values 
ref operator considered constructor purpose 
evaluation syntactic value cause side effects safe generalize type variables manner hindley milner system syntactic value 
determination generalize depends solely syntactic shape type special annotations required types 
imperative functional implementations abstraction type 
exceptions continuations fit smoothly framework 
operators polymorphic types ref ff ff 
ff ref ff ff ref ff ff ff ref ff unit application ref value expressions create cells generalized 
counter example section correctly rejected 
expressions values freely procedure bodies inhibiting polymorphism 
function section polymorphic type ff ff list 
ff list 
type system continuations allow continuations polymorphic 
expression val callcc fn assigned polymorphic type 
consider explanation expressions abbreviations 
expansion replicates subexpression callcc fn expression body different meaning 
polymorphism limited values standard ml new jersey callcc operator assigned polymorphic type ff ff cont ff ff 
identifier example assigned polymorphic type expression callcc fn value 
similarly exception types need special restrictions 
establish soundness solution showing isomorphic restriction tofte solution 
recall tofte system imperative applicative type variables rules expressions 
rule non expansive bindings syntactic values generalizes kinds type variables 
rule expansive bindings non values generalizes applicative type variables 
remove applicative type variables system types imperative type variables rule expansive bindings generalize type variables 
removing applicative type variables tofte system yields system isomorphic 
existing proofs type soundness tofte system establish type soundness 
easily establish system possesses type inference algorithm finds principal types 
algorithm ordinary hindley milner type inference algorithm run simple translation 
translation merely expands expression val syntactic value equivalent expression fn 
translation prevents type inference algorithm assigning polymorphic type 
possible consequences polymorphism limited values non value expressions polymorphic types hindley milner system longer polymorphic 
cases expressions return expressions compute polymorphic procedures opposed expressions just procedures expressions compute polymorphic data structures 
examine turn 

expressions return expressions return arise functional programs divergent computations 
language exceptions continuations expressions signal exceptions throw continuations return 
expressions seldom appear expression bindings yield useful value 
assigning polymorphic types expressions impacts realistic programs 
extend type system accommodate expressions 
common expressions return type ff 
safe generalize type ff ff regardless expression value provided ff free type environment course 

expressions compute polymorphic procedures expression binding computes polymorphic procedure computation may purely functional may exercise imperative features 
suppose computation functional example val fn fn true hindley milner typing expression typable identity procedure polymorphic type ff ff ff 
polymorphism limited values assigned polymorphic type 
body uses different types expression typable 
functional computations polymorphic procedures typically arise realistic ml code uses compose operator partial applications curried procedures map 
computation polymorphic procedure functional easily restore polymorphism expanding binding example val fn fn fn true binding value assigned polymorphic type ff ff ff 
care needed expanding bindings transformation affect algorithmic behavior program 
polymorphic procedure recomputed time 
suppose computation polymorphic procedure exercises imperative features 
expansion may possible altering semantics program 
example procedure takes procedure argument constructs procedure behaves counts number times called val fn val ref val fn counter integer cell counts calls exported assignment global variable counter 
applied polymorphic procedure map val map map resulting procedure map polymorphic map value 
restoring polymorphism expansion causes new counter allocated time map applied 
map polymorphic potentially awkward global changes program required 
leroy gives examples may desirable imperative features computing polymorphic procedure 

expressions compute polymorphic data structures expressions compute polymorphic data structures require global program modifications restore polymorphism computation functional imperative 
example expression computes polymorphic empty list val empty fn hindley milner system assigns polymorphic type ff ff list empty 
polymorphism limited values empty assigned polymorphic type 
furthermore analog expansion restore polymorphism polymorphic data structures computation functional 

practical impact limiting polymorphism values practical inability compute polymorphic procedures data structures seldom impacts real programs 
determine problem arise modified standard ml new jersey type system 
gathered extensive collection ml programs compiled modified compiler see table 
ml programs satisfy restriction polymorphism values modified expansions 
words 
realistic ml code seldom computes polymorphic procedures data structures 
furthermore 
polymorphic procedures computed computation functional 
non functional computations polymorphic procedures uses new jersey compiler unsafe procedure function performs dynamic linking 
computations polymorphic data structures construction polymorphic empty vector edinburgh ml library constructions polymorphic events exene 
simple fix 
case modifications cause detectable difference performance 
reppy concurrent ml implementation illustrates benefit assigning types functional imperative procedures 
concurrent ml extensive standard ml new jersey class continuations implement threads 
avoid assigning weak types concurrent ml procedures reppy implementation uses version callcc type ff ff cont ff ff 
type callcc unsafe new jersey compiler weak type system correct type ff ff cont ff ff reppy justifies unsafe type callcc manual proof type soundness concurrent ml 
polymorphism limited values ff ff cont ff ff correct type callcc 
troublesome procedures automatically assigned desired polymorphic types separate soundness proof necessary 

integration standard ml modules structure implementation module structure foo struct val flatten map hd application map hd type ff list list 
ff list 
polymorphism limited values ff generalized free type structure 
standard ml allow type structure contain free type variables code rejected 
table 
practical impact limiting polymorphism values program size lines features changes required exceptions continuations standard ml expansions new jersey version casts unsafe bootstrap code sml nj library ml yacc expansions expansions generated code ml lex ml twig ml info source group version concurrent ml expansion john reppy added exene exene window toolkit expansions reppy gansner choose changed declaration moved edinburgh ml library expansion vector changed ml kit interpreter expansions isabelle theorem prover expansions version hol theorem prover expansions version lazy streams thomas breuel version arrays thomas breuel doubly linked lists expansions olin shivers wireframe graphics olin shivers hilbert type declaration thomas yan grobner basis expansions thomas yan structure fixed expansion flatten polymorphic type 
alternatively type constraint instantiate free type variable flatten needed specific type structure foo struct val flatten int list list int list map hd existing ml code frequently combines structures signature constrains types definitions signature foo sig val flatten int list list int list structure foo foo struct val flatten map hd signature constraint foo constrains flatten type free type variables 
unfortunately standard ml insists structure foo closed type constrained match signature foo 
force programmers add redundant type constraints structures permit free type variables structure defined signature constraint functor result constraint 
absence signature constraint structures free type variables rejected 

related authors suggested call name semantics expressions order combine imperative features polymorphism 
expression val subexpression evaluated needed re evaluated adapting solution ml involve introducing syntactically different forms expressions polymorphic call name form non polymorphic callby value form 
allow imperative procedures polymorphic types drastically alter call value nature ml 
call name desired simulated call value system introducing dummy abstractions applications 
expression val fn simulates name denotes substitution free 
limiting polymorphism values yields simple type system smoothly incorporates imperative features 
restriction polymorphism values seldom hindrance realistic programs 
return restriction enables functional imperative implementations abstraction assigned types 
patch standard ml new jersey version limits polymorphism values eliminates weak types available anonymous ftp cs rice edu file public wright tar related file tools describes required changes important tools ml yacc concurrent ml 
acknowledgments am indebted bruce duba referees comments suggestions 
thomas breuel olin shivers thomas yan contributed programs 
notes 
observation due stefan 

see rules definition footnote page commentary 

extension ml module system appears sound bob harper personal communication february 
may possible allow free type variables absence signature constraint investigated flexible extension 

standard ml new jersey release notes version bell laboratories november 

damas principal type schemes functional programs proceedings th annual acm symposium principles programming languages january 

damas type assignment programming languages phd thesis university edinburgh 

greiner standard ml weak polymorphism sound technical report cmu cs carnegie mellon university september 

harper lillibridge 
explicit polymorphism cps conversion conference record th annual acm symposium principles programming languages january 

harper duba macqueen typing class continuations ml journal functional programming october 

hindley principal type scheme object combinatory logic transactions american mathematical society december 

mitchell viswanathan 
standard ml nj weak polymorphism imperative constructs proceedings eighth annual symposium logic computer science june 

leroy un langage phd thesis universite paris 

leroy polymorphism name continuations conference record th annual acm symposium principles programming languages january 

leroy weis 
polymorphic type inference assignment proceedings th annual symposium principles programming languages january 

milner theory type polymorphism programming journal computer system sciences 

milner tofte 
commentary standard ml mit press cambridge massachusetts 

milner tofte harper 
definition standard ml mit press cambridge massachusetts 

ohori simple semantics ml polymorphism proceedings fourth international conference functional programming languages computer architecture september 

reppy higher order concurrency phd thesis cornell university 

talpin 
jouvelot 
type effect discipline proceedings seventh annual symposium logic computer science june 

tofte type inference polymorphic information computation november 

wright typing effect inference proceedings th european symposium programming springer verlag lecture notes computer science 

wright felleisen 
syntactic approach type soundness technical report rice university april 
appear information computation 
