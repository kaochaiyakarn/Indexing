design pretty printing library john hughes chalmers goteborg sweden 
power functional programming depend 
functional programs fraction size equivalent programs languages 
easy write 
claim functional languages support software reuse extremely 
programs constructed putting program components 
discuss reuse ask kind components name reused reconstructed 
flexibly component 
programming language worthy name allows sections program identical control flow shared defining reusing procedure 
programming idioms example looping array defined procedures repeated part loop construct contains varying part loop body different instance 
functional language problem define higher order function varying part passed function valued parameter 
ability name reuse programming idioms heart functional languages power 
features contribute making reused components flexible 
polymorphic typing enables programming idiom manipulate data different types 
lazy evaluation abstracts away execution time enables reuse function different behaviours 
example lazy list behave array sequence elements stored time imperative variable sequence values stored different times say buffer bounded number elements stored time 
regardless behaviour functions manipulate list 
software reuse plainly visible functional programs example haskell standard prelude contains higher order functions map foldr intensively programs 
standard functions capture general programming idioms useful context 
just important define application specific idioms 
functional programmer approach new application seeking identify programming idioms common application area define probably higher order functions 
particular application program built far possible combining functions writing new code 
reason functions called combinators 
benefits approach rapid programming library idioms defined application programs correct time built assembling correct components 
example application area idioms thoroughly studied parsing libraries parsing combinators described volume 
example larger scale carlsson fudget library described enables graphical user interfaces constructed easily 
question address chapter libraries combinators designed 
know operations provide 
monads explained volume certainly helpful know monad 
rely completely intuition 
goal show formal specification combinators study algebraic properties guide design implementation combinator library 
case study library pretty printing gone iterations improved formal approach 
hope methods wider applicability smaller examples justify claim 
preview pretty printing library pretty printing 
program manipulates symbolic data needs display data user point compiler displaying internal structures debugging proof editor displaying proofs program transformer writing output 
problem displaying symbolic especially tree structured data recurring 
time structured data hard read layout structure visible 
take simple example binary tree type data tree node string tree tree leaf tree node foo node baz leaf leaf node leaf leaf easier read node foo node baz leaf leaf node leaf leaf pretty printer job lay structured data appropriately 
pretty printing complicated layout node just inferred form 
example nodes laid different ways horizontally vertically 
correct indentation final node depends length string parent node 
pretty printer keep track contextual information 
pretty printers hard write plenty scope mistakes 
programmers simply bother put badly formatted output 
gained capturing hard part pretty printing library 
examples chapter haskell syntax note considering problem displaying internal datastructures readable form harder problem improving layout existing text program 
case consider questions try preserve original layout 
handle comments 
problems outside scope chapter 
sketch design kind objects pretty printing combinators manipulate 
chose pretty documents type doc think documents know lay 
pretty printer particular datatype function mapping value suitable doc 
library provides operations constructing docs various ways converting doc text top level 
need convert literal strings docs reasonable provide operations combine docs horizontally vertically 
suggests provide operations text string doc 
doc doc doc horizontal composition doc doc doc vertical composition composition operators 
relieve user need think correct indentation example pretty tree layout constructed text node foo 
text node baz leaf leaf text node leaf leaf node automatically indented right amount 
operations enable construct docs fixed layout 
need construct docs choose alternative layouts depending context 
define sep doc doc combines list docs horizontally vertically depending context 
operations write pretty printer tree type pp tree doc pp leaf text leaf pp node text node 
sep pp pp pp leaf pp leaf pp text 
pp 
context dependent choice layout entirely hidden implementation doc type complication deciding insert brackets 
library provides operation nest int doc doc document number spaces 
example text nest text produces layout difference nest inserting spaces nest appropriate example sep text nest text appear laid vertically indentation laid horizontally 
choice combinators quite early development library implementation written description just 
description far satisfactory intention design fairly clear precise behaviour combinators certainly 
surprisingly led number difficulties strange behaviours 
give precise specification combinators behaviour derive alternative implementations 
continue larger case study ll simpler examples illustrate methods 
deriving functional programs specifications conveniently specification help develop functional program 
suppose specification consists signature containing possibly new types doc names types functions specified properties new functions satisfy 
task invent representations new types definitions functions properties satisfied 
call functions new types old types observations 
observations important distinguish values new types represent 
assume specification determines value possible observation strengthen specification 
implementations trying derive consist equations restricted form 
derive implementations proving constituent equations specification 
guarantee implemented functions satisfy specification proved equations 
check derived definitions terminating exhaustive property guaranteed 
see consider case single function start specification derive implementation equations considered predicates construction 
general implementation equations satisfied different functions equations define 
call function imp derived definitions exhaustive terminating argument imp defined value words imp implementation equations unique solution 
specification satisfied know imp imp holds implementation satisfies specification 
specification derive equations convenient specification consists equations laws new functions satisfy 
start deriving implementations functions choose representation new type 
different ways choosing representation 
representing values terms algebra working 
second representing values functions context value placed value corresponding observation 
designing sequence type considering simple familiar example design representation sequences 
course know represent sequences lists 
point discover new representation see arrived known representation lists starting algebraic specification 
take signature starting point nil seq unit seq cat seq seq seq list seq nil unit cat give ways build sequences list observation 
correspondence usual list operations nil unit cat operations satisfy laws xs cat ys cat zs xs cat ys cat zs nil cat xs xs xs cat nil xs list nil list unit cat xs list xs haskell allows binary function infix operator name enclosed 
op op term representation direct way represent values sequence type just terms example data seq nil unit seq cat seq trivial representation exploit algebraic laws know hold list observation little tricky define ideally implement observations simple non recursive functions real done implementations seq operators 
may choose restricted subset terms call simplified forms term put algebraic laws 
represent sequences datatype represents syntax simplified forms 
case obvious candidate simplified forms terms form nil unit cat xs xs simplified form 
simplified forms represented type data seq nil seq interpretation nil nil xs unit cat xs choose representation definition list simple derive list nil list nil list xs list unit cat xs list xs derive implementations operators algebra simply applying algebraic laws nil nil defn 
nil unit unit cat nil nil defn 
nil cat ys nil cat ys ys xs cat ys unit cat xs cat ys unit cat xs cat ys associativity xs cat ys defn 
data seq nil seq nil nil nil cat ys ys xs cat ys xs cat ys list nil list xs list xs fig 

term representation sequences 
collecting results obtain definitions 
termination function obvious 
know seq term expressed simplified form 
definitions derived proof 
function maps simplified arguments simplified results terminates construct simplified form equal term just evaluating definitions 
complicated algebras observation valuable re choosing simplified form need worry terms put simply try derive terminating definitions operations succeed result follows 
far just derived usual implementation lists nil correspond 
notice isn problems implementation cat linear argument run known problem expression unit cat unit cat unit xn gamma cat unit xn takes quadratic time evaluate 
associative law times obtain equivalent expression unit cat unit cat unit xn gamma cat unit xn runs linear time 
hope exploit associative law improved implementation achieves better complexity case 
try derive implementation cat recognises cat left argument applies associative law continuing 
alas recognise applications cat simplified forms means cat operation forced back trivial representation started 
section look different approach exploit associativity case 
avoid term canonical form general reason term need unique simplified form 
really mean semantics nil equality mean equality algebra implementing necessarily haskell equality 
conventional write nil prefer identify syntax semantics interests notation 
context passing representation apply associative law making outer cat recognise left argument cat inner cat recognise called cat context 
idea motivates representation sequences functions context observation 
context just expression hole written ffl 
example ffl cat ys context 
ffl context expression write result replacing hole case ffl cat ys xs xs cat ys 
describe contexts interested grammar 
example grammar describes possible contexts type list expressions type seq ffl list ffl ffl cat cat ffl expression seq type 
just terms represent contexts corresponding haskell datatype data cxt list seq cxt seq cxt list list ffl ffl cat cat ffl notice representation say context contains representation enclosing context contexts resemble stack 
notice context type parameterised refers seq fact just laws restricted set terms shall laws restricted set contexts 
purposes example need consider contexts form ffl list ffl list ffl cat represented datatype data cxt list listcat seq represent sequence values functions contexts lists value represented function ffl 
contexts continuations internal structure inspected 
example nil ffl nil notational distinction nil left representation nil right semantic object 
apply representation context derive example nil listcat zs nil list ffl cat zs defn 
listcat list nil cat zs defn 
nil switch backwards forwards form step comment 
derive definitions operators laws algebra nil list list nil nil listcat zs list nil cat zs list zs zs list unit list list unit list unit cat nil list nil unit listcat zs list unit cat zs list zs zs list xs cat ys list list xs cat ys xs listcat ys xs cat ys listcat zs list xs cat ys cat zs list xs cat ys cat zs assoc 
xs listcat ys cat zs notice derived definition cat recognises enclosing cat applies associative law just optimisation wanted capture 
gathering results obtain implementation shown 
show definitions terminate derive complexity considering suitable cost measure terms 
construct cost measure reduction strictly reduces cost 
start observing terms containing cat listcat reduced normal form step 
ll give terms cost zero 
notice second equations defining nil unit eliminate listcat 
listcat assigned cost reductions reduce cost 
looking definition cat see equation converts cat listcat 
assign cat cost reduction reduces cost 
tricky case second equation cat reduces number occurrences cat listcat 
obtain cost reduction case assigning different costs occurrences cat left right hand side 
assign cat cost cheap context cost contexts 
cheap contexts defined grammar cheap ffl ffl list listcat ffl cheap cat ffl data cxt list listcat seq type seq cxt nil list nil listcat zs zs list unit list unit listcat zs zs list xs cat ys list xs listcat ys xs cat ys listcat zs xs listcat ys cat zs list xs xs list fig 

context passing implementation sequences 
easy verify cat right equation cheap context left 
check equation bound variables appear cheap context left hand side iff appear cheap context right hand side implicit assumption bound variable contributes cost occurrence false 
having done know number reductions needed evaluate term bounded cost 
linear size term 
cured quadratic behaviour motivated consider context passing implementation 
changing representation contexts examine definitions see zs component listcat zs applying list 
interested value zs value list zs 
suggests try changing representation contexts store 
new context datatype data cxt list listcat interpretation list list ffl listcat list zs list ffl cat zs zs list zs derive nil listcat zs list nil cat zs list zs zs unit listcat zs list unit cat zs list zs zs xs cat ys listcat zs list xs cat ys cat zs list xs cat ys cat zs xs listcat list ys cat zs xs listcat ys listcat list zs xs listcat ys listcat zs notice time introduce listcat accompanying application list enables simplification 
case succeeded right hand side form zs appear zs 
take derived equations definitions formal parameter zs 
provided course contexts form listcat zs satisfy invariant zs zs list zs easily verified 
case go little 
noting list xs list xs cat nil xs listcat list nil xs listcat redefine list list contexts altogether 
form context remains drop listcat constructor represent contexts just lists 
resulting definitions appear 
type cxt type seq cxt nil zs zs unit zs zs xs cat ys zs xs ys zs list xs xs fig 

optimised context passing representation sequences exercise 
similar trick eliminate list contexts listcat constructor previous section 
implementing monads ideas previous section applicable want implement datatype specified signature equations operations signature satisfy 
interesting class datatypes specified way monads 
simplest monad parameterised type pair operations unit bind 
satisfying laws unit bind bind unit bind 
bind bind fx bind see chapter wadler volume exposition uses monads functional programming 
operations monad uninteresting 
reality extend signature additional operations 
particular way observe monad value implement monad type unit bind satisfies monad laws 
consider simplest interesting monad additional operation value satisfying law value unit ll look implementations simplified terms context passing 
term representation simple monad suppose try represent monad values directly terms data unit bind notice type variable occur left hand side definition 
existentially quantified type variable may construct applying bind type representation value defined value value unit value bind value value existential type definitions proposed laufer part standard haskell accepted hbc 
uses polymorphic recursion inner recursive call value different type enclosing avoid complications representation simplified terms 
fact simplify term form unit dropping bind constructor monad type obtain unit unit unit bind value unit property unit bind need derive definitions monad law 
unit constructor monad type drop represent just obtain standard identity monad 
context passing representation simple monad suppose derive context passing implementation 
interested contexts observation applying value monad laws able put context form value ffl bind value ffl value ffl bind unit value ffl bind bind value ffl bind 
bind notice hole type final value computed may type call ans 
represent contexts type parameterised ans 
consequently obliged represent monad values type parameterised ans 
example define data cxt ans ans ans type ans cxt ans ans value ffl bind isn hard guess uses take form value optimise representation contexts data cxt ans ans value value ffl bind guess proves wrong harm done simply unable derive definitions monad operations 
letting value derive standard haskell accepted hbc provided type value explicitly 
unit value unit bind value st monad law bind value bind bind value bind 
bind rd monad law value bind prop 
value value bind unit nd monad law value unit prop 
prop 
value dropping superfluous constructor obtain definitions standard monad continuations 
type ans cxt ans ans type cxt ans ans unit bind value fig 

optimised context passing monad 
monads backtracking seen derive identity monad monad continuations vanilla monad specification 
reality wish add operations signature raison etre monads 
example ll consider operations backtracking fail orelse new operations form monoid fail orelse orelse fail orelse orelse orelse orelse specify interaction monad operations fail bind fail orelse bind bind orelse bind longer appropriate give value type value sensible behaviour value fail 
give type value data satisfying laws value fail value unit orelse observe backtracking computation succeeds fails succeeds observe answer 
apply methods derive implementations monad 
term representation backtracking monad start scratch develop term representation backtracking observe replace seq fail nil orelse cat operations unit satisfy exactly axioms section 
suggests try kind simplified terms section fail unit orelse define data fail reuse previously derived definitions unit fail orelse see derive implementations remaining operators 
case bind derive fail bind fail bind fail fail bind unit orelse bind unit bind orelse bind orelse bind terminating definition recursive call bind smaller argument case value find directly value fail value expected implement backtracking monad lists 
second equation distinguishes backtracking exception handling 
context passing implementation backtracking develop context passing implementation backtracking consider complex forms context section course new operations fail orelse may occur context 
just monad laws express contexts single bind monoidal properties fail orelse express contexts single orelse 
furthermore need consider contexts orelse nested inside bind ffl orelse bind ffl bind orelse bind sufficient consider contexts form value ffl bind orelse remember choice isn critical 
mistake point discover unable complete derivations operators 
may reasonably guess discover doing derivations uses context value orelse uses context value represent contexts type data cxt ans ans ans ans value value orelse value value ffl bind orelse antecedent says uses form expect represented applying plan store value natural require need value 
says case contexts interested represented 
assuming property antecedent value derive unit value unit bind orelse value orelse st monad law value prop 
prop 
fail value fail bind orelse value fail orelse value derivation bind little complicated complex property satisfies 
usual way bind value bind bind orelse value bind bind orelse rd monad law provided satisfies value value bind orelse right hand side equation equal value satisfy condition completing derivation bind derivation orelse straightforward orelse value orelse bind orelse value bind orelse bind orelse value bind orelse bind orelse associativity value bind orelse prop 
value prop 
derive value value value orelse fail value bind unit orelse fail value fail provided value value unit orelse right hand side equal take complete derivation 
simplify definitions slightly dropping constructor replacing context argument arguments putting results obtain definitions continuation passing implementation backtracking 
exercise 
consider state monad additional operations fetch st store st run st type ans ans ans ans ans unit bind fail orelse value fig 

context passing implementation backtracking 
satisfying fetch bind store unit store bind fetch store bind unit store bind store store run unit run fetch bind run run store bind run derive term context passing implementations operations 
specifying pretty printing shall return case study pretty printing 
start derive implementations pretty printing combinators develop specification 
case isn intuitively obvious laws pretty printing combinators satisfy 
need way guide intuition lead write right laws combinators 
mathematics guide intuition help example 
formulating hypothesis certain topological spaces think reals 
important formulating new concept group concrete model mind 
trying formulate theory model guide 
shall start looking model documents agree behaviour combinators 
model intended reasonable implementation thought kind denotational semantics combinators 
model establish algebraic properties combinators satisfy implementation 
properties established previous sections derive implementations 
layouts ll looking model pretty printer output indented text 
say output just string string little structure derive intuition 
say layout sequence indented lines model type layout int string notice shall allow indentations negative contribute nicer algebra just integers nicer algebra natural numbers 
notice restrict layouts non empty gamma type non empty lists 
ll return point 
specify text nest easily text nest right definition horizontal composition 
obvious 
desired behaviour clear text placed text layouts indented 
arguments occupy line 
choice guided principles dimensional structure argument preserved appearance 
page consist combination translation translation intention layout just pretty way displaying string 
string 
define string layout string string foldr phi map snd phi interpret line break white space equivalent single space 
expect string 
string string property enables programmer predict string 
represents thinking laid 
indentation appear middle line model fortunately represent 
really choice 
meets criteria translate second operand character character operand 
formally 
nest length gamma see definition reasonable consider examples 
cases operands single line result reasonable useful 
look formal definition 
defined non empty arguments 
reason restriction non empty layouts simply sensible definition 
empty arguments 
restriction unfortunate empty layout unit improving combinator algebra useful practice 
allow empty layouts simply arbitrary choice value 
cases algebraic laws involving 
cease hold 
way dilemma allow empty layouts define 
partial operator 
complicate development done 
algebra layouts formal definitions layout operators study algebra 
laws easily proved proofs included 





text nest nest nest nest 
nest 

nest 
nest nest nest nest 

text 
text 
text 
nest length text 
text text fig 

algebraic laws layout operations 

associative 
text right unit 

left unit indentation second operand lost 
example text 
foo foo excluded empty layouts units 
indentation combinator nest distributes distributes 
left 
need indent right operand 
translated abut left operand indentation lost 
reason nest cancelled right 
course consecutive nests combined nesting zero identity operation 

related kind associative law may say associate 
example 
bc 
hand 

indentation different cases example 
ab ab 
failure law hold pretty printing algebra interesting 
way transform expressions form 
special case know position ends indentation line example just text form text 
law sufficient text 
text 
text 
nest length say difficult part pretty printing transforming expressions law applicable 
simple law relating 
text 
sense laws completely specify layout operators closed terms denote layout proved equal laws 
exercise 
prove choosing canonical form layout expressions layout denoted unique canonical form deriving implementations operators map canonical forms canonical forms 
benefits formal approach formal specification layout operators fact reconstruction 
implementation constructed seat pants intuition combinators behaviour subtly different 
nest combinator inserted spaces vertical context operand top level 
consequence law nest 

held implementation context horizontal 
behaviour layout depended context give simple model previous section 
eleven laws hold 
user developer library deprived useful algebra 
user author pretty printer law means worry need think write left right hand side 
developer law simplifies optimisation original library hard optimise changing behaviour 
program deriving implementations algebra extremely difficult follow 
problems stemmed subtle error revealed writing formal specification 
documents layout operations enable construct individual layouts pretty printer course choose alternative layouts 
design decision separate construction alternatives choice layout 
represent collection alternatives set type doc layout require layout doc represent string programmer knows string pretty printed 
choice particular layout function best doc layout author pretty printer need construct set alternatives hard selecting best alternative done just reusing function best 
docs just sets layouts natural way promote layout operations docs 
just apply operation elements operand sets form set results example 
fl 
jl promoted operations distribute preserve example 



laws layout algebra linear sense variable appears left right hand side hold documents 
laws remain true docs 
course confine layout operations construct docs single element 
add operation multiple possible layouts 
require layouts document represent string union appropriate operator provide define operation forms union docs guaranteed represent string 
noting string string string tempting define 

text 
define operator forms union 
isn quite 
want choices consistently example may want allow 

alternatives allowing 

define ary operation gamma choices consistently sep doc doc sep xs foldr 
xs foldr xs ll revise definition slightly observe pleasing interaction sep nest 
consider example sep nest alternative layouts 
nest 
nest horizontal form unwanted extra indentation appears nest cancelled right 
consider example motivates slight refinement definition sep suppose wish pretty print pairs statements separated semicolon choosing horizontal vertical layouts 
define sep 
text example ae oe horizontal vertical layouts look fine 
consider cases horizontal layout ugly misleading 
redefine sep xs fit foldr 
xs foldr xs fit fl restricts horizontal form sep fit line 
algebraic properties fit simply stated see 
sep operator fewer useful properties develop need 
fit text text fit nest nest fit fit 
fit 
fit fit fit fit fit fit fig 

fit laws 
exercise 
define type syntax trees simple imperative language assignment statements combinators write pretty printer type 
choosing pretty layout designed combinators constructing documents possible layouts time discuss choosing alternatives 
aim simply avoid exceeding page width 
criterion tends produce layouts fits page described pretty 
impose additional constraint limiting number characters line excluding indentation smaller number 
idea avoid placing information line line begins left margin 
constraint example laid general pretty layout consist ribbon text page 
see reasonable ask layout infinitely wide page really place line 
say line meets constraints nice define nice length length page width width ribbon 
tempted specify pretty printer choose layout lines nice careful documents layout 
example text characters fit 
cases want pretty printer produce adopt ad hoc solution accept criteria met 
nice layout exists may want pretty printer choose 
consider example document sep theta 
characters 
characters 
characters document nice layout page width characters second 
unreasonably inefficient pretty printer decide split line document basis contents 
efficient pretty printer need limited look ahead expect layout chosen despite trouble ahead question layout pretty printer chooses trickier appears 
course sufficient say simply nice layout chosen layouts nice preferable 
define ordering layouts choose best 
defining ordering individual lines 
guiding principles different design decision possible choose play safe split line limited look ahead shows definitely unnecessary 
explored alternative 
nice line better overflowing line avoid overflowing better overflow little lot unnecessary line breaks avoided 
define nice nice nice nice nice nice length line length know test particularly simply nice nice case nice nice shorter 
second case nice nicer nice nicer shorter 
property implementations 
unfortunately ordering lines extend unique way ordering layouts arbitrary decision 
choose order layouts lexicographic extension ordering lines write reason choice simple lexicographic ordering decided left right hope pretty print documents left right look ahead 
define layout layout layout select lexicographically nicer arguments best int int doc layout best selects lexicographically layout set 
convenient introduce unit representing layout 
careful reader noticed partial order lines equal length holds need equal 
consequently best partial operations 
trouble document operations construct sets totally ordered evident derive implementations library 
consider task define layout nicer layout document need define layout nicer layout unrelated document 
investigate properties best 
ordering layouts lexicographic nest nest nest xr nest xr nest reformulate observation simple test follows length length length min text text length min text text properties fact best chooses element set derive laws best 
best best best best nest nest best gammak best text text best best xr best best fig 

best laws 
implementing pretty printing term representation developed collection algebraic properties pretty printing operators apply methods earlier sections chapter construct implementations 
reader may wondering just representation documents implementation say representing doc list possible layouts 
consider moment medium sized syntax tree imperative language contains occurrences pretty printed sep ignoring fact nesting may force seps related choices doc alternative layouts represented list elements 
reason expect best layout near clear searching list hopeless exercise 
deriving implementation term representation docs 
choose simplified terms best laws easily applicable suggests text nest want sure apply simplified test restrict form unions 
define class documents manifest line text text simplified test easily applicable documents form provided longer line 
permit unions form shall impose invariant line layout left operand strictly longer line layout right operand 
operands represent string follows layouts right operand consist lines 
define simplified terms nest allow top level result fit restrictions best union easily determined 
represent docs type data doc text string gamma gamma text string doc gamma gamma text doc union doc gamma gamma empty gamma gamma nest int doc gamma gamma nest careful construct documents form described 
type represent layouts doc involving union empty represents layout 
definition best easy derive applying best laws see 
ll discuss union case 
know best laws best union best xr best best choose layouts argument datatype invariant implies best text text best text length length simplified comparison applicable 
nice text text text lexicographic properties follows text text text text case chooses left operand 
nice text opposite holds 
implement case function simply inspects line operand 
haskell lazy evaluation exploited ways 
firstly shorter xs defined test length xs evaluating xs 
best text text best best best nest nest best gamma best union best best shorter min shorter xs null drop xs text fig 

definition best 
layouts may long lines example layout produced seps adopt horizontal form important optimisation 
secondly decision basis line argument select best layout union layout unsuccessful branch evaluated far line 
doc apply best may large tree follow evaluate single path 
definitions text nest 
obtained simple algebraic manipulation 
take just examples nest nest nest nest nest gammak nest nest gammak nest nest gammak text 
text 
text text 
text 
text text 
text nest length law text nest length nest length remaining equations derived similarly complete definitions appear 
easy verify definitions terminate 
leave reader check datatype invariant holds arguments holds result operators 
interesting look way unions treated definitions 
case unions arguments floated upwards give union result 
exception union right argument property reason violate datatype invariant operands union right hand side lines 
reason efficiency doc form chosen groups layouts line value form best function reject layouts go nice 
may represent billions text text nest nest text nest nest nest gammak union union text 
text text text 
nest length text 
nest text 
text 
union text 
union text 


nest 
nest 
union 

union 
fig 

definitions text nest 

alternative layouts unions floated top level best reject individually 
cost prohibitive library simply 
need implement sep recall specification sep xs fit foldr 
xs foldr xs directly implementation ensure union formed 
firstly result fit avoid creating union empty operand 
secondly ensure line result fit strictly longer lines second operand 
provided xs consists documents guaranteed longest line xn longest line horizontal form contains extra space 
xs consists exactly document horizontal vertical forms union badly formed 
treat special case 
thirdly avoid constructing union nested operands happen doc list form nest case factor nest sep nest xs fit nest 
foldr xs nest foldr xs nest fit 
foldr xs nest foldr map nest gammak xs nest sep map nest gammak xs definitions sep fit appear 
notice datatype invariant lets define fit union efficiently know layouts second operand consist lines 
sep sep nest xs nest sep map nest gammak xs sep xs fit foldr 
xs foldr xs empty union fit text text fit empty fit nest case fit empty empty nest fit union fit fig 

definition sep complete implementation library just need define function mapping layouts appropriate strings 
define layout int doc string layout constructs string displaying nest suitable definition appears 
layout text indent layout indent layout layout nest layout indent nt indent gamma indent indent gamma indent nn fig 

mapping layouts strings 
minor optimisations 
example best union union tests twice nice reject reject easily avoided say redefining best return pair best layout boolean indicating line nice 
measures bring useful improvement performance fact serious problem remains 
consider example sep sep sep hello hello hello hello hello document displayed page width layout chosen layout different line implementation construct reject 
soon length hello known clear innermost sep laid vertically 
go immediately fourth layout 
large documents sep may nested deep optimisation important 
complexity depth sep nesting practice pause embarrassingly long time pretty printing gradually speeding sep decisions resolved 
incorporate optimisation need change representation documents 
optimised pretty printing term representation looking back problematic example see layouts common prefix hello tell just prefix layouts nice line 
goal factor common prefix express union layouts hello 
suitable reject favour fourth 
able observe situation introduce text 
simplified form 
time replace simplified forms text text text text old forms expressed terms new ones follows text text 
text text text 
text nest need allow places intend property fit text 
text 
fit right hand side canonical form component fit empty 
don want test empty set course fit hyper strict disastrous consequences 
new simplified forms grammar nest text text text 
impose condition unions layout operand longer line layout second 
simplified forms represented datatype data doc nil gamma gamma text nilabove doc gamma gamma text string textbeside doc gamma gamma text 
nest int doc gamma gamma nest doc union doc gamma gamma empty gamma gamma key problem rederive sep delay introducing union common prefix branches sep produced 
need algebraic law permitting draw prefix sep try prove 
assuming xs non empty sep text 
xs fit text 

foldr 
xs text 
foldr xs text 
fit text 

foldr 
xs text 
text 
foldr map nest xs text 
sep text 
map nest xs step holds nest cancelled introduced freely horizontal alternative 
seen move nest sep move union sep argument splitting sep branches explored separately 
fact time argument nil point horizontal vertical alternatives differ character really alternative 
derived definition sep 
auxiliary function specified sep ys sep map nest ys avoid repeated applications nest remaining arguments 
implementations operators derived usual way time skip details 
resulting definitions 
leave reader check datatype invariant satisfied 
fact quite implemented definitions 
heap profiling revealed derived definition leaks space unevaluated calls nest collect heap 
introduced rd th equations unfortunately passed recursive call usually introduces unevaluated applications 
solution avoid constructing unevaluated applications auxiliary function nest 
course just specification derived implementation appears 
important second parameter sep sep ys sep ys sep nil ys fit foldl 
nil ys union vertical nil ys sep nilabove ys vertical nilabove ys sep textbeside ys textbeside sep nil 
gamma length ys sep nest ys nest sep gamma ys sep union ys sep ys union vertical ys sep empty ys empty vertical ys nest foldr ys fig 

sep optimised delay union 
text textbeside nil nest nest nil 
nest nil 
nil 
nilabove 
nilabove 
textbeside 
textbeside 
nest 
nest 
union 

union 
empty 
empty nil nilabove nilabove nilabove textbeside textbeside nil 
nest nest nest nest gammak union union empty empty fig 

implementations text nest 

evaluated strictly heap fill unevaluated subtractions 
arrange hbc standard function seq evaluates returns value derive implementation best 
case best text 

know equal text 

clearly depends length affects width ribbon available line introduce new function best defining property best text 
text 
best derive definition best algebra details nil nilabove nest nilabove nilabove textbeside seq textbeside nil 
gamma length nest seq nest gamma union union empty empty fig 

defining space leak 
time 
text 
best nil best text 
text best text text text 
nil take best nil nil 
text 
best nilabove best text 
text best text nest length text nest length best gamma length text 
text best gamma length take best nilabove nilabove best gamma length textbeside case text 
best textbeside best text 
text 
text 
text 
best take best textbeside textbeside best nest case simple text 
best nest best text 
nest best text 
text 
best best nest best text 
best union best text 
best text 
best text 
text 
best text 
best text 
best best introduced new operator defining property text 
text 
text 
recall invariant unions satisfy chooses left argument line nice 
longer min text 
nice line 
case choose right argument looking 
optimisation trying capture just looking common prefix select right branch vertical form sep union came 
complete definition best appears 
best nil nil best nilabove nilabove best best textbeside textbeside best best nest nest best gamma best union best best best empty best nil nil best nilabove nilabove best gamma length best textbeside textbeside best best nest best best union best best best empty fits min length fits false case nil true nilabove true textbeside fits length false fig 

optimised definition best 
minor improvements implementation 
quite substantial speed obtained storing strings length strings represented library pair length characters 
string concatenation heavily library performed constant time consists addition lengths composition characters represented function section 
implementation library major improvement previous ones 
embarrassing pauses 
cost pretty printing grow slightly faster linearly library able produce large outputs little space reasonable time 
sparc elc benchmark program deeply nested seps evaluated seps second 
performance quite acceptable far superior earlier term implementation seat pants implementation exponential 
context passing pretty printer key observation development efficient combinators section sep text 
xs text 
sep text 
map nest xs factor text element sep splitting computation union alternatives 
exploited observation making text 
simplified form testing sep equally derived context passing implementation text tests presence enclosing sep natural think doc function chooses layout depending context implementation combinators constructed 
kind contexts consider 
certainly observations form best ffl able lay document page ribbon width 
need lay documents indentation consider contexts form best nest ffl 
take form subsumes 
imagine union appears context 
simplify follows best nest best nest best nest expect continue working able represent contexts form best nest ffl 
think layout choose forced backtrack 
conditions unions enable decide choose purely basis value course order apply key optimisation able recognise document element enclosing sep shall need contexts form sep ffl yn 
optimisation applies documents form text 
document appears top level shall need evaluate best nest text 
able evaluate need able represent context expression 
shall add contexts form text 
ffl cover case 
lay 
shall start laying represent contexts ffl 
ffl 
expand sep union alternatives horizontal alternative appears inside fit 
represent contexts form fit ffl 
choose contexts forms ffl best nest ffl best nest ffl text 
ffl sep ffl fit ffl ffl 
ffl represents integer expressions represents document expressions 
contexts represented haskell datatype data cxt int int int int int int doc textbeside string cxt sep doc cxt fit cxt doc cxt doc cxt consider complex contexts apply laws algebra simplify 
unfortunately unable eliminate forms context 
certainly context simplifications possible 
particular move textbeside top level observation key optimisation 
usefully combine textbeside enclosing way express textbeside instance best nest text 
ffl equal best nest ffl text 
general 
facts fit sep zs foldr zs 

simplify contexts occurs inside fit sep 
move top level apply best nest best nest best nest alas simplify text 
knowing fact form context simplified away just complex set 
contexts chosen actual derivation implementation follows exactly method earlier sections 
go details 
simply just previous section implementation space leak 
pending applications nest fill heap 
avoid just previous section combine application nest operators 
case define forms context built nest ffl nest ys sep ffl map nest ys derived implementation exploit sep text 
xs text 
sep text 
map nest xs corresponding property just change number context building applications nest 
evaluation context passing combinators version pretty printing library definitely complex term versions consequence complex forms context forced 
harder modify particular change way best layout chosen far reaching effects 
term libraries best separate function may replaced altering rest library 
library combinator knows behave context criterion selecting best layout distributed code 
fair price pay better performance 
implementation context passing library little slower term uses little space 
advantage require lazy evaluation term library traversing path enormous tree efficient 
reimplement pretty printing library strict functional language ml context passing version prove efficient simulating laziness nullary functions 
relationship original implementation implementation combinators context passing contexts represented tuple containing page width ribbon width length text left text 
ffl boolean forcing line layout fit ffl boolean indicating surrounding context horizontal vertical 
design natural intuitively expects pretty printer just maintain little state context guide layout choices 
seen context information sufficient implement correct behaviour combinators obstacle discovery simple specification satisfy 
performance combinators poor exponential depth sep nesting improved square 
optimisations hard find lack algebra doubt necessary complexity solution efficient context passing library described section stumble accident 
implementation developed rapidly usefulness certainly inspiration develop solutions chapter 
retrospect seemingly natural choice context passing implementation unfortunate 
abandoning choice working specification systematic program development led better behaviour efficient implementations 
comparison oppen pretty printer classic language independent pretty printing oppen pretty printer 
defined small language expressing documents interpreter language generates pretty layout 
output user pretty printer intended piped interpreter 
interpreter written imperative language space requirements small 
similarity oppen language pretty printing combinators striking 
oppen provides equivalents text sep nest language express formed documents contain 
oppen provides variant sep places elements fit line places line 
equivalent combinator usefully added pretty printing library 
hand oppen interpreter quite large hard understand 
describes behaviour formed inputs interpreter accepts wider class inputs behaviour hard predict 
interpreter defines meaning program monolithic way way describe meaning construct isolation 
isn clear possible layouts interpreter chooses 
way regard pretty printing combinators candidate denotational semantics oppen language 
oppen interpreter probably efficient combinators hand libraries probably easier modify 
example pretty printer look ahead lines avoid imminent line overflows breaking lines earlier making decisions basis current line just need redefine best function 
implementations described combinators reused 
clear changes need oppen interpreter achieve effect 
exercise 
specify implement oppen sep variant allows elements line vertical layout 
warning substantial exercise 
chapter considered design combinator libraries 
saw studying algebraic properties combinators desired help suggest natural choices representation guide implementation operators 
saw examples lists monads pretty printing library 
kind program development need language higher order functions lazy evaluation equational reasoning valid words haskell ideally suited 
case pretty printing studying algebra led correction subtle error combinators behaviour development efficient implementations 
pretty printing algebra just intricate rely intuition working informally see implement optimisation considered section invent representation 
formal approach invaluable 
pretty printing library proved useable despite simplicity 
versions seen quite extensive program transformation tools proof assistants compilers 
pretty printers chalmers glasgow haskell compilers written variants design 

lennart augustsson haskell user manual available www www cs chalmers se pub haskell chalmers 

konstantin laufer combining type classes existential types proc 
latin american informatics conference panel cem mexico september 

derek oppen pretty printing acm transactions programming languages systems vol 
october 
optimised pretty printing library module doc text sep nest pretty import seq infixl 
infixl data doc nil text nilabove doc text str textbeside doc text 
nest int doc nest doc union doc empty deriving text type str int string string optimised rep strings fast length fast concat 
len cat str length string text str textbeside nil nest nest nil nilabove nest nilabove nilabove textbeside seq textbeside nil len nest seq nest union union empty empty nil 
nest nil 
nil 
nilabove 
nilabove 
textbeside 
textbeside 
nest 
nest 
empty 
empty union 

union 
sep sep ys sep ys sep nil ys fit foldl 
nil ys union vertical nil ys sep nilabove ys vertical nilabove ys sep textbeside ys textbeside sep nil 
len ys sep nest ys nest sep ys sep union ys sep ys union vertical ys sep empty ys empty vertical ys nest foldr ys 

text 
fit nil nil fit nilabove empty fit textbeside textbeside fit fit nest nest fit fit union fit fit empty empty best nil nil best nilabove nilabove best best textbeside textbeside best best nest nest best best union best best best empty empty best nil nil best nilabove nilabove best len best textbeside textbeside best cat best nest best best union best best best empty empty str fits min len fits false case nil 
true nilabove 
true textbeside 
fits len empty 
false layout nest layout layout layout layout nil layout nilabove layout layout textbeside string layout len pretty layout best article processed macro package llncs style 
