efficient chaotic iteration strategies widenings francois bourdoncle digital paris research laboratory centre de avenue victor hugo ecole des mines de paris france sophia antipolis tel france bourdoncle prl dec com 
interpretation formal method enables static automatic determination run time properties programs 
method uses characterization program invariants greatest fixed points continuous functions complete lattices program properties 
study precise efficient chaotic iteration strategies computing fixed points lattices infinite height speedup techniques known widening narrowing 
strategies weak topological ordering dependency graph system semantic equations associated program minimize loss precision due widening operators 
discuss complexity implementation issues give precise upper bounds complexity intraprocedural interprocedural interpretation higher order programs structure control flow graph 
interpretation formal method enables static automatic determination run time properties programs range congruence properties integer variables linear inequalities variables data aliasing method characterization programs invariants greatest fixed points continuous functions complete lattices classically computed iterative computations starting smallest element largest element lattice 
efficient computation extremal fixed points functions lattices finite height classical topic :10.1.1.14.711
unfortunately interpretation deal lattices infinite large height 
instance values integer variables program coded bits lattice intervals compute maximum range variables height iterative computations extremal fixed points functions lattice worst case complexity unacceptable practice 
speed techniques known widening narrowing designed determine safe approximations extremal fixed points continuous function lattices infinite height non complete lattices complete partial orders 
control flow graph program analyzed known advance case intraprocedural interpretation fixed point equation solved amounts system equations equation associated control point case widening techniques require widening generalization operators applied control point set widening points cycle dependency graph system cut widening point 
course possible choose leads poor results 
propose efficient precise algorithms computing approximate fixed points continuous functions lattices infinite height appropriate widening narrowing operators 
organized follows 
section review classical notions widening operators narrowing operators chaotic iterations 
section introduce notion weak topological ordering directed graphs generalizes notion directed acyclic graphs 
show notion suited design chaotic iteration strategies widenings give worst case complexity corresponding algorithms 
section algorithms computing weak topological orderings different price performance ratios 
section apply previous theoretical framework intraprocedural interpretation programs 
section describe simple algorithm interprocedural interpretation higher order programs control flow graph known advance deduce worst case complexity canonical weak topological ordering interprocedural call graph 
chaotic iterations central problem interpretation program compute greatest solution system semantic equations form 
index represents control point program function continuous function lattice program properties computes property holding point program step executed point leading dependency graph system graph set vertices edge depends th parameter possible jump point point executing single program step 
cases graph identical control flow graph program 
sake simplicity shall suppose point entry point program point reachable 
naive algorithm solving system consists applying equation parallel vector stabilizes starting greatest element lattice height lattice height delta delta equations applied solution reached 
algorithm far optimal follow control flow program recomputes program property associated control point iteration step 
continuous monotonic sequential algorithm la gauss seidel provided equation applied infinitely times 
algorithms called chaotic iteration algorithms particular choice order equations applied called chaotic iteration strategy 
dependency graph acyclic optimal linear iteration strategy consists applying equations topological ordering set vertices dependency graph loops program method applicable 
furthermore naive algorithm effectively applied compute fixed points height lattice large infinite lattice intervals 
speed technique pioneered patrick radhia cousot consists choosing subset replacing equation equation widening operator safe approximation upper bound increasing chain chain defined eventually stable 
cycle dependency graph contains element chaotic iteration strategy guaranteed terminate stabilize safe approximation fixed point post fixed point 
similarly narrowing operators improve post fixed points determined widening operators compute safe approximations greatest fixed points 
widening operators generally lead important loss precision essential small possible 
unfortunately problem finding minimal set happens classical problem minimal feedback vertex set np complete problem worst case complexity naive algorithm quadratic finding set far costly 
distinct problems solved ffl determine iteration strategy order apply equations 
ffl determine set widening points problem addressed authors knowledge algorithm exists finding sets widening points authors mention widening operators improperly 
section introduce notion weak topological ordering directed graph show notion yields interesting answer problems 
particular contrary done authors iteration strategies propose guided structure dependency graph dynamically selected ad hoc data structures lists 
shall see fl fl fl fl fl fl fl fl intraprocedural dependency graph property ensures excellent theoretical upper bounds complexities resulting algorithms 
weak topological ordering definition definition hierarchical ordering hierarchical ordering set parenthesized permutation set consecutive 
hierarchical ordering set defines total order elements matching parentheses called component element component called head 
call set heads nested components containing set components heads 
define depth ffi element depth contained component 
definition weak topological ordering weak topological ordering directed graph short hierarchical ordering vertices edge oe edge called feedback edge 
directed graph head feedback edge head component containing tail instance dependency graph decomposition consists nested components heads instance feedback edge 
note parentheses topological ordering directed graph set vertices ng trivial delta delta delta nested components 
theorem shows naturally defines admissible set widening points 
theorem widening points set components heads dependency graph system semantic equations admissible set widening points 
proof 
delta delta delta cycle distinct elements 
exist oe oe delta delta delta oe oe shows case cycle cut widening point proves theorem 
course widenings costly terms precision attempt minimize cardinal trivial interesting respect 
iteration strategies seen dependency graph useful determining sets widening points defines chaotic iteration strategies 
strategy called iterative strategy simply applies equations sequence stabilizes outermost components second strategy called recursive strategy recursively stabilizes subcomponents component time component stabilized 
instance graph yields iterative strategy iterate stabilization operator recursive strategy easy see strategies correct vertex depth edge necessarily listed oe value computation final value implies necessary iterate vertices depth 
note idea forms heart method described jones strongly connected components listed topological order section 
approach superior give algorithms computing fixed points strongly connected systems semantic equations brute force algorithm 
theorem iterative strategy iterative strategy stabilization outermost component detected stabilization widening points 
proof 
suppose consists single outermost component 
going show applying equations sequence semantic values associated widening point increased changed 
suppose contrary holds value associated vertex changed 
definition edge oe exists vertex oe value changed iteration 
hypothesis inductive application argument shows head component changed absurd 
theorem recursive strategy recursive strategy component detected stabilization head 
proof 
suppose consists single outermost component applying equations stabilizing sub components value associated head component remains unchanged recomputation 
argument prove fact iteration necessary vertices depth shows values associated vertices component won change equations applied 
stabilization component head imply stabilization entire component 
theorems show iterative recursive strategies minimize number comparisons elements lattice program properties useful test costly interpretation functional logic programs instance 
note ordering explicitly algorithm improve precision force convergence computation post fixed point widening operator stable satisfy theorem gives upper bound complexity strategy 
theorem complexity lattice finite height increasing chains built widening operator length maximum complexity iterative iteration strategy strongly connected graph delta jcj delta jwj maximum complexity recursive iteration strategy delta ffi proof 
theorem shows iteration yields strictly greater element lattice jwj height delta jwj result trivial 
second result easily proved inductively showing equation vertex depth applied delta sub component depth stabilized delta times 
detailed proof bourdoncle 
complexity recursive iteration strategy linear function sum individual depths vertices graph 
interesting ffi jwj vertex upper bound recursive iteration strategy better iterative strategy 
practice shows recursive strategy better iterative strategy 
furthermore flow graphs clear worst case strategy program size obtained trivial delta iterative strategy delta delta delta delta delta delta recursive strategy 
results show number widening points impact precision fixed point computation impacts cost analysis 
essential goal minimize number widening points sum individual depths graph vertices 
section presents algorithms different price performance ratios compute weak topological orderings directed graphs relate previous works 
algorithms depth numbering idea building non trivial graph depth numbering graph obtained linear time open parenthesis head edges tail greater number close parentheses vertex 
instance algorithm yield result graph better trivial optimal ordering note algorithm tendency overestimate number widening points 
instance graph left yield widening points graph single cycle 
shown bourdoncle set heads retreating edges depth spanning tree edges ancestor tree smaller admissible set widening points 
graph left retreating edge set widening points 
gamma gamma oe gamma gamma limit flow graph consequently decomposition basis iteration strategy widening points detected retreating edges depth spanning tree easily stack currently visited vertices depth visit graph 
spite drawbacks advantage algorithm simple incremental applied graph known advance interpretation higher order programs section 
reducible graphs dependency graph reducible case structured programming languages goto statement suggested choose widening points heads intervals graph head back edge 
idea pushed step build graph iteration strategy 
idea consists computing limit flow graph obtained iteratively collapsing graph intervals 
graph reducible process guaranteed converge limit graph reduced single vertex containing vertices original graph 
process illustrated reducible graph gives result note interval parenthesized exists feedback edge vertex header prove resulting decomposition graph thing show head feedback edge header interval containing property trivially holds belong interval level 
denote interval merged distinct intervals containing containing computation limit flow graph 
known prop 
necessarily header vertex interval head property holds 
proper vertices listed feedback edge edge incompatible fact added algorithm worst case complexity equal ffi delta delta ff ffi depth graph number edges ff inverse ackerman function nearly constant 
note iteration strategies built algorithm similar ones described burke data flow analysis framework 
strongly connected components reducible graphs extensively studied literature unfortunately interprocedural dependency graphs reducible general 
instance graph unfolded version graph function fact reducible head back edge dominate tail path go base algorithm propose case algorithm due tarjan compute linear time strongly connected components directed graph 
tarjan algorithm computes list possibly trivial strongly connected components topological order basic idea algorithm recursively apply tarjan algorithm non trivial component having removed head back edges form note denotes list constructor operator 
theorem algorithm computes directed graph 
proof omitted sake brevity bourdoncle 
note graph reducible interval algorithm give better results 
instance depending order graph vertices visited algorithm gives results graph right interval algorithm gives optimum result excellent decompositions obtained non reducible graphs graph worst case complexity algorithm ffi delta ffi maximum depth graph vertices number edges 
algorithm cost fixed point computation complexity linear function intrinsic complexity graph 
note knowledge hierarchical decompositions directed graphs components weak topological orderings perform chaotic iteration strategies widenings 
function partition var vertex partition foreach vertex vertices dfn vertex num partition nil visit root partition return partition function component vertex var succ partition partition nil foreach succ succ vertex dfn succ visit succ partition return vertex partition function visit vertex inout partition var head min succ element loop push vertex head dfn vertex num num loop false foreach succ succ vertex dfn succ min visit succ partition min dfn succ min head head min loop true head dfn vertex dfn vertex pop element loop element vertex dfn element pop element partition component vertex partition partition vertex partition return head hierarchical decomposition directed graph strongly connected components subcomponents 
function fact integer integer fl fl fact fl fl fact fact gamma fl fl interprocedural dependency graph intraprocedural interpretation algorithm directly applicable intraprocedural interpretation implemented debugger 
advantage computed analysis resulting chaotic iteration strategy minimizes widening operators number tests needed detect stabilization iterative computations 
furthermore algorithm predictable worst case complexity program loops delta delta gamma gamma program nested loops 
interprocedural interpretation method previous section applicable interprocedural interpretation order program higher order programs dependency graph known advance 
incremental algorithm section determined algorithm generic form delta delta delta delta delta delta delta delta delta delta delta delta iterative strategy easier implement corresponds straightforward depth execution program 
furthermore note point necessarily entry point procedure head intraprocedural loop return point procedure call property worst case complexity interprocedural interpretation program 
theorem program procedures control points procedure calls intraprocedural loops interpretation lattice height iterative iteration strategy worst case complexity delta delta ae delta delta ae sum densities procedure calls intraprocedural loops inverse average size procedures 
furthermore procedure higher order program procedural formal parameters computation interprocedural call graph program worst case complexity ae delta delta delta note hinted section depth visit interprocedural dependency graph allows line determination better set widening points fa practice sufficient widening operators head intraprocedural loops entry exit points formally recursive procedures opposed return points procedure calls 
note algorithm proposed le charlier fact particular implementation basic functional partitioning uses widening operators entry point logic predicate exit point 
justified context noetherian domains infinite strictly increasing chain algorithm loop domain infinite height 
addressed problem efficient computation greatest fixed points continuous functions lattices infinite height widening narrowing operators 
introduced notion weak topological ordering directed graphs shown notion determine admissible sets widening points design efficient chaotic iteration strategies 
different price performance ratios compute weak topological orderings directed graphs shown apply intraprocedural interprocedural interpretation higher order languages 
design incremental version algorithm handle interprocedural interpretation higher order programs efficiently 
alfred aho ravi sethi jeffrey ullman compilers principles techniques tools addison wesley publishing francois bourdoncle interprocedural interpretation block structured languages nested procedures aliasing proc 
international workshop plilp lecture notes computer science springer verlag francois bourdoncle interpretation dynamic partitioning journal functional programming vol 
francois bourdoncle des langages ordre interpretation ph dissertation ecole polytechnique francois bourdoncle debugging higher order imperative languages proc 
sigplan conference programming language design implementation michael burke interval approach exhaustive incremental interprocedural data flow analysis acm transactions programming languages systems vol 
num 
patrick radhia cousot interpretation unified lattice model static analysis programs construction approximation fixpoints proc 
th acm symp 
popl patrick cousot asynchronous iterative methods solving fixpoint system monotone equations research report imag rr universit scientifique de grenoble patrick cousot nicolas halbwachs automatic discovery linear constraints variables program proc 
th acm symp 
popl patrick cousot ethodes de construction approximation de points fixes op erateurs sur un treillis 
analyse de programmes ph dissertation universit scientifique de grenoble patrick cousot semantic foundations program analysis muchnick jones eds analysis theory applications prentice hall alain deutsch determining lifetime aliasing dynamically allocated data higher order functional specifications proc 
th acm symp 
popl alain deutsch model aliasing abstractions finite representations right regular equivalence relations proc 
ieee international conference computer languages ieee press michael 
garey david johnson computers intractability guide theory np completeness freeman philippe granger static analysis arithmetical congruences international journal computer mathematics larry jones efficient evaluation circular attribute grammars acm transactions programming languages systems vol 
num 
le charlier van hentenryck generic interpretation algorithm complexity analysis furukawa editors proc 
international conference logic programming mit press le charlier van hentenryck universal top fixpoint algorithm technical report institute computer science university namur belgium keefe finite fixed point problems 
lassez editor proc 
fourth international conference logic programming mit press tarjan depth search linear graph algorithms siam comput tarjan improved algorithm hierarchical clustering strong components information processing letters elsevier science publishers 

