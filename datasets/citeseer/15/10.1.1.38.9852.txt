taxonomy obfuscating transformations christian collberg clark thomborson douglas low technical report department computer science university auckland private bag auckland new zealand 
cs auckland ac nz common distribute software forms retain information original source code 
important example java bytecode 
codes easy decompile increase risk malicious reverse engineering attacks 
review techniques technical protection software secrets 
argue automatic code obfuscation currently viable method preventing reverse engineering 
describe design code obfuscator tool converts program equivalent difficult understand reverse engineer 
obfuscator application code transformations cases similar compiler optimizers 
describe large number transformations classify evaluate respect potency degree human reader confused resilience automatic attacks resisted cost overhead added application 
discuss possible techniques program slicing possible countermeasures obfuscator employ 
time effort determination competent programmer able reverse engineer application 
having gained physical access application reverse engineer decompile disassemblers decompilers analyze data structures control flow 
done manually aid reverse engineering tools program 
new problem 
problem received relatively little attention software developers 
reason programs large monolithic shipped stripped native code making difficult impossible reverse engineer 
situation changing 
common distribute software forms easy decompile reverse engineer 
important examples include java bytecode architecture neutral distribution format andf 
java applications particular pose problem software developers 
distributed internet java class files hardware independent virtual machine code retains virtually information original java source 
class files easy decompile 
computation takes place standard libraries java programs small size relatively easy reverse engineer 
main concern java developers outright reengineering entire applications 
relatively little value behavior clearly violates copyright law handled 
developers frightened prospect competitor able extract proprietary algorithms data structures applications order incorporate programs 
give competitor commercial edge cutting development time cost difficult detect pursue legally 
point particularly valid small developers may ill afford lengthy legal powerful corporations unlimited legal budgets 
purpose discuss various forms technical protection intellectual property available software developers 
re transformation control obfuscation data obfuscation obfuscation layout transformation target technical protection encryption partial server side execution trusted native code obfuscation legal protection intellectual protection obfuscation layout change formatting remove comments scramble identifiers preventive transformations explore weaknesses current decompilers explore inherent problems known techniques reducible non reducible flow graphs table interpretation outline statements inline method unroll loop reorder expression split variables procedure convert static data promote scalars preventive objects variables change variable lifetimes modify inheritance relations merge arrays split fold reorder methods reorder instance variables reorder arrays ordering cost potency resilience targeted inherent aggregation ordering computations control obfuscation condition extend loop clone methods reorder statements reorder loops data obfuscation aggregation storage encoding change encoding merge scalar classification kinds protection malicious reverse engineering quality obfuscating transformation information targeted obfuscating transformation layout data control preventive 
strict discussion java programs distributed internet java class files results apply languages formats 
argue reasonable approach protection mobile code code obfuscation 
furthermore number obfuscating transformations classify effectiveness efficiency show put automatic obfuscation tool 
remainder structured follows 
section give overview different forms technical protection software theft argue code obfuscation currently affords economical prevention 
section give brief overview design code obfuscator java currently construction 
sections describe criteria classify evaluate different types obfuscating transformations 
main contributions contained sections catalogue obfuscating transformations 
section give detailed obfuscation algorithms 
conclude summary results discussion directions code obfuscation section 
protecting intellectual property consider scenario 
alice small software developer wants applications available users internet presumably charge 
bob rival developer feels gain commercial edge alice access application key algorithms data structures 
seen player game adversaries software developer alice tries protect code attack reverse engineer bob task analyze application convert form easy read understand 
note necessary bob convert application back close alice original source necessary reverse engineered code understandable bob programmers 
note may necessary alice protect entire application bob probably consists bread butter code real interest competitor 
alice protect code bob attack legal technical protection 
copyright law cover software artifacts economic realities difficult small alice enforce law larger powerful competitor 
attractive solution alice protect code making reverse engineering technically difficult impossible economically 
early attempts technical protection described 
secure approach alice sell application sell services 
words users gain access application connect alice site run program remotely paying small amount electronic money time 
advantage alice bob gain physical access application able reverse engineer 
downside course due limits network bandwidth latency application perform worse run locally user site 
partial solution break application parts public part runs locally user site private part contains algorithms alice wants protect run remotely 
approach alice encrypt code sent users 
unfortunately works entire decryption execution process takes place hardware 
systems described herzberg wilhelm 
code executed software virtual machine interpreter case java bytecodes possible bob intercept decompile decrypted code 
java gained popularity mainly architecture neutral bytecode 
clearly facilitates mobile code decrease performance order magnitude comparison native code 
predictably lead development just intime compilers translate java bytecodes native code fly 
alice translators create native code versions application popular architectures 
downloading application user site identify architecture operating system combination running corresponding version transmitted 
having access native code bob task difficult impossible 
complication transmitting native code 
problem java bytecodes subjected bytecode verification execution native codes run complete security user machine 
alice trusted member community user may accept assurances application harmful user 
sure tries contaminate application alice digitally sign codes transmitted prove user code original written 
final approach going consider code obfuscation 
basic idea alice run application obfuscator program transforms application functionally identical original difficult bob understand 
belief obfuscation viable technique protecting software trade secrets receive attention deserves 
server side execution code obfuscation completely protect application malicious reverse engineering efforts 
time determination bob able dissect alice application retrieve important algorithms data structures 
aid effort bob may try run obfuscated code automatic deobfuscator attempts undo obfuscating transformations 
level security reverse engineering obfuscator adds application depends sophistication transformations employed obfuscator power available algorithms amount resources time space available deobfuscator 
ideally mimic situation current public key cryptosystems dramatic difference cost encryption finding large primes easy decryption factoring large numbers difficult see fact obfuscating transformations applied polynomial time require exponential time 
client source object code server alice response bob compile request client source object code server alice decompile bob bread butter code code object code source bread butter code compile request response protection server side partial server side execution 
design java obfuscator outlines design java obfuscation tool java currently development 
input tool java application set java class files 
user selects required level obfuscation potency maximum execution time space penalty obfuscator allowed add application cost 
reads parses class files library files referenced directly indirectly 
complete inheritance tree constructed symbol table giving type information symbols control flow graphs methods 
contains large pool code transformations described 
applied preprocessing pass collect various types information application 
kinds information gathered standard compiler techniques inter procedural dataflow analysis data dependence analysis provided user gathered spe root piper slightly drink south pacific 
techniques 
pragmatic analysis example analyses application see sort language constructs programming idioms contains 
information gathered preprocessing pass select apply appropriate code transformations 
types language constructs application subject obfuscation classes split merged methods changed created new control data structures created original ones modified new constructs added application selected similar possible ones source application pragmatic information gathered preprocessing pass 
transformation process repeated required potency achieved maximum cost exceeded 
output tool new application functionally equivalent original normally set java class files 
tool able produce java source files annotated information transformations applied obfuscated code relates original source 
annotated source useful debugging 
encrypted object code client source object code bob decrypt decompile encrypt source object code server encrypted object code alice compile protection encryption 
server source native code native sparc code signed native code signed code request code client source signed native code verify code trusted host decompile alice bob compile sign protection signed native code 
client source object code server alice decompile bob obfuscated object code obfuscated object code object code source compile obfuscate protection obfuscation 
inheritance hierarchy id name kind type method theta class symbol table constant pool data flow analysis pragmatic analysis analysis data dependence source application java class files standard library java class files target application apply java class files annotated java source files target application low high potency low high max cost update data structures user interaction profiling data transformation pool control flow graphs cfgs select architecture java obfuscator 
main input tool set java class files obfuscation level required user 
user may optionally provide files profiling data generated java profiling tools 
information guide obfuscator sure frequently executed parts application obfuscated expensive transformations 
classifying obfuscating transformations remainder describe classify evaluate various obfuscating transformations 
start formalizing notion obfuscating transformation definition obfuscating transformation gamma 
transformation source program target program gamma 
obfuscating transformation observable behavior 
precisely order gamma 
legal obfuscating transformation conditions hold ffl fails terminate terminates error condition may may terminate 
ffl terminate produce output observable behavior defined loosely behavior experienced user 
means may side effects creating files sending messages internet long side effects experienced user 
note require equally efficient 
fact transformations result slower memory main dividing line different classes obfuscation techniques shown 
primarily classify obfuscating transformation kind information targets 
simple transformations target lexical structure layout application source code formatting names variables sophisticated transformations interested target data structures application flow control 
secondly classify transformation kind operation performs targeted information 
seen figures transformations manipulate aggregation control data 
transformations typically break abstractions created programmer construct new bogus abstractions bundling unrelated data control 
similarly transformations affect ordering data control 
cases order items declared computations performed effect observable behavior program 
useful information embedded chosen order programmer wrote program reverse engineer 
closer items events space time higher likelihood related way 
ordering transformations try explore randomizing order declarations computations 
evaluating obfuscating transformations attempt design obfuscating transformations need able evaluate quality transformation 
section attempt classify transformations criteria obscurity add program difficult break deobfuscator computational overhead add obfuscated application 
measures potency define means program obscure complex unreadable program metric definition vague part human cognitive abilities 
fortunately draw vast body software complexity metrics branch software engineering 
field metrics designed intent aid construction readable reliable maintainable software 
metrics frequently counting various textual properties source code combining counts measure complexity 
formulas proposed derived empirical studies real programs purely speculative 
detailed complexity formulas metrics literature little interest derive general statements programs identical contains property complex statement attempt construct transformation adds property program knowing increase obscurity 
table paraphrase popular complexity measures 
software construction project goal minimize measures 
contrast obfuscating program want maximize measures 
complexity metrics allow formalize concept potency remainder article measure usefulness transformation 
informally transformation potent job confusing bob hiding intent alice original code 
words potency transformation measures difficult obfuscated code understand human original code 
formalized definition definition transformation potency behavior conserving transformation gamma 
transforms source program target program complexity defined metrics table 
pot potency respect program measure extent changes complexity defined pot def gamma potent obfuscating transformation pot 
purposes measure potency point scale medium highi 
observations table possible list desirable properties transformation order potent obfuscating transformation ffl increase program size introduce new classes methods 
ffl introduce new predicates increase nesting level conditional looping constructs 
ffl increase number method arguments inter class instance variable dependencies 
ffl increase height inheritance tree 
ffl increase long range variable dependencies 
measures resilience glance increasing pot trivial 
increase metric example add arbitrary statements deliberately vague particular metric combination metrics exact choice critical application 
metric metric name citation program length halstead increases number operators operands cyclomatic complexity mccabe increases number predicates nesting complexity harrison increases nesting level conditionals data flow complexity increases number inter basic block variable fan complexity henry increases number formal parameters number global data structures read updated data structure complexity munson increases complexity static data structures declared complexity scalar variable constant 
complexity array increases number dimensions complexity element type 
complexity record increases number complexity fields 
oo metric chidamber increases number methods depth distance root inheritance tree number direct subclasses number classes coupled number methods executed response message sent object degree methods set instance variables 
note measures cohesion strongly related elements module 
classes coupled uses methods instance variables 
table overview popular software complexity measures 
complexity software component function method class program 
main main unfortunately transformations virtually useless easily undone simple automatic techniques 
necessary introduce concept resilience measures transformation holds attack automatic deobfuscator 
resilience transformation seen combination measures programmer effort amount time required construct automatic deobfuscator able effectively reduce potency deobfuscator effort execution time space required automatic deobfuscator effectively reduce potency important distinguish resilience potency 
transformation potent manages confuse human reader resilient confuses automatic deobfuscator 
measure resilience scale trivial oneway shown 
way transformations special sense undone 
typically remove information program useful human programmer necessary order execute program correctly 
examples include transformations remove formatting scramble variable names transformations typically add useless information program change observable behavior increases information load human reader 
transformations undone varying degrees difficulty 
shows deobfuscator effort classified polynomial time exponential time 
programmer effort required automate transformation measured function scope intuition easier construct counter measures obfuscating transformation affects small part procedure may affect entire program 
strong weak deobfuscator effort high resilience programmer effort poly time exp time process interprocedural full global way resilience low trivial weak strong trivial weak strong full full full resilience obfuscating transformation 
scope transformation defined terminology borrowed code optimization theory local transformation affects single basic block control flow graph cfg global affects entire cfg inter procedural affects flow information procedures interprocess transformation affects interaction independently executing threads control 
definition transformation resilience behavior conserving transformation gamma 
transforms source program target program res resilience respect program res way information removed reconstructed res def resilience deobfuscator effort programmer effort resilience function defined matrix 
measures execution cost see potency resilience components describing quality transformation 
third component cost transformation execution time space penalty transformation incurs obfuscated application 
classify cost point scale cheap costly point defined definition transformation cost behavior conserving transformation gamma 
transforms source program target program cost extra execution time space compared cost def dear executing requires exponentially resources costly executing requires resources cheap executing requires resources free executing requires resources noted actual cost associated transformation depends environment applied 
example simple assignment statement pa inserted topmost level program incur constant overhead 
statement inserted inside inner loop substantially higher cost 
noted give cost transformation applied outermost nesting level source program 
measures quality give formal definition quality obfuscating transformation definition transformation quality qual quality transformation defined combination potency resilience cost qual pot res cost layout transformations explore novel transformations briefly consider trivial layout transformations typical current java 
transformation removes source code formatting information available java class files 
way transformation original formatting gone recovered transformation low potency little semantic content formatting great confusion introduced information removed free transformation space time complexity application affected 
scrambling identifier names way free transformation 
higher potency formatting removal identifiers contain great deal pragmatic information 
control transformations sections catalogue obfuscating transformations 
derived known transformations areas compiler optimization software reengineering developed sole purpose obfuscation time 
section discuss transformations attempt obscure control flow source application 
indicated classify transformations affecting aggregation ordering computations flow control 
control aggregation transformations break computations logically belong merge computations 
control ordering transformations randomize order computations carried 
computation transformations insert new redundant dead code algorithmic changes source application 
transformations alter flow control certain amount computational overhead unavoidable 
alice means may choose highly efficient program highly obfuscated 
typically obfuscator assist trade allowing choose cheap expensive transformations 
opaque predicates real challenge designing control altering transformations cheap resistant attack 
achieve transformations rely existence opaque variables opaque predicates 
informally variable opaque property known priori obfuscator difficult deobfuscator deduce 
similarly predicate boolean expression opaque deobfuscator deduce outcome great difficulty outcome known obfuscator 
able create opaque variables predicates difficult obfuscator crack major challenge creator obfuscation tools key highly resilient control transformations 
measure resilience opaque variable predicate resistance attacks scale transformation resilience weak strong full 
similarly measure added cost opaque construct scale transformation cost cheap costly 
definition opaque constructs variable opaque point program property known obfuscation time 
write clear context 
predicate opaque outcome known obfuscation time 
write evaluates false true evaluates true false 
see 
omitted clear context 
different types opaque predicates 
solid lines indicate paths may taken dashed lines paths taken 
give examples simple opaque constructs 
easy construct obfuscator equally easy crack deobfuscator 
section give examples opaque constructs higher resilience 
trivial weak opaque constructs opaque construct trivial deobfuscator crack deduce value static local analysis 
analysis local restricted single basic block control flow graph 
gives examples 
consider opaque variable trivial computed calls library functions simple understood semantics 
language java requires implementations support standard set library classes opaque variables easy construct 
simple example pint random random library function returns integer range delta delta delta unfortunately opaque variables equally easy 
required deobfuscator designer tabulate semantics simple library functions pattern match function calls obfuscated code 
opaque construct weak deobfuscator crack static global analysis 
analysis global restricted single control flow graph 
gives examples 
computation transformations computation transformations fall categories hide real control flow irrelevant statements contribute actual computations introduce code sequences object code level exist corresponding high level language constructs remove real control flow abstractions introduce spurious ones 
insert dead irrelevant code metrics suggest strong correlation perceived complexity piece code number predicates contains 
fortunately existence opaque predicates easy devise transformations introduce new predicates program 
consider basic block delta delta delta sn 
insert opaque predicate essentially splitting half 
predicate irrelevant code evaluate true 
break halves proceed create different obfuscated versions second half 
created applying different sets obfuscating transformations second half directly obvious reverse engineer fact perform function 
predicate select runtime 
similar time introduce bug predicate selects correct version code extend loop conditions shows obfuscate loop making termination condition complex 
basic idea extend loop condition predicate affect number times loop execute 
predicate added example evaluate true mod 
convert reducible non reducible flow graph programming language compiled native virtual machine code expressive language 
case allows device language breaking transformations 
transformation language breaking introduces virtual machine native code instruction sequences direct correspondence source language construct 
faced instruction sequences deobfuscator try synthesize equivalent convoluted source language program give altogether 
example java bytecode goto instruction java language corresponding goto statement 
means java bytecode express arbitrary control flow java language easily express structured control flow 
technically say control flow graphs produced java programs reducible java bytecode express non reducible flow graphs 
expressing non reducible flow graphs awkward languages gotos construct transformation converts reducible flow graph non reducible 
done turning structured loop loop multiple headers 
add opaque predicate loop appear jump middle loop 
fact branch taken 
java decompiler turn flow graph duplicates code contains extraneous boolean variables 
alternatively deobfuscator guess flow graphs produced obfuscator simply remove opaque predicate 
counter alternative transformation shown 
deobfuscator blindly removes resulting code incorrect 
remove library calls programming idioms programs written java rely heavily calls standard libraries 
semantics library functions known calls provide useful clues reverse engineer 
problem exacerbated fact java library classes name names obfuscated 
int delta delta delta random delta delta delta int delta delta delta delta delta delta 
unchanged examples trivial weak opaque constructs 
delta delta delta delta delta delta delta delta delta sn delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta sn branch insertion transformation 
delta delta delta delta delta delta loop condition insertion transformation 
compile cate decompile cate reducible non reducible flow graphs 
split loop body parts insert bogus jump break parts moved loop opaque predicate ensures executed loop body 
second predicate ensures executed 
cases obfuscator able counter simply providing versions standard libraries 
example calls java dictionary class uses hash table implementation turned calls class identical behavior implemented say red black tree 
cost transformation execution time size program 
similar problem occurs clich es patterns common programming idioms occur frequently applications 
experienced reverse engineer search patterns jump start understanding unfamiliar program 
example consider linked lists java 
java library standard class provides common list operations insert delete enumerate java programmers construct lists objects ad hoc fashion linking field 
iterating lists common pattern java programs 
techniques invented field automatic program recognition identify common patterns replace obvious ones 
linked list case example represent standard list data structure common cursors array elements 
table interpretation effective expensive transformations table interpretation 
idea convert section code java bytecode case different virtual machine code 
new code executed virtual machine interpreter included obfuscated application 
obviously particular application contain interpreters accepting different language executing different section obfuscated application 
usually order magnitude slowdown level interpretation transformation reserved sections code small part total runtime need pointing 
high level protection 
add redundant operands constructed opaque variables algebraic laws add redundant operands arithmetic expressions 
increase metric 
obviously technique works best integer expressions numerical accuracy issue 
obfuscated statement opaque variable value 
statement construct opaque subexpression value 
obviously take different values execution program long quotient statement reached 
parallelize code automatic parallelization important compiler optimization increase performance applications running multi processor machines 
reasons wanting parallelize program course different 
want increase parallelism increase performance obscure actual flow control 
possible operations available 
create dummy processes perform useful task 
split sequential section application code multiple sections executing parallel 
application running single processor machine expect transformations significant execution time penalty 
may acceptable situations resilience transformations high static analysis parallel programs difficult number possible execution paths program grows exponentially number executing processes 
parallelization yields high levels potency reverse engineer find parallel program difficult understand sequential 
section code easily parallelized contains data dependencies wolfe 
example data independent statements run parallel programming language java explicit parallel constructs programs parallelized calls thread lightweight process libraries 
section code contains data dependencies split concurrent threads inserting appropriate synchronization primitives await advance 
program essentially running sequentially flow control shifting thread advance advance await await aggregation transformations programmers overcome inherent complexity programming introducing abstractions 
abstraction levels program procedural abstraction important 
reason obscuring procedure method calls utmost importance obfuscator 
consider ways methods method invocations obscured inlining outlining interleaving cloning 
basic idea code programmer aggregated method presumably logically belonged broken scattered program code belong aggregated method 
inline outline methods inlining course important compiler optimization 
extremely useful obfuscation transformation removes procedural abstractions program 
inlining highly resilient transformation essentially way procedure call replaced body called procedure procedure removed trace abstraction left code 
outlining turning sequence statements subroutine useful companion transformation inlining 
shows procedures inlined call sites removed code 
subsequently create bogus procedural abstraction extracting code code new procedure call call 

delta delta delta gamma delta delta delta call delta delta delta delta delta delta inline outline code code code inlining outlining transformations 
object oriented languages java inlining may fact fully way transformation 
consider method invocation 
actual procedure called depend run time type cases method invoked particular call site inline possible methods select appropriate code branching type see 
inlining removal methods obfuscated code may contain traces original abstractions 
code class code class call inline type class type class inlining method calls 
statically determine type possible methods pm bound inlined call site 
interleave methods detection interleaved code important difficult reverse engineering task 
rugaber writes factors program difficult understand code responsible accomplishing purpose may woven single section 
call interleaving delta delta delta shows easily interleave methods declared class 
idea merge bodies parameter lists methods add extra parameter global variable discriminate calls individual methods 
ideally methods similar nature allow merging common code parameters 
case parameter type 
clone methods trying understand purpose subroutine reverse engineer course examine signature body 
equally important understanding behavior routine different environments called 
process difficult obfuscating method call sites appear different routines called fact case 
shows create different versions method applying different sets obfuscating transformations original code 
method dispatch select different versions runtime 
method cloning similar predicate insertion transformations method dispatch opaque predicates select different versions code 
loop transformations large number loop transformations designed intent improve performance particular numerical applications 
see bacon comprehensive survey 
transformations useful increase complexity metrics table 
loop blocking improve cache behavior loop breaking iteration space inner loop fits cache 
loop unrolling replicates body loop times 
loop bounds known compile time loop unrolled entirety 
loop fission turns loop class method delta delta delta method delta delta delta new class method int fs delta delta delta fs delta delta delta new interleaving methods 
opaque variable passed interleaved method discriminate calls 
course stopping merging bodies obvious ways possibly opaque predicates pif delta delta deltaq class method int delta delta delta new delta delta delta class method int delta delta delta method int delta delta delta class inherits method int delta delta delta new new delta delta delta cloning methods 
generated applying different obfuscating transformations body calls px px look different methods fact go different looking methods identical behavior 
buggy version called 
compound body loops iteration space 
transformations increase metrics increase source application total code size number conditions 
loop blocking transformation introduces extra nesting increases metric 
applied isolation resilience transformations quite low 
require static analysis deobfuscator unrolled loop 
transformations combined resilience rises dramatically 
example simple loop apply unrolling fission blocking 
returning resulting loop original form require fair amount analysis deobfuscator 
ordering transformations programmers tend organize source code maximize locality 
idea program easier read understand items logically related physically close source text 
kind locality works level source locality terms expressions statements basic blocks basic blocks methods methods classes classes files kinds spatial locality provide useful clues reverse engineer 
possible randomize placement item source application 
types items methods classes example trivial 
cases statements basic blocks data dependency analysis see min min loop transformation examples 
loop blocking loop unrolling loop fission 
examples adapted 
performed determine reorderings legal 
transformations low potency add obscurity program resilience high cases way 
example placement statements basic block randomized traces original order left resulting code 
ordering transformations particularly useful companions inline outline transformation section 
potency transformation enhanced inlining procedure calls procedure randomizing order statements outlining contiguous sections statements 
way unrelated statements previously part different procedures brought bogus procedural abstractions 
certain cases possible reorder loops example running backwards 
loop reversal transformations common high performance compilers 
data transformations section discuss transformations obscure data structures source application 
indicated classify transformations affecting storage encoding aggregation ordering data 
storage encoding transformations cases natural way store particular data item program 
example iterate elements array probably choose allocate local integer variable appropriate size iteration variable 
variable types possible natural probably efficient 
furthermore natural interpretation bit patterns particular variable hold type variable 
example normally assume bit integer variable storing bit pattern represent integer value 
course mere conventions interpretations possible 
obfuscating storage transformations attempt choose unnatural storage classes dynamic static data 
similarly encoding transformations attempt choose unnatural encodings common data types 
storage encoding transformations go hand hand isolation 
change encoding simple example encoding transformation replace integer variable delta constants 
efficiency choose power 
example int delta delta delta delta delta delta int delta delta delta delta delta delta obviously overflow case floating point vari ables accuracy issues need addressed 
determine range variable question overflow occur change larger variable type 
trade resilience potency hand cost 
simple encoding function delta example add little extra execution time common compiler analysis techniques 
promote variables number simple storage transformations promote variables specialized storage class general class 
potency resilience generally low conjunction transformations quite effective 
example java integer variable promoted integer object 
true scalar types corresponding packaged classes 
java supports garbage collection objects automatically removed longer referenced 
example int delta delta delta delta delta delta int new int value delta delta delta value delta delta delta value possible change lifetime variable 
simplest transform turns local variable global shared independent procedure invocations 
example procedures local integer variable active time variable global shared void int delta delta delta delta delta delta void int delta delta delta delta delta delta int void delta delta delta delta delta delta void delta delta delta delta delta delta transformation increases metric number global data structures referenced increased 
split variables boolean variables variables restricted range split variables 
write range determined static analysis techniques querying user 
program contains threads determined examining static call graph 
variable split variables delta delta delta delta delta delta 
typically potency transformation grow unfortunately cost transformation usually restrict 
allow variable type split variables type requires provide pieces information function maps values corresponding value function maps value corresponding values new operations corresponding primitive operations values type cast terms operations remainder section assume type boolean small integer variables 
shows possible choice representation split boolean variables 
table indicates split point program corresponds false 
similarly corresponds true 
new representation device substitutions built boolean operations 
easiest way simply provide run time lookup table operator 
tables shown respectively 
boolean variables computed 
show result splitting boolean variables 
interesting aspect chosen representation possible ways compute boolean expression 
statements example look different assign false variable 
similarly statements completely different compute potency resilience cost transformation grow number variables original variable split 
resilience enhanced selecting encoding run time 
words run time look tables bd constructed compile time susceptible static analyses algorithms included obfuscated application 
course prevent line code compute primitive operations done statement 
convert static procedural data static data particularly character strings contain useful pragmatic information reverse engineer 
simple way obfuscating static string convert program produces string 
program false true true false val bool true false false delta delta delta delta delta delta delta delta delta short delta delta delta delta delta delta val delta delta delta variable splitting example 
tables compute boolean operations 
constructed obfuscator stored static data obfuscated application generated run time obfuscated application 
dfa trie traversal possibly produce strings 
example consider function 
function constructed obfuscate strings aaa ccb 
values produced aaa ccb program argument values may may terminate 
aggregating computation static string data just function course highly undesirable 
higher potency resilience achieved function broken smaller components embedded normal control flow source program 
interesting note combine technique table interpretation transformation section 
intent obfuscation convert section java bytecode code virtual machine 
new code typically stored static string data obfuscated program 
higher levels potency resilience strings converted programs produce explained 
aggregation transformations contrast imperative functional languages object oriented languages data oriented control oriented 
words object oriented program control organized data structures way 
means important part reverse engineering objectoriented application trying restore program data structures 
conversely important obfuscator try hide data structures 
object oriented languages just ways aggregate data arrays objects 
sections examine ways data structures obfuscated 
merge scalar variables scalar variables delta delta delta merged variable vm provided combined ranges delta delta delta fit precision vm example bit integer variables merged bit variable 
arithmetic individual variables transformed arithmetic vm simple example consider merging bit integer variables bit variable merging formula delta get arithmetic identities 
simple examples 
resilience variable merging quite low 
deobfuscator needs examine set arithmetic operations applied particular variable order guess consists merged string int int string fs goto fs goto fs goto fs goto fs goto goto fs goto goto return goto goto goto goto function producing strings aaa ccb 
delta delta delta delta delta delta gamma delta delta delta delta gamma delta delta int long merging bit variables bit variable occupies top bits bottom bits 
actual range deduced program intuitive merges 
gives rules addition multiplication 
shows simple examples 
example obfuscated example merging pz 
variables 
increase resilience introducing bogus operations correspond reasonable operations individual variables 
example insert operations appear merge halves example rotation pif rotate variant transformation merge delta delta delta array va delta delta delta delta delta delta appropriate type 
delta delta delta object variables example element type va class higher inheritance hierarchy types delta delta delta restructure arrays number transformations devised obscuring operations performed arrays split array sub arrays merge arrays array fold array increasing number dimensions flatten array decreasing number dimensions 
shows examples array restructuring 
statements array split sub arrays 
holds elements indices holds elements odd indices 
statements show integer arrays interleaved resulting array bc 
elements evenly spread resulting array 
statements demonstrate onedimensional array folded twodimensional array 
statements demonstrate reverse transformation twodimensional array flattened dimensional array 
array splitting folding increase data complexity metric 
array merging flattening hand decrease measure 
may indicate transformations marginal negative potency fact deceptive 
problem complexity metrics table fail capture important aspect data structure transformations introduce structure originally remove structure original program 
greatly increase obscurity program 
example programmer declares dimensional array purpose chosen structure maps cleanly data manipulated 
array folded dimensional structure reverse engineer deprived valuable pragmatic information 
modify inheritance relations current object oriented language java main modularization abstraction concept class 
classes essentially data types encapsulate data instance variables control methods 
write class set instance variables methods 
contrast traditional notion data types classes composed aggregation instance variable type inheritance extends adding new methods instance variables 
borrowing notation write inheritance phi deltac said inherit super parent class 
phi operator function combines parent class new properties defined deltac exact semantics phi depends particular programming language 
languages java phi usually interpreted union applied instance variables overriding applied methods 
metric complexity class grows depth distance root inheritance hierarchy number direct descendants 
basic ways increase complexity split factor class insert new bogus class 
problem class factoring low resilience stopping deobfuscator simply merging factored classes 
prevent factoring insertion normally combined shown 
way increasing resilience types transformations sure new objects created introduced classes 
shows variant class insertion called false refactoring 
refactoring automatic technique restructuring object oriented programs structure deteriorated 
refactoring step process 
detected apparently independent classes fact implement similar behavior 
secondly features common classes moved new possibly parent class 
false refactoring similar operation performed classes common behavior 
classes instance variables type moved new parent class methods buggy versions methods ordering transformations section argued possible randomizing order computations performed useful obfuscation 
similarly useful randomize order declarations source application 
particularly randomize order methods instance variables classes formal parameters methods 
case corresponding actuals course reordered 
potency transformations low resilience way 
cases possible reorder elements array 
simply put provide opaque encoding function maps th element original array new position reordered array int delta delta delta delta delta delta int delta delta delta delta delta delta opaque values predicates seen opaque predicates major building block design transformations obfuscate control flow 
fact quality control transformations directly dependent quality predicates 
section gave examples simple opaque predicates trivial weak resilience 
means opaque predicates broken automatic int delta delta delta delta delta delta delta delta delta int delta delta delta delta delta delta delta delta delta int delta delta delta delta delta delta delta delta delta int swap int delta delta delta delta delta delta delta delta delta int bc bc delta delta delta bc delta delta delta delta delta delta int delta delta delta int swap delta delta delta delta delta delta delta delta delta bc delta delta delta array restructuring 
array splitting statements array merging statements array folding statements array flattening statements 
deobfuscator determine value local global static analysis 
obviously generally require higher resistance attack 
ideally able construct opaque predicates require worst case exponential time size program break polynomial time construct 
section techniques 
aliasing second lightweight processes 
opaque constructs objects aliases inter procedural static analysis significantly complicated possibility aliasing 
fact different versions precise static alias analysis shown np hard undecidable 
exploit fact construct opaque predicates difficult break 
noted fast imprecise alias analysis algorithms detect aliases time aliases time 
basic idea construct complex dynamic structure maintain set pointers structure 
opaque predicates designed ask questions answered interprocedural aliasing analysis performed 
consider obfuscated method 
interspersed original code bogus method calls redundant computations guarded opaque predicates 
method calls manipulate global pointers point different connected components dynamic structure 
statement pg move non deterministically update point statement ph insert new node inserts new node updates point node methods calls extra pointer argument refers objects set allows construct opaque predicates statements 
predicate may true false move component 
conversely false refer nodes different components 
statements exploit aliasing 
predicate statement true false depending point different objects 
predicate statement evaluate true alias object 
opaque constructs threads parallel programs difficult analyze statically sequential counterparts 
reason interleaving semantics statements parallel region ppar delta delta delta sn executed 
different ways 
spite static analyses parallel programs performed polynomial time require 
interleavings considered 
java parallel regions constructed lightweight processes known threads 
java threads point view useful properties scheduling policy specified strictly language specification depend implementation actual scheduling thread depend asynchronous events generated user interaction network combined inherent interleaving semantics parallel regions means threads difficult analyze statically 
observations create opaque predicates require worst case exponential time break 
basic idea similar section global data structure created occasionally updated kept state opaque queries 
difference updated concurrently executing threads 
obviously dynamic data structure created 
threads randomly move global pointers respective components asynchronously executing calls move insert 
advantage combining data races interleaving aliasing effects high degrees resilience 
illustrate ideas simpler example pair global integer variables known fact elementary number theory integers gamma thread int random sleep thread int random sleep sleep int const sqrt maxint main run run delta delta delta gamma delta delta delta example predicate point evaluate false 
threads occasionally wake update global variables new random values 
notice involved data race matter long assignments atomic 
regardless wins race hold square number 
preventive transformations obfuscating transformations particularly control transformations section said embed bogus program real program 
words obfuscated application really consists programs merged real program performs useful task bogus program computes useless information 
sole purpose bogus program confuse potential reverse engineers hiding real program irrelevant code 
opaque predicate main device obfuscator disposal prevent bogus inner program easily identified removed 
example obfuscator embeds bogus code protected opaque predicates statements real program 
deobfuscator task examine obfuscated application automatically identify remove inner bogus program 
accomplish deobfuscator identify evaluate opaque constructs 
process illustrated 
shows anatomy semi automatic tool 
incorporates number techniques known reverse engineering community 
remainder section briefly review techniques discuss various counter measures called preventive transformations obfuscator employ difficult 
preventive transformations preventive transformations quite different flavor control data transformations 
contrast main goal obscure program human reader 
designed known automatic techniques difficult inherent preventive transformations explore known problems current decompilers targeted preventive transformations inherent preventive transformations inherent preventive transformations generally low potency high resilience 
importantly ability boost resilience transformations 
example assume reordered loop run backwards suggested section 
able apply transformation determine loop loop carried data dependencies 
naturally stopping deobfuscator performing analysis returning loop forward execution 
prevent add bogus data dependency reversed loop int resilience inherent preventive transformation adds loop reordering transformation depends complexity bogus dependency state art dependency analysis 
targeted preventive transformations example targeted preventive transformation consider program 
designed specifically explore weakness mocha decompiler 
inserts extra instructions return statement method source program 
transformation effect behavior application mocha crash 
identifying evaluating opaque constructs difficult part identifying evaluating opaque constructs 
note identification evaluation distinct activities 
opaque construct local contained single basic block global contained single procedure inter procedural distributed entire program 
example pif gamma delta delta deltaq local opaque predicate pr delta delta delta delta delta delta delta delta deltaq global 
computation performed different procedures construct inter procedural 
obviously identification local opaque predicate easier identification inter procedural 
identification pattern matching deobfuscator knowledge strategies employed known identify opaque predicates 
designer deobfuscator examine obfuscator decompiling simply examining obfuscated code generates construct pattern matching rules identify commonly opaque predicates 
method best simple local predicates px gamma thwart attempts pattern matching obfuscator avoid canned opaque constructs 
important choose opaque constructs syntactically similar constructs real application 
identification program slicing basic premise programmer find obfuscated version program difficult understand reverse engineer original 
main reasons obfuscated program live real code interspersed dead bogus code logically related pieces code broken dispersed program 
program slicing tools reverse engineer counter 
tools interactively aid engineer decompose program manageable chunks called slices 
slice program respect point variable consists statements contributed value program slicer able extract obfuscated program statements algorithm computes opaque variable obfuscator dispersed statements entire program 
strategies available obfuscator slicing useful identification tool add parameter aliases parameter alias formal parameters formal parameter global variable refer memory location 
cost precise inter procedural slicing grows number potential aliases program turn grows exponentially number formal parameters 
obfuscator adds aliased dummy parameters program substantially slow slicer precise slices required force slicer produce imprecise slices fast slicing required 
add variable dependencies popular slicing tools unravel small slices require excessive time compute larger ones 
example working line program unravel cases required minutes compute slice 
force behavior obfuscator attempt increase slice sizes adding bogus variable dependencies 
example increased size slice computing adding statements apparently contribute value fact 
main int main int statistical analysis deobfuscator instrument obfuscated program analyze outcome predicates 
call method examines run time characteristics obfuscated application way statistical analysis 
deobfuscator alert reverse engineer predicate returns truth value large number test runs may turn opaque predicate 
deobfuscator blindly replace predicates true false dangerous 
applications contain real predicates check conditions happen exceptional circumstances deobfuscator appear behave identically opaque predicate 
example consider pif leap year delta delta deltaq 
statistical analysis evaluation 
potential opaque predicate say program identified guess value true version obfuscated program opaque predicate replaced guessed value 
run parallel input compare see produce identical output 
outputs conclude predicate part bogus real application identical program 
true delta delta delta output input 
delta delta delta 
output program obviously sure chosen inputs adequately cover paths program 
program contains paths rarely taken pif leap year delta delta deltaq difficult 
furthermore generating large numbers correct input output data difficult particularly internal structure application unknown input entered case java programs complex graphical user interface 
prevent identification statistical analysis obfuscator may choose favor transformations insert predicates shown insert predicates 
possible counter measure statistical analysis design opaque predicates way predicates cracked time 
way doing opaque predicates side effects 
example obfuscator determined sort static flow analysis statements execute number times 
statements obfuscated introducing opaque predicates calls functions increment decrement global variable delta delta delta int bool return bool return delta delta delta deobfuscator tries replace predicates true overflow 
result program terminate error condition 
evaluation data flow analysis similar types code optimization 
removing pif false delta delta deltaq dead code elimination moving identical code statement branches code hoisting common code optimization techniques 
opaque construct identified attempt evaluate 
simple cases constant propagation reaching definition data flow analysis sufficient px delta delta delta delta delta delta delta delta deltaq 
evaluation theorem proving data flow analysis powerful break opaque predicate deobfuscator attempt theorem prover 
doable depends power state art theorem provers difficult ascertain complexity theorem needs proven 
certainly theorems proved induction mod reach current theorem provers 
things difficult theorems know difficult prove known proof exists 
example deobfuscator prove bogus loop terminates order determine live code random known problem 
conjecture says loop terminate 
known proof conjecture code known terminate numbers delta obfuscation safe original obfuscated code behave identically difficult 
partial evaluation bears striking resemblance partial evaluation 
partial evaluator splits program parts static part precomputed partial evaluator dynamic part executed runtime 
dynamic part correspond original program 
static part correspond bogus inner program identified evaluated removed time 
static inter procedural analysis methods partial evaluation sensitive aliasing 
preventive transformations discussed relation slicing applies partial evaluation 
obfuscation algorithms obfuscator architecture section definition obfuscation quality section discussion various obfuscating transformations sections position detailed algorithms 
top level loop obfuscation tool general structure done apply returns source code object obfuscated 
returns transformation obfuscate particular source code object 
apply applies transformation source code object updates application accordingly 
done determines required level obfuscation attained 
complexity functions depend sophistication obfuscation tool 
simplistic scale simply return random source code object transformations done terminate loop size application exceeds certain limit 
normally behavior insufficient 
algorithm gives description code obfuscation tool sophisticated selection termination behavior 
algorithm data structures constructed algorithms source code object set language constructs programmer find appropriate obfuscating transformations source code object ft 
delta delta delta tn 
vn mapping transformations values describing appropriate term source code object refer classes methods basic blocks application application 
apply idea certain transformations may inappropriate particular source code object introduce new code unnatural new code look place easy spot reverse engineer 
higher appropriateness value better code introduced transformation fit 
source code object obfuscation priority describes important obfuscate contents contains important trade secret high contains mainly bread butter code low 
routine execution time rank time spent executing routine 
primary input algorithm application set obfuscating transformations ft delta delta deltag 
algorithm requires information regarding transformation particularly quality functions res pot cost similar section returning numerical values function res returns measure resilience transformation applied source code object withstand attack automatic deobfuscator 
pot returns measure potency transformation applied source code object difficult human understand having obfuscated cost returns measure execution time space penalty added maps transformation set language constructs add application 
points algorithm load application obfuscated builds appropriate internal data structures 
point builds 
point applies obfuscating transformations required obfuscation level attained maximum execution time penalty exceeded 
point rewrites new application algorithm code obfuscation input application source code object code files delta delta delta 
standard libraries delta delta delta defined language 
set obfuscating transformations ft delta delta deltag 
mapping transformation gives set language constructs add application 
functions res pot cost expressing quality transformation respect source code object set input data fi delta delta deltag numeric values 
measure maximum extra execution time space penalty user accept 
measure amount obfuscation required user 
output obfuscated application source code object code files 

load application delta delta delta obfuscated 
obfuscator load source code files case obfuscator contain complete compiler front performing lexical syntactic semantic analysis load object code files 
object code retains information source code case java class files method preferable 

load library code files delta delta delta referenced directly indirectly application 

build internal representation application 
choice internal representation depends structure source language complexity transformations obfuscator implements 
typical set data structures include control flow graph routine 
call graph routines 
inheritance graph classes powerful obfuscator restricts purely syntactic transformations manage semantic analysis 

construct mappings algorithm algorithm algorithm 

apply obfuscating transformations application 
step select source code object obfuscated suitable transformation apply process terminates required obfuscation level reached acceptable execution time cost exceeded 
repeat apply update relevant data structures point done 
obfuscated source code objects new obfuscated application algorithm input obfuscation priority mapping computed algorithm 
output source code object maps source code object measure important obfuscate select source code object obfuscate treat priority queue 
words select maximized 
algorithm input source code object appropriateness mapping computed algorithm 
output transformation number heuristics select suitable transformation apply particular source code object important issues consider 
firstly chosen transformation blend naturally rest code handled favoring transformations high appropriateness value 
secondly want favor transformations yield high bang buck high levels obfuscation low execution time penalty 
accomplished selecting transformations maximize potency resilience minimize cost 
heuristics captured code implementation defined constants return transform 
res cost maximized algorithm done input remaining level obfuscation 
remaining acceptable execution time penalty 
source code object transformation obfuscation priority mapping output updated 
updated 
updated obfuscation priority mapping boolean return value true termination condition reached 
done function serves purposes 
updates priority queue reflect fact source code object obfuscated receive reduced priority value 
reduction combination resilience potency transformation 
done updates determines termination condition reached 
implementation defined constants gamma 
pot res 
pot res cost return algorithm pragmatic information input application set input data fi delta delta deltag output mapping routine gives execution time rank mapping source code object gives set language constructs compute pragmatic information 
information choose right type transformation particular source code object 

compute dynamic pragmatic information 
run application profiler input data set provided user 
compute execution time rank routine basic block indicating application spends time 

compute static pragmatic information 
provides statistics kinds lan guage constructs programmer source code object set operators uses set high level language constructs statements exceptions threads uses set library classes routines algorithm obfuscation priority input application rank output mapping source code object gives obfuscation priority provided explicitly user computed heuristic statistical data gathered algorithm 
possible heuristics 
routine inversely proportional rank 
idea time spent executing routine probably important procedure heavily obfuscated 

complexity defined software complexity metrics table 
possibly flawed intuition complex code contain important trade secrets simple code 
algorithm obfuscation appropriateness input application mapping transformation gives set language constructs add application 
mapping source code object gives set language constructs output mapping source code object transformation gives appropriateness respect compute appropriateness set source code object mapping primarily static pragmatic information computed algorithm 
source code object transformation degree similarity ft 
summary discussion main contribution insight may circumstances acceptable obfuscated program behave differently original 
particular obfuscating transformations target program slower larger original 
special cases allow target program different side effects original terminate original program terminates error condition 
requirement observable behavior behavior experienced user programs identical 
allowing weak equivalence original obfuscated program novel exciting idea 
belief current identifies obvious transformations great potential research 
particular see areas investigated 
new obfuscating transformations identified 

interaction ordering different transformations studied 
similar code optimization ordering sequence optimizing transformations difficult problem 

relationship potency cost studied 
particular kind code know transformations give best bang buck highest potency lowest execution overhead 
overview transformations discussed see tables 
overview opaque constructs suggested see table 
power obfuscation encryption program obfuscation bear striking resemblance 
try hide information eyes purport limited time 
encrypted document limited shelf life safe long obfuscation quality target operation transformation potency resilience cost metrics section layout scramble identifiers medium way free change formatting low way free remove comments high way free control computations insert dead irrelevant code depends quality opaque predicate nesting depth construct inserted 
extend loop condition reducible add redundant operands remove programming idioms medium strong table interpretation high strong costly parallelize code high strong costly aggregation inline method medium way free outline statements medium strong free interleave methods depends quality opaque predicate 
clone methods block loop low weak free unroll loop low weak cheap loop fission low weak free ordering reorder statements low way free reorder loops low way free reorder expression low way free data storage encoding change encoding depends complexity encoding function 
promote scalar object low strong free change variable lifetime low strong free split variable depends number variables original variable split 
convert static procedural data depends complexity generated function 
aggregation merge scalar variables low weak free factor class medium free insert bogus class medium free refactor class medium free split array weak free merge arrays weak free fold array weak cheap flatten array weak free ordering reorder methods instance variables low way free reorder arrays low weak free table table transformations part 
quality columns indicates measure dependent circumstances discussed indepth corresponding section 
metrics column lists complexity measures affected transformation 
see table descriptions measures 
obfuscation quality target operation transformation potency resilience cost metrics section preventive targeted low trivial free inherent add aliased formals prevent slicing medium strong free add variable dependencies prevent slicing depends quality opaque predicate 
add bogus data dependencies medium weak cheap opaque predicates side effects medium weak free opaque predicates difficult theorems table table transformations part 
quality opaque construct resilience cost section created calls library functions 
trivial depends cost library function 
created local intra basic block information 
trivial free cheap created global inter basic block information 
weak free cheap created inter procedural aliasing information full cheap costly created process interaction scheduling full cheap costly table table opaque constructs 
encryption algorithm attack long advances hardware speed allow messages chosen key length routinely decrypted 
true obfuscated application remains secret long sufficiently powerful built 
evolving applications problem long time releases shorter time takes deobfuscator catch obfuscator 
case time application automatically outdated interest competitor 
application contains trade secrets assumed survive releases protected means obfuscation 
partial server side execution obvious choice drawback application execute slowly network connection 
uses obfuscation interesting note may potential applications obfuscation obvious discussing 
possibility obfuscation order trace software pirates 
idea simple vendor creates new obfuscated version application new customer keeps record version sold 
probably reasonable application sold distributed net 
vendor finds application needs get copy version compare data base see bought original application 
generate different obfuscated versions application introducing element randomness algorithm algorithm 
different seeds random number generator produce different versions 
fact necessary store copy obfuscated version sold 
suffices keep random number seed software pirates illicit obfuscation 
java obfuscator outlined works bytecode level stopping pirate obfuscating legally bought java application 
obfuscated version 
faced pirate argue fact application originally bought code completely different legally reengineered version 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
isbn 
david bacon susan graham oliver sharp 
compiler transformations highperformance computing 
acm computing surveys december 
www acm org pubs toc abstracts html 
chidamber chris kemerer 
metrics suite object oriented design 
ieee transactions software engineering june 
cristina cifuentes john gough 
decompilation binary programs 
software practice experience july 
jeffrey dean 
program optimization object oriented languages 
phd thesis university washington 
james 
software protection myth reality crypto advances cryptology pages august 
james gosling bill joy guy steele 
java language specification 
addison wesley 
isbn 
halstead 
elements software science 
elsevier north holland 
warren harrison kenneth 
complexity measure nesting level 
sigplan notices 
henry dennis kafura 
software structure metrics information flow 
ieee transactions software engineering september 
hash value computed obfuscated code 
amir herzberg pinter 
public protection software 
acm transactions computer systems november 
susan horwitz 
precise flow insensitive may alias analysis np hard 
toplas january 
susan horwitz thomas reps david binkley 
interprocedural slicing dependence graphs 
toplas january 
neil jones 
partial evaluation 
acm computing surveys september 
jens knoop bernhard steffen jurgen 
parallelism free efficient optimal bitvector analyses parallel programs 
toplas may 
mark 

www 
demon nl java java january 
james lyle wallace james graham keith gallagher joseph poole david binkley 
unravel case tool assist evaluation high integrity software 
volume requirements design 
technical report nistir department commerce august 
stavros 
protecting source code andf 
ftp osf org pub andf andf ps january 
apple quicktime lawsuit 
www 
com pages june news html may news html may june 
mccabe 
complexity measure 
ieee transactions software engineering december 
john munson 
measurement data structure complexity 
journal systems software 
william opdyke ralph johnson 
creating superclasses refactoring 
stan john buck editors proceedings st annual conference computer science pages new york ny usa february 
acm press 
ftp st cs uiuc edu pub papers refactoring refactoring superclass es ps 

control flow data flow program complexity 
proceedings ieee compsac pages november 
ramalingam 
undecidability aliasing 
toplas september 
spencer rugaber kurt linda wills 
interleaving problem program understanding 
nd working conference reverse engineering toronto ontario canada july 
ftp cc gatech edu pub groups reverse repository interleaving ps 
pamela samuelson 
reverse engineering software legal 
ieee software pages january 
taivalsaari 
notion inheritance 
acm computing surveys september 
frank tip 
survey program slicing techniques 
journal programming languages september 
hans peter van vliet 
java obfuscator 
web inter nl net users van 
vliet html january 
hans peter van vliet 
mocha java decompiler 
web inter nl net users van vliet mocha html january 
uwe wilhelm 
cryptographically protected objects 
epfl ch wilhelm 
html 
linda mary wills 
automated program recognition feasibility demonstration 
artificial intelligence 
michael wolfe 
high performance compilers parallel computing 
addison wesley 
isbn 
root root phi phi phi root root phi phi root root gamma gamma phi phi phi root root phi phi phi phi modifications inheritance hierarchy 
root root inheritance tree object java 
triangles represent subtrees 
arrow class inherits basic operations class factoring class insertion shown respectively 
factoring class program replaced factoring insertion normally combined 
done original class split extra child created move node method delta delta delta node move move insert new node 
delta delta delta move 
delta delta delta delta delta delta 
token false token true token delta delta delta 
token true token false token delta delta delta opaque predicates constructed objects aliases 
construct dynamic structure nodes 
node boolean field token pointer fields represented black dots point nodes 
structure designed consist connected components global pointers pointing respectively 
bug bug true bug false bug true bug false bug obfuscation vs 
shows original program consisting statements gamma obfuscated 
real program statements boxed clarity 
unboxed code represents bogus program 
deobfuscator identifies constant opaque predicates predicates evaluate result replaces computed value 
obfuscator determines statements fact identical common code conditional 
deobfuscator applies final simplifications returns program original form 
inheritance hierarchy graphs cfgs control flow standard library java class files java class files obfuscated application java decompiler java class files application java source files decompiled application id name kind symbol table constant pool type method theta class program input user interaction theorem prover evaluate opaque predicates statistical analysis known opaque patterns predicate alias analysis identify opaque predicates program slicer undo transformations data dependence analysis architecture java tool 
main input tool application set obfuscated java class files 
reverse engineer may provide files input data allow statistical execution information gathered 
tool require extensive user interaction 
theorem provers example need guidance find profitable proof strategies 
output tool set class files converted java source decompiler 

