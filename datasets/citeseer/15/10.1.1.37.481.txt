building studying web volunteer computing systems java luis mit laboratory computer science cambridge ma usa cag lcs mit edu www cag lcs mit edu satoshi electrotechnical laboratory tsukuba ibaraki japan etl go jp project developing idea volunteer computing seeks enable people form large parallel computing networks quickly ubiquitous easy technologies web browsers java 
utilizing java object oriented features built flexible software framework easy programmers write different volunteer computing applications allowing researchers study develop underlying mechanisms 
show framework write master worker style applications develop approaches problems programming interface adaptive parallelism fault tolerance computational security scalability user interface design 
key words metacomputing parallel distributed computing network workstations heterogeneous computing java pronounced buy uh hun name old tradition neighbors help relocating family gathering family house carrying new location 
word come mean spirit communal unity cooperation seemingly impossible tasks possible concerted effort people common goal sense unity 
project seeks bring spirit realm global computing preprint submitted elsevier preprint october developing idea volunteer computing form metacomputing seeks easy ordinary people little technical knowledge cooperate solving parallel problems computers processing power 
minimizing effort expertise required add worker nodes volunteer computing maximizes potential worker pool size minimizes setup time making possible build world wide computing networks larger quickly possible forms metacomputing 
potentials volunteer computing demonstrated success projects distributed net solved rsa rc challenge employing volunteer teams world wide combined power equivalent high pcs 
project aims take volunteer computing developing web volunteer computing systems programmers write platform independent parallel applications java post web applets volunteers need web browser mouse clicks join computation 
possible benefits web volunteer computing systems ranging local global 
easier faster install existing metacomputing systems systems allow organizations including companies universities far lacked necessary expertise time pool existing workstations provide inexpensive supercomputing facilities research teaching 
resources organizations share barter trade processing power creating new possibilities global collaboration 
appropriate economic models mechanisms barter trading systems eventually turn commercial systems computing power commodity people buy sell trade 
internet set top boxes information appliances widely available volunteer computing principles build networks information appliances take advantage utilized processing power millions cpus sitting idle users homes 
ultimately web volunteer computing potential harness computing power millions computers internet solving hard computational problems worthy causes serve common local communities world 
order potentials reality challenging issues need addressed 
identify issues flexible software framework fully exploits java object oriented features easy programmers build applications researchers study various issues develop approaches 
show framework ways discuss results 
research issues implementing deploying real volunteer computing systems involves interesting challenging technical questions problems 
include ffl accessibility 
order maximize potential pool minimize setup time volunteer computing system accessible people possible 
platform independent require little technical knowledge volunteers possible 
ffl programmability 
volunteer computing system provide flexible easy programming interface allows programmers implement wide variety parallel applications easily quickly 
ffl adaptive parallelism 
volunteer nodes different kinds cpus join leave computation time parallel programming models volunteer computing systems adaptively parallel 
traditional models assume existence fixed number nodes depend static timing information system 
ffl fault tolerance computational security 
large scale metacomputing systems volunteer computing systems able tolerate faults data loss corruption random hardware software communication failures 
metacomputing systems volunteer computing systems resilient intentional attacks malicious nodes 
include sabotage nodes submitting erroneous results confidential data commercial volunteer systems 
ffl performance scalability 
useful java volunteer computing system ultimately provide users speedups better comparable available metacomputing technologies 
potential obstacles goal include java traditionally slow execution speed communication overhead lack server scalability 
ffl user interface design 
conventional parallel systems volunteer computing systems need user interfaces attract volunteers participate encourage stay 
commercial systems users need interfaces submitting jobs receiving results 
framework address issues built software framework java distributed object package similar sun rmi widely compatible 
access remote objects transparently worrying communication details able utilize objectoriented techniques enable programmers experiment different approaches research issues mixing matching objects various ways 
gui data engine watch gui result data watch engine watch advocate data data advocate engine gui data watch engine watch gui result data problem problem problem table result data result data clients server clients data pool manager watch manager result data pool advocate watch advocate program server fig 

system worker watcher clients 
system design framework defines set interacting components extended composed build systems shown fig 

system consists clients connected servers 
client java applet started web browser java application started command line 
different kinds clients worker clients performing computation watcher clients viewing results statistics 
client chassis contains active engine object communicates manager server exchanging data objects 
engine example may get data objects manager execute return result data objects done 
data objects generally polymorphic know process 
data objects example may implement method engine call 
engine data objects associated gui objects provide user interface 
server typically contains commodity server serving java class files command line java application creates problem objects representing different ongoing computations 
problem program object creates controls manager data pool objects different kinds 
example shows program object controlling manager takes care distributing collecting results worker clients watch manager distributes results watcher clients 
client connected server represented advocate object forwards client remote calls appropriate manager 
framework writing application framework typically involves selecting existing generic library components shown shaded boxes fig 
defining new application specific components shown double bordered boxes extending existing base classes 
way application programmers write wide variety applications share common programming model master worker common set pre defined engine manager data pool objects defining different data gui program objects application 
framework allows programmers researchers change generic objects making easy implement experiment new generic functionality mechanisms 
example researchers experiment performance optimization writing manager objects different scheduling algorithms 
similarly replication fault tolerance mechanisms implemented extending subclassing manager data pool objects 
programmers implement entirely new parallel programming models creating new sets engines managers data pools 
providing extensibility levels applications generic mechanisms levels framework easy programmers researchers build variety applications study different technical issues volunteer computing develop possible approaches 
remainder show level flexibility discuss current results 
building applications programming user interface programming interface framework support programming models applications currently master worker model shown fig 

model server program object creates set managers data pools fills pool data objects method 
volunteer worker clients connected server run loop repeatedly making remote calls method respective advocates 
advocate passes calls manager adding process id pid identification desired 
response call manager returns available uncompleted data object result request mw pool mw result pool engine engine server clients request reset reset reset result reset request result request pid pid result advocate advocate data watch gui request fig 

master worker model components methods 
pool 
engine runs calling method gets result calling 
sends result back manager calling advocate method 
manager receives results workers places results result pool marks corresponding pool done 
pool done manager calls parent program object method 
default method calls sets stage computation pool calling 
applications programmers override separate blocks parallel computation block guaranteed computed completely started 
provides simple form barrier synchronization 
factoring application example program object list target numbers factored method move target making sure results previous received 
users view results statistics control computation watcher clients communicate watch manager server 
watcher client engine runs loop periodically requesting watch manager list new results passing results watch gui displays accordingly 
watcher client allows user send request objects watch manager method 
watch manager forwards requests program object reacts application specific way 
mandelbrot rendering demo example watch gui shown fig 
allows users select portion screen zoom sends corresponding request objects fig 

screen shot mandelbrot worker watcher applets 
server 
program object receives request responds calling reset watch managers causing result pools cleared calling request method 
write application model programmers need override appropriate methods application specific classes 
manner written variety applications including factoring distributed web crawling rc decryption mandelbrot rendering 
seemingly simple limited embarrassingly parallel applications master worker model quite versatile practical 
mandelbrot demo example represents parallel rendering applications scientific community media industry 
potential applications include forms data mining monte carlo simulations computations general wants run sequential computation large number varying input combinations 
interestingly programmers today accustomed sequential programming lot applications real world may fall category 
extending appropriate classes master worker model support complex programming models 
example built sub framework parallel genetic algorithms defines generic data class method calls evaluation selection reproduction mutation methods set genes generic program class method redistributes resulting genes new generation objects 
writing applicationspecific subclasses successfully applied sub framework problems multivariable function optimization 
currently looking implementing bsp popular programming model programming natural providing remote memory access message passing functions time implementation easier specifying communication operations take effect global barrier synchronization 
possible implement bsp top master model defining engine allows objects communication requests run manager collects requests performs 
may implement coarse grain dataflow programming model extending master worker components support dependencies objects 
user interface design modular design framework allows application writers create different guis desired long conform interfaces required objects 
programmers create application specific guis view object different ways generic guis view different objects way 
shows examples mandelbrot application 
left watcher applet application specific object displays blocks 
colored borders corresponding different workers give users sense parallelism computation 
gui allows users zoom selected areas described sect 

right worker applet generic engine gui provides simple controls starting pausing stopping engine 
window generic gui displays status timing information 
developing generic mechanisms addition making easy write applications framework easy develop generic mechanisms 
section demonstrate flexibility showing framework initiate explorations issues adaptive parallelism fault tolerance computational security performance scalability 
done pid engine engine engine done done engine engine engine pid fig 

simple eager scheduling 
calls doing works 
finishes finishes gets 
adaptive parallelism current master worker programming model implementation employs simple form adaptive parallelism called eager scheduling 
shown fig 
object done flag set worker returns result object 
objects stored circular list pointer keeping track available uncompleted 
example pointer pointing works assigned engines respectively 
engine calls receives 
workers call soon finish current faster workers tend call get bigger share total 
way get simple form dynamic load balancing 
list circular eventually wrap point previously assigned uncompleted allowing piece reassigned workers 
eager behavior guarantees slow workers cause bottlenecks fast workers left simply bypass slow ones redoing necessary 
provides basic form crash tolerance 
fig 
example see finishes calls receives marked done crashed simply slow 
way computation go long processor alive 
fact processors crash computation continue soon new processor available 
currently examining forms adaptive parallelism master worker programming model 
example written subclasses implement pid done done pid result pid result pid result pid result done done pid spotter known result pid pid result pid result fig 

approaches fault tolerance 
majority voting 
spot checking function prefetching multiple packets distributed web crawler application improve performance hiding communication latency 
study effects changing sizes depending worker speeds 
fault tolerance computational security extending eager scheduling manager pool objects shown fig 
implemented approaches protecting faults sabotage majority voting spot checking 
majority voting works requiring majority results different workers object value 
implement new subclass done flag object remains unset long majority agreement reached results different pids received 
results received reaching majority agreement results invalidated object redone 
fig 
example works reached majority agreement marked done works considered undone 
spot checking shown fig 
works follows new batch subclass randomly selects object pool result 
engine calls manager returns spotter probability way manager check trustworthiness worker comparing result returns known result 
results match offending worker manager backtracks current results table preliminary results fault tolerance experiments 
bad plus bad ave time eff ave err ave time eff ave err ave caught ave time eff ave err ave caught ideal time voting spot checking backtracking blacklisting invalidating results dependent results offending worker 
table shows results fault tolerance mechanisms 
experiment created engine corrupts results fixed way 
ran mandelbrot application spiral range see sect 
workers varying number 
keep pool completely eliminated spot checking disabled blacklisting allowed caught nodes reconnect second delay 
configuration ran rounds measuring average running time average error rate err 
computed efficiency configuration multiplying ideal time measured workers fault tolerance fraction correct answers gamma err dividing result actual running time 
estimates efficiently workers utilized producing correct final answers 
majority voting performed expected having error rate close theoretical expected value gamma voting fraction workers assume agree answers 
error rate large values shown improve significantly realistic situations small proportional bigger problem voting efficiency shown best done twice 
respect spot checking performed 
shown efficiency loss number small backtracking error rates remained relatively low workers 
real system blacklisting enabled expect lower error rates 
shown caught high rate case 
means assume large number false identities faking ip addresses digital certificates switch dynamically quickly highly scenario quickly get eliminated error rate decrease rapidly time 
encouraging results clearly just theoretical experimental developmental research done area 
research questions include spot checking cases give bad answers avoid unnecessarily blacklisting innocent nodes just suffer temporary glitches 
important challenge applying mechanisms real applications 
spot checking may sufficient classes applications small percentage bad answers may acceptable screened 
include image rendering scattered bad pixels acceptable statistical computations outliers detected ignored double checked genetic algorithms bad results naturally screened system 
scientific applications assume reliability 
useful combine voting spot checking backtracking blacklisting shrink error rate possible 
plan explore traditional novel security mechanisms checksums digital signatures encrypted computation dynamic obfuscation reduce error rate making difficult falsify results place 
performance scalability relative speedup absolute performance shows results running mandelbrot application mhz pentium pro machines server workers connected mbit ethernet running windows nt netscape clients sun jdk jit compiler server 
experiment target pixel array divided square chunks 
represent different computation granularities tried different target ranges different average depths iterations pixel 
comparison ideal speedup computed sequential computation speed single unpartitioned array maximum depth 
shown get speedup large granularities achieving efficiency workers depths respectively 
granularity decreases communication overheads dominate limiting efficiency workers depths respectively 
possible approaches problem unique java volunteer computing include reducing overhead adaptively changing problem granularity 
workers ideal speedup black field depth spiral depth range depth blue field depth fig 

speedup measurements mandelbrot application 
table absolute java speeds mandelbrot demo mhz pentium pro 
speed iters relative speed netscape jit nt gcc gcc table shows comparison absolute speeds sequential java native executions mandelbrot code 
see just time jit compilation java faster unoptimized code slightly slower optimized code compiled gcc option produced best result 
test rc code times slower distributed net version 
impressive notable considering distributed net code hand optimized processor specific assembly code java directly support necessary operations bitwise rotates 
server scalability due security restrictions java applets communicate web server downloaded 
forces browser volunteer computing networks star topologies high congestion limited scalability 
address problem developed simple volunteer server system volunteers servers machines download run java application 
application creates generic object problem objects contains data pools managers serving worker watcher clients 
problem objects method create new gets groups data main server 
correspondingly method sends results back main server method requests 
slow congested link mandel problem main server server slow congested link mandel problem main server server vs problem volunteer server server vs problem volunteer server server fast link fast link worker applet worker applet watcher applet worker applet worker applet worker applet worker applet watcher applet worker applet worker applet fig 

volunteer servers 
slow links result unnecessary delays idling 
volunteer servers help exploiting communication parallelism locality 
table running mandelbrot application volunteer server 
time workers main server fast link main server slow link volunteer server fast link main server slow link watcher watcher shows volunteer servers help improve system performance scalability 
consider scenario shown fig 
volunteers slowed delays due congestion constraint server link server may different country 
situation improve running time having workers connect indirectly volunteer servers faster links uncongested servers servers countries shown fig 

table shows results experiment simulating scenarios kbps modem link slow link mbit ethernet fast link 
note computation took main server fast link took main server placed slow link workers forced wait server received results sent new slow link 
address problem volunteer server act cache main server workers fast link shown fig 
allow full speed idling 
shown reduced total running time spent workers computation remaining volunteer server send results back server slow link 
volunteer server allowed added slow link slowing computation 
general volunteer servers enable overcome congestion long cies exploiting locality parallelism communications 
potential applications volunteer servers include forming server pools handling large numbers clients building networks non star topologies 
related project joins growing number projects enabling people java web parallel computing 
early projects atlas newer projects icet java java applications 
restricted applets require technical expertise setup effort volunteer users 
projects support applets web browsers maximize accessibility fewer growing number 
early systems include simple ones complex general purpose ones charlotte javelin :10.1.1.37.8882
project approach maximize flexibility full advantage object oriented techniques 
developed generalpurpose framework allows programmers researchers build systems simply mixing matching interacting objects 
demonstrated effectivity framework successfully build variety master worker styles applications initiate explorations interesting research areas 
results explorations give positive outlook feasibility practicality volunteer computing systems encourage research field writing applications implementing programming models developing generic mechanisms supporting volunteer computing 
walsh wrote genetic algorithm sub framework wrote rc application alex yip helped write mandelbrot gui charlotte group math graphics code mandelbrot demo 
profs 
steve ward charles leiserson mit reviewers helpful comments suggestions 
performed mit etl supported part mit etl darpa 
addition luis supported part department science technology mit japan program de university 
image fig 
carlos francisco permission owner proc 
acm workshop java science engineering computation las vegas 
www npac syr edu users gcf html proc 
acm workshop java high performance network computing palo alto 
www cs ucsb edu conferences java blumofe brewer atlas infrastructure global computing proc 
th acm sigops european workshop systems support worldwide applications 
kedem wyckoff charlotte metacomputing web proc 
th intl 
conf 
parallel distributed computing systems 
cs nyu edu milan charlotte lawson www distributed net christiansen schauser wu javelin internet parallel computing java proc :10.1.1.37.8882
acm workshop java science engineering computation las vegas 
ere java framework seamless sequential multithreaded distributed programming proc 
acm workshop java high performance network computing palo alto 

home page 
www com ferrari 
network parallel computing java proc 
acm workshop java high performance network computing palo alto 
fox ed special issue java computational science engineering simulation modeling concurrency practice experience 

gray sunderam icet distributed computing java proc 
acm workshop java science engineering computation 
distributed execution java programs proc 
lecture notes computer science vol 
springer berlin 
www org web volunteer computing java proc 
lncs vol 
springer berlin 
www cag lcs mit edu ward building extensible framework volunteer computing java proc 
acm workshop java high performance network computing palo alto 
skillicorn hill mccoll questions answers bsp scientific programming 
www bsp worldwide org takagi matsuoka satoh parallel objects framework java proc 
acm workshop java high performance network computing palo alto 
create supercomputer java javaworld jan 
www javaworld com jw jw ibd html 
