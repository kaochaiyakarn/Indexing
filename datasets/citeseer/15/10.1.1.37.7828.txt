university amsterdam programming research group scannerless generalized lr parsing eelco visser report august university amsterdam department computer science programming research group scannerless generalized lr parsing eelco visser report august visser programming research group department computer science university amsterdam kruislaan nl sj amsterdam netherlands tel 
mail visser wins uva nl acknowledgments author arie van deursen jan van eijck paul klint useful suggestions comments previous versions 
research supported netherlands computer science research foundation sion financial support netherlands organisation scientific research nwo 
project incremental parser generation context sensitive disambiguation multi disciplinary perspective 
universiteit van amsterdam contents scannerless generalized lr parsing 
architecture 
contributions 
overview 
scannerless parsing advantages 
problems solutions 
grammar normalization normal form 
normalization 
semantics 
disambiguation disambiguation priorities 
lexical disambiguation 
longest match 
prefer literals 
automatic lexical disambiguation 
parser generation shift reduce parsing 

follow 
goto table 
action table 
remarks 
automatic lexical disambiguation prefer literals 
longest match 
reject productions semantics 
expressive power 
generalized lr parsing parse forest 
graph structured stack 
reject reductions 
algorithm 
remarks 
implementation related scannerless generalized lr parsing eelco visser current deterministic parsing techniques number problems 
include limitations parser generators deterministic languages complex interface scanner parser 
scannerless parsing parsing technique lexical context free syntax integrated grammar handled single context free analysis phase 
approach number advantages including discarding scanner lexical disambiguation means context lexical token occurs 
scannerless parsing generates number interesting problems 
integrated grammars fit requirements conventional deterministic parsing techniques 
plain context free grammar formalism leads unwieldy grammars lexical information included 
lexical disambiguation needs reformulated context free parsing 
scannerless generalized lr parsing approach solves problems 
grammar normalization support expressive grammar formalism complicating underlying machinery 
follow restrictions express longest match lexical disambiguation 
reject productions express prefer keywords rule lexical disambiguation 
slr parser generation algorithm adapted implement disambiguation general priority associativity declarations interpret follow restrictions 
generalized lr parsing provide dynamic lookahead support parsing arbitrary context free grammars including ambiguous ones 
adaptation glr algorithm supports interpretation grammars reject productions 
parsing areas computer science program generation routine technique successfully applied generate parsers programming languages formal definition means context free grammar 
theory 
practice parser generators accept limited subset context free grammars ll lalr grammars 
natural grammars languages respect limitations language designer compiler writer bend backwards fit grammar restrictions posed grammar formalism rewriting grammar rules introducing ad hoc solutions parse table conflicts resorting side effects parser 
succeeds producing grammar respects restrictions small extension modification language jeopardize careful balance tricks maintenance tools language troublesome 
source problems generated parsers division lexical analysis phase context free analysis phase corresponding division grammar regular grammar defining lexical syntax context free grammar defining context free syntax 
scanner divides character string tokens lexical syntax 
parser structures token string tree context free syntax 
interface scanner parser lexical tokens passed scanner parser 
straightforward scenario scanner produces stream tokens intervention parser 
entails knowledge parsing context available scanner lexical analysis decisions rely information 
difficult unambiguously define lexical syntax language means regular grammars 
lexical analysis interface context free analysis usually extended 
lexical disambiguation heuristics prefer longest match prefer keyword applied reduce number readings 
remain ambiguities application rules scanner produce multiple streams tokens representing possible partitionings string tokens regular grammar 
parser able cope non linear input 
possible supply feedback parser scanner reduce number applicable grammar rules 
instance specifying lexical categories expected token 
schemes lexical analysis complicated simple finite automaton model motivated regular grammars 
context free parsing functionality starts appear inside scanner interface scanner parser operational elements corrupt language definition 
consequence grammars ambiguous pure regular context free grammar considered reasoning language defined difficult 
scannerless generalized lr parsing describe approach syntax definition parser generation overcomes problems 
approach integration improvement scannerless parsing generalized lr parsing grammar normalization 
integration approach called scannerless generalized lr parsing 
scannerless parsing scannerless parsing parsing technique scanner divide string lexical tokens 
lexical analysis integrated context free analysis entire string 
comes naturally considering grammars completely describe syntax language 
term scannerless parsing coined salomon cormack 
complete character level grammars describing entire syntax language character level 
conventional lr parser generation yields tables conflicts extension slr parser generation called non canonical slr 
extension hard define grammar conflicts 
generalized lr parsing conventional lr parsing techniques especially scannerless lr parsing suffer conflicts parse table 
causes conflicts lr parse tables ambiguities lack lookahead 
conflict caused ambiguity possible actions lead successful parse 
caused lookahead problem actions lead success fail 
action successful decided statically 
ambiguity context free grammar undecidable floyd undecidable conflict due ambiguity lack lookahead 
complete character level grammars frequently need arbitrary length lookahead methods solve conflicts table succeed 
generalized lr parsing extension lr parsing interprets conflicts parse table forking parser main parser possible action case conflict 
conflict turns lead ambiguity parser constructs parse forest compact representation possible parse trees sentence 
conflict caused lack lookahead forked parsers wrong track fail 
manner lookahead handled dynamically 
generalized lr parsing ideal technique solve lookahead problems scannerless parsing 
generalized lr parsing introduced tomita building theoretical framework lang 
improved rekers handle context free grammars 
extend rekers version algorithm reject reductions facility needed lexical disambiguation 
grammar normalization aspect division lexical context free syntax affects specification syntax definition layout whitespace comments occur arbitrary places tokens 
conventional setting layout analyzed scanner thrown away 
parser sees layout tokens 
layout ignored specification context free syntax 
complete character level grammar aspects syntax completely defined including syntax positions layout 
lead unwieldy grammars declare occurrence layout separator grammar symbols context free productions 
grammar normalization technique define expressive grammar formalism terms simple context free grammars 
example normalization procedure addition layout symbols symbols context free productions 
examples definition regular expressions means productions flattening modular grammars 
important aspect scannerless generalized lr approach grammar normalization keep grammars small usable 
syntax definition formalism sdf approach formalism concise definition complete character level grammars 
sdf generalization syntax definition formalism sdf heering 

formalism normalization procedure defined visser 
architecture typical architecture application sdf depicted 
program text processor transforms text text composed parser front analyzes input text produces structured representation text form parse tree actual processor performs transformation parse tree back produces text corresponding transformed parse tree 
processors instance interpreters compilers data flow analyzers program transformation tools 
input language processor specified syntax definition formalism sdf 
language definition sdf tree tree processor corresponding text text processor constructed grammar normalizer parser generator parser pretty printer generator 
grammar normalizer language definition sdf normalized plain context free grammar extended character classes priority rules follow restrictions reject productions 
normalization briefly discussed 
full definition sdf normalization visser 
parser generator normalized syntax definition parse table generated extension standard slr algorithm character classes priorities follow restrictions reject productions 
parser generator accepts arbitrary context free grammars 
techniques parser generator discussed 
parser parse table interpreted generic language independent parser reads text produces parse tree 
heart parser extension glr algorithm rekers reads characters directly scanner 
extension glr algorithm reject reductions discussed 
pretty printer pretty printer translate output tree processor text 
pretty printer generated definition output language 
described van den brand visser discussed 
contributions scannerless generalized lr parsing approach new powerful parsing method supports concise specification languages 
technical contributions details discussed approach ffl normalization grammars eliminate features enhancing expressivity formalism particular integration lexical context free syntax means normalization single grammar 
ffl glr parsing scannerless parsing deal unbounded lookahead 
text denotes linear representation program character code ascii unicode 
definition sdf grammar normalizer definition sdf nf parser generator parse table parser text parse tree parse tree text processor definition sdf pretty printer generator architecture sdf application 
ffl static disambiguation means priorities interpreting priority declarations parser generator 
priorities completely expressed parse table 
ffl character classes grammars compact parse table 
ffl follow restrictions define longest match disambiguation interpretation follow restrictions parse table 
ffl prefer literals disambiguation means reject productions 
expressivity results context free grammars reject productions 
implementation parsers grammars extension glr algorithm 
overview section argue detail scannerless parsing number definite advantages parsing scanners introduced limitations conventional parsing techniques 
rest techniques overcome limitations result combined approach encompassing grammar formalism parsing techniques scannerless parsing feasible 
scannerless parsing term scannerless parsing coined salomon cormack indicate parsing separate lexical analysis phase scanner deterministic finite automaton 
parser directly reads characters text 
entails integration definition lexical context free syntax grammar 
consider sdf definition simple language expressions consisting identifiers additions multiplications 
sorts id exp lexical syntax 
id 
layout context free syntax id 
exp exp exp 
exp left exp exp 
exp left context free priorities exp exp 
exp exp exp 
exp line declares sorts say non terminals grammar 
lines declare lexical syntax language identifiers lists lowercase letters layout consists spaces tabs newlines 
lines declare context free syntax language 
expression identifier addition multiplication expressions 
observe grammar ambiguous order disambiguate priority associativity declarations added 
lines declare multiplication higher priority addition 
left attribute declares addition multiplication left associative 
conventional way interpret grammar parse string follows divide string tokens lexical syntax possible ways 
apply lexical disambiguation rules select desired division 
instance string ab rule prefer longest match prefer division ab longest possible identifier selected 
throw away layout tokens 
parse resulting token string context free syntax 
result parse tree contains leafs tokens yielded lexical analysis 
scannerless parsing sequence combine definition lexical context free syntax single context free grammar 
tokens left hand side productions context free syntax parse tree string ab tc explicitly separated layout 
grammar symbols renamed symbols occurring lexical syntax form lexi context free syntax form cfi 
done keep levels separated 
instance addition production transformed exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
symbol cfi represents syntax layout appear tokens 
explained detail 
complete integrated grammar corresponding definition page 
parse characters string normalized grammar 
result parse tree contains leafs characters string 
tokens recognizable subtrees 
example consider parse tree 
observe symbols hl lexi hl cfi abbreviations lexi cfi denote layout nodes 
sense new 
conventional parser instruct scanner character corresponding token parser reads tokens effect scannerless 
reason distinguish scannerless parsing parsing real scanner generates special problems avoided scanner 
advantages understanding scannerless parsing ask 
discuss advantages 
scanner obvious advantage scannerless parsing implementation scanner scanner generator needed complicated interface scanner parser eliminated 
integrated uniform grammar formalism language completely defined means grammar 
grammar rules explicit formally specified 
lexical syntax context free syntax specified formalism 
longer distinction regular context free grammars 
formalism uniform orthogonal 
features available lexical syntax available context free syntax vice versa 
simplifies implementation formalism 
disambiguation context integration lexical contextfree syntax lexical analysis guided context free analysis 
token sense position considered 
instance example longest match rule prefer ab situation adjacent identifiers syntactically correct 
paradigmatic example context dependent lexical disambiguation interplay subrange types floating point number constants pascal 
subrange types form constants 
floating point number constants form numbers scanned 
range adjacent floating point numbers 
scannerless parsing ambiguity solved automatically context 
scanner access context applies longest match rule choose second possibility adjacent numbers fail 
apparently reason syntax pascal allows real numbers form non empty lists digits jensen wirth 
similar examples languages 
example parsing context relevant making lexical decisions syntax lists statements separated semicolons newlines 
consider grammar lexical syntax 
layout context free syntax stat 
block lexical syntax defines newlines layout 
context free syntax defines blocks lists zero statements starting keyword keyword 
list declared construct fa declares list separated bs list form case separator semicolon newline 
means newlines layout non layout 
disambiguation rule prefer non layout applied tokens language newlines separator statements wrongly characterized non layout 
scannerless parser recognize newlines separator simply considering parsing context 
conservation lexical structure scanners usually maintain phrase structure tokens produce 
example grammar lexical syntax 
id 
id 
path defines lexical syntax path expressions occur instance naming conventions tree structured filesystems 
syntax lexical layout occur identifiers separators path 
scanner produce string containing characters path expression structure assigned grammar distinction identifiers path lost 
entails semantic processor tokens deal internal structure 
conservation layout scanners throw away layout tokens phrase 
way parser ignore layout simplifies parsing problem 
examples operations programs require structure program parse tree layout source 
examples source source translations transformations source text program documentation tools 
conventional parser instructed add layout parse tree detour usually require non standard extension method 
layout explicitly specified grammar get approach similar scannerless parsing 
expressive lexical syntax context free grammars provide expressive grammar formalism lexical syntax regular grammars 
additional expressive power opens way concise definitions nested comments syntactically correct expressions comments 
example consider extension expression grammar defines comments list comment words 
sorts comment lexical syntax 
context free syntax 
comment comment 
layout comment word non empty list characters whitespace 
definition comments part context free syntax comment words separated layout 
comments layout line grammar injection comment layout 
layout occur adjacent tokens comment 
definition comments nested comment words separated layout includes comments 
instance string height width depth syntactically correct expression grammar part expression including comments commented 
tedious job nested comments supported language 
extension grammar defines comment word expression 
context free syntax exp 
entails comments contain quoted expressions syntactically correct 
instance sentence contains expression part comment 
expression denotes addition useful typesetting comments literate programs generating cross 
problems solutions ask scannerless parsing introduced earlier advantages 
answer problems caused integration lexical context free syntax 
discuss solutions problems scannerless parsing feasible 
limitations parsing techniques main problem scannerless parsing limitations conventional deterministic parsing techniques 
complete character level grammars lr ll lr due lookahead needed lexical elements 
parsing scanner lookahead entails looking token ahead 
scannerless parsing lookahead entails considering character 
furthermore layout skipped scanner need considered lookahead 
solution sdf implementation generalized lr parsing algorithm tomita rekers get dynamic lookahead 
grammar size problem size grammars 
complete character level grammars large constructs specified character level 
furthermore placement layout tokens explicitly declared productions 
maintenance readability grammars problematic 
support development complete character level grammars expressive formalism needed hides details interface lexical context free syntax placement layout 
discuss approach grammar normalization order provide expressive formalism minimal semantic basis 
discuss extension context free grammars various disambiguation constructs keep grammars concise 
lexical disambiguation lexical ambiguities solved automatically integration lexical context free syntax cases disambiguation lexical constructs needs expressed 
lexical analysis context free parsing familiar lexical disambiguation rules prefer longest match prefer keyword redefined implementation reconsidered 
discuss disambiguation constructs lexical disambiguation follow restriction reject productions suffice express common lexical disambiguation rules 
interpretation disambiguation rules number ways interpret disambiguation constructs 
possibility implement filter parse forests proposed klint visser 
disambiguation lexical constructs context free expressions priorities lead exponential size parse forest filtering method inefficient 
discuss techniques parser generation encode disambiguation rules parse tables decisions taken early 
extension glr parsing algorithm reject reductions 
efficiency problem comes mind considering scannerless parsing efficiency 
scanning finite automaton lower complexity parsing stack scannerless parsing replacing finite automaton part stack machine efficient 
considerations led attempt scannerless parsing lr parsing linear particular regular grammars 
lexical syntax traditionally formulated means regular grammars expect linear behaviour lexical part scannerless parsers 
complete complexity scanner parser setup considered including lexical disambiguation 
lexical disambiguation rules solve ambiguities disambiguation deferred parser kind graph structured stack maintained keep track possible segmentation string tokens 
setup asf sdf meta environment klint forms background development sdf 
efficient maintain single graph structured stack 
complex grammars lexical syntax get area scannerless parsing parsing scanners longer properly compared syntax expressible scanner framework 
worst case complexity context free parsing taken point considering complexity scannerless parsing 
course considerations verified means experiments 
experiments scannerless parsing performed solutions problems discussed 
problems cause late scannerless parsing bad efficiency method 
discuss simple experiments performed scannerless parsing method described confirm expectations 
grammar normalization need expressive grammar formalism lexical syntax contextfree syntax integrated supports concise syntax definitions 
sdf expressive formalism 
provides regular expressions lexical context free syntax character classes literals priorities modules renaming aliases 
version formalism described visser 
full definition visser 
expensive extend tools expressive formalism features expressible primitive features eliminated means normalization function grammars 
normal form expressive power syntax definition formalism sdf characterized equation sdf context free grammars character classes priorities reject productions follow restrictions sdf definition equivalent context free grammar making character classes priorities reject productions follow restrictions 
features expressed terms features 
equivalence definition equivalent definition form sorts syntax priorities pr pr restrictions sort symbols context free productions form ff pr priority declarations form priority relation follow restrictions form ff gamma gamma cc ff list symbols cc character class 
production number attributes may include attribute reject production reject production 
priority relation left right assoc non assoc 
symbol character class symbol 
character classes interpreted parser generation 
symbols constructed symbol operators simply interpreted name 
instance symbol indicate iteration symbol special meaning normalization 
grammar projection functions defined 
sorts 
symbols 
productions pr 
priorities 
restrictions normalization example normal form consider grammar 
completely describes lexical context free syntax expressions identifier multiplication addition language described example 
fact grammar derived grammar application normalization procedure 
briefly discuss elements normalization formally specified visser 
refer examples normalization rules 
lexical context free syntax important aspect normalization integration lexical context free syntax 
productions lexical context free syntax merged 
order avoid interference lexical context free syntax symbols productions renamed 
symbols lexical syntax character classes literals renamed symbol constructor lexi 
instance id hid lexi lex 
similarly symbols context free syntax renamed cfi 
furthermore symbols left hand side context free productions separated cfi entails layout occur position 
way disjunct sets symbols created 
interface lexical context free syntax expressed injection ha lexi ha cfi symbol lexical context free syntax 
top symbol syntax definition defines number symbols 
text definition produced symbols 
context free parsing need single start symbol strings generated 
purpose sort production cfi ha cfi cfi added grammar defining start symbol 
production defines string start layout 
furthermore express termination string production eof defines string consists string generated followed file character 
character classes character classes expressions form cr cr cr characters character ranges form gamma character classes normalized unique normal form translating characters numeric character code ascii code ordering merging ranges increasing order overlap 
normalization formally specified proven correct respect set interpretation character classes visser 
literals literals abbreviations fixed lists characters 
literals defined terms production literal result singleton character classes corresponding characters arguments 
example production 
defines literal sequence characters ascii 
regular expressions extensive set regular expressions including optional alternative tupling kinds iteration permutation expressed means defining productions 
instance consider definition lex 
defines list lowercase letters 
priorities priorities declared chains declarations productions declared groups attributes 
defined terms binary priority associativity declarations 
sorts id exp syntax 
layout lex 
layout lex 
layout cf 
layout cf 
layout cf 
layout cf 
left 
layout cf 
layout cf 
layout cf 



lex 
lex 
lex 
lex 
left lex 
id lex 
id lex 
id cf 
id cf 
exp cf 
exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
left exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
left layout cf 
id cf 
layout cf 
start 
layout cf 
exp cf 
layout cf 
start 
start 
eof 
start 
priorities lex 
lex 
lex 
left lex 
lex 
lex layout cf 
layout cf 
layout cf 
left layout cf 
layout cf 
layout cf exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
exp cf 
layout cf 
layout cf 
exp cf 
exp cf exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
left exp cf 
layout cf 
layout cf 
exp cf 
exp cf exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
left exp cf 
layout cf 
layout cf 
exp cf 
exp cf 
expression grammar normal form 
grammar contains restrictions reject productions 
modules sdf definition divided number modules 
modules import modules 
share common syntax definitions language definitions 
renamings symbols productions adapt definition module application 
furthermore symbol aliases abbreviate long regular expressions 
modular syntax definitions completely expanded normalization function 
semantics syntax definition defines language set strings structure assigned strings 
strings language important users write programs 
structure strings important definition language processors compilers interpreters 
productions sdf definition describe language structure assigned strings language 
semantics syntax definition set parse trees set strings derived 
mapping trees strings achieved yield tree 
reverse mapping strings trees called parsing 
point formally define semantics context free grammars considering disambiguation rules priorities reject productions follow restrictions 
context free grammar generates family sets parse trees contains minimal sets cc cc char prod rule char character cc character class 
write ff list trees ff list symbols xn correspondingly denote set lists trees type ff ff 
notation written ff concatenation lists trees ff fi written ff fi yields list trees type fffi 
yield tree concatenation leafs 
language defined grammar family sets strings yields trees grammar yield 
parser function pi maps string characters set parse trees 
parser pi accepts string pi 
parser context free grammar accepts exactly sentences defined pi ft yield wg parser pi deterministic pi strings grammar ambiguous strings parse tree pi 
disambiguation disambiguation methods select tree set possible parse trees ambiguous string 
sdf provides disambiguation methods 
priority associativity declarations disambiguate concise expression grammars 
follow restrictions reject productions express lexical disambiguation 
section discuss methods 
disambiguation priorities priority associativity declarations fewer grammar symbols introduced compact syntax achieved 
consider grammar expressions functional programming language binary function application binding 
sorts var term lexical syntax 
var 
layout context free syntax var 
term term term 
term left var term term 
term term term 
term non assoc term 
term bracket context free priorities term term 
term term term 
term var term term 
term example term grammar sum foldr plus zero sum lst grammar disambiguated means priorities 
binary application operator declared left associative 
entails read 
illustrated shows left associative parse trees adjacent terms 
priority declaration defines applications higher priority equalities 
consider trees 
priority declaration tree priority conflict second tree correct parse tree 
definition formally defines notion priority conflicts 
definition grammar priority declarations pr set conflicts priority conflicts grammar smallest set parse tree patterns form ff fi fl fi pr ff fi fl conflicts cf fl ffl fi right non assoc bfl pr fi fl conflicts cf ff ffl fi left assoc non assoc ffb pr ff fi conflicts cf parse tree grammar priority conflict nodes matches pattern ff fi fl conflicts 
notion priority conflicts define filter sets parse trees selects trees conflict 
example rule cf declaration application left associative operator pattern ht cfi hl cfi ht cfi hl cfi ht cfi ht cfi ht cfi left right associative parse trees binary term application 
parse trees application equality 
describes tree conflict 
term layout abbreviated respectively 
second tree conflict selected disambiguation method 
rule cf application higher priority equality pattern ht cfi hl cfi hl cfi ht cfi ht cfi hl cfi ht cfi ht cfi member conflicts generated functional language grammar 
means tree priority conflict 
second tree conflict 
lexical disambiguation consider example functional expressions see contains occurrences lexical ambiguities 
longest match place longest match problem caused syntax binary application operator 
adjacent letters concatenation letters forming variable application single letter variables 
shows parse trees string fa 
tree concatenation letter lists single variable 
second tree letter interpreted variable 
want solve ambiguity means longest match rule prefers longest possible lexical token 
case string fa single variable 
define longest match notion formally comparing lengths tokens 
definition need notion token stream associated parse tree 
definition token stream token stream associated parse tree list subtrees root injection ha lexi ha cfi literal defining production 
length jtj token number characters yield 
definition token streams trees single token lex lex 
lex 
var lex 
var cf 
tokens lex 
var lex 
var lex 
lex 
var lex 
var lex 
idea longest match disambiguation compare token streams left right 
tokens length streams similar 
token differs length solves ambiguity tree associated longer token 
example token stream larger token length token second stream length 
parse trees fa functional expression grammar 
formally definition longest match disambiguation definition longest match token streams associated tree associated tree tree larger longest match ordering lm lm min jt js jt js definition method filter parse forests selecting largest trees longest match ordering 
longest match ambiguity causes exponential explosion parse forest feasible 
need method applied parsing possible filter parse tables 
naive solution longest match problem example require non empty layout separator terms application 
example solve problem second tree forbidden 
solution immediately refuted considering expression brackets argument 
method works cases encountered far follow restrictions 
follow restriction form gamma gamma cc declares symbols followed characters character class cc 
example restriction lexical restrictions var forbids variable followed letter 
entails second tree violates follow restrictions desired tree selected 
prefer literals second problem functional expression grammar overlap literals variables 
particularly problematic combination operator terms 
binding interpreted equality read variables 
clearly want declare reserved words language variables 
lexical disambiguation rule called prefer literals defined formally follows 
definition prefer literals tree violates prefer literals rule contains subtree function ha lexi ha cfi yield tree literal grammar 
rule expressed means reject productions 
reject production production ff attributed attribute reject 
declares string type derived ff 
example disambiguate grammar add productions 
lexical syntax 
var reject 
var reject creates ambiguity variable ways lexical definition production 
reject production derivations forbidden occur context binding 
need restrictions lexical restrictions prevent letter interpreted literal variable ter 
discuss properties reject productions 
automatic lexical disambiguation defined extensions context free grammars enable express lexical disambiguation rules grammars integrated lexical context free syntax 
desirable derive rules lexical disambiguation automatically grammar 
discuss issue discussed parser generation 
parser generation discussed grammar formalism disambiguation methods concise definition lexical context free syntax languages 
turn attention deriving parsers syntax definitions 
section rules generation parse tables shift reduce parser 
rules constitute modification known slr algorithm 
discuss shift reduce parsing 
shift reduce parsing shift reduce parser transition system manipulates state consisting stack input stream repeatedly shifting symbol input stack reducing number elements top stack single element enters accepting state 
transitions parse configurations determined functions actions goto defined transition rules actions shift sm ffl ma ffl shi actions reduce goto tree ffl ts ffl red actions eof accept ffl eof accept acc configuration ffl consists stack left side ffl list input characters right side ffl 
stack filled alternatingly states trees parsing starts configuration ffl initial state parser 
parsing succeeds sequence steps accept ends accepting configuration accept 
various ways define actions goto functions drive shift reduce parser 
slr algorithm anderson 
simplification lr parsing algorithm knuth 
works constructing lr parse table 
involves lookahead sets parse items 
lookahead reductions constrained follow set nonterminal defined production reduced 
rest section describe modification slr algorithm incorporates priorities follow restrictions 
modification derivation visser starting schema earley parsing algorithm parsing schema derived parser build trees priority conflicts 
changes character classes productions symbols follow goto interpretation follow restrictions restrict lookahead set reductions 
set symbol contains symbols phrase symbol start 
grammar define list symbols ff character class cc characters ff followed cc smallest character class ff cc ffl cc cc fi cc ff cc cc fi ff afi cc fffi cc fi definition set extended set symbols starts sentence derived list symbols 
ff afi phi fag fffi phi fi follow conventional slr algorithm follow set computed nonterminal grammar 
maps nonterminal set terminals follow nonterminal sentence follow fi computed closure follow fl follow fo adds characters set fl follow set fl follows production 
follow added case fl produce empty string 
notion refined follow set productions 
rule follow ff fl follow fo defines follow set production ff characters follow context 
case plain context free grammars rule fo effect rule fo 
consider priorities rule extended fi ff fl conflicts follow ff fl follow fo follow set production restricted contexts causing priority conflict 
instance expression grammar follow set addition production contain character addition occur direct descendant multiplication 
grammar defines follow restriction rules gamma gamma cc follow set production restricted fi ff fl conflicts gamma gamma cc follow ff fl follow cc fo production followed difference set right context character class cc 
see effect rule consider follow set production 
var functional expression grammar previous section 
application production injection variables terms follow set 
var eof 
lexical restriction var removes character class follow set resulting eof 
entails variable directly followed letter 
goto table states lr parser formed item sets 
item object form ff ffl fi context free production ffl symbols left hand side 
item indicates sentential form type ff recognized 
initial state parser grammar item set init defined init closure eof state expresses sentence recognized recognizing string sort followed special file character indicates strings 
closure set items adds initial items item set result symbol predicted items set 
closure cl ff ffl bfi closure fl closure cl presence priorities closure restricted items cause priority conflict 
ff ffl bfi closure fl ff fl fi conflicts closure cl example item ffle added closure result item ffle production left associative conflict pattern parsing string starts parser initial state 
recognition symbol reading character completing production parser enter states prescribed transitions goto graph 
goto function maps item set item set symbol recognized 
function goto defined goto closure shift create new item set shifting ffl symbol produce closure resulting item set 
normal lr parsing shift symbol creates item set containing items previous set ffl symbol 
ff ffl bfi ffb ffl fi shift sh refine definition shift shifting characters shifting productions 
shifting item set character character class defined rule ff ffl cc fi cc cc ff cc ffl fi shift cc sh character class cc induces shift item predicts character class cc superset cc 
shifting nonterminals refined shifting complete productions 
shift successful production cause priority conflict direct descendant position predicted symbol 
ff ffl bfi ff fl fi conflicts ffb ffl fi shift fl sh example production shift item ffle production left associative conflict 
restriction closure goto functions guarantees enter state built parse tree priority conflict 
action table action table declares actions taken state 
itemset function actions maps character set actions parser take 
set actions empty parser reached erroneous state 
set contains action way proceed 
ff ffl cc fi cc actions shift goto shi follow ff actions reduce ff jffj red ffl eof actions eof accept acc note shift denotes shift action state shift application shift function defined 
proposition states actions goto functions defined constitute correct shift reduce parser 
proposition correctness actions goto functions grammar init ffl accept iff pi contains priority conflicts pr violates follow restrictions 
remarks transition rules shift reduce parsing non deterministic 
action possible configuration transition possible 
actions function deterministic transition path possible string 
traditional parsing techniques accept grammars deterministic action function 
discuss efficient implementation non deterministic actions functions 
rules parser generation ignore reject productions treated just productions 
discuss reject productions interpreted means filter parse forests 
discuss reject productions interpreted parsing means adaptation glr algorithm 
purpose item set marked rejectable reached reject production rejectable goto ff ff reject production 
automatic lexical disambiguation discussed specification lexical disambiguation means follow restrictions reject productions 
effective way express lexical disambiguation tedious write rules 
desirable derive lexical disambiguation rules automatically grammar rules grammar disambiguated longest match prefer literals criteria 
discuss possibilities 
perfect rules longest match disambiguation 
question possible undecidable context free grammar ambiguous 
prefer literals prefer literals disambiguation rule expressed generating reject productions rule ha lexi ha lexi literal lexical phrase sort ha lexi overlap reject rule added grammar 
implements reserved keywords rule 
implementation problem parser needed recognize literals 
solved generating parser grammar reject rules parser determine overlap literals grammar lexical categories 
reject rules added grammar accordingly new parser generated extended grammar 
state explosion problem reject productions exclude keywords add items item sets 
instance language contains keywords match identifiers language itemset containing item ff ffl hid expanded items ffl hid lexi items ffl extra transitions 
prevent expansion define rejection literals indirect way follows ha lexi ha ha lexi ha symbol denotes empty phrase production 
sort ha collect literals rejected ha lexi 
production ha ha cfi defines rejection literals 
effect empty symbol second production item ffl ha ha lexi added ha lexi predicted 
cause reduction production 
item set ha predicted 
item set computed reused item sets predict ha lexi 
initial state finite automaton matching literals 
example consider prefer literals rule functional language example expressed modified rule syntax var lit 
var lex 
reject 
var lit 

var lit 
local exclusion alternative expression prefer literals rule rule lexi ha cfi ffl closure ffl ha cfi closure locally forbids predicted literals extending parser generator 
implement reserved keywords rule sense forbidding keyword lexical positions 
lexical literal appear place literal preferred 
lead ambiguities 
longest match straightforward find general rule express longest match follow restrictions 
attempt rule hb lexi follow ha lexi ha cfi ha lexi gamma gamma hb lexi ha lexi fr restricts follow set ha lexi excluding elements set hb lexi ha lexi hb lexis follow injection ha lexi ha cfi 
follow extension follow function produce symbols follow production 
rule adequate cases 
consider instance functional expression grammar 
follow restriction var derived exactly rule 
rule general 
counter example grammar expressions single character variables implicit multiplication operator 
describes mathematical expressions xy denotes multiplication lexical syntax 
var 
layout context free syntax var 
exp exp exp 
exp left rule fr forbid xy expression forcing whitespace example shows rule fr unsound considered analytic rule consider normative rule forcing clearer style language definition 
rule fr generates follow restrictions 
need restrictions literals overlapping 
instance restrictions lexical restrictions forbids interpretation letter literal variable ter 
rule adds restrictions prevent overlap 
ha lexi follow ha lexi hb lexi gamma gamma literal followed character set lexical ha lexi member follow set form lexical hb lexi longer match literal restricted follow set literal 
rule stronger longest match filter formulated 
forbid sentences single unambiguous interpretation 
instance consider string int 
int forced read variable juxtaposition literal variable clear rules final word fully automatic lexical disambiguation 
research needed decide sufficient 
reject productions introduced reject productions express prefer literals lexical disambiguation 
parser generator discussed treats reject productions normal productions 
cause ambiguous parses cases normal production reject production overlap 
section define semantics context free grammars reject productions investigate properties grammars including interpretation rejects solve ambiguities 
author jan van eijck email discussion led results section 
semantics semantics reject productions obtained refining inductive definition parse trees 
inductive rule prod restricted exclude construction parse trees yield obtained reject production 
context free grammar reject productions generates family sets parse trees contains minimal sets cc cc fi fi fi yield fi yield second condition excludes trees tree yield built reject production root 
second condition difference definition 
note trees fi excluded 
nested reject productions tree fi rejected part fi exclude trees fi 
unfortunately definition inconsistent grammars cycle containing reject production 
instance consider grammar syntax 


reject consider string member language grammar 
conversely 
reason restrict class grammars want consider grammars contain cycle disregarding rejects transitions reject production 
expressive power rest section explore properties reject productions 
context free grammars reject productions describe non context free languages 
consider example language standard example non context free language 
grammar due van eijck defines language reject productions 
productions define language productions define sorts denoting respectively productions exclude sort strings pairs unequal numbers xs ys 



reject 


reject 


reject 


reject difference context free grammar defining sorts define difference languages sorts adding productions 


reject adds trees second excludes trees match tree 
intersection extending result express intersection sorts adding new sorts adding productions 


reject 
reject defines difference gamma difference gamma gamma intersection generalize results 
context free languages express difference intersection languages context free grammars reject productions 
take union context free grammars languages renaming symbols prevent interference 
add productions sorts intersected explained 
weak complement interested strings generated grammar structure complement language generated sort defined extending grammar rules 
nota 
nota reject production defines complement string arbitrary characters 
complement empty character class character class characters 
second production excludes language strings language complement course express weak intersection sorts 
decidable seen context free grammars reject productions expressive 
appropriate ask decidable string language grammar 
theorem states case 
proof uses notion parse forest discussed section 
proof theorem need proposition generalized lr parsers 
proposition context free grammar 
yield yield glr parse result ambiguity node possibilities 
theorem parsing problem context free grammars reject productions rejects cycles decidable 
ambiguity node caused overlap syntax var lex 
reject production 
var lex 
proof 
context free grammar reject productions rejects cycles construct generalized lr parser ignoring reject annotations 
result parser possibly ambiguous context free grammar 
string parse parser 
parsing fails string language grammar reject productions 
result parsing parse forest 
cycles contain rejects removed forest 
tree rejected second condition rule reject production fi trees fi yield fi yield 
yield fi yield proposition parse forest contains ambiguity node top containing fi possibility 
reject productions interpreted traversing forest bottomup manner marking tree nodes rules leafs marked 
reduction node marked direct descendants marked 
ambiguity node marked direct descendants marked contains unmarked tree root label reject production 
parse forest finite procedure terminates 
root parse forest marked procedure string accepted grammar accepted forest marked nodes represents parse trees string 
tree illustrates proof 
overlap literal syntax variables causes ambiguity 
ambiguity node marked 
var lex 
reject production 
interpretation variable dismissed 
shows construct complete implementation parsers grammars reject productions 
section discuss reject productions interpreted parsing influence parse decisions prevent trees rejected subtrees built 
expressive power conclude context free grammars reject productions stronger pure context free grammars decidable parsing problem 
gives lower bound upper bound expressive power formalism open question class languages described context free grammars reject productions 
regular rejects introduced reject productions order express prefer literals rule 
means regular language excluded context free 
gives guarantee resulting language context free 
exploit property restrict formalism regular reject productions implement means grammar transformation 
grammar transformation probably yield large grammars 
furthermore implementation gives general way express prefer literals rule allows expression interesting grammars reach declarative specification 
feature give rise unforeseen applications 
generalized lr parsing defined generation shift reduce parsers context free grammars priority declarations follow restrictions 
actions function derived grammar deterministic shift reduce parser deterministic implemented standard way 
restrict class grammars guaranteed actions function deterministic 
causes lookahead needed grammar provided parser generator 
grammar ambiguous 
case scannerless parsing frequently see grammars unbounded lookahead needed 
entails variant lr parser generation algorithms produce deterministic actions function 
need non deterministic implementation shift reduce parsing algorithm 
configuration reached action possible possibilities tried 
case unbounded lookahead possible transitions leads accepting configuration 
case ambiguous string multiple accepting configurations reached giving possible parse trees string 
advantage non deterministic approach unbounded lookahead provides 
furthermore parser producing parse trees ambiguous string front disambiguation filter selects correct tree disambiguation method 
undecidable grammar ambiguous lookahead problems 
having parser yields possible parses help detecting ambiguities resolve easier way inspecting conflicts parse table 
naive way implement non deterministic parsing algorithm copy entire configuration point actions possible continue parsing configurations 
efficient memory requirements reuse parses substrings forked configurations 
generalized lr parsing efficient implementation non deterministic parsing 
glr parser deals conflicts parse table splitting parser parsers conflicts 
conflict due lack lookahead parsers succeed parsing sentence die 
parsers succeed parsing grammar ambiguous 
case parse trees possible parses built 
generalized lr parsing developed natural language processing tomita 
specialization general framework lang described lang creating generalized parsers 
algorithm improved rekers applied parsing programming languages 
feasibility glr parsing parsing programming languages shown experience glr asf sdf meta environment klint 
experience glr parsing programming languages adaptation algorithm reported wagner graham 
non determinism parse table need interpret reject productions grammar 
previous section showed reject productions interpreted disambiguation filter parsing 
interpret earlier 
section explain glr parsing adaptation algorithm interpret reject productions parsing 
parse forest generalized parser deals ambiguous grammars producing possible parse trees ambiguous string 
glr parsing possible parse trees represented means parse forest 
compact representation set parse trees 
parse tree constructed application ambiguity nodes 
application node represents application production list subtrees 
ambiguity node represents set possible parse trees sub string 
packing trees substring ambiguity node parses shared trees strings containing substring 
example consider grammar simple expressions ambiguous addition multiplication operator 
sorts exp syntax 
exp exp exp 
exp exp exp 
exp exp 
start 
keep example small layout allowed tokens 
parse forest ambiguous string shown 
ellipse represents ambiguity node 
observe various subtrees shared forest 
graph structured stack glr parser deals conflicts parse table maintaining number stacks parallel 
time parse stack leads conflicting actions new stacks created continue parse actions 
stacks copies old stack 
new top nodes pointers old stack 
exp exp exp exp exp exp exp exp parse forest sharing ambiguous string stage stacks get state stacks merged 
manner graph structured stack built parses ambiguous substrings shared 
graph structured stack node consists state number list links 
link contains node parse forest previous stack 
example working glr parser consider sequence stack configurations parsing string 
parse created parse forest 
shows stacks cycle parsing algorithm 
shifting character possible reductions performed character shifted 
trees pointed stack links abbreviated yield square brackets show structure 
symbol colon denotes main type tree link 
consider configurations 
initial stack state created 
character shifted 
character reduces expression production 
exp symbol shifted 
character reduces literal 
character shifted 
character reduces expression 
sequence reduces expression resulting link state state 
states shift performed character 
shifts lead stack state single stack created links stacks 
character reduces literal 
character shifted 
eof character reduces expression 
possible reductions stack state 
reduce reduce reduce 
reductions result creation stack state link initial stack 
exp exp exp exp exp exp exp exp exp exp exp exp exp exp parse configurations parse string stacks shared ambiguity node created represents possible parse trees 
point entire string read symbol eof 
expression reduced string accepted 
stack state accepting stack tree pointed link parse tree entire string 
le le le le le parse reject ignored 
reject reductions disambiguation reject productions introduced order express prefer literals rule 
outlined procedure interpreting reject productions parsing pruning parse forest 
interpret reject productions parsing prevent trees containing reject productions built 
understand achieved recall parse forest shows ambiguity created parsing substring functional expression grammar defined 
interpreted lexical productions variables reject production 
var lex 

pruning forest causes ambiguity node eliminated parse forest rejecting reading variable 
parse configurations parse show ambiguity created 
configurations letters read 
le le parse reject production forbids variable 
fourth configuration interesting 
parses substring variable constructed lex literal reject production 
var lex literal part construct 
reduction literal results stack state 
reduction lexical reject rule lead merged stack state reduction leads stack state leads term stack state 
states parsing continues shift space character state 
idea implementation reject rule forbid actions state reached reject reduction 
link created reducing reject production marked rejected 
links stack marked rejected shifts reductions state forbidden 
configuration entail link stack state stack state rejected 
reduction state shift state forbidden 
exactly happens parse shown 
dotted link rejected actions performed stack 
parse variable preempted 
configuration parsing continues stack state corresponding parse literal 
algorithm complete algorithm 
differences glr algorithm rekers productions goto function handling reject reductions 
furthermore parser scanner reads characters file string 
course stream token codes difference algorithm 
discussed character classes handled parse table transparent parser 
algorithm parse table table grammar parse string characters file 
string sentence language described grammar return parse forest string error message 
parse function parse reads characters file returns parse tree text syntactically correct error message 
list active stacks initialized contain single stack initial state parse table state 
character input parser handles actions active stack 
shifts stack stored performed shifter possible reductions performed 
characters read stacks alive parsing terminates 
parsing succeeded accepting stack direct link initial state 
link parse forest possible parse trees entire string 
parsing failed error term returned 
parse table file global accepting stack global active stacks fnew stack state init table global current token get char file parse character shifter current token eof active stacks accepting stack contains link initial stack tree return return parse error parse character list active stacks moved list stacks actor performs actions stack stack rejected 
list stacks actor extended reductions performed 
actions newly added stacks performed links created stack rejected escape 
new stacks added actor delayed rejectable considered stacks actor exhausted 
stacks taken delayed list order priority 
operation pop removes stack highest priority list stacks 
parse character global actor active stacks global actor delayed global shifter actor actor delayed actor actor actor delayed stack st actor links stack st rejected actor st actor handle actions stack st current token 
reduce action immediately handled 
shift actions saved shifter handling reductions performed 
accept action results saving current stack accepting stack 
error action ignored current stack wrong attempt stacks alive 
entire parse fails stacks lead error actions 
apparent shifting active stacks alive 
actor st action actions current token case shift shifter sig shifter reduce ff reductions st ff accept accepting stack st reductions function reductions performs reduction stack st production ff path length jffj links st stack st trees path collected reducer called handle reduction 
reductions st ff path stack st stack st length jffj kids trees links form path st st reducer st goto state st ff ff kids reducer stack st state production ff list trees kids reducer creates application node production list direct descendants kids creates new stack state link stack st exist stack state list active stacks searched 
stack new stack created branch added list active stacks list stacks actor 
new stack state link pointer newly created tree 
stack state exists direct link nl st st ambiguity 
tree added ambiguity node link 
direct link new link created st st parse tree 
new link entails new reductions inspected stacks possible active stacks reconsidered 
cases link created extended marked rejected production reject production 
reducer st ff kids application ff kids st active stacks state st direct link nl st st add possibilities ambiguity node tree nl ff reject production mark link nl rejected add link nl st st tree ff reject production mark link nl rejected st active stacks links st rejected st actor st actor delayed reduce ff actions state st current token limited reductions st ff nl st new stack state add link nl st st tree active stacks fst active stacks rejectable state st actor delayed push st actor delayed actor fst actor delayed ff reject production mark link nl rejected limited reductions function reductions reductions state production involve path going trough link nl 
limited reductions st ff path stack st stack st length jffj going link kids trees links form path st st reducer st goto state st ff ff kids shifter possible reductions performed shifter contains list stacks shift 
stack cycle parse 
list active stacks reinitialized empty list 
stack st shifter new stack created link st tree current token 
stack state created link stack st created 
shifter active stacks current token hs st shifter st active stacks state st add link st st tree st new stack state add link st st tree active stacks fst active stacks ffl 
start 
ffl 
ffl 
ffl 
ffl 
ffl 
ffl 
ffl 
ffl 
ffl 
start 
goto graph grammar nested reject productions 
remarks algorithm mark stacks rejected link stack created reject production 
action stack forbidden links stacks rejected 
done principle situations links created stack merged case links stack rejected 
clear situation occur 
proof contrary 
ordering states assumed priority pop operation procedure parse character needed ensure nested reject productions treated properly 
example consider grammar extended productions expressing intersection sorts 


reject 
reject 
start 
gives rise goto graph 
states rejectable reached reject production 
parsing string state reached reduction reduce action reject production 
reject leads stack state rejected 
action taken stack 
reduction 
leads stack state correctly acceptance string 
consider case string reduction state state rejected reduction state 
reduction state 

rejectable stacks actor delayed list 
stack state released reduction 
reject occurs stack state actor delayed rejected parsing fails 
state released parsing succeeds stack state rejected 
clear case state higher priority state 
clear ordering states determined general 
state productions reachable productions state higher priority 
guess worked carefully 
single non nested reject productions ordering plays role 
implementation exclusion means reject productions prefer literals special case dependent finding ordering states 
implementation previous sections approach scannerless parsing 
techniques implemented part sdf tools 
tools construct parsers number languages including sdf 
detailed data performance implementation available time writing couple preliminary observations 
grammar normalizer syntax definition formalism sdf completely specified asf sdf 
part definition grammar normalizer discussed 
specification compiled executable term rewriter reasonable performance 
literate specification sdf normalization syntax definitions visser 
specification defines format parse trees encoded aterm format van den brand 

parser generator parser generator described completely specified asf sdf 
compiled specification parser generator inefficient 
probably necessary implement component imperative language allows direct access lookup lists 
factors parser generation difficult compared normal slr parser generation context free grammars 
item sets productions lexical syntax 
extra productions added reject productions expressing prefer literals rule increases number items item sets 
goto table contains transition production transition nonterminal 
factor reduced sharing transitions state 
productions item sets encoded numbers 
character classes important reducing size parse table 
set actions shared characters stored efficiently means character class actions mapping item sets character classes sets actions 
parser parsing implemented implementation implementation aterms van den brand represent stacks trees 
parser includes visualization tools parse forests graph structured parse stacks produce pictures 
forest basis interactive disambiguation tool 
implementation parsing algorithm reasonably efficient sharing trees improved 
output parse trees optimal sharing subtrees completely lost writing parse forest linear term format 
solved linear encoding graphs graph exchange language gel 
furthermore mark scan garbage collector stack tree nodes 
entails stack tree nodes visited collect expensive large amount heap change status 
count garbage collector difference 
complexity lexical analysis performed experiments get idea complexity lexical analysis scannerless parsers 
experiments simple expression grammar 
experiments performed form parsing single identifier increasing length kb 
parsing expression consisting additions identifier arguments increasing length kb 
parsing expression consisting increasing number additions arguments length kb 
experiments saw linear behaviour small files deteriorating square behaviour large files 
garbage collection turned behaviour changed linear experiments 
confirms observation garbage collection algorithm 
confirms idea lexical analysis behave linearly simple regular lexical syntax 
prototype implementation optimized performance meaningfully compared scanner parser combinations lex yacc 
experiments show feasibility scannerless lr parsing approach 
related syntax definition formalism sdf formally specified visser 
specification asf sdf comprises syntax formalism normalization procedure parse tree format defined grammar 
syntax definition formalism sdf heering 
starting point discussed 
definition sdf grew specification sdf asf sdf 
number generalizations applied formalism orthogonal uniform number improvements new features added experience sdf asf sdf meta environment klint 
sdf introduced integration lexical syntax context free syntax formalism level 
implementation sdf definition mapped regular grammar defining lexical syntax context free grammar context free syntax 
scanners produced lexical syntax yield graph structured stream possible input filtered set lexical disambiguation rules 
fairly advanced setup interface suffers problems discussed 
generalized lr parsing algorithm developed tomita application natural language processing 
improved rekers applied asf sdf meta environment parsing programming languages 
algorithm rekers version 
wagner graham describe glr parsing incremental parsing programming languages 
earley described generalized parsing algorithm closely related lr algorithm knuth 
approach parsing dynamic lookahead extension top parsing syntactic predicates parr quong 
scannerless parsing introduced salomon cormack 
define extension slr parsing lack lookahead repaired extending item sets conflicts 
non canonical slr parser generation works limited set grammars making grammar development difficult 
follow restrictions simplification adjacency restriction rule nslr approach arbitrary grammar symbols forbidden adjacent 
reject productions called exclusion rules salomon cormack 
complete implementation follow restrictions reject productions adjacency restrictions exclusion rules partially implemented nslr parsing 
similar approach glr parsing tried area natural language processing 
tanaka 
discuss integration morphological syntactic analysis japanese sentences single glr parser 
morphological rules describe words formed characters 
segmentation string characters string words guided connection matrix restricting categories adjacent sentence 
rules usually suffice find unambiguous segmentation 
integrating morphological composition context free grammar syntactic phase contextual ambiguities avoided 
creates problem disambiguating combined context free grammar usingthe morphological connection matrix 
partly done filter generated lr table partly dynamically parsing 
disambiguation means priority associativity declarations introduced simultaneously aho 
earley 
describe solution conflicts lr parse tables means restricted form priorities 
aasa describes solution lr table conflicts means precedence declarations 
thorup describes solution parse table conflicts means collection excluded subtrees 
method expressive priorities sdf succeeds conflicts solved guaranteed 
klint visser logical disambiguation methods formalized disambiguation filters sets parse trees 
approach efficient implementation disambiguation priorities derived visser disambiguation filter priorities 
derivation forms foundation parser generator algorithm 
new approach parsing advantages conventional techniques 
overcomes drawbacks traditional scanner parser interface scanner completely name scannerless parsing 
lexical context free syntax language described single integrated uniform grammar formalism 
lexical ambiguities frequently solved means parsing context 
lexical structure layout preserved parse tree accessible semantic tools 
expressive formalism lexical syntax obtained example nested comments expressed 
approach encompasses expressive syntax definition formalism 
grammar normalizer reduce complexity formalism simplifying syntax definitions context free grammars extensions 
slr parser generator deals character classes follow restrictions priority associativity rules 
generalized lr parser arbitrary context free grammars reject productions nested 
parsing unambiguous languages glr parser dynamically handle lookahead problems forking parsers parallel 
reject productions turn expressive device brings domain context free languages 
unclear expressive formalism exactly lower bound stronger context free describes upper bound parsing problem decidable 
priorities compiled parse table parse trees priority conflicts produced parser 
reduces size parse forest case ambiguous binary expressions parse forest grows exponentially decreases number paths graph structured stack 
technique general conventional techniques kind disambiguation works remain conflicts parse table due causes 
instance grammar requires lookahead parser generator provides 
open issue fully automatic derivation lexical disambiguation rules grammar method easier 
apart minor point scannerless generalized lr parsing feasible parsing method syntax definition expressive solves number problems conventional parsing approaches 
acknowledgments author arie van deursen jan van eijck paul klint useful suggestions comments previous versions 
research supported netherlands computer science research foundation sion financial support netherlands organisation scientific research nwo 
project incremental parser generation context sensitive disambiguation multi disciplinary perspective 
aasa 

precedences specifications implementations programming languages 
wirsing editors programming language implementation logic programming volume lecture notes computer science pages 
springer verlag 
aasa 

user defined syntax ph thesis department computer sciences chalmers university technology university goteborg goteborg sweden 
aho johnson ullman 

deterministic parsing ambiguous grammars 
communications acm 
anderson eve horning 

efficient lr parsers 
acta informatica 
lang 

structure shared forests ambiguous parsing 
proceedings seventh annual meeting association computational linguistics association computational linguistics 
van den brand visser 

generation formatters context free languages 
acm transactions software engineering methodology 
van den brand klint olivier visser 

aterms representing structured data exchange heterogeneous tools 
technical report programming research group university amsterdam 


simple lr grammars 
communications acm 
earley 

efficient context free parsing algorithm 
communications acm 
earley 

ambiguity precedence syntax description 
acta informatica 
van eijck 

email july 
floyd 

syntactic analysis operator precedence 
communications acm 
heering hendriks klint rekers 

syntax definition formalism sdf manual 
sigplan notices 
jensen wirth 

pascal user manual report volume lecture notes computer science 
springer verlag berlin second edition edition 


gel graph exchange language 
technical report cs cwi amsterdam 
klint 

meta environment generating programming environments 
acm transactions software engineering methodology 
klint visser 

filters disambiguation contextfree grammars 
san pietro editors proc 
workshop parsing theory pages milano italy 
tech 
rep dipartimento di scienze dell informazione universit di milano 
knuth 

translation languages left right 
information control 
lang 

deterministic techniques efficient non deterministic parsers 
editor proceedings second colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 
parr quong 

adding semantic syntactic predicates ll pred ll 
fritzson editor compiler construction th international conference cc volume lncs pages edinburgh springer verlag 
rekers 

parser generation interactive environments ph thesis university amsterdam 
ftp ftp cwi nl pub reports ps salomon cormack 

scannerless nslr parsing programming languages 
sigplan notices 
salomon cormack 

disambiguation scannerless parsing complete character level grammars programming languages 
technical report department computer science university manitoba canada 
tanaka 

integration morphological syntactical analysis glr parsing 
bunt tomita editors advances parsing technology pages 
kluwer academic publishers dordrecht netherlands 
thorup 

ambiguity incremental parsing evaluation 
technical report prg tr program research group oxford university oxford thorup 

controlled ambiguity 
acm transactions programming languages systems 
thorup 

disambiguating grammars exclusion sub parse trees 
technical report dept computer science university copenhagen denmark 
tomita 

efficient parsing natural languages 
fast algorithm practical systems kluwer academic publishers 
visser 

case study optimizing parsing schemata disambiguation filters 
fischer editors proceedings pages amsterdam 
dutch graduate school logic 
visser 

family syntax definition formalisms 
van den brand editors asf sdf 
workshop generating tools algebraic specifications pages 
technical report programming research group university amsterdam 
visser 

case study optimizing parsing schemata disambiguation filters 
nijholt editor international workshop parsing technology iwpt boston usa 
appear 
visser 

character classes 
technical report programming research group university amsterdam 
visser 

family syntax definition formalisms 
technical report programming research group university amsterdam 
wagner graham 

incremental analysis real programming languages 
sigplan notices 
proc 
acm sigplan programming language design implementation pldi 
technical reports programming research group note reports obtained technical reports overview www site url www wins uva nl research prog reports anonymous ftp ftp wins uva nl directory pub programming research reports 
moonen 
generic architecture data flow analysis support reverse engineering 
visser 
specification rewriting strategies 
bergstra sellink 
arithmetical module rationals reals 
visser 
character classes 
visser 
scannerless generalized lr parsing 
visser 
family syntax definition formalisms 
van den brand sellink verhoef 
generation components software renovation factories context free grammars 
olivier 
debugging distributed applications coordination architecture 
sellink 
formal axiomatization alphabet reasoning parametrized processes 
van den brand sellink verhoef 
reengineering cobol software implies specification underlying dialects 
visser 
polymorphic syntax definition 
van den brand klint verhoef 
re engineering needs generic programming language technology 
manuel 
ansi cobol iii sdf asf definition tool 

complete system valued logic 

transformations reduction systems 
van den brand klint verhoef 
core technologies system renovation 
moonen 
data flow analysis reverse engineering 
hillebrand 
transforming asf sdf specification application 
sellink 
conservativity leibniz equality 
dinesh 
specifying input output visual languages 
dinesh 
vas formalism vase 
hillebrand 
small language specification grid protocols 

transformation tool pure prolog programs algebraic specification 
visser 
solving type equations multi level specifications preliminary version 
argenio verhoef 
general conservative extension theorem process algebras inequalities 
bergstra sellink 
sequential data algebra primitives revised version 
visser 
multi level specifications 
van den brand klint verhoef 
reverse engineering system renovation annotated bibliography 
bergstra sellink 
sequential data algebra primitives 
olivier 
embedded system simulation 

translog interactive tool transformation logic programs 
bergstra hillebrand ponse 
grid protocols synchronous communication specification correctness 

termination confluence infinitary term rewriting 
bergstra gh 
stefanescu 
network algebra relation operators 
bergstra gh 
stefanescu 
network algebra synchronous asynchronous dataflow 
visser 
case study optimizing parsing schemata disambiguation filters 
van den brand visser 
generation formatters context free languages 

automatic analysis term rewriting systems proving properties term rewriting systems derived asf sdf specifications 

