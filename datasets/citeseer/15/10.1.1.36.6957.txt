issn de recherche institut national de recherche en informatique en automatique modal lambda calculus iteration case constructs pierre unit de recherche inria sophia antipolis route des lucioles sophia antipolis cedex france international fax international partir du international fax international modal lambda calculus iteration case constructs pierre th nie calcul projet rapport de recherche pages extension simply typed calculus allowing iteration case reasoning terms dened means higher order syntax introduced jo lle despeyroux frank pfenning carsten sch rmann 
thorny mixing achieved help operator modal logic 
give new presentation system reduction rules evaluation judgments compute canonical forms terms 
presentation modal calculus better user point view concise impose particular strategy reduction computation 
system enjoys decidability typability soundness typed reduction respect typing rules church rosser strong normalization properties 
conservative extension simply typed calculus 
key words higher order syntax induction recursion modal logic logical framework type theory un lambda calcul modal op ration de par cas sum une extension du calcul typ ration le par cas sur des termes nis au de la ordre sup pr sent par jo lle despeyroux frank pfenning carsten sch rmann 
ce lange est possible par intervention de op de la logique 
nous ici une nouvelle pr sentation de leur syst des de duction au lieu de valuation qui les formes des termes 
notre pr sentation sur un calcul modal pour 
elle est plus concise impose pas de strat gie re de duction 
notre syst rie les propri de du de correction de la duction typ par rapport au de church rosser de forte normalisation 
enn il est une extension conservative du calcul typ 
mots cl ordre induction recursion logique theories modal lambda calculus iteration case constructs higher order syntax pe representation technique proves useful logical framework language involves bindings variables 
borrowing variables meta level represent variables object language need worrying variable binding substitution renaming 
operations managed meta level 
parametric hypothetical judgments directly supported framework 
hand inductive denitions frequent mathematics semantics programming languages induction essential tool developing proofs 
unfortunately known type dened means higher order syntax dened inductive type usual inductive type theories cci wer pm martin logical framework nps instance 
rst step resolution dilemma jo lle despeyroux frank pfenning carsten sch rmann dps extension simply typed calculus recursive constructs operators iteration case reasoning enables higher order syntax inductive type 
achieve operator modal logic distinguish types functional terms typed simply typed calculus types functional terms possibly containing recursive constructs 
alternative presentation system claim better aspects 
mechanism mix higher order syntax induction typing reduction rules quite dioeerent 
presentations modal lambda calculus bdp pw dp 
chosen variant frank pfenning hao chi wong pw context stacks simple contexts 
peculiarity creates study terms generated syntax simpler dps construction system better user point view 
introducing operational semantics computes canonical form long normal form strategy system reduction rules allow certain mechanism reduction 
able classic proof techniques show important metatheoretic results decidability typability soundness typing respect typing rules church rosser property cr strong normalization property sn conservativity system respect simply typed calculus 
main problems encountered proofs due hand functional types types recursive constructors hand expansion 
solve problems due expansion previous done simply typed calculus jg system gha 
second section introduce version modal inductive system syntax typing reduction rules 
third section prove essential properties soundness typing cr sn deduce conservative extension simply typed lambda calculus 
discuss related works outline 
rr pierre system section syntax typing rules semantics system 
recall motivation 
higher order syntax mechanics higher order syntax hoas exposed places example hhp 
introduce simple example representation hoas prove useful illustrate mechanism reduction rules 
assume simply typed calculus extra equations want represent untyped lambda terms 
introduce type untyped lambda terms constructors lam app known hhp canonical forms fi normal long type toone correspondence untyped lambda terms correspondence compositional 
instance term type lam app represents untyped lambda term 
constructors dene inductive type usual inductive type theories inductive calculus constructions wer extended calculus constructions luo leftmost occurence type constructor lam 
allowed kind inductive denition confronted serious problems 
lose correspondence objects represent canonical forms type delta delta delta instance case construct denition function case inductive terms term lam case represent untyped 
lose important property strong normalization precisely write terms reduce 
goal introduce system repairs 
dps modal operator modal logic distinguish types functional terms typed simply typed calculus types functional terms possibly containing recursive 
instance system term case type constructor lam type typing judgment rule undesirable terms lam case 
syntax system roughly simply typed lambda calculus extended pairs modality induction 
addition polymorphism dependent types left 
inria modal lambda calculus iteration case constructs types describe types system rst consider countable collection constant types called ground types 
approach play role inductive types 
denition types types inductively dened types theta type said pure contains operator product 
contains operator said modal 
context stacks presentation pw context stacks simple contexts 
usual context gamma dened list unordered declarations variable type variables distinct 
context stack delta ordered list contexts separated semi colons gamma gamma denotes empty context empty stack 
notations context stack said valid variables stack distinct 
call local context stack delta gamma gamma context stack gamma notation delta gamma delta stack gamma gamma gamma context stack gamma gamma gamma 
similarly notation delta delta delta stack gamma gamma delta stack gamma gamma stack gamma gamma gamma gamma terms describing set terms consider nite collection constant terms constructors pure type gamma delta delta delta delta pure type 
type simply denition terms terms dened inductively terms hm fst snd hoeicase hoeiit oe function mapping ground types types collections terms indexed indexes constructors 
delay till section explanation arguments operators case 
modal operator introduces object type operator marks elimination term type usual terms equivalent ff conversion 
rr pierre typing rules typing rules combination rules simply typed calculus pairs projections modal lambda calculus pw rules recursive constructs case 
rules simply typed part calculus give classic typing rules simply typed part calculus pairs projections 
var local context delta delta delta valid delta delta app delta delta delta pair delta delta delta hm theta fst delta theta delta fst snd delta theta delta snd modal rules modal rules exactly similar pw 
delta delta delta delta pop delta delta gamma delta gamma valid inductive rules delta delta delta delta delta valid pure types 
inductive type 
collection possibly empty pure types 
decomposed delta delta delta ground type pure type 
denote delta delta delta pi dene inria modal lambda calculus iteration case constructs delta delta delta delta delta delta 
delta delta delta rz oe rz pi pi oe map oe ground types types extended pure types equation oe oe oe typing rules case ones case delta pi ln delta pi pi oe delta hoeicase pi oe delta pi ln delta pi oe oe delta hoeiit pi oe oe typing rules may complex rst sight naturally derived behaviour case operators respect reduction sections 
expressed bit typing rules similar dps notable dioeerences noticed modal core dioeerent 
context stacks contexts modal rules pop expressed simple way pw 
typing rules terms priori indexed indexes constructors 
means case construct dene term constructor need 
computing inductive terms type ln need dene terms ln mutually inductive 
notion essential implementation extension system logical framework quite orthogonal properties state prove 
interested reader nd denition mutual inductive types adopt completely formalized dps 
case construct take argument type dps map oe ground types types 
reduction rules case ensure oe signicant contrary construct types oe ln mutually dened needed 
orthogonal properties state choice uniform presentation slightly alleviates notations 
rr pierre basic properties system allows basic stack manipulations modal calculus case pw 
proposition stack manipulations term typed type context stack typed type manipulations stack swapping contexts dioeerent local context type form delta gamma delta gamma delta delta gamma delta gamma delta thinning adding declaration inside context stack delta gamma delta delta gamma delta delta gamma delta valid modal weakening adding context stack position delta delta delta gamma delta delta gamma delta valid strengthening removing unnecessary declaration declaration variable free term typed delta gamma delta delta gamma delta fusion replacing semi colons stack commas melting contexts single 
delta gamma gamma delta delta gamma gamma delta proof easily proved induction typing judgment 
notion substitution dened usual 
terms variable denotes term substituted note hoeicase hoeicase hoeiit hoeiit fortunately rule substitution admissible provable typing rules inria modal lambda calculus iteration case constructs proposition subst rule rule subst delta delta delta proof easily proved induction derivation delta notation delta valid stack contexts gamma gamma integer delta denotes stack delta contexts removed gamma gamma gamman empty stack inversion lemmas usual typing rules syntax driven pop rule 
rules bit complex rules app fst snd case 
instance rule app seen bottom top may break modal type types modal 
faced application try apply rule pop remove local context till free variables term local context 
inversion lemmas remain fairly simple enable give type checking algorithm 
proposition inversion lemmas delta declaration belongs local context delta form declaration belongs delta 
delta delta delta type delta delta form integer delta contains free variables 
delta hm theta delta delta delta fst type delta theta form integer delta contains free variables fst delta snd type delta theta form integer delta contains free variables snd delta delta delta delta rr pierre delta hoeicase pure types ground type pi rz pi pi oe oe delta pi delta pi pi oe type form integer local context delta contains free variables hoeicase 
delta hoeiit pure types ground type pi oe oe delta pi delta pi oe oe type form integer local context delta contains free variables hoeiit 
proof induction derivation hypothesis 
inversion lemmas easy induction typing derivation shows uniqueness type corollary uniqueness type delta delta despite non determinism typing system stack delta type term unique 
source non determinism typing derivation rule pop applied stage term type fortunately rule modify type term 
important property typing system decidability typability 
theorem decidability typability typability decidable stack delta term algorithm nding typable delta returning type delta proof prove theorem describing algorithm 
check delta valid 
know able type term delta 
inductively go term applying algorithm immediate subterms step inversion rules ensure soundness algorithm 
sake brevity show cases lookup type delta 
nd typed delta 
call associated type 
form declared local context typed delta 
return inria modal lambda calculus iteration case constructs hoeicase iteratively remove local context delta till contains free variable algorithm type new stack 
type returned pi type returned pi pi oe return type pi rz pi pi oe oe typed delta 
reduction rules case simple example turn semantics system 
inspired reduction rules case proposed martin hofmann hof means describe evaluation mechanism dps 
reduction rules ones underlying terms induction principles dh 
arguments case constructs dioeerent roles best illustrated reduction rules 
show reduction rules case simple setting example section 
sake simplicity introduce notations 
notations 
type dene bn equations bn bn gamma consider map oe inductive types types oe terms app type ln ln lam type ln app type lam type sake simplicity dene macros case case hoeicase app lam hoeiit app lam reduction rules 
example reduction rules case ones case app 
app case lam 
lam case 
rr pierre app 
app lam 
lam 
rst argument case constructs inductive term dissect representing untyped lambda term example 
second app function processes case constructor app 
third argument lam function processes case constructor lam 
roughly speaking case construct computes result applying app lam sons main argument 
iteration mechanism reduction bit dioeerent terms app lam applied result sons main argument 
fact eoeect term amounts replacing constructors lam app terms lam app see dps 
want higher order declarations main argument case functional type 
particular want able compute case projection leftmost constructor 
reason functional type case constructs take input values computation projections see dps 
examples 
assume dened types integers nat declaring constructors nat nat nat 
informally dene function counts number bound variables untyped term count app count count count lam count count function implemented system construct count hoeiit nat nat plus nat nat count type nat 
give example computation count number bound variables untyped lambda term count app lam lam 
nat nat plus count lam count lam reduces count lam 
nat nat count 
count 
inria modal lambda calculus iteration case constructs illustrate reduction mechanism dene function form type nat returns argument free variable abstraction term application 
form hoeicase instance form 
nat 
form lam 
nat 
reduction rules describe set reduction rules 
term calculus want obtain computation term object language represents 
seen earlier section canonical forms fi normal long correspondence object terms 
want computation return canonical forms 
means reduction rules incorporate expansion 
technical point view choice expansion allows keep simple case redexes 
allowed contraction reductions hoeicase app app lam 
app reduction case redex hoeicase app app lam 
hoeicase app app lam contraction inside case 
example shows order reduction allow contractions case redexes case redexes 
words term hoeicase app case redex 
natural app term canonical form represent term object level 
expansion reduction rule thoroughly studied see ck aka jg 
adopting forces restrict reduction rules way want strong normalization restrictions rst introduced min 
reduction consider congruence precisely compatible application induce slight changes usual schemes proofs church rosser strong normalization properties 
rr pierre fi delta delta 
fi delta delta 
delta abstraction fresh delta 
delta delta 
app delta 
step delta delta 
pop delta 
delta gamma 
app delta delta 
delta 
delta 
delta delta gamma 
delta gamma 
delta 
delta 
pi delta hm theta delta 
pi delta hm theta delta 
sp delta hfst snd mi delta hfst snd mi 
pair delta 
delta delta hm 
hm theta fst delta 
theta delta fst 
fst pair delta 
delta delta hm 
hm theta snd delta 
theta delta snd 
snd reduction rules 
simple types product modality purpose restrictions prevent expansions create new fi redexes generate reduction loops 
instance allowed abstraction expanded delta 

fi ff convertible forbid expansion abstraction 
similarly allow expansion left argument application delta 

choice expansion means keep track types terms 
term expanded type dene notion typed reduction 
reduction relation dened inference rules simple types product modality reduction rules case compatibility rules case voluntarily omitted types rules 
immediately retrieved section 
inria modal lambda calculus iteration case constructs delta hoeicase mn pi oe delta hoeicase mn 
mn pi oe delta hoeicase rk pi oe delta hoeicase rk 
rk pi oe delta hoeiit mn pi oe oe delta hoeiit mn 
oe hoeiit hoeiit mn pi oe oe delta hoeiit rk pi oe oe delta hoeiit rk 
oe hoeiit hoeiit rk pi oe oe reduction rules case delta hoeicase pi oe delta 
delta hoeicase 
hoeicase delta hoeicase pi oe delta 
delta hoeicase 
hoeicase delta hoeiit pi oe oe delta 
delta hoeiit 
hoeiit delta hoeiit pi oe oe delta 
delta hoeiit 
hoeiit compatibility reduction rules case rr pierre note reason compute long forms expand term type want expanded forms interested terms correspondence object level terms 
modality serves tool mix induction higher order syntax techniques 
long forms special virtue deserves special attention 
similarly products rule sp contraction rule 
usual dene relations 
conversion respectively transitive symmetric transitive closures 
write delta 
mn delta 
delta mn gamma 
mn typing judgments reduction judgments preserved manipulations stack 
proposition valid reduction judgments 
particular stack delta gamma valid delta 
delta gamma 
canonical forms canonical forms dened induction 
take account types terms 
usual denition simply typed calculus see dps dene judgments iis iis 
denition canonical forms delta means atomic type delta delta means canonical type delta judgments dened rules delta delta delta arrow type delta delta delta delta delta delta delta delta delta delta delta delta gamma delta delta fst snd delta hm theta delta theta hm delta fst delta theta hm delta snd delta pi ln delta hoeicase redex delta hoeicase pi oe delta pi delta hoeiit redex delta hoeiit pi oe oe inria modal lambda calculus iteration case constructs proposition delta ioe delta abstraction reduction rule applied expansion possible form 
delta ioe delta reduction rule applied proof give sketch proof induction hypothesis 
induction typedness hypothesis 
results section devoted proofs results 
classic properties subject reduction strong normalization established modal lambda calculus induction lel 
extend results recursive operators case 
section easiest result soundness reduction respect typing rules 
state important lemmas substitution reduction show local property 
prove key result strong normalization property deduce conservative extension 
results state soundness typed reduction respect typing rules 
prove important lemmas involving reduction substitution 
theorem soundness reduction delta 
delta delta proof easy 
induction derivation hypothesis delta 
examine relationship substitution typed reduction 
calculus 



proof property compatibility reduction operations 
valid side conditions reduction rules app 
fortunately illicit expansion step reversed fi reduction 


ff rr pierre property enables prove weak forms usual results 
rst lemma examine case reduces explicit links 
give example reduce 
stack delta consider expansion delta 
delta 
left argument application expanded 
common reduct 
denition 
call basic expansion reduction step delta 
directly obtained rule 
say sequence reductions delta 
basic expansion step reductions basic expansion 
lemma assume delta delta 
term delta 
delta 
expansion sequence delta 
fi reductions sequence delta 
basic expansions obtained basic expansion 
proof induction proof delta var delta 
basic expansion ioe delta 
basic expansion 
lam renamed free 
induction hypothesis delta 
delta 
rule delta 
delta 
basic expansion 
app 
case 
induction hypothesis delta 
delta 
delta 
delta 
know induction hypothesis delta 
basic expansion 
delta 
basic expansion conclude delta 
delta 
delicate case occurs delta 
basic expansion 
inria modal lambda calculus iteration case constructs induction hypothesis means step basic expansion 
reduced fi reduction conclude applying induction hypothesis typing rules resistance reduction compatible fst snd case 
similarly delta 
case delta 
example stack delta fresh 
delta 
fi reduction delta 
lemma assume delta delta 
obtained expansion occurrence abstraction delta 
reduction fi reduction 
delta 
basic expansion delta 
basic expansion 
proof induction derivation delta 
fi 
rename free delta 
equal 
lam rename free assume delta 

conclude induction hypothesis 
app easy induction hypothesis compatibility rules app assume delta 
expansion step 
induction hypothesis delta 
expansion step 
delta 
assume delta 
fresh variable abstraction 

abstraction expansion reduces 
means abstraction impossible hypothesis 
rr pierre abstraction case delta 
fi ff convertible 
delta 
reduction rules reduction compatible corresponding operators 
local lemma claims local reduction 
established termination reduction allows prove reduction 
bit local stated lemma 
strengthen induction hypothesis proof 
lemma local delta 
delta 
term delta 
delta 
basic expansion delta 
delta 
step sequences sequence basic expansion step 
delta proof induction derivation delta 
fi assume delta 
delta delta possibilities reduction step delta 
delta 
delta 
fi reduction 
lemma know delta 
delta 
delta 
delta 
delta 
fi lemma term delta 
delta 
may expansion sequences expanded delta 
delta 
abstraction delta 
expansion conversely delta 
fi reduction ff conversion 
inria modal lambda calculus iteration case constructs lam assume delta 
delta 
abstraction reduced body reduced delta 
delta 
induction hypothesis term delta 
delta 


basic expansions sequences reductions occur bodies abstractions 
app assume delta 
possibilities reduction step delta 
induction hypothesis term delta 
delta 
delta 
delta 
basic expansion 
case delta 
fi handled 
delta 
conclude easily delta 
delta 
delta 
delta 
delta 
basic expansion delta 
reduction step delta 
expansion 
app assume delta 
possibilities reduction step case delta 
fi reduction handled 
case delta 
handled app 
delta 
delta 
delta 
know delta 

delta 
know delta 
delta 
basic expansions 
induction hypothesis term delta 
delta 
sequences contain expansion steps done delta 
delta 
induction hypothesis know unique expansion step located sequences 
assume delta 
basic expansion delta 
rst sequence delta 
basic expansion step sequence 
delta 

fi delta 
expansion sequence 
rr pierre partly handled 
fact case easy prove generality 
assume delta 
abstraction delta 
expansion 
delta 
possibilities abstraction delta 
expansion 
delta 
fi ff convertible assume delta 
kinds reduction delta 
induction hypothesis term delta 
delta 
delta 
delta 
delta 
rule 
subcases reduction steps delta 
rule delta 
rule say reduction steps give term 
reduction steps delta delta 
easy see delta 
delta 
previous case 
fi pop easy 
cases rules pi pi sp pair pair fst snd similar cases modal reduction rules 
case dioecult long detail 
show proof looks treating cases 
assume delta hoeicase reduces hoeicase terms reduce 
similar case 
show cases 
assume stack delta hoeiit reduces oe hoeiit hoeiit mn inria modal lambda calculus iteration case constructs hoeiit terms reduce oe hoeiit hoeiit mn expansion oe hoeiit hoeiit mn strong normalization give proof strong normalization theorem system prove innite sequence reductions starting typed term 
proof follows sketch normalization proofs la tait inspired wer inductive part gha expansion part 
reducibility candidates give denition reducibility candidates glt adapted setting 
call set terms dened section 
denition reducibility candidates type candidates reducibility cra sets pairs delta context stack term 
dened follows cr delta strongly normalizing delta innite sequence reductions starting delta 
cr ae delta delta ag cr delta delta 
delta cr nt delta delta 
expansion delta delta cr delta delta fresh variable 
nt fx fhm ni 
set nt called set neutral terms 
rr pierre notice sets terms consider sets pairs stack term 
reduction typed convenient reducibility candidates contain typed terms 
rule cr restriction delta 
comes jg 
introduced cope expansions 
rule cr needed expansions gha 
version reducibility candidate enjoys usual properties proposition intersection reducibility candidates belong cra belong cra proof straightforward omit 
important consequence property cra inf semi lattice 
dene set reducibility candidates 
denition cra crb delta delta gamma context delta gamma delta gamma dg denition context gamma added stack primordial 
lemma allows add fresh variables context 
notation strongly normalizing term stack delta delta denotes length greatest sequence step reductions starting delta 
lemma cra crb delta forall gamma context forall delta gamma delta gamma delta proof condition cr notice delta neutral expansion possibly reduce 
delta sn delta 
prove induction delta delta forall delta gamma delta gamma forall delta gamma delta gamma denition allow conclude delta cr show reducts neutral term basic expansions belong ways reduce term delta gamma 
delta delta apply induction hypothesis 
delta gamma 
establish induction hypothesis forall delta gamma delta gamma lemma possibilities reductions delta gamma 
case property cr delta gamma 
inria modal lambda calculus iteration case constructs case abstraction obtained expanding variable 
delta gamma 
fresh variable fi reducing redex occurrences 
delta gamma delta gamma cr delta gamma cr delta gamma cases induction hypothesis valid delta gamma 
hypothesis 
prove set reducibility candidate 
proposition cr cra crb cra proof show properties 
cr want prove delta belongs sn delta 
rst notice variable free delta delta belongs reducibility candidate cra condition cr 
delta delta implies sn stack delta show induction delta sn delta fv sn delta 
precisely examine reduced terms prove sn 
delta 
reduction step dioeerent expansion step delta 
sn sn induction hypothesis sn 
delta 
fresh variable 
term sn reductions take place body abstraction sn sn ff convertible 
cr denition cr delta delta 
cases reduction step expansion forall delta gamma delta gamma 
cr delta gamma delta reduction step expansion delta 
variable fresh result follows lemma 
case hypothesis lemma delta gamma delta gamma delta gamma true belongs rr pierre cr nt delta verifying hypotheses condition cr delta gamma prove induction delta gamma cr pair delta gamma belongs nt delta gamma 
delta gamma 
apply induction hypothesis 
possible reduction step expansion abstraction 
cr delta want prove delta lemma 
denition forall delta gamma delta gamma say delta gamma lemma allows conclude delta dene useful operations reducibility candidates 
denition cra dene set delta delta delta stack compatible delta delta delta cg 
proposition cr cra cr proof cr obvious delta delta sn delta delta implies sn delta reduction compatible operator 
cr denition cr assume delta 
delta delta delta delta delta 
cr nt delta verifying hypotheses condition cr delta 
delta want prove delta delta delta valid delta delta condition cr 
delta delta 
reduction step dioeerent expansion means delta delta 
neutral form 
hypothesis delta delta delta denition reducts belong delta delta nally delta 
cr form denition theta cra crb dene theta set theta delta delta theta gamma context compatible delta delta gamma fst delta gamma snd dg 
inria modal lambda calculus iteration case constructs proposition theta cr cra crb theta cra thetab proof similar proposition 
omit 
interpretation types sketch normalization proofs la tait dene interpretations types 
denition ground type dene set delta delta sn delta proposition set reducibility candidate 
proof cr cr cr cr immediate 
cr easy neutral forall delta 
expansion notice reducts belong ground type expanded 
sn delta 
interpretations types dene interpretation type denition types delta delta gamma delta gamma delta gamma proposition reducibility candidates reducibility candidate 
proof immediate proposition 
far dened pure type easy see pure type reducibility candidate 
dene theta 
denition theta types theta theta theta set delta delta theta gamma compatible delta delta gamma fst delta gamma snd proposition theta types reducibility candidates theta reducibility candidate 
proof immediate proposition 
rr pierre cases depending form type pure type main argument case construct 
reduction deal modal 
denition pure type pure set delta delta delta stack compatible delta delta delta proposition pure type pure reducibility candidate reducibility candidate 
proof immediate proposition 
pure type delta delta delta denition bit dioecult write take account fact may type inductive argument case 
delta delta delta stack delta delta valid oe map ground types types map mapping ground type oe delta delta pi pi delta delta pi delta delta hoeicase pi delta delta hoeiit pi delta delta shortcut delta delta delta delta delta delta delta delta delta rz 
equivalently inria modal lambda calculus iteration case constructs rz pi pi call set total functions map pure type type dene operator giving pi pure types ground type oe delta delta delta delta delta valid delta delta pi pi delta delta pi delta delta hoeicase pi rz pi pi delta delta hoeiit pi delta delta oe total functions ground types types total functions mapping ground type oe course prove really operator belonging belongs purpose proposition 
prove key point monotone 
important property allow give rigorous denition pure involving smallest xpoint proposition operator belongs belongs pure type proof assume delta delta delta types pure ground type 
assume set delta delta delta show delta delta delta cr obvious delta delta 
cr denition 
cr delta delta delta delta delta 
delta delta delta delta delta delta delta 
reductions delta delta delta delta delta delta delta hoeicase 
hoeicase pi oe rr pierre delta delta hoeiit 
hoeiit pi oe oe 
delta delta delta delta hoeicase pi rz pi pi delta delta hoeiit pi implies delta delta delta delta 
cr principle proof proposition 
assume delta hypotheses condition cr 
show delta delta delta proving delta delta hoeicase pi rz pi pi delta delta hoeiit pi delta delta 
show proof looks hoeicase nt prove set pi rz pi pi contains reducts obtained expansion 
ways reduce hoeicase delta hypotheses cr neutral form case construct eliminated delta delta hoeicase 
case pi oe delta delta hoeicase 
case pi oe prove property induction 
cr type delta delta delta form lemma monotone 
inria modal lambda calculus iteration case constructs proof assume pure type pi pi pi pi similarly rz pi pi rz pi pi pure type 
denition denition pure call yf smallest xpoint denition pure type yf 
course justify denition 
notice inf semi lattice set type inf semi lattice 
existence yf proved tarski lemma monotone operator inf semi lattice inf semi lattice note image yf point dened interpretation type types theorem immediate corollary previous lemmas 
theorem type set proof induction lemmas denition 
state lemmas show interpretations types typing judgments reduction judgments invariant certain manipulations stack 
proposition weakening type delta delta gamma valid delta gamma 
proof examine dioeerent cases ground type delta delta gamma delta sn delta gamma sn delta 
delta gamma delta delta gamma gamma delta gamma gamma denition 
rr pierre theta delta gamma theta delta theta delta gamma gamma valid delta gamma gamma fst delta gamma gamma snd denition theta 
pure delta gamma delta delta gamma delta denition 
pure proceed 
denition 
proposition modal weakening type delta delta delta valid delta delta 
proof easy denitions 
interpretation context stacks dene notion interpretation context stack step key result section 
denition bit complex classic case simply typed lambda calculus deal context stacks contexts see lel 
denition pre substitution pre substitution ae stack delta stack psi mapping set variables declared delta set terms free variables psi 
pre substitution ae applied term free variables delta 
result operation denoted ae equal term free variables replaced images ae ae 
notations stacks delta psi pre substitution ae delta psi variable declared delta term free variables psi denote ae 
pre substitution delta psi ae 
ae declared delta ae 
stack delta delta delta valid substitution ae delta psi ae ae denotes pre substitution delta delta psi ae ae ae declared delta ae ae ae declared delta denition interpretation context stack stacks delta psi interpretation delta psi delta psi set pre substitutions delta psi 
dened induction delta notation psi dened section inria modal lambda calculus iteration case constructs psi singleton element empty pre substitution psi 
gamma psi set pre substitutions ae 
ae belongs gamma psi psi 
delta gamma psi set pre substitutions ae ae ae belongs delta psi ae belongs gamma psi soundness typing reach nal stage proof 
strong normalization property easy corollary key lemma soundness typing 
prove technical lemma involves modality useful typing restrictions implies 
lemma ae delta psi term delta pure ae mn resp 
ae mn nn resp 
nn 
proof variable assumed delta modal type 
compatible hypothesis pure variable distinct inversion lemmas delta previous case means modal type 
compatible hypotheses nn variable 
applying inversion lemmas see typed stack delta means modal type 
impossible nn resp 
nn 
remaining possibility 
lemma soundness typing delta ae delta psi psi ae 
proof induction derivation delta var denition delta psi rr pierre lam delta delta ae delta psi gamma context term psi gamma 
want show psi gamma ae 
ff conversion assume loss generality declared psi gamma ae 
delta psi induction hypothesis ae 
ae sn psi prove psi gamma ae belongs induction psi ae psi gamma condition cr 
ways reduce ae basic expansion psi gamma ae 
ae ae 
delta psi gamma ae 
ae 
induction hypothesis psi gamma ae psi gamma ae 
ae induction hypothesis 
psi gamma ae 
ae induction hypothesis 
app delta delta delta immediate denition ae ae ae 
pair delta delta delta hm theta induction hypothesis psi ae psi ae 
sn psi 
gamma context psi gamma valid 
show psi gamma fst ae hm psi gamma snd ae hm 
show properties induction psi psi cr 
instance fst ae hm neutral ways reduce psi gamma fst ae hm 
fst ae hm apply induction hypothesis 
psi gamma fst ae hm 
fst ae hm apply induction hypothesis 
psi gamma fst ae hm fst hae ae 
ae fst delta theta delta fst immediate denition theta ae fst fst ae 
snd delta theta delta snd immediate denition theta ae snd snd ae 
inria modal lambda calculus iteration case constructs delta delta immediate denition ae ae 
pop delta delta gamma delta gamma valid lemma 
delta delta delta delta belongs nt reducible expansion 
belongs interpretation type cr 
case immediate denition pure 
rule proof immediate denition pure 
delta delta dioecult case 
prove psi psi ae 
ae delta psi belongs delta psi psi psi psi ae induction hypothesis 
prove psi psi ae induction psi si ae cr 
ae belongs nt ways reduce term psi psi ae 
ae psi psi ae ae apply induction hypothesis 
pure conditions denition 
assume delta delta delta ground type 
assume psi psi valid psi psi pi pi oe want prove psi psi hoeicase ae belongs pi rz pi pi 
property cr examine possible forms ae ae redex case 
hoeicase ae belongs nt apply cr done induction psi psi ae psi psi 
cases bit dioecult correspond elimination case construct 
rr pierre ae mn respectively ae mn lemma know nn resp 
nn substitutions taken place subterms nn terms smaller apply induction hypothesis pairs delta delta ae belongs right interpretations types done 
proof pretty similar 
strong normalization theorem corollary previous lemma 
theorem strong normalization innite sequence reductions 
proof assume innite sequence reductions begins delta 
proposition delta previous lemma obvious fact pre substitution identity delta delta belongs delta delta see delta belong sn delta 
point proved local lemma strong normalization theorem 
proof corollary results fact called new 
theorem delta 
delta 
term delta 
delta 
proof result trivial 
lemma prove result induction delta 
assume delta 

delta 

lemma local term delta 
delta 
induction hypothesis term delta 
delta 
similarly term delta 
delta 
induction hypothesis allows claim delta 
delta 
term delta 
delta 
delta 
delta 
see 
corollary uniqueness normal forms delta reduces delta unique canonical form 
inria modal lambda calculus iteration case constructs proof know sequence reduction starting innite 
delta 
delta 
canonical forms lemma term delta 
delta 
canonical forms means oe oe oe oe oe oe proof conservative extension show calculus conservative extension simply typed calculus 
theorem corollary technical lemma 
notations stack delta gamma gamma variables declared respectively gamma gamma say declared term said pure term simply typed calculus say contains case modal operators pairs projections 
lemma possible forms canonical term stack delta local context gamma delta canonical form contains impure variable delta free variables impure variable impure abstraction type bound variable impure free variables belong gamma form closed rr pierre form hm ni free variables belong gamma pure pure 
free variables belong gamma 
proof induction judgment delta var type variable pure 
app delta delta delta examine possibilities closed free variables belong local context delta 
verify normal right type 
examine dioeerent cases 
verify type pure 
pure free variables belong gamma 
lam delta delta impure free variable free variables belong gamma impure abstraction pure 
fst delta theta delta fst fst verify right type fst normal 
impossible type theta snd similar previous case 
inria modal lambda calculus iteration case constructs pair delta delta delta hm theta examine possibilities hm closed free variables belong local context delta hm 
symmetrically conclude hm 
free variables local context delta 
hm 
delta delta verify right type normal 
impossible type delta delta induction hypothesis closed 
pop delta delta gamma premiss rule 
impossible premiss right type 
premiss 
obviously impossible premiss 
case delta pi delta pi pi oe delta hoeicase pi oe term terms free variables belong local context 
obviously impossible rr pierre closed term delta pi ln inversion lemma delta pi induction hypothesis pure impossible closed 
canonical form simply typed calculus know variable constant redex impossible dealing normal terms 
case rule similar previous 
theorem conservative extension system conservative extension simply typed calculus delta delta pure context stack pure type unique canonical form pure 
free variables belong local context delta 
proof know typed term reduces unique canonical form 
prove theorem just prove pure stack canonical form pure type pure free variables declared local context 
trivial corollary previous lemma 
related works system inspired dps 
main dioeerence underlying modal calculus easier better adapted extension dependent types 
written reduction rules evaluation inference rules 
metatheoretic proofs compact easier read 
raymond mcdowell dale miller proposed mm meta logic reason object logics coded higher order syntax 
approach quite dioeerent ambitious sense 
give typing system supporting judgments types principle logics level object meta 
induction natural numbers derive induction principles construction appropriate measure 
modal calculus primitive recursive constructs claim better previous proposition dps 
conservative extension theorem guarantees adequacy encodings preserved proved church rosser strong normalization properties 
main goal extend system dependent types polymorphic types 
kind extension straightforward expect system allow 
inria modal lambda calculus iteration case constructs interesting direction research consists replacing recursive operators operators pattern matching alf mn system implementing martin lof type theory nps 
hints concrete syntax extension dps 
pfenning sch rmann currently working denition meta logic lines 
acknowledgment jo lle despeyroux useful comments suggestions earlier versions 
aka 
mints reduction ccc calculus 
proceedings tlca pages 
springer verlag lncs 
bdp gavin bierman valeria de paiva 
necessity revisited 
technical report csrp school computer science university birmingham 
ck di cosmo 
reduction extensional typed calculus 
proceedings icalp 
springer verlag lncs 
dh despeyroux hirschowitz 
higher order syntax induction coq 
pfenning editor proceedings fth int 
conf 
logic programming automated reasoning lpar july volume 
springer verlag lnai 
dp rowan davies frank pfenning 
modal analysis staged computation 
jr guy steele editor proceedings rd annual symposium principles programming languages pages st petersburg beach florida january 
acm press 
dps jo lle despeyroux frank pfenning carsten sch rmann 
primitive recursion higher order syntax 
technical report cmu cs carnegie mellon university september 
dps jo lle despeyroux frank pfenning carsten sch rmann 
primitive recursion higher order syntax 
hindley de groote editors int 
conf 
typed lambda calculi applications tlca pages nancy france april 
springer verlag lncs 
gha neil ghani 
eta expansions system technical report liens liens dmi ecole normale superieure 
glt jean yves girard yves lafont paul taylor 
proofs types 
cambridge university press 
rr pierre hhp robert harper furio honsell gordon plotkin 
framework dening logics 
journal association computing machinery january 
hof martin hofmann 
private communication may 
jg jay ghani 
virtues eta expansion 
journal functional programming april 
lel pierre 
metatheoretic results modal calculus 
draft 
submitted publication 
luo zhaohui luo 
computation reasoning 
oxford university press 
min mints 
pages 
mm raymond mcdowell dale miller 
logic reasoning higher order syntax 
computer information science department university pennsylvania 
lics 
mn lena magnusson bengt nordstr alf proof editor proof engine 
henk barendregt tobias nipkow editors types proofs programs pages 
springer verlag lncs 
new newman 
theories combinatorial denition equivalence 
ann 
math 
nps bengt nordstr kent petersson jan smith 
programming martin type theory 
oxford university press 
pe frank pfenning conal elliott 
higher order syntax 
proceedings acm sigplan symposium language design implementation pages atlanta georgia june 
pm ch 
paulin mohring 
inductive denitions system coq 
rules properties 
groote bezem editor proceedings int 
conf 
typed lambda calculi applications tlca springer verlag lncs 
pw frank pfenning hao chi wong 
modal calculus 
brookes main editors proceedings eleventh conference mathematical foundations programming new orleans louisiana march 
appear electronic notes theoretical computer science volume elsevier 
wer benjamin werner 
une th orie des constructions 
phd thesis universit paris 
inria unit de recherche inria sophia antipolis route des lucioles sophia antipolis cedex france unit de recherche inria lorraine de nancy campus scientifique rue du jardin ls nancy cedex france unit de recherche inria rennes irisa campus universitaire de beaulieu rennes cedex france unit de recherche inria alpes avenue de europe montbonnot st martin france unit de recherche inria rocquencourt domaine de voluceau rocquencourt le chesnay cedex france inria domaine de voluceau rocquencourt le chesnay cedex france www inria fr issn 
