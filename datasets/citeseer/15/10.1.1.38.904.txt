logic programming system non monotonic reasoning jos alferes carlos viegas dam asio lu pereira evolution logic programming semantics included new explicit form negation older implicit default negation typical logic programming 
richer language shown adequate knowledge representation reasoning forms 
widespread extended programs requires definition correct top querying mechanism prolog wrt 
normal programs 
purpose exploit sldnf derivation procedure slx programs explicit negation founded semantics wfsx prove soundness completeness 
soundness wrt 
answer sets semantics shown 
choice wfsx base semantics justified structural properties enjoys paramount top query evaluation 
course introducing explicit negation requires dealing contradiction 
consequently allow contradiction appear show removed freely changing truth values subset set predefined revisable literals 
achieve introduced paraconsistent version wfsx wfsx allows contradictions slx top procedure proven correct 
procedure detect existence pairs complementary literals wfsx simply detecting violation integrity rules introduced language program 
furthermore integrity constraints general form allowed violation likewise detected slx 
removal contradiction integrity violation accomplished variant slx procedure collects formula alternative combinations revisable literals ensure said removal 
formulas simplification satisfied number truth values changes true false undefined 
notion minimal change defined establishes closeness relation program revisions 
changes enforced introducing deleting program rules revisable literals 
illustrate usefulness originality framework applied obtain novel logic programming approach results declarative debugging model diagnosis problems 
keywords logic programming procedures logic programming semantics non monotonic reasoning belief revision founded semantics 
time programming logic shown viable proposition 
mid desire impart computer ability reason logically lead development automated theorem proving took promise giving logic artificial intelligence 
result effort find simple efficient theorem proving strategies horn clause programming sld resolution discovered implemented 
univ portugal jja fct unl pt dcs nova de lisboa monte da portugal fct unl pt 
esprit br project portugal support 
horn clauses admit positive facts give rise monotonic semantics previous questioned spite additional information number derived decrease monotonicity 
concluded false assuming finitely proven true false 
condition prevents definition appearance contradictions 
horn clause programming augmented operator cf 
prolog sldnf derivation procedure allow negative drawn default implicitly just case corresponding positive forthcoming finite number steps specific form closed world assumption cwa completion semantics programs 
form negation capable dealing incomplete information assuming false exactly true finite manner 
remains issue non terminating computations finite programs 
deal problems completion semantics semantics proposals set forth late eighties onwards including founded semantics wfs deals semantically non terminating topdown computations assigning computations truth value false undefined giving semantics program 
semantics query evaluation procedures defined 
founded semantics deals normal programs just negation default provides mechanism explicitly declaring falsity literals 
serious limitation 
evolution logic programming lp semantics included new explicit form negation older implicit default negation typical logic programming 
richer language shown adequate diversity knowledge representation reasoning forms 
fact years authors stressed importance extending lp second kind negation deductive databases knowledge representation non monotonic reasoning nmr 
different semantics extended lps negation elp appeared 
particular generalization extended programs wfs defined wfsx taken base semantics article provides added qualitative representational expressivity capture wide variety logical reasoning forms serve instrument programming 
forms negation default explicit unrelated coherence principle stipulates entails 
default negation revision believed assumptions face contradiction integrity constraint violation non monotonic reasoning mechanisms available logic programming 
combination explicit negation adds qualitative representational expressivity shown 
widespread uses extended logic programs definition correct top querying mechanism required prolog wrt 
normal programs 
users normally wish know instances literal belong semantics semantics 
purpose exploit sldnf derivation procedure slx programs explicit negation founded semantics wfsx prove soundness completeness 
soundness wrt 
answer sets semantics shown 
additionally produced prolog interpreter procedure pre processor prolog show procedure amenability implementation 
lack space implementations described available request 
slx derivation method directly inspired semantic tree characterization wfsx presuppose 
fact seen preliminary step definition procedure concern actual construction trees assumed exist 
attribution failure success posteriori assuming required trees simultaneously available 
define derivations constructed top way arbitrary selection rule attribute success failure literals incrementally derivation develops 
characterization declarative semantics step procedural 
choice wfsx base semantics justified structural properties possess paramount top query evaluation 
properties approaches fully enjoy wfsx natural candidate semantics choice logic programs extended explicit negation 
exhibits structural properties foundedness cumulativity rationality relevance partial evaluation 
foundedness mean simply characterized recourse valued logic iterative fixpoint operators 
cumulativity refer efficiency related ability lemmas addition lemmas change semantics program 
rationality refer ability add negation non provable changing semantics 
relevance mean top evaluation literal truth value requires call graph 
partial evaluation mean semantics partially evaluated program keeps original additionally amenable top bottom procedures complexity finite datalog programs polynomial furthermore wfsx sound wrt 
answer sets semantics better answer sets simply wfs plus renaming literals cf 
proposition 
top method sound answer sets provides incompleteness 
properties wfsx detailed proven 
wfsx coincides wfs normal programs method applicable ground programs compares favourably previous approaches 
best knowledge literature addresses topic proof procedures extended logic programs 
author uses notion conservative derivability proof theoretic semantics extended programs 
provides program transformation programs normal ones 
proved kunen semantics applied transformed program sound complete wrt 
conservative derivability 
approach problems mainly motivated interpretation default negation finite failure recognized author 
instance program fa ag literal false undefined contrary results obtained answer sets wfsx true 
final conservative derivability defined programs functor symbols 
approach applicable extended programs functor symbols 
wfsx solves problems properly 
author deals contradiction inhibiting propagation consequences 
course introducing explicit negation requires dealing addition contradiction 
information normally incomplete contradictory 
consequence negation default assumptions contradiction 
amounts ancient logical principle reductio ad assumption leads contradiction withdraw 
major contribution tackling issue generality semantics extended logic programs 
allow contradiction appear show removed freely changing truth values subset set pre designated revisable literals 
achieve start introducing paraconsistent version wfsx wfsx permits contradictions slx top procedure proven correct 
procedure detect existence pairs complementary literals wfsx simply detecting violation integrity rules introduced language program 
furthermore integrity constraints general form allowed cf 
section stable model approaches answer sets enjoy cumulativity rationality relevance 
stable model approaches iterative top bottom operators complexity computing stable models program np complete datalog 
violation likewise detected slx 
removal contradiction integrity violation accomplished variant slx procedure collects formula alternative combinations revisable literal truth values ensure said removal 
formulas simplification satisfied number truth values changes true false undefined 
notion minimal change improving previous defined establishes closeness relation program revisions 
changes achieve revision enforced introducing deleting program rules revisable literals 
address minimization formulas obtained susceptible simplification methods generalized valued setting formula normalized 
incremental simplification methods possible 
procedures implemented run great variety non monotonic reasoning problems solved extended logic programming published aforementioned 
introduced extensions logic programming language allow representation preference relations revisions 
essential efficient practical revision methods 
structure remainder structured sections follows 
firstly argue need extended logic programs types negation default explicit 
secondly produce overview wfsx base semantics 
thirdly motivate recap sound theoretically complete top procedure slx deciding literal belongs founded model wfsx 
address problem revising contradiction introduce paraconsistent version wfsx 
show slx procedure sound complete respect able detect pairs complementary literals contradiction obtains 
subsequently elaborate slx procedure employing combination sound complete pruning rules wrt 
finite ground programs 
section addresses issue revising programs contradictory wrt 
set integrity constraints 
language extended allow general form integrity constraints 
introduced notions program state revision closeness revisions original program 
reader find extended application examples fields declarative debugging diagnosis show utility general revision framework 
novelty approach lies formalization closeness relation general integrity constraints 
applications non monotonic taxonomies hypothetical abductive reasoning reasoning actions model diagnosis declarative debugging see 
subsection overviews issues involved implemented program revision minimization change procedures lack space detail 
subsection provide detailed theoretical insights justifying choice particular closeness relation 
follow discussion mention 
appendix contains proof correctness slx wrt 
paraconsistent wfsx 
appendix contains proofs distance closeness program states 
extended logic programs section reviewing main motivations introducing second kind negation logic programs 
normal logic programs negative information implicit possible explicitly state falsity propositions assumed false reason believe true 
wanted cases 
instance classical example database explicitly states flight connections wants implicitly assume absence connection database means connection exists 
serious limitation cases 
argued explicit negative information plays important role natural discourse common sense reasoning 
representation problems logic programming natural logic programs way explicitly representing falsity 
consider example statement penguins fly way representing statement logic programming ly penguin representation capture connection predicate ly predication flying 
clearer additionally want represent statement birds fly 
clearly statement represented ly bird 
connection whatsoever exists predicates ly ly intuitively obvious connection established 
importance connections grows think negative information representing exceptions rules 
statement seen exception general rule normally birds fly 
case really want establish connection flying flying 
exceptions expressed sentences negative common legislation 
example consider provisions british citizens citizenship subject provisions section secretary state may order british citizen subsection applies british citizenship secretary state shall person british citizenship section clearly logical form form 
clear exception rule 
argued need having explicit negation heads rules 
reasons compel believe explicit negation needed bodies 
consider statement school bus may cross railway tracks condition approaching train wrong express statement rule cross train 
problem rule allows bus cross tracks information presence absence train 
situation different explicit negation cross train 
bus allowed cross tracks bus driver sure approaching train 
difference logic program essential assume available positive information complete assume absence information clearly denotes falsity 
explicit negation combination existing default negation allows greater expressivity say representing statements driver sure train approaching wait natural way wait train 
examples combinations appear legislation 
example consider article british nationality act equivalently suggested fly penguin 
example due john mccarthy published time 
new born infant commencement abandoned united kingdom shall acquire british citizenship section shown case person born clearly conditions form shown case expressed naturally motivation introducing explicit negation logic programs relates symmetry positive negative information 
special importance negative information easier represent positive 
represent negatively say positive information corresponds complement 
order clearer take example example consider graph description predicate arc expresses graph arc vertex vertex suppose want determine vertices terminals 
clearly case complement information easier represent easier determine vertices terminal 
explicit negation combination negation default easily say terminal vertices nonterminal terminal arc terminal terminal important motivation extending logic programming explicit negation generalize relationships logic programs non monotonic reasoning formalisms 
relationships drawn semantics normal logic programs proven extreme importance sides giving mutual benefits clarifications 
extended logic programming shown adequate forms reasoning incomplete information contradiction handling belief revision default abductive counter factual hypothetical 
shown adequate knowledge representation forms rules default rules constraints denials exceptions defaults preferences defaults hypothetical possibilities falsity explicit default negation see 
wfsx overview section sake self sufficiency recall language logic programs extended explicit negation extended logic programs short briefly review wfsx semantics 
extended program set rules form lm lm ln objective literal 
objective literal atom explicit negation sequel denote complementary literal wrt 
explicit negation set objective literals program called extended herbrand base denoted symbol stands negation default called default literal 
literals objective default literals 
fa mean fnot interpretation extended program denoted disjoint subsets objective literals said true objective literals false default gamma undefined wfsx follows wfs normal programs plus coherence requirement relating forms negation objective literal entailed semantics entailed 
designation literature operational negation failure prove 
note requirement obeyed answer sets wfs explicitly negated literals simply replaced new atoms 
requirement states literal explicitly declared false coherence assumed false default 
epistemic view logic program coherence seen instance necessitation principle 
principle states known believed 
consequently known false explicitly false believed false false default 
example consider program married mary tom married mary peter married mary peter married mary tom married mary tom coherence wfsx program entails married mary tom consequently married mary peter 
result answer sets 
simply wfs renaming explicitly negated literals program entail married mary peter result 
adequate purposes wfsx distinctly different manner respect original definition 
presentation alternating fix points gelfond lifschitz gamma operators 
proof equivalence definitions proofs results section 
recalling definition gamma definition gamma operator extended program interpretation resp 
obtained resp 
denoting literal new atom say gl transformation program obtained removing rules containing default literal removing remaining default literals model gammai obtained replacing introduced atoms impose coherence requirement introduce definition semi normal version program semi normal version program program obtained adding possibly empty body rule body default literal complement wrt 
explicit negation 
gamma denote gamma gamma denote gamma ps definition partial stable model set objective literals generates partial stable model psm extended program iff gamma gamma gamma partial stable model generated interpretation gamma gamma 
words partial stable models determined fix points gamma gamma fix point objective literals true psm objective literals gamma false default undefined 
objective literals gamma true undefined ones 
note condition imposes literal true false default viz 
belongs belong gamma gamma vice versa 
note gamma imposes coherence true belongs gamma semi normality rules removed consequently gamma false default 
example program fa ag partial stable models 
fix point gamma gamma fa ag fa ag gamma fa ag fg 
psm 
programs partial stable models said contradictory 
section elaborate results obtained gamma gamma contradictory programs 
define semantics non contradictory programs 
theorem wfsx semantics non contradictory program wrt 
partial stable model founded model wfm 
obtain iterative bottom definition wfm define transfinite sequence fi ff fg ff gamma gamma ff ffi fi ff ff ffi limit ordinal ffi exists smallest ordinal sequence smallest fix point gamma gamma wfm gamma gamma 
constructive definition literals obtained application gamma gamma ff true wfm literals obtained application gamma gamma ff ff false default wfm 
note alternating fix point definition wfs definition wfsx relies application anti monotonic operators 
definition wfs operators distinct 
ll see points definition kinds derivation procedures reflecting applications gamma proving verity objective literals reflecting applications gamma proving non falsity objective literals 
meshed proof verity translated failure prove non falsity theorem relation wfs normal logic programs explicit negation wfsx coincides founded semantics 
theorem relation answer sets extended logic program answer set 
answer set psm objective literal ffl wfm belongs answer sets ffl wfm belong answer set lack space elaborate relation answer sets semi normality imposes coherence 
interesting note combination gamma operators define wfsx operators gamma gamma gamma gamma gamma gamma gives semantics sound wrt 
answer sets close wfsx 
close mean fix points subsets intersection answer sets smaller wrt 
set inclusion wfsx 
say wfsx combination best approximation answer sets semantics compared 
proposition non contradictory program 
ffl lfp gamma gamma lfp gamma gamma lfp gamma gamma ffl lfp gamma gamma lfp gamma gamma lfp gamma gamma slx derivation procedure section review definition slx top derivation procedure logic programs extended explicit negation founded semantics correctness wrt 
wfsx proven 
definition slx relies sldnf known definitions derivation refutation failure 
sake simplicity recap definition ground possibly infinite programs 
order informally motivate definitions start simpler problem programs explicit negation 
known main issues definition top procedures wfs infinite positive recursion infinite recursion combination exactly corresponds wfs renaming explicitly negated literals 
stands extended programs sl stands selected linear 
negation default 
gives rise truth value false involved recursion exist refutation refutation truth value undefined refutation 
apart additional problems mainly follow ideas sldnf refutations derivations empty goal derivations constructed resolution negation failure rule stating selected removed goal refutation goal derivation 
solve problem positive recursion sls resolution introduced failure rule necessarily finite derivations 
example fp pg derivations prefix 
prefixes infinite derivation refutation goal different empty goal 
stipulating infinite derivation refutation refutation refutation 
recursion negation default want refutations violate negation failure rule 
fact rule sldnf states refutation succeed removed goal refutation fail goal derivation 
sldnf relies valued semantics failure verity means falsity vice versa 
wfs valued semantics apply 
fact wfs failure simply means true false undefined 
solve problem defined derivation procedures consider extra status undefined undetermined assigned goals 
literals involved infinite recursion negation assigned status 
shall see approach easily generalize extended programs cf 

considering extra status similarity sldnf distinguished kinds derivations slx derivations prove verity wfm slx tu derivations tu stands true undefined prove non falsity wfm 
verity succeeds iff slx tu refutation false non falsity succeeds iff slx refutation true 
having kinds derivations easy define derived goal goal selected literal involved recursion negation default 
case wfs undefined failed goal derivation occurs slx derivation refuted removed goal occurs slx tu derivation 
example fp pg order prove verity start building slx derivation resolving goal program rule obtain goal derivation slx tu refutation replaced empty goal 
start building slx tu derivation resolving goal program rule obtain recursion negation default 
derivation true undefined removed goal derived goal empty goal 
gives slx tu refutation turn determines goal slx derivation making failed 
undefined derivations fail successful tu derivation 
having kinds derivations duplicate 
fact derivation type simply seen status assigned usual derivation 
status fails literals involved recursion negation succeeds literals 
motivate generalization procedure deal explicit negation wfsx 
lot points treatment extended programs akin normal ones atoms refer objective literals expected objective literals treated exactly atoms wfs 
main difference generalization extended programs resides treatment negation default 
order fulfill coherence requirement additional way refute literal fact true true 
example consider wfm bg order prove verity starts build slx derivation goal solving rule obtain said build slx tu derivations solving program rule obtain case recursion negation default tu derivation derived goal 
consequently refutation true coherence refuted additional method proof default literals coherence 
slx derivations order obtain coherence introduce extra possibility removing goal slx derivation selected literal removed goal slx tu refutation slx refutation care taken non falsity derivations coherence requirement override undefinedness cf 
example consider wfm cg trying prove verity starts building slx tu derivations check fail 
possible derivation starts determine derived goal tries find slx refutation reader easily check exist 
slx tu refutation slx refutation belongs wfm note problem occurs slx tu refutation exist false 
falsity wfm imposed coherence principle true 
note derivations 
fact slx tu derivation goal true 
general slx tu derivation resolution applied selected objective literal slx refutation note coherence intervenes differently tu derivations 
consequence having distinct anti monotonic operators definition wfm 
point easier understand claim usage undefined status having different kinds derivation hampers generalization extended programs 
fact normal programs simply replace kinds derivations addition undefined status single difference derivation types success failure literals involved infinite recursion default negation 
extended programs differences regards applications coherence principle distinction crucial 
formalization intuitions yields definitions derivations refutations definition slx refutation failure slx refutation resp 
slx tu refutation finite slx derivation resp 
slx tu derivation ends empty goal 
slx derivation resp 
slx tu derivation slx failure iff refutation infinite ends goal empty goal 
definition slx derivation extended program arbitrary fixed computational rule 
slx derivation defined follows ln suppose selects literal 
ffl objective literal input rule bm derived goal gamma bm ln ffl slx refutation slx derived goal gamma ln ffl goal derivation definition slx tu derivation extended program arbitrary fixed computational rule 
slx tu derivation defined follows ln suppose selects literal 
ffl objective literal exists slx refutation goal derivation 
input rule bm derived goal gamma bm ln rule goal derivation 
ffl slx refutation goal derivation 
slx derivations slx failures derived goal gamma ln due infinite recursion default negation happen previous points determine derived goal 
case definition derived goal gamma ln soundness procedure wrt 
wfsx answer sets semantics theoretical completeness wrt 
wfsx proven 
section simply theorems 
proofs follow immediately proofs theorems appendix theorem soundness slx non contradictory extended logic program arbitrary literal slx refutation wfm 
corollary soundness wrt 
answer sets extended logic program answer set arbitrary objective literal slx refutation belongs answer sets slx refutation answer set theorem theoretical completeness slx non contradictory program arbitrary literal wfm exists slx refutation practice completeness achieved general wfm computable 
theory possible need constructing derivations completeness obtained 
detecting contradictions mentioned able run non contradictory programs goal 
re interested detecting occurrences contradiction order remove 
remove contradiction shall see detail section need detect importantly need know reasons causes lead contradiction assumptions responsible contradiction supporting 
definition wfsx correctness results slx serve purposes 
note wfm defined non contradictory programs correctness proven programs 
argued definition wfsx detecting contradiction possible know program psms 
shown slx detect contradiction program contradictory exists slx refutations results weak purpose semantics slx determine contradiction removed 
guide causes contradiction 
able determine causes section generalize wfsx order define paraconsistent wfm contradictory programs show correctness slx lifted paraconsistent case 
main idea paraconsistent wfsx wfsx short calculate keeping coherence consequences program leading contradiction arising contradiction example provides intuitive preview intend capture example consider program iii ii iv 
hold rules 
hold rules ii 

hold coherence principle relating negations 

hold rules iii iv 

hold rules iii iv rules 
hold coherence principle 
set literal consequences fnot argue wfsx fact semantics 
view wfsx tool needed detecting contradiction causes wfsx able assign meaning program 
tool basis removing contradiction possible 
semantics assigned original wfsx program obtained removing contradiction 
purpose wfsx detect contradiction basis wfsx principle allows derivation literals wfsx enforced wfsx coherence kept paraconsistent case 
wfsx defined contradictory programs programs psms 
definition psm program fix points gamma gamma fix points gamma gamma comply gamma theorem shows case impossible programs contradictory fix points gamma gamma kind paraconsistent reasoning called liberal reasoning 
theorem operator gamma gamma monotonic arbitrary sets literals 
proof prove arbitrary sets objective literals gamma gamma gamma gamma proving gamma gamma anti monotonic assume definition gl transformation clear resp 
ps ps 
transformed programs definite horn clause logic monotonic directly follows gammab gammaa resp 
gamma gamma 
anti monotonicity gamma gamma gamma anti monotonicity gamma gamma gamma gamma gamma consequently program fix point gamma gamma program fix point gamma gamma complies condition definition program non contradictory fix point wfm 
program contradictory 
test knowing program contradictory fix point gamma gamma simplified program non contradictory iff fix point gamma gamma pair complementary literals cf 
theorem 
lemma non contradictory set literals fl lg gammas gamma proof literal gammas gammas 
hypothesis non contradictory gammas definition gamma clearly implies gamma theorem fix point gamma gamma program gamma iff fl lg proof fl lg calculating gamma rules deleted 
belong gamma gamma prove lfp gamma gamma fl lg gamma start showing assumptions gamma post fixed point gamma gamma gamma gamma gamma gamma inclusion proven steps gamma gamma gamma gamma gamma gamma gamma 
trivially gamma monotonicity gamma gamma implies gamma gamma gamma gamma gamma 
trivially gamma gamma anti monotonicity gamma implies gamma gamma gamma gamma gamma gamma 
hypothesis fl lg gamma follows gamma gamma gamma gamma similarly proof lemma gamma gamma gamma gamma 
anti monotonicity gamma gamma gamma gamma gammat implies gamma gamma gamma gammat lemma gamma gamma gamma gammat gamma gamma post fixed point gamma gamma gamma gamma monotonic lfp gamma gamma gamma hypothesis lfp gamma gamma gamma properties intersection gamma recall lfp xg monotonic operator complete lattice 
interested wfm condition gamma replaced testing complementary literals 
noted page condition guarantees literals true false default 
removing condition guarantee longer valid 
precisely want definition paraconsistent wfsx note belong desired semantics example 
explained points definition wfsx construction wfm fix point gamma gamma kept condition gamma removed contradictory programs contain pair complementary literals wfm definition paraconsistent wfsx extended program fix point gamma gamma paraconsistent founded model wfm gamma gamma 
theorem generalization wfsx wfm non contradictory iff objective literal fl lg non contradictory wfm wfm 
definition fulfill objectives put section 
words wfsx comply coherence 
calculate consequences program leading contradiction arising contradiction 
answer questions 
fact wfsx complies coherence easy check 
argument non contradictory programs model belongs gamma semi normality rules removed consequently gamma checking verity answer second question immediate 
wish guarantee literal true false consider consequences true false 
look property sequence calculating fix point gamma gamma program 
proposition fi ff sequence calculating fix point gamma gamma program fi element sequence arbitrary literal ffl gamma fi wfm ffl gamma gamma fi wfm 
proof sketch proof second item trivial monotonicity gamma gamma prove item prove sequence obtained iterating gamma gamma starting gamma fg decreasing 
result proven 
brevity proof long 
property envisage applications gamma determining verity default literals assuming ls false ls determined true applications gamma determining verity objective literals assuming ls true ls determined false 
consequently guarantee literal true false consequences follow obtained guarantee applying gamma belong argument maximize default literals applying gamma belong argument maximize objective literals 
proposition just proposition contradictory program fix point gamma gamma fl lg exists element ff sequence calculating fl lg ff ordinal fi ff fl lg fi gamma fi gamma fi proof sketch existence ff guaranteed definition sequence 
consequence follows immediately monotonicity gamma gamma second third follow semi normality gamma example sequence fix point gamma gamma program example fg gamma gamma fg fa ag gamma gamma fa ag fa gamma gamma fa fa wfm fnot 
note obtained gamma obtained gamma gamma having defined wfsx contradictory programs order implement wish define top derivation procedure 
theorems show new derivation procedure needed slx correct wrt 
paraconsistent wfsx 
theorem soundness slx extended logic program arbitrary literal slx refutation wfm 
theorem theoretical completeness slx extended program arbitrary literal wfm exists slx refutation implementation slx sound complete paraconsistent wfsx slx effective finite ground programs 
fact furnishes mechanism detecting loops termination guaranteed 
completeness ideal completeness 
order provide effective implementation slx tackle issue guaranteeing termination 
wfs normal programs wfsx wfsx general computable 
possible guarantee termination general case 
section modify slx termination guaranteed finite ground programs modified slx procedure easily implemented prolog meta interpreter due sldnf resemblance easy implement pre processor compiles wfsx programs prolog format corresponding specialization interpreter rules plus small number general built predicates 
lack space prevents presenting implementations guaranteeing termination guarantee termination finite ground programs section introduce rules prune slx derivations eliminate cyclic positive recursion cyclic recursion negation default simply called cyclic negative recursion 
detect kinds cyclic recursions kinds ancestors ffl local ancestors assigned literals goals derivation detecting cyclic positive recursion 
purpose including local ancestors replace literals goals pairs literal set local ancestors 
ffl global ancestors assigned derivations detect cyclic negative recursion 
proofs appendix technique re define guarantees termination allowed bounded term non ground programs 
discussion guaranteeing termination cases scope 
simply done mimicking definition slx derivations ancestors considering left selection rule 
code available request 
intuitively thinks derivation expanding tree local ancestor literal occurrence literals appearing path root tree occurrence 
global ancestors subsidiary derivation local ancestors literal invoked plus ancestor goal derivation appears 
top goal derivation global ancestors 
divide global ancestors sets global ancestors global tu ancestors 
global ancestors resp 
tu ancestors introduced slx derivation resp 
slx tu derivation 
deal non termination problem cyclic positive recursion suffices guarantee infinite derivations generated 
achieved selected literal belonging set local ancestor expanded 
leads pruning rule 
goal slx derivation tu literal selected belongs local ancestors goal derivation 
treat cyclic negative recursion tests global ancestors necessary 
easily shown form recursion reduces combination cases depending cycle occurring possible derivation types 
slx tu derivations selected literal removed goal slx derivations goal derivation 
combinations reduced just lemma reduction negative cycles cyclic negative recursions detected slx derivations looking global ancestors 
hold combination case cycles detectable test lemma cf 

lemma yields pruning rule 
goal slx derivation literal selected belongs set global ancestors goal derivation 
theorem elimination cyclic recursion wfsx pruning rules necessary sufficient guaranteeing positive negative cyclic recursions eliminated 
embed pruning rules definitions slx derivation refutations failures remain 
note pruning rules tu ancestors 
considered definitions definition slx derivation ancestors extended program arbitrary fixed computational rule 
slx derivation st defined follows fg 
ln sn suppose selects 
ffl objective literal st input rule bm derived goal gamma gamma bm ln sn fl ffl slx refutation fg ancestors st slx tu refutation fg ancestors derived goal gamma gamma ln sn ffl goal derivation 
definition slx tu derivation ancestors extended program arbitrary fixed computational rule 
slx tu derivation ancestors st defined follows fg 
ln suppose selects 
ffl objective literal rule goal derivation 
exists slx refutation fg ancestors st goal derivation 
input rule bm derived goal gamma gamma bm ln sn fl ffl slx refutation fg ancestors st goal derivation 
derived goal gamma gamma ln sn theorem correctness slx ancestors extended program 
ffl wfm slx refutation fg empty ancestors 
subsidiary derivations needed refutation finite finite number 
ffl wfm slx derivations fg empty ancestors finite goal different 
subsidiary derivations needed finite finite number 
proof follows theorems 
revision framework previous sections paraconsistent version wfsx corresponding top querying procedure able detect contradiction programs 
ready foster stance adopted program contradictory revision order 
revision contradictory program mean non contradictory program obtained introducing new predicates 
question immediately arises changes allowed order obtain clearly modification result changing directly truth value considered basic literals 
question hinges literals revisable ones allow explicit modification truth values 
argued previous modification solely literals depend literals introducing removing rules basic literals 
stance take 
purpose defining revision describing framework explicitly divides program pair called program state element contains subprogram changed contains subprogram changed predefined way adding rules simple fixed form revisable literals 
part contains rules literals depend 
program state changed state simply modifying part 
order formalize notion program states defining open programs 
open sense part changed fixed truth value 
changes truth value non revisable literals indirectly brought program rules changes open part program presence rules revisable literals 
considered contradiction coming simply nonexistence consistent wfsx 
general reasons consider program state unacceptable due additional integrity knowledge intended program semantics 
encompass situations extend language deal general integrity constraints form ln ln ln ln literal stands classical implication 
program contradictory iff wfsx contradictory violates integrity constraint 
theorem proviso removed adding constraint literal program 
previous considered separately cases removing contradiction changing truth value revisable literals undefined true 
note absence integrity constraints contradiction removed changing truth value literals undefined 
order apply contradiction removal approach diagnosis instance felt need stronger revisions truth value literals changed true 
normality component assumed wanted abnormality posited order derive available information known fault models 
mentioned allow revision introducing removing rules revisable literals change truth values value value mixed way 
relying general integrity constraints mixture literal revisions undefined default complement value obtained 
constraint requires truth value literals knowledge minimally changed undefined desires literal say ab diagnosis setting solely truth values false true may simply introduce constraint ab ab example shows mixed revision perform valued declarative debugging declarative debugging programs valued semantics 
show utility diagnosis setting subsection 
structure remainder section follows extending language general integrity constraints 
framework open programs program states subsection define declarative semantics revision means minimal changes current contradictory program state 
integrity constraints argued reiter basic utility integrity constraints program database states considered acceptable constraints meant enforce acceptable states filtering ones 
integrity constraints types static enforcement constraints depends current state database independently prior state 
dynamic depend program states 
reiter gives example employee salaries decrease 
purpose article address evolution program time static constraints considered 
reiter shows classical accounts integrity constraints order knowledge bases consistency entailment database capture intuitions 
author argues program expresses knowledge external world integrity constraints address epistemic state program knows 
problems carry setting assume database semantics defined finite ground programs 
single valued model program state epistemic theoremhood views coincide 
address problems allow disjunction heads rules 
due fact considering valued setting approaches valued revision abductive frameworks immediately carry 
start presenting integrity constraint language definition integrity constraints integrity constraint extended logic program normal form literal belonging language ln ln ln ln empty consequent head associate symbol empty antecedent body symbol integrity theory set integrity constraints standing conjunction 
notice literals appearing constraints objective default ones 
theoremhood view integrity constraint checking define constraint satisfaction manner definition constraint satisfaction set literals ground integrity constraint ln ln ln ln violated iff literal ln ln literals ln constraint satisfied equivalently integrity constraint satisfied iff classical implication satisfied ln ln ln simplicity restrict constraints finite number literals finite interpretations 
general case countable sets literals necessary extend setting order logic 
assume underlying interpretations general possible 
enforcing condition explicit statement integrity theory 
necessary consider basic building blocks constraints form literal able program elaborate conditions 
combining primitive constraints connectives express property interpretation subsequently condition easily rewritten integrity theory form properties propositional classical logic translated conjunction simple classical implications normal form disjunction conjunction 
impose value condition specific literal table resp 
mean false resp 
undefined true obtain corresponding integrity constraint theory 
condition integrity theory condition integrity theory table basic conditions notion constraint satisfaction refers arbitrary set literals contradictory 
example imagine condition undefined false true verified interpretation 
lookup table formalize means classical meta interpretation integrity constraints obtain moving negated conjuncts consequent implication produce integrity constraint theory fc bg reader check interpretation obeys condition iff true 
special integrity theories enforce known basic principles 
suppose ground objective literals conditions integrity theory 
condition coherence requirement interpretations 
condition expresses type closed world assumption assumed false explicitly false combination explicit negation default negation equivalent 
conditions enforce non contradiction interpretations notice coherence imposed reduces 
non undefinedness literals ensured condition stronger presence coherence principle 
ll mainly explicit contradiction avoidance condition meaning programs paraconsistent founded model enforces coherence open programs formally define framework open programs program states mentioned section 
truth varying basic beliefs represented open program set objective literals open literals truth values determined 
fixed part open program arbitrary extended logic program derives additional knowledge open literals value known 
integrity constraints prune unintended combinations literals 
formally definition open program open program triple hp ics component extended logic program second set integrity constraints definition third set objective literals iff set open literals 
additionally rules open literals 
open program state established introducing open literal rule defining truth value 
definition program state program state open program ics tuple pv ar ics literal variable part pv ar contains just rules ar ar ar ar 
rules belong pv ar symbols belong models 
belong model 
meaning symbols programmed fact rule absence fact rule words adding rule resp 
literal assigned truth value true resp 
undefined false 
example program contradictory 
revise characterize state oe pv ar ics fa dg pv ar fb ics ff hg fb dg remove contradiction change rules ar program state thought correspond agent set beliefs world 
basic beliefs represented variable part program state 
fixed part allows agent express extract derived beliefs basic ones 
integrity theory states directly indirectly combinations possibly contradictory beliefs sustainable agent 
note trivial fixed part rule dependent belief expressed variable part literal 
instance ll see diagnosis setting variable part contains normal faulty behaviour modes 
fixed part describes behaviour components correct faulty modes system topology predicted outcomes 
integrity theory express meta knowledge system component abnormal correct simultaneously node values variable component determines interpretation vice versa shown table pair open literals fl lg 
coherence requirement imposed additional proviso definition guarantees non contradiction ar convention writing variable part omit rules form effect 
interpretation variable part interpretation variable part fnot lg fl fg fl ug fnot lg fl ug fnot lg fl tg fnot lg fl fl lg fl table correspondence interpretations variable part program state associate interpretations 
omega denote open program ics oe program state ar ics omega gamma model omega determined oe denoted oe wfsx pv ar 
basic beliefs oe denoted oe captured wfsx oe oe pv ar 
definition contradictory program state program state oe contradictory iff pv ar contradictory exists integrity constraint oe violated oe 
non contradictory 
clearly argued section sentence fix pv ar contradictory removed definition ics form introduced proposition oe state open program ics ics ff oe contradictory iff exists integrity constraint ics violated oe 
example cont 
program state oe example oe fnot dg oe oe fnot ag state contradictory violates constraint note open programs seen valued abductive framework wfsx lines generalized stable models extension stable model semantics 
minimal change contradictory states correspond situation basic beliefs agent 
situation agent change basic revisable beliefs reach new non contradictory state 
change arbitrary 
agent starts holding intrinsic epistemic preference initial program state intuitively change beliefs minimal way respect 
new program states new states belief close possible initial set beliefs 
issue define notion closeness program states 
notion closeness define minimal revisions program state 
consider revisions single program state thereof obtaining new program states approach section iteration revisions possible agent chooses unique program state set revisions program state starts single state taken preferred 
notion closeness extension valued case winslett difference pair models possible model approach pma 
difference models defined facts pair models disagree 
pma models minimal difference minimal change sense set inclusion preferred 
considering valued setting refined notion difference necessary 
distinctive approach literal undefined prefer revise undefined revising opposite truth value undefined revise true false 
mainly motivated truth knowledge orders literals moving true false vice versa ordering undefined definition difference interpretations set coherent sets literals wrt 
finite language difference interpretations defined diff gamma theta ffg gamma gamma gamma theta ftg literals labeled resp 
change truth value resp 
going literals labeled change original truth value complementary truth value 
sets disjoint 
order iterate revisions consider revisions sets program states 
leave 
truth ordering knowledge example fag fb dg diff detailed motivated theoretically approach previous definition see subsection 
definition closeness relation set interpretations wrt 
finite language say closer iff diff ae diff 
closeness relation defined interpretations program states 
program states considered interpretations model determined program state oe associated beliefs oe 
assume changes agent basic beliefs changes belief just consequences basic belief changes 
belief readily dependent basic 
facing contradiction agent minimally change basic beliefs necessarily extracts beliefs consequences 
close connections belief base revision methods literature see 
definition revision program state oe initial program state open program omega revision oe element sigma set non contradictory program states ffi sigma diff oe ffi diff oe ffi notice revision defined terms single initial program state 
immediate extensions general cases defined 
authors define local global belief revision semantics corresponding respectively notions update revision operators 
local semantics computes revisions initial program state revision initial set set union revisions 
global semantics preferred revisions ones minimal difference respect set initial program states 
details comparisons see 
example consider interpretations corresponding variable part program states oe oe open program fag cg fa cg cg fa dg dg fa dg dg suppose agent believes corresponding program state oe contradictory 
additionally unique beliefs consistent agent current knowledge 
interpretations differences diff diff diff revisions initial program state oe foe oe diff diff diff diff 
example cont 
revisions state oe states resulting oe replacing pv ar ar ar ar fb ar fb words contradiction removed suppose just interested revisions default complement revisions undefined allowed 
need add constraint constraint revisions states resulting replacing ar ar ar ar fb contradiction removed making false 
subsection showing relationship winslett closeness relation 
show valued interpretations definition diff equivalent winslett 
noting arbitrary sets sets gamma gamma disjoint condition diff diff theorem equivalent tb gamma tm tm gamma tb ta gamma tm tm gamma ta fb gamma fm fm gamma fb fa gamma fm fm gamma fa valued interpretations considered tb gamma tm tm gamma tb fb gamma fm fm gamma fb ta gamma tm tm gamma ta fa gamma fm fm gamma fa diff diff iff gamma tm tm gamma tb ta gamma tm tm gamma ta 
corresponds winslett notion closeness interpretations possible worlds 
note initial program state literals false minimality set inclusion obtained 
shows relationship valued contradiction removal methods 
application examples examples application revision techniques 
show time achieve valued declarative debugging benefits mixed valued revisions model diagnosis applications 
declarative debugging example consider logic program founded model fnot dg order perform debugging transform program open straightforward way explicitly assuming rule incorrect predicate covers intended calls 
open literals incorrect unc uncovered literals explicit complements cf 
detailed justification program rendering examples 
fixed part unc unc unc unc unc unc unc unc suppose intended model program fb dg fc dg 
integrity theory expresses information number possible program states open program exactly 
consider initial set beliefs open literals false making initial program state equivalent original program 
associated program state contradictory perform revision regain consistency 
obtain unique revision variable part ar func unc unc tg remaining literals pv ar false 
revision returns bugs initial program 
diagnosis rules missing literals true desired rule keeping undefined lacking newly imposed truth rules incorrect 
existence single revision justified fact intended model completely known 
happens debugging ensures bugs known 
part intended model known specified revisions may exist 
instance truth value literal minimal revisions exist ar func unc unc tg ar func unc unc tg notice revision subset 
intuitively revisions cover possible buggy situations dependent truth value model diagnosis example consider anomalous situation inverter circuit inverter circuit normal abnormal behaviour inverter gate modeled rules 
assume inverter gates type known modes erroneous behaviour output mode stuck mode stuck 
implicit abnormality permanent 
second type gate belong specified model faulty behaviour 
defining fixed program part inv ab node inv ab node inv ab node inv ab node inv ab inv ab fault mode fault mode value node predicted observed node predicted node observed connections components nodes described predicted inv predicted inv predicted inv predicted inv integrity rule ensures fault modes exclusive abnormal gate fault mode assigned simultaneously 
second integrity rule expresses node single value predicted observed time 
fault mode fault mode node node open literals form ab fault mode explicit complements 
initial program state open literals taken false 
suppose measurements nodes obtain respectively 
values nodes described program new facts observed observed 
program contradictory program state predicts node value revised 
just revisions ab ab value undefined possible causes malfunction due gate gate 
additional observation node modeled adding fact observed revisions obtained initial variable program state ab ab undefined till imposed consistency observations revising ab literals sufficient regain consistency 
want revision explain circuit model predict observed wrong output new integrity constraint added open program predicted observed state program contradictory inverters type wrong outputs explained fault models missing general case fault models may incomplete 
enforce condition node replacing predicted observed existing revisions fab fault mode ab ug fab fault mode ab ug fab fault mode ab ug fab fault mode ab ug note revisions containing undefined literals seen approximations valued case 
undefined value order possible incomplete models 
mark impose literals predicted computationally expensive due necessity alternative fault models real applications complex 
mixed valued revision want delve fault model part system explain observations whilst simply requiring consistency part relation don want delve deeper 
decrease computational effort required focused analysis 
recall literals false 
general may exist exponential number revisions inherent complexity type problem solved 
order cope complexity powerful techniques preferences abstractions refinement strategies needed 
additional observations measurements improve diagnoses obtained 
avenues research pursued 
computing revisions devised implemented algorithm compute revisions slx procedure ancestors 
algorithm uses functions insert delete returns order sub formula 
syntax del cx ins cx 
topmost order formula expresses conditions open literals guarantee non contradictory state 
basic conditions tests verity non falsity open literals construct formula 
finding achieved top procedure respects similar slx plus collects relevant conditions open literals simplified 
deletion function defined terms insertion del cx ins cx 
argument ins literal second flag form tu sets ancestors necessary guarantee termination cyclic derivations 
insertion function determines necessary sufficient conditions enforce literal true cx enforce non falsity cx tu 
deletion function turn guarantees non verity literal cx falsity cx tu 
consider example example cont 
take constraint necessary step finding conditions open literals satisfy integrity constraint reformulate deletion insertion functions 
constraint satisfied iff del fg fg del fg fg true 
applying revision algorithm obtain formula note revisions page ones satisfy condition 
describe complete algorithm compute closest revisions 
provide step albeit important revision generation 
full revision system necessary equip method formula minimization get closest revisions 
distance closeness relations section theoretical results justifying closeness relation definition guide revision process 
essential sequel 
define natural metric program states obtained classic fitting orderings valued interpretations 
point problems closeness relation minimal distance said metric provide alternative definition closeness 
characterize properties 
classic fitting orderings valued interpretations generalization sets literals truth knowledge orders literals 
roughly classic ordering says interpretations degree truth preferred fitting ordering amounts prefer minimizing information maximizing degree undefinedness 
explicitly stated assume interpretations respect language formally definition classical fitting orderings interpretations say ffl iff classic truth ordering lack space completely described implementation available request 
ffl iff fitting knowledge ordering partial orders interpretations proceed define distance unit 
intuitively finite partial order nearest elements arbitrary element poset interpretations minimum distance cover covering elements wrt 
partial order 
definition nearest elements finite poset 
set nearest elements denoted fi defined fi def fb oe oe oe oe oe oe classic fitting orderings determine nearest interpretations fi fi interpretation result strongly supports notion nearest elements 
partial orders dual relations set nearest elements theorem finite valued interpretation wrt 
language fi fi flg flg gamma flg gamma flg lg characterization nearest elements define distance interpretations counting minimal number steps necessary go interpretation 
step consists moving element nearest ones 
enforce condition poset finite hasse diagram poset connected 
posets obeying previous condition said connected 
intuitively ensures possible go place poset 
notice poset having bottom top element automatically verifies connectivity condition 
definition distance follows directly characterization nearest elements definition distance finite connected poset 
elements reachable steps defined recursively follows fi fxg fi fi fi distance elements min fi theorem shows notion distance required properties theorem connected poset metric space satisfies properties required distance proof main theorems section appendix 
results characterize distance interpretations classic fitting orderings sort 
note result valid duals orderings nearest worlds partial orders interpretations 
theorem set valued coherent interpretations wrt 
finite language dc df dist dist gamma gamma gamma gamma dist diff 
definition distance program states oe oe program states open program omega distance oe oe denoted oe oe equal dist oe oe 
restrict valued interpretations definition distance tantamount extension dalal 
dalal measures distance worlds models counting number propositions differ truth values 
easily seen dist theta dalal 
results part fact change literal complement truth value costs 
change objective literal opposite truth value coherence imposes change explicit negation complement costs 
general distance function refined dalal extra truth value explicitly negated literals 
distance relation states define notion closeness contradictory state selecting close states minimum distance current 
known literature closeness relation basis state revision preference problems exemplified relative accumulated distances successive state changes 
example consider valued interpretations corresponding variable part program states oe oe open program cg fa cg cg fa cg fa cg cg fa cg cg suppose agent believes initially corresponding program state oe contradictory 
additionally unique beliefs consistent agent current knowledge 
minimal distance agent change beliefs oe dist dist dist 
imagine agent finds oe sustainable say introduced integrity constraint 
change beliefs oe dist dist 
agent changed farther world oe respect initial oe see 
example functions counter argument minimal distance dalal definitions 
change state spurred violation program integrity theory important guarantee order integrity constraints considered immaterial commutative regard obtaining set equally close final revised states diagram contains states edge implicitly expressed integrity constraint vice versa 
successive satisfaction integrity constraints seen path rules added open literals kept way ensure continued satisfaction introduced constraints 
terms agm revision operator means natural property oe oe oe verified 
st move constraint nd move constraint minimum distance counter argument example account problems revised states minimal distance sensitive program change order need notion closeness 
example intuitively oe degree closeness oe oe possible go order ics taken 
suppose start initial state oe add arbitrary integrity constraint 
integrity constraint determines set program states additional constraint enforced subset obtained 
firstly set closest elements contains elements minimal distance oe 
furthermore contain elements guaranteeing change state oe minimal distance initial program state oe exists state minimal distance oe don loose program state irrespective order treatment constraints 
motivates definition definition closeness finite metric space close fa geometric analogy 
find closest element draw line initial element arbitrary element closest element nearer initial program state closest elements initial state closest state farther world closeness relation property ensures want 
roughly says original distances elements preserved set closest elements 
theorem finite metric space closed obviously metric space considered close set program states metric 
proceed equivalently characterize set revisions terms diff extension program states follows immediately 
theorem set interpretations wrt 
finite language close dist diff diff theorems states interpretations closer ones minimal difference sense set inclusion defined 
revisions program state program states beliefs differ minimally minimal diff current ones 
fb sigma oe obtain definition 
point minimum distance approach advantage computationally expensive adopted closeness relation 
fact revision minimum distance approach polynomially bounded contrast exponential complexity minimal diff revision method 
discussion widespread richer representation language extended logic programs applications requires definition correct top querying mechanism prolog wrt 
normal programs 
exploited sldnf derivation procedure slx extended programs wfsx proven soundness completeness 
explicit negation required deal contradiction 
showed removed freely changing truth values subset set predefined revisable literals 
achieve introduced paraconsistent version wfsx wfsx allows contradictions appear slx top querying procedure proven correct 
slx detect existence pairs complementary literals wfsx simply detecting violation integrity rules introduced language program 
integrity constraints general form allowed violation likewise detected slx 
contradiction removal accomplished variant slx collects formula alternative combinations revisable literals truth values ensure said removal 
notion minimal change defined establishes closeness relation program revisions 
changes enforced introducing deleting program rules revisable literals 
illustrate usefulness originality framework applied obtain novel logic programming approach results declarative debugging model diagnosis 
point discussion raised slx applicable infinite ground programs 
programs computational complexity slx greater iterative bottom definition wfsx 
prefer slx 
reasons slx bottom definition wfsx tantamount usually prolog bottom procedures normal programs 
note problem complexity occurs comparing ground case complexity sld resolution tp bottom operator 
specially non ground programs users normally wish know instances literal belong semantics semantics 
slx applied non ground programs provided allowed bounded term 
intend extend slx deal non allowed non ground programs 
straightforward generalization method non ground programs proceed usual expansion goals rule variants keeping test inclusion ancestors lists 
problems shown loop detection method guarantee termination nonground case non allowed term bounded programs second procedure non ground default literals 
guarantee termination non ground term bounded programs intend introduce tabulation methods slx decrease computational complexity procedure 
modification differs significantly existing procedures wfs tabulation 
hand slx applicable programs explicit negation whilst aren hand normal programs slx need status distinct successful failed types proof whilst include status unknown single proof type complicates procedure 
subject introducing slx constructive negation techniques solving floundering problem 
point discussion program transformation normal programs available top procedures wfs applied obtain equivalent semantics wfsx program contradictory detected 
transformation fact resulting program specific form general wfs procedure optimal exploited particular programs double size derivations repeated 
slx procedure takes account wfsx particulars 
case compare approach wfs top procedures case normal programs 
possible generalization introduce program rules disjunctive heads 
semantics approaches disjunction program rules constructed 
adopted approach ongoing research disjunction logic programs stabilizing favour similar 
problem proposals date include explicit negation define 
contradiction removal methods disjunction involved devised semantics 
working satisfactory solution issues 
till premature incorporate fully fledged disjunction 
moment integrity constraints capture intended effect uses disjunction 
intention proceed study efficient implementations slx revision procedures 
subject national project cooperation porto implement procedures machine level deterministic call priority parallelism low level support tabulation 
alferes dam asio pereira 
slx top derivation procedure programs explicit negation 
bruynooghe editor ilps 
mit press 
appear 
alferes dam asio pereira 
top query evaluation founded semantics explicit negation 
cohn editor proc 
ecai pages 
morgan kaufmann 
alferes pereira 
logic program semantics kinds negation 
apt editor int 
joint conf 
symp 
lp pages 
mit press 
alferes pereira 
belief provability logic programs 
pearce pereira editors jelia volume lnai pages 
springer verlag 
alferes pereira 
contradiction avoidance equal removal 
dyckhoff editor th int 
ws 
extensions lp volume lnai 
springer verlag 
jos alferes 
semantics logic programs explicit negation 
phd thesis universidade nova de lisboa october 
apt bol 
logic programming negation survey 
logic programming 
note cumulative wfsx amenable methods 
apt bol klop 
safe termination prolog programs 
levi editors proc 
iclp pages 
mit press 
baral gelfond 
logic programming knowledge representation 
logic programming 
bidoit 
evaluation procedure logic programs 
int 
conf 
database technology pages 
bol 
tabulated resolution founded semantics 
proc 
ilps 
mit press 
chen warren 
goal oriented approach computing founded semantics 
apt editor int joint conf 
logic programming pages 
mit press 
chen warren 
query evaluation founded semantics 
pods 

chou winslett 
model belief revision system 
journal automated reasoning april 
clark 
negation failure 
gallaire minker editors logic data bases pages 
plenum press 
colmerauer 
un syst eme de communication machine en 
technical report groupe de recherche en intelligence artificielle universit aix marseille ii 
dalal 
investigations theory knowledge base revision preliminary report 
th aaai pages 
dam asio nejdl pereira 
revise extended logic programming system revising knowledge bases 
kr 
morgan kaufmann 
denecker de schreye 
sldnfa abductive procedure normal abductive programs 
apt editor int 
joint conf 
symp 
lp pages 
mit press 
dix 
classifying semantics logic programs 
nerode marek subrahmanian editors lp nmr pages 
mit press 
dix 
framework representing characterizing semantics logic programs 
nebel rich swartout editors kr 
morgan kaufmann 
dung 
negation hypotheses abductive framework logic programming 
furukawa editor th int 
conf 
lp pages 
mit press 
eshghi kowalski 
abduction compared negation failure 
th int 
conf 
lp 
mit press 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 
gelfond lifschitz 
stable model semantics logic programming 
kowalski bowen editors th int 
conf 
lp pages 
mit press 
gelfond lifschitz 
compiling circumscriptive theories logic programs 
de kleer ginsberg sandewall editors nd int 
ws nmr pages 
lnai springer verlag 
gelfond lifschitz 
logic programs classical negation 
warren szeredi editors th int 
conf 
lp pages 
mit press 
gelfond lifschitz :10.1.1.24.6050
representing actions extended logic programs 
apt editor int 
joint conf 
symp 
lp pages 
mit press 

british nationality act 
office 
kakas mancarella 
generalized stable models semantics abduction 
proc 
ecai pages 
katsuno mendelzon 
difference updating knowledge base revising 
allen editor nd krr pages 
morgan kaufmann 
kemp stuckey srivastava 
query restricted bottom evaluation normal logic programs 
proc 
jicslp pages 
mit press 
kowalski 
logic problem solving 
noth holland 
kowalski 
treatment negation logic programs representing legislation 
nd int 
conf 
ai law pages 
kowalski 
problems promises computational logic 
john lloyd editor computational logic pages 
basic research series springer verlag 
kowalski 
legislation logic programs 
logic programming action pages 
springer verlag 
kowalski 
linear resolution selection function 
artificial intelligence 
kraus lehmann magidor 
nonmonotonic reasoning preferential models cumulative logics 
artificial intelligence 
kunen 
negation logic programming 
journal lp 
lloyd 
declarative error diagnosis 
new generation computing 
lloyd 
foundations logic programming 
springer verlag 
lloyd topor 
basis deductive database systems 
journal logic programming 
nebel 
syntax approaches belief revision 
gardenfors editor belief revision pages 
cambridge university press 
pearce wagner 
reasoning negative information strong negation logic programs 
editors language knowledge intentionality pages 
acta philosophica 
pereira alferes 
founded semantics logic programs explicit negation 
neumann editor european conf 
ai pages 
john wiley sons 
pereira alferes apar icio 
contradiction removal founded semantics 
nerode marek subrahmanian editors lp nmr pages 
mit press 
pereira apar icio alferes 
derivation procedure extended stable models 
int 
joint conf 
ai 
morgan kaufmann 
pereira apar icio alferes 
non monotonic reasoning logic programming 
journal logic programming 
special issue nonmonotonic reasoning 
pereira dam asio alferes 
debugging diagnosing assumptions 
fritzson editor st int 
ws 
automatic algorithmic debugging number lncs pages 
springer verlag 
pereira dam asio alferes 
diagnosis debugging contradiction removal 
pereira nerode editors nd int 
ws 
lp nmr pages 
mit press 
pereira dam asio alferes 
diagnosis debugging contradiction removal logic programs 
damas editors th portuguese ai conf 
springer verlag 
gardenfors 
knowledge flux modeling dynamics epistemic states 
mit press 
przymusinska przymusinski seki 
soundness completeness partial deductions founded semantics 
voronkov editor proc 
int 
conf 
automated reasoning 
lnai 
przymusinski 
logic program natural stratification iterated fixed point model 
th symp 
principles database systems 
acm sigact sigmod 
przymusinski 
extended stable semantics normal disjunctive programs 
warren szeredi editors th int 
conf 
lp pages 
mit press 
przymusinski 
static semantics normal disjunctive programs 
technical report dep 
computer science univ california riverside 
przymusinski warren 
founded semantics theory implementation 

reiter 
closed world data bases 
gallaire minker editors logic databases pages 
plenum press 
reiter 
logical reconstruction relational database theory 
brodie mylopoulos editors conceptual modelling pages 
springer verlag 
reiter 
asking database knows 
john lloyd editor computational logic pages 
basic research series springer verlag 
ross 
procedural semantics founded negation logic programs 
journal logic programming 

proof procedure extended logic programs 
proc 
ilps 
mit press 
van gelder 
alternating fixpoint logic programs negation 
proc 
symposium principles database systems pages 
acm sigact sigmod 
wagner 
database needs kinds negation 
thalheim hd 
editors mathematical foundations database systems pages 
lncs springer verlag 
wagner 
logic programming strong negation predicates 
logic computation 
wagner 
extended logic programs 
technical report universitat berlin 
wagner 
reasoning inconsistency extended deductive databases 
pereira nerode editors nd int 
ws 
lp nmr pages 
mit press 
winslett 
reasoning action possible model approach 
th aaai pages 
proofs slx correctness assigning ranks derivations 
proofs correctness essentially rely lemmas proven transfinite induction rank derivations 
order trim proof making simplifications definitions derivations definition slx derivation possible way removing selected default literal goal find slx refutation case redundant 
note case removing slx tu refutation definition states slx tu derivation slx refutation explicit complement selected objective literal goal derivation 
slx refutation slx tu derivation single goal failure considering possibility removed goal 
consequently definition case simplified slx tu refutation derived goal gamma ln look cases selected objective literal definition 
clearly corresponds introducing derived goal 
slx refutation derivation failure equivalent case refutation simply removed equivalent second case 
consequently definition remove case selected objective literal keep third modify second input rule bm derived goal gamma bm ln assign ranks simplified derivations 
proofs shall show need assign rank slx failures slx tu refutations 
contribute proving literals belong wfm note exactly corresponds semi normal version program slx tu derivations 
tantamount having need assign rank undetermined nodes 
intuitively rank slx refutation reflects depth calls subsidiary trees considered refutation 
definition seen assigning literal removed goal associated rank 
removing objective literal subsidiary tree considered rank affected 
empty goal rank 
removing default literal depth subsidiary trees considered maximum precisely upper bound infinite case depth slx tu failures depth needed removing literals goal maximum ranks associated literals goal 
definition rank slx refutation rank slx refutation rank goal 
ranks goals refutation defined follows ffl rank 
ffl goal refutation selected literal objective 
rank rank ffl goal refutation selected literal default ff ordinal upper bound maximum finite case ranks slx tu failures rank maximum ff rank ranks slx tu failures reflect depth calls needed fail derivation subsidiary trees 
note failure derivation uniquely determined goal derivation precisely selected literal 
literal objective subsidiary tree needed fail rank 
failing default literal find slx refutation exist consider minimum depth 
case increment rank default literal failed caused extra call 
note slx refutations increment considered 
issue incrementing rank kind derivations tantamount considering increment levels sequence constructing wfm application operators gamma gamma definition rank slx tu failure infinite slx tu failure rank 
rank finite slx tu failure rank goal 
gn goal derivation selected literal ffl objective literal rank 
ffl default literal rank ff ff minimum ranks slx refutations lemma proofs correctness 
lemma relates existence sequences default literals removed gamma operator default literals removed body rules lemma interpretation sequence goals constructed definition resp 
definition selected default literals immediately removed goals 
gamma resp 
gammai iff sequence finite ends empty goal 
proof sketch omit proof gammai definition similar 
gamma definition gamma exist finite set rules ps belongs model 
definition ps semi normal program finite set rules default literal bodies rule head subset formed rules 
note removing default literal slx tu failures considered 
reason maximum 
note slx refutation slx tu derivations failures 
default literals considered definition bodies plus default negations complements heads rules derivation 
completeness sl resolution fact introduced literals shown sequence goals considering rules finite exists ends empty goal 
model contains lemma extended logic program objective literal fi ff sequence constructed wfm theorem 
case 
slx refutation rank 
slx tu derivations failures rank gamma proof transfinite induction limit ordinal ffi case ffi trivial 
ffi point assume slx refutation rank ffi ff ffi refutation exists rank ff 
ff ffi ff ff ffi ff ffi point proof similar omitted brevity 
induction step assume points lemma hold prove point holds proof point similar omitted brevity 
slx refutation rank definition ranks refutations subsidiary derivations default literals refutation failed rank simply removed 
point gamma lemma interpretation gamma removing literals follows gamma gamma proof theorem objective literal result follows immediately lemma monotonicity gamma gamma theorem 
slx refutation rank definition slx refutation slx tu derivations failures rank point lemma gamma fix point gamma gamma gamma gamma monotonic objective literal anti monotonicity gamma gamma gamma gamma gamma definition wfm wfm 
prove theoretical completeness slx 
proving lemma lemma relates sequences gamma operator 
prove completeness objective literals transfinite induction ranks particular class computation rules 
lift restriction prove completeness default literals 
lemma interpretation objective literal 
gamma resp 
gammai possible sequence goals starting constructed definition resp 
definition selected default literals immediately removed goals infinite ends goal selected literal objective ends goal selected literal proof similar proof lemma 
lemma extended logic program objective literal fi ff sequence constructed wfm exists selection rule note definite programs tu derivations reduce sl derivation 

slx refutation rank 
gamma slx tu derivations failures rank proof selection rule begins selecting objective literals default ones subject selects sequence fi ff gamma gamma transfinite induction limit ordinal ffi case ffi trivial 
point ffi proof similar lemma ffi point ffi assume gamma ffi lemma making lemma equal ffi slx tu derivation ffl infinite case failure rank 
ffl ends goal selected literal objective failure rank 
ffl ends goal selected literal ffi case point proven ffi slx refutation rank ff ff ffi definition ranks rank derivation ffi note considering special selection rule sequences mentioned lemma equal derivations ffi selected 
induction step assume points lemma hold 
proving point holds 
assume gamma gamma lemma exists sequence empty goal constructed definition selected default literals gamma immediately removed goals 
point slx failures rank sequence refutation 
rank proves point 
prove point holds 
assume gamma lemma considering lemma equal slx tu derivation ffl infinite case failure rank 
ffl ends goal selected literal objective failure rank 
ffl ends goal selected literal case point proven slx refutation rank 
definition ranks rank derivation 
argument saying sequences lemma derivation similar limit ordinals 
note proof point special selection rule slx derivations arbitrary selection rule 
point usage guarantee rank slx tu failures needed proving lemma induction 
clear slx tu derivations failures possibly greater rank happens arbitrary selection rule need consider special selection rule theorem 
proof theorem objective literal proof follows lemma 
note literals involved infinite recursion negation give rise slx tu failures 
definition wfm exists ordinal fix point gamma gamma definition wfm gamma point lemma slx tu derivations failures 
consequently slx derivation consisting single goal refutation 
proofs distance closeness proof theorem prove case orderings 
cases similar 
oe oe oe words nearest element suppose falsifies condition consider case order satisfy condition equal flg element condition false obtained adding single element true literals 
order ensure interpretation disjoint belong obey coherence proven interpretations flg nearest elements proceed show case classical ordering interpretations 
consider oe oe oe nearest element similarly consider case reasons equal flg disjointness coherence enforced fi fi proof theorem proof induction dist base case dist diff 
induction step suppose dist exist dist fi induction dist gamma gamma gamma gamma 
fi 
flg 
flg 
gamma flg 
gamma flg prove case similar 
flg dist gamma flg flg gamma gammaf gamma 
cases occur leads contradiction gamma flg gammat gamma flg gamma gammat sum equal dist induction dist contradiction 
gamma flg gamma flg gamma gamma dist dist 
set diff contains difference literal changes undefined appears diff labeled changes false true resp 
true false appears labeled resp 

intuition changing literal undefined undefined false true costs unit 
change false true true false costs necessary change literal false undefined undefined true 
distance cardinality diff 
proof theorem induction base case 
close implies metric 
induction step closed result follows trivially 
consider closed induction closed 


proof theorem prove dist dist dist iff diff diff 
proof 
diff diff tm gamma tb tm gamma ta tb gamma tm ta gamma tm fm gamma fb fm gamma fa fb gamma fm fa gamma fm show tm gamma ta tm gamma tb tb gamma ta tm ta tb tb ta tm ta tb ta tb tm ta tb tm gamma ta tb gamma tm ta gamma tm tm tb tm ta tm tb tm tb gamma ta tm gamma ta tm gamma tb tm gamma ta conclude tm gamma tb tb gamma ta tm gamma ta similar proofs conclude tm gamma ta tm gamma tb tb gamma ta ta gamma tm tb gamma tm ta gamma tb fm gamma fa fm gamma fb fb gamma fa fa gamma fm fb gamma fm fa gamma fb equalities fact right hand sides disjoint result follows 

