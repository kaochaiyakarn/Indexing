tutorial algebras induction bart jacobs jan rutten dep 
comp 
sci univ nijmegen cwi box gl nijmegen box gb amsterdam netherlands 
netherlands 
bart cs kun nl cwi nl 
algebraic structures generated collection constructors natural numbers generated zero successor finite lists trees established importance computer science 
formally initial algebras 
induction definition principle proof principle structures 
important dual coalgebraic structures come equipped constructor operations called destructor operations called observers accessors transition maps mutators 
spaces infinite data including example infinite lists non founded sets generally kind 
general dynamical systems hidden black box state space user limited access specified observer mutator operations coalgebras various kinds 
coalgebraic systems common computer science 
coinduction appropriate technique coalgebraic context definition principle proof principle 
involves bisimulations 
aim tutorial provide brief relatively new field coalgebra 
algebra established part mathematics dealing sets operations satisfying certain properties groups rings vector spaces etcetera 
results essential mathematics sciences 
universal algebra part algebra algebraic structures studied high level abstraction general notions homomorphism subalgebra congruence studied see 
step abstraction ladder taken studies algebra notions tools category theory 
approach leads particularly concise notion algebra functor monad see example 
conceptual world enter owes categorical view takes inspiration universal algebra see 
general terms program programming language manipulates data 
development computer science past decades clear description data desirable example ensure program depend particular representation data operates 
abstractness facilitates correctness proofs 
desire led algebraic methods computer science branch called algebraic specification data type theory object study data types notions techniques familiar algebra 
data types computer scientists generated collection constructor operations published eatcs bulletin 
reason initiality algebras plays important role clearly emphasised 
see example information 
standard algebraic techniques proved useful capturing various essential aspects data structures computer science 
turned difficult algebraically describe inherently dynamical structures occuring computing 
structures usually involve notion state transformed various ways 
formal approaches state dynamical systems generally automata transition systems see classical early 
decade insight gradually grew state systems described algebras called coalgebras 
formal duals algebras way precise tutorial 
dual property initiality algebras finality turned crucial coalgebras 
logical reasoning principle needed final coalgebras induction coinduction 
single link state dynamical systems coalgebra explicitly ramifications important insights 
list incomplete justice various contributors area hopefully gives reader impression developments 
notions coalgebra coinduction relatively unfamiliar aim tutorial explain elementary terms 
currently little introductory material available literature assumes form familiarity category theory dual coalgebraic way thinking 
author experiences coalgebras material usually seen difficult takes subtle change view respect traditional algebraic approach able appreciate recognise apply coalgebraic notions techniques 
start emphasise new research material tutorial 
known literature folklore claims originality possibly regarding presentation material 
main concern conveying ideas giving correct representation historical developments ideas 
mainly order provide sources background information 
emphasise assume knowledge category theory part reader 
shall diagrammatic notation typical category theory order express equality composites functions contexts 
simply efficient informative way presenting information 
order fully appreciate underlying duality algebra induction hand coalgebra coinduction elementary notions category theory needed especially notions functor homomorphism categories initial final called terminal object category 
shall explain notions concrete set theoretic setting working definitely encourage interested reader wishes pursue topic tutorial study category theory greater detail 
available texts category theory recommended easy going starting points substantial texts advanced texts 
tutorial starts introductory expositions sections 
technical material subsequent sections organised follows 

starting point ordinary induction definition principle proof principle 
shall assume reader familiar induction natural numbers data types say lists trees general terms 
real step reformulate ordinary induction way initiality see section 
precisely initiality algebras functor 
assume familiar 
explain signatures operations give rise certain functors algebras functors correspond algebras models signatures consisting set equipped certain functions interpreting operations 
description induction terms algebras functors advantage highly uniform sense applies way kinds algebraic data types 
easily giving rise theory coalgebras 

dual notion algebra functor coalgebra functor 
understood model consisting set certain operations direction operations algebra 
dual notion initiality finality finality gives coinduction definition principle reasoning principle 
pattern previous point explained section 
section give alternative formulation coinductive reasoning principle introduced terms finality bisimulations 
relations coalgebras suitably closed coalgebraic operations may understood duals congruences relations closed algebraic operations 
bisimulation arguments prove equality elements final coalgebra require elements bisimulation relation 
arguments concurrency theory 
conclude brief discussion various predicates relations relevance algebra coalgebra 
approximation duality induction coinduction intend describe understood duality greatest fixed points monotone function 
notions generalise greatest fixed points functor suitably described initial algebras final coalgebras 
point view mentioned 

explicit follows going technicalities 
reformulation induction describe induction initiality algebras algebra certain kind initial arbitrary algebra kind unique homomorphism structure preserving mapping algebras initial algebra unique homomorphism arbitrary algebra principle extremely useful 
know certain algebra initial principle define functions acting algebra 
initiality involves unique existence aspects existence 
corresponds ordinary definition induction 
uniqueness 
corresponds proof induction 
uniqueness proofs shows functions acting initial algebra showing homomorphisms algebra 
details reformulation elaborated proceed 
dually coinduction may described coinduction finality coalgebras coalgebra kind final terminal arbitrary coalgebra kind unique homomorphism coalgebras shown arbitrary coalgebra unique homomorphism final coalgebra aspects existence uniqueness corresponding time definition proof coinduction 
initial algebras terminal coalgebras play prominent role theory described canonical way initial algebra obtained closed terms terms generated iteratively applying algebra constructor operations terminal coalgebra obtained pure observations 
probably familiar illustrated examples section 
algebraic coalgebraic phenomena distinction algebra coalgebra pervades computer science recognised people situations usually terms data versus machines 
modern mathematically precise way express difference terms algebras coalgebras 
basic dichotomy may described construction versus observation 
may process theory data type theory including theory classes objects objectoriented programming semantics programming languages denotational versus operational lambda calculi automata theory system theory natural language theory fields 
assume reader familiar definitions proofs ordinary induction 
typical example consider fixed data set set list finite sequences lists elements inductively define length function len clauses len hi len delta oe len oe oe notation hi empty list called nil delta oe written cons oe list obtained oe prefixing shall see definition length function len seen instance initiality diagram 
typical induction proof predicate holds lists requires prove induction assumptions hi oe delta oe oe example way prove len oe delta len oe foe len oe delta len oe 
essentially induction proof method says proper subalgebras 
algebraic setting essential fact finite lists elements constructed operations nil cons theta write hi nil delta oe cons oe 
describe typically coalgebraic phenomena sketching relevant examples 
issues come description examples explained detail sections 
consider black box machine process external button light 
machine performs certain action button pressed 
light goes machine stops operating reached final state case pressing button effect 
client outside machine directly observe internal state machine observe behaviour button light 
simple paradigmatic situation observed directly particular state machine light 
user may iterate experiment record observations change state caused pressing button situation user observe times press button light go 
may zero times light times infinitely times machine keeps operating light goes 
mathematically describe machine terms set understand unknown state space machine function button fg new symbol occurring particular state applying function button corresponds pressing button possible outcomes button meaning machine stops operating light goes button case machine moved state result button pressed 
assumed actions pressing button happen instantaneously order occurrence actions 
state button pressed pair button fg example coalgebra 
observable behaviour resulting iterated observations described yields element set describing number times button pressed light go 
describe behaviour function beh shall see obtained instance finality diagram 
ii consider slightly different machine buttons value 
pressing value button results visible indication attribute internal state display values dataset affecting internal state 
pressing value twice consecutively yields result 
pressing button machine moves state value inspected 
abstractly new machine described coalgebra theta state space behaviour observe machines read value pressing button times 
results infinite sequence elements dataset element describing value pressing times 
observing behaviour state gives function beh described instance 
iii previous example leading direction coalgebraic description classes object oriented languages 
suppose wish capture essential aspects class points real plane moved client 
situation certainly want attribute buttons second tell pushed second coordinate point belonging class 
plays role hidden state space elements seen objects class object identified state 
want button method object oriented terminology move theta theta requires parameters corresponding change second coordinate 
move operation allows change state certain way depending values parameters 
move method equivalently described function move thetar state single argument yielding function theta parameters states 
client class interested actual details implementation state space exactly looks long behaviour determined equations move second move second describe second coordinates move terms original coordinates parameters move 
equations seen constraints observable behaviour 
important aspect object oriented approach classes built hidden state space observed modified certain specified operations 
user interested details actual implementation behaviour realised 
black box description classes unknown state space appropriate 
buttons class machine combined single function second theta theta thetar forms coalgebra state space observable behaviour simple case 
consists values second coordinates know values know observable behaviour change state bring move button observable effect determined equations 
observe state obtained direct observation repeated observations produce new information 
behaviour function takes form beh theta instance 
automata theoretic terms call space theta minimal realisation implementation specified behaviour 
iv return second example buttons value theta example may understood deterministic transition system write states observable value gamma 
value read gamma 
state observe move trace tr observations state transition system tr gamma 
gamma 
delta delta delta sequence observable behaviour beh state identified ii 
successor states completely determined deterministic machine allow state 
consider general necessarily deterministic transition system gamma gamma 
subset theta theta equivalently described coalgebra form powerset function ff theta equivalence ff gamma 
deterministic transition system mentioned previous point special case successor set ff singleton 
general transition system ff may understood transition function nondeterministic automaton set input alphabet 
labels transition system seen observable 
appropriate domain observations 
difficult question 
shall give complete answer mention difficulties sketch solutions give details 
consider variation kind transition systems maps form ff theta list theta case move state ordered sequence ff theta labels states say form ff continue process 
resulting space observations consists possibly infinite labeled trees node finitely ordered branches 
shall return coalgebras example 
step consider transition systems form ff theta finitely non deterministic sense set finitely pairs gamma 
longer ordered 
think space observations simply set possibly infinite labeled trees finitely branches situation subtle 
problem state may transitions gamma 
gamma 
label clear lead observations identified 
previous situation theta theta question occur transitions different components ordered sequence 
appropriate space observations transition systems form theta constructed quotienting space observations transition systems 
theta respect bisimulation see categorical details explanations 
bisimulation respect functor described example 
left general situation arbitrary necessarily finitely non deterministic transition systems theta 
shall see spaces observations describing final coalgebras 
shown general coalgebras isomorphisms theta 
easy cardinality argument shows isomorphism exist non empty sets 
space observations world ordinary sets 
world non founded sets classes space exist plays important role giving meaning various process operators see 
vi variation second example may consider machine buttons value theta autonomous activity time 
mean machine may perform actions change state time progresses pressing button 
stage machine state time interval length ff fx buttons pressed machine possibly different state depending ff 
action time states combination coalgebraic operations value acting states may descriptions hybrid systems combining discrete continuous behaviour 
possible observations situation form pushing button times intervals length ff ff see certain value interval length fi 
yields space observations thetar associated behaviour function beh forms suitable homomorphism 
vii example pattern finality diagram involves definition bohm trees untyped lambda terms see 
briefly bohm tree bt term obtained follows 
find head normal form 
bt consists single unlabeled node 
normal form say form ym delta delta delta mn put bt bt delta delta delta bt mn tree seen arising observations term observed term abstraction variables head variable 
operation bt gamma bohm trees seen function set lambda terms modulo fi equivalence appropriate space observations consisting possibly infinite trees labeled sequences variables finitely branches 
viii examples interesting coalgebras obtained supplying underlying set states additional structure 
instance dimensional discrete time dynamical systems consist complete metric space distance function dx continuous function describes dynamical behaviour system 
systems occur instance population biology physics 
main themes theory dynamical systems systematic study orbits orbit set fx 
coalgebraic terms orbit just smallest subsystem contains questions addressed instance point periodic periodic points distributed form dense subset orbits canonical way describe functional dependence ff called monoid action theta satisfying ff fi ff fi see 
personal communication author henk barendregt said time writing definition bohm trees felt slightly uncomfortable nature definition 
saw possibly infinite process defined finite stage 
emphasised see loc 
cit 
ii certainly inductive definition 
coinductive definition 
similar know close dx small 
turns important technique world dynamical systems answer questions called symbolic dynamics cf 
described elegantly theory coalgebras techniques metric domain theory 
interested reader referred details outside scope tutorial 
series examples coalgebras see time state space assumptions 
state space function defined consisting different components allow observe aspect state space directly move states 
limited access state space sense observe modify specified operations 
situation describe particular state behaviour arises making successive observations 
lead notion bisimilarity states expresses states distinguish operations disposal equal far see 
mean states identical elements bisimilarity important typically coalgebraic concept 
examples meant suggest difference construction algebra observation coalgebra 
difference described formally 
practice straightforward distinguish algebraic coalgebraic aspects reasons 

certain operations theta seen algebraic coalgebraic 
algebraically operation allows build new elements starting elements parameters operation equivalent function types 
seen acting state space yielding state function produces parameter element state 
context clear view prevalent 
operations form definitely algebraic gives information put elements operations form coalgebraic give observable attribute values holding elements 
complication point initial algebra may operations form obtained initiality 
example length function lists 
operations derived integral part definition algebra 
dually may derived operations final coalgebra 
algebraic coalgebraic structures may different hierarchic layers 
example start certain algebras describing application domain 
top certain dynamical systems processes coalgebras involving algebras codomains attributes 
coalgebraic systems may exist algebra processes 
concrete example layering coalgebra top algebra plotkin called structural operational semantics 
involves transition system coalgebra describing operational semantics language giving transition rules induction structure terms language 
means set terms language initial algebra 
see investigation perspective 
hidden sorted algebras see seen examples involve algebras invisible sorts playing coalgebraic role state space 
coinduction reason hidden state spaces see 
inductive coinductive definitions previous section seen constructor destructor observer operations play important role algebras coalgebras respectively 
constructors tell generate algebraic data elements empty list constructor nil prefix operation cons generate finite lists 
destructors observers transition functions tell observe data elements head tail operations tell infinite lists head gives direct observation tail returns state 
aware duality constructing observing easy see difference inductive coinductive definitions relative collections constructors destructors inductive definition function defines value constructors 
coinductive definition function defines values destructors outcome 
coinductive definition determines observable behaviour 
shall illustrate inductive coinductive definitions examples involving finite lists constructors nil cons infinite lists destructors head tail fixed dataset previous section 
assume inductive definitions known mention trivial examples earlier mentioned function len finite lists natural numbers giving length function empty 
finite lists booleans ftrue falseg telling list empty ae len nil len cons oe len oe ae empty nil true empty cons oe false typically inductive definitions constructors left hand side appear inside function defining 
turn examples coinductive definitions infinite lists say type 
function define extension ext mapping infinite list infinite list applying componentwise 
coinductive definition scheme give values destructors head tail sequence ext oe 
ae head ext oe head oe tail ext oe ext tail oe clearly see left hand side function defining occurs inside destructors 
stage clear ext defined concern moment 
alternatively transition relation notation example iv previous section write definition ext oe gamma 
oe ext oe gamma 
ext oe suppose wish define operation odd takes infinite list produces new infinite list contains order elements occurring oddly numbered places original list 
little thought leads definition clauses 
ae head odd oe head oe tail odd oe odd tail tail oe transition relation notation oe gamma 
oe gamma 
oe odd oe gamma 
odd oe convince definition gives want 
clause says element list odd oe element oe 
element odd oe head tail odd oe computed head tail odd oe head odd tail tail oe head tail tail oe second element odd oe third element oe 
hard show head tail odd oe head tail oe 
similar way coinductively define function keeps evenly listed elements 
easier define odd ffi tail 
example consider merge infinite lists oe single list elements oe turn starting oe say 
coinductive definition function merge requires outcomes destructors head tail merge oe 
ae head merge oe head oe tail merge oe merge tail oe transition system notation definition looks follows 
oe gamma 
oe merge oe gamma 
merge oe show th element oe occurs th element merge oe th element occurs th element merge oe head tail oe head tail oe head tail oe head tail define function merge oe takes elements oe element leave function exercise interested reader obvious result prove merging lists oddly evenly occuring elements list oe returns original list oe 
merge odd oe oe oe 
seen easily compute th elements sides equal head tail merge odd oe oe head tail odd oe head tail oe head tail oe head tail oe head tail oe elegant coinductive proof technique example uniqueness finality diagram section bisimulations 
functoriality products coproducts powersets remainder shall put things discussed far general framework 
doing properly requires certain amount category theory 
intend describe relevant matters highest level abstraction making full category theory 
shall mainly ordinary sets 
shall universe category sets functions 
need operations sets functorial 
reading want hint give coinductive definition function merge oe ae merges infinite lists round robin way 
means act sets functions sets appropriate manner 
familiar computer science literature categorical terminology map terminology 
example list describes set finite lists elements set function define function list list corresponding sets lists usually called map list 
sends finite list elements list elements applying elementwise 
hard show map list operation preserves identity functions composite functions map list id id list map list ffi map list ffi map list 
preservation identities compositions appropriateness mentioned 
section concentrate functoriality basic operations products coproducts disjoint unions powersets 
sections 
recall sets cartesian product theta set pairs theta obvious projection functions theta theta functions unique pair function hf gi theta ffi hf gi ffi hf gi hf gi theta notice id theta theta hf gi ffi hf ffi ffi hi theta functions interestingly product operation 
theta apply sets functions functions define function theta theta 

writes function theta theta theta symbol theta overloaded sets functions 
note theta described terms projections pairing theta hf ffi ffi easily verified operation theta functions satisfies id theta id id thetay ffi theta ffi theta ffi theta expresses product theta functorial apply sets functions way identity maps composites preserved 
operations functorial 
coproduct disjoint union sum sets write disjoint union explicitly fh xi xg fh yi components serve force union disjoint 
tags enables recognise elements inside projections going direction 
puts xi yi 
called source functions unique function ffi ffi defines case distinction ae xi yi notice id ffi ffi ffi 
coproduct sets 
extend functions way 
function ae xi yi category theory literature uses name actions functor objects morphisms leads notation list function map list 
equivalently defined ffi ffi 
operation functions preserves identities composition id id id ffi ffi ffi emphasise coproduct different ordinary union 
example idempotent isomorphism 
fixed set assignment 
ff function xg functorial function yields function sending ffi clearly id id ffi ffi example functorial operation powerset 

function defines 
ff ug idx id ffi ffi 
shall write fin gamma functorial operation maps set finite subsets 
trivial examples functors 
identity operation 
functorial acts functions 
constant set constant functorial operation 
function mapped identity function id know actions functions define functorial operations functors short merely giving actions sets 
say things consider functor theta action sets 
theta 
function action functor function 
explicitly function id theta theta gamma 
theta 
ae xi sequel shall polynomial functors built constants identity functors products coproducts finite powersets 
describe functors giving actions sets 
general notion functor mapping category 
interested polynomial functors going category sets functions 
theory applies general situations 
shall write fg singleton set typical inhabitant notice set precisely function 
says final terminal category sets functions 
functions correspond elements usually shall identify 
write empty set 
set precisely function empty function 
property initiality 
sets seen empty product coproduct 
list useful isomorphisms 
theta theta theta theta theta theta theta theta theta theta theta isomorphisms describe distribution products finite coproducts 
shall isomorphisms simply write ary product theta delta delta delta theta xn bothering bracketing 
algebras induction section start showing polynomial functors introduced previous section describe signatures operations 
algebras functors correspond models signatures 
consist carrier set certain functions interpreting operations 
general notion homomorphism defined algebras functor 
allows define initial algebras property arbitrary algebra precisely homomorphism initial algebra algebra 
turns powerful notion 
captures algebraic structures generated constructor operations shown examples 
gives rise familiar principles definition induction proof induction 
start example 
polynomial functor theta consider set function map may identified maps theta giving separate functions going set form example algebra functor set number functions going set 
example group unit element inverse function multiplication function theta organise maps algebra shape functor determines certain signature operations 
taken different functor theta maps algebras capture pairs functions theta monoid 
definition functor 
algebra algebra pair consisting set function shall call set carrier algebra function algebra structure operation algebra 
example zero successor functions natural numbers form algebra functor set labeled finite binary trees tree comes functions nil tree empty tree node tree theta theta tree tree constructing tree sub trees node label 
nil node form algebra tree theta theta tree tree functor theta theta 
illustrate link signatures operations functors details 
sigma single sorted single typed signature finite collection sigma operations oe arity ar oe oe sigma understood operation oe theta delta delta delta theta ar oe times gamma 
ar oe inputs type producing output type signature sigma say set operations foe oe ng associate functor sigma ar oe delta delta delta ar oe set fold product theta delta delta delta theta algebra sigma functor sigma identified ar oe delta delta delta ar oe functions ar oe interpreting operations oe sigma functions algebras functor sigma correspond models signature sigma 
sees arities signature sigma determine shape associated functor sigma notice special case arity operation zero constant sigma 
sigma algebra sigma get associated map giving element carrier set interpretation constant 
assumption signature sigma finite essential correspondence models group operations equations captured map sigma algebras sigma sigma infinite define sigma infinite coproduct commonly written sigma oe sigma ar oe polynomial functors built identity functor products coproducts constants algebras models kind signatures sigma described 
distribution products coproducts write functor disjunctive normal form delta delta delta mn certain natural numbers mn essential role coproducts combine multiple operations single operation 
polynomial functors form delta delta delta mn may involve constant sets 
quite useful example describe arbitrary set signature lists function symbols nil empty list cons theta prefixing element type list 
model interpretation signature algebra functor theta associated signature 
turn homomorphisms algebras understood structure preserving functions algebras signature functor 
homomorphism function carrier sets algebras commutes operations 
example suppose algebras theta theta list signature 
homomorphism algebras second consists function carriers ffi ffi ffi id theta 
diagrams fflffl fflffl theta id theta fflffl theta fflffl writing diagrams express diagrams combined single diagram theta id id theta fflffl theta fflffl list functor theta fflffl fflffl formulation entirely terms functor involved 
motivates definition 
definition functor algebras homomorphism algebras called map algebras algebra map function carrier sets commutes operations ffi ffi fflffl fflffl triviality notice algebra identity function algebra map 

compose algebra maps functions algebra maps gamma 
gamma 
gamma 
composite function ffi algebra map 
ffi ffi ffi ffi ffi ffi ffi ffi see diagram 
fflffl ffi fflffl ffi algebras homomorphisms form category 
notion homomorphism algebras formulate important concept initiality algebras 
definition algebra functor initial algebra unique homomorphism algebras 
diagrammatically express uniqueness dashed arrow call fflffl fflffl shall call unique mediating algebra map 
emphasise unique existence aspects existence algebra map initial algebra algebra uniqueness form equality algebra maps going initial algebra algebra 
existence inductive definition principle uniqueness inductive proof principle 
example shall describe set natural numbers initial algebra 
example consider set natural number zero successor function functions combine single function forming algebra functor show map initial algebra functor 
characterises set natural numbers isomorphism lemma ii 
prove initiality assume arbitrary set carrying algebra structure define mediating homomorphism try iteration simply write 
equations express commuting diagram fflffl id fflffl making homomorphism algebras 
verified easily distinguishing arbitrary element upper left corner cases case get id second case similarly check id may conclude id ffi ffi id 
looks promising show map making diagram commute 

satisfies ffi ffi id line reasoning followed 
induction 
shall give simple example showing initiality inductive definitions 
suppose wish define induction function gamman natural numbers rational numbers defining equations order define function initiality put algebra structure set rational numbers see definition 
algebra corresponds right hand side defining equations functions gamma singleton set fg number combine single function gamma forming algebra function gamman determined initiality unique function making diagram commute 
fflffl id gamma shows initiality define functions induction 
requires puts appropriate algebra structure codomain range intended function corresponding induction clauses determine function 
emphasise functor parameter definitions homomorphism initiality algebras yielding uniform notions functors representing certain signatures 
turns initial algebras certain properties shown functors 
diagrams convenient expressing proving properties display information succinct way 
useful existence uniqueness arguments 
lemma functor 
initial algebras exist unique isomorphism algebras 
initial algebras unique isomorphism algebras fflffl fflffl ii operation initial algebras isomorphism initial algebra inverse gamma 
point tells functor essentially initial algebra speak initial algebra functor second point due lambek says initial algebra fixed point functor initial algebras may seen generalizations fixed points monotone functions unique map arbitrary algebra 
proof suppose initial algebras functor initiality unique algebra map similarly initiality unique algebra map direction fflffl fflffl fflffl existence parts initiality 
uniqueness part gives resulting algebra maps 
ffi id fflffl fflffl fflffl fflffl id fflffl id equal ffi id uniqueness algebra maps 
similarly yields ffi id isomorphism algebras 
ii initial algebra 
order show function isomorphism produce inverse function 
initiality define functions arbitrary algebras 
seek function put algebra structure set 
moment thought yields candidate result general property initial objects category 
applying functor function function gives initiality rise function ffi ffi fflffl function ffi algebra map 
fflffl fflffl fflffl ffi id uniqueness algebra maps 

ffi ffi definition ffi preserves composition id just seen id preserves identities 
isomorphism inverse 
shall write initial algebra map making isomorphism explicit 
example fixed set consider functor theta earlier capture models list signature theta claim initial algebra set list finite sequences elements function element empty list nil function theta maps element list ff list cons ff obtained prefixing ff 
functions combine single function nil cons theta easily checks isomorphism 
mean initial algebra 
check explicitly 
arbitrary algebra theta list functor unique homomorphism algebras theta nil cons fflffl id id theta theta fflffl ff ae ff nil fi ff cons fi leave reader verify unique function making diagram commute 
initiality define functions induction lists 
example take length function len described section 
order define initiality arise list algebra structure theta natural numbers algebra structure functions ffi theta len determined unique function initiality diagram 
theta nil cons fflffl id id theta len theta ffi fflffl len algebra structure corresponds defining clauses len nil len cons ff len ff len ff id theta len ff 
proceed example showing proof induction involves uniqueness map initial algebra 
consider doubling function replaces element list ff consecutive occurrences ff 
function defined unique making diagram commute 
theta nil cons fflffl id id theta theta nil ff cons cons ff fflffl defined induction clauses nil nil cons ff cons cons ff 
wish show length list ff twice length ff len ff delta len ff ordinary induction proof consists steps len nil len nil delta delta len nil len cons ff len cons cons ff len ff ih delta len ff delta len ff delta len cons ff initiality induction proof fact len ffi delta gamma ffi len uses uniqueness manner 
len ffi delta gamma ffi len homomorphism initial algebra nil cons algebra ffi ffi equal initiality 
check len ffi appropriate homomorphism inspection diagram 
theta nil cons fflffl id id theta theta nil ff cons cons ff fflffl id id theta len theta ffi ffi fflffl len rectangle left commutes definition commutation rectangle right follows easily definition len 
check delta gamma homomorphism algebras theta nil cons fflffl id id theta len theta id fflffl id id theta delta gamma theta id fflffl ed bc ffi ffi oo fflffl id delta gamma ffi fflffl len delta gamma square left commutes definition len 
commutation upper square right follows easy computation 
lower square right may seen defining function delta gamma clauses delta delta delta took granted earlier ordinary proof 
conclude brief discussion algebras induction remarks 

number constructors form carrier set associated initial algebra set closed terms ground terms containing variables formed constructors 
example zero successor constructors give rise set closed terms isomorphic set natural numbers 
similarly set closed terms arising list constructors nil cons theta set finite sequences elements 
pleasant know initial algebra looks initiality need knowledge 
need know exists initial algebra 
defining property sufficient 
results guaranteeing existence initial algebras certain continuous functors see initial algebras constructed suitable colimits generalizing construction fixed points continuous functions 

initiality format induction important advantage generalises smoothly natural numbers algebraic data types lists trees 
know signature containing constructor operations data types know associated functor determine initial algebra 
uniformity provided initiality stressed adt group forms basis inductively defined types programming languages 
example functional language ml user introduce new inductive type notation datatype oe delta delta delta oe idea carrier initial algebra associated constructors oe oe functor oe delta delta delta oe 
oe existing types may contain positively uniformity provided initial algebra format dually final coalgebra format useful definition scheme ml contains various aspects investigated allows ff contain type variables ff mutual dependencies definitions iteration inductive definitions example list operation obtained scheme oe wishes automatically generate various rules associated inductively defined types example programming languages charity proof tools pvs hol isabelle coq 
great advantage initial algebra format dual final coalgebra format shall see section 
forms basis duality induction coinduction 

indicated example uniqueness maps initial algebra corresponds proof opposed definition induction 
substantiate claim show usual predicate formulation induction lists derived initial algebra formulation 
predicate formulation says predicate subset equal case nil ff cons ff 
consider set right explicit inclusion function 
induction assumptions essentially say carries algebra structure nil cons theta way inclusion map map algebras theta nil cons fflffl id id theta theta nil cons fflffl words subalgebra initiality get function left 
ffi id uniqueness 
theta nil cons fflffl id id theta id id theta id theta nil cons fflffl id id theta theta nil cons fflffl id means wished derive 

initiality property definition allows define functions initial algebra carrier wishes define functions theta involving additional parameter ranging set typical example addition function plus theta 
defined induction say argument second argument parameter 
handle functions theta currying correspond functions defined initiality scheme 
example define addition function plus 
initiality putting appropriate algebra structure see example fflffl plus fflffl plus says plus plus plus alternatively may formulate initiality parameters see handle functions theta directly 
coalgebras coinduction section seen product behaves product theta arrows point opposite direction projections theta 
says coproduct dual product theta associated arrows reversed 
similarly algebra dual algebra 
definition functor coalgebra coalgebra pair consisting set function 
algebras call set carrier function structure operation coalgebra 
coalgebras describe dynamical systems sort carrier set called state space 
difference algebra coalgebra 
essentially difference construction observation 
algebra consists carrier set function going carrier tells construct elements coalgebra consists carrier set function opposite direction going case know form elements operations acting may give information general coalgebraic operations tell say elements limited access coalgebras algebras seen models signature operations constructor operations destructor observer operations 
consider example functor theta fixed set 
coalgebra consists functions earlier called value operations things element 
produce element value 
produce element 
repeat 

form element value 
proceeding way get element infinite sequence elements value sequence elements gives rise observe elements may give rise sequence elements equal elements case calls observationally indistinguishable bisimilar 
example 
functor theta coalgebra pn theta pn stands possible 
element see 

pn theta left component 
happens experiment stops state element left continue 

pn theta right component 
gives element element carrier proceed 
repeating observe element finite sequence infinite sequence observable outcomes elements set finite infinite lists 
observations turn elements final coalgebra functors involved see example 
order formulate notion finality coalgebras need know homomorphism coalgebras algebra function underlying sets commutes operations 
example theta infinite list functor coalgebras hh theta hh theta homomorphism coalgebras second consists function carrier sets state spaces ffi ffi ffi fflffl fflffl fflffl fflffl diagrams combined single hh fflffl hh fflffl theta id theta theta hh fflffl hh fflffl definition functor 
homomorphism coalgebras map coalgebras coalgebra map coalgebra gamma 
coalgebra gamma 
consists function carrier sets commutes operations ffi ffi expressed diagram 
fflffl fflffl ii final coalgebra coalgebra coalgebra unique map coalgebras 

notice initiality property algebras allows define functions going initial algebra finality property coalgebras gives means define functions final coalgebra 
earlier emphasised typical coalgebraic setting operations constructing elements state space coalgebra state spaces seen black boxes 
know certain coalgebra final form elements state space finality principle 
example contains illustrations 
means constructing elements finality allows define various operations final coalgebras shown series examples 
fact way put certain algebraic structure top coalgebra see systematic study context process algebras 
seen definitions initiality algebras see definition finality coalgebras position see formal similarities 
informal level explain similarities follows 
typical initiality diagram may drawn initial algebra fflffl base step plus step fflffl forth map forth defined diagram applies step operations repeatedly base step 
pattern finality diagram similar observe plus step fflffl forth final coalgebra fflffl case forth map captures observations arise repeatedly applying step operation 
captures observable behaviour 
technique defining function finality describe direct observations single steps coalgebra structure function arises repetition 
coinductive definition determine step step 
section shall describe proof techniques bisimulations fully exploit step step character coinductive definitions 
identify simply coalgebra concretely show finality 
example fixed set consider functor theta claim final coalgebra functor set infinite lists elements coalgebra structure theta head ff ff tail ff ff head takes element infinite sequence ff ff ff elements tail takes remaining list 
notice pair functions theta isomorphism 
claim arbitrary coalgebra theta unique homomorphism coalgebras value head ffi value tail ffi ffi making map coalgebras 
unique satisfying equations checked easily 
earlier section saw observe element infinite list elements arising value value value see observable behaviour precisely outcome unique map final coalgebra 
elements final coalgebra give observable behaviour 
typical final coalgebras 
know final coalgebra precisely carries final coalgebra structure finality define functions start simple example involves defining constant sequence const coinduction element 
shall define constant function const fg singleton set 
explanation produce coalgebra structure theta way const arises repetition 
case thing want observe element simply define coalgebra structure theta function 

const arises finality diagram 

fflffl const fflffl theta id theta const theta expresses head const tail const const 
consider example special case wish define coinductively function maps natural number sequence involves defining coalgebra structure theta domain function trying define 
direct observation state state directly observe 
repetition leads 
define function diagram 
fflffl fflffl theta id theta theta determined equations head tail 
position provide formal background examples coinductive definitions proofs section 
instance function merge theta merges infinite lists single arises unique function final coalgebra theta merge ff fi head ff fi tail ff fflffl fflffl theta theta id theta merge theta notice coalgebra structure left put domain theta merge corresponds defining coinduction clauses merge section 
expresses direct observation merge state direct observation 
follows commutativity diagram head merge ff fi head ff tail merge ff fi merge fi tail ff function odd similarly defined coinductively finality follows odd ff head ff tail tail ff fflffl fflffl theta id theta odd theta coalgebra structure left gives finality rise unique coalgebra homomorphism called odd 
diagram satisfies head odd ff head ff tail odd ff odd tail tail ff define ff odd tail ff prove ff merge odd ff ff ff showing merge ffi homomorphism coalgebras 
required equality follows uniqueness identity function id trivially homomorphism 

prove homomorphism ffi merge ffi id theta merge ffi ffi follows computations 
head merge odd ff ff head odd ff head ff tail merge odd ff ff merge ff tail odd ff merge ff odd tail tail ff merge odd tail ff tail ff merge ffi tail ff section alternative method proving facts introduced notion bisimulation 
clearly formal similarities algebra maps coalgebra maps 
leave reader check coalgebra maps composed functions identity function carrier coalgebra map coalgebras 
result dual including proof lemma 
lemma final coalgebras exist uniquely determined isomorphism 
ii final coalgebra fixed point functor final coalgebras generalizations greatest fixed points monotone functions 
initial algebras existence final coalgebras important actual internal structure 
determined entirely finality property structure 
existence final coalgebra follows general properties relevant functor underlying category see 
unique existence map coalgebras final coalgebra aspects existence gives principle definition coinduction uniqueness gives principle proof coinduction 
illustrated series examples occupy remainder section 
example hard show final coalgebra functor theta carrier set finite infinite lists 
associated possible coalgebra structure pn theta ff 
ae ff ff ff delta ff final arbitrary coalgebra theta functor unique homomorphism coalgebras earlier section identified lists observable behaviour machines signature operations described give examples coinductive definitions finite infinite lists 
easy describing empty list nil unique coalgebra homomorphisms situation 
nil fflffl pn fflffl theta id id theta nil theta determines nil pn gamma ffi define prefix operation cons theta pn gamma ffi coinductively define list inclusion function list incl coalgebra structure list incl struct theta ff 
ae ff nil fi ff cons fi leave reader coinductively define infinite list inclusion serious example involves concatenation function conc theta yields lists new list cons contains elements followed elements coinductively defines conc laying possible observations new list conc 
concretely means define pn conc intuition concatenation tells possible pn conc possible pn empty list pn possible pn 
captured coalgebra structure conc struct theta theta theta ff fi 
pn ff pn fi ff fi pn ff ff ff fi pn ff pn fi fi concatenation function conc theta wished define arises unique coalgebra map resulting conc struct 
interested reader may wish prove uniqueness 
conc nil conc nil conc conc conc conc may wish prove conc cons cons conc 
easiest way show applying pn sides yields result 
done pn isomorphism 
example consider functor example 
remember initial algebra set natural numbers zero successor functions algebra structure gamma 
final coalgebra gamma 
set natural numbers augmented extra element 
final coalgebra structure 
best called predecessor pred sends 


written explicitly order emphasise component pred belongs 
final coalgebra may obtained constant set singleton set functor 
theta previous example 
set isomorphic possible operations pn theta predecessor 
defining property final coalgebra pred 
says set function unique function diagram 
fflffl pred fflffl id says unique function satisfying pred ae function gives behaviour observe systems button mentioned coalgebra example section 
consider function theta theta defined pred pred hx yi pred hx pred pred puts coalgebra structure theta functor 
considering 
gives rise unique coalgebra homomorphism phi theta situation 
theta fflffl phi pred theta id phi phi unique function theta 
pred phi pred pred phi pred pred phi pred hard see phim phi phi behaves addition extended natural numbers easily verifies addition function phi theta special case concatenation function conc theta introduced previous example 
special case distinguishes important aspect shown concatenation addition phi theta extended natural numbers commutative uniqueness bisimulation see details concatenation conc theta general commutative 
elements conc conc give rise different observations singleton sequence containing different elements 
example consider functor list theta constant set function yields function list theta list theta sending xn xn coalgebra list theta functor function maps state finite list pairs consisting label successor state passage states repeated coalgebra describes tree possibly infinite depth finitely ordered branches provided label example tree infinite set labels 

delta delta described coalgebra 
list theta state space hi nil gamma aim example define arbitrary coalgebra list theta classical traversal algorithms bf gamma df gamma breadth depth yielding functions bf df describe elements occurring tree element possibly infinite list breadth depth order 
functions bf df defined finality carrier final coalgebra functor 
theta see example 
done steps put coalgebra structures bfs list theta theta list theta dfs list theta theta list theta list theta 
finality give rise coalgebra homomorphisms bfh list theta dfh list theta define bf bfh ffi gamma 
df dfh ffi gamma 
thing define coalgebra structures bfs dfs list theta functions list theta theta list theta 
take bfs gamma 
ae nil delta cons dfs gamma 
ae nil delta cons delta concatenation list theta 
illustrate resulting functions bf df example 
consider tree gamma gamma delta delta delta delta oeoe gamma gamma delta delta delta delta oeoe state space coalgebra structure list theta hi compute resulting breadth depth traversals tree bf bfh bfh delta bfh delta delta bfh delta delta delta delta delta df dfh delta dfh delta delta delta dfh delta delta delta delta dfh delta delta delta delta delta calculations rely maps bfh dfh homomorphisms coalgebras functor 
theta 
defining algorithms initiality finality yields certain canonical equations reasoning correctness proofs 
developed programming methodology bird meertens see information involving initiality 
context finality 
actual programming purely basis initiality finality done language charity see mentioned 
proofs coinduction bisimulation section shall give alternative formulation earlier proofs coinduction 
new proof directly exploit uniqueness aspect finality notion bisimulation 
new examples formulate general case allowing proof equalities final coalgebras bisimulations 
recall example final coalgebra functor theta set infinite lists elements coalgebra structure 
bisimulation carrier relation satisfying ff fi ae head ff head fi tail ff tail fi satisfies coinductive proof principle cpp short ff fi ff fi bisimulation ff fi 
cpp give proof principle finality illustrate proving ff merge odd ff ff ff define relation merge odd ff ff ff ff order prove equality coinductive proof principle cpp sufficient show bisimulation 
follows proving requirements mentioned 
pair merge odd ff ff ff equal head head merge odd ff ff head odd ff head ff secondly pair merge odd ff ff ff applying tail sides yields new pair rewrite odd ffi tail tail merge odd ff ff merge ff tail odd ff merge odd tail ff odd tail tail ff merge odd tail ff tail ff proof cpp bisimulation consider set pairs supplied theta gamma coalgebra structure defining function fl theta ff fi 
head ff tail ff tail fi note fl defined tail ff tail fi bisimulation 
straightforward show projection functions homomorphisms coalgebras fl 
follows uniqueness aspect finality ff fi ff fi 
proceed considering bisimulations functor 
example define functor theta fv theta xg saw fifth coalgebra example section labeled transition system gamma 
identified coalgebra ff ff gamma 
words class labeled transition systems coincides class coalgebras 
gamma 
gamma 
labeled transition systems set labels 
interesting question coalgebra homomorphism transition systems coalgebras ff ff terms transition structures gamma 
gamma 
definition homomorphism ff ff function ffi ff ff ffi function denoted theta defined theta fha ha si easily prove equality ffi ff ff ffi equivalent conditions 
gamma 
gamma 

gamma 
gamma 
homomorphism function preserves reflects transitions 
notion quite standard preservation required see 
known notion bisimulation transition systems bisimulation transition systems relation theta satisfying hs ti 
gamma 
gamma 
hs 
gamma 
gamma 
hs concrete example bisimulation relation transition systems 
consider systems fflffl fflffl delta delta delta gf relation fhs fhs bisimulation fhs ti fhs bisimulation note function defined homomorphism exists homomorphism reverse direction cardinality reasons final coalgebra exist lemma ii final coalgebra fixed point theta set exist cardinality set strictly greater non trivial sets labels 
restrict called finitely branching transition systems satisfying states fha si gamma 
finite systems identified coalgebras functor theta fv theta finiteg functor final coalgebra exist 
proof bit technical due barr see omitted cf 
discussion section 
follows final coalgebra 
borrowing terminology concurrency theory call elements processes 
gamma 
ha 
show similarly example infinite lists satisfies coinductive proof principle bisimulation 
cpp essence proof principle observation bisimulation theta supplied coalgebra structure just define fl theta hp qi fl hp qi fha hp ii gamma 
gamma 
follows bisimulation property projection functions homomorphisms coalgebras 
finality homomorphisms equal proves cpp 
example concluded definition coinduction non deterministic merge operation processes proof cpp properties 
supply theta coalgebra structure theta fi theta theta hp qi fha hp gamma 
fha hp ii gamma 
finality exists unique homomorphism merge theta follows fact merge homomorphism transition systems theta merge ffi fi ffi merge satisfies rules gamma 
qi gamma 
qi gamma 
qi gamma 
function merge satisfies number familiar properties 
terminated process formally gamma transitions exist 
equalities 
pi 
qi pi 
qi ri rii consequence cpp fact relations bisimulations 
pi pg 
qi pi pg 
qi ri rii pg 
instance relation bisimulation transitions pi gamma 
gamma 
relation 
second relation consider pair processes qi pi suppose transition step qi gamma 
process 
case step pi considered proved exactly way 
follows rules situations applies exists transition gamma 
qi exists transition gamma 
consider situation second similar 
gamma 
follows rules exists transition pi gamma 
mimicked transition step qi transition step pi way resulting processes relation qi pair relation 
shows relation bisimulation 
kind argument 
notion bisimulation originally introduced semantics concurrency 
proof principle final coalgebras aczel theory non wellfounded sets 
categorical definition bisimulation bisimulation seen coalgebraic dual notion congruence algebras see section 
definitions bisimulation infinite sequences finitely branching processes special instances categorical definition reproduced 
definition functor coalgebra 
bisimulation relation exists coalgebra structure fl projection functions homomorphisms coalgebras oo fl oo general formulation coinduction proof principle follows 
theorem gamma 
final coalgebra 
bisimulation 
cpp examples proof principle immediate finality 
reader referred examples definitions proofs coinduction 
exist formalisations notion bisimulation 
bisimulation described coalgebra category relations suitably lifted functor associated original functor :10.1.1.36.7400
bisimulations occur suitable spans 
set theoretic context definition convenient 
predicates relations algebras coalgebras logical arguments far involved ffl inductive predicates algebras induction arguments 
mean inductive predicates satisfy induction assumptions underlying algebra 
example inductive predicate natural numbers see example assumptions induction argument 
inductive predicates suitably closed constructors algebra 
say predicates subsets subalgebras 
ffl bisimulation relations coalgebras 
binary predicates closed destructors transitions coalgebra 
subsets carry coalgebra structure indicated definition 
relations coinduction arguments sort see theorem bisimulation terminal coalgebra contained equality relation 
seeing unary predicates algebras binary predicates coalgebras wonders role binary predicates algebras unary predicates coalgebras 
aim section indicate case 
congruence relation algebra usually defined relation equivalence relation closed algebra constructors 
second condition equivalent subset carries algebra structure projection functions homomorphisms algebras dual definition see 
shall congruence relation satisfying requirement necessarily 
formulate binary induction principle congruence relation initial algebra contains equality relation 
notice perfect duality coinduction principle formulated 
note relation contains equality relation reflexive holds example binary induction principle natural numbers says holds relation theta hold easy see binary induction principle equivalent usual induction principle natural numbers 
noted proved subsequently general data types categorical setting 
situation unary predicates coalgebras fully settled 
relevance predicates closed coalgebra destructors transitions 
equivalently predicates carry subsets structure 
called analogy congruences invariants appears better name predicate holds state holds successors predicates described subsystems 
greatest invariants appear interest suitable property coalgebra greatest invariant inv final holds 
gives certain proof principle invariant inv 
applications principle may final coalgebra satisfying certain constraints characterised inv interpreted final coalgebra operations proving correctness refinements coalgebraic specifications object oriented setting 
table gives summary predicates interest algebras coalgebras 
algebra coalgebra unary inductive predicate subalgebra invariant binary congruence bisimulation 
go ulrich marieke huisman horst reichel comments earlier version 
aczel 
non founded sets 
csli lecture notes stanford 
aczel mendler 
final coalgebra theorem 
pitt poign rydeheard editors category theory computer science number lect 
notes comp 
sci pages 
springer berlin 
america rutten 
solving reflexive domain equations category complete metric spaces 
journ 
comp 
syst 
sci 
arbib manes 
arrows structures functors 
categorical imperative 
academic press new york 
arbib manes 
parametrized data types need highly constrained parameters 
inf 
contr 
de bakker 
control flow semantics 
mit press cambridge ma 
barendregt 
lambda calculus 
syntax semantics 
north holland amsterdam nd rev edition 
barr 
terminal coalgebras founded set theory 
theor 
comp 
sci 
corrigendum theor 
comp 
sci 

barr ch 
wells 
category theory computing science 
prentice hall 
barwise moss 
vicious circles mathematics non wellfounded phenomena 
csli lecture notes stanford 

eal perrin 
symbolic dynamics finite automata 
report univ de la vall ee 
bird de moor 
algebra 
prentice hall int 
series comput 
sci 
borceux 
handbook categorical algebra volume encyclopedia mathematics 
cambridge univ press 
burstall diaconescu 
hiding behaviour institutional approach 
roscoe editor classical mind 
essays honour hoare pages 
prentice hall 
cockett spencer 
strong categorical datatypes seely editor category theory number cms conference proceedings pages 
cockett spencer 
strong categorical datatypes ii term logic categorical programming 
theor 
comp 
sci 
cohn 
universal algebra volume mathematics applications 
reidel publ 
comp 
crole 
categories types 
cambridge mathematical textbooks 
cambridge univ press 
ehrig mahr 
fundamentals algebraic specification equations initial semantics 
number eatcs monographs 
springer berlin 
fiore 
coinduction principle recursive data types bisimulation 
inf 
comp 
montanari 
observability concepts data specifications 
mazurkiewicz editor mathematical foundations computer science number lect 
notes comp 
sci pages 
springer berlin 
goguen diaconescu 
algebraic semantics object paradigm 
ehrig orejas editors trends data type specification number lect 
notes comp 
sci pages 
springer berlin 
goguen 
proof correctness object representations 
roscoe editor classical mind 
essays honour hoare pages 
prentice hall 
goguen 
extended hidden agenda 
editors proceedings conference intelligent systems semiotic perspective pages 
nat 
inst 
stand 
techn 
goguen meseguer 
universal realization persistent interconnection implementation modules 
nielsen schmidt editors automata languages programming icalp number lect 
notes comp 
sci pages 
springer berlin 
goguen thatcher wagner 
initial algebra approach specification correctness implementation data types 
yeh editor current trends programming methodology pages 
prentice hall 
gordon melham 
hol theorem proving environment higher order logic 
cambridge univ press 
hermida jacobs 
algebraic view structural induction 
tiuryn editors computer science logic number lect 
notes comp 
sci pages 
springer berlin 
hermida jacobs 
structural induction coinduction setting 
full version 
hofmann pierce 
unifying type theoretic framework objects 
journ 
funct 
progr 
honsell 
final semantics untyped calculus 
dezani ciancaglini plotkin editors typed lambda calculi applications number lect 
notes comp 
sci pages 
springer berlin 
jacobs 
cofree coalgebras 
nivat editors algebraic methods software technology number lect 
notes comp 
sci pages 
springer berlin 
jacobs 
parameters parametrization specification distributive categories 
fund 
informaticae 
jacobs 
coalgebraic specifications models deterministic hybrid systems 
wirsing nivat editors algebraic methods software technology number lect 
notes comp 
sci pages 
springer berlin 
jacobs 
inheritance cofree constructions 
cointe editor european conference object oriented programming number lect 
notes comp 
sci pages 
springer berlin 
jacobs 
object oriented hybrid systems coalgebras plus monoid actions 
full version 
techn 
rep csi comput 
sci 
inst univ nijmegen 
jacobs 
objects classes algebraically 
freitag jones lengauer 
schek editors object orientation parallelism persistence pages 
kluwer acad 
publ 
jacobs 
invariants bisimulations correctness coalgebraic refinements 
techn 
rep csi comput 
sci 
inst univ nijmegen 
joyal nielsen winskel 
bisimulation open maps 
inf 
comp 
kamin 
final data types specification 
acm trans 
progr 
lang 
systems 
lambek scott 
higher order categorical logic 
number studies adv 
math 
cambridge univ press 
mac lane 
categories working mathematician 
springer berlin 
lehmann smyth 
algebraic specification data types synthetic approach 
math 
systems theory 
malcolm 
behavioural equivalence bisimulation minimal realisation 
haveraaen owe dahl editors trends data type specification number lect 
notes comp 
sci pages 
springer berlin 
manes 
algebraic theories 
springer berlin 
manes arbib 
algebraic program semantics 
texts 
comp 
sci 
springer berlin 
meijer fokkinga paterson 
functional programming bananas lenses envelopes barbed wire 
hughes editor functional programming languages computer architecture number lect 
notes comp 
sci pages 
springer berlin 
meinke tucker 
universal algebra 
abramsky dov maibaum editors handbook logic computer science volume pages 
oxford univ press 
melham 
automating recursive type definitions higher order logic 
birtwistle subrahmanyam editors current trends hardware verification automated theorem proving pages 
springer 
milner 
calculus communicating systems 
lect 
notes comp 
sci 
springer berlin 
milner tofte 
induction relational semantics 
theor 
comp 
sci 
owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
alur henzinger editors computer aided verification number lect 
notes comp 
sci pages 
springer berlin 
park 
concurrency automata infinite sequences 
deussen editor proceedings th gi conference theoretical computer science number lect 
notes comp 
sci pages 
springer berlin 
ch 
paulin mohring 
inductive definitions system coq 
rules properties 
bezem groote editors typed lambda calculi applications number lect 
notes comp 
sci pages 
springer berlin 
paulson 
isabelle theorem provers 
odifreddi editor logic computer science pages 
academic press london 
apic series vol 

paulson 
mechanizing coinduction corecursion higher order logic 
journ 
logic computation appear 
pierce 
basic category theory computer scientists 
mit press cambridge ma 
pitts 
induction principle recursively defined domains 
theor 
comp 
sci 
pitts 
relational properties domains 
inf 
comp 
plotkin 
structural approach operational semantics 
report daimi fn aarhus univ 
reichel 
approach object semantics terminal algebras 
math 
struct 
comp 
sci 
rounds 
feature logics 
van benthem ter meulen editors handbook logic language 
elsevier 
rutten turi 
foundations final semantics non standard sets metric spaces partial orders 
de bakker de roever rozenberg editors semantics foundations applications number lect 
notes comp 
sci pages 
springer berlin 
rutten turi 
initial algebra final coalgebra semantics concurrency 
de bakker de roever rozenberg editors decade concurrency number lect 
notes comp 
sci pages 
springer berlin 
rutten 
universal coalgebra theory systems 
cwi report cs 
smyth plotkin 
category theoretic solution recursive domain equations 
siam journ 
comput 
turi 
functorial operational semantics denotational dual 
phd thesis free univ amsterdam 
walters 
categories computer science 
publications sydney 
available cambridge computer science text 
wand 
final algebra semantics data type extension 
journ 
comp 
syst 
sci 

universal algebra computer scientists 
number eatcs monographs 
springer berlin 
wirsing 
algebraic specification 
van leeuwen editor handbook theoretical computer science volume pages 
elsevier mit press 

