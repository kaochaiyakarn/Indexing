higher order functions considered unnecessary higher order programming joseph goguen programming research group oxford university sri international menlo park ca usa claimed essence functional programming functions values higher order functions interesting examples showing power approach 
unfortunately logic higher order functions difficult particular higher order unification undecidable 
closely related higher order expressions notoriously difficult humans read write correctly 
shows typical higher order programming examples captured just order functions systematic parameterized modules style call parameterized programming 
advantages correctness proofs done entirely order logic interpreters compilers simpler efficient 
natural impose semantic requirements modules functions 
subtle point higher order logic mix subsorts useful functional programming supporting clean rigorous treatment partially defined functions exceptions overloading multiple representation coercion 
higher order logic avoided specification verification avoided possible reasons programming 
contains examples including hardware verification 
appendix shows extend standard equational logic quantification functions justifies surprising technique proving equations ground term reduction 
obj language gives examples showing higher order functions avoided sufficiently powerful parameterized modules 
consider higher order functions harmful useless claim significant advantages avoiding higher order functions possible claim avoided quite systematically functional programming parameterized programming 
course higher order logic useful areas particularly foundations mathematics type theory extracting programs proofs describing proof strategies lcf tactics semantics traditional programming languages scott strachey avoided possible appendix develops techniques reasoning order functions 
parameterized programming major advantage functional programming traditional imperative programming yield better structured programs 
language sufficiently powerful parameterized modules achieve highly structured programs higher order functions 
particular examples show typical higher order functional programming techniques easily carried obj parameterized programming ways written author computer science laboratory sri international 
structured flexible 
code broken highly parameterized mind sized internally coherent modules new programs constructed old ones instantiating transforming combining modules 
argues order parameterized programming includes essential power higher order programming offers certain advantages 
parameterized programming general powerful technique software design production reuse maintenance 
approach involves abstraction kinds module objects encapsulate executable code particular define data types theories specify syntactic structure semantic properties modules 
kind module parameterized actual parameters modules import modules 
interfaces parameterized modules defined theories include semantic syntactic constraints parameter instantiation view binds formal entities interface theory actual entities module asserts satisfaction theory module 
views class citizens named import modules parameterized 
integration objects theories views provides powerful wide spectrum capability 
software design represented hierarchy modules associated views software system constructed components design code executed 
particular module expressions allow complex instantiations generics include commands transform defined modules seen generalizing unix tm command 
maintenance facilitated editing re executing designs 
reusability enhanced flexibility parameterization composition transformation mechanisms 
default views greatly reduce effort defining views 
ideas illustrated obj wide spectrum order functional programming language rigorously order sorted conditional equational logic 
logic provides notion subtype supports useful features including multiple representation overloading coercion multiple inheritance exception handling 
rigorous semantic basis allows declarative style programming eases system design implementation facilitates program verification 
logical specifications directly executed 
points illustrated examples including simple hardware verification example 
history obj originally designed joseph goguen language error algebras attempt extend algebraic data types handle errors partial functions simple uniform way 
design ideas clear parameterized modules 
initial implementations obj done ucla joseph obj error algebras plus image construct parameterization 
david plaisted implemented obj enhancing sri improvements included efficient form matching modulo associativity commutativity hash coded memo functions highly interactive environment 
obj implemented sri futatsugi jean pierre jouannaud design led joseph goguen jos meseguer order sorted algebra error algebra obj provided clear parameterized modules theories views full generality 
latest version obj available sri international developed kyoto common lisp joseph goguen jos meseguer timothy winkler claude el ene kirchner implementation team led jos meseguer 
obj syntax quite close obj different implementation simpler ada notion generic package provides part needed 
particular ada generic packages provide way document semantics interfaces feature greatly improve reliability software reuse help retrieve right module library discussed 
ada provides weak facilities combining modules example level module instantiation possible time 
efficient operational semantics order sorted algebra 
provides sophisticated module expressions including default views timothy winkler deserves special credit 
obj seen implementation clear conditional order sorted logic 
implementations obj include umist obj university manchester institute science technology pascal university manchester mc obj univeristy milan franz lisp obj washington state university 
written pascal third umist obj available britain commercial product called obj ex variant called axis available labs bristol uk 
addition extending obj directions relational object oriented programming languages called foops respectively 
experimental obj systems implemented far applications including debugging algebraic specifications rapid prototyping defining programming languages way immediately yields interpreter see elegant peter mosses specifying software systems gks graphics kernel system ada configuration manager macintosh program obj hardware specification simulation verification see section 
applications produced experiment sponsored british alvey project collected book practical obj 
obj combined petri nets allowing structured data tokens language programming massively parallel machine executes rewrite rules directly fact believe obj machine greatly perform conventional language conventional machine direct concurrent execution rewrite rules foops offers advantages 
aspects obj section lengthy incomplete informal obj 
readers familiar obj skip directly section appendix readers familiar functional programming language skim section obj embodies basic design choices quite different programming languages including current functional programming languages 
rigorously deduction order sorted equational logic provides precise semantics exception handling multiple inheritance overloading multiple representations data abstractions 
uses strong sorting retracts ease parsing 

supports parameterized programming sketched expanded 

supports user defined evaluation strategies operation separately imposing global order evaluation allows eager lazy evaluation complex options efficient default evaluation strategies computed simple strictness analysis user provide explicit strategy 

rewriting modulo attributes including associative commutative identity idempotent 
obj logical programming language sense inference precise logical system conditional order sorted equational logic see logical programming order sorted equational logic 
argued advocates prolog confers certain important benefits program simplicity clarity greatly ease program understanding debugging maintenance separation logic control identity program logic proof logic 
language high level description program program execute 
logical programming languages include pure prolog pure lisp cds languages considered efficiently executable specification languages 
languages algebraic semantics include larch obscure act fair say significantly influenced obj 
higher order functional programming languages hope miranda ml haskell seen rewrite rules higher order equational logic tend impure features efficiency convenience example ml assignment exceptions miranda ad hoc coercions various kinds numbers lazy pattern matching 
standard ml powerful parameterized module facility inspired part clear 
guttag horowitz musser describe system symbolic execution algebraic data types levy sirovich describe tel system specifying semantics equations 
related systems include due hoffmann donnell lucas risch order elegant backus higher order functional programming fixed set rewrite rules data types 
section provides intuitive features obj needed understanding higher order programming examples 
important topics omitted including user definable evaluation strategies details obj semantics default views 
strong sorting avoid confusion associated different uses word type shall word sort connection sorted equational logic approach obj 
advantages strong sorting catch meaningless expressions executed separate logically intuitively distinct concepts enhance readability documenting distinctions 
modern structural editor little trouble insert sort declarations inserted automatically compiler smart editor 
ordinary unsorted logic offers dubious advantage applied example name age false iff birth temperature permissible 
lisp prolog hackers unsorted logic permissive 
sorted logic restrictive support overloaded function symbols integer rational complex numbers character serves placeholder arguments 
strictly speaking expression 
parse sorted logic assuming factorial applies natural numbers 
parses rational natural 
problem solved extending order sorted algebra retracts provide sufficient expressiveness truly meaningless expressions discussed section 
operation expression syntax worth extra implementation effort processing time support syntax flexible informative close users intuitions standard usage possible 
obj users define syntax operations including prefix postfix infix generally mixfix customize problem domain similar ecl 
obviously opportunities ambiguity parsing syntax 
obj convention expression formed exactly parse precisely unique parse sort see section 
argument value sorts operation declared time syntactic form 
distinguish cases 
usual parenthesized prefix commas functional form 
example op 
indicates sort sort sort 
general mixfix case uses place holders indicated character prefix declaration op top stack 
int top expressions top push 
similarly form singleton set operation declared op int 
set infix form addition op int int 
int mixfix declaration conditional op bool int int 
int 
operation declaration comes arity operation 
comes value sort called arity value pair called rank operation 
operations arity value sort different forms declared example ops zero 
ops 
parentheses required second case mark boundary forms 
simple object bit strings illustrates basic obj syntax obj bits sorts bit bits ops 
bit op nil 
bits op bit bits 
bits endo typical expression syntax object nil subsorts handle cases things sort sort example natural numbers rational numbers cases expressions may different sorts order sorted algebra 
approach involves imposing partial ordering set sorts nat rat meaning nat rat typographical convenience 
multiple inheritance supported sort distinct supersort operation overloading arises restricting functions subsorts 
signature object consists sorts subsort relation operations defined including form arity value sort 
happy facts order sorted algebra slightly difficult sorted algebra essentially results generalize sorted order sorted case complication 
omits technical details order sorted algebra rigorous mathematical theory 
order sorted algebra originated treated comprehensively summarized 
alternative approaches nicely developed gogolla wadge reynolds 
obj directly supports subsort polymorphism operator overloading consistent subsort restriction 
contrast languages ml hope support parametric polymorphism ideas strachey 
obj parameterized modules provide similar capability different way 
term order sorted signature considered formed iff unique parse lowest sort show occurs certain mild natural assumptions 
subexpressions expected sort coerced 
trivial subsort supersort example operation defined rationals fine natural number nat rat 
trivial way example consider 
defined natural numbers 
parse time know subexpression turn natural number parser consider rational fact expression 
parse conventional sense 
give benefit doubt having parser insert retract special operation symbol denoted rat nat example lowers sort removed run time subexpression really natural remains informative error message 
parser turns expression 
expression rat nat 
runtime rat nat 
automatically provided key equation rat nat variable sort nat 
describes mathematical operational semantics retracts 
exceptions inadequate semantic foundations insufficient flexibility programming specification languages 
algebraic specification languages partial functions simply undefined exceptional conditions 
approach developed rigorously unsatisfactory practice allow error messages error recovery 
time exploring rigorous approaches allow users define exception conditions messages handling 
unfortunately original obj error algebra approach lacks initial models current order sorted algebra approach entirely satisfactory 
subsorts give somewhat better representation bit strings previous subsection obj bits sorts bit bits ops 
bit op bit bits 
bits endo typical expression syntax semantics obj denotational semantics order sorted algebra concrete operational semantics order sorted rewriting 
operational semantics equations written declaratively interpreted operationally rewrite rules replace substitution instances lefthand sides corresponding substitution instances righthand sides 
illustrate computation term rewriting simple list int object 
protecting int line indicates int module provides integers imported module importation discussed section 
obj list int sort list protecting int subsorts int list op int list 
list op length list 
int var int var list eq length eq length length endo reduce command executed reaching term rules applied called normal reduced form 
functional programming languages require users declare constructors term reduced consists entirely constructors 
obj constructors achieving greater generality constructor declarations certainly aid compiler optimization 
example reduce length evaluated list int gives result int sequence rewrite rule applications length 
length 
length 


step uses second equation lefthand side length matching 
second step uses equation matching match works regarding integer list int subsort list 
third step simply uses rule step uses built arithmetic int 
consider sophisticated integer list object associative identity attributes obj list int sorts list nelist protecting int subsorts int nelist list op list list 
list assoc id nil op nelist list 
nelist assoc op head nelist 
int op tail nelist 
list var int var list obj optionally allows users define functions lisp code provide efficient implementations various kinds numbers 
eq head eq tail endo reduce nil nil result nelist executed applying identity axiom modulo associativity follows nil nil 
nil 
similarly reduce head result int reduce tail result nelist reduce tail nil nil result nelist explicitly name module context evaluation reduce bool true false identity attribute implemented adding rules pattern matching modulo identity 
subtle point extra rules needed 
example special case head equation list int nil added obj rulebase 
necessary generate called associative extension rules 
obj built polymorphic binary infix bool valued operation sort tell ground expressions equal 
computed checking syntactic identity normal forms expressions 
example bool just iff 
operation really equality sort provided rules expressions sort church rosser terminating respect evaluation strategy conditions guarantee normal forms reached 
negation available 
conditional bool 
provided defined sort obj allows conditional equations syntax ceq bool valued meaning operationally rewrite applied condition evaluates true 
denotational semantics operational semantics programming language shows computations done denotational semantics give precise meanings programs conceptually clear simple way supports proving properties 
denotational semantics obj algebraic algebraic approach data types denotation object algebra collection sets functions 
logical programming language obj established proof theory underlying logical system applies directly programs complex formalisms scott strachey denotational semantics hoare axiomatic semantics needed 
initial algebra semantics takes unique isomorphism initial algebra representative model equations may course models representation independent standard comparison correctness 
shows algebra initial satisfies properties 
junk element named constant operation symbols 
confusion equations true algebra proved equations 
rule set church rosser terminating rewrite rule operational semantics agrees initial algebra semantics see 
order sorted algebra obj provides completely general programming formalism sense partial computable function defined unpublished theorem jos meseguer give similar results total computable functions 
hierarchical structure conceptual clarity ease understanding greatly facilitated breaking program modules mind sized natural function 
turn greatly facilitates debugging reusability 
modules helpful keep explicit track hierarchical structure module dependence showing exactly modules 
collection modules module dependence relations constitute immediate context module 
module uses sorts operations declared module module explicitly imported defined earlier program 
program developed way structure hierarchy precisely acyclic graph modules 
exactly directed edge graph modules indicates higher target module imports lower source module context module subgraph modules depends subgraph top 
parameterized modules occur hierarchy treated essentially way modules 
discussion bit oversimplified obj environments reflect submodule relations general view relations may hold modules 
obj modes importing modules called extending protecting 
convention module imports module imports module imported importing transitive relation 
meaning import modes related initial algebra semantics importation module 
protecting adds new data items sorts identifies old data items sorts junk confusion 
extending identifies old data items sorts confusion hierarchy differs dijkstra parnas hierarchy machines higher level modules implemented lower level machines higher level modules include lower level modules 

guarantees 
implemented copying imported module text copying modules imports desired copied listing keyword 
parameterization basic building blocks parameterized programming theories views module expressions parameterized resulting capabilities go example ada generic modules 
described object encapsulates code 
hand theory defines interface parameterized module structure properties required actual parameter meaningful instantiation 
view expresses certain module satisfies certain theory certain way note module satisfy theory way view describes binding actual parameter requirement theory 
instantiation parameterized module actual parameter particular view yields new module 
module expressions describe complex interconnections modules possibly adding renaming modifying functionality 
topics treated greater detail 
theories theories express semantic properties modules module interfaces 
discuss requirement theories views respectively 
general obj theories structure objects particular theories sorts subsorts operations variables equations import theories objects parameterized views 
difference objects executable theories just define properties 
semantically theory variety models order sorted algebras satisfy object just model isomorphism initial algebra 
example theories 
example trivial theory triv requires sort designated elt 
th triv sort elt theory extension triv requiring models element sort designated 
th triv extending triv op 
elt course enrichment equivalent th triv sort elt op 
elt may clearer 
theory pre ordered sets partially ordered sets antisymmetric law 
models binary infix bool valued operation reflexive transitive 
th sort elt op elt elt 
bool vars elt eq true ceq true theory equivalence relation binary infix bool valued operation denoted eq reflexive symmetric transitive 
th eqv sort elt op eq elt elt 
bool vars elt eq eq true eq eq eq ceq eq true eq eq theory monoids serve parameter requirement theory general iterator particular gives sums products lists 
th monoid sort op 
assoc id possibility expressing semantic properties associativity operation part interface module aspect parameterized programming advantage traditional functional programming 
example certainly write second order function iterate binary function integer addition lists traditional functional programming state requirement binary function associative 
views module satisfy theory way unique way arbitrarily difficult find 
need notation describing particular ways modules satisfy theories 
example nat satisfy usual equal ordering divides greater equal possible corresponds different view 
expression sorting nat sorting requirement theory ambiguous absence definite conventions default views 
precisely view theory module indicated notation 
consists mapping sorts sorts preserving subsort relation mapping operations operations preserving arity value sort meaning attributes assoc comm id idem equation true model 
view theory logicians call theory interpretation 
mappings sorts operations expressed respective forms sort sort op op 
may operation forms forms plus value sort forms plus value sort arity needed disambiguation derived operations terms variables 
mapping considered set pairs 
sets pairs called view body 
syntax defining view top level obj adds names source target modules possibly name view 
example view nat sort elt nat op divides defines view called nat divisibility relation 
obvious view annoying write view full detail 
default views allow writing simple module expressions nat int possible capturing intuitive notion obvious view see details 
parameterized modules consider parameterized modules 
simple parameterized list object abstracting previously list int object 
obj list triv sorts list nelist subsorts elt nelist list op list list 
list assoc id nil op nelist list 
nelist assoc op head nelist 
elt op tail nelist 
list var elt var list eq head eq tail endo modules parameter 
example notation th th indicates parameters theories just write th 
parameterized theories allowed vector spaces field code similar list worth doing stack known done different formalisms fact provides illustration power order sorted algebra 
stack triv sorts stack subsorts elt stack op empty 
stack op push elt stack 
op top 
elt op pop 
stack var elt var stack 
eq top push eq pop push endo simple program desire 
instantiation subsection discusses instantiating formal parameters parameterized module actual modules 
construction requires view formal parameter requirement theory corresponding actual module 
result instantiation replace requirement theory corresponding actual module views bind actual names formal names producing multiple copies shared submodules 
example assuming parameterized object sorting form sorting sorting endm explicit view list nat endm uses default view triv nat instantiate parameterized module list actual parameter nat 
similarly real list list real endm real field real numbers default view triv real real vector sp real endm default view field real 
interestingly stack list real stack list real endm uses default views 
note ada allow complex module expression require steps 
general endm equivalent obj protecting endo may module view 
module composition parameterized programming powerful purely functional composition traditional functional programming single module instantiation compose different functions 
example generic complex arithmetic module easily instantiated real arithmetic modules actual parameter ffl single precision reals sp real ffl double precision reals dp real ffl multiple precision reals mp real 
instantiation involves substituting dozens functions dozens functions 
similar possible higher order functional programming coding modules records natural 
furthermore parameterized programming logic order understanding verifying code simpler 
semantic declarations allowed module interfaces requirement theories module expressions allow useful transformations combinations application 
approach parameterization inspired clear specification language 
fact obj regarded implementation clear 
particular notion view developed collaboration rod burstall clear 
clear approach turn inspired ideas general system theory 
key idea colimits diagrams theories determine result module expression evaluation 
colimits scope give precise foundation parameterized programming foundation independent particular choice underlying logical system making institutions 
logical programming language sense precise features parameterized programming described 
includes foops obj various combinations functional relational object oriented programming covered 
environments ordinary programming languages assignments names values indirection environments parameterized programming languages include relations modules 
section discussed submodule inclusion relation arises module importation giving acyclic graph structure 
views stored environments source target explicitly indicated giving rise general graph structure 
submodule inclusions seen views submodule hierarchy appears subgraph view graph 
interesting generalization instantiation 
notice parameterized module seen view requirement theory sum requirement theories body necessarily includes example stack triv just inclusion view stack triv 
code stack replacing name stack triv just 
binding view actual module form instantiation substitutes translation precisely result application called pushout category theory developed semantics clear 
technique single body parameterized different ways 
ada idea separate body specification really interface parts modules flexible views added 
module expressions module expressions permit defining constructing instantiating complex combinations modules permit modifying modules various ways making possible module wider variety contexts improve efficiency existing code 
major combination modes instantiation sum 
possible modifications 
extend module adding functionality 
rename external interface 
restrict module eliminating functionality 
encapsulate existing code 
modify code inside module 
approach program transformation provides broad range program transformations right inside programs easily takes account data structure 
module importation seen special case parameter instantiation convenient treat separately see section 
worth mentioning modules may internal states feature discussed far implemented give information approach important issue 
simplest module expressions constants including built data types bool nat int qid id float plus user defined modules available current environment 
theory triv built ary parameterized tuple modules form tuples sorts 
requirement theories tuple triv 
example tuple int bool module expression principle sort consists pairs integer truth value 
example tuple list int int bool 
renaming uses view body sort mapping operation mapping create new module old 
renaming applied module expression postfix modifies syntax module expression applying pairs 
enrich module expression need import module add desired sorts operations equations really need explicit enrichment transformations module expressions 
example renaming modify theory enrich follows th eqv op eq vars elt eq eq eq important module building operation creates new module adds sums combines information summands 
modes summand modules just imported modules default extending 
important issue sharing submodules imported summand 
example sum probably protecting import bool may protect extend nat int modules 
sum contain copy multiply imported modules 
useful sum views source sum view sum sources target sum view sum targets 
see details 
higher order programming verification section argues higher order functions needed higher order programming 
subsection shows typical higher order programming techniques accomplished order logic parameterized programming suggests advantages approach 
second subsection gives hardware verification example 
examples higher order logic useful areas including foundations mathematics type theory extracting programs correctness proofs algorithms describing proof strategies lcf tactics modeling traditional programming languages scott strachey semantics studying foundations programming process 
main advantage higher order programming traditional imperative programming capability structuring programs see cogent arguments examples 
language sufficiently powerful parameterized modules need higher order functions 
oppose higher order functions claim lead unnecessarily complex programs avoided programming languages 
claim parameterized programming provides alternative basis higher order programming certain advantages 
particular shows typical higher order functional programming examples easily coded obj programs quite structured flexible rigorous 
theories document semantic properties may required functions 
classic functional programming example motivated instances sigma adds list numbers pi multiplies 
encompass similar examples want function applies binary function recursively suitable lists 
see example looks vanilla higher order functional programming notation 
polymorphic list type defined type list nil cons list function want defined function iter 



list 
axiom iter nil 
axiom iter cons list 
iter list write sigma list 
iter plus list pi list 
iter times list applications iter correctly certain semantic properties 
example want evaluate pi list multiplications possible parallel associative 
algorithm converts list binary tree tree level parallel 
associativity implies homomorphic property needed correctness proof iter append list list iter list iter list list list type 
furthermore want empty list nil behave correctly property identity example obj 
mixfix syntax improves readability somewhat significantly requirement theory monoid assert associativity identity axioms actual arguments generic iteration module obj iter monoid protecting list 
op iter list 
var var list 
eq iter nil eq iter iter 
endo monoid identity 
note list uses default theory view triv 
monoid 
code uses associative list easy write code cons constructor obj 
instantiate iter get examples 
sigma iter nat endm sums lists numbers pi iter nat endm people find rank iter difficult understand 
simplified uncurrying products convention permits omitting parentheses devices help 
feel products fundamental higher order functions eliminating products currying misleading confusing 
multiplies lists numbers view nat views nat monoid addition nat view nat monoid multiplication 
impressively clear concise programs written rigorous order logic 
valid instance iter property notation written iter iter iter natural state fact theory view follows th hom monoid protecting list op list 
var list eq view iter hom monoid hom iter view parameterized property holds instances obtain appropriate assertion instance iter just instantiate view actual parameter module semantic requirements argument functions stated conventional functional programming language done outside language 
obj assert monoid property prove property implies property methods described 
argued easier higher order functions type inference get declarations instantiations automatically 
notational overhead encapsulating function module really keywords generated automatically structural editor single keystroke overhead shared function declarations 
overhead due variable declarations 
reduced techniques type inference give variable highest possible sort declare sorts fly qualification notation 
implemented obj explicit declarations save human program readers effort doing type inference 
sort operation declarations needed approach notation slightly simplified thought worth trouble 
view crucial issue structure large programs clear possible tricks slightly simplify notation small examples little importance negative value harder read large programs 
hand notation instantiation significantly simplified example non default views needed renaming needed avoid ambiguity instance module context 
example iter nat iter view nat op endm certainly complex iter plus 
just iter nat denote module go bit iter nat denote iter function effect creating module instantiation defines 
essentially notation functional programming avoids need give distinct names distinct instances iter 
call abbreviated operation notation 
argument note expression iter nat uses default view conventions elt maps nat bool maps 
abbreviated operation notation implemented obj abbreviated view notation example 
alternative model polymorphism order sorted algebra declare certain parameterized objects polymorphic syntactic scope obtain usual kind polymorphism order logic 
am sure worth trouble rare need different instantiations function symbol handled simple module expressions 
second example define traditional function map applies unary function list arguments 
interface theory requires sort unary function generally distinct source target sorts desired 
th fn sort op 
obj map fn protecting list op map list 
list var var list eq map nil nil eq map map endo instantiate map various ways 
object defines functions examples 
obj fns protecting int op sq int 
int op dbl int 
int op int 
int var int eq dbl eq eq sq endo instantiation uses default view fn 
fns maps sq sq operation introduced fns 
test map fns endm sample reduction reduce map result nelist reductions objects line non default views operation abbreviation reduce map dbl fns map result nelist reduce map fns map result nelist module classical functional programming example applying function twice instantiations 
obj fn op 
var eq endo reduce fns result int reduce dbl fns result int reduce fns op fns result int consider example carefully 
applies twice result function instantiation applies sq twice raises th power second instantiation applies twice raises th power 
renaming prevent syntactic ambiguity avoided qualification 
summarize difference parameterized programming higher order functional programming essentially difference programming large programming small 
parameterized programming just combine functions combines modules 
parallels great insights modern algebra important examples functions considered isolation association functions constants axioms satisfy explicit sources targets 
invention algebras vector spaces groups parallels invention program modules vectors permutations parameterized programming parallel explicit carries introducing theories views document semantic requirements function arguments module interfaces assert provable properties modules property 
noted convenient combine modules compose functions single module instantiation compose conceptually related functions complex arithmetic example mentioned section 
hand notational overhead theories views excessive applying just function 
exactly case abbreviated view operation notations advantage 
forget difficult reason higher order functions order functions fact undecidability higher order unification means difficult certain aspects reasoning 
easier compile interpret order programs 
worth noting poign significant difficulties combining subsorts higher order functions hope convincing subsorts useful 
note experience programmers just naive ones higher order notation difficult understand 
hardware specification simulation verification subsection develops computer hardware verification example 
crucial advantage logical programming language reductions really proofs programs really logical theories 
propositional calculus decision procedure object excellent example software reuse original form written years thought hardware verification obj sort prop protecting truth qid subsorts id bool prop op prop prop 
prop assoc comm prec op xor prop prop 
prop assoc comm prec vars prop eq false false eq true eq eq xor false eq xor false eq xor xor op prop prop 
prop assoc comm prec op prop 
prop prec op implies prop prop 
prop prec op iff prop prop 
prop assoc prec eq xor xor eq xor true eq implies xor xor true eq iff xor xor true 
endo xor constructors subject group equations second group introduces derived operations 
attribute prec means operation follows precedence lower precedence means tighter binding 
declaration id bool prop prepares way overloading boolean operations includes identifiers propositions propositional variables 
code defines time bit streams functions time prop 
requirement theory line defined gate 
object introduces variables generic time input stream respectively 
gates composed applied renaming avoid syntactic ambiguities nice default views 
note expression form iff reduces true iff reduce thing 
extended equations proved described informally 
detail assertion form sigma phi means satisfied initial algebra sigma union signatures obj objects time union equations phi signature containing functions time prop 
readers may surprised see equations second order quantifiers proved just ground term reduction basics needed correctness verification technique appendix details may 
obj time sort time op 
time op time 
time endo th line protecting time op time 
prop obj line op time 
prop var time eq false eq endo obj protecting time op 
time op time 
prop endo op op endm reduce iff result bool true reduce iff result bool true reduce iff result bool true note parameterized modules code readable 
techniques equally effective difficult examples hardware specification simulation verification discussed 
parameterized programming attractive application instances just kinds basic gates 
summary discussion shown higher order functions needed typical higher order programming techniques fact shown advantages order parameterized programming including greater flexibility possibility imposing semantic requirements arguments functions 
poign significant difficulties combining subsorts higher order functions argued subsorts useful seen argument higher order functions 
difficult reason properties higher order functions fact undecidability higher order unification means difficult certain aspects reasoning 
easier compile optimize interpret purely order programs 
note experience programmers just naive ones higher order notation difficult understand 
bit philosophical may say ordinary computation manipulating bits instructions inherently order mathematics inherently higher order reason reasoning 
appendix presents useful extension equational logic quantification functions particular justifies surprising technique proving second order quantified equations just ground term reduction 
gives powerful calculus order reasoning order functions think may capture reasoning needed functional programming 
think conclude better factorize code parameterized modules higher order functions fact better avoid higher order functions possible 
conclude essence functional programming higher order functions lack side effects 
feel true essence may having solid basis equational logic avoids side effects importantly supports simple equational reasoning programs transformations needed powerful programming environments 
seeing parameterized programming way supplant higher order logic see interesting direction generalize higher order logic calculus views confront issues formalized calculus including 
basic types modules including bool nat monoid user chooses define denote just classes functions categories models order sorted algebras case obj 

similarly parameters range classes functions classes modules classes subject semantic constraints equations 

modules include theories objects 

parameterized modules represent functors classes models 

views entirely new feature calculus 
points deserve elaboration 
suggest awkward code parameterized programming form denotational semantics style type theory style pebble px martin lof type theory 
encoding sort notation deal practice somewhat trying program godel numbers valuable theoretical studies 
course code calculus type theory obj quite different issue 
encoding parameterized programming emphasize really fundamental entities just types play secondary role indices functions typed calculus objects play secondary role indices morphisms category theory may modules play secondary role indices views parameterized programming 
claim order proof theory major advantage obj interesting see far parameterization pushed asset 
possible achieve equivalent parameters parameterized nesting parameterized modules 
special case type theory calls dependent types 
see discussion 
significant applications elaborate possibilities allowed type theory remains unclear 
interesting inquire find suitable categorical semantics terms similar cartesian closed category characterization calculus course semantics clear shown needs colimits theories 
locally cartesian closed categories relevant cartmell categories extending hierarchy parameterized module inclusions preserved instantiation see hierarchical categories 
interesting john gray dependent data types 
altogether promising area research 
wish professor rod burstall extended going collaboration clear foundations inspired parameterization mechanism obj dr jos meseguer invaluable contributions aspect obj including theoretical foundations implementation applications timothy winkler suggestions concerning design theory obj professor jean pierre jouannaud efforts educate theory practice rewrite rules dr futatsugi programming methodology obj victoria efforts obj hardware specification verification 
jos meseguer timothy winkler valuable comments drafts 
research reported supported part science engineering research council national science foundation system development foundation contracts office naval research fujitsu 
second order quantifiers order equations appendix generalizes standard case equational logic quantifies constants permit quantification arbitrary function symbols 
kind second order quantification seen order equational logic limit second order realm essential terms order 
see generalization useful 
mathematics easy extension standard case hard see thought 
appendix includes new results justifying ground term reduction prove equations second order quantifiers 
result powerful order calculus reasoning order functions believe satisfactory trying calculus general powerful tool 
body familiarity basics universal algebra probably needed read appendix 
obj order sorted equational logic discussion uses unsorted equational logic expository simplicity 
signature sigma family sigma sets element sigma function symbol arity particular elements sigma constant symbols 
signatures sigma phi union defined sigma phi sigma phi sigma algebra set interpretation function sigma family functions sigma interpret function symbols sigma actual functions point set say sigma identify point generally write just sigma algebras sigma homomorphism function sigma particular sigma signature sigma sigma denote sigma algebra ground sigma terms 
recall sigma initial sense sigma algebra unique sigma homomorphism sigma define sigma equation consist signature phi variable symbols disjoint sigma plus pair sigma phi terms 
write equations abstractly form phi concretely form arities presumably inferred uses example power kind equation arises denotational style semantics expressions normally write equations ae ae ae gamma ae ae gamma ae theta ae ae theta ae 
simpler equation quantifies binary function symbol ae ae equation slightly different meaning finite set equations asserts homomorphic property possible get semantics conditional equation 
standard case phi nonempty phi identified set standard variables 
case union signature written sigma standard equations written abstractly form sigma terms concretely form sigma algebra interpretation phi variable symbols phi unique extension sigma phi homomorphism sigma phi initiality sigma phi regarded sigma phi algebra extend interpretation function sigma sigma phi 
sigma term variables phi just element sigma phi sigma algebra satisfies sigma equation phi iff interpretation phi case write sigma phi sigma algebra satisfies set sigma equations iff satisfies case write sigma presentation sigma ei consists signature sigma set sigma equations 
obj program defines presentation sigma ei sigma finite standard details yields sigma ei involve theories views colimits need concern simply identify presentation sigma ei ignore concrete syntax obj 
course obj program really defines order sorted presentation restricting attention unsorted case 
obj programming language specification language admits kinds program 
objects intended semantics standard model 
theories intended semantics variety models second case generally appears auxiliary role usually interested defining particular data structures particular functions 
basic intuition equational logic standard models initial models 
reduction techniques sufficient prove properties initial models particular supplemented induction techniques 
writing sigma phi mean sigma phi sigma theorem disjoint signatures sigma phi set sigma equations sigma phi sigma phi iff sigma phi denotes empty signature 
proof condition equivalent condition sigma phi algebra satisfying sigma phi unique homomorphism 
pleasing proof simple entirely semantics satisfaction particular choice rules deduction 
follows view rewrite rules reduces value sigma phi helps justify hardware proof section full details may 
moral appendix higher order functions unnecessary higher order programming higher order logic unnecessary reasoning functional programs 
detail including completeness theorem induction principles techniques verifying generic modules 
john backus 
programming liberated von neumann style 
communications association computing machinery 
eugenio de giancarlo 
net systems class high level nets having objects domains 
joseph goguen derek coleman robin editors applications algebraic specification obj 
cambridge university press 
appear 
jan bergstra john tucker 
characterization computable data types means finite equational specification method 
automata languages programming seventh colloquium pages 
springer verlag 
lecture notes computer science volume 
berry pierre luc 
theory practice sequential algorithms kernel applicative language cds 
algebraic methods semantics pages 
cambridge university press 
bidoit christine choppy 
specification environment motivations design 
hans jorg kreowski editor trends data type specification volume informatik pages 
springer verlag 
selected papers third workshop theory applications data types 
rod burstall john darlington 
transformation system developing recursive programs 
journal association computing machinery january 
rod burstall joseph goguen 
putting theories specifications 
raj reddy editor proceedings fifth international joint conference artificial intelligence pages 
department computer science carnegie mellon university 
rod burstall joseph goguen 
semantics clear specification language 
bjorner editor proceedings copenhagen winter school software specification pages 
springer verlag 
lecture notes computer science volume unpublished notes handed symposium algebra applications stefan banach center poland 
rod burstall joseph goguen 
informal specifications clear 
robert boyer moore editors correctness problem computer science pages 
academic press 
reprinted software specification techniques gehani andrew editors addison wesley pages 
rod burstall joseph goguen 
algebras theories freeness computer scientists 
manfred wirsing gunther schmidt editors theoretical foundations programming methodology pages 
reidel 
proceedings marktoberdorf nato summer school nato advanced study institute series volume 
rod burstall butler lampson 
kernel language data types modules 
proceedings international symposium semantics data types volume lecture notes computer science pages 
springer verlag 
rod burstall david macqueen donald sannella 
hope experimental applicative language 
proceedings lisp conference volume pages 
stanford university 
john cartmell 
formalising network hierarchical data models application categorical logic 
proceedings conference category theory computer programming volume pages 
springer verlag 
lecture notes computer science 
carlo marco de giancarlo 
mc obj interpreter obj 
note di software october 
italian 
thomas 
definitional facilities higher level programming languages 
proceedings afips fall joint computer conference pages 
spartan books 
derek coleman robin victoria 
design rewrite rule interpreter algebraic specifications 
iee software engineering journal july 
alan colmerauer van 
etude un syst eme prolog 
technical report groupe intelligence artificielle de universit ii 
david duce 
concerning compatibility gks 
joseph goguen derek coleman robin editors applications algebraic specification obj 
cambridge university press 
appear 
hartmut ehrig bernd mahr 
fundamentals algebraic specification equations initial semantics 
springer verlag 
derek coleman alia 
axis papers 
technical report hpl isc tr bristol labs 
futatsugi joseph goguen jean pierre jouannaud jos meseguer 
principles obj 
brian reid editor proceedings th acm symposium principles programming languages pages 
association computing machinery 
futatsugi joseph goguen jos meseguer okada 
parameterized programming obj 
robert balzer editor proceedings ninth international conference software engineering pages 
ieee computer society press march 
christopher paul 
specification controlled implementation configuration management tool obj ada 
joseph goguen derek coleman robin editors applications algebraic specification obj 
cambridge university press 
appear 
martin gogolla 
partially ordered sorts algebraic specifications 
bruno courcelle editor proceedings ninth caap bordeaux pages 
cambridge university press 
nr 
universitat dortmund abteilung informatik 
martin gogolla 
final algebra semantics errors exceptions 
hans jorg kreowski editor trends data type specification volume informatik pages 
springer verlag 
selected papers third workshop theory applications data types 
joseph goguen 
types theories 
appear proceedings symposium general topology applications oxford june oxford university press 
joseph goguen 
mathematical representation hierarchically organized systems 
editor global systems dynamics pages 
karger 
joseph goguen 
semantics computation 
ernest manes editor proceedings international symposium category theory applied computation control pages 
university massachusetts amherst 
lecture notes computer science volume springer verlag pages 
joseph goguen 
errors data types 
eric neuhold editor proceedings ifip working conference formal description programming concepts pages 
mit 
formal description programming concepts peter neuhold ed north holland pages 
joseph goguen 
prove algebraic inductive hypotheses induction applications correctness data type representations 
wolfgang bibel robert kowalski editors proceedings fifth conference automated deduction pages 
springerverlag 
lecture notes computer science volume 
joseph goguen 
reusing interconnecting software components 
computer february 
reprinted tutorial software reusability peter freeman editor ieee computer society press pages 
joseph goguen 
obj theorem prover application hardware verification 
graham editors current trends hardware verification automated theorem proving pages 
springer verlag 
technical report sri csl sri international computer science lab august 
joseph goguen 
principles parameterized programming 
ted biggerstaff alan perlis editors software reusability volume concepts models pages 
addison wesley 
joseph goguen rod burstall 
institutions model theory specification programming 
journal association computing machinery appear 
report computer science department university edinburgh january preliminary version report csli center study language information stanford university remote ancestor introducing institutions proceedings logics programming workshop edward clarke dexter kozen editors springer verlag lecture notes computer science volume pages 
joseph goguen derek coleman robin editors 
applications algebraic specification obj 
cambridge university press 
appear 
joseph goguen jean pierre jouannaud jos meseguer 
operational semantics algebra 
brauer editor proceedings international conference automata languages programming 
springer verlag 
lecture notes computer science volume 
joseph goguen jos meseguer 
rapid prototyping obj executable specification language 
software engineering notes december 
proceedings rapid prototyping workshop 
joseph goguen jos meseguer 
universal realization persistent interconnection implementation modules 
nielsen schmidt editors proceedings th international conference automata languages programming pages 
springerverlag 
lecture notes computer science volume 
joseph goguen jos meseguer 
equality types generic modules logic programming 
douglas degroot gary lindstrom editors logic programming functions relations equations pages 
prentice hall 
earlier version appears journal logic programming volume number pages september 
joseph goguen jos meseguer 
order sorted algebra solves constructor selector multiple representation coercion problems 
proceedings second symposium logic computer science pages 
ieee computer society press 
technical report csli center study language information stanford university march 
joseph goguen jos meseguer 
unifying functional object oriented relational programming logical semantics 
bruce shriver peter wegner editors research directions object oriented programming pages 
mit press 
preliminary version sigplan notices volume number pages october 
joseph goguen jos meseguer 
software rewrite rule machine 
proceedings international conference fifth generation computer systems pages 
institute new generation computer technology icot 
joseph goguen jos meseguer 
order sorted algebra equational deduction multiple inheritance overloading exceptions partial operations 
technical report sri csl sri international computer science lab july 
lecture seminar types carnegie mellon university june draft versions exist 
joseph goguen jos meseguer david plaisted 
programming parameterized objects obj 
domenico ferrari mario joseph goguen editors theory practice software technology pages 
north holland 
joseph goguen 
algebraic denotational semantics parameterized modules 
formalizing programming concepts pages 
springer verlag 
lecture notes computer science volume 
joseph goguen joseph 
obj language writing testing software specifications 
marvin zelkowitz editor specification reliable software pages 
ieee press 
reprinted software specification techniques gehani andrew editors addison wesley pages 
joseph goguen james thatcher eric wagner 
initial algebra approach specification correctness implementation data types 
technical report rc ibm watson research center october 
current trends programming methodology iv raymond yeh editor prentice hall pages 
joseph goguen james thatcher eric wagner jesse wright 
data types initial algebras correctness data representations 
alan editor computer graphics pattern recognition data structure pages 
ieee press 
michael gordon robin milner christopher wadsworth 
edinburgh lcf 
springer verlag 
lecture notes computer science volume 
john guttag 
specification application programming data types 
phd thesis university toronto 
computer science department report csrg 
john guttag james horning wing 
larch easy pieces 
technical report digital equipment systems research center july 
john guttag ellis horowitz david musser 
data types software validation 
communications association computing machinery 
robert harper david macqueen robin milner 
standard ml 
technical report department computer science university edinburgh 
hayashi hiroshi nakano 
px computational logic 
technical report rims research institute mathematical sciences kyoto japan april 
christoph hoffmann michael donnell 
programming equations 
transactions programming languages systems 
paul hudak philip wadler arvind report functional programming language haskell 
technical report yaleu dcs rr computer science department yale university december 
draft proposed standard 
john hughes 
functional programming matters 
technical report programming methodology group university goteborg november 
horst reichel 
initial algebraic semantics non context free languages 
marek karpinski editor fundamentals computation theory pages 
springerverlag 
lecture notes computer science volume 
claude kirchner el ene kirchner jos meseguer 
operational semantics obj 
proceedings th international conference automata languages programming 
springerverlag 
lecture notes computer science volume 
john latham 
pascal tutorial 
technical report version university manchester department computer science 
joseph goguen timothy winkler 
cell ensemble architecture rewrite rule machine 
proceedings international conference fifth generation computer systems pages 
institute new generation computer technology icot 
claus werner lerman jacques 
obscure new specification language 
hans jorg kreowski editor trends data type specification volume pages 
springer verlag 
selected papers third workshop theory applications data types 
giorgio levy sirovich 
tel proof theoretic language efficient symbolic expression manipulation 
technical report iei february 
nota interna 
peter lucas tore risch 
representation factual information equations evaluation 
technical report ibm research yorktown heights 
david macqueen ravi sethi gordon plotkin 
ideal model recursive polymorphic types 
proceedings symposium principles programming languages pages 
association computing machinery 
martin lof 
constructive mathematics computer programming 
logic methodology philosophy science vi pages 
north 
john mccarthy michael levin lisp programmer manual 
mit press 
jos meseguer 
general logics 

ebbinghaus editors proceedings logic colloquium 
north holland 
jos meseguer joseph goguen 
initiality induction computability 
maurice nivat john reynolds editors algebraic methods semantics pages 
cambridge university press 
robin milner 
theory type polymorphism programming 
journal computer system sciences 
peter mosses 
semantic algebras 
bjorner editor formal description programming concepts ii pages 
ifip press 
peter mosses 
basic semantic algebra 
proceedings international symposium semantics data types pages 
springer verlag 
lecture notes computer science volume 
nakagawa futatsugi shimizu 
algebraic specification macintosh obj 
technical report draft electrotechnical laboratory tsukuba science city japan 
proceedings tenth international conference software engineering singapore april 
michael donnell 
equational logic programming language 
mit press 
department defense 
manual ada programming language 
united states government report ansi mil std 
david plaisted 
initial algebra semantics error presentations 
sri international computer science laboratory 
axel poign 
semantic algebras higher order structures 
informatik ii universitat dortmund 
noah amir pnueli 
compilation specifications computer programs 
ieee transactions software engineering se may 
john reynolds 
category theory design implicit conversions generic operators 
neal jones editor semantics directed compiler generation pages 
springer verlag 
lecture notes computer science volume 
william scherlis 
data types specialization program reuse 
conradi tor dag editors proceedings workshop advanced programming environments pages 
springer verlag 
lecture notes computer science volume 
william scherlis dana scott 
steps inferential programming 
mason editor information processing pages 
elsevier north holland 

locally cartesian closed categories type theory 
mathematical proceedings cambridge philosophical society 
sridhar 
implementation obj object oriented language program specification 
editor proceedings sixth conference foundations software technology theoretical computer science pages 
springer verlag 
lecture notes computer science volume 
victoria 
specifying obj verifying ideas time 
technical report draft department computer science university manchester 
joseph 
design specification implementation language writing testing algebraic program specifications 
phd thesis ucla computer science department 
david turner 
miranda non strict functional language polymorphic types 
jouannaud editor functional programming languages computer architectures pages 
springer verlag 
lecture notes computer science volume 
william wadge 
classified algebras 
technical report university warwick october 
mitchell wand 
order identities defining language 
acta informatica 
originally report computer science indiana university 
steven zilles 
specification data types 
technical report computation structures group massachusetts institute technology 
contents parameterized programming 
history 
aspects obj strong sorting 
operation expression syntax 
subsorts 
semantics 
operational semantics 
denotational semantics 
hierarchical structure 
parameterization 
theories 
views 
parameterized modules 
instantiation 
module expressions 
higher order programming verification examples 
hardware specification simulation verification 
summary discussion second order quantifiers order equations 
