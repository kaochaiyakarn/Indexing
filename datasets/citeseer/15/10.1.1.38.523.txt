distributed replicated data balanced search structure theodore johnson university florida dept cis gainesville fl adrian mit laboratory computer science cambridge ma concurrent dictionary data structures proposed usually context shared memory multiprocessors 
algorithm concurrent distributed tree implemented message passing computer systems 
distributed tree db tree replicates interior nodes order improve parallelism reduce message passing 
db tree stores redundant information nodes permit lazy updates maintain replica coherency 
show db tree algorithm build efficient implementation highly parallel data balanced distributed dictionary de tree 
keywords concurrent dictionary data structures message passing multiprocessor systems balanced search trees link trees replica coherency 


introduce new balanced search tree algorithm distributed memory architectures 
search tree uses link tree base distributes ownership nodes processors maintain tree 
replicate non leaf nodes improve parallelism 
apply read write consistency maintenance rule reading node cheaper writing node expensive increase degree replication 
observe node close root read rarely written node close leaf rarely read relatively written 
ownership rule processor owns leaf owns copy nodes root leaf 
root replicated node operations initiated fully parallel manner modified nodes near leaf moderately replicated reducing cost maintenance 
restructuring tree occurs path root leaf 
processor restructures node local copy parent restructuring decisions locally eliminating need centralized control permitting parallelism 
keys distributed data structure arbitrarily statically allocated processors processors required store disproportionate share keys 
imbalance cause processor exhaust storage space processors store keys 
distributed search structure needs able perform data balancing order efficiently storage available system 
show data balancing implemented flexible distributed link tree algorithms 

search trees 
search trees widely fast implementations dictionary data types 
dictionary partial mapping keys data supports operations insert delete search 
simplicity assume dictionary stores data keys may viewed set keys 
number useful computations implemented terms dictionary data types including symbol tables priority queues pattern matching systems 
tree originally introduced bayer 
tree algorithms sequential applications designed minimize response time single query sequential algorithm single search operation balanced tree logarithmic complexity 
improvement response time may achieved parallel algorithm single search best logarithmic number processors 
parallel systems important concern increasing system throughput series search insertion deletion operations executing parallel 
large number concurrent search tree algorithms literature prevents complete description 
discuss common issues addressed algorithms 
concurrent search tree algorithms share problem managing contention 
concurrency control required ensure independent processes accessing tree interfere 
common approach associate read write lock node search tree 
causes data contention writers block incoming writers readers readers block incoming writers 
contention severe occurs higher levels search tree particularly root termed root bottleneck 
similar problems caused resource contention 
shared memory architecture processes trying access tree node access memory module machine 
similarly message passing architectures processor node resides receive messages processor trying access node 
resource contention serious higher levels search tree 
node replication reduces contention requires coherence protocol maintain consistency 
redundant information stored db tree nodes allows lazy update algorithms maintain consistency 
associated contention issue problem process overtaking 
may occur process holds lock selects node wishes access releases lock attempts acquire lock node 
second process may acquire lock node original process releasing old lock acquiring lock node 
second process update node fashion cause process lock wrong node eventually acquires lock 
prevent kind process overtaking algorithms operations lock coupling block independent operations 
operation traverses tree obtaining appropriate lock child releasing lock holds parent 
link trees eliminate need lock coupling 
wrong node reached stage operation able find correct node 
reduces number locks held concurrently increases throughput 
link tree base db tree 

previous 
wang weihl proposed parallel trees stored multi version memory special cache coherence algorithm linked data structures 
multi version memory permits single update occur replicated node point time analogous value logging transaction systems 
algorithm permits concurrent updates replicated nodes analogous transition logging 
ellis proposed algorithms distributed hash table 
directories table replicated sites data buckets distributed sites 
hash table shallow search structure update index structure distributed copy index 
distribution updates limited distributed tree multilevel index structure 
link tree flexible data structure sophisticated operations range queries easily implemented 
yen developed algorithms implementing hash table simd parallel computer cm 
authors examine chaining linear probing double hashing handle bucket overflows 
peleg proposed structures implementing distributed dictionary 
concern papers message complexity access data balancing 
issues efficiency concurrent access addressed 
shmueli propose methods distributing search structures way high space utilization 
authors assume index stored shared memory don address issues concurrent restructuring 
meyer auf der hyde give algorithms implementing hash table synchronous network 
gives algorithms performance bounds implementing search tree synchronous butterfly mesh network 
proposed pipelined distributed tree level tree maintained different processor 
parallelism obtained implementation limited number levels tree distributed tree data balanced 
contribution highly parallel distributed tree db tree permits concurrent updates replicated tree node rarely blocks operations 
show distributed tree implement efficient highly parallel data balanced distributed dictionary de tree 
section describe db tree 
section show de tree built db tree 
drawn section 
db tree concurrent distributed tree 

concurrent link tree algorithms 
base distributed tree concurrent link tree 
link tree algorithms highest performance existing concurrent tree algorithms 
restructuring operations link trees performed node time algorithms easily translated distributed environment 
link tree node contains pointer right neighbor 
concurrent link tree algorithm node contains field highest highest valued key stored subtree rooted node 
link tree algorithms additional information stored nodes operation recover tree due date information 
template concurrent link tree algorithm described sagiv shown code 
search operations start placing read lock root searching root determine node access 
search operation unlocks root places lock node 
search operation continues accessing interior nodes manner reaches leaf contain key searching 
operation reads node finds highest field lower key searching follows right pointer node 
search operation reaches leaf contain key searching searches leaf key returns success failure depending key leaf 
link locate decisive key var node root loop invariant lock find nil exit loop unlock loop keyset dec restructure code 
concurrent link tree algorithm 
insert operation works phases search phase restructuring phase 
search phase insert operation uses algorithm search operation places exclusive write locks leaf nodes 
insert operation reaches appropriate leaf inserts key key leaf 
leaf full insert operation split leaf restructure tree usual tree algorithm 
operations hold lock time break restructuring disjoint pieces 
insert operation finds restructure tree performs operation see 
half split operation consists creating new node sibling transferring half node keys sibling linking sibling leaf list 
order complete split insert operation releases lock node locks parent inserts pointer sibling 
parent full insert operation applies restructuring steps 
notice period time pointer parent sibling 
operations reach sibling right pointers highest field 
sibling sibling parent parent parent complete split half split initially fig 

half split operation link tree shared memory multiprocessor easily support deletion nodes 
lehman yao recommend nodes deleted 
sagiv describes garbage collection algorithms nodes 
shasha wang describe algorithm leaves stubs place deleted nodes 
show nodes safely removed tree due explicit naming shared nodes 

db tree 
distributed tree algorithm builds concurrent link algorithms 
example db tree distributed tree shown 
leaves db tree distributed processors 
interior nodes db tree replicated processors 
rule replicating interior processor owns leaf owns copy node path root leaf inclusive 
processor level links neighbors just right neighbor 
keeping nodes level double linked list simplifies replication control deletion nodes discussed aids downwards range queries 
addition node stores distance leaves 
nodes db tree distributed processors share common memory space 
naming nodes address name tags 
node unique tag 
tags generated requiring processor keep count objects creates 
processor creates node names root fig 

db tree counter concatenated processor id pointer db tree node node tag list processors copy node 
order access node processor translates tag local address translation table organized hash table example 
db tree operations defined search insert delete 
operations usual semantics 
operation db tree performs actions tree nodes order perform computation 
actions performed atomically processor processor local data 
processor queue pending actions need performed local nodes 
processor helps maintain accepts operations processors performs operation suboperations 
conversely processor send operation different processor 
processor executes code 
get task node action parameters queue local node lookup node node execute recovery actions execute action local node code 
main loop node manager 
processor store node action requesting action recover error 
case occur processor stored node deleted transferred 
discuss possibilities type 
search operation originates participating processors starts performing node search action locally stored copy root 
search operation originates processor help maintain db tree transmit request participating processors 
node search action completely local node read parallel processor owns copy node node search processor block update node processor 
node search action determines node access essentially step algorithm code 
copy node search path may stored locally case local copy copies may stored remotely case processor send operation processor stores copy node 
node search local node action range local node local node leaf level local node action level execute action local node locate child perform local search child action locate neighbor perform local search neighbor action code 
node search action 
node search action basic mechanism ensuring action performed correct node case sagiv algorithm 
node search written deliver action nonleaf node 
example search operation key stored originates processor operation reads processor copy root transmits request read processor 
processor choice sites send search operation choice reasonable criteria locality estimated load 
example search request key stored originates processor processor chooses processors service request search node 
search operation reaches correct leaf returns success message originating processor key leaf failure message 
insert delete operation cause restructuring executed way search operation action leaf insert delete key 
insert delete actions applied inserting keys leaf inserting pointers new children parent 
insert delete actions specified code 
insert local node pointer deletion recorded pointer insert key pointer local node update replicated copies local node local node full perform half split local node remove record deletion 
code 
insert algorithm 
delete local node key node delete key local node update replicated copies local node local node leaf record deletion node code 
delete algorithm 
insert delete actions performed asynchronously 
result action insertion child arrive parent action deletes link arrives 
delete action arrives corresponding link delete delete recorded cancels corresponding insert 
insert causes node full triggers half split action 
allow implementation choose point node merges triggered example merge empty causes little loss space utilization greatly simplifies implementation 

db tree half splits half merges 
double links requires splitting node carried steps 
half split action shown code illustrated 
node full splits sibling half keys stored sibling node stored locally transferred different processor set processors 
step leaf list consistent 
pointer sibling inserted parent 
split procedure carried performing actions nodes 
half split action performed node link change action sent node insert action sent parent 
note copies sibling parent 
actions sibling parent performed concurrently half split action block waiting completion 
action sent responsible processors 
note parent split merged search actions performed insert link change actions performed 
assume parent sibling sibling parent sibling parent parent initially split point sibling parent point sibling fig 

db tree half split modification suboperations performed copies node atomically 
half split local node create sibling transfer half keys local node sibling link point sibling add sibling incoming link list perform link change local node sibling neighbor perform insert sibling parent code 
half split action 
node merged empty removed tree 
half merge procedure shown code illustrated 
node deleted contact neighbors transfer key range keys contains 
transfer completed marks deleted indicates node contains keyspace 
addition node performs link change points sibling 
node sends link change action sibling delete action parent 
node splits merges neighbors concurrently split merge 
node perform link change action identified upper lower key space range name 
furthermore range boundary deleted due merge 
case link change longer applicable ignored 
order ensure node level index reach parent agree merge parent parent change local pointers reclaim space 
fig 

db tree half merge node level require links merged node node level removed merged node deleted 
node keeps list nodes contain left link 
left right neighbor node contain links soon perform link change action 
addition nodes left completed link change action due split previously deleted nodes remain structure see 
node splits adds name new sibling incoming link list sibling receives name right neighbor 
node agrees half merge puts deleted node incoming link list 
link change action performed node performs action acknowledges link change 
deleted node informs node merged space reclaimed 
node merges left neighbor wait nodes incoming link list acknowledged link change reclaiming space 
node merges right neighbor wait left neighbor 
node receives right link change action node incoming link list deletes node list possibly records new right neighbor left link list 
half merge local node contact neighbor agree merge transfer keys keyspace mark local node deleted drain requests neighbor perform link change local node neighbor neighbor perform delete local node parent nodes incoming link list acknowledged fig 

old links deleted node 
link change deletion inform neighbor deletion reclaim space code 
half merge action 
accept half merge local node neighbor half merge acceptable agree half merge accept keys keyspace update link pointer add neighbor incoming link list code 
accepting merge request 
link change actions performed order generated doubly linked list nodes level correctly maintained 
requests link change node causally related generated actions neighbor numbering scheme enforce ordering 
link change local node neighbor boundary value boundary value matches local node boundary change link obeying causal ordering acknowledge link change code 
link change action 
parent deleted node receives deletion boundary child find keyspace shrunk 
example see 
case boundary values parents modified link change action 
period time unclaimed key range parent list 
messages received order sent cause action 
addition grandparent informed new boundary 

actions 
node deleted guarantees action attempt access 
particular actions arrive parent children deleted node 
result request perform action node arrive processor highest highest lowest highest separating child deleted perform deletion parent neighbor parent neighbor parent highest highest neighbor lowest lowest perform link change parent lowest highest perform link change neighbor inform grandparent grandparent link change fig 

shifting key range parent 
store node 
processor find node db tree submit action 
node submit action node sent action node level root 
node search action eventually deliver action intended destination 

integrating concurrency control replica coherency 
discussion assumed modifications nodes occur atomically 
achieve atomic updates requiring modifying actions lock copy modified node performing update block reads updates node wellknown algorithms managing replicated data 
maintain replicated nodes far synchronization overhead 
observe necessary distribute contents node modification necessary distribute modification 
second tree left incorrect state search actions need blocked 
third modifying actions commute 
authors studied issue concurrency control data types operations may commute context transaction processing system 
algorithms similar described ellis maintain replicated directories distributed hash tables necessary actions performed order nodes 
example insert actions may performed order 
example shown nodes half split copies parent parent parent inserted copy inserted copy parent parent copies parent fig 

lazy inserts nodes split pointers new nodes need inserted pointers parents 
time sibling created pointer sibling inserted parent sibling reached search insert delete actions right left pointers 
inserts parent node pending matter performed performed different order different copies parent node 
actions node performed arbitrary order 
consider example copies node full 
actions pending node insert delete 
suppose insert performed delete copy delete performed insert second copy 
copy decide split node second copy 
problem inserts deletes ordered problem arises split action ordered insert delete actions 
order argue correctness data structure need correctness condition 
natural correctness condition operations applied data structure eventually evolve state replicated copies nodes contents set operations applied single copy data structure sequentially equivalent serial order 
shasha goodman describe proof schemas concurrent search structures discussed 
link type data structures action atomic maps state state structure action action accesses node removed search structure algorithm correct 
handle replication need additional conditions copy node eventually receives set actions 
second non commuting actions performed order copy 
addition replication algorithms enforce desired orderings actions requiring link changes executed order requested 
categorize actions nodes lazy semi synchronous synchronous amount synchronization required perform action 
lazy action need synchronize lazy actions 
semi synchronous action synchronize actions 
classify synchronous action ordered actions requires communication nodes 
johnson krishna framework creating analyzing lazy update algorithms 
framework develop algorithms manage db tree node 
algorithm uses lazy insert actions semi synchronous half split actions 
addition algorithm framework accounts ordered actions require classes actions performed node order generated 
example actions ordered 

correctness operations 
shasha goodman provide framework proving correctness non replicated concurrent data structures 
extensive framework order discuss operation correctness 
data type consists data structure set operations data structure 
case dictionary adt operations insert delete search 
operation consists sequence actions carry operation 
adt operation takes search structure state 
example insert operation adds key search structure state 
issue need address meaning state search structure 
base section assumed search structure state globally observable assumption applies context multiprogrammed uniprocessor tightly coupled parallel processor 
interested search structures asynchronous distributed system global time exist 
result need careful defining state search structure particular point computation 
nodes search structure distributed processors manner operations performing actions 
node contain keys contain pointers nodes possibly stored different processors 
intuitively col lection nodes contents collectively global state question look nodes order collect global state 
due restrictions speed light examine state nodes simultaneously 
recording nodes processor state nodes changing 
concept consistent snapshot define global state 
global state corresponds see run snapshot algorithm 
actions completed simultaneous global state snapshot get 
search structures modeling replicated search structures node logical search structure stored different processors 
say physically stored replicas logical node copies logical node 
generally refer physically stored records copies logical records nodes 
asynchronous synchronous system replicated copies node general value 
indicate set copies members set copies node mark physical nodes system label 
copies label iff 
replicated copies logical node 
refer logical node label assigned copies 
state distributed search structure copies root contents ffl set nodes logical search structure 
ffl set physically stored copies 
ffl copies maps logical node physical copies 
function label inverse mapping copies 
note copies corresponding node 
ffl set directed edges data structure copies theta copies 
ffl root distinguished node root copies root root copies 
ffl contents function returns keys contained copy node 
contents keyspace ffl function returns set keys operation traverses edge searching 
keyspace operation key starting traverse state copies label value logical node single copy equivalent 
logical nodes single copy equivalent state search structure single copy equivalent 
contents implies label search structure replicate data 
consider search structures replicate data 
path pathset intersection edges suppose copy root copy root case call search structure single rooted 
inset copy union paths copy root outset node union edges leaving keyset node difference inset outset keyset set keys stored single rooted search structure state ffl keyset jc partitions keyspace 
ffl contents keyset search structure root copies possible roots 
search structure state ffl data structure state wrt 
edge set root copy 
ffl node keyset wrt 
root copy 
global contents gc search structure union contents nodes search structure gc contents 
operations data structure map structure global contents 
operation specification mapping stated 
ffl member ds ds bool bool true iff ds ffl insert ds ds nil ds ds fxg ffl delete ds ds nil ds ds gamma fxg operation executes submitting initial action execution submits subsequent actions forth actions due operation executing pending processor 
define execution operation consists actions program issues partial ordering actions return values actions partial ordering causal happens ordering iff 
executed processor executed processor sends message processor executes receives executes transitive closure 
actions related ordered concurrent 
operation contain concurrent actions performs update copies replicated node example 
computation quadruple search structure state computation starts search structure state computation completes set operations execution partial order extends operation partial orders 
partial order means completes begins actions occur simultaneously aren ordered 
proposition 
distributed search structure computation total order actions change return values final state actions 
proof communication processors execute concurrent actions order concurrent actions arbitrarily 
place total order execution actions operation 
similarly place total order actions distributed computation 
lamport timestamps example ffl actions search structure computation serialized am 
sequence states gamma corresponds sequence snapshots global state take computation 
different set snapshots order concurrent actions differently see different set global states operation return values final search structure state 
serialized order possible serialized order serialized orders equivalent important aspects 
computation parent fo om computation semantically serializable 
total order execution sequence gc yields gc final state returns return value operation computation strict serializable 
serializable 

actions dec dec operation distinguished decisive action define type serializability 
computation decisive action serializable 
serializable 
dec dec decisive action operation typically changes global state data structure decides return value 
decisive operation serializability stronger condition strict serializability decisive operation serializable implies strict serializable somewhat easier prove 
correctness condition computation type serializability equivalent serial execution 
generally start assuming base serial algorithm correct building serial algorithm 
assume analogue serial algorithm issues actions copies simultaneously executes isolation correct 
mentioned previously decisive action operation meant action performs operation 
say action operation proper decisive action performs specification 
total formed search structure computation keyset computation 
begins state action maps state state 

dictionary operation execution exactly decisive action proper decisive 

actions change global contents 
theorem 
keyset computation strict serializable 
proof keyset computation total formed computation actions ordered 
particular decisive actions operations ordered 
ordering dictionary operations ordering decisive actions 
serial execution specification ds ds 
consider actions non decisive operations don change global state global state remains decisive action 
actions map states states decisive action performed maps representative ds gamma ds returns value global contents don change decisive operation final state computation ds decisive operation serializable strict serializable want stronger condition serializability want search structure look single copy search structure 
particular want final state search structure single copy equivalent 
definition distributed search structure computation distributed keyset computation keyset computation single copy equivalent 
distributed keyset computation keyset computation operations serializable 
final state single copy equivalent search structure appearance single copy search structure 
note distributed keyset computation required single copy equivalent final state intermediate state 
issue single copy equivalence addressed 
link algorithm concurrent data structure uses linked nodes allow concurrent actions locks 
operation due action operation node recover link pointers 
code shows execution typical link algorithm 
case db tree search insert delete actions leaves decisive actions 
shasha goodman show correctness criteria link type algorithms set paths define node pathset inset intuitively node set keys stored keys stored nodes legal path node 
restructuring phase operation release lock link algorithm decrease operation recover undetected decrease inset 
shasha goodman guidelines link type algorithms 
non decisive action maps state state 

keyset state preceding dec dec occurs dec proper decisive action maps state state 

action change global contents 

action removes action argument accesses theorem shasha goodman 
computation begins state dictionary actions link technique satisfy guidelines decisive action serializable 
corollary 
db tree decisive action serializable 
proof proof corollary consists applying theorem db tree regarding multi rooted search structure 
note uses link technique 
need show guidelines followed 
keys stored leaf nodes leaf nodes partition keyspace 
non decisive action maps state state 

search insert delete operation uses node search action locate key proper key range atomically perform decisive action 
decisive action proper decisive maps state state 

global contents db tree stored leaves 
replica coherency algorithm ensures link change actions executed order issued leaf reachable node 
period time parent may point deleted node space reclaimed portion key space may directly reachable parent 
algorithm detects condition link eventually changed reachable 
operations blocked period time keys removed global contents 

space node reclaimed algorithm permit access node executes recovery action 

distributing data de tree 
simple implementation distributed dictionary statically divide key range processors direct operations processor manages operation key 
problem simple approach processors data balanced 
insert equally directed processor processor keys hold considerably keys average 
data balancing necessary order distribute request load prevent processors required devote disproportionate share memory resources dictionary prevent storage errors storage available processors 
ellis algorithm performs data balancing processor runs storage 
peleg studied issue data balancing distributed dictionaries complexity point view requiring processor store keys number keys number processors 
practice definition simultaneously strong weak ignores constants node capacities 
db tree provides flexibility perform data balancing processors leaves tree distributed processors arbitrary fashion 
processor splits node assign newly created node processor owns fewest leaves 
data balancing mechanism expensive restructuring requires communication processors causes internal nodes widely replicated 
way reduce communication costs try neighboring leaves stored processor 
define extent maximal length sequence neighboring leaves owned processor 
processor decides owns leaves looks processors neighboring extents 
neighbor accept leaves processor transfers leaves neighbor 
neighboring processor lightly loaded heavily loaded processor searches lightly loaded processor creates new extent 
shows processor db tree data balanced extents 
notice extents characteristics leaf db tree upper lower range doubly linked accept dictionary operations occasionally split merged 
transform extent balanced db tree de tree distributed extent tree 
processor manages number extents 
keys stored extent kept convenient data structure 
extent linked neighboring extent 
extents managed leaves db tree 
processor decides heavily loaded looks neighboring extents take keys 
neighboring processors heavily loaded new extent created lightly loaded processor 
processor manages new extent chosen number heuristics examine factors data load processor capacity communication locality degree replication 
creation deletion extents shifting keys extents de tree correspond splitting merging leaves db tree index updated db tree algorithms 
primary advantage de tree db tree great reduction amount index restructuring required keys inserted deleted restructuring required 
addition size distributed index reduced size proportional number processors number keys assume processor store keys 

propagating load information 
information load processors distributed system informed decisions creating placing new extents 
design load propagation mechanism address tradeoff propagating information quickly processors require significant communication bandwidth distribute load information propagating information slowly processors result load imbalance processors sitting idle system slow react changes load individual processors 
addition load balancing techniques unstable large systems 
instability arise information propagated slowly processors may think lightly loaded long heavily loaded continue create tasks 
arise de tree processor processor processor processor processor processor processor processor processor processor processor processor extent balanced db tree fig 

de tree decisions create new extents quickly load processor changes new extents moved processor suddenly lightly loaded 
avoid problems information propagated reasonably rapidly system number processors react quickly change load particular processor limited 
suitable load propagation mechanisms include probing gradient methods processor pairing drafting algorithms bidding algorithms 
algorithms lumer huberman uses hierarchical control structure particularly suited number processors large 

analysis 
db tree algorithm designed avoid blocking permit highly concurrent access 
occasion action blocked occurs parent points deleted child space reclaimed 
action resubmitted parent parent submit action node neighbors block action 
action routed node level deleted node action blocked 
updates node non blocking lazy updates permit concurrent updates node 
performance db tree depends factors 
example message passing overhead depends network topology distribution nodes processors load balancing algorithm implementation replica coherency 
consider space overhead required de tree 
best case processor stores extents worst case processor stores extents number processors 
processor stores nodes path root leaf processor stores log log internal nodes 
gives algorithms storing search tree synchronous mesh butterfly network require storage overhead key 
suggested replication strategy storage complexity guarantee note mass storage system typically store ae log bytes processor 
processors store de tree log messages passed perform desired operation 
index restructuring required data balancing performed relatively rare 
de tree efficient distributed index practice 


distributed dictionary blink tree db tree 
interior nodes tree replicated order allow processors read node increase parallelism 
degree replication decreases descends root order control cost maintaining replica coherency 
update operations interior nodes rarely block operations search phases proceed concurrently replicated node cases increasing parallelism tree 
flexible db tree construct efficient data balanced dictionary de tree 
de tree assigns key ranges processors processor may maintain key ranges 
db tree allow key ranges created deleted modified centralized control 

acknowledgments 
william weihl comments suggestions 
bayer symmetric binary trees data structure maintenance algorithms acta informatica pp 

bayer concurrency operations trees acta informatica pp 

bernstein hadzilacos goodman concurrency control recovery database systems addison wesley 
operation specific locking trees principles database systems acm sigact sigart sigmod pp 

bryant finkel stable distributed scheduling algorithm proceedings international conference distributed computing systems pp 

kurose towsley resource contention management parallel systems radc tr rome air development center radc april 
chandy lamport distributed snapshots determining global states distributed systems acm transactions computer systems pp 

brewer dellarocas weihl algorithm concurrent search trees proceedings th international conference parallel processing pp 
iii iii 
dietzfelbinger meyer auf der hyde optimal parallel dictionary proc 
acm symp 
parallel algorithms architectures pp 

donovan performance shared memory parallel computer ieee transactions parallel distributed systems pp 

ellis concurrent search inserts trees acta informatica pp 

distributed data structures case study ieee transactions computing pp 

unix local computer network load balancing ieee computer pp 

finkel solomon horowitz distributed algorithms global structuring proceedings national computer conference pp 

gifford weighted voting replicated data proceedings seventh annual acm symposium operating system principles acm pp 

peleg compact deterministic distributed dictionaries proceedings tenth annual acm symposium principles distributed computing acm pp 

guibas sedgewick dichromatic framework balanced trees proc 
th annual symposium foundations computer science acm pp 

herlihy quorum consensus replication method data types acm transactions computer systems pp 

johnson performance concurrent data structure algorithms phd thesis nyu dept computer science 
johnson krishna lazy updates distributed search structures sigmod 
johnson shasha utilization trees inserts deletes modifies acm sigact sigmod sigart symposium principles database systems pp 

framework performance analysis concurrent tree algorithms acm symp 
principles database systems pp 

krishna johnson implementing distributed search structures tech 
report uf cis tr anonymous ftp site cis ufl edu university florida dept cis 
kwong wood new method concurrency trees ieee transactions software engineering se pp 

shasha symmetric concurrent tree algorithm fall joint computer conference pp 

lausen integrated concurrency control shared trees computing pp 

lehman yao efficient locking concurrent operations trees acm transactions database systems pp 

lin keller gradient model load balancing method ieee transactions software engineering se pp 

lumer huberman dynamics resource allocation distributed systems preprint submitted ieee transactions smc xerox palo alto research center march 
shmueli efficient method distributing search structures symposium parallel distributed information systems pp 

miller multiple access trees proceedings conference information sciences systems johns hopkins university baltimore md pp 

mohan levine aries im efficient high concurrency index management method write ahead logging research report rj ibm 
mond raz concurrency control trees databases preparatory operations th international conference large databases stockholm aug pp 

ng histories implement atomic objects acm transactions computer systems pp 

ni xu distributed drafting algorithm load balancing ieee transactions software engineering se pp 

peleg distributed data structures complexity oriented view fourth int workshop distributed algorithms bari italy pp 

quinn designing efficient algorithms parallel computers mcgraw hill 
maintaining dynamic ordered sets processor networks proc 
acm symp 
parallel algorithms architectures pp 

sagiv concurrent operations trees overtaking journal computer system sciences pp 

schwartz spector synchronizing data types acm transactions computer systems pp 

shasha goodman concurrent search structure algorithms acm transactions database systems pp 

shasha schmidt analytical model performance concurrent tree algorithms nyu note nyu lab 
srinivasan carey performance tree concurrency control algorithms tech 
report computer sciences technical report university madison 
thomas majority consensus approach concurrency control multiple copy databases acm transactions database systems pp 

wang depth analysis concurrent tree algorithms tech 
report mit lcs tr mit laboratory computer science 
weihl concurrency control data types ieee trans 
computers pp 

impact recovery concurrency control tech 
report mit lcs tm mit laboratory computer science 
weihl liskov implementation resilient atomic data objects acm transactions programming languages systems pp 

weihl wang multi version memory software cache management concurrent trees proc 
nd ieee symp 
parallel distributed processing pp 

yen hash tables massively parallel systems int parallel processing symposium pp 


