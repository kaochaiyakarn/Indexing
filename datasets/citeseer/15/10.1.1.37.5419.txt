appears proceedings acm sigplan conference programming language design implementation may 
hardware trends produced increasing disparity processor speeds memory access times 
variety techniques tolerating reducing memory latency proposed rarely successful pointer manipulating programs 
explores complementary approach attacks source poor locality problem manifestation memory latency 
demonstrates careful data organization layout provides essential mechanism improve cache locality pointer manipulating programs consequently performance 
explores placement techniques cluster ing coloring improve cache performance increasing pointer structure spatial temporal locality reducing cache conflicts 
reduce cost applying techniques discusses strategies cache conscious reorganization allocation describes semi automatic tools ccmorph ccmalloc strategies produce cache conscious pointer structure layouts 
ccmorph transparent tree utilizes topology information cluster color structure 
ccmalloc cache conscious heap allocator attempts locate contemporaneously accessed data elements physical cache block 
evaluations microbenchmarks small benchmarks couple large real world applications demonstrate cache conscious structure layouts produced ccmorph ccmalloc offer large performance benefits cases significantly outperforming state art prefetching 
keywords cache conscious data placement clustering coloring cache conscious allocation cache conscious reorganization 
speed microprocessors increased year decades 
period time access main memory decreased year 
unfortunate inevitable consequence trends large increasing processor memory gap 
memory caches ubiquitous response problem 
single cache sufficed increasing gap orders magnitude requires hierarchy caches introduces disparities memory access costs 
hardware software techniques prefetching multithreading non blocking caches dynamic instruction scheduling speculative execution try reduce tolerate memory latency 
programs performance dominated memory 
high variable memory access costs undercut fundamental memory ram model programmers understand design data structures algorithms 
period application workloads changed 
predominately scientific applications broadened richer workload 
shift came change data structure arrays richer mix pointer structures 
surprisingly techniques reducing tolerating memory latency scientific applications ineffective pointer manipulating programs 
addition techniques fundamentally limited focus manifestation problem memory latency cause poor locality 
general software locality improved changing program data access pattern data organization layout 
approach successfully applied improve cache locality scientific programs manipulate dense matrices 
properties array structures essential uniform random access elements number theoretic basis statically analyzing data dependencies 
properties allow compilers analyze array accesses completely reorder way increases cache locality loop transformations affecting program result 
unfortunately pointer structures share property 
possess extremely powerful property locational transparency elements structure placed different memory cache locations changing program semantics 
careful placement structure elements provides mechanism improve cache locality pointer manipulating programs consequently performance 
describes provides analytic framework placement techniques clustering coloring improve cache performance uniprocessor systems increasing data structure spatial temporal locality reducing cache conflicts 
applying techniques may require detailed knowledge program code data structures architectural familiarity considerable programmer effort 
reduce cost discuss strategies cache conscious reorganization cache conscious allocation applying placement techniques produce cache conscious pointer structure layouts describe semi automatic tools ccmorph ccmalloc embody strategies 
measurements demonstrate cache conscious data layouts produced ccmorph ccmalloc offer large performance benefits cases significantly outperforming copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
cache conscious structure layout chilimbi computer sciences department university wisconsin west dayton st madison wi chilimbi cs wisc edu mark hill computer sciences department university wisconsin west dayton st madison wi cs wisc edu james larus microsoft research microsoft way redmond wa larus microsoft com state art prefetching 
contributions cache conscious data placement techniques 
section shows clustering coloring improve pointer structure cache performance 
clustering places structure elements accessed contemporaneously cache block 
coloring heavily infrequently accessed element non conflicting cache regions 
strategies applying cache conscious data placement techniques 
section describes strategies cache conscious reorganization cache conscious allocation applying placement techniques produce cache conscious data layouts 
cache conscious reorganization utilizes structure topology profile information data access patterns transform pointer structure layouts 
approach incorporated ccmorph utility reorganizes tree structures trees lists chained hash tables clustering coloring structure 
programmer need supply function helps traverse data structure 
cache conscious allocation improves conventional heap allocators attempting locate contemporaneously accessed data elements physical cache block 
section describes ccmalloc memory allocator implements strategy 
case programmer specify additional argument malloc pointer structure element contemporaneous 
evaluation cache conscious data placement 
section demonstrates performance benefits cache conscious data placement 
microbenchmarks cache conscious trees outperform naive counterparts factor outperform trees factor 
pointer intensive programs olden benchmark suite semi automatic cache conscious data placement improves performance outperformed state art prefetching 
applied techniques full application programs 
radiance widely ray tracing program showed speedup vis model verification package improved 
significantly applying ccmalloc line vis required little application understanding took hours 
analytic framework 
section presents analytic framework quantifies performance benefits cache conscious pointer data structures 
key part framework data structure centric cache model series accesses traverse pointer data structure 
model characterizes performance pointer data structure amortized rate sequence pointer path accesses 
applies framework cache conscious trees validates predictions microbenchmark 

cache conscious data placement techniques section discusses general data placement techniques clustering coloring combined wide variety ways produce cache efficient data structures 
running example discussion binary trees 
clustering clustering attempts pack data structure elements accessed contemporaneously cache block 
clustering improves spatial temporal locality provides implicit prefetching 
effective way cluster tree pack subtrees cache block 
illustrates subtree clustering binary tree 
intuitive justification binary subtree clustering follows detailed analysis section 
series random tree searches probability accessing child node 
nodes subtree clustered cache block expected number accesses block height subtree log greater 
consider alternative depth clustering scheme nodes block form single parent child grandchild chain 
case expected number accesses block course analysis assumes random access pattern 
specific access patterns depth search clustering schemes may better 
addition tree modifications destroy locality 
experiments indicate trees change infrequently subtree clustering far efficient allocation order clustering 
coloring caches finite associativity means limited number concurrently accessed data elements map cache block incurring conflict misses 
coloring maps contemporaneously accessed elements non conflicting regions cache 
illustrates color scheme way set 
subtree clustering 

associative cache easily extended multiple colors 
cache cache sets set contains associativity blocks partitioned regions containing sets sets 
frequently accessed structure elements uniquely mapped cache region remaining elements mapped region 
mapping ensures heavily accessed data structure elements conflict replaced infrequently accessed elements 
tree heavily accessed elements nodes near root tree 

strategies applying data placement designing cache conscious data structures requires detailed knowledge program code data structures considerable programming effort 
section explores strategies cache conscious reorganization cache conscious allocation applying placement techniques produce cache conscious data layouts describes semi automatic tools ccmorph ccmalloc implement strategies 
significantly reduce level programming effort knowledge architectural familiarity 
cache conscious data reorganization data structure typically allocated memory little concern memory hierarchy 
resulting layout may interact poorly program data access patterns causing unnecessary cache misses reducing performance 
cache conscious data reorganization addresses problem specializing structure layout correspond access pattern 
general structures require detailed profile program data access patterns successful data reorganization 
important class structures trees possess topological properties permit cache conscious data reorganization profiling 
section presents transparent semantic preserving tree ccmorph applies clustering coloring techniques described previous section 
ccmorph language unrestricted pointers analytical techniques identify pointers structure element 
knowledge system move reorder data structures application cooperation language designed garbage collection 
programmer guarantees safety operation ccmorph transparently reorganizes data structure improve locality applying clustering coloring techniques section section 
reorganization appropriate read data structures built early computation subsequently heavily referenced 
approach construction consumption code need change structure reorganized phases 
structure changes slowly ccmorph periodically invoked 
ccmorph operates tree structures homogeneous elements external pointers middle structure data structure decomposed components satisfying property 
allows liberal definition tree elements may contain parent predecessor pointer 
programmer supplies ccmorph respect structure type pointer root data structure function traverse structure cache parameters 
example contains code reorganize quadtree data structure olden benchmark perimeter programmer supplying node function 
ccmorph copies structure contiguous block memory number contiguous blocks large structures 
process partitions tree structure subtrees laid linearly 
structure colored map elements traversed unique portion cache determined color const parameter conflict structure elements 
ccmorph determines values size subtrees cache parameters structure element size 
addition takes care ensure gaps virtual address space implement coloring correspond multiples virtual memory page size 
effectiveness ccmorph discussed section 
cache conscious heap allocation ccmorph requires little programming effort currently works tree structures moved 
addition incorrect usage ccmorph affect program correctness 
frequently accessed cache virtual address space data structure elements remaining data structure elements 
coloring data structure elements reduce cache conflicts 
complementary approach requires little programming perform cache conscious data placement elements allocated 
general heap allocator invoked times data techniques incur low overhead 
difference data operate entire structures global techniques coloring heap allocator inherently local view structure 
reasons cache conscious heap allocator ccmalloc performs local clustering 
ccmalloc safe incorrect usage affects program performance correctness 
ccmalloc ccmalloc memory allocator similar malloc takes additional parameter points existing data structure element accessed contemporaneously parent tree node 
ccmalloc attempts locate new data item cache block existing item 
contains code olden benchmark health illustrates approach 
experience ccmalloc indicates programmer unfamiliar application select suitable parameter local examination code surrounding allocation statement obtain results see section 
memory hierarchy different cache block sizes means data located different ways 
ccmalloc focuses cache blocks 
system sun ultrasparc cache blocks bytes blocks bytes severely limits number objects fit block 
bookkeeping overhead allocator inversely proportional size cache block larger blocks successful incur overhead 
important issue allocate new data item cache block full 
ccmalloc tries put new data item close existing item possible 
putting items virtual memory page reduce program working set improve tlb performance exploiting strong hint programmer items accessed 
putting page ensures conflict cache 
possible strategies select block page 
closest strategy tries allocate new element cache block close existing block possible 
new block strategy allocates new data item unused cache block optimistically reserving remainder block calls ccmalloc 
fit strategy uses fit policy find cache block sufficient empty space 
section evaluates strategies 

evaluation cache conscious data placement evaluate cache conscious placement techniques combination microbenchmark large real world applications 
addition performed detailed cycle cycle simulations benchmarks olden suite break time spent 
microbenchmark performed large number random searches different types balanced trees 
macrobenchmarks line ray tracing program line formal verification system 
olden benchmarks variety pointer applications written methodology ran benchmarks sun contained mhz ultrasparc processors gb memory running solaris 
system levels blocking cache kb direct mapped data cache byte lines mb direct mapped cache byte lines 
data cache hit takes cycle 
data cache cache hit costs additional cycles ml 
typically results additional cycle delay ml 
benchmarks compiled gcc version optimization level run single processor 
main root ccmorph root node num nodes max kids cache sets cache blk size cache associativity color const 
quadtree node quadtree node int valid values 
max kids switch case return node parent case return node nw case return node ne case return node sw case return node se 
ccmorph transparent cache conscious data reorganization 
void struct list list struct patient patient struct list list null list list list forward list struct list ccmalloc sizeof struct list list patient patient list back list forward null forward list 
ccmalloc cache conscious heap allocation 
tree microbenchmark microbenchmark measures performance ccmorph large binary search tree call transparent tree 
compare performance core tree colored reduce cache conflicts random depth clustered binary trees 
microbenchmark perform insertions deletions 
tree contained keys consumes mb memory times cache size 
cache block size bytes capacity bytes provides practically clustering reuse rate close 
measured average search time randomly selected element varying number repeated searches 
shows trees transparent trees outperform randomly clustered binary trees factor depth clustered binary trees factor 
transparent trees outperform factor 
reason trees reserve extra space tree nodes handle insertion gracefully manage cache space efficiently transparent trees 
expect trees perform better transparent trees change due insertions deletions 
macrobenchmarks studied impact cache conscious data placement real world applications 
radiance tool modeling distribution visible radiation illuminated space 
input dimensional geometric model space 
radiosity equations ray tracing produces map spectral radiance values color image 
radiance primary data structure octree represents scene modeled 
structure highly optimized 
program uses implicit knowledge structure layout eliminate pointers implicit heap lays structure depth order consequently sense ccmalloc 
binary tree microbenchmark 

radiance vis applications 
actual execution times bar 
case 
changed octree subtree clustering colored data structure reduce cache conflicts 
performance results includes overhead restructuring octree 
vis verification interacting synthesis system formal verification synthesis simulation finite state systems 
vis synthesizes finite state systems verifies properties systems verilog descriptions 
fundamental data structure vis multi level network latches combinational gates represented binary decision diagrams bdds 
bdds dags ccmorph 
modified vis ccmalloc allocator new block strategy consistently performed see section 
shows results 
cache conscious clustering coloring produced speedup radiance cache conscious heap allocation resulted speedup vis 
result vis demonstrates cache conscious data placement improve performance graph data structures data elements multiple parents 
significantly changes line programs produced large performance improvements 
addition modifications vis accomplished hours little understanding application 
olden benchmarks performed detailed cycle cycle uniprocessor simulations olden benchmarks 
execution driven simulator models dynamically scheduled processor similar mips 
aggressive memory hierarchy includes non blocking pipelined cache non blocking pipelined cache 
table contains simulation parameters 
table describes olden benchmarks 
simulator perform detailed comparison semi automated cache conscious data placement implementations ccmorph clustering clustering coloring ccmalloc clos est fit new block strategies latency reducing schemes hardware prefetching prefetching loads stores currently reorder buffer software prefetching implement luk mowry greedy prefetching scheme hand 
shows results 
execution times normalized original unoptimized code 
commonly applied approach attribute execution delays various causes 
cycle processor retires maximum number instructions cycle counted busy time 
cycle charged stall time component corresponding instruction retired 
perimeter create pointer structures trees program start subsequently modify 
cache conscious data placement improves performance gain structure elements created dominant traversal order produces natural layout 
cache conscious data placement implementations outperform hardware prefetching competitive software prefetching outperform table simulation parameters 
issue width functional units int fp addr 
gen branch integer multiply divide cycles integer cycle fp divide square root cycles fp cycles reorder buffer size branch prediction scheme bit history counters branch prediction buffer size data cache kb direct mapped dual ported write write buffer size cache kb way set associative write back cache line size bytes hit cycle cycles cycles outstanding misses table benchmark characteristics 
name description main structures input data set memory allocated sums values stored tree nodes binary tree nodes mb health simulation health care system doubly linked lists max 
level max 
time kb mst computes minimum spanning tree graph array singly linked lists nodes kb perimeter computes perimeter regions images quadtree image mb software hardware prefetching perimeter 
ccmalloc new block allocation policy requires memory closest fit allocation policies perimeter respectively primarily due leaf nodes allocated new cache blocks 
health primary data structure linked lists elements repeatedly added removed 
cache conscious version periodically invoked ccmorph reorganize lists attempt determine optimal interval invocations 
despite overhead ccmorph significantly outperformed software hardware prefetching 
surprisingly ccmalloc new block allocation strategy left space cache blocks add new list elements outperformed allocators cost additional memory 
mst primary data structure hash table uses chaining collisions 
constructs structure program start change program execution 
health ccmalloc new block allocator ccmorph significantly outperformed schemes 
ccmorph coloring impact lists short 
short lists locality lists incorrect placement incurs high penalty 
ccmalloc new block allocator significantly outperformed fit closest allocation schemes cost extra memory 
summary ccmorph outperformed hardware software prefetching schemes benchmarks resulting speedups base case prefetching 
exception ccmalloc new block allocation strategy produced speedups prefetching 
addition ccmalloc new block allocator compares favorably allocations schemes low memory overhead exception perimeter 
confirm performance improvement merely artifact ccmalloc implementation ran control experiment replaced ccmalloc parameters null pointers 
resulting programs performed worse base versions system malloc 
discussion table summarizes trade offs cache conscious data placement techniques 
incorrect ccmorph affect program correctness ccmalloc affect program performance 
addition techniques focus single data structures 
real programs course multiple data structures structure 
techniques applied structure turn improve performance 
consider interactions different structures 
cache conscious structure layout techniques place contemporaneously accessed elements cache block 
improve uniprocessor cache performance multiprocessor systems depends data items accessed processor different processors 
case locating data elements exacerbate false sharing 

analytic framework cache conscious data placement techniques improve structure spatial temporal locality description ad hoc 
framework section addresses difficulty quantifying performance advantage 
framework permits priori estimation benefits techniques 
intended estimate cache performance data structure compare relative performance structure cache conscious counterpart 
addition pro 
performance cache conscious data placement 
base hp prefetch sp prefetch fa fit allocator ca closest allocator cl clustering cl col clustering coloring na new block allocator ccmalloc ccmorph table summary cache conscious data placement techniques 
technique data structures program knowledge architectural knowledge source code modification performance cc design universal high high large high ccmorph tree moderate low small moderate high ccmalloc universal low small moderate high vides intuition understanding impact data layout cache performance 
key part framework data structure centric cache model analyzes behavior series accesses traverse pointer paths pointer data structures 
pointer path access multiple elements data structure traversing pointers 
examples searching element tree traversing linked list 
details concrete applies analytic framework predict steady state performance cache conscious trees 
analytic model level blocking cache configuration expected memory access time pointer path access core data structure memory ml ml memory level cache access time rates level level caches respectively ml ml penalties level level caches respectively cache conscious data structure minimize memory access time 
penalties determined hardware design layout data structure attempt minimize rate 
develop simple model computing data structure rate 
pointer path access data structure multiple structure elements represent rate th pointer path access structure 
sequence pointer path accesses structure define amortized rate long random sequence pointer path accesses amortized rate shown approach steady state value fact limit exists pathological sequence values 
define amortized steady state rate examine amortized rate cache configuration cache capacity sets cache block size words cache associativity 
consider data structure consisting homogenous elements subjected random sequence pointer path accesses type 
pointer path access function represents average number unique required access element structure 
depends data structure type pointer path access pointer path accesses type additionally depends distribution different access types 
example log key search balanced binary search tree 
size individual structure element number structure elements fit cache block 
represent average number structure elements residing cache block required current pointer path access 
measure data structure spatial locality access function definition follows represent number elements data structure required current pointer path access cache prior accesses 
number elements reused th pointer path access measure data structure temporal locality 
definition follows definitions rate single pointer path access written number cache misses total reuse function highly dependent small values initially data structure suffers cold start misses 
interested steady state performance data structure start misses eliminated 
data structure colored reduce cache conflicts see section approach constant value steady state reached 
independent amortized steady state rate data structure approximated amortized rate large random sequence pointer path accesses type follows equation analyze steady state behavior pointer data structure previous equation analyze transient start behavior 
speedup analysis model derive equation speedup terms lim min arg cache conscious speedup naive naive cc cc 
cache conscious speedup 
cache rates results applying cache conscious techniques pointer data structure metric desirable speedup meaningful cache rate easier measure 
cache conscious speedup memory naive memory cache conscious structure layout changed number memory remains equation reduces 
worst case pointer path accesses data structure laid naively cache block contains single element reuse prior accesses naive naive 
steady state performance analysis section demonstrates calculate steady state performance cache conscious tree see section subjected series random key searches 
consider balanced complete binary tree nodes 
size node words 
cache block size words nodes clustered cache block 
subtrees size nodes fit cache block 
tree colored top nodes tree map uniquely sets cache conflicts remaining nodes tree map sets cache divisions cache possible 
coloring subtree clustered binary trees ensures steadystate top nodes cache 
binary tree search examines log nodes worst case random searches large tree approximate log nodes hit cache remaining nodes subtrees size nodes clustered cache blocks single cache block transfer brings log nodes needed current search 
number tree searches large ignore start behav ior approximate data structure performance amortized steady state rate shown 
comparing steady state rate equation get log log 
result indicates cache conscious trees logarithmic spatial temporal locality functions intuitively appear best attainable access function logarithmic 
model validation section validates model predictions performance improvement 
experimental setup see section 
tree microbenchmark experiments repeated searches randomly generated keys tree section 
apply model predict performance advantage transparent trees subtree clustering coloring naive counterpart 
experiments subtrees size clustered single cache block tree nodes half cache capacity nodes fit page colored unique portion cache 
tree size increased nodes 
results shown 
graph shows model predictive power underestimating actual speedup accurately predicting shape curve 
reasons systematic underestimation lower cache rate assumed tlb performance improvements captured model 

related previous research attacked processor memory gap reordering computations increase spatial temporal locality 
focused regular array accesses 
gan 
cache conscious binary tree 
log log log log log log log 
predicted actual speedup trees 
non studied exhaustive approach generated permutations loop nest selected best evaluation function 
wolf lam developed loop transformation theory unimodular matrix transformations heuristic select best combination loop transformations 
carr simple model spatial temporal reuse cache lines select compound loop transformations 
considers entirely different class data structures 
structures support random access chang ing program access pattern impossible general 
database researchers long ago faced similar performance gap main memory disk speeds 
designed specialized data structures trees bridge gap 
addition databases clustering compression improve virtual memory performance 
clustering improve virtual memory performance smalltalk lisp systems reorganizing data structures garbage collection 
seidl zorn combined profiling variety different information sources time object allocation predict object frequency lifetime 
showed program heap objects highly predictable 
studies focused program paging behavior cache behavior 
differs vast difference cost cache page fault cache blocks far smaller memory pages 
chilimbi larus generational garbage collector implement cache conscious data placement 
collect low overhead real time profiling information data access patterns applied new copying algorithm uses information produce cache conscious object layout 
relies properties object oriented programs requires copying garbage collection focuses programs 
chilimbi describes techniques structure splitting field reorganization structure definition demonstrates performance improvements java 
truong suggest field reorganization structures 
works complement concerned improving cache performance data structure reorganizing internal layout orthogonal techniques improve performance arranging collections structures 
calder applied placement techniques developed instruction caches data 
approach creates address placement stack local variables global variables heap objects constants order reduce data cache misses 
technique requires training run gather profile data shows little improvement heap objects significant gains stack objects globals 
contrast provide tools cache conscious heap layout produce significant improvement profiling 
addition entirely different allocation strategy history previously allocated object programmer supplied hint ccmalloc uses locate objects 
researchers empirical models program behavior analyze cache performance 
efforts tailor analysis specific cache parameters limits scope 
exceptions agarwal comprehensive cache model singh model 
agarwal model uses large number parameters appear require measurements calibrate 
provides performance validation shows model predictions quite accurate 
model complexity large number parameters difficult gain insight impact different cache parameters performance 
singh presents technique calculating cache rate fully associative caches mathematical model workload behavior 
technique requires fewer parameters agarwal model measurements appear necessary calibrate 
model predictions accurate large fully associative caches small caches 
hill proposed simple model classifies cache misses categories compulsory capacity conflict 
model provides intuitive explanation causes cache misses lacks predictive power 
models focus analyzing predicting program cache performance focus cache performance individual core pointer structures 
lam developed theoretical model data conflicts cache analyzed implications blocked array algorithms 
showed cache interference highly sensitive stride data accesses size blocks result wide variation performance different matrix sizes 
cache model captures loop nests access arrays regular manner model focuses series pointer path accesses core pointer data structures 
lamarca ladner explored interaction caches sorting algorithms 
addition constructed cache conscious heap structure clustered aligned heap elements 
collective analysis models algorithm behavior direct mapped caches obtains accurate predictions 
framework relies independence assumption algorithm centric data structure centric specifically targets correlations multiple accesses data structure 

traditionally core pointer data structures designed programmed memory access costs uniform 
increasingly expensive memory hierarchies open opportunity achieve significant performance improvements redesigning data structures caches effectively 
techniques clustering coloring improve spatial temporal locality pointer data structures applying existing codes may require considerable effort 
shows cache conscious techniques packaged easy tools 
structure ccmorph cache conscious memory allocator ccmalloc greatly reduce programming effort application knowledge required improve cache performance 
cache conscious structure layout tools described fairly automated require programmer assistance identify tree structures moved suitable candidates cache block location 
explore directions reduce amount programmer effort static program analyses profiling 
believe compilers run time systems help close processor memory performance gap 

authors thomas ball brad calder bob fitzgerald anoop gupta thomas reps anonymous referees useful comments 
research supported nsf nyi award ccr support sun microsystems nsf mip 

agarwal horowitz hennessy 
analytical cache model 
acm transactions computer systems 
aho denning ullman 
principles optimal page replacement 
journal acm 
banerjee kim 
clustering dag cad databases 
ieee transactions software engineering 
bayer mccreight 
organization maintenance large ordered indexes 
acta informatica 
benzaken claude delobel 
enhancing performance persistent object store clustering strategies 
technical report aug 
brayton vincentelli somenzi aziz cheng edwards pardo qadeer ranjan villa 
vis system verification synthesis 
proceedings international conference computer aided verification july 
doug burger james goodman alain 
memory bandwidth limitations microprocessors 
proceedings rd annual international symposium computer architecture pages may 
brad calder chandra john todd austin 
cache conscious data placement 
proceedings international conference architectural support programming languages operating systems asplos viii pages oct 
david callahan ken kennedy allan 
software prefetching 
proceedings fourth international conference architectural support programming languages operating systems asplos iv pages april 
steve carr kathryn mckinley chau wen tseng 
compiler optimizations improving data locality 
proceedings sixth international conference architectural support programming languages operating systems asplos vi pages oct 
chilimbi james larus 
generational garbage collection implement cache conscious data placement 
proceedings international symposium memory management oct 
chilimbi bob davidson james larus 
cache conscious structure definition 
proceedings acm sigplan conference programming language design implementation may 
douglas comer 
ubiquitous tree 
acm computing surveys 
courts 
improving locality garbage collecting memory management system 
communications acm 
drew king 
performance utility implementation algorithms 
proceedings th vldb conference pages 
dennis gannon william jalby gallivan 
strategies cache local memory management global program transformation 
journal parallel distributed computing 
blackwell smith calder 
procedure placement temporal ordering information 
proceedings micro dec 

cache hit ratios geometric task switch intervals 
proceedings th annual international symposium computer architecture pages june 
mark hill alan jay smith 
evaluating associativity cpu caches 
ieee transactions computers december 
david 
lockup free instruction fetch prefetch cache organization 
th annual international symposium computer architecture pages may 
lam wilson moher 
object type directed garbage collection improve locality 
proceedings international workshop memory management pages sept 
monica lam edward rothberg michael wolf 
cache performance optimizations blocked algorithms 
proceedings fourth international conference architectural support programming languages operating systems pages santa clara california 
anthony lamarca richard ladner 
influence caches performance heaps 
acm journal experimental algorithmics 
anthony lamarca richard ladner 
influence caches performance sorting 
annual symposium discrete algorithms jan 
james laudon anoop gupta mark horowitz 
interleaving multithreading technique targeting multiprocessors workstations 
proceedings sixth international conference architectural support programming languages operating systems pages san jose california 
chi luk todd mowry 
compiler prefetching recursive data structures 
proceedings seventh international conference architectural support programming languages operating systems asplos vii pages oct 
scott mcfarling 
program optimization instruction caches 
proceedings third international conference architectural support programming languages operating systems pages 
moon 
garbage collection large lisp system 
conference record symposium lisp functional programming pages aug 
todd mowry monica lam anoop gupta 
design evaluation compiler algorithm prefetching 
proceedings fifth international conference architectural support programming languages operating systems asplos pages october 
pai ranganathan adve 
manual version technical report dept electrical computer engineering rice university aug 
pai ranganathan adve 
evaluation memory consistency models shared memory systems ilp processors 
proceedings seventh international conference architectural support programming languages operating systems asplos vii pages oct 
david patterson thomas anderson neal cardwell richard kimberly randi thomas katherine 
case intelligent ram 
ieee micro pages apr 
sharon perl richard sites 
studies windows nt performance dynamic execution traces 
second symposium operating systems design implementation oct 
karl pettis robert hansen 
profile guided code positioning 
sigplan notices june 
pro ceedings acm sigplan conference programming language design implementation 
rao 
performance analysis cache memories 
journal acm 
rogers carlisle reppy hendren 
supporting dynamic data structures distributed memory machines 
acm transactions programming languages systems 
rosenblum bugnion herrod witchel gupta 
impact architectural trends operating system performance 
proceedings th acm symposium operating system principles sosp pages dec 
roth sohi 
dependence prefetching linked data structures 
proceedings international conference architectural support programming languages operating systems asplos viii pages oct 
saltzer 
simple linear model demand paging performance 
communications acm 
seidl zorn segregating heap objects behavior lifetime 
proceedings international conference architectural support programming languages operating systems asplos viii pages oct 
pal singh harold stone dominique 
model workloads rate prediction fully associative caches 
ieee transactions computers 
smith 
comparative study set associative memory mapping algorithms cache main memory 
ieee trans 
software engineering 
alan smith 
cache memories 
acm computing surveys 
burton smith 
architecture applications hep multiprocessor computer system 
real time signal processing iv pages 
editor 
program behavior models measurements 
operating programming system series elsevier new york 
stamos 
static grouping small objects enhance performance paged virtual memory 
acm transactions programming languages systems 
dan truong francois andre 
improving cache behavior dynamically allocated data structures 
international conference parallel architectures compilation techniques oct 
naughton 
performance object clustering techniques 
proceedings acm sigmod intl 
conf 
management data pages june 
ward 
radiance lighting simulation rendering system 
proceedings siggraph july 
wilkes 
slave memories dynamic storage allocation 
ieee trans 
electronic computers pages april 
paul wilson michael lam thomas moher 
effective static graph reorganization improve locality garbage collected systems 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
michael wolf monica lam 
data locality optimizing algorithm 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
