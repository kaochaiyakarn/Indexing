term rewriting traversal functions mark van den brand paul klint jurgen centrum voor wiskunde en informatica term rewriting appealing technique performing program analysis program transformation 
tree term traversal frequently supported standard term rewriting 
extend sorted order term rewriting traversal functions automate tree traversal simple type safe way 
traversal functions bottom top traversals traverse nodes tree traversal certain depth soon matching node 
define sort preserving transformations mappings fixed sort 
give small somewhat larger examples traversal functions describe operational semantics implementation 
assessment various applications discussion conclude 
categories subject descriptors programming techniques applicative functional programming programming languages language constructs features polymorphism recursion general terms algorithms languages additional key words phrases automated tree traversal term rewriting types 
background program analysis program transformation usually take syntax tree program starting point 
operations tree expressed ways ranging imperative object oriented programs attribute grammars rewrite systems 
common problem encounters express traversal tree visit nodes tree extract information nodes changes certain nodes 
kinds nodes may appear program syntax tree determined grammar language program written 
typically rule grammar corresponds node category syntax tree 
real life languages described grammars containing grammar productions 
immediately reveals hurdle writing tree traversals naive recursive traversal function consider node categories size definition grow accordingly 
dramatic realize traversal function real apart traversing authors address centrum voor wiskunde en informatica cwi software engineering department kruislaan sj amsterdam netherlands mark van den brand cwi nl paul klint cwi nl jurgen cwi nl permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions computational logic vol 

january pages 
van den brand node categories 
problem asks form automation takes care tree traversal human programmer concentrate node categories real done 
stated differently looking generic way expressing tree traversals 
previous experience brand brand klint know term rewriting convenient scalable technology expressing analysis transformation renovation individual programs complete software systems 
main reasons term rewriting provides implicit tree pattern matching easy find patterns program code 
programs easily manipulated transformed term rewriting 
term rewriting rule easy combine sets rules 
efficient implementations exist apply rewrite rules millions lines code matter minutes 
aim enhancing term rewriting analysis transformation software systems address question tree traversals added term rewriting paradigm 
important requirement typed design automated tree traversals terms formed 
requirement simplicity design 
important properties sorted order term rewriting want preserve 
plan remainder discuss general issues tree traversal section briefly recapitulate term rewriting section discuss traversal functions necessary term rewriting section explain term rewriting extended section discuss related section 
section traversal functions asf sdf bergstra deursen give various examples 
larger examples traversal functions section 
operational semantics traversal functions section implementation issues considered section 
section describes experience traversal functions section gives discussion 
issues tree traversal simple tree traversal possible goals transforming tree replacing certain control structures goto structured statements statements 
extracting information tree counting goto statements 
extracting information tree simultaneously transforming extracting declaration information applying perform constant folding 
course simple tree traversals combined complex ones 
acm transactions computational logic vol 

january 
topdown bottomup term rewriting traversal functions continue break fig 

traversal cube principal ways traversing tree 
goal traversal achieved visiting tree nodes certain visiting order applying rewrite rule node 
general properties tree traversal shown traversal cube 
vertical axis distinguish standard visiting orders top order root sub trees bottom order sub trees root 
note binary trees shown example way visiting node called order order sub tree root sub tree 
target arbitrary tree structures consider special case 
second horizontal axis distinguish traversals break recursion specific nodes traversals continue nodes visited 
right half breaks occur nodes 
third depth axis distinguish direction traversal visiting nodes left right right left 
possibilities traversal cube obvious candidates abstraction automation 
focus front plane cube left right traversals prominently application areas interested 
extension complete cube straightforward 
tree traversal rewrite rule applied nodes achieve intended effect traversal 
type traversal function depends type input nodes nodes untyped 
case instance lisp prolog 
ease manipulation provided expense type safety 
nodes typed tree homogeneous nodes order called post order art computer programming volume knuth nowadays post order indicate called order book 
acm transactions computational logic vol 

january 
van den brand type 
case instance java nodes tree represented single tree node data type 
untyped nodes homogeneous trees manipulated easily combination nodes typed 
nodes typed tree heterogeneous nodes may different types 
case instance java separate data type introduced representing construct grammar declaration node statement node node forth 
focus traversal typed heterogeneous trees 
various aspects traversal functions discussed type result value 
type arguments 
result traversal function depend current node visited information stored deeper nodes information global state 
obviously tree traversals heavily influenced type system programming language expressed 
brief recapitulation term rewriting basic insight term rewriting important understanding traversal functions 
give brief recapitulation innermost term rewriting 
full account see 
term prefix expression consisting constants variables function applications 
simplicity view constants nullary functions 
closed term ground term term variables 
rewrite rule pair terms 
may contain variables provided variable occurs 
term matches term structurally equal modulo occurrences variables matches results binding bound 
variable occurs term called non left linear pattern values matched occurrence required equal 
bindings resulting matching substitution replace variables term values bound 
ground term set rewrite rules purpose rewrite rule interpreter find sub term reduced called redex 
sub term matches left hand side rule bindings resulting match substituted yielding 
replaced search new redex continued 
rewriting stops new redex say term normal form 
accordance tree traversal orders described earlier different methods selecting redex may yield different results 
limit attention leftmost innermost rewriting redex searched left right bottom fashion 
note innermost rewriting corresponds call value programming language acm transactions computational logic vol 

january 
algorithm interpreter innermost rewriting 
function match term term bindings match function substitute term bindings term function innermost term rules list rule term var children children list term var child reduct term var fn function symbol term rewriting traversal functions decompose term fn children children nil foreach child children children append children innermost child rules od compose term fn children reduct reduce rules return reduct fail reduct fi function reduce term rules list rule term var rule var left right term foreach rules decompose rule left right var bindings match left match return innermost substitute right rules fi od return fail operation rewrite rule interpreter shown detail algorithm 
functions match substitute defined meaning just sketched 
show signature 
terms composed top function symbol list children decomposed separate parts 
example fn value function name children value list terms compose term fn children yield term 
decompose works similar fashion allows structured term patterns 
example decompose term fn child children result assignments fn child children 
rules composed left hand side right hand side 
decomposed obtain distinct parts 
underlying term representation typed untyped 
compose decompose functionality functions match substitute take aspect account 
append function append element list 
observe function innermost reduces children current term attempting reduce term 
realizes bottom traversal term 
note reduction term fails returns result 
function reduce performs possible reduction step 
searches rules acm transactions computational logic vol 

january 
van den brand module tree syntax imports naturals exports sorts tree context free syntax nat tree tree tree tree tree tree tree tree tree tree variables nat tree module tree trafo imports tree syntax equations fig 

sdf grammar simple tree language 
fig 

example equation 
matching left hand side bindings resulting successful match substituted corresponding right hand side 
modified righthand side reduced innermost rewriting 
section extend algorithm cover traversal functions 
presentation term rewriting focused features essential understanding traversal functions 
features instance conditional rules various forms conditions equality inequality matching conditions list matching left 
actual implementation section course taken care 
traversal functions term rewriting 
rewrite rules convenient express transformations trees may wonder traversal functions needed 
clarify way simple trees containing natural numbers 
displays sdf grammar heering simple tree language 
leafs natural numbers nodes constructed binary constructors note numbers sort nat embedded trees sort tree due production nat tree 
corresponds chain rule context free grammar 
grammar defines variables natural numbers 
trees 
transformations trees defined easily 
instance want replace occurrences single equation shown suffices 
applying rule term leads normal form steps innermost reduction acm transactions computational logic vol 

january 
module tree trafo imports tree syntax equations term rewriting traversal functions fig 

example equation 
similarly want replace sub trees form achieve single rule shown 
apply rule get normal form step note cases standard innermost reduction order rewriting system takes care complete traversal term 
elegant approach severe limitations want combined effect rules get unpredictable results rules interfere combined rewrite system said non confluent 
applying rules sample term may lead steps depending applied reduction step 
observe interpreter shown algorithm select rule produce single result 
second problem rewrite rules access context information term matches left hand side rewrite rule 
especially program transformation restrictive 
thirdly ordinary typed term rewriting type preserving rewrite rules allowed type left hand side rewrite rule equal type right hand side rule 
sub terms replaced sub terms type enforcing complete term remains typed 
way express non type preserving traversals interpretation analysis term 
cases original type integer expressions type exp translated values type integers type int 
common solution problems introduce new function symbols eliminate interference rules 
example introduce functions trafo trafo explicitly control outcome combined transformation order apply trafo trafo initial term 
introducing extra function symbols gain ability pass data extra parameters functions 
function symbols allow express non type preserving transformations explicitly typing function accept type yield 
proposed change specification style yield semantically equivalent rewriting system general 
practical style specifications reasons 
introducing new function symbols limitations rewrite rules solved 
main side approach loose built facility innermost rewriting traverse input term explicit effort acm transactions computational logic vol 

january 
van den brand module tree trafo imports tree syntax exports context free syntax trafo tree tree trafo tree tree equations trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo trafo fig 

definition trafo trafo 
programmer 
extra rewrite rules needed define traversal trafo trafo input term shown 
observe equations correspond original equations respectively 
equations just needed define tree traversal 
defining traversal rules requires explicit knowledge productions grammar case definitions 
example number rules function directly related size tree language 
large grammars clearly undesirable 
extending term rewriting traversal functions take sorted order term rewriting language point departure 
suppose want traverse syntax trees programs written language described grammar consisting grammar rules 
typical tree traversal described usually rewrite rules covering possible constructors may encountered traversal syntax tree 
value largely depends structure grammar specific traversal problem 
typically significant subset constructors needs traversed get point interest resulting tens hundreds rules written large grammar specific transformation analysis 
question avoid writing rewrite rules 
general approaches problem 
higher order term rewriting 
solution higher order term rewriting huet lang felty heering 
allows writing patterns context certain language construct captured higherorder variable eliminating need explicitly handle constructs occur context 
refer heering simple example higherorder term rewriting 
higher order term rewriting powerful mechanism acm transactions computational logic vol 

january 
term rewriting traversal functions avoid expressing entire tree traversals 
introduces complex semantics implementation issues 
solve non confluence problems discussed earlier see section 
observation traversal done matching match sub terms traversed 
expensive 
generic traversal strategy primitives extend rewriting language set generic traversal strategy primitives basic operators enable formulation arbitrary tree traversals 
primitives instance traversal sub trees node sequential composition choice repetition traversals 
selectively apply rewrite rule location term 
generic traversal primitives separate application rewrite rule traversal tree advocated strategic programming 
see instance visser survey strategic programming area program transformations 
genericity provided generic traversals hard handle conventional typing systems visser mmel 
reason type traversal primitive completely independent structures traverse 
mmel proposal typing system generic traversal primitives discuss section 
having types relevant static type checking program documentation program comprehension 
beneficial efficient implementation optimization 
ordinary typed term rewriting type preserving rewrite rules allowed type left hand side rewrite rule equal type right hand side rule 
sub terms replaced subterms type enforcing complete term remains typed 
type checking order sorted term rewriting system simply boils checking sides rewrite rule yield type checking sides formed respect signature 
traversal functions 
approach allow functions traverse tree automatically set built traversal primitives 
terminology functions called traversal functions 
solve problem extra rules needed term traversal loosing practical abilities functions carry data having non sort preserving transformations 
extending ordinary term rewriting traversal functions type system remain 
provide primitives allow type preserving class non type preserving traversals type safe manner changing type checker language 
related directly related 
classify directly related approaches discuss 
elan borovansk language sorted order rewrite rules extended strategy language controls application individual rewrite rules 
strategy primitives don know choice don care acm transactions computational logic vol 

january 
van den brand table classification traversal approaches 
untyped typed strategy primitives stratego visser elan borovansk built strategies renovation factories brand traversal functions txl cordy choice allow formulating non deterministic computations 
currently elan support generic tree traversals easily fitted elan type system 
stratego visser untyped term rewriting language provides userdefined strategies 
strategy primitives rewrite rules generic strategy operators sequential composition choice repetition allow definition tree traversal top bottomup manner 
tree traversals class objects reused separately rewrite rules 
stratego provides library kinds named traversal strategies instance bottomup topdown innermost 
transformation factories brand approach asf sdf rewrite rules generated language definitions 
generation phase user instantiates actual transformation providing name transformation updating default traversal behavior 
note generated rewrite rules typed general types obtain reusability generated rewrite rules 
transformation factories provide kinds traversals transformers analyzers 
transformer transforms node visits 
analyzer combination traversal combination function default value 
generated traversal function reduces node default value user overrides 
combination function combines results innermost manner 
simulation higher order behavior leads general types 
txl cordy txl typed language transformational programming cordy 
asf sdf permits definition arbitrary grammars rewrite rules transform parsed programs 
txl form term rewriting terminology notation deviate standard term rewriting parlance 
txl renovation projects 
discussion 
traversal functions emerged experience writing program transformations real life languages asf sdf 
stratego transformation factories offer solutions remedy problems encountered 
stratego extends term rewriting traversal strategy combinators userdefined strategies 
conservative extend order term rewriting fixed set traversal primitives 
contribution traversal functions provide simple type safe approach tree traversals order specifications 
result simple statically type checked trivial manner implemented efficiently 
side approach allow adding new traversal orders simulated acm transactions computational logic vol 

january 
term rewriting traversal functions built traversal orders 
see klint discussion relative merits approaches 
mmel type system tree traversals proposed 
traversal combinators stratego 
typing system attractive ways complicated approach 
generic types added order type system type preserving tp type unifying tu strategies 
mediate generic types normal types extra combinator offered combines type guard type lifting operator 
extending type system needed traversal function approach tree traversal joined functional effect single traversal function 
allows interpreter compiler deal type safe traversal user intervention 
case traversal functions mmel traversal types divided type preserving effects mappings single type 
tupled combination offered 
compared transformation factories directly inspired traversal functions provide slightly different set traversal functions reduce notational overhead 
important provide fully typed approach 
level implementation generate asf sdf rules incorporated traversal functions standard interpreter compiler asf sdf 
result execution efficient specifications readable users confronted generated rewrite rules 
developed completely independently approach common txl provides type safe term traversal 
txl rules apply pre order search term looking pattern 
matching subterms replacement performed 
txl rules comparable topdown transformers 
difference transformers perform pass term visit transformed subtrees 
txl rules visit transformed subtrees 
cases renaming variables program special measures needed avoid undesired repeated transformations 
txl jargon traversal functions pass rules 
txl support accumulators notion global variables collect information traversal 
useful txl feature support ability skip subterms certain types traversal 
related 
apart directly related mentioned briefly mention related functional languages object oriented languages attribute grammars 
functional languages 
prototypical traversal function functional setting functions map fold relatives 
map takes tree function argument applies function node tree 
problems arise soon heterogeneous trees traversed 
solution problem fold algebras described mmel language definition traversal functions generated haskell 
tool generates generic folding algebraic types 
folds updated user 
way introducing generic traversals functional setting described mmel visser 
acm transactions computational logic vol 

january 
van den brand object oriented languages 
traversal arbitrary data structures captured visitor design pattern described gamma 
typically fixed traversal order provided framework default behavior node kind 
default behavior overruled node kind 
implementation visitor pattern kuipers visser tool generates java class structures sdf language definitions 
generated classes implement generic tree traversals overridden user 
technique related generating traversals language definitions transformation factories tailored profits object oriented programming paradigm 
visser approach generalized traversal combinators 
attribute grammars 
approaches described far provide operational view tree traversals 
attribute grammars provide declarative view extend syntax tree attributes attribute equations define relations attribute values 
attributes get values solving attribute equations achieved traversals tree 
attribute grammars tree traversal issue implementation user 
attribute grammars convenient expressing analysis tree limitation tree transformations easily expressed 
higher order attribute grammars vogt remedy limitation certain extent 
new tree constructed attributes passed ordinary tree higher order attribute function 
combining attribute grammars object orientation 
magnusson field combining attribute grammars visitors class weaving 
attribute values attributes may nodes tree 
implicit tree traversal mechanism attribute evaluation combined explicit traversal visitors 
convenient analysis purposes solve problems posed program transformations 

traversal functions asf sdf want automate tree traversal sorted order term rewriting 
traversal functions context language asf sdf bergstra deursen approach applied term rewriting language 
prior knowledge asf sdf required explain language need arises 
reason choosing asf sdf known language term rewriting community supported interactive development environment widely available addition industrial applications test cases language extensions 
asf sdf uses context free syntax defining signature terms 
result terms written arbitrary user defined notation 
means functions free notation move move complete text programs represented 
www cwi nl projects acm transactions computational logic vol 

january 
term rewriting traversal functions context free syntax defined sdf terms rewrite rules defined asf purpose features asf relevant sorted typed terms 
unconditional conditional rules 
conditions comparisons terms come flavors equality terms inequality terms called assignment conditions introduce new variables 
flavors new variables may introduced side 
form side condition may contain new variables bound matching pattern side condition 
default rules tried rules fail 
terms normalized leftmost innermost reduction 
idea traversal functions follows 
programmer defines functions usual providing signature defining rewrite rules 
signature traversal function defined 
ordinary declaration explicitly labeled attribute traversal 
call labeled function traversal function user perspective automatically traverses term rewrite rules term traversal specified anymore provided automatically traversal attribute 
specification writer give rewrite rules nodes traversal function visit 
rewrite rules provided traversal attribute define traversal behavior rewrite rules provided user define visit behavior nodes 
innermost rewriting traversal function appears outermost function symbol redex function traverse redex reductions occur 
conceptually traversal function shorthand possibly large set rewrite rules 
traversal function set rewrite rules calculated implements traversal actual rewriting sub terms 
expanding traversal function set rewrite rules possible way defining semantics traversal functions pursue see brand 
continue discussion section type generic traversals 
question built traversals provide fully typed setting 
offer types traversal functions section types visiting strategies section discuss order 
section examples traversal functions 
merits limitations approach discussed section 
kinds traversal functions distinguish kinds traversal functions defined follows 
transformer sort preserving transformation declared 
sn traversal trafo syntax definition formalism 
algebraic specification formalism 
acm transactions computational logic vol 

january 
van den brand accumulator mapping single type declared 
sn traversal accu accumulating sort preserving transformation accumulates information si transformer declared 
sn traversal accu trafo transformer traverse argument 
possible extra arguments may contain additional data modified traversal 
transformer returns sort type safe 
transformer transform tree implements goal discussed section 
accumulator traverse argument second argument keeps accumulated value 
application accumulator accumulated argument updated 
application accumulator possibly term new value accumulated argument 
words accumulator acts global modifiable state traversal 
accumulator function changes tree changes accumulated argument 
furthermore type second argument equal result type 
result accumulator value accumulated argument 
restrictions accumulator type safe instantiation 
accumulator meant extract information tree implements goal discussed section 
accumulating transformer sort preserving transformation accumulates information traversing argument 
second argument maintains accumulated value 
return value accumulating transformer tuple consisting transformed argument accumulated value 
accumulating transformer simultaneously extract information tree transform 
implements goal discussed section 
transformers accumulators accumulating transformers may overloaded obtain visitors heterogeneous trees 
optional extra arguments carry information defining rewrite rules extract information children conditions 
express analysis transformation non local information easily 
visiting strategies having types traversals provided visiting strategies recall 
visiting strategies determine order traversal 
provide strategies type traversal bottom recur children try visit current node 
annotation bottom selects behavior 
top try visit current node traverse children 
annotation top selects behavior 
extra attribute strategies define traversals visit nodes tree 
add attributes select happen successful acm transactions computational logic vol 

january 
term rewriting traversal functions module tree trafo imports tree syntax exports context free syntax trafo tree tree traversal trafo top continue trafo tree tree traversal trafo top continue equations tr trafo tr trafo trafo trafo fig 

trafo trafo top traversal functions 
module tree imports tree syntax exports context free syntax tree tree traversal trafo bottom continue equations visit 
fig 

transformer increments number tree 
break visiting nodes current branch successful visit 
corresponding annotation break 
continue continue traversal successful visit 
corresponding annotation continue 
transformer bottom strategy resembles standard innermost rewriting sort preserving bottom 
small rewriting system defined context transformer function 
difference transformer function reduction node innermost reduction normalizes node completely 
able break traversal powerful feature 
example allows user continue traversal certain conditions 
examples transformers subsections give trivial examples transformers accumulators accumulating transformers 
examples tree language introduced earlier 
section show elaborate examples 
trafo example revised 
recall definition transformations trafo trafo 
looked clumsy cluttered intention transformation completely 
shows express transformations traversal functions 
acm transactions computational logic vol 

january 
van den brand module tree imports tree syntax exports context free syntax tree nat tree traversal trafo bottom continue equations fig 

transformer increments number tree value 
module tree imports tree syntax exports context free syntax tree tree tree tree tree traversal trafo bottom continue equations fig 

transformer replaces occurrences observe rules resemble original rewrite rules 
significant difference rules corresponding function applied term 
increment numbers tree 
specification shows transformer purpose increment numbers occur tree 
better understand example follow traversal rewrite steps applying tree start application outermost node node visited left right bottom fashion 
rewrite rule activated identity transformation applied 
example naturals transformed nodes left unchanged 
increment numbers tree parameter 
specification shows transformer 
purpose increment numbers occur tree parameter value 
observe argument traversed second argument value carried acm transactions computational logic vol 

january 
term rewriting traversal functions module tree imports tree syntax exports context free syntax tree tree tree tree tree traversal trafo top continue equations fig 

transformer replaces occurrences module tree imports tree syntax exports context free syntax tree tree tree tree tree traversal trafo top break equations fig 

transformer replaces shallow occurrences module tree imports tree syntax exports context free syntax tree tree tree tree tree traversal trafo bottom break equations fig 

transformer replaces deep occurrences traversal 
follow traversal rewrite steps get replace function symbols 
common problem tree manipulation replacement function symbols 
context tree language want acm transactions computational logic vol 

january 
van den brand module tree sum imports tree syntax exports context free syntax sum tree nat nat traversal accu bottom continue equations sum sum fig 

accumulator sum computes sum numbers tree 
replace occurrences symbol new symbol replacement defined flavors 
show full replacement replaces occurrences shallow replacement replaces occurrences closest root tree deep replacement replaces occurrences closest leafs tree 
full replacement defined 
specified bottom traversal continues traversing reduction 
ensure nodes tree visited 
note case top strategy get result shown 
shallow replacement defined 
case traversal stops outermost occurrence break attribute 
case top strategy essential 
observe top traversal break attribute applies traversal function applicable outermost node visit sub trees node 
right hand side defining equation traversal function may contain recursive applications traversal function 
way traverse certain sub trees recursively avoiding explicitly 
combination bottom strategy break attribute define deep replacement shown 
soon rewrite rule applies certain node traversal visits nodes path reduced node root 
case bottom strategy essential 
examples accumulators far shown examples transformers 
section give examples accumulators 
add numbers tree 
problem want solve computing sum numbers occur tree 
accumulator sum solves problem 
note equation variable represents current node number variable represents sum accumulated far number 
count nodes tree 
second problem count number nodes occur tree 
accumulator cnt shown job 
acm transactions computational logic vol 

january 
term rewriting traversal functions module tree cnt imports tree syntax exports context free syntax cnt tree nat nat traversal accu bottom continue equations cnt cnt fig 

accumulator cnt counts nodes tree 
module tree pos imports tree syntax exports context free syntax pos tree nat tree nat traversal accu trafo bottom continue equations pos pos fig 

accumulating transformer pos multiplies numbers tree position 
examples accumulating transformers conclude series examples example accumulating transformer 
multiply position tree 
problem determine position number top traversal tree multiply number position 
achieved accumulating transformer pos shown 
general idea accumulate position number traversal multiplier transform numeric nodes 

larger examples give trivial applications traversal functions 
small imperative language pico syntax shown 
toy language pico originally introduced bergstra running example 
pico program consists declarations followed statements 
variables declared types natural number string 
kinds statements assignment statement 
assignment types left hand side right hand side equal 
statement statement condition type natural 
arguments numeric operators natural 
arguments string valued operator strings 
acm transactions computational logic vol 

january 
van den brand module pico syntax imports pico whitespace exports sorts program decls id type id decls stat stats exp sorts nat con str con lexical syntax id nat con str con context free syntax decls stats program declare id types decls id type id type natural string type id type id types id exp stat exp stats stats fi stat exp stats od stat stat stats id exp nat con exp str con exp exp exp exp left exp exp exp left exp exp exp left exp exp bracket context free priorities exp exp exp exp exp exp exp exp exp type checking fig 

sdf grammar small imperative language pico 
example defines type checker pico style described heering 
general idea reduce type correct programs empty program reduce programs containing type errors program contains erroneous statements 
achieved information declarations variables replace variable occurrences declared type replacing constants implicit type 
type correct statements removed program 
result type correct programs normalized empty program 
approach interesting perspective error reporting rewriting augmented origin tracking technique links back sub terms normal form sub terms initial term deursen 
way residuals type incorrect statements normal form traced back source 
see tip dinesh applications similar techniques 
example works follows 
necessary accommodate acm transactions computational logic vol 

january 
term rewriting traversal functions module pico typecheck imports pico syntax exports context free syntax type type id replace stats id type stats traversal trafo bottom break replace exp id type stats traversal trafo bottom break equations declare id type decl stat declare decl replace stat id type replace id id type type type replace nat con id type type natural replace str con id type type string type string type string type string type natural type natural type natural type natural type natural type natural stat type natural stat stat fi stat stat stat stat stat stat type natural stat od stat stat stat stat stat type type type type stat stat stat declare natural string abc fi fig 

type checker pico 
declare type string type natural replacement variables type words want replace type natural type natural assuming declared natural 
achieved extending syntax pico context free syntax rule type type id actual replacement variables declared type done transformer replace 
declared sorts equations replace defined case stats exp bottom breaking transformer 
second argument replace identifier type pair appears variable declaration 
note complex languages bottom breaking transformer sufficient 
example dealing nested scopes imperative type environment updated going new scope 
top breaking transformer case stops entrance new acm transactions computational logic vol 

january 
van den brand scope explicitly recurs scope updating type environment 
equation program containing non empty declaration section replaced new program declaration 
statements occurrences variable declared removed declaration replaced declared type 
replace specified equations 
simply replaces identifiers natural constants string constants type 
type correct expressions simplified equations 
type correct statements removed program equations 
result type correct program reduce empty program type incorrect program reduce simplified program precisely contains incorrect statements 
example shows incorrect statement sides assignment type reduced type string type natural 
traversal order top bottom replace matches leafs 
bottom break traversal efficient leaf visited ancestors visited anymore 
example shows traversal functions style type checking approach feasible larger languages 
equations associative matching called list matching asf sdf concisely express operations lists statements 
instance list variables stat stat represent statements surrounding statement stat represents list statements body statement 
right hand side equation lists statements concatenated effectively merging body statement surroundings 
inferring variable usage second example computes equivalence relation pico variables usage program 
technique known cardelli compiler optimization reverse engineering 
examples statically inferring variable types dynamically typed language smalltalk weakly typed language cobol deursen moonen 
analysis starts assumption input program correct 
usage program variables related putting equivalence class 
equivalence classes completed transitive closure 
variables type different purposes appear different classes 
way example distinguish integer variables dates integer variables account numbers 
specification notation introduced sets expressions set sets sets sets 
accumulator infer type declared collects identifier declarations expressions assignments puts separate equivalence classes represented sets 
expressed equations 
assignment statement generates new set consisting sides assignment 
expression generates new set 
equations acm transactions computational logic vol 

january 
term rewriting traversal functions module pico usage inference imports pico syntax exports sorts set sets context free syntax exp set set sets infer program sets sets traversal accu top break infer stat sets sets traversal accu top break infer exp sets sets traversal accu top break variables set set set set exp exp equations infer id exp set id exp set infer exp set exp set exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp set exp id exp set exp id exp set set exp id exp exp exp set set infer declare natural natural natural fi fig 

inferring variable usage pico programs 
equivalence sets simplified breaking complex expressions constituting operands 
equation computes transitive closure equivalence relation 
note equations list matching concisely express operations sets 
instance list variables exp exp exp match elements surround occurrences expression exp right hand side equation construct new list expressions contains single occurrence exp fact equation defines set defines sets 
shows example applying infer small program 
examples accumulating transformers leave examples accumulating transformers reader 
directions 
transformation side effects transformations acm transactions computational logic vol 

january 
van den brand state 
trivial example generate logfile transformation 
log entries added accumulated argument traversed argument transformed 
functionality split generating logfile doing transformation inevitably leads code duplication performance 
instance second scenario transformer assigns unique identification language constructs 
accumulated argument keep track identifications 
impossible split behaviour separate transformer accumulator 
algorithm interpreter transformers part 
function traverse trafo term rules list rule term var trfn function symbol var subject term var args list term decompose term trfn subject args return visit trfn subject args rules function visit trfn function symbol subject term args list term rules list rule term var subject reduct term traversal strategy trfn top subject reduce typed compose trfn subject args rules subject fail return visit children trfn subject args rules traversal continuation trfn break return subject reduct visit children trfn subject args rules return reduct fail subject reduct fi fi fi bottom subject visit children trfn subject args rules subject fail reduct reduce typed compose trfn subject args rules traversal continuation trfn break return subject reduct reduce typed compose trfn subject args rules return reduct fail subject reduct fi fi fi fi acm transactions computational logic vol 

january 
term rewriting traversal functions algorithm interpreter transformers part 
function visit children trfn function symbol subject term args list term rules list rule term var children children list term var child reduct term var fn id var success bool decompose term subject fn children success false foreach child children reduct visit trfn child args rules reduct fail children append children reduct success true children append children child fi od return success true compose term fn children fail fi function typed compose trfn function symbol subject term args list term term var subject type var function symbol var fn id subject result type subject decompose function symbol trfn fn 
compose function symbol fn subject 
subject return compose term subject args 
operational semantics describe operational semantics traversal functions 
assume fully typed term representation 
means function name order type associated 
example function name type constant type constructor function arguments typed respectively 
call fully typed version function name function symbol assume terms contain function symbols 
course term construction destruction matching functionality adapted term representation 
note typed term representation operational detail traversal functions 
needed match correct nodes traversing tree 
definition traversal function statically type checked section ensure execution leads ill formed term 
extending innermost start normal innermost rewriting depicted earlier algorithm see section 
original algorithm normalizes children term relies reduce reduce term outermost level 
acm transactions computational logic vol 

january 
van den brand modified algorithm call function reduce replaced case distinction depending kind function normal function traversal function transformer accumulator accumulating transformer 
cases calls respective functions reduce traverse trafo traverse accu traverse accu trafo 
note describe kinds traversal functions means different functions 
done expository purposes see discussion section 
transformer function traverse trafo auxiliary functions shown algorithms 
function traverse trafo mainly decomposes input term function symbol traversal function subject term traversed optional arguments 
delegates actual function visit 
function visit distinguishes major cases top bottom traversal 
cases break continue behavior traversal function modeled 
application traversal function failed recursion continues breaks depending annotation traversal function 
application failed continues recursion 
apply traversal function reusing reduce function basic innermost rewriting algorithm see algorithm 
applied traversing children depending traversal strategy bottom top 
visit depends visit children recurring children current node 
children reduced visit children returns fail returns list new children 
order type safe type traversal function follows type term traversed 
type matches type node currently visited 
behavior encoded typed compose function 
transformers type preserving type argument result adapted type node currently visited 
note algorithm reuse existing matching functionality 
auxiliary functions defined algorithms traversal strategy fn function symbol returns traversal strategy function symbol fn top bottom 
traversal continuation fn function symbol returns continuation style function symbol fn break continue 
result type term returns result type outermost function symbol term accumulator function traverse accu auxiliary functions shown algorithms 
definitions largely follow pattern transformers exceptions traverse accu separates traversed subject arguments traversal function 
identifies second argument initial value accumulator 
acm transactions computational logic vol 

january 
term rewriting traversal functions algorithm interpreter accumulators part 
function traverse accu term rules list rule term var trfn function symbol var subject term var args list term decompose term trfn subject accu args return visit trfn subject accu args rules function visit trfn function symbol subject term accu term args list term rules list rule term var reduct accu term traversal strategy trfn top accu reduce typed compose trfn subject accu args rules accu fail return visit children trfn subject accu args rules traversal continuation trfn break return accu reduct visit children trfn accu reduct args rules return reduct fail accu reduct fi fi fi bottom accu visit children trfn subject accu args rules accu fail reduct reduce typed compose trfn subject accu args rules traversal continuation trfn break return accu reduct reduce typed compose trfn subject accu args rules return reduct fail accu reduct fi fi fi fi visit visit children extra argument accumulator 
typed compose type argument changed type accumulator argument remains 
traversal children function visit children takes account accumulated value passed child 
accumulating transformer give details algorithms accumulating transformer essentially fusion algorithms accumulators transformers 
accumulating transformer input output values initial term current accumulator value respectively transformed term updated accumulator value types visit visit children typed compose adjusted manipulate pair terms acm transactions computational logic vol 

january 
van den brand algorithm interpreter accumulators part 
function visit children trfn function symbol subject term accu term args list term rules list rule term var children list term var child accu reduct term var fn id var success bool decompose term subject fn children accu accu success false foreach child children reduct visit trfn child accu args rules reduct fail success true accu reduct fi od return success true accu fail fi function typed compose trfn function symbol subject term accu term args list term term var subject type var function symbol var fn id subject result type subject decompose function symbol trfn fn 
compose function symbol fn subject 
return compose term subject accu args single term 
discussion presentation separated cases transformer accumulator accumulating transformer 
actual implementation cases implemented single function uses pairs terms accommodate accumulating transformers 
algorithms slightly involved algorithms transformer accumulator deal term pairs places case distinctions cater specific behavior algorithms 

implementation issues actual implementation traversal functions asf sdf consists parts parsing user defined rules traversal function section 
interpreter implementation traversal functions section 
compilation scheme traversal functions section 
acm transactions computational logic vol 

january 
parsing traversal functions term rewriting traversal functions terms rewrite rules asf sdf user defined syntax 
order parse specification user defined term syntax combined standard equation syntax asf 
combined syntax generate parser parse specification 
order parse rewrite rules traversal function need grammar rules define 
approach described brand generate syntax possible application traversal function 
collection generated functions viewed overloaded function 
simple approach relieved programmer typing trivial productions 
practice solution drawbacks parse tables tended grow factor equal number traversal functions 
result interactive development unfeasible parse table generation time growing accordingly 
generated grammars possibly ambiguous 
disambiguating grammars delicate process user needs complete control grammar 
control lost generated productions interfere user defined productions 
alternative approach adopted user specify grammar rule sort argument traversal function amounts rewrite rules defining traversal function applications traversal function rules 
amount defining changing traversal function increases approach proportional number node types visited 
parse table grow proportionally number visited node types 
result parse table generation time acceptable interactive development 
opted solution targeting industrial size problems traversal functions solutions small examples acceptable 
considerations relevant term rewriting concrete syntax 
systems fixed term syntax generate complete signature introducing significant overhead 
interpretation traversal functions asf interpreter rewrites parse trees directly terms 
parse trees rewrite rules simply matched parse trees terms rewriting 
reduction done substituting parse tree right hand side rule location redex term 
asf sdf interpreter implements algorithms section 
compilation traversal functions order better performance rewriting systems compiling proven beneficial 
asf sdf compiler brand brand translates rewrite rules functions 
compiled specification takes parse tree input produces parse tree result 
internally acm transactions computational logic vol 

january 
van den brand dense term format 
compilation run time behavior rewriting system follows bottom fashion node input parse tree visited corresponding function retrieved called immediately 
retrieval implemented way pre compiled dictionary maps function symbols corresponding function 
step conversion parse tree term takes place 
called function contains dedicated matching automaton left hand sides rules function symbol node outermost symbol 
contains automaton checking conditions 
function calls similarly compiled rewrite rules evaluation right hand sides 
application function fails means node normal form 
result normal form explicitly constructed memory 
nodes rewrite rules apply including constructors standard behavior 
resulting normal form term format translated back parse tree format dictionary 
traversal functions fitted run time behavior manner 
defining rewrite rule traversal function call traversal function type overloaded argument optionally result type turned single universal type 
result collection rewrite rules share outermost traversal function compiled existing compilation scheme obtain matching automaton entire traversal function 
clarifies scheme small example 
phase shows module containing traversal function visits types module parsed type checked translated module pretty printed readability 
phase variants traversal function collapsed single function symbol 
denotes universally quantified type 
traversal function new module type unsafe 
application traversal function guarded constructor 
rule applicable terms type rule guarded constructor 
turning type argument traversal function universal rule matches terms type faithful semantics asf sdf 
solution add run time type check cases argument traversal function guarded 
dictionary described look types symbols 
new module shown third pane 
condition added rewrite rule stipulating rule may succeed type argument equal expected type 
type function encapsulates lookup dictionary described 
takes top symbol term variable matched returns type 
module compiled conventional compiler obtain type safe matching automaton defining rules traversal function 
acm transactions computational logic vol 

january 
module example exports context free syntax example traversal trafo bottom continue example traversal trafo bottom continue variables vara equations example vara 
example vara module example exports context free syntax example traversal trafo bottom continue variables vara equations example vara 
example vara module example exports context free syntax example traversal trafo bottom continue equations type vara example vara 
example vara 
term rewriting traversal functions aterm example aterm arg aterm tmp call kids trafo example arg extra args check symbol tmp symbol return term equal get type tmp type return return tmp fig 

selected phases compilation traversal function 
acm transactions computational logic vol 

january 
van den brand obtain tree traversal behavior automaton combined calls small run time library 
contains functions take care traversing tree optionally passing accumulated argument 
fourth pane shows code running example 
depending traversal type different run time procedure 
case transformer call kids trafo 
transformer function applied children new node created children reduced 
accumulator library procedure call kids accu takes care passing accumulated value children 
depending traversal order calls library simply generated matching automaton 
break continue primitives implemented inserting extra calls run time library procedures surrounded conditionals check successful application failure traversal function 

experience traversal functions applied variety projects 
highlight representative ones 
cobol transformations joint project software improvement group sig centrum voor wiskunde en informatica cwi vrije universiteit vu traversal functions applied conversion cobol programs 
earlier described sellink 
purpose migrate vs cobol ii cobol 
existing tool ibm carry basic technically necessary conversions 
leaves constructions unchanged obtain status archaic obsolete cobol standard 
addition compiler specific cobol extensions remain code outdated run time utilities replaced standard cobol features 
transformation rules formalized replace deprecated language features achieve code improvements 
examples rules adding keywords close statements 
replace nested statements evaluate statements 
replace outdated call utilities standard cobol statements 
reduce go statements goto elimination algorithm consists different transformation rules applied iteratively 
formalization rules asf sdf traversal functions applying test base programs containing lines code results obtained ifs added 
lines changed order eliminate call utilities 
go tos eliminated go tos 
acm transactions computational logic vol 

january 
term rewriting traversal functions module trafo imports cobol exports context free syntax program program traversal trafo continue top variables stats expr exp equations expr stats expr stats expr stats stats expr stats stats fig 

definition rules add ifs 
transformation rule implemented means traversal function defined equations 
shows rewrite rules add missing keywords cobol conditionals 
complete transformation took half hours asf interpreter 
compiled version traversal functions ready time experiment done reduce time factor see section 
estimated compiled execution time minutes 
results show traversal functions effectively solve problems realistic size 
sdf re factoring mmel framework sdf transformations fst described intended support grammar recovery process recovering grammars manuals source code grammar re engineering transforming improving grammars serve new purposes information extraction legacy systems dialect conversions 
techniques applied vs cobol ii grammar 
experience traversal functions positive 
cite authors time writing fst described traversal functions rewrite rules function 
sdf grammar relevant productions 
remarkable indication usefulness support traversal functions 
worst case deal rewrite rules sdf formedness checker sdf supported tool set containing parse table generator formedness checker 
considerable part parse table generator specified asf sdf 
formedness checker entirely specified asf sdf mhz pc mb memory running linux 
www cwi nl projects acm transactions computational logic vol 

january 
van den brand table ii 
performance sdf checker 
grammar productions interpreted compiled ratio seconds seconds sdf java action semantics cobol extensive traversal functions 
formedness checker analyses collection sdf modules checks completeness specification sort declarations missing unused double uniqueness constructors uniqueness labels 
sdf grammar consists production rules asf sdf specification consists functions equations functions traversal functions equations traversal function outermost function symbol left hand side considered traversal equations 
indication resulting performance shown table ii 
shows results sdf java action semantics cobol 
grammar number grammar rules execution times interpreted compiled sdf checker 
column gives interpreted compiled ration 
figures show traversal functions completely acceptable performance 
show compilation gives speed factor 

discussion traversal functions minimalist design tries combine type safety expressive power 
discuss consequences limitations approach 
declarative versus operational specifications traversal functions expressed annotating function declarations 
understanding meaning rules requires understanding function traversal function visiting order uses 
pure algebraic specification considered bad practice depend rewriting strategy operational semantics writing specifications 
extending operational semantics rewrite system traversal functions effectively encourage operational semantics 
term rewriting viewed programming paradigm traversal functions enhance declarative nature specifications 
traversal functions simple transformation coded lot operational style rewrite rules 
traversal functions essential rules defined 
effort understanding checking specification decreases significantly 
brand show traversal functions asf sdf translated specifications traversal functions relatively straightforward manner 
traversal functions seen abbreviation mechanism 
mhz pc mb memory running linux 
acm transactions computational logic vol 

january 
expressivity term rewriting traversal functions recall main left right visiting orders trees top bottom combined criteria application visit nodes 
orders expressed traversal functions combinations bottom top break continue 
opted solution precisely covers possible visiting orders 
may wonder concepts repetition conditional evaluation strategic programming see section fit 
case control structures moved strategy language base language rewrite rules functions remains relatively simple 
case base language asf sdf able express concepts need added set traversal primitives 
limited types traversal functions accumulators map sub trees single sort transformers sort preserving transformations 
serious limitation 
argue general non sort preserving transformations expressed conveniently restriction 
transformations typically occur translating language completely change type sub term 
case full translations advantage generic traversal scheme debatable translation rules language construct anyway 
interesting case partial translations occur instance embedded language statements translated surrounding language constructs remain untouched 
case number rules proportional number translated constructs total number grammatical constructs 
partial transformations seen combination sort preserving transformation constructs transformation defined non sort preserving transformation defined parts 
sort preserving part expressed transformer number rewrite rules proportional number translated constructs 
difficult see generic non traversal primitive really specifications translations concise 
reuse versus type safety separate traversal strategy rewrite rules applied 
doing loose potential advantage reusing set rewrite rules different visiting orders 
precisely combination traversal strategy rewrite rules allows simple typing mechanism 
reason generic traversal attributes separate operators need type checked 
allows ensure formedness type preserving transformations type unifying computations extending typing mechanisms order specification language 
acm transactions computational logic vol 

january 
van den brand described term rewriting traversal functions extension asf sdf 
advantages approach frequently traversal orders provided built primitives 
approach fully type safe 
traversal functions implemented efficiently 
traversal functions nice compromise simplicity expressive power 
main disadvantage approach manifest dealing visiting orders go basic model tree traversal 
escapes possible cases traversals simulated modification built strategies adding conditions auxiliary functions fall back tedious specification traversal enumerating traversal rules constructors grammar 
practice scenario occurred experience traversal functions shows extremely versatile solving real life problems 
acknowledgments received indispensable feedback users traversal functions 
steven software improvement group hans university amsterdam cobol transformations ralf mmel cwi vrije universiteit amsterdam guido university rostock applied sdf re factoring 
ralf mmel eelco visser joost visser commented drafts 
feedback anonymous referees greatly improved presentation 

attribute grammars 
international summer school attribute grammars applications systems eds 
lecture notes computer science vol 

springer verlag berlin heidelberg new york 
bergstra heering klint eds 

algebraic specification 
acm press addison wesley 
borovansk kirchner kirchner moreau ringeissen 
overview elan 
international workshop rewriting logic applications kirchner kirchner eds 
electronic notes theoretical computer science vol 

elsevier 
brand deursen klint meulen 
industrial applications asf sdf 
algebraic methodology software technology amast wirsing nivat eds 
lncs vol 

springer verlag 
brand heering klint olivier 
compiling language definitions asf sdf compiler 
acm transactions programming languages systems 
brand klint olivier 
compilation memory management asf sdf 
compiler construction 
lecture notes computer science vol 

springer verlag 
brand klint verhoef 
core technologies system renovation 
theory practice informatics jeffery kr barto sek eds 
lncs vol 

springer verlag 
acm transactions computational logic vol 

january 
term rewriting traversal functions brand klint verhoef 
term rewriting sale 
second international workshop rewriting logic applications kirchner kirchner eds 
brand klint 
term rewriting traversal functions 
tech 
rep sen centrum voor wiskunde en informatica 
brand sellink verhoef 
generation components software renovation factories context free grammars 
science computer programming 
cardelli 
type systems 
handbook computer science engineering 
crc press 
cordy halpern 
txl rapid prototyping system programming language dialects 
computer languages 
deursen heering klint eds 

language prototyping algebraic specification approach 
amast series computing vol 

world scientific 
deursen klint tip 
origin tracking 
journal symbolic computation 
deursen moonen 
type inference cobol systems 
proc 
th working conf 
reverse engineering baxter quilici verhoef eds 
ieee computer society 
felty 
logic programming approach implementing higher order term rewriting 
extensions logic programming elp 
eriksson schroeder heister eds 
lecture notes intelligence vol 

springer verlag 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley reading 

incremental semantic analysis 
ph thesis lund university 
magnusson 
java system implementing frontends 
proc 
van den brand parigot eds 
electronic notes theoretical computer science vol 

elsevier science 
heering 
implementing higher order algebraic specifications 
proceedings workshop prolog programming language miller ed 
university pennsylvania philadelphia 
published technical report ms cis 
heering 
second order term rewriting specification static semantics exercise 
language prototyping van deursen heering klint eds 
amast series computing vol 

world scientific 
heering hendriks klint rekers 
syntax definition formalism sdf manual 
sigplan notices 
huet lang 
proving applying program transformations expressed second order patterns 
acta informatica 
klint 
strategic programming viable paradigm 
workshop reduction strategies rewriting programming wrs gramlich lucas eds 
electronic notes theoretical computer science vol 

elsevier science publishers 
klint 
understanding restructuring differ compiling rewriting perspective 
proceedings th international workshop program comprehension iwpc 
ieee computer society 
knuth 
art computer programming volume 
addison wesley 
kuipers visser 
object oriented tree traversal 
electronic notes theoretical computer science van den brand parigot eds 
vol 

elsevier science publishers 
proc 
workshop language descriptions tools applications 
mmel 
typed generic traversal term rewriting strategies 
journal logic algebraic programming 
mmel visser 
typed combinators generic traversal 
padl practical aspects declarative languages 
lecture notes computer science lncs vol 

springer 
acm transactions computational logic vol 

january 
van den brand mmel visser 
dealing large bananas 
workshop generic programming jeuring ed 
ponte de lima 
published technical report uu cs department information computing sciences universiteit utrecht 
mmel 
transformation sdf syntax definitions asf sdf meta environment 
proc 
van den brand parigot eds 
electronic notes theoretical computer science vol 

elsevier science 
sellink verhoef 
restructuring cobol cics legacy systems 
proceedings conference maintenance reengineering 
amsterdam 


term rewriting systems 
number cambridge tracts theoretical computer science 
cambridge university press 
tip dinesh 
slicing approach locating type errors 
acm transactions software engineering methodology 

modifiability legacy assets 
th european conference software maintenance reengineering van den brand canfora gym thy eds 
ieee computer society press 
visser 
language independent traversals program transformation 
workshop generic programming jeuring ed 
ponte de lima 
published technical report uu cs department information computing sciences universiteit utrecht 
visser 
stratego language program transformation rewriting strategies 
system description stratego 
rewriting techniques applications rta middeldorp ed 
lecture notes computer science 
springer verlag 
visser 
survey strategies program transformation systems 
workshop reduction strategies rewriting programming wrs gramlich lucas eds 
electronic notes theoretical computer science vol 

elsevier science publishers 
visser 
visitor combination traversal control 
acm sigplan notices nov 
oopsla conference proceedings object oriented programming systems languages applications 
vogt swierstra kuiper 
higher order attribute grammars 
sigplan notices 
proceedings acm sigplan conference programming language design implementation 

source code transformations new asf sdf 
thesis university amsterdam programming research group 
received month year revised month year accepted month year acm transactions computational logic vol 

january 
