architecture pier internet scale query processor submission redistribute ryan huebsch brent chun joseph hellerstein boon loo petros maniatis timothy roscoe scott shenker ion stoica presents architecture pier query engine building years 
pier general purpose relational query processor targeted peer peer architecture thousands millions participating nodes internet 
supports massively distributed database style dataflows snapshot continuous queries 
intended serve building block diverse set internet scale applications particularly tap standardized data readily available networked machines including packet headers system logs file names 
earlier papers vision pier application relevance initial simulation results 
real world results showing benefits pier filesharing network 
time detailed look pier architecture implementation 
pier targets unusual design point relational query engine architecture reflects challenges levels core runtime system aggressive multi purpose overlay networks implementation query engine basics including data representation query dissemination query operators approach system metadata 
addition reporting pier architecture discuss generation design concerns arisen system real starting address current 
context distributed database systems long topic interest database research community 
fundamental goal generally distribution transparent users applications encapsulating details distribution standard query language semantics acid guarantees 
resulting designs sdd mariposa differ respects share modest targets network scalability pier stands peer peer information exchange retrieval :10.1.1.135.2031
uc berkeley intel research berkeley db cs berkeley edu systems deployed handful distributed sites 
internet community interested distributed query processing reasons akin laid earlier :10.1.1.14.7680
surprisingly approach problem different angle traditional database literature 
fundamental goal internet systems operate large scale thousands millions nodes 
inherent conflicts consistency availability tolerance network partitions cap theorem designers internet systems willing tolerate loose consistency semantics order achieve availability 
tend sacrifice flexibility sql style database query language favor systems scale naturally hierarchical wiring internet 
examples category include astrolabe irisnet hierarchical internet query systems discuss section :10.1.1.16.4376:10.1.1.16.4376
pier coming mixed heritage tries strike compromise internet database approaches 
internet systems pier targeted large scales settles relaxed semantics 
pier provides full degree data independence including relational data model full suite relational query operators indexing facilities manipulate data regard location network 
section describing basic design choices pier characteristics target applications 
followed section detailed explanation pier architecture 
highlight key design challenges exploring system 
trustworthiness widely distributed system special concern discuss number challenges respect section 
exploring number avenues respect query optimization discussed section 
design decisions sample application philosophical assumptions adopted pier described earlier discussion guided architecture :10.1.1.14.7680:10.1.1.14.7680
focus concrete design decisions submission redistribute architecting system 
overview number sample applications built pier 
design decisions pier fully embraces notion data independence extends idea traditional disk oriented setting promising new territory volatile realm internet systems 
pier adopts relational data model data values fundamentally independent physical location network 
approach established database community stark contrast internet query processing systems including known systems dns ldap filesharing systems gnutella kazaa research systems astrolabe irisnet hierarchical networking schemes achieve scalability :10.1.1.16.4376:10.1.1.16.4376
analogies early days relational databases 
pier may somewhat efficient customized locality centric solution certain constrained workloads 
pier data independence allows achieve reasonable performance far wider set queries making choice easy development new internet scale applications query distributed state 
network scalability resilience performance pier achieves scalability distributed hash table dht technology see representative :10.1.1.140.3129:10.1.1.10.5979:10.1.1.105.3673
discuss detail section dhts overlay networks providing naming network routing reused host purposes pier typically separate modules traditional dbms section 
dhts extremely scalable typically incurring operation overheads grow logarithmically number machines system 
designed resilience capable operating presence churn network frequent node link failures steady arrival departure participating machines network 
pier designed internet assumes network key bottleneck 
especially important environment hosts see bottlenecks mile dsl cable links 
discussed pier minimizes network bandwidth consumption fairly traditional bandwidth reducing algorithms bloom joins multi phase aggregation techniques :10.1.1.14.7680:10.1.1.14.7680
lower fundamental system level pier core design centers low latency processing large volumes network messages 
respects resembles router database system 
decoupled storage key decision earliest discussions decouple storage pier query engine 
inspired regard filesharing applications successful adding new value querying preexisting data situ 
approach com mon database community data integration stream query processing systems 
pier designed variety storage systems transient storage data streams main memory buffers locally reliable persistent storage file systems embedded dbs jdbc enabled databases proposed internet scale massively distributed storage systems 
course decision means pier sacrifices acid storage semantics traditional distributed databases 
believe natural trade internet scale context internet scale applications need persistent storage cap theorem suggests strong consistency semantics unrealistic goal internet scale systems 
strictly decoupling storage query engine give ability reliably store system metadata 
result pier metadata catalog sort traditional dbms 
significant ramifications parts system sections 
software engineering day pier targeted platform thousands nodes wide area network 
development testing massively distributed system hard lab 
order possible native simulation key requirement system design 
native simulation mean runtime harness emulates network multiple processors exercises standard system code 
challenges debugging massively distributed systems involve code deals distribution parallelism particularly handling node failures logic surrounding ordering timing message arrivals 
issues tend hard reason difficult test robustly simulation 
result attempted encapsulate distribution parallelism features modules possible 
pier logic resides largely dht code 
relational model helps subtle network timing issues affect ordering tuples dataflow effect query answers operator logic pier uses distributed sort algorithms 
potential applications pier targeted applications run thousands users nodes centralization undesirable infeasible 
date grounded specific application classes file sharing 
application global deployment serves baseline scalability 
characterized number features simple schema keywords constrained query workload boolean keyword search data stored inherent locality loose query semantics resolved users relatively high churn administration extreme ease 
order put pier implemented filesharing submission redistribute percentage queries pier rare items gnutella queries gnutella rare items result latency sec cdf latency receipt answer pier gnutella real user queries intercepted gnutella network 
pier measured planetlab nodes worldwide challenging subset queries rare keywords infrequently past 
baseline cdf gnutella rare query subset complete query workload popular rare queries 
details appear :10.1.1.1.6174
top sources firewall log events reported planetlab nodes running continents 
search engine pier integrated existing gnutella filesharing network yield hybrid search infrastructure uses gnutella protocol find widely replicated nearby items pier engine find rare items global network 
describe topic deployed hybrid infrastructure nodes worldwide planetlab testbed ran real gnutella queries data :10.1.1.109.4681:10.1.1.1.6174
hybrid infrastructure outperformed native gnutella recall performance 
example results pier hybrid system reduced number gnutella queries receive results significantly lower answer latency 
presents representative performance graph study showing significant decreases latency 
endpoint network monitoring 
hosts wealth network data standard schemas packet traces firewall logs standard examples 
endpoint network monitoring data important emerging application space constrained query workload typically distributed aggregation queries joins streaming data located sources destinations traffic relatively high churn 
approximate answers online aggregation desirable 
shows prototype applet built executes continuous pier query running firewall logs planetlab nodes worldwide 
query reports ip addresses top sources firewall events nodes 
forensic studies firewall logs suggest top sources firewall events generate large fraction total unwanted traffic :10.1.1.118.6576
pier query illustrates result real time automatically parameterize packet filters firewall 
architecture section describe pier architecture detail 
low level execution environment overview dht 
discuss life query details query processing logic highlight varying ways dht query processing 
execution environment serious query engine pier designed achieve high degree multiprogramming bound activities 
noted section needs support native simulation 
requirements led design grounded main components narrow virtual runtime interface event style multiprogramming minimal threads 
virtual runtime interface lowest level pier presents simple virtual runtime interface encapsulates basic execution platform 
bound real world physical runtime environment section simulation environment section 
composed interfaces clock timers network protocols internal pier scheduler dispatches clock network events 
interested reader representative set methods provided shown table 
events handlers multiprogramming pier achieved event programming model running single thread 
common routers network bound applications computation triggered arrival message tasks specifically posted local code 
events pier processed single thread preemption 
submission redistribute clock main scheduler long void delay void udp void listen port void release port void send source destination payload callback client void success void source payload tcp void listen port void release port connect source destination disconnect int read int write void void void table selected methods 
single threaded event approach number benefits purposes 
importantly supports goal native simulation 
discrete event simulation standard way simulate multiple networked machines single node 
adopting event model core system able reuse program logic simulation environment physical runtime environment 
uniformity simulation runtime code key design feature pier enormously improved ability debug system experiment scalability 
java handle large number threads efficiently matter taste easier code thread event handling 
consequence having single main thread event handler system complete relatively quickly compared inter arrival rate new events 
practice means handlers synchronous calls potentially blocking routines network disk system utilize asynchronous split phase non blocking registering callback routines handle notifications operation complete similarly long chunk cpu intensive code yield processor time scheduling continuation timer event 
handler manage state heap program stack cleared event yields back scheduler 
events originate expiration timer completion take stand scalability number threads fundamental limit :10.1.1.130.8002
simply needed java current limitations system 
java adequate support non blocking file jdbc operations 
scenarios devices data sources spawn new thread blocks call enqueues proper event main scheduler event priority queue call complete 
virtual runtime interface 
main scheduler query execution query dissemination program clock overlay network secondary queue network marshal timer event network event internet physical runtime environment single priority queue main scheduler stores events waiting handled 
events enqueued setting timer arrival network message 
outbound network messages enqueued asynchronous processing 
second thread responsible dequeuing marshaling messages placing network 
thread receives raw network messages contents places resulting event main scheduler queue 
operation 
physical runtime environment physical runtime environment consists standard system clock priority queue events main scheduler thread set ip networking libraries 
clock scheduler fairly simple networking libraries merit overview 
udp primary transport protocol pier mainly due low cost latency state overhead relative tcp sessions 
udp support delivery acknowledgments congestion control 
overcome limitations utilize library provides acknowledgments tcp style congestion control :10.1.1.10.5979
tracks message provides reliable delivery notifies sender failure guarantee order message delivery 
tcp sessions primarily communication user clients 
simulation environment simulation environment capable simulating thousands virtual nodes single physical machine providing node independent logical clock network interface 
main scheduler simulator designed coordinate discrete event simulation demultiplexing events multiple logical nodes 
program code node remains simulation environment physical runtime environment 
network simulated message level granularity packet level efficiency 
words simulated packet contains entire application message may arbitrarily large 
avoiding need fragment messages multiple packets simulator fewer submission redistribute virtual runtime interface 
node demultiplexer main scheduler query execution query dissemination program overlay network network model clock network topology congestion model simulation environment simulator uses main scheduler priority queue nodes 
simulated events annotated virtual node identifiers demultiplex events appropriate instances program objects 
outbound network messages handled network model uses topology congestion model calculate network event executed program 
congestion models may reschedule event queue outbound message affects calculation 
units data simulate 
message level simulation accurate approximation real network long messages relatively close size maximum packet size real network usually bytes internet 
messages pier kb 
simulator includes support standard network topology types star transit stub congestion models congestion fair queuing fifo queuing 
simulator currently simulate network loss messages delivered capable simulating node failures 
overlay network having described underlying runtime environment interfaces describe pier program logic 
overlay network key abstraction pier variety ways discuss section 
internet scale systems pier require robust communication substrates keep track nodes currently participating system reliably direct traffic participants nodes come go 
approach problem uses central server maintain directory participants direct ip addresses original napster model peerdb 
solution requires expensive administered highly available central server placing control liability system hands organization central server 
central server pier uses decentralized routing infrastructure provided overlay network 
overlay networks means inserting distributed layer indirection standard ip network 
dhts popular class overlay networks provide location indepen inter node operations void get namespace key void put namespace key suffix object lifetime void send namespace key suffix object lifetime void renew namespace key suffix lifetime void namespace key objects intra node operations objects void void upcall void namespace key object namespace key object table selected methods provided overlay wrapper 
dence assigning node object identifier identifier space 
dht maintains dynamic mapping identifier space actual nodes system 
dht provides name implies hash table interface hash buckets distributed network 
addition distributed implementation hash table traditional get put methods dht provides additional object access maintenance methods 
proceed describe dht core components naming routing state various dht interfaces table pier 
naming object pier dht named parts namespace partitioning key suffix 
dht computes object routing identifier namespace partitioning key suffix differentiate objects share routing identifier 
query processor uses namespace represent table name name partial result set query 
partitioning key generated relational attributes index tuple dht hashing attributes 
suffixes tuple chosen random minimize chance spurious name collision table 
routing key features dhts ability handle churn set member nodes 
centralized directory nodes system node keeps track selected set neighbors neighbor table continually updated consistent actual membership network 
keep overhead low dhts designed node maintains neighbors reducing volume updates 
consequence node route directly handful nodes 
reach arbitrary nodes multi hop routing 
multi hop routing node dht may required forward messages nodes 
forwarding entails deciding hop message destination identifier 
dht algorithms require message forward progress hop prevent routing submission redistribute cycles 
definition forward progress key differentiator various dht designs full discussion scope 
useful side effect multi hop routing ability nodes forwarding path intercept messages forwarding hop 
upcall dht query processor inspect modify drop message 
upcalls play important role various aspects efficient query processing discuss section 
soft state recall pier support persistent storage pier places burden ensuring persistence originator object publisher soft state key design principle internet systems 
soft state node stores item relatively short time period object soft state lifetime item discarded 
publisher wishes keep object system longer periodically renew object extend lifetime 
dht node fails objects stored node lost longer available system 
publisher attempts renew object identifier handled different node recognize object identifier cause renewal fail publisher publish item making available system 
soft state side effect natural garbage collector data 
publisher fails objects published eventually discarded 
choice soft state lifetime publisher system enforcing maximum lifetime 
shorter lifetimes require publisher maintain persistence increase object availability failures detected fixed publisher faster 
longer lifetimes publisher failures go undetected longer 
maximum lifetime protects system having expend resources storing object publisher failed long ago 
implementation overlay network composed modules router object manager wrapper see 
router contains peer peer overlay routing protocol options 
currently utilize bamboo choice pier agnostic actual algorithm dhts past :10.1.1.10.5979
listed table dht supports collection internode intra node operations 
hash table functionality provided pair asynchronous inter node methods put get 
phase operations lookup performed determine identifier ip address mapping direct point point ip communication perform operation 
get operation completes dht passes data query processor callback 
api supports lightweight variant put called renew renew object soft state lifetime 
renew method succeed item routing query processor wrapper overlay network object manager obj 
obj 
obj 
overlay network composed router object manager wrapper 
router wrapper exchange messages nodes network 
query processor interacts wrapper turn manages choreography router object manager fulfill request destination node renew fail put performed 
send method similar put upcalls provided node path destination 
shows operations performed 
intra node operations key query processor 
allows query processor view objects local node enable query processor notified new object arrives node 
upcall allow query processor intercept messages sent send call 
query processor having described runtime environment overlay network turn attention processing queries pier 
introduce pier query processor describing data representation explaining basic sequence events executing query 
data representation access methods recall pier maintain system metadata 
result tuple pier self describing containing table name column names column types 
pier utilizes java type system column values stored native java objects 
java supports arbitrarily complex data types including nesting inheritance polymorphism 
provides natural support extensibility form data types pier interpret types accessing java methods 
tuples enter system access methods contact variety sources internal dht remote web pages files jdbc fetch currently implemented synchronous call dht interface 
assumption dht stored objects memory may case 
converted asynchronous call upcoming version system 
submission redistribute put renew send get source destination lookup obj 
obj 
lookup request obj 
forward forward upcall upcall forward forward response obj 
obj 
response put renew perform lookup find object ip mapping directly forward object destination 
send similar put object routed destination single call 
send uses fewer network messages message larger includes object 
get done lookup followed request message response including object requested 
data 
access method converts data native format pier tuple format injects tuple dataflow section 
necessary type inference conversion performed access method 
specified explicitly part query access method unable perform type checking deferred processing comparison operator function accesses value 
life query overview life query pier subsequent sections delve somewhat deeply details 
current version pier defined native algebraic box arrow dataflow language call ufl ufl spirit stream query systems aurora router toolkits click 
ufl queries direct specifications physical query execution plans including types pier refer query plans 
graphical user interface called lighthouse available conveniently wiring ufl pier supports ufl graphs cycles recursive queries pier topic research scope 
ufl query plan operator graphs 
individual connected set dataflow operators nodes edges specifying dataflow operators section 
operator associated particular implementation 
separate formed query redistributes data network usual local dataflow channels section sets operators similar distributed exchange operator currently ufl stands unnamed flow language somewhat surprise early users requested sql query language 
implemented naive version functionality interface raises various query optimization issues section 
obj 
placed 
producer consumer separate connected dht particular namespace dht rendezvous point 
unit section allowing different parts query selectively sent node required portion query 
query composed user application client establishes tcp connection pier node 
pier node selected serves proxy node user 
proxy node responsible query parsing dissemination forwarding results client application 
query parsing converts ufl representation query java objects suitable query executor 
parser need perform type inference ufl typed syntax check existence type column system catalog 
query parsed query plan disseminated nodes needed process portion query section 
node receives creates instance operator graph section establishes dataflow links section operators 
execution node executing may produce answer tuple 
tuple batches tuples forwarded client proxy node 
proxy delivers tuple client application 
node continues execute timeout specified query expires 
timeouts snapshot continuous queries 
natural alternative snapshot queries wait dataflow delivers eof similar message 
number problems 
pier dataflow source may massively distributed data source dht 
case data may coming arbitrary subset nodes entire system node executing need maintain list live nodes system churn 
second useful messages sent network delivered order guarantee message layer provide 
contrast timeouts simple applicable snapshot continuous queries 
burden selecting proper timeout left query writer 
overview expand query dissemination indexing operators dataflow operators pier overlay network 
query dissemination indexing non trivial aspect distributed query system efficiently disseminate queries participating nodes 
simplest form query dissemination broadcast node 
broadcast specialized multicast dht studied :10.1.1.20.299:10.1.1.11.1973
method describe distribution tree techniques 
pier maintains distribution tree queries multiple trees supported reliability load balancing 
joining network pier node routes message send containing node identifier submission redistribute known root identifier hard coded pier 
node hop receives upcall message records node identifier contained message drops message 
process creates tree message informs parent node new child 
node depth tree equivalent number hops message taken reach root 
shape tree fanout height imbalance dependent dht routing algorithm tree maintained soft state periodic messages allow adapt membership changes 
broadcast proxy node forwards directly hard coded id root distribution tree 
root sends copy child identifier recorded previous phase forwards recursively 
broadcasting efficient scalable possible want send nodes tuples needed process query 
just dbms uses disk index read fewest disk blocks pier distributed indexes determine subset network nodes needed predicate 
respect query dissemination really example distributed indexing problem pier currently supports kinds indexes true predicate index equality predicate index index 
true predicate index distribution tree described allows query ranges data find data 
equality predicates pier directly supported dht operations need find specific value partitioning key routed relevant node dht 
range search pier uses new technique called prefix hash tree pht dht addressing storage 
pht essentially resilient distributed trie implemented dhts 
full description pht algorithm 
pht implemented directly dht codebase integrate pier 
note primary index pier achieved publishing table dht pht partitioning attributes serving index key 
secondary indexes possible create simply tables index key tupleid pairs published index key partitioning key 
tupleid identifier pier access tuple dht name 
pier provides automated logic maintain consistency secondary index base tuples 
addition query dissemination problem described pier uses distributed indexing facility manners analogous traditional dbms 
pier primary index inner relation fetch matches join essentially distributed index join 
case call index disseminating small single table subquery join algorithm 
example chord produces distribution trees roughly binomial koorde produces trees roughly balanced binary :10.1.1.105.3673
discuss role node local indexes enable fast access data stored node 
pier traditional fashion currently main memory hashtables 
pier take advantage called secondary indexes 
achieved query explicitly specifying semi join secondary index original table index serves outer relation fetch matches join follows tupleid fetch right tuples right nodes 
note semi join situated inner relation fetch matches join achieves effect distributed index join secondary index 
operators query plans pier equipped logical operators physical operators logical operators multiple implementations 
operators similar dbms selection projection tee union join group duplicate elimination 
pier uses number non traditional operators including access methods result handler memory table queues put similar exchange eddies section control flow manager section :10.1.1.34.8546
join algorithms pier include symmetric hash join fetch matches join :10.1.1.56.701
common rewrite strategies bloom join semi joins 
examine different join strategies trade offs :10.1.1.14.7680
part pier operators queries similar systems salient differences hierarchical aggregation 
simplest method computing aggregate collect source tuples location 
tuples communication costs easily overwhelm node receiving data 
want distribute load multiple nodes 
method node compute partial aggregate values group nodes 
explicitly grouping nodes arrange nodes tree process query broadcasting see section 
node computes local aggregate uses dht send call send root identifier specified query 
hop routing path pier receives upcall combines partial aggregate data 
waiting data arrive nodes node forwards partial aggregate hop closer root 
eventually root receive partial aggregates include data node root produce answer 
optimal case node sends exactly partial aggregate 
achieve optimal node know received data children 
problems similar discussion eof section 
discuss detail 
procedure works distributive algebraic aggregates constant state needed submission redistribute step regardless amount source data aggregated 
holistic aggregates benefit hierarchical computation 
hierarchical joins 
hierarchical aggregation goal hierarchical joins reduce communication load 
case reduce bandwidth node bandwidth 
partitioning rehash phase parallel hash join source tuples routed network send destined correct hash bucket node 
tuple forwarded path intermediate node intercepts caches copy annotates local node identifier forwarding 
tuples cached node joined previously annotated matching node identifier join result produced sent directly proxy 
essence join results produced early 
improves latency shifts bandwidth load node responsible hash bucket nodes paths node 
hierarchical joins reduces bandwidth nodes 
particular skewed workload causes hash buckets receive majority tuples network bottleneck skewed nodes ameliorated offloading bandwidth nodes way 
bandwidth node responsible particular hash bucket remain receives join input tuple hierarchical processing 
malformed tuples 
wide area decentralized application pier encounter tuples match schema expected query 
pier uses best effort policy processing data 
query operators attempt process tuple tuple contain field proper type specified query tuple simply discarded 
likewise comparison general function processed field incompatible type tuple discarded 
global synchronization 
pier nodes loosely synchronized error synchronization longest delay nodes system time 
executed soon received node 
possible node processing send data node receive query 
consequence pier query operators capable catching start processing data may arrived 
memory operators 
currently operators pier memory algorithms spilling disk 
mainly result pier having buffer manager storage subsystem 
problem applications plan revisit decision 
local dataflow arrives node local dataflow set 
key feature design intra site dataflow decoupling control flow dataflow execution engine 
recall pier event driven model prohibits handlers blocking 
pier unable widely iterator pull model 
pier adopts non blocking iterator model uses pull control messages push dataflow 
query tree parent operators connected children traditional control channel function calls 
asynchronous requests sets data probes issued flow parent child graph open call iterators 
requests operator sets relevant state heap 
probe generated state necessary operators stack unwound operators return function call initiating probe 
access method receives probe typically registers callback dht data arrival yields schedules timer event main scheduler 
tuple arrives node pushed child parent data channel simple function calls operator calls parent tuple argument 
tuple continue flow child parent plan reaches operator removes dataflow selection consumed operator stores awaiting tuples join group enters queue operator 
point call stack unwinds 
process repeated tuple matches probe multiple tuples may pushed probe request 
queues inserted places dataflow processing comes air yields control back main scheduler 
queue receives tuple registers timer event zero delay 
scheduler ready execute queue timer event queue continues tuple flow child parent 
arbitrary tag assigned probe request 
tag sent data requested probe 
tag allows arbitrary reordering nested probes allowing operators match data stored state iterator model needed get request outstanding dataflow edge 
query processing uses overlay pier unique aggressive reuse dhts variety purposes traditionally served different components dbms 
take moment enumerate various ways dht 
query dissemination 
multi hop topology dht allows construction query dissemination trees described section 
table published dht particular namespace partitioning key query dissemination layer route queries submission redistribute equality predicates partitioning key just right nodes 
hash index table published dht table essentially stored distributed hash index keyed partitioning key 
range index substrate pht technique provides resilient distributed range search functionality mapping nodes trie search structure dht 
partitioned parallelism similar exchange operator dht partition tuples value parallelizing entire system providing network queue separation control flow contiguous groups operators 
operator state dht local storage layer supports hash lookups directly main memory state operators hash joins hash grouping maintain separate hashtables 
sense dht unifies exchange consumer operator single primitive single distributed api put get 
hierarchical operators inverse dissemination trees aggregation tree exploits multihop routing callbacks dht enable hierarchical implementations dataflow operators aggregations joins 
security years running pier planetlab testbed machines continents 
environment raises real world challenges scale reliability remains relatively benign terms participants system 
goal ready pier truly internet scale deployment wild require facing interrelated questions security robustness 
section initial considerations direction identifying major challenges techniques considering meet challenges 
challenges challenges facing loosely coupled distributed systems operate unfriendly environments identified 
context peer peer systems wallach gives survey 
concentrate challenges particular query processing system 
result fidelity measure close returned result correct result 
depending query fidelity related information retrieval success metrics precision recall numerical accuracy computed result aggregation function 
fidelity may deteriorate due network failures message loss nodes nodes unreachable node failures causing partial total loss data results node 
classes failures caused malicious activity network denial service dos attacks node break ins 
addition compromised malicious node reduce fidelity data poisoning instance introducing outlier value computation minimum 
resource management highly distributed loosely coupled system pier faces additional challenges traditional issues fairness timeliness important concerns include isolation free riding service flooding containment 
isolation prevents client generated tasks causing distributed system consume vastly resources required expense tasks example due poorly maliciously constructed query plans 
free riding nodes peer peer systems exploit system contributing little resources 
service flooding malicious clients practice sending requests service goal overloading 
containment important avoid powerful pier infrastructure attacks entities internet consider instance malicious queries name unsuspecting victim intended recipient voluminous results 
accountability components pier ability assign responsibility incorrect disruptive behavior important ensure reliable operation 
misbehavior detected accountability helps identify offending nodes justifies corrective measures 
example query repeated excluding nodes short term information input reputation database node selection 
politics privacy issues peer peer system 
different data sources may differing policy restrictions including access control export controls data notion pricing coarse grained summaries data set may free access raw data may require fee 
flip side data usage policies user privacy 
adoption large query applications may hindered user concerns query patterns exploited patterns may reveal personal information help direct targeted fidelity attacks 
certain data sets may require anonymity data points users responsible data points 
defenses currently pier concentrates primarily mechanics feasibility important issues security fault tolerance 
section defensive avenues investigating pier case outline support pier incorporates approaches actively pursuing implemented explorations foresee 
wallach maniatis survey available defenses peer peer environments 
redundancy redundancy simple powerful general technique improving security robustness 
multiple ran submission redistribute selected entities compute result operator may help reveal maliciously suppressed inputs overcome temporary loss network links 
similarly multiple overlay paths thwart malicious attempts drop delay modify pier messages query dissemination result aggregation 
current codebase incorporate techniques 
studying benefits offered different dissemination aggregation topologies minimizing influence adversary computed result 
specifically examine change simple metrics fraction data sources suppressed adversary relative result error plan consider complex ones maximum influence 
hope outcome study help adapt mechanism designs duplicate insensitive summarization proposed benign environments significantly unfriendly target environment :10.1.1.109.5109
rate limitation powerful defense abuse pier resources calls enforcement rate limits dissemination execution queries transfer results 
rate limits may imposed queries particular clients prevent clients unfairly overwhelming system expensive operations may imposed results traffic directed particular destinations limit damage malicious clients bugs cause pier inflict external entities may imposed pier node pier node limit amount free riding possible pier nodes compromised 
pier takes advantage virtualization inherent java environment sandbox operators execute 
important step rate limits limits including access controls imposed running operators 
system currently impose limits actively investigating rate limitations particular clients 
monitor pier node total resource consumption cpu cycles disk space memory client query operators time window 
node detects total exceeds certain threshold contacts pier nodes compute aggregate consumption suspect client system 
aggregate pier node throttle back primarily amount local resources available culprit operators 
note client controls propose dependent dependable authentication mechanism pier nodes clients sybil attacks malicious client uses identities queries quite reaching rate limitation thresholds benefits defense 
assigning client identifiers centralized fashion may help problem reverts tightly coupled subsystem identity 
scenarios pier nodes may misbehave free ride hoping incorporate system coarser grained dynamic rate limitation mechanism previously different peerto peer problem 
scheme pier nodes apply reciprocative strategy node executes query injected node executed query injected objective strategy ensure maintain balance executed queries associated resources consumed injected rate limits queries injected need inject new queries 
reciprocation works effectively contribution individual peers system varies instance due popularity peer resources 
reciprocative approaches especially helpful infrastructural environments pier nodes expected interact frequently long time period 
spot checking early commitment program verification techniques probabilistic early commitment authenticated data structures invaluable ensuring accountable operation individual components loosely coupled distributed system 
sia project techniques aggregate information securely contained setting sensor networks 
briefly client requesting query wishes verify correct behavior single aggregator samples inputs ensures samples consistent result supplied aggregator 
client knows input samples obtains aggregator compute result aggregator commits early inputs cryptographically making practically impossible cover tracks fact spot checking 
context pier execution operators including aggregation operators distributed nodes may malicious 
near term investigating spot checks verify correct execution individual nodes aggregation tree example sum operator added inputs aggregation children correctly 
second ensure data inputs included computation trace computation path sampled data sources query result 
third ensure included data inputs fact included sample execution paths aggregation tree verify raw inputs come legitimate sources 
client detects result suspect inconsistent subsequent spot checks refine approximation additional sampling redundancy obtain second opinion simply abort query 
long term hope implement pier promising principle trust verify mechanisms secure undeniable evidence certifying misbehavior system participant 
evidence avoids malicious framing competitors powerful tool address issues accountability data fidelity 
submission redistribute query optimization pier ufl query language places responsibility query optimization hands query author 
initial assumption application designers pier internet systems experts comfortable dataflow diagrams click router sql traditional complex query optimizations join ordering important massively distributed applications 
respect assumption simply wrong users administrators planetlab testbed far prefer compact syntax sql ufl lighthouse gui 
second issue open debate 
see multiway join queries filesharing application keyword query table instance joined far network monitoring 
choices join algorithms access methods remain important issue cases 
currently implementation sql language pier naive optimizer 
considered general approaches sophisticated optimizer discuss briefly 
static optimization natural consider implementation traditional style static query optimizer pier 
unusual approach pier lack metadata catalog 
pier mechanism store statistics table cardinalities data distributions indexes 
fundamentally place store agreed list tables modeled metadata 
natural workaround problem enduser application pier bake metadata storage interpretation application logic 
related approach store metadata outside boundaries pier 
table column statistics computed running approximate aggregation queries pier batch statistics stored disseminated canonical file format outside system 
band approach taken popular bittorrent filesharing network users exchange lists file names torrents websites case pier metadata course far richer 
analogous approach possible including possibility different communities users share independent catalogs capture subsets tables available 
design entirely separates optimizer core pier built add system 
currently pursuing static optimization approach pier reasons 
suspect properties large network quite volatile need runtime reoptimization endemic 
second key target applications distributed network monitoring naturally multi user multi query environment multi query optimization critical feature 
building single query style optimizer involve significant effort providing step direction 
distributed eddies order move runtime reoptimization multi query optimization implemented prototype version eddy optional operator employed ufl plans :10.1.1.34.8546
set ufl operators wired eddy principle benefit eddy ability reorder operators 
involved implementation stems stairs adaptive selection access methods join algorithms telegraphcq mechanism optimization fairly naturally added mix :10.1.1.10.3686
discussion realm mechanism components implemented framework pier dataflow model 
implementation intelligent eddy routing policy distributed system key performance proven challenging issue 
eddies employ basic functions routing policy observation dataflow rates operators observations decision mechanism choosing route tuples operators 
centralized environment observation happens naturally eddy intercepts inputs outputs operator 
pier node eddy sees data gets routed node 
difficult local eddy instance global decisions routing 
eddies communicate sites aggregate observations done naively significant overheads 
degree coordination regard open issue 
related pier currently major effort relational query system 
inspired related large number projects db internet communities 
brief overview connections :10.1.1.14.7680:10.1.1.14.7680
internet systems widely internet directory systems simple query facilities 
dns ubiquitous distributed query system internet 
supports exact match lookup queries hierarchical design data model internet node names implementation relying set currently root servers known ip addresses 
ldap hierarchical directory system largely managing lookup selection queries 
database research community mapping database research ideas ldap domain vice versa 
systems proved effective narrow workloads persistent concerns dns number fronts 
known filesharing huge phenomenon systems kazaa gnutella hundreds thousands users 
systems typically provide simple boolean keyword query facilities ranking short file names coordinate point point downloads 
submission redistribute addition having limited query facilities ineffective basic respects answering queries allow interested reader referred papers subject :10.1.1.1.6174
database systems course owe debt early generations distributed databases mentioned section ways pier architecture algorithms closer parallel database systems gamma volcano particularly hash partitioning query processing 
naturally parallel systems typically worry distributed issues multi hop internet routing face node churn 
terms data semantics pier closely resembles centralized data integration web query systems tukwila telegraph 
systems reached data multiple autonomous sites concern storage semantics sites 
point database community nascent area distributed stream query processing application pier supports 
aurora proposal focuses small scale distribution single administrative domain stronger guarantees support quality service query specification execution 
medusa project augments vision mariposa economic negotiation large agents 
tian dewitt analytical models simulations distributed eddies 
illustrated metrics eddy routing policies centralized systems apply distributed setting 
approaches node periodically broadcasting local eddy statistics entire network scale system pier 
terms declarative query semantics widely distributed systems promising bawa addresses network semantics shot continuous aggregation queries focusing faults churn execution 
pier context open issues remain capturing clock jitter soft state semantics complex multi operator queries 
hybrids db gribble case joint research agenda technologies database systems 
early vision databases bernstein medical example motivation called multiparty semantic mediation semantic challenge integrating peer databases heterogeneous schemas 
area main focus piazza project representative result mediating schemas transitively queries propagate multiple databases 
perspective pier related internet systems clear challenges benefits unifying abundant homogeneous data internet :10.1.1.14.7680
research agendas complementary pier interesting see query execution semantic mediation intersects time 
early effort regard peerdb project relies central directory server approach schema integration quite simple 
pier system address distributed querying data internet 
irisnet system similar goals pier design stark contrast irisnet uses hierarchical data model xml hierarchical network overlay dns route queries data 
result irisnet shares characteristics traditional hierarchical databases best scenarios hierarchy changes infrequently queries match hierarchy 
astrolabe system focuses hierarchy case hierarchy networks sub networks internet :10.1.1.16.4376
astrolabe supports data cube roll facility hierarchy maintain query roll ups 
system shares goals sophia distributed prolog system network information 
sophia vision essentially superset pier inasmuch relational calculus subset prolog 
date sophia provides distributed optimization execution strategies idea functionality coded prolog part query 
variety component operations pier explored internet systems community 
distributed aggregation focus dahlin starting point surveys earlier 
range indexing topic explored multiple projects favor pht scheme pier simpler proposals reuses dht requiring separate distributed mechanism works dht mercury appears starting point resiliency concurrency correctness issues secondary related 
began design pier expected mixture networking database issues expertise lead unusual architectural choices 
case 
anticipated cross domain issues start 
example pier aggressive multipurpose exercising overlay network interest networking researchers group design router event driven push dataflow core query execution interest database researchers 
challenges came surprise including ramifications metadata storage general purpose query engine interrelationships query dissemination index access methods 
believe current state pier strong basis remaining questions algorithmic architectural front 
addition issues covered sections include efficient processing recursive queries network submission redistribute routing high performance integration disk persistent storage challenges declarative query semantics soft state system unsynchronized components 
daniel abadi don carney mitch cherniack christian convey lee michael stonebraker tatbul stan zdonik 
aurora new model architecture data stream management 
vldb journal 
ron avnur joseph hellerstein :10.1.1.34.8546
eddies continuously adaptive query processing 
proc 
acm sigmod international conference management data pages dallas may 
bawa gionis hector garcia molina rajeev motwani 
price validity dynamic networks 
proc 
acm sigmod international conference management data paris june 
bernstein giunchiglia kementsietsidis mylopoulos serafini 
data management peer peer computing vision 
fifth international workshop web databases webdb june 
philip bernstein nathan goodman eugene wong christopher reeve james jr query processing system distributed databases sdd 
acm transactions database systems volume pages 
ashwin bharambe sanjay rao srinivasan seshan 
mercury scalable publish subscribe system internet games 
proceedings workshop network system support games pages 
acm press 
eric brewer 
lessons giant scale services 
ieee internet computing 
laud lipmaa 
eliminating applications accountable certificate management 
computer security 
miguel castro peter druschel ganesh antony rowstron dan wallach 
secure routing structured peer peer overlay networks 
proceedings th usenix symposium operating systems design implementation pages boston ma usa december 
miguel castro peter druschel anne marie kermarrec antony rowstron 
scribe large scale decentralized application level multicast infrastructure 
ieee journal selected areas communications jsac special issue network support multicast communications october 
mitch cherniack hari balakrishnan balazinska don carney cetintemel ying xing stan zdonik 
scalable distributed stream processing 
biennial conference innovative data systems research asilomar ca january 
clark 
design philosophy darpa internet protocols 
proceedings sigcomm august 
jeffrey considine li george john byers 
approximate aggregation techniques sensor databases 
proceedings international conference data engineering 
prakash johannes gehrke shanmugasundaram 
querying peer peer networks trees 
proc 
seventh international workshop web databases webdb paris france june 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proc 
th acm symposium operating systems principles sosp chateau lake louise banff canada october 
neil daswani hector garcia molina 
query flood dos attacks gnutella 
proceedings acm conference computer communications security pages washington dc usa november 
deshpande joseph hellerstein 
lifting burden history adaptive query processing 
proceedings th international conference large data bases september 
dewitt ghandeharizadeh schneider hsiao rasmussen 
gamma database machine project 
ieee transactions knowledge data engineering 
john douceur 
sybil attack 
proceedings st international workshop peer peer systems pages boston ma usa march 
funda erg kannan ravi kumar rubinfeld mahesh viswanathan 
spot checkers 
proceedings thirtieth annual acm symposium theory computing pages dallas tx usa 
acm press 
michal feldman kevin lai ion stoica john chuang 
robust incentive techniques peer peer networks 
proceedings th acm conference electronic commerce pages new york ny usa 
acm press 
phillip gibbons brad karp yan ke nath srinivasan seshan 
irisnet architecture world wide sensor web 
ieee pervasive computing october december 
michael goodrich roberto tamassia andrew 
implementation authenticated dictionary skip lists commutative hashing 
darpa information survivability conference exposition discex anaheim ca usa june 
goetz graefe 
encapsulation parallelism volcano query processing system 
proc 
acm sigmod international conference management data pages atlantic city may 
acm press 
steven gribble alon halevy zachary ives maya dan suciu 
databases peer peer 
proc 
fourth international workshop web databases webdb santa barbara may 
gupta agrawal amr el abbadi 
approximate range selection queries peer peer 
cidr january 
alon halevy zachary ives dan suciu igor tatarinov 
schema mediation peer data management systems 
th international conference data engineering bangalore india 
harren hellerstein huebsch loo shenker stoica 
complex queries dht peer peer networks 
st international workshop peer peer systems iptps march 
joseph hellerstein 
network data independence 
sig mod record volume september 
hodges morgan 
lightweight directory access protocol technical specification september 
ryan huebsch brent chun joseph hellerstein 
pier planetlab initial experience open problems 
technical report irb tr intel research berkeley november 
ryan huebsch joseph hellerstein nick lanham boon loo scott shenker ion stoica :10.1.1.14.7680
querying internet pier 
proceedings th international conference large data bases september 
ryan huebsch shawn jeffrey 
dht adaptive query processing federated eddies 
technical report ucb csd uc berkeley july 
zachary ives daniela florescu marc friedman alon levy daniel weld 
adaptive query execution system data integration 
acm sigmod conference management data philadelphia pa june 
frans kaashoek david karger 
koorde simple distributed hash table 
proc 
second international workshop peer peer systems iptps berkeley ca february 
olga raymond ng divesh srivastava 
evolution revolutions ldap directory caches 
proc 
international conference extending database technology edbt pages konstanz germany march 
submission redistribute david kempe jon kleinberg va tardos 
maximizing spread influence social network 
proceedings th acm sigkdd international conference knowledge discovery data mining pages 
acm press august 
eddie kohler robert morris chen john jannotti frans kaashoek 
click modular router 
acm transactions computer systems august 
john kubiatowicz david bindel yan chen steven czerwinski patrick eaton dennis geels ramakrishna gummadi sean rhea hakim weatherspoon weimer chris wells ben zhao 
oceanstore architecture global scale persistent storage 
proc 
ninth international conference architectural support programming languages operating systems asplos november 
guy lohman mohan laura haas lindsay pat selinger paul dean daniels 
query processing 
technical report ibm research report april 
boon loo joseph hellerstein ryan huebsch scott shenker ion stoica :10.1.1.1.6174
enhancing file sharing internet scale query processor 
proceedings th international conference large data bases september 
boon loo ryan huebsch ion stoica joseph hellerstein 
case hybrid search infrastructure 
proceedings rd international workshop peer peer systems iptps san diego ca february 
lothar guy lohman 
optimizer validation performance evaluation distributed queries 
proc 
twelfth international conference large data bases vldb pages kyoto august 
samuel madden shah joseph hellerstein raman 
continuously adaptive continuous queries 
proc 
acm sigmod international conference management data madison june 
petros maniatis mary baker 
secure history preservation timeline entanglement 
proceedings th usenix security symposium pages san francisco ca usa august 
petros maniatis tj giuli roussopoulos david rosenthal mary baker 
impeding attrition attacks systems 
proceedings th acm sigops european workshop leuven belgium september 
acm sigops 
ralph merkle 
protocols public key cryptosystems 
proceedings symposium security privacy pages oakland ca april 
ieee computer society 
mockapetris 
domain names implementation specification november 
nath phillip gibbons zachary anderson srinivasan seshan 
synopsis diffusion robust aggregation sensor networks 
proceedings acm sensys baltimore md usa november 
internet navigation domain name systems technical alternatives policy implications 
www 
org dns 
wee ng beng chin ooi lee tan zhou 
peerdb system distributed data sharing 
th international conference data engineering bangalore india march 
network simulator ns 
www isi edu nsnam ns index html 
larry peterson tom anderson david culler timothy roscoe :10.1.1.109.4681
blueprint introducing disruptive technology internet 
proc 
acm hotnets workshop princeton october 
dawn song adrian perrig 
sia secure information aggregation sensor networks 
proceedings sensys los angeles ca usa november 
raman deshpande joseph hellerstein 
state modules adaptive query processing 
th international conference data engineering bangalore india march 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proc 
acm conference berkeley ca august 
sylvia ratnasamy mark handley richard karp scott shenker 
application level multicast content addressable networks 
proceedings ngc 
sylvia ratnasamy joseph hellerstein scott shenker 
range queries dhts 
technical report irb tr intel research berkeley june 
sean rhea dennis geels timothy roscoe john kubiatowicz :10.1.1.10.5979
handling churn dht 
proceedings usenix annual technical conference usenix boston massachusetts june 
shah samuel madden michael franklin joseph hellerstein 
java support data intensive systems experiences building telegraph dataflow system 
acm sigmod record volume december 
jeffrey naughton 
adaptive parallel aggregation algorithms 
proceedings acm sigmod international conference management data pages 
acm press 
stoica morris karger kaashoek balakrishnan :10.1.1.105.3673
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm conference pages 
michael stonebraker paul aoki witold litwin avi pfeffer adam sah jeff carl staelin andrew yu :10.1.1.135.2031
mariposa wide area distributed database system 
vldb journal 
feng tian david dewitt 
tuple routing strategies distributed eddies 
proceedings th international conference large data bases september 
robbert van renesse kenneth birman dan werner vogel :10.1.1.16.4376
scalable management data mining astrolabe 
proc 
international workshop peer peer systems iptps cambridge ma march 
rob von behren jeremy condit feng zhou george necula eric brewer 
capriccio scalable threads internet services 
proceedings nineteenth acm symposium operating systems principles pages 
acm press 
dan wallach 
survey peer peer security issues 
international symposium software security 
mike larry peterson timothy roscoe 
sophia information plane networked systems 
proceedings nd workshop hot topics networks hotnets ii cambridge ma usa november 
matt welsh david culler eric brewer 
seda architecture conditioned scalable internet services 
proceedings eighteenth acm symposium operating systems principles pages 
acm press 
wilschut apers :10.1.1.56.701
dataflow query execution parallel main memory environment 
proc 
international conference parallel distributed info 
sys 
pdis pages 
praveen mike dahlin 
scalable distributed information management system 
acm sigcomm portland oregon 
beverly yang hector garcia molina 
improving search peer topeer systems 
proc 
nd international conference distributed computing systems icdcs vienna austria july 
vinod paul barford jha :10.1.1.118.6576
global intrusion detection domino overlay system 
proceedings network distributed system security symposium ndss february 
jeffrey chase 
trust verify accountability internet services 
proceedings th acm sigops european workshop leuven belgium september 
acm sigops 
