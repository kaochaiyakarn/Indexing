scaling reasoning actions relational database technology reiter variant situation calculus tightly related relational databases complete information initial situation available 
particular information initial situation seen relational database actions specified preconditions successor state axioms seen operations change state database 
show exploit correspondence build systems reasoning actions standard relational database technology 
exploiting standard relational dbms services system may able perform projection exploiting dbms querying services progression exploiting dbms update services large action theories 
key result realization natural conditions reiter basic action theories turn safe formulas basically negation form difference predicates regression progression preserve safeness 
fundamental property efficiently exploit relational database technology reasoning 
show action theories safe trying retain efficiency possible 
briefly discuss results extended certain forms incomplete information 
typically cognitive robotics assume cognitive agent robot equipped representation world specification agents actions affect world 
choices representation reasoning formalism adopt task 
situation calculus revised reiter emerging general tool express action theories reiter 
modelling world deal incomplete information various forms 
situation calculus typically incomplete information initial situation 
certain domains main issue cope incomplete information deal facts describe current state world 
order need able scale action theories especially able reason facts 
known reiter basic action theories tightly related relational databases complete information copyright american association artificial intelligence www aaai org 
rights reserved 
giuseppe de giacomo toni mancini dipartimento di informatica sistemistica universit di roma la sapienza salaria roma italy dis uniroma initial situation available 
particular information initial situation seen relational database actions specified preconditions successor state axioms seen operations change state database reiter fangzhen reiter 
show exploit correspondence build systems reasoning actions standard relational database technology cf abiteboul hull vianu 
particular exploiting relational dbms systems may able perform large action theories projection evaluate certain open closed formula world resulting executing sequence actions progression progress initial situation situation resulting executing sequence actions 
order perform task exploit standard dbms querying services perform second task exploit standard dbms update services 
key result realization natural conditions reiter basic action theories turn safe formulas negation form difference predicates regression progression preserve safeness 
fundamental property exploit relational database technology reasoning formulas dbms evaluate 
possible general assumptions domain closure transform formula safe formula requires large relations suitable cartesian products relation containing domain elements put serious ability dbms efficiently evaluate queries formulas 
discuss problem showing methods try retain efficiency possible transforming formula equivalent safe 
important stress crux setting standard relational database technology performing reasoning query evaluation formula evaluation deduction 
certainly done case complete information initial state reasoning action system case focus 
done case missing information supplied sensors see notion just time histories de giacomo levesque 
results principle extended cases incomplete information 
observe ability performing projection allows reasoning action system relational technology conjunction high level robot language interpreters exploit formula evaluation capabilities evaluating tests action preconditions levesque de giacomo lesp rance levesque 
situation calculus basic action theories account action change formulated language situation calculus mccarthy hayes reiter 
go language note components 
language particular sort action actions sort state situations sort object terms 
fact may allow specializing sort object creating sorts corresponding various types objects domain simplicity stick single sort object 
special constant denote initial situation actions occurred 
distinguished binary function symbol denotes successor situation resulting performing action relations truth values vary situation situation called relational fluents denoted predicate symbols situation term argument 
special predicate poss state action executable situation language formulate action theories describe world changes result available actions 
focus reiter basic action theories reiter 
basic action theory formed axioms denoted ds describing initial situation form initial database 
action precondition axioms dap form poss primitive action characterizing poss 
successor state axioms dss form fluent stating conditions holds function holds situation successor state axioms consistency requirement hold states case hold arguments 
successor state axioms take place called effect axioms provide solution frame problem reiter 
fact generated automatically starting standard effect axioms form applying called causal completeness assumption intuitively says second effect axiom consider functional fluents 
characterize conditions action causes true false successor situation cf 
reiter details 
unique names axioms primitive actions plus foundational domain independent axioms 
consider situation calculus formulas uniform intuitively uniform talks facts hold situation cf 
reiter 
main reasoning services reasoning actions system support solving called projection problem formula uniform sequence actions determine formula entailed action theory written ground situation resulting performing sequence actions initial situation cf 
reiter 
decide main results reiter variant situation calculus projection problem reduced checking certain formula holds initial situation formally ds called regression operator cf 
reiter intuitively recursively eliminates poss atoms favor definitions dap replaces fluent atoms ai logically equivalent expressions dss 
applying regression operator uniform formula results formula uniform initial situation ds reiter 
notice regression operator applied open formulas case statement holds instantiations open formula reiter 
relational databases highest abstraction level relational database order relational structure db formed finite set relations different arities associated predicate name formed finite set tuples fixed domain 
domain general infinite unique name assumption domain closeness enforced domain distinct constant object domain 
order query database db open order function free formula free variables predicates associated relations db 
answer query set tuples constants domain elements db substituting free variables closed formula true db 
long limit interest safe query see 
important issue databases concept safe formula abiteboul hull vianu 
mentioned relations database may infinite domain including naturals strings 
due problem avoiding queries return infinite answers arises 
suppose example deal database single monadic relation naturals extension suppose write query asks tuples belong 
answer query infinite number tuples 
happens additional relation want compute 
usual databases consider queries return answers finite independent database domain 
restrictions syntax needed mainly negation disjunction 
don go details just observe intuitively negation safe written difference disjunction safe operands relations schema 
formal definition safe formula specialized uniform situation calculus formulas situation section 
closing section need mention usually order queries databases expressed firstorder logic relational algebra ra 
relational algebra seen direct abstraction queries written sql standard query language adopted virtually relational database systems 
known abiteboul hull vianu strong relationship identified general fo formulas ra expressions 
particular maier proposes simple extension original codd ra order translation fo formulas ra expressions effective 
extension relies concept indexed relational table pair set tuples constants tuple distinct variables 
intuitive idea indexed relational tables represent order query free variables allowing refer tuples free variables computed 
extension ra equivalent original proposed codd 
particular traditional ra operators straightforwardly defined means operations domain indexed relational tables 
situation calculus relational databases section show relate situation calculus formalism relational database technology 
need introduce constraints basic action theories consider 
reinforce requiring unique name assumption closure sort object 
way force element object uniquely denoted single distinct constant 
additionally require fluent tuple objects theory ds logically implies 
complete information initial situation 
assumption characterized initial situation simply set facts form logically implied theory ds 
constraints quite severe certainly suitable certain applications reiter 
application allow assumptions loss generality formula evaluation logical implication exchanging entailment getting quite efficient method base reasoning de giacomo levesque liu levesque 
observations indicate exploit standard relational database technology base system reasoning actions 
particular relational database querying techniques perform formula evaluation able exploit sophisticated optimization techniques developed databases order deal large amounts facts 
relational database technology promises vehicle scaling reasoning actions limited form realistic domains require dealing lot information 
order develop system need decide tackle issues represent fluents values database states ii represent uniform situation calculus formulas queries database 
deal issues turn 
representing system states database states assume database explicitly store objects sort state inside tables database may considered snapshot taken fluent current situation 
words database keeps track truth values fluents objects current situation 
consider current situation initial situation represent database dbs defined follows fluent arity defined action theory associated table composed columns fk 
table populated tuples objects fluent true situation 
ds uniform situation calculus formulas queries moment concentrate safe formulas 
definition safe situation calculus formulas 
set safe situation calculus formulas smallest set formulas uniform atoms form safe variables sort object constants sort object possibly distinct function symbols sort action fluent 
safe provided free variable sort object free safe variables sort object occurring free 
safe safe provided free variables sort object safe situation calculus formula uniform 
easily define function maps indexed relational table equivalently relational algebra expression 
definition function 
safe situation calculus formula uniform 
defined follows 
atomic form variables sort object constants sort object distinct function symbols sort action axiom fluent ds 
form resp 
resp 
provided free variable sort object free provided free variables sort object safe formula variables sort object 
definitions place formally express inference initial situation evaluating queries corresponding database dbs 
theorem 
ds safe situation calculus formula uniform initial situation 
ds ans dbs 
words answer database dbs query modelled indexed table corresponding safe situation calculus formula initial situation exactly tuples constants substituted free variables resulting formula entailed ds entailed information initial situation assumptions constants 
safe basic action theories aim formula evaluation reasoning engine natural assume able evaluate formulas checking action possible fluent changes performing action 
relational setting proposed natural assume queries checking action precondition effect axioms safe 
words natural consider basic action theories precondition axioms form poss safe effect axioms form safe 
concentrate moment effect axioms 
safeness premises effect axioms guarantee safeness corresponding successor state axiom obtained applying causal completeness assumption 
interestingly answer question positive 
theorem 
effect axioms fluent safe 
formula corresponding successor state axiom safe 
observe assuming precondition effect axioms having safe premises quite spirit idea checking conditions evaluating database 
successor state axioms embed quite sophisticated technique deal frame problem 
theorem comes nice welcome surprise 
discussion feel comfortable introducing notion safe basic action theory 
definition safe basic action theory 
safe basic action theory basic action theory right part action precondition axiom right part successor state axiom safe formulas 
safe basic action theories interesting property regression preserves safeness 
theorem regression safe basic action theories 
safe basic action theory safe situation calculus formula uniform ground situation 
regression operator applied returns formula uniform safe 
observe theorem theorem gives mean exploit database technology deal projection problem 
theorem 
safe basic action theory safe situation calculus formula uniform situation formula initial situation obtained regression 
ans dbs 
theorem tells exploit relational databases solve projection problem get tuples constants entailed action theory particular proceed follows 
apply regression get situation calculus formula initial situation guaranteed new formula safe 
transform sql query immediate formula transformed relational algebra 
compute return answer resulting query database dbs 
dealing unsafe formulas nice solution case safe formulas 
enforce safeness 
database theory tells need enforce finiteness domain fact introduce additional relation database corresponding domain 
hypothesis finite domain query safe trivial way example query rewritten relation relation stores domain values observe new relation cartesian products may involved query store huge number tuples making query answering efficiency critical 
extend approach deal unsafe formulas need reinforce assumption una state sort object finite 
corresponds introduce new fluent obj contains initially number elements model denoted distinct constant successor state axiom states change actions 
predicate obj defines extension sort object 
assumption introduce database dbs relation obj denotes exactly objects obj 
obj obj place straightforward uniform situation calculus formula safe 
caution put order retain efficiency query answering reduce reasoning query evaluation initial database 
problem query safe forced introduce occurrences obj table typically formed huge number tuples 
unfortunately general overcome carefully choose different alternatives best way translate unsafe uniform situation calculus formula query current database 
course functions defined reduce definition dealing safe formulas heuristics defined choosing efficient translation 
give possible heuristic reasonable assumption size obj relation larger size relation database 
assumption heuristic allows choose step apply de morgan laws formula computing cost alternative 
obj relation consists tuples cost evaluating ra formula sum factors time table obj obj denoted times obj built 
cost incremental fashion considering constant cost evaluating subformulas 
way allowed independently choose level formula tree apply de morgan laws 
uniform situation calculus formulas initial situation outermost operator common free variables sort object 
additional free variables sort object occur additional free variables sort object occurring 
describe detail case analogous 
situation calculus formula translated 
identify possible alternatives translating translate directly apply de morgan laws order obtain equivalent formula 
translation option obj obj obj translation option obj obj assuming ra expressions computed cost formula formula assume simplicity cost second alternative lower formula rewritten pushing negation 
calculations full rewrite kind unsafe formulas order achieve efficient translation occurrences cartesian products obj table 
define function firstly applying heuristic inserting suitable cartesian products obj table 
details omitted lack space full 
performing actions changing database normally interested querying current database state possibly exploiting regression order projection 
hand time time want perform progression transform action theory updating current situation results performing sequence actions 
results changing database content order reflect new situation 
assumptions unique name assumption closure object domain complete information initial situation results fangzhen reiter show progression difficult general simple 
relational technology potentially allow perform progression exploiting standard update mechanisms developed databases take advantage transactional support guarantee consistency case failure progression 
observations mind develop account progression relational setting proposed far 
order need clarify successor state axioms exploited specification updates perform 
successor state axiom fluent 
extract effect axioms instantiated ground action 
order change database accordingly assuming tables corresponding respectively need perform sql commands unique transaction delete exists select xn xn fn insert select xn fn tuple contained table update associated action update inserted table tuple table update deleted 
clearly corresponds specified successor state axiom instantiated action consistency requirement holds tables disjoint 
exchanging order statements change result 
defined updates exploiting result progression mentioned get theorem theorem 
safe basic action theory ds defined usual 
safe situation calculus formula uniform ground situation db database obtained dbs performing updates corresponding action ai order 
ans db 
words order evaluate formula situation resulting executing sequence actions update database update commands evaluate formula resulting database 
update commands progress sense fangzhen reiter database action theory represents 
worth noting transactional support relational dbms exploited avoid leaving database undesired state case progression fails issuing commit statement progression successfully completed 
exploited 
cases regression generates query big complex efficiently evaluated progression alternative proviso evaluation transaction corresponding progression gives explicit roll back command restore initial situation 
fact technique shown quite effective practice dealing projections involving long sequences actions 
observe state theart dbmss computations main memory disks directly updates mentioned far usually performed fast way main memory issuing commit statement 
described reasoning actions complete information potentially scaled exploiting standard relational technology 
prototype system implementation reported de giacomo currently construction experimental results promising 
important stress advanced form reasoning rely formula evaluation potentially take advantage relational technology proposed 
line currently working extending approach reasoning incomplete information missing information supplied sensors setting de giacomo levesque 
abiteboul hull vianu 
foundations databases 
addison wesley publ 
de giacomo levesque 
projection regression sensors 
proc 
ijcai 
de giacomo levesque 
approaches efficient open world reasoning 
logic artificial intelligence 
kluwer 

de giacomo 
exploiting relational dbms reasoning actions 
proc 

de giacomo lesp rance levesque 
con golog concurrent programming language situation calculus 
artificial intelligence 
fangzhen reiter 
progress database 
artificial intelligence 
levesque reiter lesperance lin scherl 
golog logic programming language dynamic domains 
logic programming 
liu levesque 
tractability result reasoning incomplete order knowledge bases 
proc 
ijcai 
maier 
theory relational databases 
computer science press rockville maryland 
mccarthy hayes 
philosophical problems standpoint intelligence 
machine intelligence 
reiter 
frame problem situation calculus 
artificial intelligence mathematical theory computation 
academic press 

reiter 
knowledge action logical foundations describing implementing dynamical systems 
mit press 
