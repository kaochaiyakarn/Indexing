model checking middleware event driven real time embedded software william deng matthew dwyer john hatcliff georg jung robby singh department computing information sciences kansas state university 
component frameworks corba component model ccm middleware services corba event service increasingly build safety mission critical distributed real time embedded dre systems 
novel model checking infrastructure checking global temporal properties dre systems built top real time corba event service ccm architectures 
describe building support oo structures communication layers directly extensible model checker leveraging domain properties related priorities scheduling timing dramatically reduce costs checking realistic systems 
modern distributed systems built sophisticated component middleware frameworks enterprise java beans corba component model ccm microsoft net 
real time versions frameworks rt corba ccm increasingly build safety mission critical distributed real time embedded dre systems 
displays typical architecture systems loosely coupled components communicate middleware layers hide complexities associated moving data network connections 
implementations components middleware extensive objectoriented oo features design patterns facilitate reuse 
middleware frameworks include sophisticated services support functions commonly required distributed systems transactions persistence particular loose coupling components achieved asynchronous event communication infrastructures corba event service 
event services allow components easily plug system publish subscribe mechanisms provide support defining event types event filtering event correlation 
real time event services provide capabilities specifying real time quality service attributes 
typical concurrent architectures component include supported part army research office daad darpa program afrl contract rockwell collins intel honeywell technology center nasa langley research center ncc 
nichols hall manhattan ks usa 
deng dwyer hatcliff jung robby singh cis ksu edu technical report santos tr component component component component component middleware component component component fig 

middleware architecture distributed system threads real time event services achieve greater control scheduling timing constraints providing thread pool 
approach components passive include threads 
event service provides manages threads execute event handlers subscribing components event published 
interested reasoning component dre systems model checking techniques 
previous relevant task falls roughly categories high level modeling analysis asynchronous systems checking oo software 
high level modeling verification asynchronous systems embodied tools spin prominent theme research computer aided verification 
existing tools modeling distributed systems lack direct support oo features dynamically created objects component connections ubiquitous modern distributed systems 
state representation state exploration techniques existing tools general purpose optimized take advantage numerous opportunities reduction enabled considering particular threading models scheduling policies dre systems 
second research produced checking tools bandera java path finder jpf dspin directly support checking concurrent systems implemented oo languages providing built representations dynamically created objects garbage collection despite popularity component frameworks potential utilized mission safety critical applications relatively little done enhance existing software model checking techniques provide native support complex event middleware distributed component systems exploit specific properties dre systems scale analysis feasibly approach real life problems :10.1.1.29.3872
address lack support built cadena development verification environment building dre systems ccm 
cadena supports specification components ccm interface definition language idl extensions enable multiple forms light weight specification component behavior dependencies 
cadena sophisticated gui component configuration selection real time middleware configuration parameters design level slicing dependence checks extensive auto coding facilities inside ibm eclipse open source develop ment environment provides support development real time ccm systems 
addition light weight static analyses mentioned built model checking backbone cadena focusing safety event sequencing properties 
previous cadena translated ccm system descriptions input language dspin model checker 
dspin directly supports dynamic creation deletion objects suited modeling oo features modern distributed systems 
dspin provide direct support threading model scheduling policies real time middleware state space reduction techniques tailored systems 
describe new model checking core cadena provides substantial advances representation middleware models previous significantly increases ability model check properties ccm dre systems 
specifically contributions follows 
introduce new model checker called bogor addition supporting direct modeling oo software variety sophisticated state space reduction techniques includes powerful extension mechanism allows new primitives added modeling language 
describe model real time corba event service bogor extension facilities 
compared previous approaches modeling publish subscribe systems approach allows direct modeling realistic systems 
describe bold stroke ccm architecture descriptions lightweight behavioral annotations realized bogor models 
series strategies leveraging timing scheduling properties soft real time systems bogor primitives allow checking systems infeasible check 
checking infrastructure check avionics systems boeing rockwell collins 
focus boeing bold stroke application framework discuss strategy influenced actual bold stroke development process 
fact believe context things interesting relevant address analysis widely general purpose middleware frameworks languages design functionality features analysis tools mesh actual industrial development process 
close cooperation industry gives better feedback feasibility introduced techniques purely theoretical approach provide 
gain insight exploit domain information scheduling policies scale model checking significantly 
methods introduced suggest general approaches exploiting domain info may adaptable component architecture models 
detailed formalization model checking strategy employ extended version 
due space constraints focus giving motivation overview implementation framework 
completed robust implementation bogor 
section gives brief overview bold stroke describes aspects bold stroke development process attempt support presents strategy modeling bold stroke system behavior 
section gives overview ccm cadena support development dre applications ccm 
section describes corba real time event channel highlights factors influence design appropriate models 
section presents strategy modeling bold stroke systems bogor 
section reports experimental studies carried validate approach 
section discusses related section concludes 
bold stroke modeling approach bold stroke boeing bold stroke program example corba middleware embraced dre domain reasons outlined 
bold stroke product line program providing object oriented mission critical avionics software variety military aircraft produced boeing 
avionics software acts center mission control aircraft pilot 
manages cockpit displays navigation tactical sensors weapon deployments 
complex systems hard soft real time deadlines involving large amounts periodic aperiodic processing support thousands operating modes 
addition software developed military aircraft maintained updated course years 
development process repeated update update aims preserve legacy software possible reduce cost risk 
bold stroke represents significant technological advance boeing previous mission computing development practices largely assembly code 
aspects bold stroke system functional real time behavior attempt model cadena 
choose focus supporting system design assembly phase boeing engineers pin pointed challenging aspects system construction 
phase component integrator attempts satisfy functional soft real time requirements system hooking general purpose project specific components drawn component library selecting distribution strategies execution priorities particular event data communication layers 
rate monotonic scheduling theory conventional schedulability analysis techniques employed ensure real time deadlines achieved 
inability reason high level control flow abstractions system data state leads costly iterations test process 
specifically engineers desire support reasoning intra component control flow realized conventional control constructs conditionals locking mode states components effect mode states enabling disabling particular component actions communication patterns inter component control flow realized event subscription patterns orderings broadcast reception correlation events method calls 
modeling approach building approach garlan model checking systems factor cadena system descriptions parts collection semantic descriptions components system developer specified application dependent capture aspects collection reusable models run time event delivery infrastructure provided developer re application cadena supports capture semantics inter component communication identified aspect collection connection actions specifies connection topology components hooks component models part middleware models part 
component models component models defined simple modeling language similar promela includes object method calls 
modeling intra component control flow required aspect straightforward control constructs language 
reasoning system mode states required aspect fits nicely verification model checking mode variables small finite domains component enabled disabled mode 
model modes enumerated types modeling language 
summary component models need include simple control flow skeletons transition actions consisting reads writes mode variables event publish receives method calls local objects 
middleware infrastructure models modeling inter component communication difficult semantics corba communication layers captured level abstraction fine expose interleavings lead property violations coarse avoid state space explosion systems large number components 
define variants trade precision space time varying degrees bogor extension facilities 
involves defining bogor extensions represent event queues customizing bogor modules particular scheduling strategies rt corba middleware 
forming system model developer chooses particular variant middleware model library provided cadena 
connection actions bogor native support method calls dynamic object creation object allows components connected communication layer passing object manner closely follows actual implementation 
accordingly system initialization modeled sequence bogor object creation statements create models components middleware services followed sequence connection actions pass appropriate establish connectivity 
pragma cadena module data timeout enum component consumes enum enabled component modal consumes fig 

ccm cadena artifacts excerpts corba component model cadena ccm component interface definitions ccm architecture system realized collection components 
component component interface consisting ports connect components 
different kinds connections interface connections event connections 
port unidirectional types ports interface supplier facet port interface consumer receptacle port event supplier event source port event consumer event sink port 
ccm interface definition language idl define component interfaces consisting named ports interface event types port types 
gives ccm idl defines interfaces component types called modal component types example simple avionics system called define 
definitions illustrate basic mechanisms interface event connections 
type interface connection defined interface definition collection method signatures corresponding conventional notion interface java corba 
interfaces provide mechanism components exchange data synchronous method calls 
frequently interface contain accessor method get mutator method set manipulate data associated particular data field methods abbreviated declaring field attribute particular interface idl compiler automatically generate accessor mutator methods 
example interface contains single attribute data readonly qualifier indicates accessor method get data interface 
type event connection defined event type declaration essentially record structure containing zero data fields 
example timeout event types zero data fields application interested arrival events payload needed 
timer interface data ports event ports facet interface provided receptacle interface source event published sink event consumed event correlation correlation bm navigator timer bm device gps bm passive bm airframe stale fresh bm modal disabled enabled bm modal enabled disabled fig :10.1.1.29.3872:10.1.1.29.3872

simple avionics system bm display display bm component type declares ports provides facet interface type name uses receptacle interface type name publishes event type port consumes event type port 
additionally component declares component mode variable attribute type 
general attributes component configuration represent aspect component state 
ccm systems presents ccm architecture simple avionics system shows steering cues pilot navigational display 
pilot choose different display modes tactical display mode displays steering cues related tactical mission objective navigation display mode displays cues related navigational objective 
cues navigation display derived part navigation steering points data entered navigator 
system realized collection components coupled interface event connections 
input position data gathered periodically rate hz gps component passed intermediate airframe component realistic system take position data variety sensors 
component produce cue data display air frame position data 
navigator component polls inputs plane navigator rate hz form data 
data form navigational steering cues 
polls pilot steering mode rate hz enables disables accordingly 
time occurrence timeout rate referred frame length frame associated hz rate milliseconds 
architectural aspects example peculiar real time bold stroke applications 
note periodic processing achieved having component gps subscribe periodic time timer component mode dat dat dat component modal mode dat dat getdata dat get set fig 

cadena property specification cps excerpts timer published rt event channel rt event channel contains dedicated timer threads publish events 
details event channel threading model section 
second bold stroke applications follow cases control push data pull architecture data transferred components step process 
data producer gps publishes event indicating updated data ready consumed 
subscribing data consumer airframe receives event calls accessor method facet provided supplier type retrieve data 
threads block waiting data available simplifies design real time aspects 
note strategy component connections come pairs consisting asynchronous event connection notification synchronous interface method connection fetching data 
cadena system specifications far presentation example system specification artifact ccm idl specifies interfaces components 
generate system models appropriate model checking additional specification forms needed 
modeling strategy section need transition system specifications components specification connection information address turn 
ccm include mechanism giving high level description behavior components 
cadena add component property specification cps format allows developers state different light weight semantic properties components including mode aware dependency specifications transition system descriptions 
presents transition system portion cps description modal component type 
component type implements variant control push data pull strategy handle situations component airframe depends data updated frequently clients require data 
instance example system airframe component fetch data immediately gps notified gps data available simply sets attribute indicate data stale calculated gps data obsolete notifies clients data available 
retrieves calculates new data gps ordered clients facet 
cps behavior captured mode variable status links attribute declared idl 
behavior part provides coarse description incoming ports methods example handler method incoming event port called push method corba terminology interface method get data facet port accessor method data attribute interface 
handler method receives event sets mode stale publishes event 
interface method checks mode updates internal data component accordingly returning value 
value updated mode reset fresh subsequent calls clients data returned retrieving new input receptacle 
note real avionics system significant numeric computation transform raw gps data form useful components airframe 
represent computation model significant reasons 
actual systems supplied boeing computation stripped security reasons avoid dissemination information 
second boeing engineers primarily concerned reasoning control properties associated modes data computations stripped influence modal behavior system 
essence boeing engineers performed manual abstraction system abstraction produces system suited model checking remaining mode data domains finite small 
represent lack concrete information stripped data values representing associated variables corba type top value corba type hierarchy 
addition statement dat getdata assignment statement 
declares dataflow dependency dat getdata abstracts situation series assignments method calls actual code transforms raw data received port refined value held dat variable 
dependency declarations components cadena model checking left generated models influence properties checked 
modal components modes enabled disabled 
modes set facets provided modal components 
shows modal type component 
modal component disabled events received simply discarded component 
enabled component responds control push data pull system import cadena common cadena rates hz deployment 
airframe implements connect gps connect gps implements modal connect airframe connect airframe 
fig 

cadena assembly description excerpts strategy responds airframe calling airframe get data method 
having introduced cps format specifying component behaviors turn cadena assembly description cad format specifying component instance allocations connection information 
ccm allows components dynamically created dis connected bold stroke applications follow typical practice safety mission critical systems employ static component allocation configuration policy creating connecting components system initialization phase 
corba specification provide dedicated language static system configuration 
xml component assembly description specified leaving tool developers free build variety configuration facilities produce xml data 
cadena provides graphical textual form incremental static configuration facilities syntax tree textual form providing canonical representation 
displays fragment textual cadena assembly description cad example system 
cad developer declares component instances form system event channel rate groups distribution locations 
receptacle event sink ports connect clause declares connection port current instance port component provides interface event 
follows convention connections declared client side interface event connection 
event sink port connection uses clause indicate rate group thread run event handler event dispatch thread rate groups explained section 
type checking procedure ensures typed connections 
real time event channel section give detailed description corba real time event channel elements shown 
description basis explaining bogor event channel models cadena uses model checking bold stroke systems 
bold stroke applications conceptual level component event source ports connected event sink ports implementation component supplier component supplier push push proxy consumer proxy consumer thread pool subscriber list 
correlator subscriber list 
hz hz hz hz dispatch queue event channel proxy supplier proxy supplier fig 

rt corba event channel hz dispatch queue push push component consumer component consumer event communication factored real time corba event channel 
infrastructure central bold stroke computation provides mechanism communicating events pool threading model time triggered periodic events event correlation 
order shield application components physical aspects system product line flexibility run time efficiency components passive component methods run event channel threads dispatch events calling event handlers push methods corba terminology associated event sink ports 
event channel layer engine system sense threads pool drive computation system 
defined corba standard event connection consists types objects supplier event source port consumer event sink port 
object type consumer provide push method event handler method takes event argument 
object type supplier stores push method 
connect supplier consumer supplier set point consumer push method 
publish event supplier simply calls push method event argument pushes event 
complying scheme event channel offers proxy consumer push method supplier connect 
similarly consumer event channel provides proxy supplier point consumer push method 
simple method pattern allows connections 
consumer interested events published supplier proxy consumer inside event channel features list consumers event originating supplier pushed 
list called subscriber list consumers subscribe events supplier 
way consumer supplier needs handle connections event channel multiplexing events done inside channel 
event channel provides event correlation event filtering mechanisms 
example system correlation instance combine event flows airframe display 
semantics correlation events event channel waits instance published creating notification event dispatched consumer correlation 
semantics correlator defined automaton event traces derived correlation expression 
thread pool shown contains threads necessary support rate groups hz hz hz example system 
rate monotonic theory hz thread highest priority followed hz thread hz thread 
event dispatch queue associated thread tr holds pairs event dispatched event sink port subscribed event 
thread tr dispatches event queue running push method associated port related proxy supplier event passed parameter 
periodic computation initiated time triggered events er rate events associated event sinks navigator gps 
specified rate hz gps event sink special internal timer thread displayed places pair er queue component port subscribes timeout event er 
thread tr dispatches events calling push methods subscribers proxy suppliers turn may execute methods calls publish events drive computation 
different paths event channel take way particular subscriber sk 
normal path proxy consumer obtains sk rate priority declared sk handler recall discussion non time triggered event sink port rate identifier specified configuration time indicates pool thread dispatch event subscribed subscriber list puts pair sk queue tr 
second sk event correlation associated pair sk placed queue 
correlator state machine advanced account publishing correlator reaches accepting state pair sk ec placed queue matches rate declared sk handler ec correlation result event possibly combines information events correlated 
third path optimization path short cuts steps event dispatch process observation correlation associated sk subscriber sk handler declared rate priority thread tr running publisher sk immediately placed dispatch queue thread tr dispatching case rt event channel implementation optimizes having tr directly call push method sk parameter bypassing queueing dequeuing sk 
detail trace example considering hz thread look follows 
system interrupt causes event channel special timer thread place hz timeout pair sk hz rate group dispatch queue hz time subscriber sk case sub timeout port gps 
hz queue longer empty hz rate group thread started call event handler push method gps 
running gps handler timeout event reads data physical gps device issues event calls push method connected proxy consumer inside event channel 
method executed thread typically queue event dispatch queues subscribing components thread groups 
subscriber event gps airframe belongs hz thread group case optimization path thread directly calls event handler airframe 
handler pushes event consumer proxy associated airframe port 
proxy longer list subscribers queues event dispatch queue component forwards event consume events respectively 
state change reflects incoming event executed hz thread potential queueing correlated event display rate group dispatch queue 
components run hz events hz dispatch queue hz thread continue execute 
assuming component enabled component disabled push method handles incoming event component simply ignores event calls airframe facet fetch newly available data 
call airframe fetches data gps turns fresh mode returns data 
receiving updated values issues event 
proxy forwards event correlator state indicating airframe sent event correlated event queued display 
hz group event queue executed thread 
thread runs push method display calls facet receives new data calls facet airframe fresh mode immediately returns new data 
data processed displayed hz thread ends hz timeout 
behavioral models cadena assemblies representing component structure connections noted section connections current bold stroke systems established initialization phase remain fixed lifetime system 
means connection information represented need stored state vector 
similarly interpretation cadena models bogor seen phases buildup phase establishes static part system single atomic step connected system checked state vector discussed 
cad 
component enum enabled disabled cad 
enabled cad 
cad 
cad 
data data cad 

cad 
airframe 
eh cad 
event data dat enabled goto 
enabled goto dat dat cad 
data airframe data goto cad 
data data dat goto 

fig 

bogor component assembly descriptions excerpts buildup phase begins creation component instances followed actions connect ports instance ports instances case facets model real time event channel case event source sinks 
shows bogor cad extension supports buildup data structures representing components 
extension shown declares new types event component type bir variable 
extension defines number operations implemented java methods extension 
note example operation declares bir function displayed bottom event handler events flowing port 
declaration component structure illustrates method 
action causes bogor port added subscriber list recall discussion section port airframe 
implementing bogor extension define state manager walks extension state produces representation suitable placing model checker state vector 
flexibility leveraged queue type type cad 
event 
queue 
queue cad 


type cad 
event cad 
event queue 
queue 
queue dequeue 

second 
goto goto fig 

bogor dispatch queue thread model excerpts variety ways omit various fields data vector form abstractions state build canonical representations necessary achieving symmetry reductions representations sets 
cadena models mechanism avoid storing static connection information state vector 
allows increase granularity actions initialization middleware actions soundly reducing number interleavings 
traversal subscriber lists carried atomically depending priorities threads involved chance interfering updates subscriber lists execution begins 
representing component behavior event handlers methods ccm components represented bir functions 
shows bir model event handler event sink modal component type defined cps definition 
transitions capture handler behavior defined cps file component disabled handler simply returns fetches data port updates local data publishes event port 
example bold stroke systems supplied boeing concrete internal data components consists exclusively values component mode variables enabled disabled values mode variable component modal 
discussed section boeing engineers away data values actual numerical data produced gps devices 
values represented bir extension type data equivalently type cps single dummy value 
state mechanism introduced component fields type data held state vector 
means component models contribute values mode variables state vector 
representing real time event channel bir model real time corba event service represents event dispatch queues section 
recall section dispatch queues hold event subscriber pairs 
bogor model queues modeled queue pair extensions 
illustrates hertz rate queue pending event dispatches thread cyclically dequeues dispatch pairs invokes component event handler encoded pair note pair type declarations elided improved readability 
correlator represented deterministic finite state automaton transition function encoded static transition table 
correlator single state variable holds current correlator state 
structure fixed system transition tables held state vector 
summary data portion state vector summarize modeling strategy discussed state vector components related data state cadena systems 
observable state cadena assembly comprised non fixed system data 
noted correlator transition tables subscriber lists component connection information fixed considered part observable state 
definition 
cadena data states tuples 
ck stores data states component instances comprised possibly empty set mode attributes defined ci component type 
qr 
rate specific queues pairs recording dispatch event component 
stores current states event correlation recognition automata 
records abstraction time trigger timeouts 
records priority current thread executed 
initial state defined instance modes set initial values correlation automata set start state rate specific queues empty priority variable set highest priority 
addition values local variables component handlers methods implementation push methods rate specific threads observed outside method activation threads property observables considered part observable state 
local variable held state vector corresponding method activations 
strategies modeling scheduling time behavior cadena systems driven triggering middleware timeouts described section controlled scheduling policies thread pool real time event channel 
finding effective strategy modeling timeouts thread scheduling central issue construction cadena models 
analyzing concurrent systems model checkers attempt exploit knowledge specific timing scheduling strategies explore possible interleavings concurrent actions 
followed approach allow timeout events occur non deterministically system transition allow actions different threads interleaved non deterministically consideration priorities scheduling constraints 
strategy sound covers possible system behaviors number states generated impractical smallest systems 
subsections describe reduce infeasible interleavings 
strategy incorporates constraints observations priority scheduling timeout policies implemented real time middleware 
priority scheduling having model checker non deterministically explore interleavings considering thread priorities obviously introduces schedules infeasible actual system schedule continues execute transitions lower priority thread higher priority thread enabled 
inter rate group timeout constraints having model checker non deterministically generate timeout events introduces schedules infeasible actual system hz timeout event occur frequently hz timeout event 
strategies reduce infeasible interleavings account appropriate relative frequency timeout events account constraints exist timeouts different rate groups 
intra rate group timeout constraints having model checker non deterministically generate timeout events introduces infeasible schedules timeout rate group occurs events current frame dispatched previous timeout group dispatched 
constrain generation time events ensure timeouts rate group triggered quickly 
strategy constrains occurrence timeouts considering relative lengths real times frames constrains scheduling considering priority information 
lazy time priority scheduling addition techniques strategy strategy considers timing estimates system transition allows additional infeasible schedules removed consideration 
representing priority scheduling information bold stroke systems priority scheduled results rate monotonic analysis set harmonic rate groups 
cad call illustrated assigns rate priority component handler event 
default non deterministic scheduling policy bogor implemented module calculates set enabled transitions state passes set state exploration module explores possible outgoing transition 
reporting experiments refer models strategy priority unaware 
cadena models bogor plugin intercepts set enabled transitions state selects transition highest priority passes single transition state exploration module 
expected yields dramatic reductions state space shown section improves precision state space infeasible schedules eliminated ones lower priority transition executes higher priority transition enabled 
refer models strategy priority aware 
variations plugin models allow interleaving timeouts highest priority enabled transition 
representing intra rate group timing constraints treatment time determines part fidelity model respect real system behaviors 
detailed timing information available keep track time component actions executed time value trigger periodic events 
timing information available reduce occurrence timeout events intra inter rate group constraints 
intra rate group constraints consider involve notion frame overrun 
frame overrun occurs timeout event er rate group occurs events triggered directly indirectly previous timeout processed rate group thread tr 
normal situations timeout er occurs dispatched events arrive event channel dispatch queues including associated thread tr idle events associated dispatched 
time tr remains idle waiting timeout called slack time 
system frame overrun error thread tr slack time unable finish timeout er arrives 
note exploring state space systems arbitrary frame overruns modeled results huge number additional system behaviors infeasible actual timing data considered timing data allow conclude cases frame overruns occur 
frame overruns real source bugs bold stroke systems engineers tools methods detecting types errors 
accordingly reduce state space explore strategies 
strategy call overruns assumes frame overruns occur 
implemented having model checker scheduler emit timeout event rate group enabled transitions associated rate group models situation tr idle 
second strategy call limited overruns implemented having model checker scheduler emit timeout event er timeout event remaining dispatch queue non timeout events may waiting queue dispatch 
intuitively model includes overruns spill frame include overruns processing late additional frame 
representing inter rate group timing constraints strategies related buffer overrun previous section constrain timeout events considering occur relative timeouts rate group 
strategy call relative time rt strategy timeout events considering timeout occur relative timeout different rate group specifically take advantage fact rate monotonic scheduling theory bold stroke systems frame associated rate evenly divided number frames rate higher example system frame slowest rate hz divided hz frames hz frame divided hz frames 
longest frame period frame associated lowest rate called hyper period 
general priority scheduled models assuming overruns strategy relative time model enforces constraints related issuing timeouts single timeout issued slowest rate group hyper period timeouts rate groups ri rj ri rj issued ri rj timeouts rate ri issued rj frame 
constraints determine total number relative ordering instances timeouts may occur hyper period 
shows bogor code threads model strategy 
thread increments abstraction time tick increment time variable represents passing time corresponding shortest frame system tick represents hz frame 
time variable wraps ticks corresponds fact hz frames hz 
thread models behavior rate specific timer threads middleware discussed section 
thread monitors time observes change time value passes case statement see timeout events dispatched point 
time tick represents period shortest frame new timeout event fastest rate issued pass case statement 
example system hz timeout happens fourth tick 
represent occurrence timeout thread enqueues timeout event standard push call 
explanation clear rt model establishes occurrence timeouts relative relate timeout occurrences time required component event handlers method execution 
important understand timeout actions may occur respect actions occur inside component handlers actions interrupted timeouts 
cad 
component timer 
timer cad 
timer cad 
timer timeout timeout 
time time goto 

hz case time goto time goto 
timer timeout cad 
timeout goto 
hz case 
hz hz fig 

timer thread models excerpts hz hz time priority delay hz interleaving fig 

relative time environment hz timeout hz execution step hz timeout hz execution step see model safely approximates interleavings timeouts component actions constraint frame overruns consider 
illustrates points system execution contains hz hz rate processing 
hz timeouts queued point frames point 
hz timeout event dispatched due higher priority 
actions associated hz component processing complete point model checker scheduler begins consideration lower priority actions hz timeout dispatched leading hz component processing 
overruns assumption entails processing hz component actions require time period hz frame hz timeout occur point 
modeling actual time required carrying component actions impossible determine relationship time required hz component action processing duration point time hz timeout duration point 
safely cover possibilities allow relationship durations 
model relationships adapt bogor standard scheduling hz hz time hz hz fig 

lazily timed environment module consider interleavings enabled timeouts enabled transitions 
right interleavings hz timeout enabled transitions performed hz component processing illustrated 
white circle represents dispatching leftmost hz timeout event 
followed black circles representing transitions hz component processing branch point represents choice hz timeout left dispatching queued hz timeout event right 
hz processing selected choice hz timeout hz processing repeats enabled hz transition illustrated grey circle 
lazily timed components relative time model timeouts arranged proper order ratio respect constraints guarantee interval time outs appropriate correspond period 
means model may interleavings timeout ri occurs prematurely respect action sequence duration period ri 
example hz component processing point guaranteed time hz timeout point interleavings timeouts hz processing rt model infeasible 
lazily timed lt component model addresses leveraging worst case estimates running time components available cadena systems support rate monotonic analysis 
model configured granularity timing information available 
consider worst case timing estimates event handlers 
conceptually estimates determine handler run interruption timeout occurs model non deterministically interleaves action sequences handler timeouts higher priority actions follow timeouts 
model modifies data associated time record intra time normalized common factor handler durations timeout periods guards adjusted accordingly component handler modified include increment time 
illustrates increments performed 
shows execution hz component processing subsequent completion hz processing frame 
cases worst case time estimate hz processing runs point equal timeout timeout occurs point timeout occurs point interrupts hz actions 
case time incremented worst case timing estimate currently running hz event handler state space exploration algorithm proceeds note branching state space case 
case time incremented timeout point non deterministically chosen prefix currently running hz handler executed hz timeout performed 
choosing prefix handler actions modeling possible distributions timing actions handler 
remaining portion handler left state space exploration algorithm hz timeout subsequent hertz processing performed 
difference point point worst case execution time handler assigned remaining portion duration 
model seen refinement rt model 
eliminates interleavings timing estimates guarantee group highest priority enabled transitions guaranteed complete timeout 
example right light grey circles correspond hz component handler body worst case execution bound time hz timeout branching portion state space lower left outgoing arcs hz timeouts eliminated 
experimental results table shows results evaluating strategies example systems provided boeing engineers 
example read system description scenario example threads rate groups hz hz hz components event correlation events generated second hyper period hp 
scenario give data models incorporate modeling strategies previous section 
model 
scheduling policy thread groups scenario priority unaware intra group timing constraints 
job executions interleaved 
rt uses policies priority aware scheduling relative time environment implement frame overruns strategy highest priority thread 
rt rt assumes frame overruns threads 
lt rt uses lazy time environment model 
example collect number transitions trans states time memory consumption mem search 
numbers transitions states listed steps model marked invisible atomic bogor save states 
experiments run pentium ghz gb ram java platform 
example system rt rt lt basic scenario trans threads hz states components time sec sec sec sec events sec hp mem mb mb mb mb multi rate scenario trans threads hz hz states components time min sec sec sec events sec hp mem mb mb mb mb scenario trans threads hz hz hz states components time sec sec sec events sec hp mem mb mb mb medium scenario trans threads hz hz states components time min min events sec hp mem mb mb table 
experiment data bogor collapse compression heap symmetry process symmetry reductions experiments 
experiments represents complete exploration state space system 
table state space generally decreases model rt rt lt 
shows incorporating knowledge scheduling policy model checked states need explored 
example medium largest scenario model checked bogor previous dspin implementation employing reduction strategies rt lt 
basic states model rt rt single thread interleaving 
model larger number states lack constraints allows timeout occur events associated current frame dispatched 
model lt states rt due overhead introduced timing transitions 
bogor runs memory checking states medium rt states 
interesting states require memory states medium rt 
effect collapse compression 
specifically threads threads medium rt 
addition fewer scheduling constraints allows interleaving medium rt 
collapse compression save medium rt similar state bit patterns medium rt 
related garlan describe approach checking publish subscribe systems refer implicit invocation systems smv 
build key insights factoring system models parts reusable model run time event delivery infrastructure application dependent user specified component models 
support directly forms component structure connections ccm structures object event delivery mechanisms rt corba middleware real systems 
advance achieved leveraging bogor direct modeling oo concepts compared smv input language provides little support modeling programming language features bogor extension mechanism allows complex middleware behavior captured internally model checker 
addition provide performance data consider state space reductions priorities scheduling timing constraints critical scaling realistic applications 
large body timing schedulability analysis component systems 
techniques matured integrated environments support development real time systems 
example metah geodesic frameworks support reuse components written ada java respectively real time systems 
frameworks include range timing analyses automatically generate infrastructure code coordinates execution component code way achieves system timing requirements 
cadena complementary targets logical properties system light weight heavy weight analysis techniques 
ptolemy framework allows wide variety formal descriptions components behavior integrated single system 
user provide sufficient detail descriptions allow implementations automatically generated 
ptolemy provides run time infra structure mediate components different execution models 
contrast cadena models intentionally leave detail order provide system descriptions amenable analysis large systems 
cadena provides code generation capabilities attempt generate component method implementations 
model checking extremely popular technology analyzing behavioral models software artifacts 
researchers extracted models source code uml design artifacts architectural descriptions 
difficulty applications model checking scaling apply realistically large complex systems 
years seen enormous amount research systematic abstraction models enable tractable reasoning 
take different approach cadena exploiting natural abstractions arise developing high level design models systems 
believe idea flexible model checking framework allows domainspecific extensions ones encoding models corba communication layers effective approach modelchecking modern distributed system designs implementations 
currently working boeing engineers incorporate forms domain formation common specification idioms forms light weight checking interface protocol checking refinement checking static analysis cadena 

allen garlan 
formal basis architectural connection 
acm transactions software engineering methodology july 

dams 
symmetric spin 
international journal software tools technology transfer 
springer verlag 

brat havelund park visser 
java pathfinder second generation java model checker 
proceedings workshop advances verification july 

clarke grumberg peled 
model checking 
mit press 

corbett dwyer hatcliff laubach robby zheng 
bandera extracting finite state models java source code 
proceedings nd international conference software engineering june 

de rajkumar 
geodesic reusable component framework embedded real time systems 
technical report carnegie mellon university 

iosif 
dspin dynamic extension spin 
theoretical applied aspects spin model checking lncs sept 

deng dwyer hatcliff jung robby singh 
model checking middleware event driven real time embedded software extended version 
forthcoming april 

sharp 
freeing product line architectures execution dependencies 
proceedings software technology conference may 

eclipse consortium 
eclipse website 
www eclipse org 

garlan 
model checking implicit invocation systems 
proceedings th international workshop software specification design nov 

harrison levine schmidt 
design performance real time corba event service 
proceedings acm sigplan conference object oriented programming systems languages applications pages 
acm press 

hatcliff deng dwyer jung prasad 
cadena integrated development analysis verification environment component systems 
proceedings th international conference software engineering appear 

havelund 
model checking java programs java pathfinder 
international journal software tools technology transfer 

holzmann 
model checker spin 
ieee transactions software engineering may 

holzmann 
state compression spin recursive indexing compression training runs 
proceedings third international spin workshop apr 

iosif 
symmetry reduction criteria software model checking 
proceedings ninth international spin workshop volume lecture notes computer science pages 
springer verlag apr 


automatic verification behavioural subset uml statechart diagrams spin model checker 
formal aspects computing 

lee 
overview ptolemy project 
technical report ucb erl university california berkeley mar 

lilius 
vuml tool verifying uml models 
proceedings th ieee international conference automated software engineering 

robby dwyer hatcliff 
bogor extensible highly modular model checking framework 
technical report santos tr kansas state university 
submitted publication 

robby dwyer hatcliff 
bogor website 
www cis ksu edu bandera bogor 

sipma 
event correlation formal approach 
technical report draft stanford university july 


metah user manual 
www honeywell com metah 
