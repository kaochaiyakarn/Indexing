bipartite matching approach approximate string comparison search samuel buss peter yianilos approximate string comparison search important part applications range natural language interpretation dna 
presents bipartite weighted graph matching approach problems authors linear time matching algorithms approach tolerance permutation symbols blocks distinguishes widely edit distance finite state machine methods 
close relationship earlier related proximity comparison method established 
linear cost model simple time position online algorithm comparing strings fixed alignment 
heuristics optimal alignment 
approximate string search problem string advances fixed direction relative time step 
introduce new online algorithm setting dynamically maintains optimal bipartite weighted matching 
discuss application algorithms natural language text search including prefilters improve ciency symbols improve search quality 
approach likeit text search utility development 
design objectives summarized 
keywords approximate string comparison approximate string search text search sequence comparison bipartite quasi convex matching distance metric natural language processing 
supported part nsf dms 
department mathematics university california san diego la jolla ca 
email ucsd edu 
nec research institute independence way princeton nj department computer science princeton university princeton nj 
email research nj nec com 
earlier related works authors may obtained anonymous ftp euclid ucsd edu directory pub research filenames ps ps 
search implied process comparison fundamental notions theoretical applied computer science 
usual case comparison straightforward attention rests mainly search 
finite strings finite alphabet example define comparison test equality known dictionary problem arises 
organize set strings ective storage retrieval exact matches 
short string longer strive ciently locate occurrences called string matching problem 
comparison method generalized allow inexact match resulting ideas algorithms data structures somewhat complicated 
despite added complexity research direction important resulting algorithms frequently greater practical value 
case naturally occurring strings result generative process includes error ambiguity 
examples include natural language text speech signal naturally occurring dna just sequence corresponds measurement natural process 
natural generalized comparison method relaxes requirement exact equality admit bounded number errors 
error typically restricted insertion deletion substitution transposition adjacent symbols 
query string possible build finite state machine fsm detect match error bounds second string 
refer approach generalizations fsm methods 
demonstrates text scanned high speeds framework comparison 
known approach generalized string comparison computes edit distance ed measures costly transformation string set primitive operations 
common choices primitive operations insert delete substitute adjacent transposition 
simple dynamic program computes distance quadratic time proportional product string lengths 
see discussion related algorithms refer ed methods 
fsm ed approaches strictly enforce temporal ordering 
applications extent desirable 
observe similar strings natural language exhibit strong local temporal agreement frequently include global ordering violations 
concretely words entire clauses rearranged result similar original 
example strings abcd maximally distant respect edit distance transform second deleted inserted 
disturbing word level symbol replaced word significant divergence human similarity judgment apparent 
presents formal basis string comparison search entirely distinct fsm ed paradigms 
represents computationally solution problem preserving emphasis local temporal ordering allowing global permutation 
framework reduces string comparison multiple instances bipartite weighted matching problem called assignment problem 
bipartite graph parts correspond strings compared 
nodes symbols generally features string position 
edges connect symbols string costs vary magnitude positional displacement 
local temporal ordering emphasized defining features consist varying lengths assume insertion deletion operators simplicity 
string comparison bipartite weighted matching string position 
solution superposition assignment problems distinct 
sections follow describe method greater detail 
proximity comparison method related approach commercial spelling error correctors information retrieval products 
show earlier method may viewed approximation assignment problem solve exactly 
principal virtue algorithm simplicity resulting speed 
proximity comparison requires passes strings compared demonstrate exact solution possible 
cases time spent processing symbol 
algorithms essentially supplant proximity comparison approach 
context sensitive feature symbols proximity comparison applications practical reasons length generally limited 
friendly finder program example proximity comparison database retrieval system entirely grams positional relationship 
damashek hu man developed large scale text retrieval system entirely 
convenient imagine strings arranged top 
example graph nodes consist unigrams single letters 
linear cost model matching cost determined simply adding horizontal displacements graph edge imposing penalty number unmatched nodes 
evident lower cost matching result shifted left position 
illustrates cost optimal matching function string relative alignment 
applications fixed alignment assumed require alignment optimized 
case string search long string imagined advance leftward time step 
problem maintain optimal matching dynamically time advances alignment changes 
ll describe problem greater detail describe algorithm somewhat cient obvious solution finds entirely new matching step 
illustrates edge matching connects identical symbols 
alignment matching problem may decomposed union subproblems alphabet member 
show may decomposed levels 
level decomposition trivially produced pass amounts parenthesis nesting algorithm 
level simple pass time node algorithm finds optimal matching 
combined sizes subproblems equals size original problem original problem solved pass time symbol 
discuss text search application techniques improve processing speed search quality 
symbols variable length employed node increase system sensitivity local ordering changes 
searching optimal matching published proximity technology alignment prefilter stages employed ectively rule candidates 
likeit system development combines techniques 
practice database record may located query remotely resembles 
system character oriented ort extract words query database 
best described approximate phrase retrieval system tolerates re ordering considering word proximity 
theoretical foundations bipartite matching string comparison start mathematical definitions strings bipartite matchings cost matching 
spite mathematical abstraction definitions underlying idea quite simple query string database string wish find optimal assignment symbols occurring occurrences symbols optimality measured terms distance symbol assigned symbol distance corresponding symbol assignment depends choice alignment relative reason definition string specify just contents position integer number line 
notion optimal assignment defined position implicit definition string 
consider higher level optimization problem varying relative position alignment strings optimize minimize assignment cost 
string intuitively sequence characters finite alphabet formally string domain 
mapping denote symbol position notice string domain really th symbol 
allowing domains general easier describe process searching optimal alignment process searching approximate occurrences string domain denote string domain length equal number symbols 
meta symbols strings 
meta symbols symbols definition strings 
bipartite matching partial mapping dom dom dom denote number values defined 
cost function mapping sided cost matching cost function equal dom sided cost matching equal dom 
sided cost useful string comparison problem wants notion distance hand sided cost useful string search problem wants know extent contained note equal length sided sided costs identical 
definition write dist denote optimal sided cost matching function dist enjoys property metric theorem cost function non decreasing satisfy 
dist metric 
dist dist dist dist dist dist proof properties dist dist dist immediate definition 
triangle inequality minimum cost matchings respectively 
form composition su ce show cost equal sum costs convenient cost dom dom dom dom ran think costs expressed similar form 
consider kinds values dom dom contribute cost dom contributes cost dom contributes cost dom dom contributes cost dom contributes cost ran contributes cost cost ran ran contributes cost ran contributes cost dom contributes cost corresponding contribution cost contribution cost fact satisfies triangle inequality 
case contribution cost equal sum contributions large number enhancements definitions cost distance 
example possible assign character real valued weight weight costs proportionally weight character 
possible heavily weight characters near enhancements useful practice improve perceived quality optimal assignment little di erence algorithms described shall just simple notion cost defined 
authors developed linear time near linear time algorithms finding minimum cost bipartite matchings cost function concave 
space permit review details algorithm shall review keys aspects algorithm needed case cost function linear constant 
simplicity assume strings domain symbol occurs position level equal number occur minus number occur similarly level equal number minus number minus 
simple important fact optimal matchings proposition lemma lemma concave assume optimal cost matching level level defined 
proposition provides step algorithm finding optimal matching 
step separately consider symbol calculate level occurrence level separately find optimal matching level union matchings gives optimal matching original strings 
allows reduce problem finding optimal bipartite matching problem definition positions symbol positions suppose equals 
example occurrences occurrences level 
alternating matching problem occurrences find maximal partial mapping 

minimizes total cost dom 
note dom contain points 
alternating matching problem said balanced unbalanced 
dual formulation alternating matching problem occurrence precedes occurrence case equal complete solution alternating matching problem matching problem concave cost functions authors 
particularly simple useful special case cost function linear 
case theorem explains algorithm simplified 
theorem cost function linear arbitrary 
instance alternating matching problem 
minimum cost matching 
simplifying assumption holds loss generality pad strings new symbols occur string strings domain 
common shifting strings position 
undefined 
dually part simple special case known problem see 
part generalization unbalanced matching 
proof recall notion jumper 
suppose cost function linear need put jumper assuming ties broken favor adding jumper 
optimal matching matching suppose unbalanced problem reduced balanced tour adding new phantom occurrence cost function modified edge contributes zero total cost new phantom node distance zero nodes 
ties may broken favor jumpers 
methods optimal matching jumpers case dual essentially proof works 
proved linear time algorithm solve alternating matching problem theorem linear cost function clearly satisfies weak crossover condition algorithm explained passes words left right 
special case linear cost function simpler online algorithm uses time symbol theorem 

instance alternating matching problem assume online algorithm scans values sequential order constant time value finds optimal matching described theorem 
proof setting part theorem trying find value matching undefined minimal cost 
cost function linear may assume cost matching omits domain clearly equal constant su ce find value minimizes algorithm simple 
read sequentially value updated single addition subtraction node minimum value remembered corresponding value scan stored value minimizes describes optimal cost matching gives total cost 
note algorithm uses constant amount space necessary store values current values plus minimal value seen far associated need kept 
realignment previous section considered problem finding minimum cost matching strings positions strings held fixed 
frequently desirable allow strings shifted relative find better matching 
example matching string dinosaur 
strings aligned domain domain total cost strings shifting leftward letting domain total cost reduced call problem finding optimal shift realignment problem 
give heuristics finding realignment 
center gravity quick implement produce optimal free realignment 
second median calculation produces optimal free realignment time consuming compute 
fixed strings define equal dist problem find minimizes find corresponding optimal cost matching general idea iteratively calculate optimal match alignment calculate free realignment improves cost match repeat process 
formally define free realignment follows definition strings dom dom partial matching 
free realignment specified integer parameter cost free realignment equal dom 
general approach take realignment algorithm algorithm set loop set optimal matching exit loop set endloop function computes free realignment 
suggest possible methods computing center calculation center gravity cog defined equal cog dom rounded nearest integer 
cog cog function easy compute fast worked likeit system described section 
guaranteed yield best possible free realignment example string abc compared string bc dashes represent long string blanks case cog free realignment reposition placed thirds mark optimal free realignment minimum cost positioned substrings bc perfectly aligned 
second free realignment algorithm median value mean di erences median multiset integers defined usual number members middle elements considered median value median defined equal median multiset pi dom theorem shows median optimal free realignment 
theorem median gives minimum cost free realignment proof recall matching consider di erence dom pi easily seen equal number minus number greater median conversely median follows minimized median multiset unfortunately median free realignment provides optimal free realignment mean converge alignment locally optimal 
example suppose bca domain domain optimal matching alignment median value alignment locally optimal matching lower cost assuming reason realignment remains merely useful heuristic works practice may fail produce optimal alignment rare situations 
cog function median function computable linear time practice cog slightly simpler quicker compute yield results 
cog free realignment prefilter stages likeit system median approach computing final matching 
bipartite matching string search development began considering problem approximate string comparison fixed alignment query string relative database string 
discussed optimization alignment 
cases setting record oriented assumed complete records words names section consider di erent related problem approximate string search bipartite matching outlook 
strings generally longer paragraph article represents text approximate string search optimal bipartite weighted matching maintained fixed window text slides stationary query 
searched 
shorter string thought human generated query 
text imagined motion passing query depicted 
earlier record oriented approach principle applied setting problems exist 
local search heuristics introduced relied produce global optimum alignment led recompute entire matching alignment 
second linear cost function agreement mathematical notion similarity human judgment appears break substantially 
see consider varying position distant matching symbol ects score just nearby variations 
searching keywords regard position may reasonable behavior 
query represents phrase collection words expected occur close proximity parts query match distance locations easily dominate matching score 
part motivated authors consider non linear quasi convex cost functions earlier 
approach take linear costs restrict matching process moving window text indicated dotted line 
matching edges allowed window 
position text relative query di erent bipartite matching may exist 
problem face consists ciently maintaining optimal matching text slides 
problem separates immediately alphabet symbol may focus subproblem corresponding single symbol 
notion level decomposition time time adjust text slides 
focusing single level important realize optimal matching may change text moves need arises recompute levels 
think eventualities events alarm set events consisting recomputation levels optimal matching level 
alarms sounds easy see matching edge grow shorter longer time step 
edge change growth direction alarms change correspond event 
alarms matching cost change constant amount time step total edge change 
algorithms describe computing symbol subproblem cost optimal matching number time steps alarm event change matching cost time step 
cost changes symbol summed form single value 
alarm sounds symbol processing time step consists adding single value adjust cost optimal matching 
trivial outer loop manages alarms updates cost change variables 
worst case alarms sound nearly time step algorithm better direct approach merely recomputes optimal matching cost time step 
problem domains natural language text alphabet may defined considerable savings result 
example define alphabet consist say grams grams exclude grams 
doing problem considerable sparse subproblems sleep time steps needed 
window size algorithms perform time step 
hope find algorithm log step amortized basis 
represents interesting area 
failing result analyze algorithms assumption distribution strings 
outer level processing straightforward confine discussion matching subproblem single symbol denote algorithm represents occurrences linked list formed search begins 
occurrences maintained linked list list updated 
entry added tail shifted right time step 
list head deleted shifted window 
assuming constant number symbols string position maintenance lists clearly cost step 
lists need formed alphabet symbols occur time steps denoted numbered zero 
denote set windows right edge position list entries consist integer giving time step particular occurrence shifted list entries consist position occurrence natural coordinate system position zero 
time step lists ectively adding element 
show single scan lists associated finds optimal matching cost alarm intervals corresponding leveling described 
scan performed earlier alarm sounds appears right vanishes left window 
part process consists merging lists produce single sorted list 
merge straightforward matter split list sublists level 
merge easy set leveling alarm focusing positions merged list list element immediately followed list element 
minimum gap pairs gives value leveling alarm may trivially maintained scan 
seen earlier section optimal matching cost may level online fashion show alarm set 
turning log step algorithm need leave leveling maintain levels non trivial data structures 
see consider block say occurrence moving block occurrences generate leveling event time step 
quadratic number matching edge changes generated despite fact canonical matching avoiding leveling alarms matching edge changes alarms 
course true examples number occurrence exactly equals number may provide intuition leading improved algorithm general case 
focusing individual level recall consist elements alternate level length elements matched required leveling changes 
level odd length exactly element left unmatched optimal matching 
processing level online don know advance odd length 
poses real problem may assume odd reach find 
merge ties broken favor cost leaving ith element unmatched minus cost leaving element unmatched increases time step 
assume generality situation level begins element level odd length contains unmatched element 
part depicts matching element left unmatched 
part shows matching element excluded 
slides left edges left parts decrease cost edges right behave di erently 
part grow costly cost declines di erence cost matchings part minus part increases time step 
course true elements cross time leveling alarm sounded 
position denote di erence optimal matching corresponds minimum function graph 
imagine animating graph respect time step rule derived 
value may expanded function time kt denotes level length minus apparent move left right level rate increase declines 
situation illustrated 
time passes values represent minima general change 
notice absolute vertical location graph ect identification optimal matching minima unchanged vertical translation 
observe di erences easily computed online local di erences level list 
vertical translation graph may built online starting arbitrary value accumulating values 
show graph built left right easily constant time update value variable alarm gives number time steps graph new global minimum 
corresponds course change optimal matching alarm require complete algorithm string search 
observations needed understand short algorithm follows 
left right graph construction new global minimum encountered earlier point replace earlier points increasing value greater rate 
second current point greater equal current global minimum number time steps pass current point smaller current global minimum exactly min min algorithm results current optimum graph di erence computed 
minima correspond optimal matchings time passes values increase rate increases linearly right left 
algorithm set min 
min set min min alarm min min alarm set alarm relationship proximity matching section give new characterization call proximity metric strings 
metric various generalizations developed primarily second author reported extensively natural language applications especially spelling correction proximity technologies large number word processing software publishers franklin electronic publishers hand held solid state electronic books 
product implementations include pf vlsi circuit friendly finder database retrieval system proximity scan subroutine library clean mail program eliminating duplicates mailing lists 
proposing bipartite graph matching approach string matching improvement proximity metric string matching 
proximity metric fast cient implementation proven natural language applications 
argue new bipartite graph matching approach provides qualitative improvement proximity matching seen bipartite graph string matching performed ciently linear time performance rivals proximity metrics 
space allow complete treatment proximity metric include full definition proofs main new results 
rest section equal length domain definition denote substring position position symbol common equal minimum number occurrences number common common number occurrences symbols common proximity similarity defined equal sim common common 
note common sim define proximity distance equal dist sim 
clear dist value value common symbols 
traditionally proximity metric scaled version sim sim theorem proved omit proof theorem fix 
dist metric 
known dist acts somewhat matching string comparison method linear cost function noted dist metric acts counter intuitively unequal numbers symbol phenomena explained characterization dist giving characterization dist give slightly definition dist function basically discussion section algorithm finding optimal cost matching implemented split symbols alternating tours level find optimal matching tour independently 
shall cost function symbol level number matching maximal matching maps positions occurrences level positions occurrences level 
injective total 
cost equal dom recall level occurrences form alternating tour theorem describes ways minimum cost matchings formed 
case theorem holds say balanced unequal numbers occurrences level strings said unbalanced 
define dist minimum sided cost matchings occurrences level dist proposition tells bipartite graph string matching distance defined dist dist 
give similar characterization dist dist defined dist dist balanced note case unbalanced dist just constant independent positions level occurrences may slightly counterintuitive constant di er exactly character substitution dist case values unbalanced tour character substituted character unbalanced tours contributes dist net contribution theorem dist dist 
proof rhs shorthand notation double summation theorem 
shall prove theorem induction common base case common symbols 
case dist exactly distinct pairs occurs level strings 
rhs equal induction step pick symbol level occurs level positions appears respectively level loss generality new symbols define obtained replacing position define similarly replacing position induction hypothesis dist equal rhs su ce show dist dist rhs rhs 
prove suppose strings balanced consider di erence rhs rhs unmatched symbols contribute distance theorem tells occurrences positions matched optimal matching contribute distance 
rhs rhs 
consider di erence dist dist unmatched symbols provide common values 
occurrences increase common increase common dist dist 
desired 
suppose strings unbalanced consider di erence rhs rhs tour unbalanced contributed way think dist intended variation sided cost 
dist unbalanced unbalanced 
contribute extra distance rhs rhs 
consider di erence dist dist unmatched symbols provide common values 
occurrences increase common increase common dist dist 
desired 
string matching algorithms bipartite graph matchings seen advantages proximity matchings 
principal advantages proximity matching approach counting common occurrences symbol give assignment matching symbols string symbols string 
bipartite graph approach string matching give assignment 
potentially useful assignment firstly shows explicitly correspondences strings secondly assignment post processing phase evaluate correspondence matched strings 
second advantage proximity matching serious flaws symbols occur equal numbers times strings 
example consider strings aba bab abb 
dist dist dist dist normalize distances range divided dist reflects fact di er exactly symbols 
clearly feels similar fact dist dist undesirable dist dist desired 
see discussion relative merits bipartite graph approach string matching edit distance ed approach string matching 
natural language search bipartite approach string matching discussed single string comparison decomposed linear superposition matching problems alphabet symbol 
framework extensive permutation string result new string close original measured minimum cost matching new string original string 
natural language applications behavior presents problems perceptual distance increases rapidly local rearrangement cost optimal matching 
fortunately simple way augment string matching algorithm discussed overcome problems add additional symbols strings performing comparison 
symbols called consist sequence ordinary symbols 
gram sequence symbols underlying alphabet comparing strings preprocess adding character position new symbols grams position string 
give concrete example likeit system method preprocessing string domain value 
min gram comprising symbols min inserted immediately symbol similar preprocessing applied number chosen empirically works natural language text applications 
applications dna sequence analysis appropriate di erent lengths 
preprocessing nearly times long fear increase runtimes factor 
practice preprocessing greatly improves perceived quality matches greatly reduces run time search process 
reason paradoxical reduction runtime search discussed section ective filtering reducing greatly number actual string comparisons performed 
note insertion characters done ciently finite state machine scanning left right 
likeit system gives di erent weights single symbols gram receives weight weight proportional length 
noted optimal matching may respect overlapping 
say overlap may matched widely divergent example consider matching strings bart 
initial gram bar match initial gram overlapping gram art match final gram kind extra symbols inserted strings matching occurs 
natural text search applications addition symbols encoding phonetic information strings approach phonetic information inserted algorithmic method phonetic information inserted algorithmically dictionary 
prefilters matching approach may thought crude model human similarity judgment 
corresponding linear time simple practice important consider simpler models algorithms order increase search speed 
simplest model consists comparing set occur strings frequencies 
ignore position entirely 
may thought crude projection matching model cost function assumes constant value matching edges independent edge length 
corresponds frequencies 
model simplifications involve approximations seen 
examples free realignment cog heuristic approximate solutions level matching problem 
simplification consists dealing fewer sizes 
simplified algorithms form prefilters applied database order limit search subset processed prefilters ultimately final algorithm 
records considered prefilter added heap bounded size 
prefilter reads heap writes new 
particular domains transaction logs query models may intelligently set size heaps estimate probability error failing pass correct record acceptable 
alphabet element relationships framework allows matching edges identical characters 
sense corresponds discrete metric distance function assuming zero equality unity 
languages awkward may unacceptable simplification 
simplest current practical technique known authors consists mapping alphabet element string 
mapping attempts capture linguistic relationships 
likeit text search engine summary preview ideas authors earlier lead development likeit new text search engine web 
weighted matching approach represents single conceptual framework deals variations word spelling form spacing ordering proximity text 
system objective provide easy administer distributed search service ering great deal error tolerance simple user interface 
web user query communicated likeit search servers html document returned containing similar information 
optimal matching visualized user highlighting selected characters returned text 
relationships servers may established form distributed network search service include explicit hierarchy desired 
database roughly bibliographic citations searched query title optimal bounds dictionary problem returned 
search requires little seconds mhz pentium processor system 
realistic example search finds papers author intended 
keyword systems glimpse wais design 
algorithms find application construction front spelling correctors keyword systems 
interesting directions 
algorithms approximate string search improved provide constant nearly constant time bounds time step 
strategies indexing hashing explored prefilters rapidly limit search range 
general techniques dealing relationships elements retaining computational ciency developed 
alphabet symbol weights parameters way learned system 
application areas dna analysis explored 
conclude review relative advantages disadvantages bipartite graph string matching algorithms discussed prior edit distance ed algorithms 
algorithms advantage online linear time contrast ed algorithms dynamic programming require quadratic time general linear time limited number edit operations allowed 
algorithms give better quality match strings compared contain substantial di erences ed approach gives higher quality matching strings di er edit operations fewer 
primarily due fact algorithms match distinct alphabet symbols independently 
symbols disadvantage algorithms largely overcome 
ed distance algorithms widely text search applications 
precursor algorithms proximity matching widely 
algorithm provides qualitative improvement proximity matching deployed general purpose tool likeit text search package 
aggarwal bar noy khuller kravets schieber cient minimum cost matching quadrangle inequality proceedings th annual ieee symposium foundations computer science ieee computer society pp 

buss neighborhood metrics dimensional blocks characters tech 
rep mathematical sciences research institute berkeley september 
buss robinson yianilos solving minimum cost matching problem quasi convex tours cient ansi implementation tech 
rep cs san diego 
buss yianilos linear log time minimum cost matching algorithms quasi convex tours 
appear siam comput 
extended appeared proceedings th annual acm siam symposium discrete algorithms pp 

damashek gauging similarity grams language independent categorization text science pp 

huffman damashek acquaintance novel vector space gram technique document categorization proceedings text retrieval conference trec washington nist pp 

karp 
li special cases assignment problem discrete mathematics pp 

knuth james morris pratt fast pattern matching strings siam journal computing pp 

lawler combinatorial optimization networks matroids holt rinehart winston 
manber wu glimpse tool search entire file systems proceedings winter usenix conference pp 

sankoff kruskal time warps string edits macromolecules theory practice sequence comparison addison wesley 
wu manber fast test searching allowing errors communications acm pp 

yianilos definition computation application symbol string similarity functions master thesis emory university 
dedicated comparator matches symbol strings fast intelligently electronics magazine 
yianilos buss associative memory circuit system method part 
patent december 
yianilos buss application pattern matching algorithm searching medical record text ieee symposium computer applications medical care pp 

yianilos likeit distributed web search system 
manuscript preparation 

