modal calculus ect handling june cmu cs school computer science carnegie mellon university pittsburgh pa purest formulation monads functional programming purposes propagate ects ect scope ect occurs purity surrounding computation restored 
consequence monadic typing provide naturally practically important ability handle ects number previous works directed deficiency 
extending monadic framework extra logical constructs support handling 
adopt di erent approach founded observation pfenning davies monad decomposed terms modal operators possibility necessity 
idea modality comonad hygienic propagation ects leave globalization ect scope 
ects admit natural notion handling encoded global need push 
idea develop general framework ect handling systems obtain novel calculi exceptions catch throw composable continuations specific instantiations 
keywords modal logic ect systems exceptions composable continuations established correspondence functional programming monads type theoretic equivalent ects ect systems :10.1.1.18.9697
monad described moggi wadler serves purposes marks impure code segments program supporting way disciplined propagation ects canonical map leave scope monad ects represented monads global introduced ect holds till program :10.1.1.100.9674:10.1.1.32.3968
monads ect systems purest formulation express important programming practice ubiquitous ability handling ects restoring purity impure computation means action 
fact definition handling ects direct contradiction property ects global scope 
expressiveness ect handling required endowed monadic framework means additional extra logical constructs :10.1.1.33.8720:10.1.1.46.2016:10.1.1.134.8272:10.1.1.43.8213
novel ect system modal logic capable representing ect handling 
founded observation pfenning davies monad composition modalities possibility necessity variant modal logic :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
build result recognizing informally takes duty marking impure code segments enforcing ect propagation discipline takes duty single threading program scope ects 
independent modal type constructors ascribe typings precise monadic calculus 
ects admit natural notion handling may encoded modality scope ects global need forced 
necessitation operator fact comonad authors argument comonads addition monads represent certain kinds ects 
example argues comonads appropriate monads represent ects arise environment :10.1.1.32.3968
identifies comonads encoding computations expect additional arguments environment :10.1.1.17.1563
focus necessitation operator leave issues related global ects destructive state update possibility operator related :10.1.1.17.1563
development hope strengthen case comonads 
idea extend modal calculus new semantic category names label track specific ects :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
similar indexed monads type ca classifying suspended computations type may course eventual execution raise ects listed possibly ordered set names monads canonical coercions ca possible represent handlers equipped deal names sense comonad modal necessity endowed names represents ects arising environment fact marks ects scope global ects handled :10.1.1.18.9697
interaction environment comonad aforementioned passing additional arguments diverse di erent ects di erent notions handling 
approach formulating ects follows elimination pattern natural deduction ects introduced forms eliminated handling forms 
particularly appealing may uncover logical content ects question explore 
illustrate idea develop example novel calculus exceptions exception associated name raising exceptions form handling exceptions elimination form :10.1.1.33.8720
novel calculi catch throw composable continuations :10.1.1.50.2608:10.1.1.50.2608:10.1.1.50.2608:10.1.1.32.3968:10.1.1.32.3968:10.1.1.32.3968:10.1.1.17.1563
calculi derived simple uniform extensions core framework 
modal calculus starting point development language ects calculus :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
proof term system necessitation fragment modal logic considered functional programming context specialization purposes run time code generation 
syntax summarized stand predetermined set base types 
types terms box box value variable contexts expression variable contexts important feature calculus type constructor referred modal necessity modal logic necessitation modifier propositions :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
purposes useful operational intuition consider type type suspended expressions type contrast non modal type populated executable expressions 
sense suspending expressions enclosing binder customarily done functional programming separate language construct 
gives orthogonal appropriate abstraction mechanism build subsequent sections 
type system 
box box distinguishes variable contexts variables bound executable expressions variables bound suspended expressions 
elimination forms type constructor term constructors box box respectively 
operationally term constructor box suspends evaluation argument expression wraps thunk box manipulated rest program 
note typing rule box prohibits refer variables possible coerce values suspensions 
counter intuitive interpretation modal calculus remedy subsequent sections 
elimination form box takes suspended expression boxed binds expression variable example function exp takes integer argument builds suspension computing fun exp int int box box exp box exp val box int elimination form box bound variable belongs context expression variables suspended positions box executable positions 
way compose suspended programs explicitly force evaluation 
example force evaluation way 
box val int formalize operational intuition calculus employ evaluation context operational semantics style wright felleisen 
decided call value evaluation strategy line interpretation boxed expressions suspended code prohibits reductions box boxed expressions considered values 
choice means canonical necessary purposes 
formalization relies definitions redex evaluation context introduced 
values box redexes box evaluation contexts box expression decomposed uniquely evaluation context redex 
define small step operational semantics calculus define primitive reduction relation redexes denote evaluation expressions denote reduce redex identified unique decomposition 
primitive reduction evaluation relation call value defined follows 
box box names markers ects section extend calculus notion names 
names labels provide formal abstraction tracking ects 
ect assigned name ect appears suspended term corresponding type indexed name 
example exception suspended term type may raise exception type xa provide coercions xa represent exception handlers described indexing modal operator names similar monadic language labels identify ects may occur monad :10.1.1.18.9697
setup allow dynamic fresh names computation generation new ects establish typing discipline 
having mentioned idea provide intuition goal proceed introduce calculus stages 
formally tying names effects immediately limited fragment intended account dynamic names name propagation 
fragment common part ect calculi develop 
names relate ects various ects raised handled discussed subsequent sections 
start explaining syntax various syntactic conventions language 
names supports types ca terms box box choose variable contexts name contexts just calculus distinction levels suspended executable expressions 
separated modal type constructor family modal type constructors finite sequence names names drawn countably infinite universe names hinted type ca classifies suspended expressions may raise ects names sequence referred support expressions 
consider partial ordering supports 
term support safely appear scope handler capable dealing names term pure empty support need restricted particular set handlers 
require empty support smallest element 
suspended expressions contain ects extend typing assignments context keep track typing support variable 
example typing declares variable bound expression type support furthermore commented previous section enable coercion values suspended expressions join contexts calculus 
context considered part declaring variables explicitly empty support 
correspondingly frequently abbreviate decision logically corresponds identifying types index support type empty 
equivalently viewed imposing monotonicity kripke frame possible worlds semantics modal logic :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
course multitude modal operators corresponding various supports indices move collapse hierarchy modal types 
change addition context declares names types currently active program 
types calculus depend names impose conditions formedness contexts 
context formed type uses names declared left 
variable context formed respect names appear types declared 
types new calculus include family elimination forms choose constructs dynamically introduce fresh names calculus 
example term binds name type subsequently names stand ects construct really declares new ect enables raise handle 
ensure type system result evaluation depend prevent escape scope form 
abstraction value calculus 
particular suspend evaluation want evaluate choose 
term constructor choose picks fresh name type substitutes name bound argument abstraction type proceeds evaluate body abstraction 
enlarging appropriate context new variable name subject usual variable conventions new variables names assumed distinct renamed order clash existing ones 
terms di er syntactic representation bound variables names considered equal 
binding forms language box capture avoiding substitution expression variable expression defined rename bound variables names descending scope 
term denote fv set free variables set names appearing type denoted fn 
typing judgment core fragment judgment hypothetical works contexts context names context variables 
expression judgment checks type ects support core fragment typing rules explained 
pervasive characteristic type system support weakening principle support expression determines ects raise handlers restore purity 
consequently support weakening principle formally models intuitive property ects handled handler handled stronger handler 
particular ect free handled handlers empty support smallest element partial ordering 
property formally represent values language ect free 
values obviously raise ects simply evaluation finished 
support values system empty support weakening principle weakened arbitrarily 
explains explicit weakening box da da box fn choose type system core fragment 
hypothesis rule arbitrary support typing rules abstractions box 
calculus fragment 
rule abstraction requires body abstraction pure match empty support 
say contain ects suspended box correspondingly accounted type 
parallels exactly monadic type systems function bodies pure ects raised monad 
hand terms values support abstraction arbitrarily weakened explained 
implicitly assumed argument type formed name context introduced variable context 
note bound variable introduced empty support decision allow coercion values suspensions 
bound ect free expression 
force commit call byvalue evaluation strategy calculus reduce function arguments values ect free passing 
formulation type system favor particular evaluation strategy possible retains contexts section achieves discussed monotonicity means separate rule 
bit verbose leave 
modal fragment 
type suspended code box check typed matching support supplied index constructor 
boxed expressions values support arbitrarily weakened formed support set elimination rule straightforward extension corresponding rule 
di erence bound expression variable context stored support annotation 
names fragment 
rule check typedness context extended new name similar rule require empty support eventual ects may raise boxed 
characteristics constructor requirement appear type ensures remains local escape scope introducing observable way 
ect corresponding raised course evaluation appears appears dead code part occurrences handled appropriate notion handler 
term constructor choose elimination form picks fresh name substitutes bound name abstraction 
example introduce construct val calculus rule val syntactic sugar box box usual complication arises box pure put abstraction 
example assume arbitrary support sets 
terms typed empty support 
box box box da box box box box db box box box function simply eta expands argument 
shows support weakening boxed types derivable 
function illustrates unbox evaluate suspended expressions raise ects notice argument type empty index support 
function shows consequence imposed monotonicity possible coerce values suspended computation simply boxing 
values name free support weakened arbitrary support set functions generalize characteristic axioms modal necessity names :10.1.1.17.1563:10.1.1.17.1563
example anticipating section suppose language contains term constructor raise raise raises exception passing argument assuming type 
name type term typed 
box box raise xa assume closed exception free term closed term may raise exception expression choose 
box raise declares new exception raises suspension box raise fact appear type application depend 
true argument suspension forced dead code 
clause typed type expression type section introduce exception handling able meaningful choose 
operational semantics operational semantics basic fragment calculus defined judgment relates expression step reduct relation defined expressions free variables 
expression contain ects names declared empty support 
words consider evaluation expressions ects suspended appear dead code part handled 
reduct introduce new names computation accounted extended name context new names mark ects suspended raised handled 
definition judgment relies notion redexes evaluation contexts 
values box redexes box choose evaluation box contexts choose primitive reduction rules evaluation rules operational semantics 
identical rules new reduction rule choose extends run time name context fresh name proceeding evaluation box box choose dom example illustration operational semantics calculus couple steps evaluation term example 
choose 
box raise box raise fresh name structural properties type soundness rest section develops basic properties calculus 
extensions rely basic structure results 
proposition expression substitution principle 
lemma replacement exist type 

extend lemma canonical forms closed value 
holds 

db box 
consequence support arbitrarily weakened support lemma subject reduction extends 
theorem preservation extends 
lemma progress exists term context lemma unique decomposition expression 
value 
unique evaluation context redex theorem progress 
value 
exists term context proposition determinacy exists permutation names fixing domain 
exceptions calculus far involve concrete notions ects 
capable dynamic propagation ects fact raising handling 
section extend code fragment calculus exceptions 
idea assign name exception propagated tracked means core fragment 
able raise handle exceptions need constructs specific exceptions 
extend syntax language way 
exception handlers xz terms 
raise handle informally role raise evaluate raise exception passing value 
hand handle evaluates may raise exceptions raised exceptions handled exception handler 
exception handler syntactically defined list exception patterns refers di erent exception 
conceptually regard exception handler mapping set names set functions terms terms terms treat handlers able take action exceptions just action specifically prescribed term action just involve propagation exception 
example empty handler handles exceptions propagating 
handler domain dom defined set dom raise consider handlers finite domains 
handler finite domain finitary syntactical representation set patterns xz relating name dom function frequently equate handler set represents result ambiguities 
operations perform term mapping limited ordinary compositions term constructors language 
case value function term equal example assuming integer names wellformed expressions exception calculus 
handle xx handle xx handle handle handle xx terms evaluate respectively 
term raises exception handles 
second raises value handled handler handler raises exception value ultimately handled second handler 
third term raises value propagated handler handled second handler 
type system calculus exceptions consists judgments typing expressions typing exception handlers 
judgment expressions form simply extends judgment core fragment section new rules raise handle 
specific calculus support represents sets collecting exceptions allowed raise 
defined viewed sets ordering repetition elements supports ignored 
support weakening need raise exceptions support exception raised judgment exception handlers form handler type handle exceptions support set arising term type handling allowed raise exceptions support set typing rules judgments briefly comment 
exception raised accounted support 
rule raise requires term raise changes flow xz raise handle typing rules exceptions 
control passing nearest handler 
environment term encountered matter type raise arbitrary type rule handle type support expression match type domain support handler 
exception handler propagates whichever exceptions encounters 
supplied expression support produce expression support 
maintain support weakening property allow range support empty handler superset notice empty support handler may assigned arbitrary type rule nonempty exception handlers simply prescribes inductively checking exception patterns handler 
type pattern variable match type corresponding exception type value exception raised 
handling terms type type assigned handler 
example function tail computes tail argument integer list raising exception empty unit argument list empty 
function length uses tail compute length list 
note range type tail empty intlist 
required body tail may raise exception explained previous section ects function bodies boxed 
reduce clutter subsequent examples abbreviate box simply unbox choose empty unit 
fun tail xs intlist empty intlist case xs nil box raise empty xs box xs fun length xs intlist int length unbox tail xs handle length val points worth emphasizing calculus :10.1.1.32.3968
exceptions calculus values bound variables 
correspondingly explicitly raised raising variable exception possible 
aside fact local exceptions concerned exceptions originate function call raised handled body function calculus resembles standard ml :10.1.1.32.3968
particular exceptions raised handled forcing changes type function 
want function propagate exception handled caller need specifically mark range type function type 
contrast general mechanism monads ects global adding ect body pure function invariably requires range type function changed monadic type 
turn may require serious restructuring programs function 
calculus presents really bare bone theoretical foundation treatment exceptions 
probably case ect calculi practical compared say standard ml exactly types decorated exception names 
believe hurdle overcome easier hide excess information recover lack thereof comment section 
operational semantics exception calculus simple extension semantics core fragment 
evaluation judgment form need extend syntactic categories evaluation contexts redexes define primitive reductions new redexes 
evaluation contexts 
raise handle pure box contexts choose raise redexes 
handle raise handle explained exception handler handle exceptions 
exceptions handled specified way handled simple propagation 
simplify operational semantics somewhat order find handler capable handling particular raise need find nearest handler preceding raise 
purpose select special subclass pure evaluation contexts pure sense contain exception handlers acting hole context 
easily shown evaluation context pure exist unique evaluation context pure context handle 
primitive reduction new redexes follows 
handle raise handle reduction exploits fact values exception free simply fall handler 
second reduction chooses closest handler particular raise 
requires values passed exceptions operational semantics demands exception raised argument evaluated 
happens evaluation argument raises exception take precedence raised 
illustrated term example exception raised eventually handled 
structural properties type soundness core fragment readily extend exception calculus 
list specific additional lemmas 
lemma handler substitution principle lemma unique decomposition expression 
value 
raise unique pure context 
unique evaluation context redex theorem calculus satisfies progress preservation 
typing rules catch throw 
catch throw calculus catch throw calculus simplification calculus exceptions 
consider right order illustrate di erent notion handling 
provide intuition calculus composable continuation section 
catch throw calculus names associated labels program jump 
informally catch establishes destination point jump assigns name throw jumps established point 
exact syntax constructs defined follows 
terms 
throw catch viewed restrictions raise handle catch handles throw immediately returning value associated throw 
typing judgment establishes type may throw destination points names listed support supports sets sequences just calculus exceptions 
typing rules calculus 
throw destination point allowed destination point support set 
catch establishes destination point placing support set argument expression checked 
example terms adopted typed catch throw calculus :10.1.1.32.3968
choose int 
int int 
box int 
box choose int 
int int 
box box int 
box term evaluates addition skipped throw 
second term catch pushed inside preserve addition term evaluates 
example program segment defines recursive function multiplying elements integer list 
element equal product performing remaining computation terminate explicit throw outside recursive function 
choose exit int 
fun mult xs intlist exit intlist case xs nil box xs box throw exit box mult xs box catch exit unbox mult val int evaluation judgment catch throw calculus straightforward extension evaluation judgment core fragment section :10.1.1.17.1563
need define new redexes corresponding new catch throw constructs extend syntactic category evaluation contexts 
redexes 
evaluation contexts 
redex assumed context contain phrase acting hole primitive reductions new redexes defined follows 
similar exception calculus values simply fall catch throw caught closes surrounding catch appropriate name 
operational semantics catch throw requires values passed throw 
possibly nested throws subject catching 
structural properties lemmas core fragment require minor modification unique decomposition 
lemma unique decomposition expression 
value 
unique context catch 
unique evaluation context redex theorem calculus satisfies progress preservation 
composable continuations similar catch throw calculus composable continuations names label destination points program jump 
destination point jump established construct reset assigns name similar catch previous section 
jump performed shift sense corresponds throw throw calculus 
exact syntax calculus defined follows 
terms 
shift resetx di erences catch throw calculus arise property characteristic continuation calculi throw construct shift evaluated captures variable part surrounding term shift corresponding reset precedes may compute value passed jump 
important evaluation undertaken changed environment part captured removed 
specifically able shift destination points defined captured removed part 
example example adopted :10.1.1.50.2608:10.1.1.17.1563
terms typed examples calculus composable continuations 
resetx int 
box box resetx resetx resetx box box box box resetx examples continuation variable int int bound box box represents environment delimited shift corresponding reset 
notice capturing continuation delimiting reset removed reduct 
expressions bound referred composable continuation names partial continuation delimited continuation subcontinuation 
ordinary calculus continuations viewed calculus composable continuations jumps unique destination point predefined program 
calculi continuations functions range type equal type destination point 
special case ordinary continuations type necessarily ordinary continuations composed non trivial way 
typing judgment calculus composable continuations 
establishes expression type may shift destination points names listed support typing rules composable continuations 
case composable continuations shifting name notion ect establishing destination point notion handling 
type system enable shift destination point accounted support placed corresponding reset 
situation bit involved 
mentioned shift evaluates changed environment destination points shift removed typechecked support changed correspondingly 
argument indicates calculus composable continuations ordering names support term important 
previous ect calculi supports simply sets exploit list structure 
simplify matters allow shift certain name name support 
accounted typing rule shift demands rightmost name support 
environment delimited captured removed destination point removed evaluated changed environment 
correspondingly typechecked support rightmost removed 
shift required name deeper done performing sequence nested shifts manner names 
sense view supports calculus continuations stacks 
important aspects typing rule shift need explained 
expression computes value passed jump type destination point jump changes flow control immediate environment shift matter type shift arbitrary type domain range continuation match source destination points shift rule types respectively 
shift appears context support stack placed context domain type range type meaning captured continuation include delimiting resetx resetx handler making range type ca 
contrast calculi composable continuations capture delimiting reset continuation leave environment :10.1.1.50.2608:10.1.1.50.2608:10.1.1.50.2608:10.1.1.32.3968:10.1.1.32.3968:10.1.1.32.3968
decision adds expressiveness calculus illustrate point section 
typing rule reset simpler 
construct resetx establishes destination point allows expression shift placing support 
value immediately falls destination point types 
allow arbitrary weakening supports rule order satisfy support weakening principle 
partial ordering imposed family supports trivial partial ordering empty stack smallest element holds sequences 
example program particularly convoluted way reversing list adopted :10.1.1.17.1563
fun reverse intlist intlist choose intlist 
fun rev intlist case nil box nil xs val rev xs box 
resetx unbox box rev resetx shift resetx typing rules composable continuations 
understand reverse instructive view particular evaluation helper function rev 
example rev produces box :10.1.1.17.1563
resetx unbox box 
resetx unbox box 
resetx unbox box nil prepended resetx unboxed evaluated code uses continuations accumulate reversed prefix list 
example bound box box corresponding initial empty prefix bound box box bound box box reversed list produced 
development operational semantics previous ect calculi start extending notion evaluation contexts core language defining new redexes 
evaluation contexts 
resetx pure contexts box choose redexes 
resetx resetx shift shift handled nearest reset typing rules ensure labeled name need identify evaluation context reset closest hole similar calculus exceptions identify specific subclass evaluation contexts pure sense contain resets 
easy prove evaluation context pure exist unique evaluation context pure context reset 
primitive reduction rules new redexes defined 
reset reset shift box box reduction rule simple just serves values pass reset 
values ect free case shift free resets really relevant 
second primitive reduction deserves comment 
prescribes evaluation context captured substituted continuation variable notice reset delimits context discarded altogether evaluation 
survive capturing part reduct survive captured continuation includes 
pointed fact discussion type system reduction rule formal 
merits choices 
obvious reset removed environment shift names support stack 
bit di cult explain benefits decision delimiting reset discarded captured continuation 
purely technical aspect certainly flexible discard reset include continuation 
reset missing put back retained eliminate 
important point improves expressiveness calculus 
particular example mind concerns application composable continuations neatly encode bounded nondeterministic computation depth search employed explore space solutions :10.1.1.50.2608:10.1.1.17.1563
able system particular design decision express manner breadth search 
illustrate argument examples 
example depth search composable continuations conveniently express nondeterministic computation computation return results :10.1.1.50.2608:10.1.1.17.1563
paraphrase papers program finding triples distinct positive integers smaller sum ectively phrased terms primitive function choice 
choice int int fun choice box int unit 
fun loop int unit box box resetx loop loop triple int int unit fun triple resetx val unbox choice val unbox choice val unbox choice print run function triple print triples returning unit :10.1.1.17.1563
program works maintaining list composable continuations represented run time sequentially composed sequence expressions unit type 
call choice picks top element list stores top element composable continuation delimited name unit time removing list 
element expanded resetx resetx reset resetx placed back top list 
sense strategy program uses exploring search space depthfirst 
depth search tree bounded particular example program enumerate solutions 
relation composable continuations style bounded non determinism :10.1.1.50.2608:10.1.1.17.1563
example breadth search calculus composable continuations limited depth search strategy 
example employ breadth search enumerate solutions search space unbounded depth 
outlined continuations capture environment including resets provides needed expressiveness 
particular expanding top element list computations need push newly expanded cases top list previous example place bottom 

capture list computations continuation function 
argument function abstracts top list adding new elements top list represented continuation doing depth search influenced continuation delimited reset 
continuations delimited elements added bottom delimiter gets way 
capture delimiting reset continuation extend represented list bottom encoding breadth search strategy place reset back delimit new list 
scope reset include newly expanded search cases 
paraphrase continuations delimited time capturing type system force delimit invoked chance modify suit needs 
example version triple uses breadth search strategy 
need names delimit continuations name unit delimits individual entries list name unit list 
new function picks top element expands resetx resetx resetx resetx 
expanded segment attached bottom list captured continuation 
int int fun box int unit 
shift unit unit 
reset fun loop int unit box box resetx loop box box resetx loop triple int int unit fun triple reset resetx val unbox val unbox val unbox print structural properties core fragment readily extend new cases characteristic calculus composable continuations 
lemma unique decomposition expression 
value 
shift unique pure context 
unique evaluation context redex theorem calculus satisfies progress preservation 
related integrating ects functional calculi quite long history section bound incomplete 
numerous systems proposed treating various ects various levels precision verbosity typing 
example list :10.1.1.32.3968
treatment exceptions haskell peyton jones :10.1.1.17.1563
associates exceptions values value type normal exceptional 
similar calculus expressions function calls marked type system exceptional 
introduces handling exceptions means primitive map getexception enclosed io monad preserve soundness 
exception calculi de groote 
call value calculus uses separate binding mechanisms introduce exceptions computation 
calculus lacks modal monadic types specifically require values language ect free case implements standard ml exception mechanism 
logical content exceptions relationship classical logic 
exception mechanism java relates calculus java methods labeled exceptions raise :10.1.1.32.3968
catch throw calculus specific simplifications exceptions theoretical analysis catch throw :10.1.1.32.3968:10.1.1.17.1563
composable continuations probably considered felleisen untyped setting shifting nearest reset prompt 
sitaram felleisen generalized family control operators shifting indexed numeral prescribing closest resets jumped 
untyped setting hieb dybvig anderson introduce labels numerals describe destination points hierarchy shifts :10.1.1.32.3968
danvy filinski develop type system composable continuations single shift operator :10.1.1.17.1563
resets labeled 
appendix briefly discuss idea employed capturing remove resets environment jumps resets context stack 
logical content composable continuations studied murthy :10.1.1.17.1563
develops type system composable continuation hierarchy shifting operators monads indexed lists types restrict resets implication free types order preserve soundness 
wadler analyses type systems composable continuations single shift operator hierarchy shift operators presents terms indexed monads :10.1.1.50.2608
kameyama works labels numerals provide hierarchy shifting operators :10.1.1.32.3968:10.1.1.32.3968
calculi lack modal monadic types mentioned system exceptions limit calculus order avoid scope extrusion labels preserve soundness 
coming side logic type theory ect calculi directly representable monads 
monads denotational semantics moggi adopted functional programming wadler represent computations :10.1.1.100.9674:10.1.1.32.3968
point filinski develops concepts monadic reflection reification intentions similar increase flexibility monadic programming delimit scope ects 
similar motivation lies kieburtz lexical scoping ects :10.1.1.32.3968
hand specifically motivated pfenning davies formulates natural deduction variant modal logic proof term calculus :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
shows monadic system embedded modalities 
modal necessity defined comonad fact comonads may represent ects noticed kieburtz pardo relation handling established :10.1.1.32.3968:10.1.1.17.1563
modal necessity naturally extended notion names argued :10.1.1.17.1563
calculus direct precursor ect system 
motivated nominal logic freshml pitts gabbay introduce names urelements fraenkel mostowski set theory 
introduced logically motivated ect system modal logic designed naturally uniformly support process ect handling 
founded observation pfenning davies monad decomposed terms operators necessity possibility variant modal logic :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
calculus necessity operator serves mark impure program segments accounts hygienic propagation ects represent ects handled 
give callby value operational semantics language purely logical formulation favor particular evaluation strategy possible hope explore system equational theory 
system extends modal calculus names labels dynamically introduced computation serve identify ects :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
possibly ordered collection ects may appear certain term refered support term 
typing judgment relates terms supports terms empty support guaranteed ect free considered evaluation 
notion support calculus flexible depending particular ect modeled di erent definitions support may 
example case exceptions catch throw supports simply sets names listing exceptions jump destinations respectively 
case composable continuations supports stacks names depicting environments nested continuation delimiting points 
interesting investigate di erent definitions support may interact system combining ects heterogeneous respect 
system modalities indexed supports 
example type ca classifies computations type capable raising ects names listed support possible project value type computation type ca ects handled way specified particular ects question 
special case empty support computation ect free value projected trivially behavior propositional necessity recovered 
impose monotonicity new logic multiple modalities resulting identification types type empty index support 
operationally allow coerce values computations monadic system 
system consists core ect calculus easily extended account various ects simply providing elimination handling forms specifying particular notions support suitable ect 
demonstrate extending core fragment new calculi exceptions catch throw composable continuations 
mention obtained systems probably practical verbosity support annotations types may significantly complicate serious programming ort 
may comfort similar criticism fact applicable ect calculi 
rate important investigate questions type support inference calculus possibly style develop new abstraction mechanism hide unwanted support result practical language combining support polymorphism proof irrelevance :10.1.1.17.1563
system logically motivated fully explicit supports terms solid theoretical basis investigations 
acknowledgments author frank pfenning numerous suggestions regarding 
bauer :10.1.1.32.3968
propositions types 
technical report se institut le er royal swedish academy sciences 
danvy filinski :10.1.1.17.1563
functional abstraction typed contexts 
technical report diku computer science department university copenhagen 
danvy filinski 
abstracting control 
conference lisp functional programming pages nice france 
davies pfenning 
modal analysis staged computation 
journal acm 
de groote 
simple calculus exception handling 
dezani ciancaglini plotkin editors typed lambda calculi applications volume lecture notes computer science pages 
springer 
felleisen 
theory practice class prompts 
symposium principles programming languages popl pages san diego california 
filinski 
representing monads 
symposium principles programming languages popl pages portland oregon 
filinski 
controlling ects 
phd thesis carnegie mellon university 
filinski 
representing layered monads 
symposium principles programming languages popl pages san antonio texas 
gosling joy steele :10.1.1.32.3968
java language specification 
addisonwesley 
hieb dybvig anderson iii :10.1.1.32.3968
subcontinuations 
lisp symbolic computation 
kameyama :10.1.1.32.3968
logical understanding delimited continuations 
sabry editor proceedings third acm sigplan workshop continuations cw pages 
technical report computer science department indiana university 
kameyama :10.1.1.32.3968
type theoretic study partial continuations 
van leeuwen watanabe hagiya mosses ito editors theoretical computer science exploring new frontiers theoretical informatics volume lecture notes computer science pages 
springer 
kameyama sato :10.1.1.32.3968
strong non deterministic catch throw calculi 
theoretical computer science 
kieburtz :10.1.1.32.3968
taming ects monadic typing 
international conference functional programming icfp pages baltimore maryland 
kieburtz :10.1.1.32.3968
codata comonads haskell 
unpublished 
available www cse ogi edu dick 
lucassen gi ord :10.1.1.32.3968
polymorphic ect systems 
symposium principles programming languages popl pages san diego california 
milner tofte harper macqueen :10.1.1.32.3968
definition standard ml revised 
mit press 
moggi :10.1.1.32.3968
computational lambda calculus monads 
symposium logic computer science lics pages asilomar california 
moggi :10.1.1.17.1563
notions computation monads 
information computation 
murthy :10.1.1.17.1563
control operators hierarchies pseudo classical type systems translation 
danvy talcott editors proceedings acm sigplan workshop continuations cw pages 
technical report stan cs stanford university 
nakano :10.1.1.17.1563
constructive formalization catch throw mechanism 
symposium logic computer science lics pages santa cruz california 
:10.1.1.17.1563
meta programming names necessity 
international conference functional programming icfp pages pittsburgh pennsylvania 
significant revision available technical report computer science department carnegie mellon university 
:10.1.1.17.1563
dynamic binding state modal possibility 
international conference principles practice declarative programming ppdp pages uppsala sweden 
appear 
pardo :10.1.1.17.1563
merging recursion comonads 
proceedings nd workshop generic programming pages ponte de lima portugal 
peyton jones reid hoare marlow henderson :10.1.1.17.1563
semantics imprecise exceptions 
conference programming language design implementation pldi pages atlanta georgia 
pfenning :10.1.1.17.1563
extensionality proof irrelevance modal type theory 
symposium logic computer science lics pages boston massachusetts 
pfenning davies :10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563:10.1.1.17.1563
judgmental reconstruction modal logic 
mathematical structures computer science 
pitts :10.1.1.17.1563
nominal logic order theory names binding 
kobayashi pierce editors theoretical aspects computer software volume lecture notes computer science pages 
springer 
pitts gabbay :10.1.1.17.1563
metalanguage programming bound names modulo renaming 
backhouse oliveira editors mathematics program construction volume lecture notes computer science pages 
springer 
sitaram felleisen 
control delimiters hierarchies 
lisp symbolic computation 

talpin jouvelot 
polymorphic type region ect inference 
journal functional programming 

talpin jouvelot 
type ect discipline 
information computation 
thielecke 
control ects typed continuation passing 
symposium principles programming languages popl pages new orleans louisiana 
wadler 
essence functional programming 
symposium principles programming languages popl pages new mexico 
wadler :10.1.1.50.2608
monads composable continuations 
lisp symbolic computation 
wadler 
monads functional programming 
jeuring meijer editors advanced functional programming volume lecture notes computer science pages 
springer 
wadler :10.1.1.18.9697
marriage ects monads 
international conference functional programming icfp pages baltimore maryland 
lee pfenning 
run time code generation modal ml 
conference programming language design implementation pldi pages montreal canada 
lee pfenning davies 
modal types staging specifications run time code generation 
acm computing surveys es 
wright felleisen 
syntactic approach type soundness 
information computation 

