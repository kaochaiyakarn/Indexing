veri cation java programs symbolic execution invariant generation corina willem visser kestrel technology nasa ames research center mo ett field ca usa email arc nasa gov riacs nasa ames research center mo ett field ca usa email arc nasa gov 
software veri cation recognized important dif cult problem 
novel framework symbolic execution automated veri cation software 
framework uses annotations form method speci cations loop invariants 
novel iterative technique uses invariant strengthening approximation discovering loop invariants automatically 
technique handles di erent types data boolean numeric constraints dynamically allocated structures arrays allows checking universally quanti ed formulas 
framework built top java pathfinder model checking toolset veri cation non trivial java programs 
model checking popular technique veri cation software typically deal closed systems su ers state explosion problem :10.1.1.32.5769:10.1.1.134.652
previous developed veri cation framework symbolic execution model checking allows analysis complex software take inputs unbounded domains complex structure helps combat state space explosion :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
framework program instrumented add support manipulating formulas systematic treatment aliasing enable standard model checker perform symbolic execution program 
framework built top java pathfinder model checker test input generation error detection complex java programs proving properties programs containing loops 
method uses symbolic execution framework proving light weight speci cations java programs contain loops :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
method requires annotations form method speci cations loop invariants 
novel iterative technique uses invariant strengthening approximation discovering loop invariants automatically 
technique uniformly handles di erent types constraints boolean numeric constraints constraints dynamically allocated structures arrays allows checking universally quanti ed formulas 
formulas necessary expressing properties programs manipulate unbounded data arrays 
technique loop invariant generation works backward property checked basic ingredients iterative invariant strengthening iterative approximation re nement 
symbolic execution check current invariant inductive base case checks current candidate invariant true entering loop induction step checks current invariant maintained execution loop body 
failed proofs induction step iterative invariant strengthening process may result possibly nite sequence candidate invariants 
strengthening step novel iterative approximation technique achieve termination 
strengthening step nite set relevant constraints called universe constraints iterative approximation consists sequence strengthening drop constraints newly generated 
nite process guaranteed converge inductive approximate invariant boolean combination constraints intuition similarities predicate abstraction techniques perform iterative computations nite set predicates constraints 
failed base case proof indicate error program approximation current step strong case re nement consists enlarging universe constraints new constraints come candidate invariant computed step 
loop invariant generation received attention literature see 
methods papers concerned generation numerical invariants 
describes loop invariant generation method java programs uses predicate abstraction :10.1.1.12.7968
method handles universally quanti ed speci cations relies user supplied input predicates 
show section iterative technique discovers invariants examples user supplied predicates :10.1.1.12.7968
main contributions veri cation framework combines symbolic execution model checking novel way extend basic framework ability handle arrays symbolically prove partial correctness speci cations may universally quanti ed :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
results exible powerful tool proving program correctness addition test input generation model checking 
new method iterative invariant generation 
method handles uniformly di erent types constraints boolean numeric constraints arrays objects conjunction powerful approximation methods widening 
series small non trivial java examples showing merits method method extends languages model checkers 
precondition null void example int int assert fig 

motivating example section shows example analysis framework 
section gives background symbolic execution describes symbolic execution framework java programs 
section gives method proving properties java programs symbolic execution invariant generation section illustrates application veri cation non trivial java programs 
give related section conclude section 
example illustrate veri cation framework code shown 
method takes parameter array integers sets elements zero 
method precondition input null 
assert clause declares partial correctness property states execution loop value rst element zero 
loop invariant framework automatically check array bounds violations 
simple invariant stated ort 
order prove assertion violations complex loop invariant needed 
constructing loop invariant requires ingenuity 
framework discovers invariant iterative approximation 
starts length weakest possible invariant necessary prove assertion violated 
checking invariant see inductive nd violation formula length length holds loop hold loop 
iteration strengthen length drop new constraint length due iterative computation loop body 
yields formula length length simpli es desired invariant 
suppose want verify additional assertion states execution loop element array set zero int 
assertion universally quanti ed refers quanti ed variable program variables 
model introducing symbolic constant new variable mentioned int assert false pc pc pc pc pc pc true pc false 
pc fig 

code swaps integers corresponding symbolic execution tree transitions labeled program control points program assigned new unconstrained symbolic value 
symbolic execution framework automatically infers loop invariant length length length 
symbolic constant represents xed unknown value invariant valid value technique crucial checking programs manipulate unbounded data arrays :10.1.1.12.7968
symbolic execution java pathfinder section give background symbolic execution symbolic execution framework reasoning java programs 
background symbolic execution main idea symbolic execution symbolic values actual data input values represent values program variables symbolic expressions :10.1.1.12.7968
result output values computed program expressed function input symbolic values 
state symbolically executed program includes symbolic values program variables path condition pc program counter 
path condition quanti er free boolean formula symbolic inputs accumulates constraints inputs satisfy order execution follow particular associated path 
program counter de nes statement executed 
symbolic execution tree characterizes execution paths followed symbolic execution program 
nodes represent program states arcs represent transitions states 
consider code fragment swaps values integer variables greater shows corresponding symbolic execution tree 
initially pc true symbolic values respectively 
branch point pc updated assumptions inputs order choose alternative paths 
example execution rst statement alternatives statement possible pc updated accordingly 
path condition false set inputs satisfy means symbolic state reachable symbolic execution continue path 
example statement unreachable 
generalized symbolic execution describe algorithm generalizing traditional symbolic execution support advanced constructs modern programming languages java :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
algorithm handles dynamically allocated structures lists trees method preconditions acyclicity lists data integers strings concurrency 
partial correctness properties assertions program temporal speci cations 
extended adding support symbolic execution arrays checking quanti ed formulas :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
symbolic execution framework symbolic execution framework automates test case generation allows model checking concurrent programs take inputs unbounded domains complex structure 
enable model checker perform symbolic execution original program instrumented doing source source translation adds nondeterminism support manipulating formulas represent path conditions 
model checker checks instrumented program usual state space exploration techniques essentially model checker explores symbolic execution tree program 
state includes heap con guration path condition primitive elds thread scheduling 
path condition updated checked satis ability appropriate decision procedure omega library linear integer constraints :10.1.1.12.7968
path condition unsatis able model checker backtracks 
note performing forward symbolic execution programs loops explore nite execution trees 
systematic state space exploration framework uses depth rst search iterative deepening breadth rst search :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
framework test input generation nding counterexamples safety properties 
upper bound number times loop program may executed framework proving correctness corresponding symbolic execution tree nite 
programs xed bound number times loop executed exists corresponding execution trees nite 
order void example new expression new expression pc update lt length set new plus new assert expression pc update eq get new fig 

instrumented code prove correctness programs extended framework ability traversing symbolic execution tree inductively explicitly loop invariants section 
java pathfinder framework uses java pathfinder jpf model checker analyze instrumented programs 
decision procedure framework uses java implementation omega library 
jpf explicit state model checker java programs built top custom java virtual machine jvm 
built jvm handle language features java addition treats nondeterministic choice expressed annotations program analyzed annotations added programs method calls special class verify 
features verify choose boolean verify choose adding nondeterminism implement updating path conditions 
jpf supports program annotation forces search backtrack verify condition certain condition evaluates true analysis infeasible paths path conditions unsatis able 
instrumentation interested reader referred detailed description code instrumented symbolic execution just highlight key new features :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
main idea replace concrete types corresponding symbolic types library classes provide concrete operations method calls implement equivalent operations symbolic types 
illustration instrumentation consider code 
gives part resulting code instrumentation gives part library classes provide 
classes expression support manipulation symbolic integers symbolic integer arrays respectively 
class expression static pc expression plus expression 
class 
constraints boolean update lt expression expression boolean result result verify choose boolean result add constraint lt add constraint ge verify sat return result class vector expression length 
new expression idx int cell elementat expression pc update eq cell idx idx return cell new length idx name add return public expression get expression idx assert expression pc update ge idx expression pc update lt idx length cell new idx return cell elem fig 

library classes static eld expression 
pc stores numeric path condition 
method update lt nondeterministic choice call choose boolean add path condition constraint negation constraint invocation expresses returns corresponding boolean 
method sat uses omega library check path condition infeasible case jpf backtrack 
method plus constructs new expression represents sum input parameters 
subclass expression wraps concrete integer values 
store input array elements created result lazy initialization variable class vector input array 
get set methods elements vector systematically initialize input array elements 
execution accesses symbolic array cell algorithm nondeterministically initializes new cell cell created prior cell initialization 
assertion checks get set methods establish array bounds errors 
proving properties java programs section floyd hoare style method proving lightweight properties java programs 
method requires loop invariants novel iterative technique discovering automatically 
init body assert init assert base case symbolic variables assume assert induction step pc assert fig 

single loop program left instrumented program proof right proving properties symbolic execution simplicity presentation illustrate methodology single loop program left multiple loops treated similarly see 
program consists loop free initialization code loop condition loop free body post condition verify program suces nd loop invariant formula true entering loop re entering loop iteration exiting loop 
strong produce veri able results loop invariant true general sucient 
symbolic execution framework amounts checking assertions modi ed program right 
replaced statement statement equivalent placing cut loop 
cut point consider variables modi ed loop body initialized new symbolic values path condition initialized true 
note symbolic execution point representative arbitrary number loop input variables cut point variables modi ed loop body new symbolic values represent cases 
program loop cut symbolic execution terminate nite symbolic execution tree 
check assertions assertion line base case inductive argument checks holds entering loop assertion line induction step checks assuming holds loop holds execution loop body inductive assertion line checks strong property hold assertion violations loop free program right program left violate property technique verify properties complex java programs symbolic execution framework section 
technique requires generation loop invariants 
invariant generation generation loop invariants intricate problem requires deep understanding loops 
propose novel technique generating loop invariants automatically 
technique works backward starting property proved basic ingredients iterative invariant strengthening iterative approximation re nement 
iterative invariant strengthening consider example 
check actual property assertion line de ning initial candidate invariant weakest possible choice 
base case fails candidate invariant program veri able assertion violation 
checking inductive step generates symbolic paths loop body 
paths invariant inductive replaced stronger invariant 
assume pc pc pcn path conditions paths veri cation induction step fails 
path conditions characterize inputs loop body check inductive step fails 
invariant strengthened replacing pc pc pcn base case inductive step checked 
applied repeatedly process introduce nitely new constraints lead nite sequence exact candidate invariants propose simple powerful approximation technique help termination 
iterative approximation step apply approximation phase current candidate invariant rst observe symbolically executing assumption body loop executing lines code right generate nite number symbolic execution paths contain nite number constraints call constraints universe constraints step contains constraints current invariant constraints generated symbolically executing loop body 
new constraints may get generated symbolic execution assertion line 
distinguish exact candidate invariants generated iterative invariant strengthening approximate candidate invariants generated iterative approximation 
base case fails exact invariant program veri able 
base case fails approximate invariant indicate approximation coarse needs re nement 
pc path condition path loop body checking discovering violation assertion line path condition path loop body checking assertion 
said checking assertion potentially add new constraints path condition set constraints accumulated subset set constraints pc 
approximation phase strengthening invariant pc weaker pc pc ect obtaining stronger invariant 
words approximation consists strengthening step drop newly generated constraints constraints pc 
approximation phase generates sequence approximate candidate invariants nite number constraints process guaranteed terminate yielding inductive invariant 
boolean combination constraints contained re nement base case fails approximate invariant may approximation strong 
means universe constraints coarse proving property needs re ned 
simple re nement consider base case fails approximate invariant 
amounts backtracking candidate invariant computing exact candidate invariant applying approximation phase iteration 
note set constraints subset set constraints yield ner approximation steps 
note program error eventually caught proof base case fail exact invariant 
description general veri cation method seen basic ingredients general method checking properties works 
check actual property come initial candidate invariant check base case inductive step invariant 
checks yield errors done result property holds program current invariant inductive inductive step fails apply iterative approximation get stronger invariant go back checking base case inductive step base case fails current candidate invariant exact done result property hold program base case fails current candidate invariant approximate apply re nement check base case inductive step error program method guaranteed terminate reporting error 
program correct respect property iterative method terminate re nement continue inde nitely 
void example new expression new try assert base case new expression new verify assume expression pc update lt length set new plus new 
pc assert induction step assert expression pc update eq get new assert expression pc update eq get catch 
print 
print pc fig 

motivating example veri cation excerpts illustration consider motivating example program section 
program instrumented allow symbolic veri cation inductive reasoning illustrated 
assertion violation triggers exception caught program see lines instrumented code 
variable stores value path condition check inductive step value approximation phase invariant strengthening 
model checking program jpf prints path conditions pc assertion violations 
rst check assertion line fails 
initial candidate invariant length 
instrument formula enable symbolic execution add lines model check program nd counterexample path condition pc length 
point iterative approximation strengthening invariant drop newly generated constraint length pc yielding new candidate invariant 
invariant suces prove property 
order check additional assertion declare new symbolic variable line check assertion line instrumented symbolic execution 
initial candidate invariant length length 
model checking program additional invariant gives counterexample path condition pc length length length 
strengthening invariant get length suces prove property 
discussion method extends framework ability proving partial correctness speci cations :10.1.1.12.7968:10.1.1.12.7968:10.1.1.12.7968
yields exible framework checking java programs 
general methodology framework rst model checker depth rst search iterative deepening breadth rst search 
errors certain depth con dence program correct respect property proof correctness attempted method section 
error model checking phase base case violation exact candidate invariant 
approximation consists dropping newly generated constraints potentially powerful expensive approximation dropping constraints replace appropriate boolean combination existing constraints similarities predicate abstraction techniques investigate 
technique conjunction powerful methods 
current system fully automated discover path conditions lead assertion violation automatically combine conditions hand candidate invariant add back code check inductive 
implementation features currently underway 
traditionally invariant generation performed iterative forward backward traversal di erent heuristics terminating iteration convergence accelerated auxiliary invariants proved invariants structural invariants obtained static analysis 
interpretation introduced widening operator compute xpoints systematically 
alternative methods constrained techniques numeric invariant generation 
methods techniques domain speci method invariant generation uniformly treats di erent kinds constraints 
method viewed iterative deepening search sucient set constraints express invariant strong verifying property 
step search guaranteed terminate deepening re nement may non terminating 
precondition null null length length int find int boolean int spot length int spot length spot assert spot length spot return spot fig 

method find experiments section shows application framework veri cation non trivial java programs 
compare invariant generation method :10.1.1.12.7968
show example method able infer loop invariant case bene powerful approximation techniques 
method nd shows example adapted :10.1.1.12.7968
method find takes parameters array integers array booleans method returns index rst non zero element exists length 
method sets th element true th element nonzero false 
preconditions method state arrays null length 
assertion states index returned spot length true index 
check assertion array bounds violations framework infers invariant approximation steps length spot length spot length spot length spot spot length spot length 
invariant sucient prove property 
checked additional assertion states method execution element spot contains false int spot :10.1.1.12.7968
prove assertion holds framework generates additional invariant length spot spot length length spot length length spot spot length spot spot spot 
node partition node int node curr node prev null node newl null node curr null curr curr elem prev null prev curr curr newl assert curr prev newl curr prev curr curr return newl void int int int hint assert fig 

method partition left example right method starts set interesting predicates provided user performs iterative forward computations compute loop invariant combination predicates :10.1.1.12.7968
proving rst assertion example method requires predicates spot length spot spot proving second assertion method requires additional predicates spot 
contrast method require user supplied predicates note predicates generated heuristic methods described :10.1.1.12.7968
note invariants concise disjunctive normal form :10.1.1.12.7968
method works backward starting property checked naturally discovers necessary constraints program variables symbolic execution re nement :10.1.1.12.7968
interesting research direction method conjunction step approximation predicate abstraction method starting set constraints list partition left shows list partitioning example adapted :10.1.1.12.7968
list element instance class node contains elds integer elem node list 
method partition takes arguments list integer value removes node value greater returns list containing nodes 
assertion states curr aliased prev 
framework checks assertion violations generates sequence candidate invariants 
curr prev curr null curr elem 
curr prev curr null prev null curr elem 
approximate invariant strong leads base case violation 
framework backtracks continues exact invariant curr prev curr null prev null curr elem prev elem prev curr 
curr prev curr null prev null curr elem prev elem prev curr 
approximate invariant inductive 
example shown framework handle constraints structured data 
successfully applied framework examples checked absence null pointer dereferences 
pathological example iterative method invariant generation section terminate 
example consider code right method works backward property rst attempt compute loop invariant second loop 
iterative re nement terminate loop 
considering increasing number exact strengthening steps help 
intuitively method converge constraint negation important achieving termination constraint get discovered repeated symbolic executions code loop body 
programmer provide additional helpful constraints hand form hints boost precision iterative approximation method 
example hint line code right ect nondeterministically adding constraint negation current path condition constraints added universe constraints strengthening step 
hint get loop invariant second loop approximation steps 
invariant postcondition rst loop get loop invariant rst loop suces prove property 
note powerful techniques linear equalities domain example :10.1.1.12.7968
framework conjunction powerful abstraction techniques alternative dynamic methods discovering loop invariants daikon tool provide useful hints :10.1.1.12.7968
note methods predicate abstraction re nement implemented slam tool terminate example 
related discussed related invariant generation 
link approach software veri cation tools 
king developed system symbolic execution programs xed number integer variables :10.1.1.12.7968
supported various program analyses assertion correctness checking earliest systems kind 
projects aim developing static analyses verifying program properties 
extended static checker esc uses theorem prover verify partial correctness classes annotated jml speci cations 
esc verify absence errors null pointer dereferences array bounds violations division zero 
tools esc rely heavily speci cations provided user bene invariant generation techniques 
valued logic analyzer tvla static analysis system verifying rich structural properties preservation list structure programs perform list reversals destructive updating input list :10.1.1.12.7968
tvla performs xed point computations shape graphs represent heap cells shape nodes sets indistinguishable runtime locations summary nodes 
approximation technique similarities widening operations static analysis 
explore connection 
pointer assertion logic engine pale verify large class data structures represented spanning tree backbone possibly additional pointers add extra information :10.1.1.12.7968
data structures include doubly linked lists trees parent pointers threaded trees 
shape analyses tvla pale typically verify properties programs perform operations numeric data values 
lot interest applying model checking software 
java pathfinder verisoft operate directly java respectively program 
projects bandera translate java programs input language veri cation tools 
extend tools ability prove partial correctness speci cations 
composite symbolic library uses symbolic forward xed point operations compute reachable states program :10.1.1.12.7968
uses widening help termination analyze programs manipulate lists xed number integer elds deal closed systems 
slam tool focuses checking sequential code static data engineered predicate abstraction abstraction re nement tools 
handle dynamically allocated data structures 
symbolic execution map counterexamples concrete executions re ne abstraction adding new predicates discovered symbolic execution 
note tools slam perform abstraction program statement method performs approximation seen form abstraction necessary loop headers 
indicates method potentially cheaper terms number predicates constraints required 
course experimentation necessary support claim 
similarities predicate abstraction iterative approximation method compare methods terms relative completeness :10.1.1.12.7968
novel framework symbolic execution veri cation software 
framework uses annotations form method speci cations loop invariants 
novel iterative technique discovering loop invariants automatically 
technique works backward property checked systematically applies approximation achieve termination 
technique handles uniformly numeric constraints constraints structured data allows checking universally quanti ed formulas 
illustrated applicability framework veri cation non trivial java programs 
presentation context java programs jpf omega library framework instantiated languages model checkers decision procedures 
plan investigate application widening powerful abstraction techniques conjunction method invariant generation 
plan extend framework handle multithreading richer properties 
integrate di erent semi decision procedures constraint solvers allow handle nonlinear constraints 
believe framework presents promising exible approach analysis software 
scales real applications remains seen 

ball majumdar millstein rajamani 
automatic predicate abstraction programs 
proc 
pldi pages 

ball podelski rajamani 
relative completeness abstraction re nement software model checking 
proc 
tacas 

bensalem lakhnech saidi 
powerful techniques automatic generation invariants 
proc 
cav 

bjorner browne colon manna sipma uribe 
verifying temporal properties reactive systems step tutorial 


colon sipma 
linear invariant generation non linear constraint solving 
proc 
cav 

corbett dwyer laubach robby zheng 
bandera extracting nite state models java source code 
proc 
icse 

cousot cousot 
abstraction software veri cation 
proc 
cav 

cousot halbwachs 
automatic discovery linear restraints variables program 
proc 
th popl 

podelski 
widen narrow relax 
technical report 

detlefs leino nelson saxe 
extended static checking 
research report compaq systems research center 

dor rodeh sagiv 
checking linked lists 
proc 
sas 

ernst griswold notkin 
quickly detecting relevant program invariants 
proc 
icse 
acm 

flanagan qadeer 
predicate abstraction software veri cation 
proc 
popl 

floyd 
assigning meanings programs 
proc 
symposia applied mathematics pages 

godefroid 
model checking programming languages verisoft 
proc 
popl pages paris france jan 

graf saidi 
verifying invariants theorem proving 
proc 
th cav pages 

graf saidi 
construction state graphs pvs 
proc 
th cav pages 

king 
proving correctness programs 
acm comput 
surv 

havelund shankar 
experiments theorem proving model checking protocol veri cation 
proc 
fme pages 

hoare 
axiomatic basis computer programming 
commun 
acm 

holzmann 
spin model checker primer manual 


karr 
ane relationships variables program 
acta informatica 
:10.1.1.12.7968
khurshid visser 
generalized symbolic execution model checking testing 
proc 
tacas 

king 
symbolic execution program testing 
commun 
acm 

manna pnueli 
temporal logic reactive concurrent systems speci cation 


moeller schwartzbach 
pointer assertion logic engine 
proc 
pldi snowbird ut june 

pugh 
omega test fast practical integer programming algorithm dependence analysis 
communications acm aug 

sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm trans 
prog 
lang 
syst january 

tiwari saidi shankar 
technique invariant generation 
proc 
tacas 

visser havelund brat park 
model checking programs 
proc 
ase grenoble france 

wegbreit 
synthesis loop predicates 
communications acm 

wolper 
verifying systems nite regular state spaces 
proc 
cav pages 


automated veri cation concurrent linked lists counters 
proc 
sas 
