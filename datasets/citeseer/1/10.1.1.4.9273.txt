journal artificial intelligence research submitted published metric ff planning system translating ignoring delete lists numeric state variables jorg hoffmann hoffmann informatik uni freiburg de institut fur informatik georges kohler geb 
freiburg germany planning numeric state variables challenge years part rd international planning competition ipc 
currently popular successful algorithmic techniques strips planning guide search heuristic function heuristic relaxing planning task ignoring delete lists available actions 
natural extension ignoring delete lists numeric state variables preserving relevant theoretical properties strips relaxation condition numeric task hand monotonic 
identify subset numeric ipc competition language linear tasks monotonicity achieved preprocessing 
extend algorithms heuristic planning system ff linear tasks 
resulting system metric ff ipc results discuss currently efficient numeric planners 

planning community long aware fact purely propositional representation languages particular strips fikes nilsson suited modeling various phenomena essential real world problems 
particular modeling context dependent effects concurrent execution actions different duration continuous resources awkward impossible strips language 
overcome limitations pednault defined nowadays widely accepted adl language things allows conditional effects effects occur condition holds true state execution 
overcome limitations various proposals ghallab koehler smith weld 
effort direction pddl language defined fox long input language rd international planning competition ipc 
ipc series biennial challenge planning community inviting planning systems participate large scale publicly accessible evaluation 
ipc hosted aips stressed planning strips formalism featuring tracks temporal numeric planners 
article describes approach planners participated ipc metric ff 
metric ff extension ff system handle adl numeric constructs 
currently popular successful algorithmic techniques strips planning guide search forward backward state space plan space heuristic fl ai access foundation 
rights reserved 
hoffmann function heuristic relaxing planning task ignoring delete lists negative effects available actions 
heuristic value search state framework estimate difficulty extending state solution relaxed actions 
idea independently proposed mcdermott bonet widely huge number variations 
examples planners idea mcdermott hsp various configurations bonet geffner grt mips stan fox long repop nguyen kambhampati kambhampati ff hoffmann hoffmann nebel 
search paradigms planners include forward backward state space search partial order planning 
forward state space planner ff especially successful ipc bacchus 
follows extend heuristic idea strips ignoring delete lists numeric state variables way preserves relevant theoretical properties strips relaxation 
phrase properties admissibility basic polynomiality 
investigation takes place setting forward state space search ff ideas search schemes plan space search outlook section 
system deals numeric constructs 
heuristic function completely ignores numeric goals lacks relevant theoretical properties basic return 
numeric versions mips grt 
respective mips version publication available time writing article reader referred appear jair special issue 
numeric version grt grt allows restricted form numeric variables expressions basically limited form resource allocation consumption 
heuristic function considers resource consumption form state cost 
heuristic lacks basic see 
numeric planning task numeric constraints action preconditions goal numeric effects action effects 
constraints effects different types 
example constraint require value variable high high constant 
numeric effects semantic perspective increase decrease value affected variable 
delete effects strips decrease logical value propositional variables idea explore relax numeric task ignoring decreasing effects 
main difficulty idea ignoring decreasing effects necessarily simplify task 
example goal requires initially equal decreasing effects needed solve task relaxed task unsolvable 
relaxation adequate preserves theoretical properties mentioned tasks preferable higher variable values 
call tasks monotonic 
observe tasks belong subset numeric ipc competition language linear tasks numeric variables linear functions brought 
duality respect ignoring increasing effects decreasing effects 
lower variable values preferable ignoring increasing effects adequate relaxation 
chooses difference 
choose monotonicity positive sense conceptually simpler 
translating ignoring delete lists numeric state variables normal form monotonic 
extend heuristic algorithms ff system linear tasks 
ff hoffmann nebel close relative hsp bonet geffner 
search takes place forward state space starting initial state new states explored goal state 
search process ff guided heuristic function solving search state relaxed task starting heuristic value number actions respective relaxed plan number actions needed achieve goal assuming delete lists empty 
states lower heuristic value preferred 
main obstacle extension ff numeric state variables extend machinery solves relaxed task search state 
machinery defined rest system translates effortlessly 
evaluate resulting planning system metric ff discussing results numeric domains rd international planning competition 
turns metric ff lpg gerevini best performing numeric planners competition 
article structured follows 
text refer related relevant 
give necessary background terms strips notation techniques strips version ff uses 
section introduces notation numeric state variables numeric subset pddl 
section describes heuristic principle strips relaxation extended numeric setting 
section defines algorithms solving relaxed numeric tasks 
section fills details relaxed plans implement metric ff planning system briefly describe adl constructs handled flexible optimization criteria taken account 
ipc results discussed section 
section concludes outlines 
appendix contains proofs 

strips techniques section give background techniques ff system uses strips language 
start examining relaxation underlies ff heuristic function 
proceed algorithms solve relaxed tasks 
describe relaxed plans implement actual ff system 
discussion little detailed strictly necessary understand ff workings 
serves provide solid background come sections turn subtopics dealt section show methodologies extended numeric setting 
start give notation strips language 
refer sets mean finite sets 
consider propositional strips language constructs logical propositions 
world state set true propositions 
action triple proposition sets pre eff eff gamma precondition add list delete list respectively somewhat unusual notation eff eff gamma extension numeric variables readable 

source code metric ff available free download ff homepage www informatik uni freiburg de hoffmann ff html 
hoffmann specify semantics world states actions 
article consider sequential planning single action time applied world state 
actions induce state transitions follows 
world state action result executing action sequence consisting solely result hai result hai eff gamma eff action applicable pre result hai undefined 
result executing action sequence ha am state recursively defined result ha am result result ha am gamma am result hi strips task word task problem avoid confusion complexity theoretic notion decision problems tuple set logical propositions task set actions initial state world state goal partial world state see 
propositions actions initial state goal taken task wants find plan 
action sequence ha am plan result ha am 
relation equality goal states plan ends 
exists plan task task solvable 
refer optimal plans 
sequential framework plan optimal task plan task contains fewer actions 
relaxing strips tasks want inform search plan function estimates goal distance search states 
idea define relaxation simplification planning tasks solve search state relaxed task take length relaxed solution estimate long solution state hand really relaxation proposed mcdermott bonet geffner relax strips tasks ignoring delete lists actions 
definition assume strips task 
relaxation action pre eff eff gamma defined pre eff relaxation fa ag 
action sequence ha relaxed plan ha plan 
ignoring delete lists simplifies task action preconditions goal positive 
identify number desirable properties relaxation 
define relaxations numeric variables properties 
definition denote problem 
assume strips task 
relaxation solvable 

opposed graphplan approaches blum furst find sets actions applied parallel 
translating ignoring delete lists numeric state variables proposition relaxation definition adequate holds true 

admissibility plan solves original task solves relaxed task assuming strips task plan relaxed plan 

basic preconditions goals trivially achieved original task holds relaxed task assuming strips task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality relaxed task solved polynomial time deciding proof trivial admissibility basic follow directly definitions polynomiality proved earlier bylander 
proof appendix want length relaxed plans heuristic function properties stated proposition important reasons 
admissibility tells optimal relaxed plan length admissible heuristic optimal real plan relaxed plan 
mistake solvable state dead relaxed plan real plan 
directions basic tell relaxation give constraints free example heuristic value zero goal states 
heuristic properties possibly parts problem solved regions heuristic information heuristic value zero goal state reached 
polynomiality tells compute heuristic function efficiently 
solving relaxed tasks ideally search state know relaxed actions needed reach goal know length optimal relaxed plan admissible heuristic 
finding optimal relaxed plans intractable bylander 
compute arbitrary necessarily optimal relaxed plans 
done graphplan style algorithm blum furst hoffmann nebel 
search state strips task build relaxed planning graph starting task 
extract relaxed plan graph 
graph building algorithm depicted 
note term admissibility way slightly abuses notation admissibility usually refers property heuristic function technique relaxation case 

formulation basic unnecessarily complicated 
chose general formulation hand definition easily transferred relaxation techniques ones introduce 
hoffmann fa pre eff fail endif endwhile succeed building relaxed planning graph task 
planning graph relaxed case simply represented sequence gamma proposition sets action sets 
built incrementally obvious fashion starting initial layer iteratively inserting add effects applicable actions 
algorithm fails point reaching goals new propositions come 
happens relaxed task unsolvable 
proposition assume strips task state algorithm depicted fails relaxed plan 
proof appendix main argument consecutive proposition layers identical hold true layers graph reached fixpoint 
case goals reached layer call relaxed plan extraction mechanism depicted 
level proposition action layer relaxed planning graph appears minimum 
fg level tg endfor select level gamma eff pre level fpg endfor endfor endfor extracting relaxed plan task levels computed algorithm 
relaxed plan extraction sequence goal sub goal sets 
goals sub goals inserted set respective level translating ignoring delete lists numeric state variables position appearance relaxed planning graph 
goal sets initialized inserting respective top level goals 
backwards loop selects layer actions support respective goal set 
goals sub goals supported preconditions respective actions new sub goals 
way termination selected actions form relaxed plan state hand 
proposition assume strips task state algorithm depicted reaches goals 
actions selected algorithm depicted form relaxed plan 
goals sub goals supported arranging actions selected layer arbitrary order yields relaxed plan 
proof appendix ff relaxed plan information heuristic state space planner easily implemented 
choices relaxed plans arrange search strategy 
describe specific methods ff efficient strips adl benchmarks hoffmann nebel 
extended system uses straightforward methods 
define heuristic function search strategy pruning technique 
heuristic estimates goal distances relaxed plan length 
definition assume strips task state ff heuristic value defined follows 
algorithm depicted fails 
ja set actions selected layer algorithm depicted 
relaxed plan state heuristic value set 
justified property proved proposition relaxed plan real plan state dead sense goals reached 
states pruned search 
search scheme kind hill climbing procedure complete lookahead find better states 
see 
enforced hill climbing standard hill climbing starts initial state performs number search iterations trying improve heuristic value state zero value reached 
normally iterative improvement done selecting best direct successor current search state enforced hill climbing uses complete breadth search find strictly better possibly indirect successor 
search cuts states seen earlier iteration expand states heuristic function recognizes dead ends 
strategy works better successors usually nearby case planning benchmarks ff heuristic function hoffmann 
better successor current search node algorithm fails 
define pruning technique selecting set promising successors search state 
unpromising successors ignored 
promising successor state generated action helpful sense 
hoffmann initialize current plan empty plan 
starting perform breadth search state avoiding repeated states hash table expanding states state fail endif add actions path current plan endwhile output current plan succeed enforced hill climbing algorithm task heuristic definition assume strips task state algorithm depicted reaches goals 
set helpful actions defined fa eff set sub goals constructed layer algorithm depicted 
words action considered helpful achieves lowest level goals relaxed plan state hand 
helpful actions information pruning technique 
breadth search iteration enforced hill climbing expanding state states generated actions included search space 
note states relaxed planning graph reach goals get expanded anyway 
general enforced hill climbing helpful actions pruning maintain completeness 
algorithm fails enforced hill climbing gets caught dead state 
happen search backtrack decisions heuristic function return value dead state 
algorithm fails helpful actions pruning cuts important states happen technique non admissible approximation usefulness 
deal issue employing solution enforced hill climbing fails planner starts scratch complete heuristic search engine pruning technique 
search engine russel norvig term greedy best search 
weighted strategy weight node cost equation search simply expands search nodes increasing order goal distance estimation 
repeated states avoided obvious way keeping hash table visited states 

numeric state variables introduce notation numeric part pddl language pddl level defined fox long ipc 
restrict strips readability reasons 
extensions adl summarized section 
sets assumed finite stated 
translating ignoring delete lists numeric state variables addition propositions set numeric variables 
notationally say fv article denote number numeric variables 
state pair set propositions vector rational numbers obvious semantics true propositions value 
expression arithmetic expression rational numbers operators gamma 
numeric constraint triple exp comp exp exp exp expressions comp comparator 
numeric effect triple ass exp variable ass assignment operator exp expression effect right hand side 
condition pair con con con set propositions con set numeric constraints 
effect triple eff eff gamma eff eff eff gamma sets propositions add delete list eff set numeric effects ass exp ass exp eff 
action pair pre eff pre condition eff effect 
semantics language straightforward 
value exp expression exp variable value vector numeric part state rational number expression simplifies replacing variables respective values undefined division occurs 
constraint exp comp exp holds state written exp comp exp values exp exp defined stand relation comp 
condition con con con holds state con con numeric constraints con hold value ass exp numeric effect ass exp variable value vector numeric part state outcome modifying value value exp assignment operator ass 
numeric effect applicable value defined 
effect eff eff eff gamma eff applicable numeric effects eff applicable eff eff state eff gamma eff value vector results replacing ass exp ass exp eff 
putting definitions result executing action state result hai eff pre eff applicable undefined 
case said applicable action sequence ha result ha usual defined recursively result ha result result ha gamma result hi numeric task tuple variables propositions set actions state condition 
sequence actions ha plan result applying yields state models result ha algorithmic framework distinctions different degrees expressivity allow numeric constraints effects different numeric 
ignore readability reasons possibility fox long original language variable undefined value assigned 
methodology easily extended fact implemented deal case 

fox long assumption implicitly requiring outcome action defined note commutative effects variable merged 
hoffmann languages 
numeric language tuple cons eff ass eff rh cons possibly infinite set numeric constraints eff ass set assignment operators eff rh possibly infinite set expressions 
task belongs language constraints assignment operators effect right hand sides members respective sets 
sections contain technical part article 
organized follows 

section provides theory metric ff heuristic function 
relaxation ignoring delete lists described section extended numeric variables 
section formalizes key idea restricted numeric language states extended relaxation fulfills admissibility basic polynomiality 
section abstracts restricted language identifying generalized semantic properties relaxation 
section introduces language linear tasks brought linear normal form lnf semantic properties 
metric ff core planning algorithms implemented lnf tasks 

section introduces algorithms implemented metric ff heuristic function 
algorithms extensions relaxed graphplan methods described section 
section describes algorithms restricted language section extends lnf tasks 
state formally algorithms complete correct 
see algorithms theory efficient 
number relaxed planning graph layers built exponential size task encoding contrast polynomiality relaxation proved section 
reason implementation lags theoretically possible implementation done theory fully developed 
practical point view debatable important potential number relaxed planning graph layers built bounded length shortest relaxed plan 
exploring issue depth topic 
details sections 
section details relaxed plan information implement metric ff system 
section explains extension basic ff architecture described section 
section explains extension adl section describes flexible optimization criteria dealt 

relaxing numeric state variables show relaxation technique strips naturally extended numeric context 
proceed steps outlined 
restricted language key idea relaxation apparent considers context constraints compare variables constants translating ignoring delete lists numeric state variables effects effect right hand sides positive constants 
formally restricted language comp variable comp qg fc strips delete lists troublesome falsify propositions need preconditions goal 
restricted numeric language effects troublesome diminish value affected variables 
idea ignore effects 
definition assume restricted numeric task 
relaxation action pre eff eff gamma eff defined pre eff exp exp eff relaxation fa ag 
action sequence ha relaxed plan ha plan 
relaxation adequate restricted language precise sense introduced section 
definition restricted denote problem 
assume restricted numeric task 
relaxation solvable 
theorem relaxation definition adequate holds true 

admissibility assuming restricted numeric task plan relaxed plan 

basic assuming restricted numeric task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality deciding restricted detailed proof appendix straightforward extension strips proof exploiting correspondence pre goal conditions add lists delete lists hand constraints effects effects hand 
tricky part lies proving polynomiality precisely handle repeated increasing effects variable 
effects applied exponential number times 
consider tasks initially goal action effect 
task shortest relaxed plan comprises steps exponentially long size non unary encoding hoffmann trick decide relaxed solvability polynomial time simple handling 
polynomial decision process forward fixpoint procedure similar building relaxed planning graph 
soon appears action increases variable assume value reflecting fact value arbitrarily high applying sufficient number times 
indicated earlier current implementation metric ff describe section handling technique may build exponential number relaxed planning graph layers search state 
section 
words related order 
relaxes numeric tasks ignoring numeric constructs gets admissibility polynomiality basic 
heuristic methods kambhampati grt come quite close extreme case 
fact heuristic constructs relaxed plan completely ignores numeric part task 
resource consumption resulting relaxed plan roughly sum decreasing effects numeric variables estimate number actions needed re produce resources number added heuristic value state hand 
particular method ignores numeric goals preconditions lacks basic 
similarly heuristic technique grt considers resource consumption form state cost take numeric precondition goal constraints account 
heuristic technique explicit relaxed plans definitions directly applied 
numeric constraints considered heuristic value purely numeric action precondition zero precondition true current state technique lacks basic 
monotonicity dynamic relaxation look scenes relaxation technique restricted language 
syntax numeric constructs focus semantics 
define extension relaxation general context identify group semantic properties relaxation adequate 
focus syntactically restricted language linear tasks easier see relaxation adequate 
main intention subsection provide theoretical background general characteristics relaxation works 
ignore semantic issues simply extend definition relaxation 
general definition easy restricted case definition 
idea ignore decreasing effects difficulty effect decreasing depend context executed 
simple example say action numeric effect 
negative value state execution effect decreases value increasing 
statically relax 
common practice refer effects increasing effects effects decreasing effects 
contrast distinguish syntax semantics denote syntax increasing decreasing denote semantics arbitrary numeric effects 
translating ignoring delete lists numeric state variables ignoring parts specification 
relaxation dynamic relax state transition function 
definition assume state action pre eff 
relaxed result executing result eff value vector results replacing ass exp ass exp eff ass exp 
action sequence ha result ha defined recursively original result function section 
note strips restricted numeric language definition comes exactly relaxations 
having generalized relaxation want know exactly situations relaxation adequate 
obviously ignoring decreasing effects adequate general 
simple example value variable initially effect goal requires relaxation renders task unsolvable 
intuitively relaxation adequate preferable numeric variables higher values 
formalizing intuition turns bit tricky 
recall conditions adequacy relaxation admissibility real plan relaxed plan basic relaxation ignore precondition goal constraints polynomiality solvability relaxation decided polynomial time 
basic obviously relaxation 
admissibility polynomiality 
say want sure real plan relaxed plan 
numeric constraints prefer higher variable values effects 
example say initially goal action effect action effect 
ignore decreasing effect solve task effect better takes lower values 
considering polynomiality ensure relaxed solvability decided polynomial time kinds subtleties handled 
say want shortcut repeated action application trick assuming repeated application increasing effects affected variable diverge case restricted language 
get trouble repeated relaxed application action value affected variable converge 
similar difficulties arise expression constraint diverge variables 
constraint looks correct inserting fulfilled finite values 
example constraint fulfilled inserting definition introduce number conditions sufficient ensure difficulties described appear 
see monotonic tasks real plan relaxed plan strictly monotonic tasks effects acyclic certain sense relaxed plan existence decided polynomial time 
definition assume numeric task 
task monotonic pairs states holds 

example initially effect gamma repeated application effect value converge value applications gamma 
hoffmann numeric constraints exp comp exp occurring task exp comp exp exp comp exp numeric effects ass exp occurring task ass exp ass exp relation holds values defined 
task strongly monotonic hold 
states numeric effects ass exp occurring task ass ass exp gamma ass exp gamma relation holds values defined 
expressions exp occurring task exp lim exp exp denotes set variables contained exp 
numeric constraints exp comp exp occurring task exp comp exp explanation lengthy definition order 
condition ensures numeric constraints prefer higher variable values 
condition effects requiring value effect increase variables 
particular value undefined division zero occurs variables grow 
conditions suffice real plan relaxed plan higher variable values preferable 
conditions aim making relaxed solvability easy decide 
condition stronger version condition 
require value effect adds affected variable increases variables 
ensures repeated application effect causes value affected variable diverge 
illustrate effect gammav fulfills condition condition 
outcome effect monotonic zero variables affects value higher 
condition postulates expressions diverge variables condition postulates constraints finite variable assignment constraints true 
condition requirements ensure constraints eventually fulfilled increasing values variables 

weaken conditions definition exploiting fact interested reachable states 
matter constraint monotonic region variable values reached due semantics task 
metric ff implements analysis techniques throwing away actions numeric constraints effects preconditions reached relaxed planning graph initial state ignoring numeric constructs 
exploring topic depth 
translating ignoring delete lists numeric state variables effects separated definition strong monotonicity postulate condition postulate condition 
postulating condition effects suffice 
condition hold simplest form effects assigning constant variable 
note principle effect example gammav 
effects kind common limited suits benchmarks currently available filling tank fuel level assigned maximum level 
identify different sufficient criterion effects tractable captures common forms effects 
computing maximum outcome set assignment effects relaxation condition easy value changes single variable propagated value 
proof argument transitively change influence value needs perform value propagation steps step computing maximum assignment available variable 
steps variables values fixed 
formalize possible value propagations straightforward graph definition 
definition assume numeric task 
task acyclic effects graph cycle free theta exp eff exp exp denoting set variables contained exp state ways definitions imply adequacy ignoring decreasing effects relaxation 
notation relaxed plan existence decision problem syntactic issues assume formed input task decision procedure strongly monotonic acyclic effects 
definition strongly monotonic denote problem 
assume numeric task 
relaxed plan provided task strongly monotonic acyclic effects 
theorem relaxation definition adequate strongly monotonic tasks acyclic effects 
precisely holds true 

admissibility assuming monotonic numeric task plan relaxed plan 

basic assuming numeric task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality deciding strongly monotonic hoffmann proof appendix basically straightforward exploitation properties ensured definitions 
note theorem identifies sufficient criteria relaxation 
interesting questions weaker criteria 
concrete example certain cases cyclic assignment effects easily handled 
exactly cases 
answering questions topic 
thing dealt semantic constraints translate syntax arithmetic expressions allowed pddl 
consider details base rest article subset pddl required semantic properties easily achieved language metric ff system implemented 
extending system richer languages open research topic 
linear tasks lnf metric ff system implemented deal call linear tasks 
language numeric tasks effects numeric variables linear expressions 
formally exp comp exp exp exp linear expression comp exp linear metric ff implementation allows tasks linear preprocessing step 
assume planning task 
variable task constant affected effect action expression task constant variables occurring task constants 
pre process replaces task constants respective rational numbers resulting inserting initial variable values 
linear tasks course necessarily monotonic 
fact illustrative counter examples linear 
linear functions monotonic precisely strictly monotonic diverging variables positive negative sense 
idea introduce variable negative sense point inverted variable gammav takes value gamma replace gammav points negatively 
done variables task strictly monotonic variables positive sense details 
introducing inverted variables viewed shortcut way informing heuristic function places variables positive negative sense 
return issue considering metric ff heuristic algorithms section 
linear task metric ff transforms task call linear normal form lnf 
lnf task expressions weighted sums variables weights greater 
transformation process works follows 
series simple steps transforms task language 

quotient exp exp exp simplifies expression undefined respective constraint fulfilled respective action effects applicable 
case replace constraint false remove action 

david smith personal communication 
translating ignoring delete lists numeric state variables achieve language format replaces constraints exp exp exp exp exp exp effects exp 
rest matter normalizing linear functions 
language format differs lnf variable weights may negative 
course difference 
reconsider example variable initially action effect goal requires 
take running example 
language format effect gamma goal requires gamma 
due negative weighting goal condition ignoring decreasing effects viable 
way introduce inverted variables extension methodology eliminates negative preconditions strips planning technique introduced knoblock 
process works follows 
initialize set translated variables 
iterate negative weights select arbitrary occurrence weighted sum 
introduce new variable gammav set gammav gamma 
effects introduce effect set action effect gammav gamma gamma 
set fv gammav occurrences weighted sums may original variables introduced inverse variables replace gamma gammav gammav respective inverse counterpart 
jv iterations weights positive process terminates 
task linear normal form 
running example lnf transformation 
variables gammav initially 
action effects gamma gammav 
goal condition expressed terms value gammav reads gammav 
single application action achieves goal relaxed transition function effect gammav increasing 
general easy see lnf tasks strongly monotonic 
proposition assume linear numeric task 
task lnf strongly monotonic 
proof conditions definition trivially fulfilled lnf tasks 
examples condition true compare expressions positively monotonic variables constants 
condition true effects right hand sides positively monotonic variables 

note estimating maximum value gammav estimating minimum value section 
hoffmann proposition lnf task acyclic effects remember separated definition condition task fulfills prerequisites theorem ignoring decreasing effects adequate relaxation 
feasible solutions relaxation means heuristic estimation 
effects easily translate effects exp translates gamma exp 
reader wonder bother treating effects 
point translated effects behave equivalently real transition function behave differently relaxation 
running example suppose second action effect 
lnf transformation translated version effect gammav 
say execute result effects gamma gammav original task resulting value 
translated task value decreasing effect ignored 
difference treat effects separately 
open question situations difference important planner performance 
metric ff implements inverted variables lnf tasks similar processes richer languages functions strictly monotonic diverging variables 

solving relaxed tasks concentrate algorithms ff generally algorithms obtain heuristic information forward state space search 
explain solve relaxed numeric tasks 
consider restricted language extend methods lnf tasks 
algorithms form basis metric ff implementation 
restricted tasks implementation uses straightforward extension graphplan style algorithms introduced section 
step process builds relaxed planning graph extracts relaxed plan graph succeeds reaching goals 
parallel structures keep track progress logical propositions structures keep track progress terms maximally possible variable values 
graph building mechanism outlined 
parts algorithm concerned propositions exactly strips case section 
numeric variables max value vector layer specifies current maximum value variables take 
vectors updated obvious fashion adding layer total sum increasing effects layer 
termination condition checks maximum values variables changed higher needed value variable defined highest requirement variable max gamma fc pre note algorithm fails relaxed plan algorithm fails layer termination condition hold true layers 
translating ignoring delete lists numeric state variables max endfor max fa pre pre max cg eff max max eff endfor max max max fail endif endwhile building relaxed planning graph state restricted numeric task 
note finite number layers numeric variables increase eventually reach finite values 
mentioned section number layers exponential task encoding 
reconsider example initially goal action effect 
number graph layers built example exponential non unary encoding easily decide solvability trick outlined section 
hand appears implementation provably polynomial decision procedure better practice 
graph building algorithm polynomial length output minimal length relaxed plan 
possibly exponential minimal length relaxed plan exponential non unary encoding variable values particularly relevant examples specifically constructed provoke 
remains open question implementation handling achieve better performance realistic examples 
focus relaxed plan extraction 
invoked relaxed planning graph succeeds reaching goals 
information graph provides levels actions propositions numeric goals 
actions propositions level graph layer appear section 
numeric goals level graph layer goal achieved max holds time 
plan extraction mechanism outlined 
logical entities dealt exactly strips case section 
addition propositional sub goal set layer set numeric goals 
strips goals sub goals inserted set appearance relaxed planning graph goal sets initialized inserting respective top level goals 
backwards loop top bottom layer selecting actions support propositions numeric variables respective goal sets 
propositions supported difference hoffmann fg level tg level tg endfor select level gamma eff pre pre level fpg level endfor endfor max gamma select level gamma eff previously selected loop gamma introduce preconditions endwhile gamma endfor endfor extracting relaxed plan state restricted numeric task levels computed algorithm 
numeric preconditions supporting actions inserted goal sets 
uniting sets numeric goals contain constraint variable stronger constraints taken 
numeric goals general select single action actions gamma contributed maximum value supporters selected goal achieved layer earlier 
note max gamma gamma eff max gamma loop terminate successfully 
note occurrence action support different logical numeric goals different effects support numeric goal twice 
termination plan extraction selected actions form relaxed plan denoting actions selected layer arbitrary linearization gamma relaxed plan task 
note apply various simple heuristics selecting effects maximum right hand side relaxed plans short possible 
lnf tasks algorithms numeric tasks linear normal form differ restricted tasks need take care effects general expressions numeric translating ignoring delete lists numeric state variables constraints effect right hand sides 
turns integrating extensions overly difficult 
issue slightly involved exact termination criterion relaxed graph building 
solution issue assume theoretical analysis underlying theorem effects acyclic 
outline graph building mechanism shown 
max endfor exp exp max fa pre exp pre exp max eff max max exp eff exp max exp max endfor max max max max exp eff exp max endfor max max max fail endif endwhile building relaxed planning graph state lnf task 
compare 
deal expressions constraints effect right hand sides simply inserting respective max values variables computing respective outcome recall exp expression exp variable value vector denotes value exp inserting values 
effects taken account obtain max values exactly adding combined contributions max value right hand sides computed max values 
effects taken account determining effects contributed max effect graph value inserting max values higher hitherto max value 
case max respective variable updated maximum assignment possible 
part algorithm somewhat complicated comparison algorithm restricted tasks termination criterion 
difficult part computation values values variables longer contribute relaxed solution 
values depend state start 
derive values start static non state dependent notion solution relevant variables 
variable solution relevant occurs numeric constraint right hand side exp effect exp solution relevant variable note solution relevance transfers transitively variables 
denote set solution relevant variables rv state dependent aspects relaxed task provide notation value variable take state order raise support value positively weighted sum hoffmann exp constant exp gamma gamma course support value exp defined exp part weighted sum 
reader easily convince raise value exp know value exp concept determine point variable contributes sufficiently constraints effect right hand sides contribute 
constraints exp exp point reached exp constraint fulfilled 
effect right hand sides exp exp rv may needed point reached exp effect eventually increase arbitrarily high values 
effect right hand sides effect exp exp rv value sufficient exp effect high assign sufficient value 
main complication want values define values definition effects recursive 
constitute problem assumption effects acyclic 
effect recursion guaranteed terminate 
altogether definition 
max gamma exp exp pre exp exp exp eff exp rv exp exp eff exp rv note definition variables gamma variables solution relevant 
theorem assume linear numeric task lnf acyclic effects 
assume state algorithm depicted fails relaxed plan 
main proof idea algorithm fails layer termination condition hold true layers 
argument concerning values follows outlined 
full details bit lengthy 
see appendix discussed restricted language number graph layers built termination finite eventually variables increase reach finite values exponential encoding length task 
implement provably polynomial algorithm lines method proof theorem debatable implementation realistic examples achieve significant performance improvements existing implementation 
interesting consider role inverted variables introduced metric ff lnf pre processing see section play relaxed planning graph process described 
estimating maximum value inverted variable estimating minimum value respective original variable 
precisely inverted variable gamma max optimistic translating ignoring delete lists numeric state variables approximation minimum value take steps value results ignores increasing effects optimistic decreasing effects 
sense inverted variable gammav viewed way informing relaxed planner numeric constraints effects minimum maximum possible value computing optimistic approximation maximum minimum values 
focus relaxed plan extraction 
justified theorem invoked relaxed planning graph succeeds reaching goals 
information graph provides levels actions propositions numeric goals 
actions propositions definitions stay numeric goals exp level graph layer goal achieved exp max holds time 
outline plan extraction mechanism shown 
compared algorithm restricted tasks shown novelties complex numeric goals get split goals individual variables effect right hand sides forced sufficiently high value effects handled 
issue numeric goal exp dealt simply constraining variables exp take respective max value 
similarly effect right hand sides exp forced sufficiently high requiring exp take respective max value 
effects taken account alternative way achieving numeric goal 
effect exp sufficiently high value exp max gamma respective action selected 
set actions effects selected similar fashion restricted tasks 
uniting sets numeric goals contain constraint variable stronger constraints taken 
easy see termination selected actions form relaxed plan state hand 
theorem assume linear numeric task lnf acyclic effects 
assume state algorithm depicted reaches goals 
actions selected algorithm depicted form relaxed plan 
straightforward proof appendix conclude section additional remarks 
thing occurred reader necessarily need support goal exp requiring exp take maximum possible value 
weaker requirements sufficient 
holds true effect right hand sides 
able find shorter relaxed plans simple heuristics points 
plausible algorithms specified strictly monotonic task uses effects acyclic effects assuming value computation modified appropriately 
exploring idea richer language classes left open topic 
left open effects effects taken account 

insight pointed author david smith comment submitted version article 
optimistically estimating maximum minimum variable values generally multiple variable values alternative viewpoint monotonicity paradigm explore 
investigating alternative viewpoint depth open topic 
hoffmann fg level tg max exp level exp exp endfor select level gamma eff pre exp pre level fpg level exp max level exp exp endfor endfor level gamma exp eff exp max gamma gamma max gamma exp introduce preconditions max gamma select level gamma exp eff exp max gamma previously selected loop gamma exp max gamma introduce max constraints vars exp introduce preconditions endwhile gamma endif endfor endfor extracting relaxed plan state lnf task levels computed algorithm 

metric ff section details theoretical algorithmic described far implement heuristic planning system metric ff 
section specifies relaxed plan information define basic architecture planner handles strips plus linear tasks acyclic effects 
describe extensions integrated system section explains extension adl handled section explains flexible optimization criteria taken account 
basic architecture strips case techniques extracting relaxed plans state space planner easily implemented 
linear task transformed lnf task algorithms described section 
define heuristic function search translating ignoring delete lists numeric state variables strategy pruning technique analogous strips version ff section 
methods straightforward strips techniques 
heuristic function estimates goal distance number actions relaxed plan 
definition assume linear numeric task lnf acyclic effects state metric ff heuristic value defined follows 
algorithm depicted fails 
ja set actions selected layer algorithm depicted 
search strategy remains exactly enforced hill climbing depicted 
difference lies way avoid repeated states 
strips case simple hash table lookup procedure 
straightforward adaption store visited states cut new state identical state visited 
derive weaker cutoff criterion important performance impact certain situations 
differs solution irrelevant numeric variables values 
example difference execution time spent 
expand iteratively infinite sequence succeeding states increase execution time phenomenon observed various benchmark domains 
avoid phenomena cutting new states dominated stored state task state dominated state propositions solution relevant rv holds 
dominated task hand monotonic sense definition action sequences achieve goal starting starting proposition assume numeric task monotonic 
assume states dominated action sequences result result proof say ha action sequence result holds 
show solution relevant variables rv result ha result ha holds 
proves proposition variables goal constraints rv goal constraints monotonic definition condition goal constraints fulfilled result 
claim fulfilled result 
prove claim solution relevant variable values induction base case prerequisite holds rv inductive case 
preconditions fulfilled result ha due argument goal constraints 
second variables contained effect right hand sides solution relevant variables solution relevant definition induction hypothesis holds 
proves claim monotonicity numeric effects definition condition 

recall definition solution relevant variables rv section variables occur numeric constraint right hand side exp effect ass exp solution relevant variable hoffmann lnf tasks monotonic 
proposition solution plan solution plan cutting search space contains solution preserving 
consequently search iteration performed enforced hill climbing implementation keeps hash table states visited iteration skips new state dominated visited states 
indicated various benchmark examples prevents planner looping new states increase value solution irrelevant variable execution time 
extend strips pruning technique helpful actions actions support propositional numeric goal lowest layer relaxed planning graph 
definition assume linear numeric task lnf acyclic effects state algorithm depicted reaches goals 
set helpful actions defined eff exp eff exp exp eff exp set sub goals constructed layer algorithm depicted 
supporting numeric goal means effects right hand side effect sufficient fulfill goal effects respective right hand side expression greater 
note right hand side value effect lowest layer relaxed planning graph exactly value state hand 
search iteration enforced hill climbing expanding state states generated actions included search space 
note states relaxed planning graph reach goals get expanded anyway 
strips algorithm fail enforced hill climbing gets trapped dead state helpful actions pruning cuts important states 
observed helpful actions pruning severe numeric domains 
case enforced hill climbing fails try pruning technique turned continue hill climbing procedure point failure pruning 
fails strips employ safety net solution complete greedy best strategy trying solve task scratch 
strategy expands search nodes increasing order goal distance estimation 
new states cut dominated visited state 

precisely new state skipped dominant visited state hash entry 
value solution relevant variables execution time increased implementation ensures case 
matter chance 
open question visited states indexed order provide fast exact answer query contain dominant state 

consequence undecidability numeric planning observed seemingly benign benchmarks 
finite state space course run risk entering infinite loop 
translating ignoring delete lists numeric state variables adl adl pednault goes strips allows action preconditions goal arbitrary equation free order logical formulae actions conditional effects effects occur effect condition holds true 
effect condition arbitrary equation free order logical formula 
numeric setting effects contain updates numeric variables 
numeric constraints appear point logical formula logical atom allowed 
previous ff version hoffmann nebel metric ff compiles quantifiers disjunctions away pre processing phase 
metric ff compile conditional effects away 
metric ff internal language differs strips numeric constraints effects actions conditional effects effect conditions conjunctions propositions numeric constraints 
reason adl compiled language heuristic algorithms relaxed planning graph implemented efficiently restricted language format 
compilation exponentially costly general feasible expect formulation realistic planning scenario logical formulae overly complex 
reason conditional effects compiled away done principle nebel proved imply exponential blow want preserve solution length 
fortunately conditional effects easily dealt need compile away 
give brief overview compilation process extended heuristic function implementation 
heuristic function thing adapted state transition function conceptually trivial 
compilation process largely implementation ideas proposed knoblock koehler hoffmann 
extensions handle numeric constructs straightforward 
process starts usual planner inputs set parameterized operator schemata initial state goal formula 
compilation works follows 

determine predicates numeric functions static sense operator effect 
predicates functions common phenomenon benchmark tasks 
examples transportation context connections locations static connected predicate distances locations static distance function 
static predicates functions recognized simple sweep operator schemata 

transform formulae quantifier free dnf 
subdivided steps pre normalize logical formulae 
knoblock process expands quantifiers translates negations 
formulae consist conjunctions disjunctions atoms containing variables atoms numeric constraints 
instantiate parameters 
simply done instantiating operator effect parameters type consistent constants 
process knowledge static predicates sense hoffmann instantiated formulae simplified koehler hoffmann 
example instantiated static predicate occurs formula instantiation contained initial state replaced false 
example sides numeric constraint static constraint replaced true false 
transform formulae dnf 
postponed instantiation costly applied smallest formulae possible 
fully instantiated formula static predicate occurrences constant constraint occurrences replaced true false resulting simpler formula structure 

dnf formula contains disjunct corresponding effect operator goal condition gets split manner proposed knoblock 
logical constructs normalized numeric constructs task transformed lnf manner analogous process described section 
integrating conditional effects relaxed planning process easy matter 
relaxed planning graph differs strips counterpart keeps track graph layers action effects applicable 
relaxed plan extraction process differs strips counterpart selects supporting effects propositional numeric goals 
optimization criteria pddl user specify optimization criterion task 
criterion consists arbitrary numeric expression keyword maximize minimize saying higher lower values expression preferred 
semantics solution plan optimal iff state leads maximal minimal goal state respect optimization expression 
metric ff supports run optimization mode somewhat restrictive form optimization 
accepts optimization criterion criterion transformed certain schema additive action cost minimization 
heuristic cost state summed cost actions respective relaxed plan search standard weighted weights set command line 
note methodology give guarantee quality returned solution heuristic function provably admissible 
methodology obvious option cost relaxed plan additive setting gives remaining cost estimation technique free 
open question general optimization criteria dealt 
describe implemented methodology little detail 
start strips setting outline changes extension adl 
metric ff rejects optimization expression linear 
optimization keyword maximize expression multiplied gamma minimization required 
expression brought lnf constant part obviously skipped 
notation optimization criterion accepted action effects variables increase optimization expression value translating ignoring delete lists numeric state variables constant effects form 
action cost action defined cost eff sum increases cost variables action multiplied weight optimization expression 
cost action sequence set sum individual costs 
easy see setting finding goal state minimizes optimization expression value equivalent finding plan minimal cost 
search algorithm stated standard weighted algorithm implementing best search function cost search path leads remaining cost estimate cost relaxed plan weights command line 
remaining cost estimate general admissible plan guaranteed optimal 
expect empirically better plans 
see fact case ipc testing domains 
adl cost action state sum costs effects appear cost action sequence sum costs actions respective states minimizing optimization expression equivalent minimizing plan cost 
estimating remaining cost means relaxed plan somewhat obvious choice effect costs counted result 
effects selected support logical numeric goals relaxed plan extraction effects get triggered executing relaxed plan 
chosen count costs effects 
heuristic search algorithm remains exactly strips case 

competition results briefly examine ipc competition data relevant metric ff 
competition featured domains spanning range strips pddl level permits combination logical numeric temporal constructs 
ff participated strips domains numeric domains demonstrating competitive performance 
discuss data numeric domains 
discussion strips results competition overview article long fox 
numeric domains competition 
domains include showing runtime curves discuss relative runtime solution quality performance text 
ff mips lpg systems configured favor speed quality find plan fast possible search plan sense optimization criterion 
graphs readable show runtime curves planners favor speed 
discuss solution quality behavior planners terms plan length number steps 
note planners take account optimization criterion anyway 
planners favor quality discuss runtime solution quality behavior text 
optimization mode metric ff preliminary implementation keep discussions short 
give brief descriptions domain semantics 
hoffmann details overview article long fox 
focus domains turn give short summary metric ff performance 
depots depots domain combination known logistics blocksworld domains 
objects transported trucks logistics arranged stacks blocksworld 
numeric constructs define fuel consumption trucks lift objects order stack 
objects weights sum weights objects loaded truck time lower equal truck capacity 
shows runtime data depots instances competition 
ff speed lpg speed mips plain runtime curves depots instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
planners participating numeric version depots metric ff lpg mips 
time writing numeric version planners published 
lpg mips reader referred respective articles appear jair special issue gerevini 
shows solve single smallest instance mips solves instances scattered set 
metric ff lpg solve instances exhibit similar behavior 
metric ff planner solve largest instances 
stated show curves configurations favoring speed 
competition data version metric ff called ff speed version lpg called lpg speed version mips called mips plain 
translating ignoring delete lists numeric state variables assess relative plan quality behavior plan length minimization expression value computed quotients follows 
planners measure instances solved planners plan quality divided plan quality 
compute average quotient 
points need absolute measure comparison participating planners domain set planner hypothetical best planner data obtained selecting best lowest results planners 
individual planners domain ranked comparing best 
data obtained concerning plan length depots planners shown 
ff speed plans average times long best plans lpg speed plans average times long best plans mips plain plans average times long best plans 
plan lengths roughly similar 
single instance solves plan steps ff speed steps lpg speed mips plain steps 
comment algorithms planner versions favoring quality 
mips similar metric ff optimization mode heuristic function kind relaxed plan cost algorithm 
contrast lpg optimization method starts plan continues search plans better 
metric ff performs best search function 
competition weights set 
quality version mips simply called mips competition data 
improve readability call mips quality similar quality favoring versions metric ff lpg called ff quality lpg quality 
optimization criterion depots minimize fuel consumption 
runtime quality versions mips lpg behave slightly worse speed versions 
contrast metric ff quality version solves smallest instances 
solution quality fuel consumption ff speed instances ff quality 
optimization effect observable 
instances mips quality finds costly plans lpg quality plans slightly better 
instances lpg quality plans consume average times fuel best plans consume average value mips quality 
domain variation logistics trucks need drivers underlying map arbitrary undirected graph opposed fully connected graphs standard version domain 
drivers move different paths trucks 
numeric constructs specify total time driven walked 
shows runtime data instances competition 
depots participating planners metric ff lpg mips 
solved smallest instance 
lpg speed planner solves instances 
ff speed solves task mips plain respective data point hidden top right corner roughly fast lpg speed tasks solves 
plan length planners clearly superior 
average quotients versus best ff speed lpg speed mips plain 
ff speed lpg speed plan lengths hoffmann ff speed lpg speed mips plain runtime curves instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
average somewhat longer mips plain 
difference tendency grow instance size 
single instance solved plan steps planners 
optimization criterion minimize instance specific linear combination total time driven distance walked distance 
ff quality runtime behavior depots lot worse ff speed solving smaller instances 
quality plans slightly better times ff speed values average 
mips quality lpg quality solve instances speed favoring counterparts 
average comparison lpg quality best precisely mips quality single instance mips quality plan consumes fuel units lpg quality plan units 
competition featured version hard numeric driving truck consumes fuel proportional square load criterion minimize instance specific linear combination total time fuel consumption 
interestingly optimization criterion ff quality slightly efficient ff speed solving instances speed favoring version 
come back phenomenon outlook discuss effect optimization expressions runtime performance 
runtime performance planners similar domain version described 
optimization expression ff quality values average times ff speed optimization effect observed 
comparison best ff quality lpg quality mips quality 
translating ignoring delete lists numeric state variables domain competition classical transportation domain objects transported airplanes 
planes fuel fly slow fast 
fast movement consumes fuel 
numeric version domain fuel level plane fuel usage numeric variables 
addition numeric variable counts passengers board plane fast movement allowed number passengers certain threshold 
operator set fuel level plane back maximum capacity 
durations difference effects slow fast flying lie higher fuel consumption fast flying useless action 
shows runtime data instances competition 
ff speed lpg speed mips plain runtime curves instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
participating planners metric ff lpg mips 
solves smallest instances planners solve test set 
ff speed order magnitude faster lpg speed mips plain 
plan length ff speed mips plain behave similarly lpg speed finds somewhat longer plans 
quotient values versus best ff speed lpg speed mips 
visualizing data finds difference lpg speed ff speed plans grows instance size 
finds best shortest plans instances solves 
quotients ff speed versus instances solved 
hoffmann optimization criterion minimize instance specific linear combination total time fuel consumption 
ff quality runtime behavior worse ff speed solving smaller half test set 
mips quality solves instances lpg quality solves largest instance 
optimization criterion values ff quality average times ff speed optimization effect observed 
quotient values versus best ff quality lpg quality mips quality 
satellite satellite number satellites number observations installed instruments 
involves turning satellites right direction switching instruments calibrating instruments images 
numeric version domain turning satellites consumes non fuel images occupy data memory satellites limited data memory capacity 
shows runtime data problem instances competition 
ff speed lpg speed mips plain tp runtime curves satellite instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
domain participating planners metric ff lpg mips tp geffner 
tp finds plans optimal makespan solves smallest instances mips plain solves smaller instances lpg speed solves instances ff speed solves 
note instances lpg speed fails solve ff speed solves mainly smaller ones 
plan length quotients versus best ff speed lpg speed mips plain tp 
translating ignoring delete lists numeric state variables plan lengths roughly similar lpg speed mips plain slight advantage ff speed 
optimization criterion satellite minimize fuel consumption 
ff quality mips quality runtime behavior lot worse ff speed mips plain solving smallest instances 
lpg quality solves instances lpg speed 
fuel consumption ff speed instances ff quality solves 
ff quality slight optimization effect instances 
lpg quality finds best plans instances solves quotient versus best constantly comparison mips quality best 
competition featured version satellite hard numeric logical numeric goals optimization criterion maximize amount stored data memory occupied taken images 
example optimization criterion transformed action costs sense explained section 
actions take images negative costs 
metric ff rejects optimization criterion reports instances trivially solved empty plan 
similarly plans returned mips plain empty 
mips quality version finds non trivial plans smaller half instances 
lpg data competition results domain version 
rovers rovers number planetary rovers analyze number rock soil samples take number images 
involves navigating rovers dropping samples rovers hold sample time calibrating camera images communicating data lander 
numeric version domain activities decrease energy available rover certain amount energy recharge operator applied rover located sunny spot 
shows runtime data rovers instances competition 
participating planners domain metric ff lpg mips 
planners solve test set fact lpg scales best planner solve larger instances 
smaller instances solved quickly participants 
ff speed slight plan length advantage 
quotients versus best ff speed lpg speed mips plain 
optimization criterion rovers minimize number recharge actions applied plan cost recharging cost actions 
optimization criterion ff quality solve single instance return outlook 
mips quality lpg quality solve instances speed favoring counterparts 
lpg quality plan quality instances mips quality solves 
mips quality plans contain recharge actions cases recharge action cases recharge actions case 

actual competition data lpg failed solve instances due implementation bug 
show corrected data provided alfonso gerevini 
hoffmann ff speed lpg speed mips plain runtime curves rovers instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
domain building infrastructure unsettled area 
things built include housing railway tracks lot operator schemata encoding complex building process 
raw materials timber stone ore broken mined 
process timber wood coal process ore iron 
carts trains ships built transport materials 
combine materials build housing encoding intensive numeric variables domains 
domains numeric constructs mainly encode resource constraints action costs numeric variables play active part achieving goal 
operator schemata logical effects 
example timber increases amount timber available respective location unit 
loading unloading material unit vehicle encoded increasing decreasing respective material availability vehicle decreasing increasing material availability respective location 
building housing unit wood stone unit available resulting increased housing units decreased wood stone units 
numeric variables playing active role domain encoding interesting benchmark numeric planners 
shows runtime data instances competition 
metric ff mips versions favor speed able solve instances 
lpg participate domain operators translating ignoring delete lists numeric state variables ff speed mips runtime curves instances planners favoring speed 
time shown logarithmic scale instance size scales left right 
universally quantified effects lpg support 
mips plain solves single instance ff speed solves smallest instances 
noted instances example suite appear large 
ff speed plans smallest instances contain actions respectively 
comparison domains depots ff speed longest plan instances contains steps 
depots numbers th instance isn solved planner 
plan mips plain finds second smallest instance contains steps stated ff speed plan instance contains steps 
planner favoring quality solved instances 
performance summary speed favoring configurations metric ff lpg perform best terms runtime solution length 
runtime rovers lpg scales better solves instances 
metric ff scales better order magnitude advantage runtime 
lpg run metric ff solve large instances 
depots satellite slight advantage metric ff solves instances 
mips lags metric ff lpg domains scales roughly similar lpg 
solution length roughly similar lpg metric ff domains lpg plans longer 
satellite slight advantage lpg hoffmann rovers slight advantage metric ff 
plan lengths mips roughly similar metric ff domains 
results metric ff optimization mode ff quality satisfying far runtime behavior concerned 
ff quality solve single instance rovers solves instances depots normal hard optimization expression satellite 
ff quality runtime behavior reasonably hard optimization expression 
solution quality behavior mixed 
cases observed ff quality plans better sense optimization criterion ff speed plans 
better plan quality clearly observable hard optimization expression 
observable normal optimization expression satellite small number instances solved domains 
compared lpg quality mips quality ff quality quality favoring planner shows dramatically worse runtime behavior speed favoring counterpart 
reasons lie algorithmic differences systems concerning way treat optimization expressions 
outlook speculate reasons ff quality poor runtime behavior done 

outlook natural extension popular heuristic technique strips ignoring delete lists numeric planning 
straightforward implementation technique best performing numeric planning systems ipc 
summarize contributions little detail 
important contribution monotonicity idea numeric framework main strips concepts pre goal conditions add lists delete lists translate naturally numeric concepts monotonic constraints increasing effects decreasing effects 
monotonicity idea useful contexts specific heuristic planner implementation focus article ideas outlook 
heuristic context considered ffl abstracted desirable properties admissibility basic polynomiality ignoring delete lists relaxation strips 
ffl defined natural extension relaxation numeric case provided sufficient criteria identify numeric tasks relaxation preserves desirable properties 
ffl defined subset pddl level linear tasks sufficient criteria achieved pre processing technique 
ffl defined algorithms solve relaxed tasks language provide heuristic function 
ffl implemented straightforward extension ff technique takes userspecified optimization criteria account 
ff extension ff speed shows reasonable performance number benchmark domains 
specifically performed translating ignoring delete lists numeric state variables best lpg numeric track rd international planning competition terms runtime solution length 
runtime behavior optimization technique ff quality unsatisfying plan quality improvements observed 
various research topics left open ffl background theory section provides sufficient criteria numeric relaxation adequate 
question weaker sufficient criteria come complete analysis find exact borders ignoring decreasing effects longer adequate 
identified translate syntactically mathematical constructs allowed pddl level 
ffl pre processing algorithm section transforming linear tasks lnf tasks defined linear tasks 
extended richer language classes 
similarly algorithms section lnf 
easy extension richer language classes 
ffl mentioned section various kinds numeric effects easily translated effects effects vice versa respective translations behave differently relaxation 
identify problem classes formulation yields better heuristic performance 
ffl current optimization technique ff quality restricted optimization criteria transformed action cost minimization certain simple translation schema 
general optimization criteria handled 
ffl seen runtime performance ff quality unsatisfying 
appears interaction exemplified different quality metrics form optimization action cost minimization expression runtime behavior 
explanation degree minimization expression 
intuitively minimization expression goal directed closely correlated goal distance lower expression value nearer goal vice versa 
maximally goal directed minimization expression goal distance total time sequential framework 
contrast minimization expression rovers number recharge operations loosely connected goal distance 
worthwhile come formal notion goal directedness investigate connection runtime performance connection obvious rovers 
practical side algorithms remain show better performance matter form optimization expression option integrate extent current goal distance estimate length 
note easily imagine domains relaxed plans way metric ff uses yield heuristic information 
example consider puzzle numeric variables encoding positions tiles 
situation large degree interaction numeric variables relaxed plans presumably able capture interaction 
hoffmann relaxed plan case remaining cost estimation 
option different search schemes 
branch bound approach appears possible find plan quickly cost plan upper bound exploration search space 
exciting explore impact monotonicity idea correspondence brings pre goal conditions monotonic constraints add lists increasing effects delete lists decreasing effects different contexts planning research 
examples spring mind heuristic approaches numeric planning goal ordering techniques 
stimulate imagination reader ffl similar methods heuristic approaches relax task ignoring delete lists 
example techniques presumably adapted heuristic estimators partial order framework repop nguyen kambhampati yielding heuristic numeric partial order planner 
appears feasible integrate techniques kambhampati heuristic function possibly making function accurate various numeric situations 
possible avenue able adapt techniques lpg heuristic precondition cost estimation process gerevini making sensitive numeric constructs potentially improving lpg performance 
ffl koehler extension ipp numeric context koehler suffers complications backward search procedure significantly degrade runtime performance 
difficulties arise monotonic context 
ffl koehler hoffmann argue reasonable ordering goals states achieved delete order achieve monotonicity straightforward translation numeric goals ordered values variables participate sufficient achieve values decreased necessary value order achieve koehler hoffmann techniques approximate strips goal orderings transfer easily situation 
similarly monotonicity definitions approximation techniques landmarks subgoals necessarily arise planning hoffmann directly transferred numeric goals 
acknowledgments article extended revised version hoffmann published ecai 
metric ff developed implemented author visiting durham planning group durham uk 
go maria fox derek long discussions making stay enjoyable 
go translating ignoring delete lists numeric state variables fruitful remarks relaxation theory 
david smith insights nature inverted variables detailed comments language 
anonymous reviewers comments helped improve 
appendix proofs appendix presents proofs theorems detail 
different classes results focus turn relaxation adequacy relaxed graphplan completeness relaxed graphplan correctness 
classes results languages increasing expressivity 
relaxation adequacy strips restricted numeric language numeric tasks general prove respective relaxations adequate general case identify situations relaxation adequate 
proof strips case trivial 
proposition relaxation definition adequate holds true 

admissibility plan solves original task solves relaxed task assuming strips task plan relaxed plan 

basic preconditions goals trivially achieved original task holds relaxed task assuming strips task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality relaxed task solved polynomial time deciding proof 
application action relaxed action sequence propositions true true real sequence 
action precondition goal fulfilled 

holds dropping precondition goal constraints 
empty plan hi plan holds 
true 
similarly action preconditions 

proved bylander 
proof case restricted numeric language straightforward extension strips proof exploiting correspondence pre goal conditions add lists delete lists hand constraints effects effects hand 
theorem relaxation definition adequate holds true 
hoffmann 
admissibility assuming restricted numeric task plan relaxed plan 

basic assuming restricted numeric task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality deciding restricted proof 
application step relaxed plan propositions true true real plan values numeric variables high real plan 
action preconditions goal require variable values greater equal constant constraints remain fulfilled 

holds dropping precondition goal constraints 
empty plan hi plan holds 
true 
similarly action preconditions 

polynomial time algorithm decides restricted 
remove action preconditions goal propositions numeric constraints fulfilled values fa pre eff ng eff endif endfor fail endif remove action preconditions goal propositions numeric constraints fulfilled values endwhile succeed remember denotes number numeric variables 
denote action set iteration algorithm 
prove algorithm succeeds relaxed plan relaxed plan algorithm succeeds algorithm takes polynomial time size task 
relaxed plan ha holds true set values include high true facts relaxed plan variable values relaxed plan 
algorithm succeeds iterations 
fail earlier implies fixpoint contradiction reachability goals 
direction algorithm succeeds iteration construct relaxed plan 
simply linearize relaxations actions sets translating ignoring delete lists numeric state variables arbitrary order 
action layer effect variable repeatedly execute action constraints removed iteration fulfilled constraints form eventually happen 
actions applied way preconditions fulfilled empty respective iteration execution sequence constraints true algorithm 
runtime single iteration polynomial 
upper bound number iterations jv jp iteration avoid failure new proposition enter new variable value set 
generalizing restricted language ignoring decreasing effects adequate numeric constraints monotonic numeric effects strongly monotonic plus changes due effects propagate numeric variable value 
proof generalizes way proof 
theorem relaxation definition adequate strongly monotonic tasks acyclic effects holds true 

admissibility assuming monotonic numeric task plan relaxed plan 

basic assuming numeric task hi plan hi relaxed plan result hi pre result hi pre 

polynomiality deciding strongly monotonic proof 
say ha plan 
executing sequence result precondition goal constraints fulfilled 
denote value variable execution action denote value variable execution action result show monotonicity numeric constraints definition condition suffices 
claim easily shown induction holds simply result identical result effects decrease value variable ignored 
holds due argument plus monotonicity numeric effects sense definition condition higher input numeric variables higher resulting value affected variable 

empty plan hi plan holds 
true hi relaxed plan dropping goal constraints 
similarly action preconditions 

polynomial time algorithm decides relaxed solvability strongly monotonic task acyclic effects 


remove action preconditions goal propositions hoffmann numeric constraints fulfilled values 

fa pre 
eff 

ng 
ass exp eff 
ass ass exp endif 
endfor 
ng 
exp eff exp 
max exp eff exp exp 
endif 
endfor 
fail endif 

remove action preconditions goal propositions numeric constraints fulfilled values 
endwhile 
succeed exp expression exp denotes set variables contained exp value expression contains variables set infinity limit expression variables 
note assumption limits definition condition particular computed efficiently 
prove algorithm succeeds relaxed plan relaxed plan algorithm succeeds algorithm takes polynomial time size task 
denote action set iteration algorithm 
relaxed plan ha holds true variable updates performed algorithm high performed result function 
note line takes maximum available effects 
note effects obey definition condition needs consider maximum input values order obtain maximum output value 
consequence monotonicity numeric constraints sense definition condition algorithm reaches goals succeeds iterations 
fail earlier implies fixpoint contradiction reachability goals 
algorithm succeeds iteration construct relaxed plan follows 
perform upwards loop iteration repeatedly apply actions constraints removed line iteration fulfilled 
show point eventually reached 
point reached continue higher value step succeeding iteration completed 
actions applied way preconditions fulfilled empty iteration actions applied constructed relaxed plan fulfills constraints removed iteration definition condition constraints false translating ignoring delete lists numeric state variables true relaxed plan 
reason goals fulfilled iteration remains show iteration repeatedly applying actions eventually fulfill constraints removed iteration 
denote set variables got set iteration line denote set variables got set line denote set variables got set new value line 
show 
application actions variables values constraint removal line 

repeated application actions variables reach arbitrarily high values 
suffices constraints eventually fulfilled 
assume claims hold true 
monotonicity constraints definition condition variables contribute constraints iteration decision algorithm 
variables finite assignment variables higher previous values respective constraints true point 
simple consequence definition condition constraints prefer higher variable values condition expressions diverge variables condition existence finite fulfilling assignment fact constraints true previous iteration true setting variables 
claim follows simple fact actions responsible increasing values variables actions fulfill condition line particular contained outcome higher variables respective effect right hand side increased negative interactions variables considering relaxed transition function 
argument second claim follows 
variables contains respective responsible action fulfilling condition lines 
application action increases definition condition variable value previous application repeated application diverges 
note relaxed state transition applying action worsen situation variables 
variables contains action fulfilling condition line exp eff exp containing variable exp set point exp 
recursively responsible action setting included previous iteration 
effect effect responsible action included earlier 
point responsible action respective ancestor variable included line 
repeated application causes value diverge argument effect transitively causes value diverge 
remains show algorithm terminates polynomial time 
obviously single iteration polynomial 
number iterations bounded number times different respectively changes values occur lines 
number changes line bound number logical propositions jp number changes line bound number numeric variables jv exponential number iterations termination hoffmann exponential number consecutive iterations changes occur line 
number consecutive iterations bound jv jaj 
seen follows 
entire sequence iterations effects contribute changes 
effects acyclic assumption value change propagate value possible change occur new action comes 
takes jv iterations propagate changes variables length longest possible propagation path new action comes iteration new action comes iteration jv latest 
obvious bound number iterations new actions come jaj concludes argument 
relaxed graphplan completeness strips lnf tasks prove respective relaxed graphplan mechanisms complete find relaxed plan 
proof strips case trivial 
proposition assume strips task state algorithm depicted fails relaxed plan 
proof show contrapositive relaxed plan algorithm succeeds 
say relaxed plan ha am 
algorithm applies layer possible actions 
particular includes layer facts true true executing step argument inductively applied actions implying layer contains facts true execution actions implies goals true layer pm algorithm fail layer follows fixpoint reached pm pm contradicts assumptions 
proof lnf tasks proceeds line requires care details concerning values numeric variables longer contribute solution 
theorem assume linear numeric task lnf acyclic effects 
assume state algorithm depicted fails relaxed plan 
proof show contrapositive relaxed plan algorithm succeeds 
say relaxed plan ha am 
algorithm applies layer possible actions 
particular includes layer facts true true executing step max values high respective variable values 
fact effect right hand sides positively monotonic inserting max values increase outcome argument inductively applied actions implying layer contains facts true execution actions max values high translating ignoring delete lists numeric state variables respective variable values 
monotonicity numeric constraints implies goals reached layer pm exp exp max 
algorithm fail layer assume 
new propositions come max values changed maximum needed value 
denote set variables value low max 
note rv holds outside rv values gamma 
pm pm max max show pm pm max max proves claim iterating argument holds true layers get contradiction goals reached note constraints variable participates fulfilled increasing variables reach new goal constraints 
set propositions increase layer new action came am am value variable increase layer new action came effect right hand side expression exp positive am result increasing variable values right hand side expression exp am higher max result increasing variable values 
cases occur definition values variables reached 
case am contain new action new precondition constraints true variable values increased constraints participate fulfilled second case exp effect right hand sides variables participate values rv definition effects applies 
third case occurred variable contained right hand side responsible effect exp 
variable fulfill max exp max hold rv definition effects applies max hold application exp am contradiction assumptions 
concludes argument 
relaxed graphplan correctness strips lnf tasks prove respective relaxed graphplan mechanisms correct actions select form relaxed plan 
proof strips case trivial 
proposition assume strips task state algorithm depicted reaches goals 
actions selected algorithm depicted form relaxed plan 
proof note layer goal action level gamma eff due way levels computed 
action preconditions lower level action 
algorithm selects set layer arrange actions sets arbitrary order obtain relaxed plan 
goals hoffmann sub goals layer achieved actions gamma delete effects ignored propositions true needed 
proof lnf tasks straightforward extension strips proof 
theorem assume linear numeric task lnf acyclic effects 
assume state algorithm depicted reaches goals 
actions selected algorithm depicted form relaxed plan 
proof note layer goal action level gamma eff due way levels computed 
numeric goals exp effect sufficiently high right hand side value max gamma exp eff exp max gamma exp max gamma max gamma holds 
case loop entered second case terminates successfully 
note occurrence action support different logical numeric goals different effects support numeric goal twice 
denote layer set actions selected algorithm layer 
arrange actions sets arbitrary order obtain relaxed plan 
goals sub goals layer logical numeric achieved actions gamma expressions numeric goals effect right hand sides high required constrain contained variables take respective maximum values 
delete effects ignored propositions true needed 
decreasing effects ignored monotonicity effect right hand sides expression values constraints high required 
bacchus 

aips planning competition 
ai magazine 
blum furst 

fast planning planning graph analysis 
artificial intelligence 
bonet geffner 

hsp heuristic search planner 
aips planning competition pittsburgh pa bonet geffner 

planning heuristic search new results 
fox 
eds advances ai planning 
th european conference planning ecp pp 
durham uk 
springer verlag 
bonet geffner 

planning heuristic search 
artificial intelligence 
bonet geffner 

robust fast action selection mechanism planning 
proceedings th national conference american association artificial intelligence aaai pp 

mit press 
translating ignoring delete lists numeric state variables bylander 

computational complexity propositional strips planning 
artificial intelligence 
kambhampati 

domain independent heuristic metric temporal planner 
cesta borrajo 
eds advances ai planning 
th european conference planning ecp pp 
toledo spain 
springer verlag 


taming numbers durations model checking integrated planning system 
journal artificial intelligence research 
issue 


mips model checking integrated planning system 
ai magazine 
fikes nilsson 

strips new approach application theorem proving problem solving 
artificial intelligence 
fox long 

stan hybrid planning strategy subproblem abstraction 
ai magazine 
fox long 

third international planning competition temporal metric planning 
ghallab hertzberg traverso 
eds proceedings th international conference artificial intelligence planning scheduling aips pp 
toulouse france 
morgan kaufmann 
knoblock 

combining expressiveness ucpop efficiency graphplan 
steel alami 
eds advances ai planning 
th european conference planning ecp vol 
lecture notes artificial intelligence pp 
toulouse france 
springer verlag 
gerevini 

planning stochastic local search temporal action graphs 
journal artificial intelligence research 
issue 
gerevini 

local search techniques temporal planning lpg 
proceedings th international conference automated planning scheduling trento italy 
morgan kaufmann 
ghallab 

representation control ixtet temporal planner 
proceedings nd international conference artificial intelligence planning systems aips pp 
chicago il 
aaai press menlo park 
geffner 

heuristic planning time resources 
cesta borrajo 
eds advances ai planning 
th european conference planning ecp pp 
toledo spain 
springer verlag 


decidability undecidability results planning numerical state variables 
ghallab hertzberg traverso 
eds proceedings th international conference artificial intelligence planning scheduling aips pp 
toulouse france 
morgan kaufmann 
hoffmann 

heuristic domain independent planning enforced hill climbing algorithm 
proceedings th international symposium methodologies intelligent systems ismis pp 

springer verlag 
hoffmann hoffmann 

local search topology planning benchmarks empirical analysis 
nebel 
ed proceedings th international joint conference artificial intelligence ijcai pp 
seattle washington usa 
morgan kaufmann 
hoffmann 

extending ff numerical state variables 
proceedings th european conference artificial intelligence ecai pp 
lyon france 
wiley 
hoffmann 

local search topology planning benchmarks theoretical analysis 
ghallab hertzberg traverso 
eds proceedings th international conference artificial intelligence planning scheduling aips pp 
toulouse france 
morgan kaufmann 
hoffmann nebel 

ff planning system fast plan generation heuristic search 
journal artificial intelligence research 
koehler 

planning resource constraints 
proceedings th european conference artificial intelligence ecai pp 
brighton uk 
wiley 
koehler hoffmann 

reasonable forced goal orderings agenda driven planning algorithm 
journal artificial intelligence research 
koehler hoffmann 

instantiation adl operators involving arbitrary order formulas 
proceedings ecai workshop new results planning scheduling design 
long fox 

rd international planning competition results analysis 
journal artificial intelligence research 
issue 
mcdermott 

heuristic estimator means ends analysis planning 
proceedings rd international conference artificial intelligence planning systems aips pp 

aaai press menlo park 
mcdermott 

regression match graphs control search planning 
artificial intelligence 
nebel 

expressive power propositional planning formalisms 
journal artificial intelligence research 
nguyen kambhampati 

partial order planning 
nebel 
ed proceedings th international joint conference artificial intelligence ijcai pp 
seattle washington usa 
morgan kaufmann 
pednault 

adl exploring middle ground strips situation calculus 
brachman levesque reiter 
eds principles knowledge representation reasoning proceedings st international conference kr pp 
toronto 
morgan kaufmann 
hoffmann 

extraction ordering usage landmarks planning 
cesta borrajo 
eds advances ai planning 
th european conference planning ecp pp 
toledo spain 
springer verlag 
translating ignoring delete lists numeric state variables 

grt domain independent heuristic strips worlds greedy regression tables 
fox 
eds advances ai planning 
th european conference planning ecp pp 
durham uk 
springer verlag 


heuristic planning resources 
proceedings th european conference artificial intelligence ecai pp 
berlin germany 
wiley 


grt planning system backward heuristic construction forward state space planning 
journal artificial intelligence research 
russell norvig 

artificial intelligence modern approach 
prentice hall englewood cliffs nj 
smith weld 

temporal planning mutual exclusion reasoning 
proceedings th international joint conference artificial intelligence ijcai pp 
stockholm sweden 
morgan kaufmann 

