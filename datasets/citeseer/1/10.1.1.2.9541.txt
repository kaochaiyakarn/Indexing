shape analysis reinhard wilhelm mooly sagiv thomas reps fachbereich informatik universit des saarlandes department computer science tel aviv university computer science department university wisconsin madison 
shape analysis algorithm statically analyzes program determine information heap allocated data structures program manipulates 
results understand verify programs 
contain information valuable debugging compile time garbage collection instruction scheduling parallelization 
pointers anonymous objects stored heap dark corner imperative programming languages 
treatments semantics pointers 
semantic descriptions imperative programming languages assume nonexistence pointers semantics assignment statement complex 
reason assignment pointer variable pointer component may far reaching side ects 
far reaching side ects program dependence analysis harder dicult compute aliasing relationships di erent pointer expressions program 
having precise program dependence information decreases opportunities automatic parallelization instruction scheduling 
usage pointers error prone 
dereferencing null pointers accessing previously deallocated storage common programming mistakes 
usage pointers programs obstacle program understanding debugging optimization 
activities need answers questions structure heap contents pointer variables pointing heap 
shape analysis generic term denoting static program analysis techniques attempting determine properties heap contents relevant applications mentioned 
structure structure follows section number questions contents heap listed 
subsection presents program running example program destructively reverses singly linked list 
subsection shows shape analysis answer questions heap contents produced program 
section introduces parametric shape analysis lines provides generative way design implement shape analysis algorithms 
shape semantics plus additional properties individual storage elements may may possess speci ed logic shape analysis algorithm automatically generated speci cation 
abstraction functions transfer functions intuitively means examples 
section presents experience obtained implementation done java 
section brie discusses related 
section presents 
questions heap contents shape analysis somewhat constrained view programs 
interested numerical string values programs compute exclusively linked structures build heap pointers heap stack global memory cells heap 
term execution state mean set cells heap connectivity pointer components heap cells values pointer variables store 
questions execution states wish pose points program null pointers may pointer variable pointer component heap cell contain null 
valuable debugging information entry statement attempting dereference pointer 
may alias may pointer expressions heap cell 
absence may aliasing improving program dependence information 
alias pointer expressions denote heap cell 
may predict cache hit trigger prefetch 
sharing may heap cell shared 
uses information 
explicit deallocation shared node may leave storage manager inconsistent state heap cell deallocated twice calls predecessor 
nonshared cell may explicitly deallocated pointer ceases exist 
valuable debugging 
reachability heap cell reachable speci variable pointer variable 
unreachable cells certainly garbage 
disjointness data structures pointed distinct pointer variables common elements 
disjoint data structures may processed parallel di erent processors may stored di erent memories 
term shared means heap shared pointed pointer components heap cells 
sharing due pointer variables pointer variable heap cell component pointing heap cell deducible results shape analysis 
may heap cell part cycle 
garbage collection done counting 
shape shape part heap contents 
shapes precisely shape descriptors characterize data structures 
shape descriptor indicate heap contains singly linked list potentially de nitely cycle doubly linked list binary tree properties listed ingredients shape analyses sharing reachability disjointness 
shape analysis understood extended type analysis results aid program understanding debugging veri cation 
example destructive reverse exit null false true null null fig 

flow graph program program reverse running example 
destructively reverses list pointed pointed reverse include list list reverse list list null null null return assumes declaration list data type list typedef struct node struct node int data list control ow graph reverse reproduced fig 

program points labeled ease 
body loop pointer variable holds current list grabs head current list 
moved tail current list 
rst ed connect new head old list fig 

input list reverse workings reverse exempli ed input list shown fig 

table shows execution state rst iterations loop 
assume input program non empty acyclic singly linked list unshared elements shown fig 

correct answers questions listed section point acyclic singly linked lists list may empty may aliases point null 
points null lists point disjoint list element heap shared 
aliases may aliases 
may aliases aliases 
note case initial list contained cycle 
garbage cells 
answers shape analysis shape analysis started aforementioned assumption input program non empty acyclic singly linked list 
expressed called shape graphs shown fig 

shape analysis reverse produce information program point lists arise 
program point results shape graphs shown fig 

graphs interpreted follows rectangular box containing name represents pointer variable pointer variables program reverse appear boxed shape graphs figures 
splitting assignment steps done simplify de nition semantics 
table 
rst iterations loop reverse ovals stand locations 
solid oval stands location represents exactly heap cell 
fig 
oval represents cell input list length 
dotted oval box stands location may represent heap cells fig 
dotted oval represents cells tail input list 
example input list shown fig 
cells 
solid edge labeled locations represents fact component heap cell represented point heap cell represented fig 
indicates component heap cell represented point heap cell represented 
uu uu fig 

description input reverse 
represents acyclic lists length lists length 
edge represents component pointing third gure table 
dotted edge labeled locations tells component heap cells represented may point heap cells represented case location edge may may represent cycle 
fig 
dotted self cycle location represents components heap cells represented possibly pointing heap cells represented 
additional information non heap sharing see implies case dotted self cycle represent cycle heap 
fig 
represents execution state second gure table 
dotted location represents heap cells dotted back edge represents pointers respectively 
solid edges location represent properties de nitely heap cells represented example solid edge pointer variable represents fact point heap cell represented heap cell property pointed 
property example reachable denoted graph 
means heap cells represented corresponding location transitively reachable pointer variable components 
solid ovals viewed locations having property uniquely representing called summarized 
dotted edge property location indicates heap cells represented location may may property 
absence edge property location means heap cells represented de nitely property 
fig 
absence edge location means de nitely point cell represented 
absence uu uu uu fig 

shape graphs describing execution states arise pointer variable shape graph means stores represented graph points null 
analysis reverse important heap cell property means heap shared 
show graphs fig 
signifying heap cell shared execution states arise 
summary shape graphs portray information kinds solid meaning holds properties including uniquely representing absent meaning holds properties dotted meaning don know properties including uniquely representing holds holds called de nite values properties don know called inde nite value 
shape graph produced program point describes execution states occur execution reaches program point 
set graphs produced program point describes superset execution states occur execution reaches program point 
interpretation mind claims properties heap contents checked verifying hold graphs shown fig 

shape analysis example program reverse works lists arbitrary lengths 
described preceding section program point description lists occurring execution nite graphs describing lists arising 
general requirement shape analysis 
data structures program builds manipulates general unbounded size shape descriptor bounded size 
representation heap contents conservative sense asks properties heap contents compiler debugger program understanding system receives reliable answer 
claim pointer variable pointer component value null program point may case executions program program paths leading program point 
may case program execution resp 
null point analysis unable derive information 
eld program analysis say program analysis allowed err safe side 
short shape analysis computes program point program nite conservative representation heap allocated data structures arise path program point executed 
summarization constraint bounded representation implies loss information heap contents 
size information lengths lists depths trees general lost 
structural information may get lost due chosen representation 
part execution state properties exactly represented part execution state properties approximatively represented 
process leading called summarization 
summarization intuitively means heap cells lose identity represented heap cells location 
connectivity jointly represented heap cells represented conservatively pointer heap represented pointers absence pointers may represented jointly 
properties heap cells represented conservatively 
means property holds summarized cells hold hold summary location property holds summarized cells value don know summary location 
seen subsection main problems extract location summary location concrete execution program pointer advanced heap cells represented summary location 
process called materializing new location summary location 
static program analysis shape analysis static program analysis technique 
couched terms theory interpretation cf 

important ingredient static program analysis abstraction function 
abstraction function relates worlds case shape analysis concrete world program execution states world shape graphs 
maps execution state bounded conservative representation 
abstraction function described summarization 
concrete semantics programming language set functions st statement st language 
describe ect statements execution state 
semantics describes ect statements representation execution states 
form transfer function st statement st applying st called abstractly executing st parametric shape analysis shape analysis generic term standing class algorithms di erent power complexity trying answer questions structures heap 
setting particular shape analysis algorithm determined set properties heap cells may values tracked shape analysis algorithm 
core properties pointed property program pointer variable property connected pairs heap cells possess component points properties part pointer semantics 
core properties particular shape analysis reverse program pointed denoted just pointed denoted pointed denoted connected denoted properties called instrumentation properties 
determined analysis meant observe 
expressed terms core properties 
example analysis nd properties programs manipulating acyclic singly linked lists 
sharing properties important detect acyclicity 
reachability properties speci pointer variables important keep disjoint sublists summarized separately pointer moves list 
instrumentation properties example analysis shared denoted reachable denoted reachable denoted reachable denoted 
property existing shape analysis 
abstraction functions abstraction function particular shape analysis determined subset set properties called abstraction properties 
principle heap cells de nite values abstraction properties summarized location 
view set abstraction properties means observing contents heap heap cells summarized summary location observable di erence 
fig 
cells tail input list length summarized location property properties location represents exactly rst cell input list 
properties properties 
analyzing statement semantics pointer statements available language speci ed formalism 
describes core instrumentation properties change statement executed 
uses unary properties 
complex statement involving pointers moves pointer pointer component 
reverse program statement semantics described means example 
shape graph fig 
describes lists arise program point 
uu uu uu fig 

shape graph arises shape graphs resulting abstractly executing shape graph 
statement abstractly executed 
candidate result shape graph moved inde nite edge labeled point location acceptable shape graph image abstraction function 
see note summarized location representing heap cells de nite property pointed 
semantics languages pointers implies pointer variable pointer component point cell time 
cases possible points null ii points exactly cell 
better approach creating shape graph results abstractly executing case analysis reasons summarized property edges inde nite 
rst case assumes de nite edge exists starting represents exactly heap cell 
inde nite trivial cycle labeled 
absence edge indicates cell represented shared 
back edge fig 
represent concrete back pointer solid edge representing concrete pointer 
inde nite back edge eliminated 
execution statement results graph shown fig 

second case assumes de nite edge exists starting 
assume represents heap cell 
new de nite location called materialized represents rst cells tail list 
de nite edge starting point 
argumentation potential back edge rst case newly materialized location property target back edge 
execution statement results graph shown fig 

third case inde nite edge representing absence pointer cell represented cells represented incompatible fact properties de nite value 
case impossible 
powerful shape analysis information heap contents general summarized 
shape analysis algorithms exponential doubly exponential parameters derived program parameters determined set properties observed 
implementation experience valued logics approach described implemented tvla engine valued logic analysis tal lev ami tel aviv university 
prototype implementation java experimenting analysis designs 
small examples reverse analyzed seconds pentium mhz pc 
bigger examples mobile ambients may take hours 
surprising experience expects precise analysis costly terms time space necessarily true valued logic analyses precise analysis may create fewer unneeded structures run faster 
instance lev ami analyzed program sort elements linked list 
list merge function analyzed reachability properties analysis created tens thousands graphs machine ran space 
adding reachability properties reduced number graphs analysis time seconds 
number issues need addressed tvla engine useful tool large programs 
related brief account related 
detailed treatment 
types allocation sites earliest properties heap cells abstraction point program cells allocated allocation site 
cells allocated di erent program points represented jointly node 
motivation approach nodes allocated di erent places probably going treated di erently nodes allocated place probably updated similarly 
true true 
example allocation site information fails keep locations separate cells data structure allocated program point 
methods described additional information sharing heap counts improve precision results 
types partition set heap cells 
typed language typed pointer may point cells appropriate type 
available 
lead coarse representations cells data structure type 
allocation site information type information induce static partition heap 
contrast approach described induces dynamic partition heap 
pointer variables pointed properties de ne abstraction function :10.1.1.152.1240
additional information non sharing information improve precision 
algorithm rst achieve strong cation strong update pointer values statements modi ed pointer values :10.1.1.152.1240
means algorithm delete overwrite existing pointers conservative way 
result able materialize new nodes summary nodes described section 
eciency reasons method methods described merged information available program point shape graph :10.1.1.152.1240
semantics hard understand implied loss precision 
precise variant method easier understand described 
uses sets shape graphs program point 
bounded approaches approach represent unbounded structures bounded fashion choose constant represent diameter precisely summarize heap cells outside diameter 
applied problem shape analysis mean representing lists precisely length trees depth general graphs diameter summarizing rest data structure 
approach corresponds reachable access path property jones muchnick formulation drawbacks analysis yields poor results programs manipulate cons cells horizon 
example list reversal program reverse little useful information obtained 
analysis algorithm model happens program applied lists lengths greater tail list treated conservatively arbitrary possibly cyclic data structure 
analysis may extremely costly number possible doubly exponential addition jones muchnick limiting number subsequent papers 
methods shape graphs algorithms nding may alias information pointer variables shape graphs 
sophisticated ones landi ryder deutsch 
certain programs manipulate lists deutsch algorithm ers way representing exact nite set may aliases compact way 
di erent approach taken hendren nicolau designed algorithm handles acyclic data structures 
conclude general observations 
parametric framework shape analysis method surveyed provides basis parametric framework shape analysis 
framework parts language specifying various properties heap cell may may possess properties ected execution di erent kinds statements programming language ii method generating shape analysis algorithm description 
rst issue having speci cation speci ed set properties determines characteristics data structure elements static analysis distinguish 
second issue generate appropriate algorithm speci cation 
ideal fully automatic method yacc shape analysis speak designer shape analysis algorithm supplies speci cation shape analysis algorithm created automatically speci cation 
tvla system discussed section implements parametric framework 
di erent instantiations framework create analyses di erent classes shape graphs prepared identify di erent classes store properties hold di erent points program 
di erent classes shape graphs may needed depending kinds linked data structures program link rearrangement operations performed program statements 
general instantiation framework handle program may produce conservative results due class shape graphs appropriate distinctions 
essence particular shape analysis methods discussed section captured di erent instantiations framework 
instantiation analysis framework described subsection suciently powerful successfully analyze reverse program works singly linked lists 
produce precise information programs deal singly linked lists 
fail programs operate doubly linked lists property hold rst elements lists 
instantiation doubly linked lists need properties forward backward pairing forward pointer heap cell points heap cell backward pointer point 
backward forward pairing backward pointer heap cell points heap cell forward pointer point 
di erent versions doubly linked lists need additional properties rst elements requiring unused pointer value null 
biased versus unbiased static program analysis classical data ow analysis algorithms bit vectors represent characteristic functions set valued data ow values 
corresponds logical interpretation semantics uses values 
de nite bit values conservative 
false means false true means may true may false true means true false means may true may false 
algorithms similar character 
conventional wisdom holds static analysis inherently sided bias 
material developed shows inde niteness inherent static analysis unable general give de nite answer basing semantics valued logic de nite truth de nite tracked third value capturing inde niteness 
outlook provides insight true nature values arise static analyses sided analysis precise respect false conservative respect true really valued analysis false true don know con ates true don know uses true place don know 
likewise analysis precise respect true conservative respect false really valued analysis false true don know con ates false don know uses false place don know 
contrast shape analysis shown create analyses unbiased precise respect false true separate don know value capture inde niteness 
tal lev ami carried implementation tvla 
instantiation tvla analyze example program generate gures 
hanne riis nielson provided helpful comments 


interprocedural heap analysis parallelizing imperative programs 
shriver editors programming models massively parallel computers pages washington dc september 
ieee press 

chase wegman zadeck 
analysis pointers structures 
sigplan conf 
prog 
lang 
design impl pages new york ny 
acm press 

zapata 
new shape analysis techniques automatic parallelization code 
international computing symposium 

cousot cousot 
interpretation uni ed lattice model static analysis programs construction approximation xed points 
symp 
princ 
prog 
lang pages new york ny 
acm press 

deutsch 
interprocedural may alias analysis pointers limiting 
sigplan conf 
prog 
lang 
design impl pages new york ny 
acm press 

dor rodeh sagiv 
detecting memory errors static pointer analysis 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering paste pages june 
available www math tau ac il paste ps gz 

hendren 
parallelizing programs recursive data structures 
phd thesis cornell univ ithaca ny jan 

hendren hummel nicolau 
abstractions recursive pointer data structures improving analysis transformation imperative programs 
sigplan conf 
prog 
lang 
design impl pages new york ny june 
acm press 

hendren nicolau 
parallelizing programs recursive data structures 
ieee trans 
par 
dist syst january 

horwitz er reps dependence analysis pointer variables 
sigplan conf 
prog 
lang 
design impl pages new york ny 
acm press 

jones muchnick 
flow analysis optimization lisp structures 
muchnick jones editors program flow analysis theory applications chapter pages 
prentice hall englewood cli nj 

jones muchnick 
exible approach interprocedural data ow analysis programs recursive data structures 
symp 
princ 
prog 
lang pages new york ny 
acm press 

landi ryder 
pointer induced aliasing problem classi cation 
symp 
princ 
prog 
lang pages new york ny january 
acm press 

larus 
restructuring symbolic programs concurrent execution multiprocessors 
phd thesis univ calif berkeley ca may 

larus hil nger 
detecting con icts structure accesses 
sigplan conf 
prog 
lang 
design impl pages new york ny 
acm press 

lev ami 
tvla framework kleene static analysis 
master thesis 

nielson riis nielson hankin 
principles program analysis 
springer verlag 

nielson riis nielson sagiv 
kleene analysis mobile ambients 
proceedings esop 

plevyak chien karamcheti 
analysis dynamic structures ecient parallel execution 
banerjee gelernter nicolau padua editors languages compilers parallel computing volume lec 
notes comp 
sci pages portland august 
springer verlag 

ross sagiv 
building bridge pointer aliases program dependences 
proceedings european symposium programming pages march 
available www math tau ac il sagiv 

sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
symp 
princ 
prog 
lang new york ny january 
acm press 

sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
trans 
prog 
lang 
syst january 

sagiv reps wilhelm 
parametric shape analysis valued logic 
symp 
princ 
prog 
lang 
available www cs wisc edu papers popl ps 


lattice interpretation dynamic lisp structures 
inf 
comp nov 


wang 
analysis recursive types imperative language 
phd thesis univ calif berkeley ca 
