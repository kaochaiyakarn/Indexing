testing reactive systems gast pieter koopman rinus plasmeijer nijmegen institute computer information science netherlands pieter rinus cs kun nl 
st fully automatic test system 
logical property stated function able generate appropriate test values execute tests evaluate results tests 
reactive systems automata protocols specified model order logic 
exist tools able test software model specification tools lack ability verify relations data values specified order logic 
introduce extensions st combine best worlds 
integration model testing testing logical properties single automatically systems contribution 
fully automatic test system st properties functions data types expressed order logic 
properties written functions functional programming language clean 
types functions st automatically systematically generates test values evaluates property values analyses test results 
avoids burden design evaluate test suite hand easy repeat test changing program regression tests 
automatic systematic generation test data distinguishing feature st allows proofs finite types exhaustive testing 
mainly focused concepts basic implementation st possible specify behaviour reactive systems famous ee vending machines protocols logic demonstrated 
systems usually specified model property order logic 
st able test implementations models interesting systems directly 
formalisms literature models reactive systems 
labelled transition systems lts shown general ective testing 
introduce extensions st suited model testing 
introduce general format specify labelled transition systems directly data structure clean 
specification lts function shown concise handle infinite numbers labels states 
test conformance ectively specifications basis test case generation 
test cases ective purpose systematic generation possible inputs turn ective random generation inputs 
deterministic finite lts possible prove implementation behaves specified spot error assumption implementation lts contain states specification 
advantage extending st ability test products specified lts ability test data types preserved combined new possibilities 
ability generate data test properties involving data types weak point existing automatic model test systems 
model checkers spin assume specification correct 
practise di erences specification actual implementation appears caused unintended forgotten transitions specification 
ect increasing quality confidence specification noticed specifications basis test generation 
overview st self contained give overview st automatic test system embedded functional programming language clean 
st ordinary clean functions specify properties 
example consider rotate algorithm simple way encrypt texts 
hide text casual reading rotates alphabet half length characters 
characters alphabet ected 
example encryption answer yields gur 
nice property encryption method decryption 
logic char rot rot st expressed char bool rot rot notice arguments functions specify desired property treated universal quantified variables 
testing results implementation rot property tested applying number characters check yields true arguments 
exactly function test generate arguments desired type systematic way evaluate property generated arguments investigate test cases successful 
test initiated executing start test 
execute program need implementation rotation algorithm 
rot char char rot toint rem toint rem executing test yields proof success arguments tests 
due systematic generation test data st situation detect property holds possible defined arguments 
result qualifies proof just successful test result 
type char st generates printable characters explains successful test performed 
show property tested possible characters desired 
evaluating test results basic rules evaluating series test results simple 
soon single counterexample encountered property hold 
testing process terminates appropriate error message 

counterexamples possible test values property proven defined arguments 
course proof possible finite types feasible small types 

counterexamples certain upperbound tests property passes test successfully 
gained confidence correctness 
logical operators st additional property require applying rot character yields di erent character char bool rot executing test yields counterexample tests 
stated alphabetic characters changed 
characters una ected rot 
precise formulation property require applying rot letter yields di erent character char property rot operator mimics implication operator logic 
usual semantics left operand holds right hand operand obeyed 
implementation reasons function yields element type property boolean 
boolean result transformed property applying function prop 
semantically type property union booleans functions yielding boolean just logical expressions containing universal quantifier 
evaluating property st yields proof success rejected arguments tests rejections 
left hand argument operator yields false test value rejected counted success 
operator select test values test value rejected known property right hand side 
misleading count successful test 
ways tester control generation test values 
infix operator property tested values list right hand side operator 
instance test characters standard ascii set start test map st reports passed tests 
situation easy turn result proof 
increase number tests allowed 
start map st reports proof success arguments tests 
ways control generation test values include explicit transformation generated values lists balanced trees specification tailor instances generic generation values 
automatic generation test values test data generation predefined types char easy 
possible elements finite relatively small types bool char test value 
large types int real course feasible 
st generates default common border types followed random values types 
generation test values user defined recursive types interesting 
clean generic programming facilities st generates instances types fully automatically 
test data generated small instances come larger values 
due systematic generation duplicates avoided situation 
implies st able detect instances finite type generated 
property holds values proven correct 
generation test values customized type desired 
see details 
reactive systems reactive system automaton internal state interacts environment 
restrict software systems single input output channel 
instance communication channel modelled function type message message 
simple reactive systems specify aspects behaviour order logic 
instance system consisting unreliable communication channel supervised alternating bit protocol required yield list messages identical list messages send 
st int bool int bool int bool input input input function int bool int bool mimics communication channel 
function arguments mimic communication errors sending receiving direction channel respectively 
argument list input channel result output alternating bit protocol user 
possible implementation protocol message bit bit error send bit wait bit sender message message sender send sender send cs sender wait cs sender state wait cs case sender send cs sender state cs receiver bit message message receiver receiver ms case cs cs receiver ms cs cs receiver ms channel int bool message message channel error ms error error list received acks received receiver channel messages messages sender send list channel acks implementation passes test property st works fine properties specified way limited 
instance unclear behaviour sender alternating bit protocol specified formalism 
usually labelled transition systems specify kind behaviour 
labelled transition systems labelled transition system lts description defined terms set states labelled transitions states 
clear separation input output labels deviate usual definition lts di erent types labels 
allow input generate list outputs 
introducing additional intermediate states lts transformed traditional lts 
non empty countable set states non empty countable set input symbols non empty countable set output symbols transition relation qi labelled transition system give tuple 
moment restrict deterministic systems output new state uniquely determined current state input 
fact mealy finite state machine 

due restriction spontaneous transitions transitions triggered input 
writes model checkers test systems tailor language promela language spin torx describe labelled transition systems serves specification prefer specification clean 
advantages 
full power functional programming language write specification write functions generate desired specification 
second need additional language 
explicit sets states labels employ type system clean enforce correct states labels 
straightforward realisation lts consists record containing list transitions initial state 
clean transition state input output state input output state lts state input output trans transition state input output initial state type parameters sets states labels involved gives maximum flexibility 
various di erent types transition systems context desired 
usually lts partial function decide input received state covered lts 
model checkers choose ignore input state change output empty 
known implicit completion model 
example conference protocol conference protocol described known case study model specifications testers 
conference protocol describe behaviour conference protocol entity cpe 
conference protocol allows fixed number entities chat various conferences 
order chat user able issue commands cpe join nickname conference user joins named conference nickname 
user participates conference time 
messages users conference receive message 
leave user leaves current conference 
network cpes communicate 
interface cpe network user datagram protocol udp 
cpe sends protocol data units pdus network 
network delivers pdus indicated cpe adds identification sender 
assumptions order arriving messages reliability connection 
cpe receive inputs network cpe message cpe receives messages cpe 
cpe nickname conference indicated cpe wants join named conference nickname 
cpe nickname conference request join named conference indicated cpe supplied nickname 
cpe indicated cpe leaves current conference 
accomplish task cpe send output messages cpe nickname conference send request named cpe join named conference 
network transforms message input cpe destination replace sender 
cpe nickname conference conformation cpe wants participate conference 
cpe message send message indicated cpe 
cpe indicate cpe users leaves conference 
data nickname message show received message user 
definition appropriate data types hold cpe identifiers messages nicknames conferences messages transformed directly corresponding algebraic data types 
state cpe idle participates conference 
list tuples consisting nickname records cpes participate conference nicknames 
list sorted cpe occurs 
idle conf nickname nickname number states finite conference ids nicknames id finite 
consider parameterised states lts cheating define mapping possible states su ciently large algebraic type 
specification cpe generated function 
su cient grasp idea specification don bother details 
occurring nicknames conference ids messages modelled simple algebraic datatypes 
lists members types generated systematic generation functions st instance conference conference possible conferences occurring state cpe generated function conferences 
due restrictions list participants ordered partner occurs possible generic generation conferences 
generation function lts remains correct add change remove members types involved 
powerful convenient definitions labelled transition systems existing model test systems 
instance torx uses specification lts promela 
promela specification number lts myid initial idle trans idle join nn cpe nn cpe myid conf nn nn conf cpe nn id cpe nn id conf id nn cpe nn mem conf conf id nn mem cpe nn cpe myid ismember cpe map fst mem conf cpe nn id conf id nn cpe nn mem conf conf id nn mem cpe nn ismember cpe map fst mem conf leave cpe cpe conf conf id nn mem conf cpe conf nn conf conf nn mem cpe conf cpe mes data nn mes conf conf conf id nn mem mes cpe nn compensate loss conf cpe mes cpe nn id conf conf conf id nn mem mes cpe cpe myid ismember cpe map fst mem conf mes cpe mes cpe conf conf id nn mem mes isempty mem fig 

specification cpe data structure lts partners hardwired specification 
specification concise compare specifications collected 
di erence size specification factor 
executing deterministic lts lts basis testing able execute 
lts current state input need able determine associated output new state 
lts currently deterministic fact finite state machine fsm 
prefer able give sequence inputs obtain list associated outputs giving single input 
achieved function execute deterministic lts 
lts trans initial inputs run initial inputs run state run state case run state undefined ignore input run abort lts deterministic 
implementation test perform black box test implementation test iut observe output system input 
show clearly single input produces sequence outputs system new state type iut input output iut input output iut input output convenient transform function converts sequence inputs associates outputs 
done iut iut iut iut iut testing conference protocol representation model specifications tools execute specification iut ready formulate properties tested automatically st instance desirable property implementation conference protocol iut outputs equal outputs obtained execution specification bool input id id input id input standard property st tested property st executing start test 
argument list inputs 
second argument cpe identifications 
test data generated test data st model property combined ordinary logical property 
logical predicate bool check sanity states cpe ordered duplicated combine thes properties property input id input id conferences id convinced protocol handles cpes equal limit test single cpe id cpe property bool input input cpe testing properties reveals discrepancies initial versions specification implementation 
di erences concerned handling unusual inputs receiving cpe member conference 
lead improvements implementation specification 
st reports properties passes tests 
implementation passes significant number tests tempting believe implementation conforms specification 
analysis generated inputs showed conferences established tests 
inputs generated systematically small fraction generated inputs correspond entering conference sending messages 
typically single data transfer conference established tests generated 
tests systematically generated inputs appear valuable verify specification implementation ignore inputs sequence messages completely meaningless 
tests iut shows specified behaviour robustness testing 
implementations types type iut suits tests 
implementation tested type 
custom alternative type implementation 
iut produces single stream output tokens sequence output event test implementations st adapting property slightly bool input id id input id input bool input id flatten id input id input lost ability check particular output token generated response correct input 
particular element output generated late early 
test data generation lts check correct behaviour meaningful sequences messages conformance lts source information input sequences 
instance meaningful sequence inputs input corresponding transition initial state 
existing knowledge testing fsm 
input sequence usually called path world fsm testing 
assumes iut deterministic learn new executing path prefix tested path 
furthermore assume iut states specification useless test transition twice 
assumptions standard fsm testing 
knowledge construct finite amount longer meaningful inputs 
implies able prove things exhaustive testing just executing successful tests 
discuss test generation algorithms 
state specification test transitions state 
terminate input sequence randomly choose path possible transitions point 
basically algorithm test data generation torx 
useless test transition twice terminate path untested transition current state randomly 
paths generated previous algorithm verify final state path 
iut black box check final state directly 
algorithm checks final state performing additional transitions allow transition twice path 
algorithm function type state input determine inputs test final state 
ideally unique input output sequence uio distinguishing sequence ds identify final state 
unknown exist short sequence inputs 
finding shortest set paths achieve goals variant travelling salesman problem 
simple algorithm chooses transition available 
input sequence terminated extend transition 
transitions extend prefix inputs transitions need done 
table list number states number transitions lts generated number input sequences algorithms various numbers cpe nicknames conferences messages 
nature generate infinitely paths 
particular test choose paths 
table shows number input sequences generated big specifications modest size 
large quick complete automatic test 
algorithm produces paths accurate requires known paths verify final state 
testing conference protocol nick confer mes trans paths generated cpes names ences sages states table 
number paths generated various size types 
state mess join nn mess hd messages nn hd nicknames hd algorithms appropriate test sequence final states hand 
usually gives results 
important realize tests check iut behaves specified lts known conformance testing 
testing generated input sequences show iut shows unspecified behaviour 
purpose need exhaustive tests inputs states 
default generation algorithm st provides useful approximation 
functional nondeterministic specifications lts type straightforwardly represents labelled transition systems 
su ers drawbacks 
allows nondeterminism thorough examination data structure necessary see specification deterministic 

limited finite number transitions 
impossible specify system echoes integer string 

impossible typical functional language features guards pattern matching specification 
problems solved functions type spec state input output state input state output specification 
just implicit completion specification inputs states specified change state produce output 
consider system returns absolute value negative integers 
small definition covers transition integers 
state test circumstances required function total 
achieved adding default yielding empty list transitions 
compare new specification specification data structure list myid idle join nn conf conf conf nn cpe nn conf myid state conf conf nn mem input map fst mem case input mes state cpe mes cpe leave idle cpe cpe id mes ismember id state data nn mes cpe nn state id nn conf handle lost join id nn conf conf conf ismember id myid conf conf nn id nn mem id nn conf conf conf ismember id myid conf conf nn id nn mem id nn conf id conf conf nn id specification total specification total fig 

specification cpe function 
specification conference protocol function 
clearly compact previous version 
lists yielded length obvious specification deterministic 
contrast specification data structure listed section version works types int cpe ids string messages nicknames 
kind specifications really powerful 
test sequence generation algorithms section operate data structures 
uses algorithms need generate transitions specification function 
transitions state produced spec transition spec inputs obtain entire transition relation just construct transitions reachable state 
finite types generic generation list inputs tested 
infinite extremely large types int tester supply list inputs 
testing nondeterministic systems consider simple vending machine nondeterministic lts inal coin tea tea button idle button ee coin ee final button pressed machine decides produce tea ee happens coin inserted 
better vending machine returns idle producing ee tea 
input ouput decide state machine pressing button 
impossible bring machine state tea supplying inputs possible machine take branch 
machine specified st idle button coin tea coin coffee state input cope situation ioco test 
name ioco stands input output conformance 
basic idea observed output corresponding input allowed specification 
deal nondeterminism maintain list possible current states single current state 
implemented spec iut string spec states iut paths test paths test tests successful test paths tostring ioco iut states test paths ioco iut path cont error ioco iut states cont ok cont ioco iut iut states path cont ioco iut states path cont iut iut states test require system really nondeterministic 
instance test conference protocol input generated algorithms discussed 
paths generated algorithms introduced section 
sophisticated ioco test algorithm generate input basis observed behaviour 
fly testing remains 
related closest related test system logical properties quickcheck 
discriminating di erence quickcheck st systematic test data generation st test data generation quickcheck class user supply instance new type random data generation 
st test data generation new type comes free generics 
generation test data systematic small large duplicates 
property holds values type proven 
extension st introduced model test system torx tgv uio test 
basically systems generate inputs system tested lts specification 
currently systems di culties conditions values 
st conditions easily expressed order logic 
aware number running projects extend model test systems capabilities handle restrictions types 
results reported 
model specifications clean appear clearer shorter general example specifications collected 
representing labelled transition system data type enabling execution lts able test systems specified lts st significant improvement interesting systems specified model property order logic 
lts basis test data generation 
input sequences test system behaves correct inputs part specification 
default data generation st verify system show undesired behaviour inputs 
functions data type specify lts significant advantages 
specification concise able handle infinite data types labels states 
model testing integrated automatic testing logical properties 
st extension stronger existing model testers 
systems known weak testing data types 
projects running extend model test systems ability generate data values results reported 
peter marko van eekelen jan tretmans rene de vries van ronny contributions 

douglas adams 
hitch guide galaxy isbn 

aho lee optimization technique protocol conformance test generation uio sequences rural chinese postman tours protocol specification testing verification viii volume 

plasmeijer 
generic programming extension clean 
ifl lncs pp 

van der rensink tretmans component testing ioco ctit technical report university twente 

vries tretmans formal test automation simple experiment int 
workshop testing communicating systems pp 

brinksma tretmans testing transition systems annotated bibliography modeling verification parallel processes th summer school lncs pp 

claessen hughes 
quickcheck lightweight tool random testing programs 
international conference functional programming acm pp 
see www cs chalmers se quickcheck 

claessen hughes 
testing monadic code quickcheck proceedings acm sigplan workshop haskell pittsburgh pp 

fernandez fly verification techniques generation test suites lncs 

fernandez 
fly verification techniques generation test suites conference computer aided verification 

tretmans formal test automation conference protocol ural testing communicating systems procs 
kluwer pp 

hinze polytypic values possess types fifth international conference mathematics program construction lncs pp 

gerard holzmann spin model checker primer manual addison wesley isbn 

comparing torx tgv uio test algorithms sdl meeting uml th international sdl forum copenhagen denmark june proceedings 
lncs pp 

automated test generation sdl specifications millennium proceedings th sdl forum pp 

pieter koopman jan tretmans rinus plasmeijer gast generic automated software testing ricardo pena ifl implementation functional programming languages lncs pp 

lee yannakakis principles methods testing finite state machines survey proceedings ieee pp 

george mealy method synthesizing sequential circuits bell system technical journal 
rinus plasmeijer marko van eekelen concurrent clean language report version 
www cs kun nl clean 

schmitt ek grabowski kock putting sdl test generation practise proceedings th international workshop testing communication systems pp kluwer academic 

mike spivey notation manual nd ed prentice hall 

tretmans brinksma cote de automated model testing progress rd workshop embedded systems pp 

tretmans test generation inputs outputs 
software concepts tools 

tretmans testing concurrent systems approach 
baeten concur lncs pp 

formal specifications conference protocol various languages 
fmt cs utwente nl specifications specs html 
ural formal methods test sequence generation computer communications journal pp 
