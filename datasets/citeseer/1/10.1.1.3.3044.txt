value dependence graphs representation taxation daniel weise roger crew michael ernst bjarne steensgaard microsoft research value dependence graph vdg sparse representation simplifies program analysis transformation 
functional representation represents control flow data flow explicit machine quantities stores channels 
developing compiler builds vdg representing program analyzes transforms vdg produces control flow graph cfg asu optimized vdg 
framework simplifies transformations improves published results 
example enables powerful code motion fow eliminates redundancies redundant loops provides important information code scheduler br 
exhibit pass method elimination partial redundancies performs redundant code motion krs ds simpler classical ssa methods 
results accrue eliminating cfg analysis transformation phases demand dependences preference control dependences 
program analysis prerequisite important program transformations performed compilers 
classical program representation analysis control flow graph cfg 
cfg analyses transformations suffer burdens main authors address microsoft way redmond wa 
email rfc research microsoft com 
slightly revised version appeared conference record annual acm symposium principles programming languages portland january pp 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
tain cfg invariants produce semantically equivalent cfg code motion transformation sensitive names values 
cfgs computation totally ordering operations requiring addition extra nodes entry pads exit pads cfg performing code motion 
cfgs name values names usually provided programmer get way analyzing underlying computation 
decade new program representations proposed alleviate problems analysis simpler faster thorough 
static single assignment ssa form cfr gives value distinct name improves efficiency constant propagation analyses wz wz 
dependence flow graph dfg improves efficiency analyses ignoring irrelevant sections code linking definitions uses jp 
representations viewed augmentations cfg allow rapid traversal cfg 
program dependence graph pdg eliminates control artifacts linking operations control dependence builds local data dependence graphs simplify analysis transformation ott fow 
program dependence web bmo value flow pdg explicit gated single assignment gsa form 
step solving problems cfgs eliminate cfg basis analysis transformation 
represent computation value dependence graph vdg specifies value flow computation 
vdg depend information values names locations reside computed 
vdg parallel representation specifies partial order operations computation solely data dependences arbitrary total order specified cfg 
vdg semantics demand value computed needed computation 
evaluation sese analysis cfg sdg symbolic execution vdg vdg analysis optimization vdg sdg nonrecursive inlining cfg cfg stages translation initial control flow graph cfg final cfg 
parser creates initial cfg back generates machine code final cfg 
vdg may terminate original program cfg values demanded appear vdg 
code generation cfgs straightforward cfg limitations requirement maintain total ordering program statements cfg statement nature complicate analyses transformations 
claim wrong tradeoff optimizing compiler contains analyses transformations conversion intermediate representation say cfg form back 
analysis transformation simpler implement understand express formally frequently faster vdg cfg 
simple minded code generation vdg may result poor code representation provides important information code scheduler br code movement scheduling considerably easier 
believe code generator right place complexity generating sequential code analysis transformation burden maintaining structures irrelevant operation applied 
shows steps translation cfg vdg form analysis optimization back cfg form 
example program illustrate resulting transformations 
figures show transformations cfg framework figures show intermediate steps translation cfg vdg discussed detail 
optimizations performed independently final order evaluation performed vdg 
example global constant copy propagation constant folding global name insensitive common subexpression elimination dead code elimination performed directly vdg 
code motion optimizations decided demand dependence graph constructed vdg 
demand dependence graph similar spirit control dependence graph cdg fow demand dependence graph constructed predicates lead computation contributing output program predicates cdg int example int int int int int bcopy int cse epr dead bcopy bcopy dead cse 
cse 
bcopy epr 
cse return epr example procedure containing loop invariant computations common subexpressions partial redundancies dead computations 
figures show transformations performed procedure cfg translation vdg form back vdg manipulations 
lead computation performed 
optimizations depend final placement code performed vdg demand dependence graph constructed 
demonstrates results transformations performed vdg 
basis powerful precise efficient program slicing algorithms 
efficient algorithms interprocedural slicing slicing unstructured programs interactive slicing operate directly vdg ern 
section describes vdg translation cfgs steps 
analyses transformations discussed section 
section discusses aspect producing cfgs construction demand program dependence graph 
ste describes translation final cfg 
section shows representation affords algorithm elimination partial redundancies epr simpler faster classical ssa formulations 
algorithm uses constructed code generation 
section compares research related section discusses research directions 
bcopy lp inv bcopy lp inv lp inv dead cse cse epr lp inv epr deallocate local storage return false true true false allocate local storage original cfg example 
cfgs asu explicitly represent branches joins 
dotted boxes enclose irreducible sese regions see section 
value dependence graphs vdg functional representation expresses computation procedure solely value flow 
lack control flow immediate consequences 
machine quantities usually implicit representations store contents stack heap allocators input output channels volatile locations explicitly represented value flow ensure state changing operations occur correct order 
simplify exposition consider machine state consist solely store 
second operators choose control paths switch statements represented selectors choose possible values essentially fl nodes bmo 
third looping represented function calls cfg backedge finds analog vdg recursive call 
vdg consists 
directed bipartite graph vertices nodes representing computations ports representing values 
graph arcs connect nodes bcopy lp inv bcopy lp inv lp inv cse dead cse cse epr epr lp inv lp inv epr deallocate local storage return allocate local storage lp inv true false true false transformations example done analysis shown cfg framework 
transformations performed cfg occur result translations vdg form back done vdg 
statements light font moved removed transformations appear final cfg 
statements heavy underlined font appear final cfg 
transformations occur example hoisting loop invariant loop lowering loop invariant loop name insensitive global common subexpression elimination code motion arm statement lowering invariant expression outside loop value expression consumed loop dead code elimination decoupling values store 
analysis reveals example run parallel functions depend result 
lp inv cse epr lp inv lp inv epr return lp inv true false true false final cfg example results translation vdg cfg 
operand values ports ports computations nodes producing results 
port produced exactly node free value produced node 
nodes kinds ffl primitive operation nodes including basic arithmetic data structure operations constants ffl boolean integral selector fl nodes representing conditional expressions produce single result predicate integer operand alternative value operands ffl closure nodes produce function values ffl function application call nodes function operand actual parameter operands corresponding formal parameters function vdg see producing result ports corresponding function vdg return nodes ffl formal parameter nodes operands result parameter value ffl return nodes operand return value produce results vdg contains return node value returns 
cycles graph include node 

indexings sets parameter nodes return nodes operand arcs node result arcs node 

body node vdg bijection free values vdg operands practice simply identify free values operands note operands parameters 
figures show 
free values vdg viewed analogous free variables lambda term 
vdg body node free values denote external values external functions addresses global variables calls node common 
top level vdg complete program takes form function producing final machine state store initial machine state free values 
slightly larger cfgs anticipate prove large practical 
experiments thinned gated single assignment form hav indicate practice constructed time space linear number variable programs satisfying reasonable assumptions 
surprised result hold vdg form similar form 
sections describe steps constructing procedure vdg 
step sese analysis constructs store dependence graph sdg translation cfg vdg form basic blocks left uninterpreted 
unstructured control flow modeled procedure calls 
second step inlining nonrecursive calls introduces extra fl nodes allow inlining code duplication 
third step symbolic execution sdg closure interprets basic blocks produce vdg 
construction store dependence graph store dependence graph sdg vdg having node kinds place nodes indexing set bijection suffices 
establishes correspondence call operands parameters call results returns selector branches predicate values construction sdg expository fiction 
implementation finds information necessary construct sdg uses information guide symbolic execution construct sdg 
bcopy lp inv bcopy lp inv lp inv dead cse cse epr lp inv epr deallocate local storage return allocate local storage call call store store store store sdg example produced cfg 
sdg vdg diagrams suppress ports computations single valued 
heavy box denotes node produces function result 
arcs leaving box function operand arc inner call node denote free value operands 
parameter return nodes embedded upper lower boundaries respectively 
dotted lines indicate store values solid lines scalar function values 
ffl block nodes produce store previous store operand ffl predicate nodes produce predicate value store operand 
initial cfg assumed explicit join nodes entry exit nodes 
addition statements reside cfg basic block nodes having just predecessor successor branches contain predicate switch value joins content whatsoever 
block predicate node resulting sdg corresponds particular cfg basic block branch 
cfg node consider function giving store prior function store prior sdg representation function case entry exit 
way control flow replaced store value flow 
shows sdg example 
problem reduces constructing sdg fragment corresponding traversal cfg 
ffl basic block replaced corresponding basic block sdg node applied store operand 
cfg traversal proceeds block successor 
ffl translate branch node designated branch see 
sequence stores obtained traversing cfg branch successor turn branch stores combined fl node 
cfg traversal proceeds branch 
ffl join indicative looping unstructured control see translates node call node join predecessor 
nodes called internal nodes distinguish functions explicitly defined programmer corresponding calls eventually converted gotos code generator 
branch translation join translation requires designation postdominator join designate cfg traversal continues call produce body sdg traversing cfg join successor join 
ffl remaining joins lower join merely distinct paths branch call nodes necessary 
particular join needs corresponding internal designate branch join ends resolved single entry single exit sese analysis jp 
pair distinct cfg nodes encloses sese region iff exist arcs ff fi ff dominates fi fi postdominates ff ff fi cycle equivalent cfg graph cycle contains 
sese region consists nodes dominated merging consecutive joins original cfg prevents artifacts resulting ordering joins 
specified sese region refers nontrivial sese region single basic block composition sese regions 
node sese bottom node enclose sese region 
cfg node bottom postdominator smallest sese region containing bottom nodes time 
join symptomatic looping unstructured control iff sese bottom 
analysis associates branch join node branch join 
analysis depends node sese bottom 
branch sese bottom node branch branch unique successor outside sese region 
join sese bottom node join 
determining non branch join bottom 
nodes contained sese regions nodes bottom bottom ignored 
non sese bottom branch node nearest postdominator join node non sese bottom join nearest postdominator branch analysis depends postdominator trees takes linear time har 
important property construction cfg basic block predicate appears exactly resulting sdg consequence cfg node visited exactly cfg traversal 
rules determining branch join ends chosen minimize number call nodes generated numerous variations worth exploring 
fl transform inlining nonrecursive calls initially sdg models looping unstructured control call nodes 
simplify analysis transformation fl transform calls corresponding unstructured control flow ensuring recursive external call 
permits inlining code duplication call model looping procedures procedure calls 
result process similar thinned gated single assignment hav fl trees take stores values inputs 
passes produce structures fl trees operate values stores 
fl transform call loops discovered identifies internal loop entry points identifies recursive calls finding loops multiple entry points 
fl transform particular internal proceeds steps 
control dependence tree projected contain paths leading nonrecursive calls 
symbolic execution tags operations control dependences 
second fl tree generated converting predicates branches contained projection fl nodes omitting predicates 
final step depends called recursively 
called recursively new call created input fl tree operands original calls leaves 
new call replaces old nonrecursive calls non recursive call internal called recursively third step inlines body making consumers store input consume fl tree making consumers calls consume outputs body 
fl transform handles irreducible loops fashion collecting treating calls loop 
example consider simple unstructured program cfg 
upper join point sese bottom 
corresponding sdg cfg contains calls possible path entry cfg unstructured join point 
fl transform produces new fl node selects stores paths join predicates fl fork initiates separate paths inlines body replacing store parameter node just constructed fl node 
fl transform illustrated sdgs 
fl nodes introduced pass represent additional representational overhead form ssa form 
experiments shown overhead linear function size programs ssa form hav 
symbolic execution symbolic execution expands sdg unevaluated basic blocks vdg nodes 
expansion global value numbering copy propagation constant propagation performed recourse fixed point analysis automatically performed 
shows vdg results symbolically executing example sdg 
symbolic execution occurs independently body node basic block visited turn predecessors processed 
symbolic execution uses data structure called symbolic store maps locations vdg ports representing values currently known stored 
essentially symbolic store represents known store operand basic block sdg node executed 
basic block sdg supplied symbolic store contains information globally allocated locations necessarily contents 
symbolic execution basic block updates symbolic store represents known result store gets passed basic block successors 
symbolic execution produces vdg nodes rules variable lookup variable location symbolic store contains value placed previous update see return value 
location contains explicit value build vdg lookup node representing corresponding runtime load operation return result port 
store result fl node ste describes handling store operations location looked modified known due pointer operations 
false true false true call call store store store store store store cfg left contains unstructured control flow results non recursive nodes corresponding sdg middle 
non recursive prevent accurate analysis lack fl nodes indicate parameter values come paths program 
way track call supplied particular parameter value 
solve problem constructing fl trees indicate inputs come inlining fl input right illustration 
create fl node operand result looking variable store 
constant folding performed values port simply return 
expression evaluation expression evaluated statically return value build vdg node represents runtime execution expression return result port 
nodes cached attempts construct node operation operands match existing node merely retrieve existing node 
caching known global value numbering coc cs implements common subexpression elimination cse representing multiple necessarily identical source expressions single node 
variable update assignment statement update location symbolic store contain value vdg port obtained symbolically executing expression part assignment statement 
updated store symbolically execute program assignment assigned value available subsequent follow asu defining expressions common subexpressions compute value dominates 
lookups 
symbolic execution performs interprocedural analysis call effect store passes perform 
symbolic execution call results store information contents locations 
lookups store symbolic execution create lookup nodes 
additionally values homed placed single locations temporary storage call return 
done constructing update store node arguments changed values corresponding locations symbolic store 
analysis transformation vdg produced symbolic execution coarse program analysis computation depends store operations inhibit instruction level parallelism 
analyses transformations reduce reliance store making vdg sparser parallel 
standard transformations dead code elimination performed 
transformations arity raising parameter return values performed 
allocate store store update store update store update store call update store dead lp inv lp inv cse epr store call update store deallocate store epr lp inv bcopy cse vdg example symbolic execution 
dashed circles store operand lookup load operations 
clarity location arguments lookup update store nodes suppressed values produced allocate node indicated labels lookup nodes value operand arcs update store nodes 
vdg representation transformations simpler state prove correct implementations efficient 
formulation admit standard dataflow model proving properties program points model program points 
analysis proves invariants runtime values 
node interpretation fixpoint engine finds fixpoint equations specified vdg functions 
framework accommodates forward flow problems backward flow problems variants question information rest program demand example dead update elimination eliminates operations store backwards flow analysis determines elements store demanded rest program 
vdg called sparse representation analysis information flows directly consumed 
loop dependences analysis pass annotates internal node locations node demands mutates 
represents loop locations demanded mutated loop called loop dependent locations 
loop example variable demanded changed demanded changed epr changed demanded 
pass employs fixed point finding algorithm determine information 
particular strongly connected component scc vdg demands changes locations 
algorithm performs inside traversal sccs visiting inner sccs internal inner loops get detailed information outer ones 
traversal reveals locations demanded changed 
traversal needs follow store arguments operations perform lookups modifications interest values retrieved stored 
dotted arcs need followed traversal quicker full traversal vdg 
components scc traversed scc annotated demand modification information transformation passes depend 
accounting effects calls store analysis transformation constant folding pass major goal program independent store possible symbolically executing lookup nodes pull values store 
construction left lookups store produced call nodes graph 
likewise known store parameters produced lookup nodes internal store parameter 
pass uses information loop dependence analysis approximate stores entry exit call 
effects calls accounted single topdown pass vdg 
node processed inputs processed 
processing propagates symbolic store symbolic execution graph 
processing call blanks locations mutated called leaves unchanged 
processing lookup node attempts lookup incoming symbolic store 
lookup successful lookup node replaced remains 
internal node processed single external call processed 
incoming store approximated symbolic store call loop dependent locations lookups symbolically executed eliminated 
example vdg example pass replaces lookups internal direct pointers inputs procedure 
input arity raising lookups eliminated bodies passing desired values directly addition passing store parameter 
profitable releases caller obligation update store call 
node takes store argument produces store result internal nodes arguments results 
store argument coarse locations contents demanded changed modified loop dependent locations need arguments 
invocations sequentialized inhibits transformations especially code motion 
aliased variables requirement reorder output similar constraints may introduce dependences force sequentialization 
arity raising store argument changes contract calls 
lookup nodes operate incoming store replaced arranging calls provide values arguments executing lookup prior calling example arity raising lookup internal example replaced new formal parameter 
store parameter node eliminated dead code removal transformation accessed internal aggressive input arity raiser fixed point algorithm find constant values 
may cheaper discover additional constants input arity raising pass 
output arity raising just internal input arity increased output arity increased 
originally returns store 
external lookup operations retrieve values store 
move lookup operations having return value lookup additional return value original lookup 
example transformation applied epr lookup call internal causing value returned internal 
store return node eliminated dead code removal transformation dead calls consumers store result ports 
dead update elimination due arity raising symbolically evaluated lookups dead update operations stores 
dead update elimination removes extraneous operations 
bottom traversal determines store mutating site update nodes calls locations contents demanded may affect computation final value store mutator 
called live variable analysis 
locations changed operation demanded rest computation operation deleted consumers changed accept store input store mutator 
direct methods transforming vdg particular determining values demanded modified loops 
sparse representations dependence flow graphs jp ssa form constructed directly cfg 
collect pass variables modified loop 
actively extending system handle data structures pointers requires uniform incremental method determining locations modified loop 
incremental transformations vdg models data dependences explicitly transformations occur classical problem data flow control flow information getting sync need global analysis put back sync 
example consider selector deletion occurs static analysis determines value predicate selector fl node 
fl nodes predicate epr cse lp inv lp inv call call vdg example vdg transformations section 
dotted lines separate regions equivalent demand dependence store values 
directly connecting outputs relevant inputs transitively rebuilding successor nodes necessary performs common subexpression elimination constant folding 
safely ignore issue variable defined deleted selector definition allowed pass deleted selector dataflow ramifications directly accounted vdg 
nodes demand dependent solely predicate negation whichever false garbage collected need employ separate dead code elimination pass 
local changes propagate scan determines enclosing formals may removed return values longer computed relevant calls updated local transformations proceeding outward 
effect achieved pdg methods fow section higher cost conceptual complexity overhead analysis passes 
region root region true false true demand dependence graph constructed vdg example 
code generation generating code vdg done stages 
stage transforms vdg program dependence graph 
standard pdg fow consists data dependence graph control dependence graph cdg 
vdg operand arcs provide data dependences cdg replaced demand dependence graph 
second stage transforms cfg code may generated directly 
stage described ste extends earlier pdgs sf 
demand dependence vdg node characterized fl nodes encountered paths return node control dependence cfg node characterized branch nodes encountered paths entry node 
path return node vdg node yields sequence fl selector ports corresponding sequence selector predicate values required order node demanded path 
loosely node demand dependent fl node dominates vdg arm true false 
space prevents giving formal definitions demand dependence vdg dominance 
example final vdg nodes demand dependence recursive call node demand dependence cse 
node demand dependence cse remaining nodes demanded 
shows demand dependence graph example 
viewed predicates demand dependence vdg contains names really refer result port node particular expression 
computation implies control dependence original cfg computation may computed program may occur program point doesn post dominate computation 
example control demand dependences expression example differ 
control dependence vacuous execute demand dependence 
corresponding code motion arm conditional called revival transformation 
enables code motion transformations representations control dependences 
motion loops occurs automatically reflects computation location original program 
data dependences enforce total ordering code generator free reorder computations conditional constructs 
example system performs strict code motion 
particular system move assignments clause movable statement right side resulting clear improvement code 
extend results ways redundancy detection find structural common subexpressions common algorithm finds statements moved method don values iterations method handles problem case 
elimination partial redundancies computation partially redundant program point path point performed computation redundant path path program point computation performed 
example second 
operation example partially redundant 
show remove partially redundant computations program transformation 
consider operation node operands fl node 
operation distributed fl node changing vdg semantics constructing new operation nodes 
transformation equivalent converting op op op transformation rule 
contribution program representation allows simple transformation basis efficient epr 
assume expressions due loop carried dependences semantic issues volatile variables op op op distributing operation fl node 
distribution fls duplicates code increases size program number operations performed runtime 
removes redundant computations profitable new operation nodes matches operator operands node subsumes applications transform match node 
node subsumes node iff demand dependence implies demand dependence demanded 
words subsumes computation available available computation epr algorithm performs profitable transformations searching subsumed match candidate node fl tree input 
inputs fl nodes predicate minor bookkeeping ensures possible program paths considered search transformation 
assume hashing matching nodes determining predicate encountered value constant time operation subsumption relation verified time linear depth demand dependence graph 
gtree denote size fl tree rooted node candidate node fl tree input processed worst case time delta gtree equivalent quadratic size procedure optimized 
node inputs fl trees time worse cubic 
empirical results cfr indicate practice gtree contains elements implies practice depth demand dependence graph small bound 
epr method employs partial ordering computation expressed simpler methods employ total orderings expressed cfg 
example compared pure cfg methods krs ds requires availability global partial analysis expression basic block basic block code motion 
cfg epr methods perform re code motion 
simpler ssa method cfg graph conditioning adding landing pads assignment ranks orders mct tables related research graph structure direct descendant graph structure fuse partial evaluator wei 
graph structure designed reasoning transforming strict functional programs 
accommodation imperative programs explicit presence store datatype usually implicit machine quantities operations stores 
transformational engine extension fuse fuse specializer constant folding function specialization 
graphs reason imperative programs unstructured control translation source graph form complex fuse 
pdg compilers simplify transformations eliminating cfg cost needing reconstruct cfg produce serial code fm fms saf sf ste 
underlying representation statement oriented control dependences attached statements pdg approach enable analysis transformation simplifications vdg eliminates cfg attaches demand dependences expressions 
program dependence graph pdg fow consists control dependence graph cdg data dependence graph 
cdg novel contribution ties elements program execute control conditions 
provide information enables simplifies transformations code motion 
theta graph cli cli pdg program ssa form cfr 
theta graph built directly cfg need inlining step vdg construction 
click suggests removing control information program representation occurs theta graph probably similar vdg 
dependence flow graph dfg jp extension standard ssa form addition oe nodes inserted merge points switch nodes inserted branch points 
switches merge points backwards program execution dfg easy perform backwards forwards analyses 
mit dataflow graphs differ including tokens control needing represent machine state stores 
suggests dataflow intermediate representation shares goals concerns 
uses tokens represent control keeps explicit control program representation 
authors abandoned dataflow model investigating jp 
gated single assignment gsa component program dependence web bmo similar vdg transformation hindered need keep different representations sync fails handle irreducible programs 
thinned gated single assignment form hav similar representation 
major difference vdg form represent looping procedure call return form represents looping special nodes 
fie presents framework reasoning partially evaluating programs graphical form idea guarded expression 
rewrite rules similar vdg transformations similar techniques extract values stores converting lookup operations values return 
similar cf discusses semantics program dependence graph pdg considered executable dataflow program 
sparse evaluation graphs ccf program representation efficient solution dataflow problems 
dataflow problem program converted sparse evaluation graph data structure analysis 
translated similar data structure removing nodes function identity function removing fl nodes true false inputs identical eliminating internal call parameters longer represent loop dependences 
advantage constructing sparse evaluation graphs presence fl nodes allow conditional analyses conditional constant propagation 
expect vdg representation simplify pointer alias analysis 
approximate locations pointer may refer explicitly modeling locations operation allocates 
mini stores represent portions global store aliased locations aliasing may occur order minimize false dependences maximize parallelism 
eliminate names values may bound locations names really denote 
system give expressions global value number expressions differing demand dependences 
occurs may program point value computed unnecessarily increasing register pressure 
system forced duplicate computation worse original program computation appeared multiply 
help system decide computation multiple uses appeared duplicated original program plan keep track control dependences expression combine global value numbering merges computations 
anticipate construct control dependences fly symbolic execution store propagation 
fl nodes predicate produced statement program different statements boolean value predicate 
consider case come statement 
share demand dependence code generator produces branch operation 
different demand dependences code generator may decide place different parts program require saving test value replicating statement program 
doing may may improve program 
need address issue back 
representation raises issues code generator 
example computation demanded sites program different demand dependences may duplicated reduce register pressure 
similarly fl nodes similar predicates dissimilar demand dependences force precompute vs register pressure vs code size engineering tradeoff 
issues trivial belong back 
program slicing wei ven determines elements program affect affected computation 
analysis useful debugging distributing computations processors 
vdg particularly convenient representation slicing sparse operands connected directly inputs computation expressed value flow vdg effectively representation slice computation program simultaneously 
authors noticed efficacy pdg slicing hrb addressed problems irreducible control flow bh 
algorithms equally precise best simpler state efficient ern 
vdg represents value flow able slice values particular program points notion sense vdg framework 
appear serious limitation 
acknowledgments ellen spertus erik ruf cliff click todd knoblock referees helpful comments 
arvind nikhil 
executing program mit tagged token dataflow architecture 
ieee transactions computers march 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
computer science series 
addison wesley reading massachusetts 
bowen alpern mark wegman kenneth zadeck 
detecting equality variables programs 
proceedings fifteenth annual acm symposium principles programming languages pages 
acm press january 
preston briggs keith cooper linda torczon 

proceedings sigplan conference programming language design implementation pages 
acm press june 
bh thomas ball susan horwitz 
slicing programs arbitrary control flow 
technical report university wisconsin madison december 
beck richard johnson keshav pingali 
control flow dataflow 
journal parallel distributed computing 
bmo robert arthur maccabe karl ottenstein 
program dependence web representation supporting control data demand driven interpretation imperative languages 
proceedings sigplan conference programming language design implementation pages 
acm press june 
br david bernstein michael rodeh 
global instruction scheduling superscalar machines 
proceedings sigplan conference programming language design implementation pages june 
ccf jong deok choi ron cytron jeanne ferrante 
automatic construction sparse data flow evaluation graphs 
procedings eighteenth annual acm symposium principles programming languages pages 
acm press january 
cf robert cartwright matthias felleisen 
semantics program dependence 
proceedings sigplan conference programming language design implementation pages portland june 
cfr ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficient method computing static single assignment form 
proceedings sixteenth annual acm symposium principles programming languages pages 
acm press january 
philip campbell krishna robert 
refining defining program dependence web 
technical report cs university new mexico albuquerque march 
cli cliff click 
combining analyses combining optimizations 
phd thesis proposal april 
cli cliff click 
quads graphs intermediate representation journey 
submitted publication october 
ron cytron andy lowry kenneth zadeck 
code motion control structures high level languages 
proceedings thirteenth annual acm symposium principles programming languages pages january 
coc john cocke 
global common subexpression elimination 
sigplan notices july 
cs john cocke jacob schwartz 
programming languages compilers 
technical report courant institute nyu april 
preliminary notes 
dhamdhere 
practical adaptation global optimization algorithm morel renvoise 
acm transactions programming languages systems april 
barry rosen kenneth zadeck 
analyze large programs efficiently 
proceedings sigplan conference programming language design implementation pages san francisco california june 
acm press 
ds karl heinz drechsler manfred 
variation knoop steffen lazy code motion 
acm sigplan notices may 
ern michael ernst 
program slicing value dependence graph 
preparation 
fie john field 
simple rewriting semantics realistic imperative programs application program analysis preliminary report 
proc 
acm sigplan workshop partial evaluation semantics program manipulation pages san francisco june 
published yale university technical report yaleu dcs rr 
lawrence david robert xing xue 
revival transformation 
proceedings annual acm sigplan sigact symposium principles programming languages portland january 
fm jeanne ferrante mary mace 
linearizing parallel code 
proceedings twelfth annual acm symposium principles programming languages pages january 
fms jeanne ferrante mary mace barbara simons 
generating sequential code parallel code 
proceedings international conference supercomputing pages june 
fow jeanne ferrante karl ottenstein joe warren 
program dependence graph optimization 
acm transactions programming languages systems july 
har dov harel 
linear time algorithm finding dominators flow graphs related problems 
proceedings seventeenth acm symposium theory computing pages may 
hav paul havlak 
construction thinned gated form 
draft private distribution february 
hrb susan horwitz thomas reps david binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems january 
jp richard johnson keshav pingali 
dependence program analysis 
proceedings sigplan conference programming language design implementation pages albuquerque nm june 
acm press 
richard johnson david pearson keshav pingali 
finding regions fast single entry single exit control regions linear time 
technical report ctc tr cornell university july 
krs jens knoop oliver bernhard steffen 
lazy code motion 
proceedings sigplan conference programming language design implementation pages san francisco california june 
acm press 
etienne morel claude renvoise 
global optimization suppression partial redundancies 
communications acm february 
ott karl joseph ottenstein 
data flow graphs intermediate program form 
phd thesis purdue university august 
keshav pingali beck richard johnson paul 
dependence flow graphs algebraic approach program dependencies 
technical report department computer science cornell university ithaca ny september 
barry rosen mark wegman kenneth zadeck 
global value numbers redundant computations 
proceedings fifteenth annual acm symposium principles programming languages pages 
acm press january 
saf barbara simons david alpern jeanne ferrante 
foundation parallel code extended 
proceedings nd acm symposium parallel algorithms architectures pages 
sf barbara simons jeanne ferrante 
efficient algorithm constructing control flow graph parallel code 
technical report tr ibm santa teresa laboratory san jose california february 
standish neighbors 
irvine program transformation catalogue 
technical report university california irvine department information computer science january 
ste bjarne steensgaard 
program dependence graphs irreducible programs 
technical report microsoft research redmond wa august 
ste bjarne steensgaard 
store algebra graphical program representations 
preparation november 
ven venkatesh 
semantic approach program slicing 
proceedings sigplan conference programming language design implementation pages toronto ontario canada june 
daniel weise roland erik ruf scott seligman 
automatic online partial evaluation 
hughes editor functional programming languages computer architecture number lecture notes computer science pages cambridge ma august 
acm springer verlag 
wei mark weiser 
program slicing 
ieee transactions software engineering se july 
wei daniel weise 
graphs intermediate representation partial evaluation 
technical report csl tr stanford computer systems laboratory stanford ca march 
wz mark wegman frank kenneth zadeck 
constant propagation condition branches 
proceedings twelfth annual acm symposium principles programming languages pages january 
wz mark wegman kenneth zadeck 
constant propagation conditional branches 
technical report cs ibm watson research center yorktown heights ny may 

