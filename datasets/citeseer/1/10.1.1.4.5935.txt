languages tim sheard ogi school science engineering oregon health science university sheard cse ogi edu explores new point design space formal reasoning systems part programming language part logical framework 
system built programming language user expresses equality constraints types type checker enforces constraints 
simple extension type system allows programmer describe properties program types witness objects thought concrete evidence program property desired 
techniques rich typing mechanisms rank polymorphism extensible kinds create powerful new programming idiom writing programs types enforce semantic properties 
language features practical programming language logic 
marriage previously separate entities increases probability users apply formal methods programming designs 
kind synthesis creates foundations languages 
huge semantic gap programmer knows program way express knowledge system reasoning program 
reasoning tools built curry howard isomorphism hard programmers conceptualize put abstraction 
propose design language important isomorphism concrete proofs real objects programmers build manipulate leaving programming language 
proofs express important semantic properties programs 
believe increases orders magnitude probability programmers construct programs reason measurable differences quality code produced 
supported nsf ccr 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october vancouver 
copyright acm programmers reason programs find barriers entry high 
semantic gap formal tools implementation languages prevents application formal methods software design important applications 
build systems trust large scale develop programming languages narrow semantic gap 
programming languages properties 
allow programmers describe reason semantic properties programs programming language mainly powerful type systems 
languages designed interoperate external reasoning testing systems 
languages reach majority programmers 
reasoning capability language time consuming learning curve learning features high 
practical supporting capabilities expect programming language 
may organize capabilities new ways better control potentially unsafe features 
static analyses separate powerful risky features rest program clearly mark boundaries 
spell obligations required control risk support track obligations met 
efficiently implementable new novel ways 
relying strict compiletime run time distinction perform single optimization provide flexible hierarchy stages programming language 
staging deal uniformly notions compile time link time run time run time code generation 
allow computation system take advantage important contextual information matter available 
staging separation track semantic properties stages 
possible know stage program builds stage program known property explore new point design space formal reasoning systems development language wmega 
wmega practical programming language logic 
irreconcilable goals possible embedding wmega logic type system equality qualified types 
design supports construction maintenance propagation semantic properties programs powerful old ideas types novel new ways 
theorem provers logical frameworks goals believe qualitative differences 
wmega practical programming language 
supports practical programming features input output side effects uses type system cleanly separate potentially dangerous features core language logic 
second wmega uses single computational model logic programming 
uses strict functional model monads separate effects computation 
model suffices describe programs properties 
contrast logical frameworks programs purely functional logic employs prolog style back chaining elf higher order pattern matching twelf 
similar dichotomy arises lcf style theorem provers coq 
systems programs extracted proofs constructed highly unnatural ways tactics proof combinators 
believe model paradigm unnatural single model wmega easier learn ordinary programmers 
discuss detail section 
third wmega incorporates powerful extension mechanisms 
coq related systems proofs correspond programs 
wmega proofs programs equality qualified types 
efficient implementations extracted proofs form type erasure 
coq isabelle type erasure fixed inflexible type erasure wmega implemented explicit staging 
conjunction staging logical systems provides powerful new tool 
staging extraction efficient programs proofs control programmer targeted 
staging perform specialization partial evaluation 
second extension mechanism wmega ability reflect representations types value world perform arbitrary computations representations type safe manner 
logic wmega embedded type system sound reflection mechanism supports extension wmega logic deal wide variety properties logical semantic physical resource usage 
wmega design heavily influenced set advances programming language community 
ability combine type inference type checking arbitrary rank semantics staged computation systems simplified form dependent typing called indexed types combined create powerful new way embed properties programs types :10.1.1.19.8322:10.1.1.41.548
wmega clearly descended functional programming languages syntax type system similar haskell approach combining reasoning programming single system interest programmers 
wmega opens intriguing possibilities design exploration implementation programs semantic properties 
believe exploring point design space programming languages reasoning systems important step direction programming languages 
types capture properties important role type systems programming languages guarantee property programs data including functions inappropriate ways 
types ensure sophisticated properties 
types ensure safety low level code java byte code typed assembly language :10.1.1.24.6526
systems types model shape stack register bank ensure low level code sequences properly stack underflow 
types model information flow ensure security properties systems :10.1.1.10.3979
types track resource control possibility non termination place upper bounds time consumed computation 
types means removing dynamic error tests example enforce data structure invariants ensuring red black trees formed code efficient removing unnecessary run time array bounds checks 
types track access control allows removing minimizing stack inspection overhead means managing capabilities 
far author tell literature systems built general purpose programming language 
properties systems modelled formal system logical framework theorem prover coq isabelle twelf properties metalogical property program external implementation 
wmega property implementation enforced programming language 
model existing application formal system formal system build model unimplemented application derive generate implementation model implement reason single paradigm wmega 
formal reasoning systems designed programming languages 
tools expressive 
trade expressiveness 
gained selective choosing features wisely maintaining pragmatic properties system 
powerful tools useful place system design missing point continuum tools practical formal wmega designed fill gap 
doing wisely gained terms ease gradual learning curve increased interoperability systems 
coined new slogan process designing reliable systems types just little theorem proving 
argue properties modeled theorem prover logical framework modelled straightforwardly programming language type system strengthened just simple ways 
allows properties systems modelled light weight manner completely formal 
adding rank polymorphism equality qualified types extensible kinds staging support light weight formality possible 
programmers familiar theorem prover logical framework find powerful ideas tools moved practical programming language widely applicable 
save power frustration theorem prover really need 
wmega section introduce wmega 
simple application semantic invariant captured type system wmega 
example sequences elements semantic property length sequence encoded type 
example sequence type seq type cons operator adds element front sequence kind nat nat data sum base exists step sum data seq nil exists cons seq app sum seq seq seq app base nil ys ys app step cons xs ys cons app xs ys 
wmega encoding lists types record lengths 
value type kind int nat nat succ nat nat seq nat sum nat nat nat nil seq cons seq seq sn base sum step sum sum sm 
classification values nil cons base step types succ sum seq kinds nat defined seq seq 
type append operator seq seq seq 
order type functions necessary arithmetic type level 
wmega program captures 
code introduces new types sum seq new function app new kind nat 
new kind nat introduces new type constructors encode natural numbers type level 
kinds similar types types classify values kinds classify types 
indicate classifies relation 
example int say classified int int classified star zero 
kind classifies types classify values things compute 
classified write shorthand 
infinite hierarchy classifications 
call hierarchy strata 
fact infinite hierarchy chose name wmega 
strata values expressions classified types types classified kinds kinds classified sorts illustrate relationship values types kinds introduced 
constructor functions nil cons base step construct elements data types 
type constructor function described data declaration 
example clause seq declaration exists cons seq introduces cons constructor function 
qualification constructor function cons type cons seq seq 
equality qualification indicated clauses nil cons base step existential quantification indicated exists clauses cons step help encode semantic properties 
qualifies cons type effect saying cons seq seq provided capture formally writing cons forall seq seq 
equations fat arrow equality qualifications 
universally quantified type variable way solve qualification making equal 
unique solution cons type forall seq seq 
type guarantees cons applied contexts existential quantification type variable names intermediate length sublist cons introduced way appear unbound type variable 
equality constrained types relatively new feature world programming languages introduced hinze cheney 
mechanism model relations types equality defining witness types 
witness value constructed constructor functions base step data definition sum 
type value encodes property 
existence witness non bottom value type implies property true 
witnesses untrue properties constructed values ill typed 
value type sum witnesses ternary arithmetic relation wmega types enforce property length appending lists sum length lists appended app sum seq seq seq 
argument app witness crucial property 
consider clause defining append function app base nil ys ys typed 
know app type argument base type sum second argument nil type seq third argument ys type seq 
right hand side equation type seq 
right hand side second argument clause appears ill typed 
short write base sum nil seq ys seq ys seq key type checking clause recognize constructor functions nil base equality qualified types 
particular constructed case nil base 
complete typing judgment base sum nil seq ys seq ys seq easily shown true 
propagation solving equality qualifications handled compiler type checker 
user simply required introduce equalities clause data definitions stating type function giving type signature app sum seq seq seq compiler rest 
type signature supplied compiler attempt infer hindley milner polymorphic type function 
hindley milner inference app fail uses polymorphic recursion 
important thing note wmega uses combination type inference type checking 
presence type signatures indicates function type checked 
believe supplying type signatures functions overly burdensome 
types encode properties object language user ought know type functions corresponds properties trying model 
function type checks user proof program property described equalities types 
inductive nat set nat nat nat 
definition plus nat nat nat fix plus plus nat nat nat nat cases plus 
inductive seq set nat set nil seq cons nat xs seq seq 
definition app set nat seq seq seq plus 
intros 
induction 
simpl 
apply cons plus 
defined 
coq encoding elem type 
elem 
nat type 
nat 
nat nat 
plus nat nat nat type 
base plus step plus seq nat type 
nil seq 
cons elem seq seq 
app plus seq seq seq type 
app app base nil app app step cons xs ys cons zs twelf encoding 
coq twelf programs comparison wmega 
comparison formal reasoning systems 
coq twelf encodings see similar encoding natural numbers type level encoding sequences encoded lengths 
coq definition plus defined structural induction nat types definition append series commands simpl guide coq theorem prover construct proof object type 
append function extracted shown proof object 
twelf encoding plus function append function encoded logic programs 
big advantage wmega approach program logic 
translation programming notation external reasoning tool 
second need switch gears reasoning system 
thinking terms implementation programming language coq think terms proof tactics twelf vast majority programs written prolog think terms logic programs 
fair point caveats arguments address 
wmega implement sum witness logical style 
style closer twelf logical style coq functional style wmega appears think logically functionally type level 
consequence mechanism solve equality constraints 
second probably sense familiar coq defined append set proposition defined induction wmega 
done longer extract efficient program definition 
combining programming language logic believe address issues 
section discuss extracting efficient programs 
removing relational bias type level scope short note 
example type safe language turn richer example modelling simple imperative language semantic properties static scoping type safety 
program represented wmega data structure proof variable program refers binding site static scoping program typed 
power wmega modelling static semantic properties requires approximately amount time intellectual effort uses model context free syntactic properties means 
addition wmega program manipulates program data structure guaranteed maintain properties 
wmega programs maintain scoping typing statically determined ill typed rejected 
introduce data structures represent language 
data declarations introduce new parameterized types exp com variables expressions commands 
type constructors actual element new types types int bool bool exp int bool int com int bool 
interpret exp expression type store type store captures types variables currently scope 
similar interpretation variables 
commands don result types interpreted store com 
declarations introduce constructor functions intc types comments 
readers familiar type systems notice types constructor functions look lot typing judgments 
equality constrained types encode reason inference rules programming language 
observation type parameters wmega type constructors 
parameters type constructors play qualitatively different role type parameters data structures 
consider declaration binary tree datatype data tree tip fork tree tree 
declaration type parameter indicate sub components trees type fact trees polymorphic 
type value placed sub component type type value placed reflected tree type 
contrast com 
sub components type parameter stand property types statically reachable qualifications restrict legal instances type parameters way called index types :10.1.1.41.548
manipulating programs 
small interpreter language 
expressions interpreted function eval exp function eval term type exp producers function eval gives meaning term 
store data structure stores values expression variables produce data exists exists xn data exp intc int int int exp int bool bool true bool exp bool plus exp int exp int int exp int exp int exp int exp int exp int bool exp int exp bool var exp data com exists set exp exp com seq com com com com com exp bool com com exp bool com com com exp bool com exp bool com com exists declare exp com int exp com com 
typed statically scoped syntax language 
left hand column illustrates wmega code introduces data structures represent new object language middle column comment token suggests concrete syntax syntax represents 
right hand column gives type constructor function described text 
value expression applying eval expression store 
type store models types reachable variables object program 
variables integers de bruijn notation stores nested pairs 
nested pairs shape indicate index variable reaches corresponding location nested pair 
natural number definition type see var models variable index var models variable index var models variable index type store int bool variable index type int variable index type bool 
interpretation easy understand functions update eval exec 
consider update false true 
return new nested pair location index replaced false giving false 
proceeds update false true update false true false 
note pattern matching chooses correct clause execute 
similar fashion eval function applied variable var extracts th value nested pair 
eval var true eval var true true 
execution function commands exec com store transformer transforming store assignments executed command 
properties object programs captured types respecting types ensures meta programs maintain properties object programs 
example meta level variables sum defined sum variable index variable index observe prog com int int prog seq set sum int seq set int var int seq set sum plus var sum var set plus var int sum sum sum term prog meta level type states typed object level object level store int indexes 
tries create ill typed object level term static type checking error occurs 
example consider command variable needs typed int bool 
var set intc set intc expression set intc result type com int expected com bool int unify bool possible enhancements 
enhancing object languages type safety accomplished dimensions richer language richer type system 
done 
modelled different styles language semantics big step style language 
interesting semantics consisted typed small step semantics 
small step semantics typed amounts machine checked subject reduction proof 
staging supports efficient implementations staged programs proceed stages 
stage writes program executed stage 
practical examples staged systems include run time code generation dynamic compilation program generators 
staging key technology supports efficient implementations interpretive overhead 
staging programming language interface code generation 
built large sophisticated systems implement staging 
metaml system run time code generation template haskell system compile time code generation think macros quasi quotes type safety 
staging mechanism wmega 
consists annotations brackets escape 
brackets introduce new code template specify expression inside brackets generated program stage 
brackets escape specifies hole template 
escaped expression executed resulting piece code resultant code spliced hole 
staging perfect update update update update eval exp eval intc eval eval plus eval eval eval eval eval var eval var eval var exec com st st st exec set update eval exec seq exec exec exec test eval test exec exec exec test body loop loop eval test loop exec body exec declare body store store exec body eval 
interpreters language 
functions illustrate pattern matching constructor functions semantics preserving meta functions 
update eval exec manipulate programs way respects semantic properties 
fact programs typed interpreters tagless return values types correspond types programs 
typed object code string string annotated ast typed object code marshall internet check code producer code consumer 
proof carrying code process data data int bool vara int equality proofs type representations data eq data intr int bool exists match eq match intr intr succeed match succeed match succeed match fail match fails judgments types data exists tj tj intr tj case tj tj tj judgments expressions data exists ej exp sr succeed ej intr intc sr succeed ej sr ej ej succeed ej intr plus vara ty tj succeed ej var vara ty ej var tj succeed ej var 
implementing check function proof carrying code example 
plus var var plus var intc data store code forall code store test eval eval exp store code eval intc lift eval lift eval plus eval eval eval eval eval var eval var eval var test app sum code seq code seq code seq app base xs ys ys app step xs ys case xs cons zs cons app zs ys test sum code seq seq seq test witness xs ys app witness xs ys test step step base xs ys case xs cons zs cons case zs cons ws cons ys 
illustrating staging removal interpretive overhead top witness removal bottom 
ment equality qualified types reasons 
applications encoded domain specific languages dsls 
languages meaning writing simple interpreter eval exec functions 
staging interpreters produces efficient compiler interpretive overhead traversing syntax removed 
illustrated top exp fragment language 
second staging implement program extraction proofs 
coq extent isabelle support program extraction proofs 
features limited target languages hardwired generated programs conform type system target language 
requires discarding important information source program run time passing static information 
consider app function proof takes witness sum type lists staging remove witness early stage resulting new piece code rely static information encoded witness 
note witness step step base staged function app unroll loop 
witness removed second stage resulting program longer recursive 
ability control extraction important 
different programs extracted proof object may different physical properties heap space usage 
staging allows users extract programs manner fits needs 
example proof carrying code peter lee web site states proof carrying code pcc technique code consumer host verify code provided untrusted code producer adheres predefined set safety rules 
key idea proof carrying code code producer required create formal safety proof attests fact code respects defined safety policy 
code consumer able simple fast proof validator check certainty proof valid foreign code safe execute 
illustrate implemented wmega 
code producer produces code safety policy embedded type object code illustrated previous section 
producer pretty prints code flat untyped representation transported internet string 
consumer side consumer parses string untyped annotated syntax tree 
check dynamic run time attempt reconstruct typed object code static property annotated untyped ast 
succeeds consumer proof object code desired safety property typed object programs safety property 
difficult step process reconstruction typed untyped annotated ast 
order describe done introduce additional features wmega polymorphic kinds representation types 
apply features dynamic construction statically typed exp datatype program example 
define untyped algebraic datatypes annotated syntax types 
type representation type 
reflects objects live type world int bool pairs value world 
note intr int value type completely distinguishes value notion called singleton types think representation types appropriate name 
writing program manipulates representation types allows programmer encode operations type system limited computation mechanism essentially solving equalities types 
emphasized important ability typing problems solved type system programmed user necessary 
choose represent int bool pairs types appear type indexes exp com describe shape store nested pair 
key dynamic reconstruction static type information eq data type 
eq type constructor polymorphic kind eq forall 
kind means arguments eq range types classified classified 
includes types int bool type constructors tree list 
constructor function forall eq class dynamic witness fact static types equal 
equality witnesses created static context equal passed data new context information needed 
way create witnesses function match forall eq 
function match dynamically tests representation types equal 
return boolean value returns successful equality witness returns failure 
witness pattern matching context guard expression new piece static information 
example type eq case expression case eq case arm indicated type checked static assumption standard typing rules equality qualified types provide mechanism 
new new way old techniques 
datatypes forms exp existential types hide type indexes type constructor functions 
includes representation type functions match examples partial functions 
succeed producing result ans fail 
wmega indicated result type ans 
programmed notation easy program partial functions comprised sub computations fail 
sequence partial computations 
succeeds succeed 
fails sequence fails 
succeeds structured data object pattern match result successful 
successful object returned doesn match sequence fails 
explain clause definition 
consider sr 
recursively check subterm annotated ast returns judgment encapsulating typed term exp representation type existentially quantified type variable 
test representation matches intr 
succeeds witness eq int pattern matched rest computation proceed static assumption equal int 
similar fashion check test succeed new judgment 
possible enhancements 
believe technique extended full language including com language 
case judgment commands include representations stores way judgment expressions contained representations types 
techniques infer typed object code terms untyped syntax trees annotations details complicated 
reflection type world value world powerful idea 
lets user construct objects static properties static type system may able infer limited computational mechanism 
example language temporal safety properties systems depend communication occurring temporal protocol 
example file opened written 
opened file shouldn opened closed 
closed file written 
protocols naturally expressed finite state automata 
dfa captures protocol precisely 
language express enforce protocols quite naturally type system 
illustrate augmented language commands opening closing writing single file discuss removing restriction 
kind state open closed prog com int int open open prog seq set sum int seq set int var int seq set sum plus var sum var seq var set plus var int data com st forall set st exp st forall seq com st com st exp st bool com st com st exp st bool com st forall declare exp st com st closed open open closed exp st int open open closed open open close write 
language augmented commands manipulating file dfa protocol 
defined new kind state types open closed augmented command data structure new constructor functions 
com type takes additional type parameters 
interpret type com st command store st starting execution state state types new constructors enforce protocol com st closed open com st open closed exp st int com st open open 
type command prog describes precisely states protocol command resides 
commands polymorphic starting states essentially carry proof io 
possible enhancements 
easy imagine richer protocols dfa states 
accommodating protocols simply requires enriching state kind adding new commands transition 
host language notion typed procedures isn necessary add new constructor functions com transition dfa 
languages multiple protocols file accommodated specifying starting state parameters com structured types component 
example language multi level security example concerns language multi level security domains 
multi level security language meant ensure confidentiality information stored higher levels security hierar domain kind domain high low high low domain domain data lo low lo low hi high hi high data lh low high ll low low hh high high data data forall forall eval exp exec com st st st exp domain data exp int int int bool bool bool plus exp int exp int int exp int exp int bool forall var com domain data com st forall set st exp st seq com st com st exp st bool com st com st exp st bool com st forall declare exp st com st update update update update 
security domains chy 
language data partitioned security domains example level domain levels high low 
key semantic property insure value data higher levels influences value data lower levels 
tricky control flow decisions predicated high security information cause information leak lower levels 
example problem high int low int reason confidentiality need object language reason information flow 
define language similar languages literature 
kind declaration introduces new kind domain new types high low 
data declaration introduces new type constructor interesting kind domain 
data declarations introduces new values hi lo 
type reflects structure kind domain value world type hi lo indexed types high low represent lo low hi high 
security language closely related language 
main difference domains 
necessitates change way type stores 
language type store nested tuple encoding types variables scope 
security language types variables encode domain variable 
role type constructor think special kind pair 
language command typed com int bool typed com high low int bool security language 
type parameter exp com describing stores pair 
second component pair exactly component pair parallel structure nesting shape second storing representations domain variables types 
interpretation command type com command store executing control thread domain similar interpretation applies expressions types exp expression returns value type security language enforced witnesses var set constructors 
consider var exp variable expression formed domain variable thread execution 
information flow low variables high threads way 
assignments constructor function set exp com 
thread expression assigned domain variable assigned 
assign high variables expressions low threads assign low variables 
addition thread assignment command thread variable 
prevents problem illustrated control flow predicated high information leak information low variables 
semantics language similar eval exec commands language easy state prove type system prevents adverse information flow 
proof cast separation argument 
typed command com ds st meaning exec st st function stores stores values low variables output store depend values high variables input store 
related expressing types equal manner controllable programmer key embedding semantic properties object programs 
expressing equality types programming language idea leibniz equality build explicit witness type equality 
wmega write data eq witness forall 
logical intuition definition types equal interchangeable context arbitrary type constructor 
note relies heavily higher rank polymorphism 
germ idea originally appeared developed years 
programming witnesses requires building explicit casting functions different contexts type tedious error prone 
programming witnesses problems solution known type equality practical equality qualified types hinze cheney 
implementation wmega key idea 
know type system built top equality constrained types sound 
kinds classify types long history 
adding extensible kinds higher classifications practical programming language wmega natural step 
duggan kinds dynamic typing manner reminiscent new kinds tied types 
explored new point design space formal reasoning systems 
choice closer world programming languages reasoning systems 
see positive benefit conjecture programming languages built similar lines 
logic system embedded type system 
semantic properties programs expressed meta logical level necessarily external world programmer expressed programming language 
system supports reflective mechanism enables intensional analysis reflected types allows programmers write tactic level proof scripts value level reflections 
tactics reflected back type system sound manner 
staging build efficient implementations exploiting contextual invariants extract efficient programs proof objects 
conjecture programming language features lead reliable programs 
arthur doaitse swierstra 
typing dynamic typing 
proceedings seventh acm sigplan international conference functional programming pages 
acm press new york september 
appears acm sigplan notices 
barendregt 
lambda calculi types 
samson editors hand witness type eq known construct witness type eq eq 
possible straightforward consequence congruence 
book logic computer science 
oxford university press oxford 
bertelsen 
semantics java byte code 
technical report dep 
information technology technical university denmark march 
ric thomas de de latour thomas jensen 
secure calling contexts stack inspection 
proceedings fourth acm sigplan conference principles practice declarative programming ppdp pages new york october 
acm press 
cristiano eugenio moggi tim sheard 
closed types safe imperative metaml 
journal functional programming may 
chen hongwei xi 
meta programming typeful code representation 
proceedings th acm sigplan international conference functional programming icfp acm sigplan notices pages new york august 
acm press 
james cheney ralf hinze 
phantom types 
available www informatik uni bonn de ralf publications phantom pdf 
karl crary stephanie weirich 
resource bound certification 
proceedings th acm symposium principles programming languages pages january 
acm press 
dominic duggan 
dynamic typing distributed programming polymorphic languages 
acm transactions programming languages systems january 
ralf hinze james cheney 
lightweight implementation generics dynamics 
manuel chakravarty editor proceedings acm sigplan haskell workshop pages 
acm sigplan october 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
proceedings conference functional programming languages computer architecture copenhagen denmark june 
simon peyton jones mark shields 
practical type inference arbitrary rank types 
technical report microsoft research december 
research microsoft com users simonpj papers putting index htm 
launchbury paterson 
parametricity unboxing types 
lecture notes computer science 
didier le didier remy 
ml raising ml power system acm sigplan notices september 
peter lee 
proof carrying code 
available www cs cmu edu papers pcc pcc html 
morrisett walker crary glew 
system typed assembly language 
acm transactions programming languages systems toplas may 
greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
talx realistic typed assembly language 
acm sigplan workshop compiler support system software 
palsberg 
trust calculus 
journal functional programming november 
emir walid taha tim sheard 
tagless staged interpreters typed languages 
proceedings seventh acm sigplan international conference functional programming icfp pages pittsburgh pa october 
acm press 
lawrence paulson 
isabelle theorem provers 
odifreddi editor logic computer science pages 
academic press 
emir tim sheard walid taha 
dali untyped cbv functional language supporting order datatypes binders technical development 
technical report cse ogi 
available www cse ogi edu 
frank pfenning carsten 
system description twelf meta logical framework deductive systems 
harald ganzinger editor proceedings th international conference automated deduction cade volume lnai pages berlin july 
springer verlag 
andrei sabelfeld andrew myers 
language information flow security 
ieee journal selected areas communications january 
zhong shao saha trifonov 
type system certified binaries 
acm sigplan notices january 
sheard 
metaml staged programming language 
lecture notes computer science 
sheard peyton jones 
template meta programming haskell 
proceedings acm sigplan haskell workshop pages 
acm 
vincent simonet 
extension hm bounded existential universal data types 
acm sigplan notices september 
stata abadi 
type system java bytecode subroutines 
th annual acm symposium principles programming languages pages january 
christopher stone robert harper 
deciding type equivalence language singleton kinds 
conference record popl th acm sigplan sigact symposium principles programming languages pages boston massachusetts january 
walid taha 
sound reduction semantics untyped cbn stage computation 
theory metaml nontrivial 
sigplan workshop partial evaluation semantics program manipulation pepm january 
walid taha henning john hughes 
tag elimination jones optimality 
lecture notes computer science 
walid taha tim sheard 
metaml multi stage programming explicit annotations 
theoretical computer science 
coq development team 
coq proof assistant manual version 
inria 
pauillac inria fr coq doc main html 
joseph karl crary 
foundational typed assembly language grid computing 
technical report cmu cs carnegie mellon university 
dennis volpano geoffrey smith cynthia irvine 
sound type system secure flow analysis 
journal computer security december 
philip wadler 
comprehending monads 
proceedings acm symposium lisp functional programming nice france pages june 
philip wadler 
essence functional programming invited talk 
th acm symposium principles programming languages albuquerque new mexico january 
philip wadler 
monads functional programming 
broy editor program design calculi volume nato asi series series computer system sciences 
springer verlag 
proceedings international summer school marktoberdorf directed bauer broy dijkstra gries hoare 
wallach felten 
understanding java stack inspection 
ieee symposium security privacy ssp pages washington brussels tokyo may 
ieee 
stephanie weirich 
type safe cast functional pearl 
acm sigplan notices september 
andrew wright matthias felleisen 
syntactic approach type soundness 
information computation november 
hongwei xi 
dependent types practical programming 
phd thesis carnegie mellon university 
hongwei xi frank pfenning 
eliminating array bound checking dependent types 
acm sigplan notices may 
hongwei xi frank pfenning 
dependent types practical programming 
acm editor popl 
proceedings th acm sigplan sigact principles programming languages january san antonio tx acm sigplan notices pages new york ny usa 
acm press 
