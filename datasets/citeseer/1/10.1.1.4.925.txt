distributed mediation ambiguous context aware environments anind dey jennifer mankoff gregory abowd scott carter intel research berkeley intel berkeley ca anind intel research net context aware services assumption context completely accurate 
reality sensed interpreted context ambiguous 
challenge facing development realistic deployable context aware services ability handle ambiguous context 
describe architecture supports building context aware services assume context ambiguous allows mediation ambiguity mobile users aware environments 
illustrate architecture evaluate example context aware services word predictor system board reminder tool 
keywords context aware computing ambiguity aware environments ubiquitous computing mediation error handling 
characteristic aware sensor rich environment senses reacts context information sensed environment mobile occupants activities providing context aware services facilitate occupants everyday actions 
researchers building tools architectures facilitate creation context aware services providing ways easily acquire represent distribute sensed data 
experience shows sensing cost effective ubiquitous interpretation sensed data context imperfect remain time 
challenge facing development realistic deployable context aware services ability handle imperfect ambiguous context 
presents runtime architecture supports programmers development multi user interactive distributed applications ambiguous data 
researchers aware environments techniques artificial intelligence ai community including bayesian networks neural networks deal imperfect context 
techniques remove ambiguity sensed data leaving aware environment programmer occupants deal 
alleviate problem propose leverage useful ai techniques reducing ambiguity involve users removing remaining ambiguity process called mediation 
submitted uist eecs department uc berkeley berkeley ca cs berkeley edu college computing georgia institute technology atlanta ga abowd cc gatech edu graphical user interface gui design mediation refers dialogue user computer resolves questions user input interpreted presence ambiguity 
common example mediation recognition guis best list 
ambiguity arises recognizer uncertain current interpretation user input defined user intent 
application choose ignore ambiguity just take action act choice mediation techniques ask user actual intent 
ambiguous context aware environment produce errors similar recognition interfaces 
previous architecture development context aware services assumed context unambiguous :10.1.1.9.5130
developed architecture support mediation ambiguity recognition gui interfaces 
build past contribution solve additional architectural requirements justified section arise result requesting highly mobile users mediate ambiguous context distributed interactive sensing environments 
support timely delivery update ambiguous events interactive distributed system storage ambiguous context time delivery ambiguous context multiple applications may may able support mediation pre emption mediation application component applications services requesting application service mediate distributed feedback ambiguity users aware environment 
runtime architecture addresses issues supports goal building realistic context aware applications handle ambiguous data mediation 
overview presenting motivating example illustrate requirements mediation context aware setting 
section brief overviews previous extended 
show combined deal ambiguous context describe additional architectural mechanisms developed requirements unique mediation context distributed setting 
section demonstrates architecture mechanisms support implementation motivating example 
evaluate architecture describing required part programmer modify existing context aware applications support mediation 
complete evaluation describing architecture supports experimenting multiple mediators context motivating example implemented entirely architecture 
conclude related discussion challenges mediating interactions context aware applications 
motivating example developed applications demonstrations architecture 
particular context aware communication system communicator illustrate key points introduce 
communicator designed people motor speech impairments 
people exemplified stephen hawking computers provide way communicate world increase independence freedom 
people severe motor impairments control single switch triggered muscle 
switch scan screen elements keys soft keyboard 
input sort slow enhanced word prediction 
displayed text communication partner vocabularies mediated displayed text progress communicator communicator partner interfaces 
communicator shown word predictor attempts predict word user typing letters typed far 
non speaking individual uses interface shown 
keyboard layout shown chosen optimal efficiency scanning users 
text displayed communication partner top reversed easy readability facing user flat display separate interface 
word predictors inaccurate usually display list possible predictions user scans correct choice avail 
word prediction especially difficult spoken communication speed conversational speech reaches words minute wpm users word prediction rarely go wpm 
goal communicator facilitate conversational speech improved word prediction 
augment word prediction third party intelligent system remembrance agent select conversation topics vocabularies contextual information including words history user previous conversations tagged location time information current time date user current location 
vocabularies help limit set predicted words relevant improve prediction 
example bank words finance money priority similar words 
shown effective predicting urls netscape internet explorer web browsers theory individuals 
goal build application support context aware word prediction non speaking individuals 
unfortunately hard accurately predict topic user conversation vocabulary selection process ambiguous 
experimented mediation strategies ranging simply selecting top choice vocabulary stopping conversation order ask user vocabulary correct 
requirements focus support programmers building realistic context aware applications addressing architectural issues needed support mediation ambiguous input 
issues obvious exist system able capture context deliver interested consumers mediation techniques managing ambiguity 
issues dealt previous 
subsections discuss interesting additional challenges arise mediating ambiguous context supported architecture 
context acquisition mediation common characteristic context aware applications sensors collect data 
communicator location time information help improve word prediction 
user location sensed active badges radar video cameras gps units 
sensors degree ambiguity data sense 
vision system targeted identify locate users color clothing wear produce inaccurate results multiple users wearing color clothing 
ambiguity problem worse applications derive implicit higher level context sensor data 
example application may infer meeting occurring number users moving room time interval 
may explanations phenomenon including random behavior started multiple people arriving desk 
sophisticated bayesian networks ai techniques low high level inferences correct resulting ambiguity 
distribution context aware applications distributed multiple computing devices 
applications system components interested context called subscribers running devices remote components gathering context 
component gathering context may component mediates may interface 
communicator user interface communication partner interface running separate devices 
important minimize number duration network calls interactive distributed system important send information absolutely needed mediation components performing mediation 
storage context aware systems distributed asynchronous sensor data may multiple applications beneficial store data gathered sensors 
communicator takes advantage stored information accessing past conversations match user current location time 
storing context data allows applications running time data collected access historical data 
data ambiguous versions saved making storage requirements prohibitive 
interesting issues address store data ambiguity resolved store ambiguous unambiguous context 
multiple subscription types context aware systems multiple subscribers interested single piece sensed input 
interesting issue allow individual components opt ambiguous context allowing opt 
components may wish deal ambiguity may 
example non interactive components data logging system may way interact users may support mediation 
components communicator interface may wish receive unambiguous data 
manner logging system wish record data certain 
second issue deal allowing components deal ambiguous data requiring perform mediation 
discuss word predictor widget communicator property 
pre emption mediation system multiple completely unrelated components may subscribe ambiguous data source 
communicator interfaces ability mediate ambiguous vocabularies example 
important concern resolve components start mediate data point time 
forced mediation cases subscriber wish mediate ambiguous data may wish exert control timing subscriber completes mediation 
way doing allowing request immediate mediation 
communicator conversation ends component responsible managing past conversations wants store conversation appropriate vocabulary 
component interface requests application mediate possible vocabularies 
feedback distributed sensors collect context user context aware system needs able provide feedback ambiguous context particularly consequences important 
typical aware environment users mobile may interact multiple devices interaction environment 
reason architecture needs support remote feedback providing feedback visual aural practice device may remote subscribing component sensing component 
take previous example user motion monitored video camera provide identity location services 
user moves hallway device wall may display window synthesized speech indicate video camera system thinks user device subscriber context context sensor simply ability provide useful feedback users state system 
implemented example feedback discussion reminder application 
section discuss architecture designed implemented deal requirements 
mediating ambiguous context built support mediation extending existing toolkit context toolkit :10.1.1.9.5130
context toolkit software toolkit building context aware services support mobile users aware environments 
basic building blocks relevant discussion context widgets context interpreters 
shows relationship context components applications 
context widgets analogy gui widgets responsible collecting contextual information environment occupants :10.1.1.9.5130
provide uniform interface components applications context hiding details underlying context sensing mechanism 
widgets allow heterogeneous sensors sense redundant input regardless input implicit explicit 
widgets maintain persistent record context sense 
allow applications widgets query subscribe context information maintain 
application interpreter application widget sensor interpreter context architecture context toolkit components arrows indicate data flow 
context interpreter interpret context 
example context widget may provide location context form latitude longitude application may require location form street name 
context interpreter may provide abstraction 
complex interpreter may take context widgets conference room infer meeting place 
interpreters widgets sources ambiguous data 
modifications mediation order explain met requirements previous section introduce basic abstractions support mediation 
chose base abstractions oops toolkit gui toolkit provides support building interfaces recognizers interpret user input 
chose oops explicitly supports mediation single user single application ambiguous desktop input restricted version problem 
oops provides internal model recognized input 
model encapsulates information ambiguity relationships input interpretations input produced recognizers graph see 
graph keeps track source events interpretations produced recognizers 
words time location vocabularies wed 
pm mall shopping movie buy clothes watch times event graph representing predicted words context 
oops toolkit automatically identifies ambiguity graph intervenes widgets interpreters application passing directed graph mediator 
mediator displays portion graph user 
user response mediator accepts rejects events graph 
ambiguity resolved events graph accepted rejected toolkit allows processing input continue normal 
shows resulting changes 
gray boxes indicate components added context toolkit architecture illustrated support mediation ambiguous context 
mediation subsystem subsystem application mediator mediator mediator check ambiguity mediate resolved interpreter widget sensor interpreter context architecture application mediation subsystem architecture extended context toolkit 
gray box new 
example discussing additional changes necessary support requirements listed illustrate ambiguous hierarchical events context toolkit example 
communicator system time location information choose relevant vocabularies 
intelligent recognition system provides vocabularies interpreted words user typing 
set vocabularies set words stored sets alternatives associated confidences fairly common representation 
alternatives ambiguous event system 
result directed graph shown 
path graph correct user perspective mall wednesday shopping clothes 
call situation ambiguous mediation resolve ambiguity 
particular mediator display feedback interpretations user select repeat input 
suppose application subscribes data 
applications location data 
subscribers ambiguous location data may wait ambiguity resolved action location update take action ambiguous data asking user help mediate data picking alternatives usually highest confidence performing action performing higher level inference word user typing ambiguity 
increases depth complexity event graph 
modifications new requirements previous subsections described basic abstractions support mediation widgets interpreters applications mediators event graph 
explain additional architectural mechanisms needed support unique problems faced mediation ambiguous context introduced 
distribution original oops toolkit designed support mediation non distributed gui applications 
passed pointer entire graph mediators 
order support appropriate response times distributed environment context toolkit portions event graph subscribers passed network 
time new event added existing event accepted rejected component interested ambiguous context notified 
distributed system impede ability deliver context timely fashion required provide feedback action context 
single component contains entire graph represent ambiguity particular piece context 
graph distributed multiple components widgets interpreters copies particular graph levels provided applications needed 
event element graph list source events parent list interpretations children 
having lists contain full representations sources interpretations lists contain event proxies 
event proxy consists event id status accepted rejected undetermined event communication information hostname port number component name component produced event contains full representation 
components care status sources interpretations proxies allow components operate local access entire graph request information parts event graph don locally 
storage described storage context data useful feature context aware architecture 
context ambiguous immediately obvious stored 
option store data regardless ambiguous 
option provides history user mediation system ambiguity leveraged time create user models improve recognizers abilities produce interpretations 
chose implement complex option default widget stores unambiguous data 
dimension storage relates data stored 
storing unambiguous data store context data mediated 
reason choices fold storage simpler understand gain benefits offered knowledge ambiguity mediation process just arbitrary time mediation record ambiguity discarded 
case relatively simple modify architecture support second option default 
multiple subscription types multiple components may interested piece context may interested ambiguous data components need way specifying want handle ambiguous data 
architecture simply set boolean flag specify 
components accept ambiguous data required perform mediation 
take action wish data 
components accept unambiguous data required perform mediation wait component force mediation described receive data 
case component successfully mediates data components interested data notified 
architecture keeps track recipients ambiguous data updates 
keeps track components waiting unambiguous versions data passes mediated data 
notifies components produced ambiguous data data improve ability produce new data 
pre emption mediation multiple components may subscribe ambiguous data mediation may occur simultaneously components 
multiple components mediating succeed interrupts updates 
handled automatically architecture successful mediator accepts rejects data 
architecture notifies recipients change status 
recipient determines updated data currently mediated locally 
informs relevant mediators pre empted mediating 
past handle mediation multiple distributed components 
strategies handling simultaneous mediation discussed section 
forced mediation cases subscriber ambiguous context unable want perform mediation request component perform 
subscriber simply passes set ambiguous events wants mediated remote component asks remote component perform mediation 
remote component unable notifies requesting component 
performs mediation updates status events allowing requesting component take action 
feedback context data may gathered locations remote active application executing times remote user interacting active application need distributed feedback services separate applications 
support distributed feedback extended context widgets support feedback actuation output services 
output services quite generic range sending message user rendering output screen modifying environment 
existing output services render messages speech send email text messages arbitrary display devices control appliances lights televisions 
application component request output service executed allowing component provide feedback user 
section described modifications context toolkit allow human driven distributed mediation imperfectly sensed interpreted context 
sections demonstrate architectural solutions provided modified context toolkit implement motivating example modify existing applications support mediation ambiguity 
architecture section communicator illustrate runtime behavior architecture 
show practice programme designing context aware application uses architecture 
word mediator keyboard widget communicator vocabulary mediator word predictor widget ambiguous data unambiguous data forced vocabulary mediator vocabulary widget gps widget architecture communicator system companion vocabulary mediator runtime description communicator architecture order illustrate toolkit works runtime need describe details communicator system 
shows architecture described 
applications widgets communicator direct data widgets soft keyboard word predictor vocabulary selector 
keyboard widget produces unambiguous data simply lets components know user typing 
word predictor widget produces ambiguous data uses current context predict word user trying type 
uses unigram frequency method common simple word predictors history words 
subscribes keyboard get current prefix letters current word typed far 
letter typed suggests completions 
word predictor uses weighted vocabularies predictions 
subscribes vocabulary widget get list ambiguous probable vocabularies uses probability associated suggested vocabulary weight words vocabulary 
described earlier vocabulary widget uses remembrance agent suggest relevant ambiguous vocabularies current conversation 
person user communicating display available companion application run 
application presents interface see showing unambiguous words selected user current set ambiguous vocabularies 
summary application uses unambiguous widgets gps keyboard widgets generate ambiguous data third party recognizer vocabulary house recognizer word 
typical context aware systems ambiguity systems retained cases displayed user 
mediation ambiguous information generated system includes potential vocabularies potential words 
architecture allows component mediate ambiguous context mediated 
cases exist system 
application mediates ambiguous words vocabularies 
word predictor uses ambiguous vocabularies 
vocabulary widget uses unambiguous words user mediated 
word mediator graphical displays ambiguous words buttons horizontal list shown situ near bottom 
word may selected user ignored 
mediator replaces displayed words receives new words word predictor 
screenshots mediators choice mediator words vocabularies required mediator vocabularies 
experimented different strategies mediating ambiguous vocabularies 
simply accepts vocabulary highest probability user input equivalent mediation 
second see displays choices similarly words allows user ignore 
require user choose vocabulary different points conversation 
third requires choice new conversation starts new ambiguous vocabularies suggested 
fourth displays vocabulary choices requires user choose conversation ended 
mediated vocabulary name append current conversation appropriate vocabulary file improves vocabulary word prediction 
approaches demonstrate range methods appropriateness dependent recognizer accuracy 
architecture easily supports type experimentation allowing programmers easily swap mediators 
event graph describe architecture works system perspective 
widgets user interfaces started word predictor generates initial set guesses words empty prefix keyboard widget 
source event empty prefix sent word predictor interpretation interpretations predicted words passed handler user interface ui immediately routes word mediator display ambiguous 
user may select case mediator accepts word rejects 
toolkit proceeds notify interpretations source event producers word predictor keyboard widgets respectively recipients 
word predictor adds accepted word words list enhance prediction 
communicator ui companion application ui display word user companion respectively 
user types letter soft keyboard letter passed communicator ui displays bottom word predictor 
word predictor uses subsequent letters sources predictions user may resolve predictions selecting word 
money movie shopping movies mall money movie shopping movies mall shopping movies shopping movies keyboard word predictor communicator companion sample event graph distribution components 
events exist components created components sent money word event exists word predictor widget communicator interface 
vocabulary widget attempts find relevant vocabularies time user enters new word user changes location 
ambiguous vocabularies received word predictor widget predicts new words see 
potential vocabularies displayed vocabulary mediator communicator ui companion ui 
person selects vocabulary architecture notifies mediator pre empted 
third vocabulary mediation strategy vocabulary widget forces mediation request selection vocabulary gps vocabulary conversation signaled long break keyboard 
architecture passes request subscriber see perform mediation 
communicator receives request creates dialog box mediator shown 
user interacts mediator selects vocabulary 
event hierarchy updated vocabulary widget notified event created accepted 
widget writes conversation disk appropriate vocabulary file 
writing program features define application system data subscribes mediators uses 
programmer perspective new context aware system may entail creation application mediators widgets mediators widgets available library components sufficient 
illustrates demands programmer creating components scratch 
application specify handle ambiguous data create subscriptions widgets retrieve data storage necessary install mediators handle results subscriptions mediator produce feedback data mediated request info data parents children needed mediation allow user interact accept reject events user interaction mediate take mediator specific action pre empted forced mediate widget specify data provide ambiguous data create event graph send subscribers garbage collect perform widget specific actions mediated data steps building system components programmer create subscriptions initialization code application 
distinction subscribing ambiguous unambiguous context 
subscription data arrives left programmer handle application specific 
programmer specifies application wishes receive ambiguous data simple boolean flag 
communicator flag set false meaning receive unambiguous data 
word prediction widget sets flag true able likelihood ambiguous vocabularies improve prediction accuracy 
application needs access historical context simply asks relevant widget 
information retrieved storage ambiguous stated earlier 
programmer specifies mediators install initialization allowing experiment mediators directly 
programmer may wish extend existing mediator library mediators note italics highlight architectural issues impact program design 
way specific application 
case communicator means modifying reusable graphical mediator extract names vocabularies words ambiguous events order display meaningful choices user 
mediator support acquisition user feedback ambiguous data 
usually done application user interface 
appropriate mediator ask component data producer feedback user 
remote feedback reminder application discuss section 
event accepted rejected user mediator updates local part event graph notifies recipients event producer event accepted 
due issues involved distribution described earlier portion event hierarchy sent mediator 
necessary mediator may request additional events sources interpretations events mediating 
practice events application subscribed sufficient mediation proceed cases 
applications tend subscribe events interest user appropriate displayed mediation 
mediator provide code indicating pre empted mediator 
example communicator ui companion ui include vocabulary mediator 
user selects vocabulary pre empted 
mediator clean things visually notify user completed mediation 
communicator word mediator supports removing choices user 
unrelated subscriber may force mediation mediator provide code asked immediately mediate 
mediator able mediate special required 
necessary information resolve ambiguity clean display pass control mediator line 
vocabulary widget forces communicator vocabulary mediator mediate conversation ended needs know vocabulary file conversation appended 
programmer may need create new widget encapsulate new source context data 
widget specify type data produces 
produces new data notifies subscribers 
data ambiguous new event graph created data root 
unambiguous event graph created 
data mediated widget notified garbage collect event take actions event appending conversation appropriate vocabulary file 
summary shown architectural changes described practice 
illustrated runtime behavior communicator application 
described programmer needs know create components applications architecture 
discuss impact architecture design applications 
evaluation architecture evaluated architecture building applications 
applications simple modifications existing applications include ambiguous sensors mediation 
third application built scratch uses mixture ambiguous unambiguous data sources 
board application modified board application displays current status group building occupants :10.1.1.9.5130
original system unambiguous location widget informed application user entered left room 
users indicated status docking java ibutton 
substituted ambiguous location widget original widget 
requiring explicit action user determine status new widget uses historical information combined motion detector guess entering leaving 
motion detector microphone speakers ibutton dock display keyboard photograph board physical setup board transparent graphical feedback 
original system support ambiguity ignored fact docking ibutton merely provides information user presence user arrival departure room 
new widget introduces ambiguity user state attempt require explicit user action introduces additional ambiguity user identity 
added mediator handles types ambiguity 
mediator displays current best guess user allows correct variety modalities ranging lightweight heavyweight including speech docking ibutton typing keyboard 
application modified follows 
total lines changed added 
fourteen minor substitutions changed unambiguous widget ambiguous new library imports 
new class variables created hold pointers mediator lines code added instantiate mediator pass piece necessary information application pointer user interface 
new widget board reusable fact application 
mediator extension mediator library mediators modified display application specific text 
second application modified situation aware reminder system 
original application subscribes widget running allows user create reminders triggered combination events widgets generate 
example user set reminder go meeting people meeting room right time 
delivery reminders performed current context appears match triggers specified user 
application assumes reminder successfully delivered acted 
modified delivery mechanism adding mediator remove assumption 
mediator gives user opportunity reject reminder certain time delivery 
indicates reminder time current context matches trigger 
user reject system proceeds change status delivered just done immediately original application 
original application modified subscribe ibutton widgets application notified user mediate reminder install custom mediator 
mediator associated remote widget feedback services display feedback reminder status 
extension timer mediator modified display application specific messages 
application modifications required addition library imports lines code modified added 
word predictor third application communicator built scratch 
system built consists widgets mediators ambiguous recognizers shelf interfaces 
illustrated architecture application 
application demonstrates important features architecture 
shows supports experimentation mediation making trivial swap mediators 
adding replacing mediator requires lines code 
second shows difficult build compelling realistic application 
main communicator application consists lines code majority deals gui issues 
lines deal mediation deal context acquisition 
summary modified existing applications built scratch 
demonstrate required features architecture 
reuse ambiguity generating widgets 
applications required minor modifications deal ambiguity 
third application built scratch little code dedicated dealing mediation context acquisition 
applications involve distributed event hierarchies reusable mediators resolve ambiguity 
related past years number research efforts aimed creating ubiquitous computing environment described weiser 
aware environments environments automatically implicitly sense information state users take action context 
past reactive room neural network house intelligent room provide explicit reusable support users handle correct uncertainty sensed data interpretations 
number architectures facilitate building context aware services aware environments built :10.1.1.9.5130
case aware environments simplifying assumption context sensed unambiguous 
exceptions assumption 
example remembrance agent uses context retrieve information relevant user explicitly addresses ambiguity interface showing users multiple potentially relevant pieces information letting select interesting 
multimodal maps map application travel planning addresses ambiguity multimodal fusion combine direct manipulation pen gestures handwriting speech input prompts user information remove remaining ambiguity 
multi modal map application prompts user disambiguating information 
services demonstrate mediation techniques allow user correct ambiguity sensed input 
require explicit input part user take action 
goal provide architecture supports variety techniques ranging implicit explicit applied context aware services 
removing simplifying assumption context certain attempting facilitate building realistic context aware services 
valid question sensors accurately interpreted 
unfortunately practice due social technological issues sensors reliable appropriate 
long chance sensors may mistake need provide users techniques correcting mistakes 
sensors chose foolproof combination sensors ability correct errors applications take action satisfactory necessary alternative 
extended context toolkit supports building realistic context aware services able ambiguous context 
addressed issues raised problem 
implemented basic algorithm handling multiple applications attempting mediate simultaneously add sophisticated priority system allows mediators control global mediation process 
need build context aware services new architecture put extended 
lead better understanding users deal having mediate implicit input better understanding design heuristics involved building context aware services 
attempt answer question best handle mediation settings 
design mediation distributed multi user settings settings implicit input open question 
architecture easy programmers experiment different mediation techniques hope enable learn appropriate ways handling mediation 
extended context toolkit supports building context aware services deal ambiguous context allow users mediate context 
users mobile aware environment mediation distributed space time 
toolkit extends original context toolkit providing mediators provide timely delivery context partial delivery event graph distributed feedback output services context widgets 
demonstrated evaluated extended context toolkit modification example context aware applications creation new context aware application 
showed architecture relatively simple create realistic context aware applications handle ambiguous context 

bobick perceptually interactive immersive story environment 
presence 

brown stick document framework creating context aware applications proc 
electronic publishing 

cheyer julia multimodal maps agent approach proc 
international conference cooperative multimodal communication 

coen human computer interaction learned worrying love intelligent room 
ieee intelligent systems 

cohen multimodal interaction distributed applications proc 
multimedia 

reactive environments throwing away keyboard mouse 
cacm 

cutrell czerwinski horvitz notification disruption memory effects messaging interruptions memory performance 
proc 
interact 

dey conceptual framework toolkit supporting rapid prototyping context aware applications 
human computer interaction journal 

dey abowd context aware system supporting reminders proc 
huc 

harter anatomy context aware application proc 
mobicom 

hull situated computing proc 
iswc 

lesher techniques augmenting scanning communication 
augmentative alternative communication 

lesher domain specific word prediction augmentative communications 
proceedings annual conference reno 

mankoff oops toolkit supporting mediation techniques resolving ambiguity recognition interfaces 
computers graphics 

augmentative alternative communication role broadband telecommunications 
ieee transactions rehabilitation engineering 
september 

moran paul dourish editors 
special issue context aware computing 
human computer interaction journal 

mozer neural network house environment adapts inhabitants proc 
aaai spring symposium intelligent environments 

rhodes wearable remembrance agent system augmented memory 
personal technologies 

schilit system architecture context aware mobile computing ph thesis columbia university may 

weiser computer st century 
scientific american 
