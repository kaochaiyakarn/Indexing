impact dht routing geometry resilience proximity krishna gummadi ramakrishna gummadi steve gribble sylvia ratnasamy scott shenker ion stoica irb tr march proceedings acm sigcomm disclaimer document provided warranties whatsoever including warranty non infringement fitness particular purpose 
intel authors document liability including liability infringement proprietary rights relating implementation information document 
provision document provide license express implied intellectual property rights copyright intel rights reserved 
impact dht routing geometry resilience proximity gummadi gummadi gribble ratnasamy shenker stoica various proposed dht routing algorithms embody different underlying routing geometries 
geometries include hypercubes rings tree structures butterfly networks 
focus basic geometric approaches affect resilience proximity properties dhts 
factor distinguishes geometries degree flexibility provide selection neighbors routes 
flexibility important factor achieving static resilience effective proximity neighbor route selection 
basic finding despite initial preference complex geometries ring geometry allows greatest flexibility achieves best resilience proximity performance 
categories subject descriptors computer systems organisation computer communication networks general terms algorithms performance keywords dht routing geometry flexibility university washington 
gummadi cs washington edu usc los angeles 
gummadi usc edu university washington 
gribble cs washington edu intel research berkeley 
sylvia intel research net icsi berkeley 
shenker icsi berkeley edu uc berkeley 
cs berkeley edu supported part nsf ccr itr iis ani ani itr itr itr ani ani stoica sloan foundation fellowship 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigcomm august karlsruhe germany 
copyright acm 

unexpected unprecedented explosion peer topeer file sharing ignited napster succession legally vulnerable successors gnutella kazaa inspired development distributed hash tables dhts 
dhts offer promising combination extreme scalability scaling typically log useful semantics supporting hash table lookup interface proposed substrate large scale distributed applications see example :10.1.1.28.5987
focus uses dhts underlying dht routing algorithms 
wide variety dht routing algorithms proposed list grows longer passing conference 
dht routing literature infancy result dht routing papers describe new algorithms provide general insight algorithms usefully compare algorithms 
attempt take small step direction looking basic geometry underlying dht routing algorithms impacts performance important areas static resilience proximity routing 
current collection dht routing algorithms differs respects fundamental distinction lies different routing geometries 
instance dimension taken log routes hypercube chord routes ring viceroy uses butterfly network prr algorithm uses tree structure :10.1.1.140.3129:10.1.1.38.1850:10.1.1.17.4065:10.1.1.105.3673
geometries differing degrees flexibility choosing neighbors hop paths 
importance geometry resulting flexibility isn clear looking typical metrics concern state number neighbors efficiency average path length algorithms achieve state efficiency trade offs 
geometry flexibility relevant looking performance issues 
crucial questions facing dhts operate extremely transient environment significant fraction nodes time 
facets issue notably speed overhead recovery algorithms relatively completely see unexplored area static resilience dht route recovery algorithms chance magic :10.1.1.3.9768:10.1.1.28.5987
discuss issue section 
crucial question dhts adapt underlying internet topology 
research devoted incorporating proximity dht routing protocols areas concern 
total latency dht routing path small multiple underlying internet latency 
discuss path latency section 
second paths converge various tasks providing efficient caching building parsimonious multicast trees finding closest server easier dht routing paths local convergence property explore section 
examines extent geometry impacts performance areas discussing geometry section 
embarking discussion hope provides insight readily confess initial stab problem undoubtedly incomplete 
various sins include picking currently proposed dht routing algorithms considering factors symmetry may affect state management overhead focusing performance issues resilience proximity considering interactions various properties 
rectifying omissions subject 

geometries algorithms provide context technical material follow discuss philosophy motivates 
noted myriad dht designs literature extensively analyzed promoted 
envision large scale dht infrastructures 
routing choices select build systems 
question choice 
approach view systems complete coherent proposals bake comparing performance real world situations 
black box approach taken compares designs turn key systems :10.1.1.12.8387
provides performance comparisons fixed set designs environment doesn provide guidance designing new dhts 
different approach view proposal set somewhat independent design choices evaluate wisdom design choice hope insight eventually lead superior hybrid design 
adopts approach 
intend observations rankings current dht proposals hints better design dht routing algorithm 
geometries roughly divide dht design issues categories routing level category confined defined issues neighbor selection picks set neighbors node route selection chooses hop routing message 
choices determine call routing behavior dht 
system level category contains 
higher level design decisions apply routing level choices 
examples system level issues caching replication actual delivery messages done iteratively recursively 
routing level system level choices completely independent routing level design choices affect feasibility performance system level design choice largely orthogonal treated 
useful distinction routing algorithm routing geometry 
algorithm refers precise details neighbors hops chosen 
change details change routing algorithm 
geometry precise term formal definition way neighbors routes chosen compelling geometric interpretation 
conversely choice routing geometry constrains way neighbor routing choices 
small changes routing algorithm change underlying routing geometry 
focuses impact routing geometry particular algorithmic details 
noted earlier current dht routing proposals clear geometric interpretations 
question properties various dht routing algorithms derive basic choice geometry altered small algorithmic changes 
understanding constraints possibilities inherent underlying routing geometry help guide designing dht routing algorithms 
note geometries capable providing log path lengths log neighbors viceroy improve neighbors 
don focus geometry effects space efficiency 
note geometries place different constraints route neighbor selection 
resulting varying degrees flexibility geometry provides significant impact resilience proximity properties system 
discuss flexibility somewhat greater depth 
flexibility flexibility algorithmic freedom left basic routing geometry chosen 
freedom exercised selection neighbors routes 
discuss issues turn neighbor selection dhts routing table comprised neighbors 
original set dht proposals algorithms choice neighbors purely deterministic set identifiers system neighbor tables completely determined allowed freedom choose neighbors criteria addition identifiers notably proximity latencies select neighbors 
question initial proposal included feature basic routing geometry precludes 
routing geometry precludes choosing neighbors proximity true loss flexibility routing geometry allows choice omission merely small algorithmic detail changed 
dht proposals call sequential neighbors 
neighbors route sure making progress destinations 
pastry successors chord examples sequential neighbors 
geometries naturally support sequential neighbors don neighbors play crucial role recovery algorithms dht proposals basic geometries don naturally support sequential neighbors augmented design include 
result somewhat hybrid geometry 
route selection set neighbors destination routing algorithm determines choice hop 
flexibility relevant reasons 
determined hop flexibility describes options hop 
routing algorithm fare poorly high failure rates 
second analogous choosing neighbors proximity want choose hops proximity 
extent reflects degree freedom alluded picking options failure arises different context 
algorithms discuss basic routing geometries 
reviewing dhts describing routing algorithm interpreted geometrically 
special note flexibility neighbor route selection provided different geometries 
important note consider flexibility exercised significantly altering tradeoff geometry 
instance chord pick neighbors choose routes path lengths spectacular degree flexibility represent desirable design 
discussion follows assume systems nodes log bit node identifiers 
practice algorithms typically log bit identifiers identifier space wholly populated nodes clarity conciseness assume wholly populated identifier spaces discussion 
likewise description treats identifiers binary strings practice base assumptions affect correctness comments help facilitate presentation 
abuse terminology frequently term node refer node identifier 
consider dhts prr chord viceroy pastry kademlia :10.1.1.140.3129:10.1.1.38.1850:10.1.1.28.5987:10.1.1.16.4785
reasons space time algorithms consider tapestry discussion prr apply tapestry de bruijn inspired algorithm randomized algorithm due kleinberg 
simulation results assume dense identifier space 
base allow reasonable path lengths typically hops clearly results relevant dhts short paths hops 
tree tree hierarchical organization candidate efficient routing fact geometry underlying prr algorithm dht routing algorithm 
basic routing algorithms tapestry pastry similar spirit original algorithm pastry describe uses ring geometry addition tree 
tree geometry node identifiers constitute leaf nodes binary tree depth log distance nodes height smallest common subtree 
node holds log neighbors th neighbor distance node routing works greedy routing destination 
words node neighbor nodes match prefix identifier differ bit 
routing achieved successively correcting highest order bit forwarding node differs destination effectively increasing length longest prefix match hop 
observation flexibility node choosing neighbors node options choosing neighbor distance corresponding subtree nodes share log bits node differ log bit 
unconstrained lower order bits give great deal freedom choosing neighbors amount freedom increasing exponentially increasing distance yields total approximately log log possible routing tables node 
course node choose exactly possible routing tables 
consider routing flexibility 
particular choice routing table flexibility node selecting hop destination 
observe tree node neighbor reduces distance destination neighbor increase length longest prefix match 
contrast generous flexibility choosing neighbors tree offers flexibility route selection 
hypercube routing resembles hypercube geometry 
uses torus partitioned nodes node owns distinct zone space 
explained node identifier binary string representing position space :10.1.1.140.3129
log dimensions neighbor sets exactly log dimensional hypercube 
node log neighbors neighbor differs node th bit 
distance nodes number bits identifiers differ routing works greedy forwarding reduce distance 
routing effectively achieved correcting bits forwarding node differs destination 
key difference routing hypercube tree hypercube allows bits corrected order tree bits corrected strictly left right order 
reason hypercube order bit hypercube interpretation extendable log purposes restrict case log dimensions routes log hops directly comparable dhts 
fixing tree node neighbor differs single bit previous corrections lower order bits maintained higher order bits corrected 
hypercube offers greater flexibility route selection 
specifically routing source destination distance log node log hop choices second node log choices yielding total approximately log 
routes nodes 
note paths length differ order destination bits fixed 
hypercube pays price flexibility route selection 
node neighbors differ exactly bit possible choice neighbors 
node flexibility selecting neighbors 
opposite occurs tree neighbor selection flexibility route selection flexibility 
butterfly viceroy algorithm emulates operation traditional butterfly network adapts structure self organizing robust face node arrivals departures 
viceroy improves state efficiency tradeoff previously proposed dhts routing log hops constant state node 
details viceroy fairly involved provide sketchy overview 
traditional butterfly nodes organized series log stages nodes stage capable essentially correcting th bit identifier 
ensure correctness face node dynamics viceroy imposes global ordering nodes system requires node hold neighbors immediate successor predecessor ordering 
node holds neighbors immediate successor predecessor nodes stage 
viceroy routing consists phases uses log hops move stage second uses log hops traverse stages reaches vicinity destination point routing enters third phase uses successor predecessor neighbors reach destination log additional hops 
note final routing phase uses log hops permit flexibility route neighbor selection 
butterfly achieves greater efficiency dhts consider results far flexibility 
stress flaw particular viceroy design conjecture limitation fundamental constant state algorithms 
ring ring geometry nodes lie dimensional cyclic identifier space distance identifier calculated clockwise numeric distance circle 
chord embodies ring ways restore flexibility keeping state making state critical operation algorithm imposing recovery requirement critical state 
subject pursue 
different ring dhts measure distance ring slightly different ways chord uses clockwise distance viceroy uses minimum clockwise distance 
difference changes constants flexibility bounds 
try 
chord node identifier say maintains log neighbors called fingers th neighbor node closest circle 
node route arbitrary destination log hops hop cuts distance destination half 
original chord proposal defines specific set neighbors node identifier rigidity neighbor selection way fundamental ring geometry 
specifically routing ring achieved log hops node pick th neighbor node range exact node closest circle originally defined chord 
implies terms flexibility neighbor selection ring geometry tree possible options picking th log neighbor total approximately possible routing tables node 
having selected possible routing tables examine flexibility route selection available node terms neighbors progress destination 
nodes initially distance apart node approximately log neighbors progress destination 
hop node approximately log possible hops yield total approximately log 
possible routes typical path 
note paths respect efficiency bound log hops 
routing source destination uses log hops span exponentially different distances greedy routing takes hops decreasing order spans path takes different spans just reach destination log hops irrespective order spans taken 
section define rule allows chord take different spans just imposing order 
discussion limited paths bounded log hops chord allows paths longer log accomplished multiple hops smaller spans single hop large span 
example take successive hops th neighbors span single hop th neighbor span xor kademlia defines novel routing metric distance nodes numeric value exclusive xor identifiers :10.1.1.16.4785
lack intuitive name term xor geometry refer geometry interpretation yielded xor metric 
kademlia node picks log neighbors th neighbor node xor distance 
examination definition neighbors reveals kademlia routing table permits exactly routing entries tree geometries prr 
routing greedily xor metric kademlia chooses exactly routes prr routing table fully populated failures successive hops fix bits left right 
failures kademlia behaves differently tree node fix highest differing bit progress xor distance destination effectively fixing lower order fairly recognized fact dht community developers chord claim observation 
property tree hypercube ring butterfly xor hybrid log neighbor selection log log log route selection optimal paths log log route selection non optimal paths log log log natural support default routing sequential neighbors 
fallback routing table neighbor route selection flexibility node various routing geometries 
small constants 
bit 
multiple paths exist source destination paths equal lengths 
stems fact distance node neighbors respect node little bearing distance destination 
intuitively kademlia offers flexibility fixing lower order bits higher ones lower order fixed bit need preserved routing hops fix higher order bits 
hybrid far pure geometric interpretations 
routing algorithms employ dual modes mode inspires different geometric interpretation call hybrid geometries 
pastry canonical example hybrid geometry combines tree geometry ring geometry 
node identifiers regarded leaves binary tree points dimensional circle 
pastry distance pair nodes computed different ways tree distance second cyclic numeric distance 
default pastry uses tree distance metric routing falls back ring geometry tree routing fails 
freedom neighbor selection tree geometries 
route selection flexibility subtle 
hybrid geometry allows take hops progress tree progress ring paths necessarily retain log bound number hops 
pastry canonical example point dhts similar hybrid geometry discuss 
mentioned earlier sequential neighbors progress destination identifiers 
requires single global ordering distances nodes ring geometry naturally supports sequential neighbors 
designs augmented include sequential neighbors especially recovery essentially defining separate ordering aside ordering normal routing 
particular viceroy see incorporated sequential neighbors 
examples pastry hybrid geometries 
evaluation explore extent sequential neighbors nat argue tree similar multiple paths exist allow sideways hops maintain increase length longest prefix matched 
require rule prevent looping require ordering nodes share prefix 
precisely pastry achieves defining second distance metric 
supported artificially added improve proximity resilience 
table summarizes discussion different routing geometries flexibility 
note enter slightly different constants flexibility route selection different geometries 
specifically claim ring hypercube twice flexibility route selection compared hybrid xor geometries 
simulation results sections validate difference 

static resilience reasons dhts seen excellent platform large scale distributed systems resilient presence node failures 
resilience different aspects explore data replication nodes fail data pointers holding go 
measures taken doesn result loss data system 
complementary approaches proposed notably data replication 
discussion assume degree replication adequate prevent data loss remaining question route presence failures 
routing recovery failures occur routing tables remaining nodes 
recovery algorithms routing tables live nodes routing continue 
static resilience recovery algorithms take time restore routing tables ask dhts route routing state restored 
call static resilience keep routing table static deleting failed nodes ask routing performs 
static resilience measures extent dhts route trouble aid recovery mechanisms fix trouble 
static resilience gives measure quickly recovery algorithm dhts low static resilience require faster recovery algorithms similarly robust 
see true consider node ring routing destination distance node neighbors progress destination 
likewise hypercube node differs destination bits corresponding neighbors progress 
hybrid xor destination distance node th neighbor progress th bit differs destination true half time 
papers consider resilience presence active recovery algorithms examine static resilience 
address issue contexts pastry respectively examines certain graph theoretic properties overlay structure affect static resilience :10.1.1.140.3129
routing average median percentile geometry hopcount hopcount hopcount xor ring tree butterfly hypercube hybrid table comparing different dhts node network failures 
test static resilience node network 
allow different dhts populate routing tables ensuring geometries exception butterfly store amount state number routing table entries node 
shown table performance geometries exception butterfly similar node failures 
fixed fraction uniformly chosen nodes fail remove entries corresponding failed nodes routing tables 
try route live node live node ask routing succeed 
particular look metrics paths failed describes routing able connect live nodes 
increase path length describes increase path length compared path length failed nodes 
follows consider algorithms routing geometries xor ring tree butterfly hypercube hybrid 
performance results section discuss questions question static resilience various geometries compare 
left graph shows results failed paths failed nodes varied 
results consistent degree route selection flexibility geometry see table 
tree butterfly route selection flexibility resilience quite poor nodes failed paths failed 
extreme ring hypercube geometries flexibility route selection resilience significantly better nodes failed routes failed 
intermediate cases hybrid xor geometries dhts amount state stored butterfly node constant controlled 
ring performs better hypercube number log length paths ring alternate paths longer log hypercube 
half number alternate paths half routing flexibility ring hypercube 
resilience correspondingly inferior ring hypercube far superior tree butterfly nodes failed routes failed 
right graph shows results increase average path lengths path stretch failed nodes varied 
path stretch hypercube minimal consistent observation alternative paths equal length 
ring suffers intermediate path stretch alternate paths longer rest 
geometries incur significant path stretch longer alternate paths 
path stretch decreases large fraction nodes fail routes succeed high node failure rates succeed short 
question addition sequential neighbors affect static resilience various geometries 
previous results include sequential neighbors 
consider happens add sequential neighbors various algorithms 
eliminate xor geometry doesn support sequential neighbors tree included represented hybrid 
obvious result sequential neighbors greatly increase resilience path failures path failures seen geometry nodes failed 
suggests dhts equipped sequential neighbors route successfully high node failure rates 
ring performs significantly better hypercube sequential neighbors artificially grafted 
increase resilience path failures comes cost path stretch 
algorithms suffer significantly greater path stretch hypercube sequential neighbors paths equal lengths 
question sequential neighbors better regular neighbors ensuring static resilience 
previous results specific sequential neighbors conjecture increased resiliency equally achieved just increasing total number neighbors insisting sequential 
ask sequential neighbors especially useful increasing resilience 
considering ring geometry compare cases total number sequential regular neighbors number sequential neighbors different 
results shown 
left graph indicates high node failure rates sequential neighbors better regular neighbors increasing resilience path failures right graph indicates lead significantly longer paths note axis right graph shows path hop counts path stretch 
sequential neighbors preferred option concerned routing success metrics total path latency 
summarize results confirm static resilience geometry largely determined amount routing flexibility offers 
ring greatest routing flexibility highest resilience tree butterfly flexibility routing resilience 
addition sequential neighbors dhts significantly resistant path fail failed paths xor ring tree butterfly hypercube hybrid failed nodes increase avg 
path hop counts xor ring tree hypercube hybrid failed nodes left percentage failed paths varying percentages node failures different routing geometries 
right percent increase average path hop counts successful paths varying percentages node failures different routing geometries 
butterfly left graph routes usable take shorter paths original ones resulting negative path stretch 
failed paths ring hypercube butterfly hybrid failed nodes increase avg path hop counts ring hybrid hypercube failed nodes left percentage failed paths varying percentages node failures different routing geometries 
right percent increase average path hop counts successful paths varying percentages node failures different routing geometries 
butterfly left graph path increase higher reaching distort axis 
algorithms sequential neighbors 
ures path stretch get worse 
ring topologies replacing additional sequential neighbors regular neighbors yields similar smaller increased resistance path failures smaller path latency 

path latency dhts designed provide efficient routing measured terms hopcount number overlay hops source node destination node 
hopcount important metric measuring processing bandwidth requirements peers adequately address issue latency overlay hop potentially involve significant delays links satellite links 
result effort reduce latencies dht routing algorithms considering relative proximity overlay nodes ip latency :10.1.1.38.1850
proposed methods fall broad categories consider 
proximity neighbor selection pns neighbors routing table chosen proximity 
proximity route selection prs routing table chosen choice hop routing particular destination depends proximity neighbors 
proximity identifier selection pis explored pick node identifiers geographic location 
load balancing hard increases likelihood correlated failures don discuss method 
consider proximity methods pns prs 
section begins short description methods rest section devoted analysis 
evaluation recursive opposed iterative routing believe key regarding relative performance pns prs hold true iterative routing 
confirming belief subject 
evaluating proximity methods requires topology underlying network link latencies 
testing proximity methods topologies doesn ensure results generalize 
defining pns prs discuss generally failed paths ring ring ring ring failed nodes average path hop counts ring ring ring ring failed nodes left percentage failed paths varying percentages node failures ring geometry varying numbers neighbors sequential neighbors 
right average path hop counts successful paths varying percentages node failures 
stand role topology link latencies proximity methods 
preliminaries address question geometry affects path latency dht routing algorithms 
analysis style different previous section static resilience comparing detailed differences geometries 
find geometries difference support pns prs 
section really comparison proximity methods 
discussed section geometries capable pns prs 
section wish evaluate relative performance pns prs see restrictions adopting significant hindrance 
pns prs dht algorithms flexibility choosing neighbors typically neighbors chosen subset identifier space 
ideal pns algorithm select closest neighbors measured latency subsets 
example subset th neighbor node tree geometry identifier space sub tree depth containing node ring geometry identifier space 
identifying closest nodes hard practice sizes subsets grow exponentially various heuristics proposed approximate performance ideal pns 
define heuristic dubbed pns uses random sampling 
pns samples consecutive nodes starting element relevant subset picks closest 
don dwell pick general node reasonable choice inspecting latency distribution see 
term pns refer ideal pns 
prs algorithms deal complicated tradeoff number hops latency 
neighbor closer destination identifier space valid hop proximity hop chosen greedy fashion decrease number hops 
number heuristics trade hops latency focus heuristics effective ring xor hypercube geometries 
heuristic ring takes advantage multiple paths equal number hops destination see table chooses hop subset neighbors called candidate set usually increase routing path hops 
select candidate set distance destination expressed binary notation neighbor chosen set th position 
closest member candidate set picked hop 
coupled pns algorithm disallows closest log neighbors candidate set course destination lies closest log neighbors 
heuristic applied xor geometry luxury multiple paths number hops destination 
prs heuristic xor takes non greedy hop latency smaller latency greedy hop choice average latency network 
primarily helps avoid long hops 
hypercube alternate paths number hops prs heuristic simple 
valid hops pick smallest latency 
investigate role topology determining effectiveness proximity methods 
role topology latency aspects hard understand proximity methods performance depends critically underlying topology latency characteristics 
large literature describing possible approaches topology modeling starting initial random graphs waxman structural generators gt itm transit stub tiers set power law degree generators little known assign latencies topology 
previous studies evaluate proximity methods topology generators ad hoc choice latency assignments don analyze choice latencies affects performance proximity methods 
research proximity methods position know describe real world latencies understand effect proposed algorithms 
version prs adds combined ideal pns algorithm effectively infinite 
cdf latency distributions internet seen different geographic locations node gt itm topology seen typical node 
propose possible way bind 
conjecture effect topology latencies large class networks including current internet graph reasonably approximated looking latency distribution seen typical node 
conjecture choosing neighbors hops reasonable approximation consider set possibilities coming independent drawing latency distribution 
conjecture holds immediate benefits 
empirically measure latency distribution internet various suitably located hosts need guess latency assignments internet topology model 
second measured distribution compute merely simulate approximation expected performance proximity method 
evaluate conjecture simulate performance various proximity methods latency annotated network topology compare performance computed latency distribution seen random node topology 
doing approximation latency distribution uniform nodes 
see results simple rough approximation agree simulation results see 
illustrate real world latencies data skitter project measurement project plot latencies large number hosts spread internet seen various geographical locations similar measurements seen 
hosts measured skitter project cover large fraction routable ip prefixes measured project gnutella hosts 
striking feature common latency graphs curves rise sharply certain latency range indicating heavy concentration nodes latency range 
note latency graphs differ significantly assumptions required prove bounds :10.1.1.38.1850
show latency distribution typical node node gt itm topology simulation results 
important difference observed gt itm latencies acknowledge approximation suffers latency distribution varies substantially qualitatively point point 
approximation need capture relative merits different approaches intended provide quantitatively accurate descriptions method performance 
non negligible fraction observed real world latencies large 
gt itm case paths double median latency observed distributions atleast paths latencies double median 
cdf simulated pns tree computed pns tree simulated prs ring computed prs ring latency cdf path latency distributions pns tree prs ring derived ways simulated gt itm topology computed latency distribution 
compares computed simulated results algorithms prs ring pns tree gt itm topology nodes 
links transit nodes assigned latency transit node stub node assigned 
latencies links stub nodes set 
note computations agree simulations confirming conjecture earlier computations latency distribution seen typical node provides reasonable approximation actual simulations 
results prs close pns due fact prs algorithms typically lead variations hop count 
differences simulated computed results far differences gt itm observed latency distributions 
precision lost computations simulations increase accuracy modeling reality 
follows consider xor ring hypercube tree 
hybrid algorithm tree algorithm essentially identical node failures 
butterfly admit pns prs 
minor point tree admit prs cdf plain xor pns xor prs xor pns prs xor internet latency msec cdf plain ring pns ring prs ring pns prs ring cdf path latency distributions plain pns prs pns prs versions xor left ring right routing geometries 
addition cdf underlying internet latency distribution plotted comparison 
right graph pns prs curve lies top pns curve isn directly visible 
algorithms sequential neighbor computed real world latency distribution marked va 
cdf plain ring pns ring prs ring pns prs ring latency msec cdf latency plain ring seq 
neighbor plain ring seq 
neighbor prs ring seq 
neighbor prs ring seq 
neighbor pns ring seq 
neighbor pns ring seq 
neighbor left cdf path latency distributions plain pns prs pns prs versions ring 
algorithms sequential neighbors 
right cdf path latency distributions plain prs pns versions ring sequential neighbors marked titles curves 
computed real world latency distribution marked va 
geometry proximity pns prs xor ring tree hypercube table th percentile different dhts show change significantly various proximity methods 
network nodes 
results obtained node network 
th percentile different geometries various proximity methods summarized table confirm gains path latency reported come significant cost path 
performance results rest section address questions 
hybrid geometry extended accommodate prs 
don pursue extension 
latency question effective pns prs 
methods proposed literature effectiveness compared 
hold fixed effect underlying geometry compare approaches geometries accommodate xor ring 
shows results plain pns prs pns prs versions xor ring algorithms 
cases prs version shows significant improvement plain version far improvement realized pns version 
addition adding prs pns gives small improvement pns 
understand pns better prs consider node densely packed ring geometry trying route identifier distance 
pns node deterministically pick th neighbor neighbor selected nodes identifiers 
contrast prs choose neighbors neighbor deterministically chosen 
pns chooses options prs options resulting improved performance pns 
results reported ideal pns 
see results change sampling small sub set compare various design options sample size 
left graph shows results similar case pns performing significantly better prs performance improvement pns prs pns somewhat performance improvement pns prs pns 
see impact adding sequential neighbors results compare performance plain pns prs versions ring adding sequential neighbors right graph 
improvements noticeable plain prs versions large affect comparative results significant way 
results latency distribution seen node virginia east coast usa marked va 
distribution similar seen west coast usa europe marked ca nl considerably different seen japan marked jp 
test consistency results different latency distributions compute performance proximity methods xor geometry jp latency distribution show results 
comparing graph left graph notice relative performance proximity methods similar pns outperforming prs wide margin absolute performance differs markedly latency distributions 
cdf plain xor jp pns xor jp prs xor jp pns prs xor jp internet jp latency msec cdf path latency distributions plain pns prs pns prs versions xor routing geometry 
algorithms sequential neighbor computed realworld latency distribution marked jp 
conclude considering path latency important geometry accommodate pns accommodating prs sake path latency appear important 
question underlying geometry matter determining pns prs 
geometry flexibility determines lack space don performance results gt itm latency distributions note results somewhat different observed realistic latency distributions 
specifically performance gap prs plain smaller performance gap pns pns larger gt itm case real world latency distributions 
urge caution gt itm topologies evaluate proximity methods 
cdf pns prs ring pns prs xor pns ring pns tree prs ring prs hypercube latency cdf path latency distributions pns prs ring pns prs xor pns ring pns tree prs ring prs hypercube 
computed real world latency distribution marked va 
pns prs ring lies top pns curve directly visible 
algorithms sequential neighbor 
routing median va median jp median algorithm hopcount latency latency internet xor pns xor prs xor pns prs xor table comparing median latency xor overlay paths underlying ip paths extremely different latency distributions marked va jp 
latencies milliseconds 
accommodate pns prs ask geometry affects path latency distinction 
compares performance pairs pns prs ring versus pns prs xor pns ring versus pns tree implement prs prs ring versus prs hypercube implement pns 
performance pair designs close suggesting really matters ability implement pns prs factors geometry 
question absolute performance proximity methods 
results far compare relative performance proximity methods address question absolute sense 
question addressed papers proposing individual proximity designs revisit tests realistic latency distribution may indicative real world performance 
absolute performance depends exact latency distribution table show median latencies various designs different latency distributions 
seen best options pns pns prs fare quite distribution 
plain xor ratio roughly latencies pns prs xor ratio 
available proximity methods reduce latencies overlay small multiple underlying internet path latencies consistent findings 
summarize discussion section find neighbor selection pns route selection prs help finding shorter paths pns yields significantly better paths prs 
effectiveness proximity methods depend choice routing geometry 
geometries tree xor ring support pns perform considerably better geometries hypercube support prs 
xor ring accommodate pns prs tree additional benefit supporting prs pns appears quite limited 
ability accommodate may advantage pns limited practical version pns 

local convergence local convergence issue arises considering effects underlying network latencies 
local convergence identified property messages sent nearby terms latency nodes addressed location converge node near sources 
property leads low latencies bandwidth savings different uses dhts including overlay multicast setting multicast tree cares lengths individual path considered previous section efficiency entire multicast tree 
quantity improved dht routing local convergence property mentioned 
caching way speed access cache pointers retrieval path described 
dht local convergence nearby node requesting content cached content 
server selection similar caching explained clients easily find nearby servers pointers stored path root section seek understand impact geometry local convergence :10.1.1.38.1850
general local convergence depends nature underlying topology exact location sources destination 
provide simplified controlled experiment consider case isolated domain 
consider nodes small latency nodes isolated domain large latency away nodes 
node isolated domain contact randomly chosen destination outside domain 
measure local convergence exit points nodes domain relay message domain node 
best case node sends message domain messages domain nodes converge point leaving domain 
test convergence ring tree xor geometries 
figures plot measured number exit expect prs hypercube offer convergence similar prs ring explore hypercube 
similarly omit hybrid expect offer performance similar ring 
points increasing domain sizes held fixed varies 
results organized questions question effective pns prs 
shows results pns prs pns prs versions xor ring 
cases pns pns prs provide optimal performance prs little limit number exit points large case ring 
pns far effective prs 
combining prs pns helps somewhat ring xor 
ineffectiveness prs isn surprising simulated system size node neighbors 
domain size large fraction total population neighbors domain prs little effect 
question answer change considering pns 
left shows results pns prs pns prs versions ring 
sampling limited proximity neighbor selection ideal effectiveness greatly reduced 
fact prs pns equally ineffective 
combination pns prs effective particularly moderate sized domains 
domain size small limited amount sampling choosing neighbors routes isn help 
combination pns prs increases level sampling effectiveness kicks lower values prs play important role local convergence domain sizes interest small sampling implement pns limited 
question performance various geometries compare 
right compares results pns tree pns prs ring pns prs xor 
seen perform roughly 
path latency biggest difference geometries accommodate pns prs 
results suggest relevance prs depends pns closely approximated closely pns 
implementing prs provides significant value prs may needed pns provides performance pns prs 
propose methods efficiently approximating pns known better pns scenarios 

discussion introduced new dht algorithms theorems 
hope provided pieces insight useful dht routing designs 
high level findings summarized follows component analysis comparing dht algorithms advocate analyzing component design decisions separately comparing dhts black boxes turn key systems 
particular requires separating systems level design decisions usually independent routing design decisions 
philosophy science think approach effective picking best current design conducive creating better designs 
number exit points size isolated domain pns xor prs xor pns prs xor number exit points size isolated domain pns ring prs ring pns prs ring number exit points system size varying sizes isolated domains 
left graph shows results pns prs pns prs versions xor right graph shows results pns prs pns prs versions ring 
number exit points pns ring prs ring pns prs ring pns prs ring size isolated domain number exit points size isolated domain pns tree pns prs ring pns prs xor number exit points system size varying sizes isolated domains 
left graph shows results pns prs pns prs versions ring right graph shows results pns tree pns prs ring pns prs xor 
routing geometry fundamental choice routing geometry constrains routing design issues 
myriad detailed routing designs explored space routing geometries limited 
reach consensus best routing geometry reaching consensus various design details 
flexibility important important difference noticed geometries butterfly geometry ability achieve log paths neighbors degree flexibility offer 
flexibility describes amount freedom available choose neighbors hop paths 
freedom turn affects performance areas static resilience path latency local convergence 
ring xor flexible ring xor geometries ones tested freely choose neighbors routes implement pns prs 
pns significantly effective prs dealing proximity times saw section prs important complement pns 
ability support advantage 
ring 
ring geometry flexibility addition provides natural support sequential neighbors 
achieved highest performance resiliency tests geometry proximity metrics path length local convergence 
investigation showed advantage geometries slight advantage ring 
initial inclination favor complicated geometries question ring geometries 
pose question 
done definitive judgements drawn 
investigation incomplete aspects 
example study extended wider class routing geometries theoretical bounds derived simulation results impact routing geometry particular symmetry lack thereof cost maintaining associated overlay structure studied 
view step fundamental investigation routing algorithms 

wish anonymous reviewers shepherd antony rowstron feedback suggestions 
malkhi david help implementation viceroy 

castro jones anne marie kermarrec rowstron theimer wang wolman 
evaluation scalable application level multicast built peer peer overlays 
proceedings infocom san francisco april 
miguel castro peter hu antony rowstron 
exploiting network proximity peer peer networks 
technical report msr tr microsoft research 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proceedings th acm symposium operating systems principles sosp lake louise ab canada october 
peter druschel antony rowstron 
storage management caching past large scale persistent peer peer storage utility 
proceedings th acm symposium operating systems principles sosp lake louise ab canada october 
iris infrastructure resilient internet systems 
iris lcs mit edu may 
david karger frans kaashoek 
simple constant space distributed hash tables 
proceedings iptps berkeley february 
gupta barbara liskov rodrigo rodrigues 
hop lookups peer peer overlays 
proceedings hotos ix hawaii may 
kirsten hildrum john kubiatowicz satish rao ben zhao 
distributed object location dynamic environment 
proceedings acm spaa 
jain mahajan david wetherall 
study performance potential dht overlays 
proceedings th usenix symposium internet technologies systems usits seattle wa usa march 
david karger matthias ruhl 
finding nearest neighbours growth restricted metrics 
proceedings acm stoc montreal may 
kleinberg 
small world phenomenon algorithmic perspective 
proceedings acm stoc 
john kubiatowicz 
oceanstore architecture global scalable persistent storage 
proceedings asplos cambridge ma usa november 
loguinov kumar vivek rai sai ganesh 
graph theoretic analysis structured peer peer systems routing distances fault resilience 
proceedings acm sigcomm conference karlsruhe germany august 
malkhi moni naor david 
viceroy scalable dynamic emulation butterfly 
proceedings podc 
maymounkov david mazieres 
kademlia peer peer information systems xor metric proceedings iptps boston march 
greg plaxton rajaraman andrea richa 
accessing nearby copies replicated objects distributed environment 
proceedings acm spaa june 
caida skitter measurement project 
www caida org tools measurement skitter index html 
sylvia ratnasamy 
scalable content addressable network 
phd thesis university california berkeley october 
sylvia ratnasamy paul francis mark handley richard karp scott shenker 
scalable content addressable network 
proceedings acm sigcomm technical conference san diego ca usa august 
sylvia ratnasamy mark handley richard karp scott shenker 
application level multicast content addressable networks 
proceedings ngc 
sylvia ratnasamy mark handley richard karp scott shenker 
topologically aware overlay construction server selection 
proceedings infocomm 
antony rowstron peter druschel 
pastry scalable distributed object location routing large scale peer peer systems 
ifip acm international conference distributed systems platforms middleware pages november 
stefan saroiu krishna gummadi steven gribble 
measurement study peer peer file sharing systems 
proceedings multimedia computing networking conference mmcn san jose ca usa january 
john kubiatowicz sean rhea timothy roscoe 
dhts need application driven benchmarks 
proceedings iptps berkeley february 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
proceedings acm sigcomm san diego ca usa august 
marcel waldvogel roberto 
efficient topology aware overlay network 
proceedings hotnets princeton october 
ben zhao anthony joseph john kubiatowicz 
locality aware mechanisms large scale networks 
proceedings italy june 
zhao kubiatowicz joseph 
tapestry infrastructure fault resilient wide area location routing 
technical report ucb csd university california berkeley april 
shelley zhuang ben zhao anthony joseph randy katz john kubiatowicz 
bayeux architecture scalable fault tolerant wide area data dissemination 
proceedings nossdav 
