secure routing structured peer peer overlay networks miguel castro peter druschel ganesh antony rowstron dan wallach microsoft research thomson avenue cambridge cb fb uk microsoft com rice university main street ms houston tx usa structured peer peer overlay networks provide substrate construction large scale decentralized applications including distributed storage group communication content distribution 
overlays highly resilient route messages correctly large fraction nodes crash network partitions 
current overlays secure small fraction malicious nodes prevent correct message delivery overlay 
problem particularly serious open peer peer systems diverse autonomous parties preexisting trust relationships wish pool resources 
studies attacks aimed preventing correct message delivery structured peer peer overlays presents defenses attacks 
describe evaluate techniques allow nodes join overlay maintain routing state forward messages securely presence malicious nodes 
structured peer peer overlays chord pastry tapestry provide self organizing substrate large scale peer peer applications :10.1.1.28.5987
systems provide powerful platform construction variety decentralized services including network storage content distribution application level multicast 
structured overlays allow applications locate object probabilistically bounded small number network hops requiring node routing tables small number entries 
systems scalable faulttolerant provide effective load balancing 
fully realize potential paradigm overlay networks able support open environment mutually parties conflicting interests allowed join 
appears proc 
th usenix symposium operating sys tems design implementation boston ma december 
druschel cs rice edu closed system sufficiently large scale may unrealistic assume participating nodes compromised attackers 
structured overlays robust variety security attacks including case fraction participating nodes act maliciously 
nodes may mis route corrupt drop messages routing information 
additionally may attempt assume identity nodes corrupt delete objects supposed store behalf system 
consider security issues structured overlay networks 
describe attacks mounted overlays applications support design secure techniques thwart attacks 
particular identify secure routing key building block combined existing application specific security techniques construct secure decentralized applications structured overlays 
secure routing requires secure assignment node identifiers secure routing table maintenance secure message forwarding 
techniques problems show techniques secure routing maintained efficiently despite malicious participating nodes 
show overhead secure routing acceptable proportional fraction malicious nodes 
rest organized follows 
section gives background structured overlays specifies models assumptions defines secure routing 
sections attacks solutions assignment identifiers nodes routing table maintenance message forwarding respectively 
section explains overhead secure routing minimized self certifying data 
section discusses related section provides 
background models solution section background structured overlay protocols chord tapestry pastry 
space limitations prevent giving detailed overview protocol 
describe model structured overlay networks keep discussion independent particular protocol 
concreteness give overview pastry point relevant differences protocols 
describe models assumptions faulty nodes may behave 
define secure routing outline solution 
analyses techniques terms model apply structured overlays noted 
security performance techniques fully evaluated context pastry full evaluation techniques protocols 
routing overlay model define model structured routing overlay designed capture key concepts common overlays chord tapestry pastry 
model participating nodes assigned uniform random identifiers nodeids large id space set bit unsigned integers 
applicationspecific objects assigned unique identifiers called keys selected id space 
key mapped overlay unique live node called key root 
protocol routes messages key associated root 
route messages efficiently node maintains routing table nodeids nodes associated ip addresses 
node maintains neighbor set consisting number nodes nodeids near current node id space 
nodeid assignment random neighbor set represents random sample participating nodes 
fault tolerance application objects stored node overlay 
replica function maps object key set replica keys set replica roots associated replica keys represents random sample participating nodes overlay 
replica root stores copy object 
discuss existing structured overlay protocols relate model 
pastry pastry nodeids assigned randomly uniform distribution circular bit id space 
bit key pastry routes associated message live node nodeid numerically closest key 
pastry node keeps track neighbor set notifies applications changes set 
node state purpose routing nodeids keys thought sequence digits base configuration parameter typical value 
node routing table organized rows columns 
entries row routing table contain ip addresses nodes nodeids share digits node nodeid th nodeid digit node column row equals column row corresponds value th digit local node nodeid remains empty 
routing table entry left empty node appropriate nodeid prefix known 
depicts example routing table 
node maintains neighbor set called leaf set 
leaf set set nodes nodeids numerically closest node nodeid larger smaller nodeids current node id value constant nodes overlay typical value approximately log bn number expected nodes overlay 
leaf set ensures reliable message delivery store replicas application objects 
message routing routing step node seeks forward message node routing table nodeid shares key prefix digit bits longer prefix key shares node id node message forwarded node nodeid shares prefix key long current node numerically closer key node id appropriate node exists routing table neighbor set current node immediate neighbor message final destination 
shows path example message 
analysis shows expected number routing hops slightly log bn distribution tight mean 
simulation shows routing highly resilient crash failures 
achieve self organization pastry nodes dynamically maintain node state routing table neighbor set presence node arrivals node failures 
newly arriving node new nodeid initialize state asking existing pastry node route special message key 
message routed existing node nodeid numerically closest obtains neighbor set constructs routing table copying rows routing tables nodes encountered original route announces presence initial members neighbor set turn update neighbor sets routing tables 
routing table pastry node nodeid 
digits base represents arbitrary suffix 
similarly overlay adapt abrupt node failure exchanging small number messages log bn small number nodes 
chord tapestry briefly describe chord tapestry emphasis differences relative pastry 
tapestry similar pastry differs approach mapping keys nodes manages replication 
tapestry neighboring nodes namespace aware 
node routing table entry node matches key nth digit message forwarded node higher value nth digit modulo routing table 
procedure called surrogate routing maps keys unique live node node routing tables consistent 
tapestry direct analog neighbor set think lowest populated level tapestry routing table neighbor set 
fault tolerance tapestry replica function produces set random keys yielding set replica roots random points id space 
expected number routing hops tapestry log bn 
chord uses bit circular id space 
pastry chord forwards messages clockwise direction circular id space 
prefix routing table pastry chord nodes maintain routing table consisting pointers live nodes called finger table 
ith entry finger table node refers live node smallest nodeid clockwise entry points successor subsequent entries refer nodes repeatedly doubling distances node chord maintains pointers predecessor successors nodeid space successor list represents neighbor fc route ba da routing message node key 
dots depict live nodes pastry circular namespace 
set model 
pastry chord replica function maps object key nodeids neighbor set key root replicas stored neighbor set key root fault tolerance 
expected number routing hops chord log 
routes messages dimensional space node maintains routing table entries routing hops node reached average 
entries node routing table refer neighbors dimensional space 
neighbor table duals routing table neighbor set model 
tapestry replica function produces random keys storing replicas diverse locations 
pastry tapestry chord routing table grow network size number routing hops grows faster logn case 
tapestry pastry construct overlay internet topology aware manner reduce routing delays network utilization 
protocols routing table entries chosen arbitrarily entire segment nodeid space increasing expected number routing hops 
protocols exploit initializing routing table refer nodes nearby network topology appropriate nodeid prefix 
greatly facilitates proximity routing :10.1.1.28.5987
systems vulnerable certain attacks shown section 
choice entries chord routing tables tightly constrained 
routing table entries refer specific neighboring nodes dimension chord finger table entries refer specific points nodeid space 
proximity routing harder protects nodes attacks exploit attacking nodes proximity victims 
system model system runs set nodes form overlay protocols described previous section 
assume bound fraction nodes may faulty 
faults modeled constrained collusion byzantine failure model faulty nodes behave arbitrarily may necessarily operating single conspiracy 
set faulty nodes partitioned independent coalitions disjoint sets size bounded cn 
faulty nodes may collude cause damage system 
model case nodes grouped multiple independent coalitions setting members coalition corrupt overlay unaware nodes coalitions 
studied behavior system ranging model different failure scenarios 
assume node overlay static ip address contacted 
ignore nodes dynamically assigned ip addresses nodes network address translation boxes firewalls 
overlays extended address concerns focuses traditional network hosts 
nodes communicate normal internet connections 
distinguish types communication network level nodes communicate directly routing overlay overlay level messages routed overlay protocols discussed previous section 
cryptographic techniques prevent adversaries observing modifying network level communication correct nodes 
adversary complete control network level communication nodes controls 
compromise communication routed faulty node 
adversaries may delay messages correct nodes assume message sent correct node correct destination overlay route faulty nodes delivered time probability pd secure routing define secure routing primitive combined existing techniques construct secure applications structured overlays 
subsequent sections show implement secure routing primitive fault network models described previous section 
routing primitives implemented current structured overlays provide best effort service deliver message replica root associated key 
malicious overlay nodes message may dropped corrupted may delivered mali node legitimate replica root 
primitives construct secure applications 
example inserting object application ensure replicas placed legitimate diverse replica roots opposed faulty nodes impersonate replica roots 
applications cryptographic methods authenticate objects malicious nodes may corrupt delete deny access supply stale copies replicas object 
address problem define secure routing primitive 
secure routing primitive ensures non faulty node sends message key message reaches non faulty members set replica roots rk high probability 
rk defined set nodes contains member set replica keys associated live root node responsible replica key 
pastry instance rk simply set live nodes nodeids numerically closest key 
secure routing ensures message eventually delivered despite nodes may corrupt drop message message delivered legitimate replica roots key despite nodes may attempt impersonate replica root 
secure routing combined existing security techniques safely maintain state structured overlay 
instance self certifying data stored replica roots byzantine fault tolerant replication algorithm bft maintain replicated state :10.1.1.127.6130:10.1.1.127.6130
secure routing guarantees replicas initially placed legitimate replica roots lookup message reaches replica exists 
similarly secure routing build secure services maintaining file metadata user quotas distributed storage utility 
details services scope 
implementing secure routing primitive requires solution problems securely assigning nodeids nodes securely maintaining routing tables securely forwarding messages 
secure nodeid assignment ensures attacker choose value nodeids assigned nodes attacker controls 
attacker arrange control replicas object mediate traffic victim node 
secure routing table maintenance ensures fraction faulty nodes appear routing tables correct nodes exceed average fraction faulty nodes entire overlay 
attacker prevent correct message delivery relatively small number faulty nodes 
secure message forwarding ensures copy message sent key reaches correct replica root key high probability 
sections describe solutions problems 
secure nodeid assignment performance security structured overlay networks depend fundamental assumption uniform random distribution nodeids controlled attacker 
section discusses goes wrong attacker violates assumption problem addressed 
attacks attackers choose nodeids compromise integrity structured overlay needing control particularly large fraction nodes 
example attacker may partition pastry chord overlay controls complete disjoint neighbor sets 
attackers may target particular victim nodes carefully choosing nodeids 
example may arrange entry victim routing table neighbor set point hostile node chord overlay 
point victim access overlay network completely mediated attacker 
attackers choose nodeids control access target objects 
attacker choose closest nodeids replica keys particular target object controlling replica roots 
result attacker delete corrupt deny access object 
attackers choose nodeids may able mount attacks obtain large number legitimate nodeids easily 
known sybil attack :10.1.1.17.1073
previous approaches nodeid assignment assumed nodeids chosen randomly new node compute nodeids hashing ip address node 
approach secure attacker opportunity choose nodeids necessarily random choose ip address hashes desired interval nodeid space 
particularly ipv deployed modest attackers potential ip addresses disposal nodes network 
solution certified nodeids solution securing assignment nodeids delegate problem central trusted authority 
set trusted certification authorities cas assign nodeids principals sign nodeid certificates bind random nodeid public key speaks principal ip address 
cas ensure nodeids chosen randomly id space prevent nodes forging nodeids 
furthermore certificates give overlay public key infrastructure suitable establishing encrypted authenticated channels nodes 
conventional cas offline reduce risk exposing certificate signing keys 
involved regular operation overlay 
nodes valid nodeid certificates join overlay route messages leave repeatedly involvement cas 
ca infrastructure ca public keys known installed part node software done current web browsers 
inclusion ip address certificate deserves explanation 
protocols tapestry pastry measure network delay nodes choose routing table entries minimize delay 
attacker multiple legitimate nodeid certificates freely swap certificates nodes controls able increase fraction attacker nodes target node routing table 
binding nodeid ip address harder attacker move nodeids nodes 
allow multiple nodeid certificates ip address ip addresses nodes may change attackers deny service hijacking victim ip addresses 
downside binding nodeids ip addresses node ip address changes result dynamic address assignment host mobility organizational network changes node old certificate nodeid invalid 
systems ip addresses allowed change dynamically nodeid swapping attacks may unavoidable 
certified nodeids nodes fixed nodeids case chord pastry tapestry 
harder secure nodeid assignment 
nodeids represent zone ddimensional space split half new node joins 
nodeid original node nodeid joining node change process 
sybil attacks nodeid assignment ca ensures nodeids chosen randomly important prevent attacker easily obtaining large number nodeid certificates 
solution require attacker pay money certificates credit card suitable mechanism 
solution cost attack grows naturally size network 
example nodeid certificates cost controlling overlay nodes costs cost rises nodes 
cost targeted attacks higher costs expected obtain closest nodeid particular point id space overlay nodes 
apart making attacks economically expensive fees fund operation cas 
solution bind nodeids real world identities charging money 
practice different forms cas suitable different situations 
identity ca preferred solution virtual private overlays run organization maintains employment membership records strong identity checks 
open internet deployment money ca may suitable avoids complexities authenticating real world identities 
known solutions nodeid assignment effective overlay network small 
small overlay networks require members network trusted cheat 
network reaches critical mass sufficiently hard attacker resources control significant fraction overlay untrusted nodes allowed join 
rejected distributed nodeid generation cas represent points failure vulnerable technical legal attacks 
networks may cumbersome require users spend money prove real world identities 
desirable construct secure overlays requiring centralized authorities fees identity checks 
unfortunately fully decentralized nodeid assignment appears fundamental security limitations :10.1.1.17.1073
methods aware ultimately prevent determined attacker acquiring large collection nodeids 
techniques may able minimum moderate rate attacker acquire nodeids 
possible solution require prospective nodes solve crypto puzzles gain right nodeid approach taken address number denial service attacks 
unfortunately cost solving crypto puzzle acceptable slowest legitimate node puzzle hard sufficiently slow attacker access fast machines 
conflict limits effectiveness technique 
completeness briefly describe relatively simple approach generate certified nodeids completely distributed fashion crypto puzzles 
idea require new nodes generate key pair property sha hash public key bits zero 
expected number operations required generate key pair properties public key cryptography allow nodes secure hash public key nodeid 
hash computed sha different initialization vector md avoid reducing number random bits nodeids 
nodes prove performed required amount nodeid revealing information allow reuse 
value set achieve desired level security 
possible bind ip addresses nodeids avoid attacks overlays exploit network locality 
idea require nodes consume resources order able nodeid ip address 
requiring nodes find string sha sha nodeid bits equal zero 
nodes required pair nodeid accepted 
possible periodically invalidate nodeids having trusted entity broadcast overlay message supplying different initialization vector hash computations 
harder attacker accumulate nodeids time reuse nodeids computed overlay overlay 
requires legitimate nodes periodically spend additional time communication maintain membership overlay 
secure routing table maintenance turn attention problem secure routing table maintenance 
routing table maintenance mechanisms create routing tables neighbor sets joining nodes maintain creation 
ideally routing table neighbor set average fraction random entries point nodes controlled attacker called bad entries 
attackers increase fraction bad entries supplying bad routing updates reduces probability routing successfully replica roots 
preventing attackers choosing nodeids necessary avoid problem sufficient illustrated attacks discussed 
discuss solutions problem 
attacks attack aimed routing algorithms network proximity information improve routing efficiency attackers may fake proximity increase fraction bad routing table entries 
example network model assumed allows attacker control communication faulty nodes controls 
correct node sends probe estimate delay faulty node certain nodeid attacker intercept probe faulty node closest reply 
attacker controls faulty nodes spread internet nodes controls appear close correct nodes increase probability routing 
attack harder maximal fraction colluding nodes small large 
attack ruled restrictive communication model nodeid certificates bind ip addresses nodeids see section 
example faulty nodes observe messages sent ip address attack prevented 
note rogue isp offices world easily perform attack configuring routers appropriately 
attack possible form indirection attacker control mobile ipv 
second attack manipulate proximity information 
exploits fact hard determine routing updates legitimate overlay protocols tapestry pastry 
nodes receive routing updates join overlay nodes join fetch routing table rows nodes routing table periodically patch holes reduce hop delays 
systems attackers easily supply routing updates point faulty nodes 
simple attack causes fraction bad routing table entries increase bad routing updates propagated 
precisely routing updates correct nodes point faulty node probability probability high routing updates faulty nodes 
correct nodes receive updates correct nodes probability faulty nodes probability probability routing table en try faulty update greater effect cascades subsequent update causing fraction faulty entries tend 
systems strong constraints set nodeids fill routing table slot vulnerable attack 
pastry tapestry impose weak constraints top levels routing tables 
flexibility hard determine routing updates unbiased allows systems effectively exploit network proximity improve routing performance 
chord impose strong constraints nodeids routing table entries need closest nodeids point id space 
hard exploit network proximity improve performance security attackers choose nodeids control probability attacker controls nodeid closest point id space solution constrained routing table enable secure routing table maintenance important impose strong constraints set nodeids fill slot routing table 
example entry slot constrained closest nodeid point id space chord 
constraint verified independent network proximity information manipulated attackers 
solution propose uses routing tables exploits network proximity information efficient routing pastry tapestry constrains routing table entries chord 
normal operation routing table forward messages achieve performance 
second efficient routing technique fails 
test section detect routing fails 
modified pastry solution 
normal locality aware pastry routing table additional constrained pastry routing table 
locality aware routing table node identifier slot level domain contain nodeid shares digits value st digit 
constrained routing table entry constrained point closest nodeid point domain 
define follows shares digits value st digit remaining digits pastry message forwarding works constrained routing table modifications 
true tapestry 
algorithms initialize maintain routing table modified follows 
overlay routing algorithms rely bootstrap node initialize routing state newly joining node 
bootstrap node responsible routing message nodeid joining node key 
bootstrap node faulty completely corrupt view overlay network seen new node 
necessary set diverse bootstrap nodes large ensure high probability correct 
nodeid certificates task choosing set easier attacker forge nodeids 
newly joining node picks set bootstrap nodes asks route nodeid key 
non faulty bootstrap nodes secure forwarding techniques described section obtain neighbor set joining node 
node collects proposed neighbor sets bootstrap nodes picks closest live nodeids proposed set neighbor set definition closest protocol specific 
locality aware routing table initialized collecting rows nodes route nodeid 
difference routes picks entry minimal network delay set candidates receives routing table slot 
entry constrained routing table initialized secure forwarding obtain live nodeid closest desired point id space 
similar done chord 
problem quite expensive recall controls number columns routing table tapestry pastry 
reduce overhead take advantage fact induction constrained routing tables nodes neighbor set point entries close desired point collect routing tables nodes neighbor set initialize constrained routing table 
set candidates receives entry picks nodeid closest desired point entry 
side effect process informs nodes neighbor set arrival 
exploit symmetry constrained routing table inform nodes need update routing tables reflect arrival checks neighbor set set candidates entry determine candidates update routing table entries point informs candidates arrival 
ensure neighbor set stabilization absence new joins leaves informs members neighbor set changes periodically retransmits information receipt acknowledged 
secure message forwarding certified nodeids secure routing table maintenance ensure constrained routing table neighbor set average fraction random entries point nodes controlled attacker 
routing constrained routing table sufficient attacker reduce probability successful delivery simply forwarding messages algorithm 
attack effective small show 
section describes efficient solution problem 
attacks structured overlays provide primitive send message key 
absence faults message delivered root node key average routing hops 
routing may fail nodes route sender root faulty faulty nodes may simply drop message route message wrong place pretend key root 
probability routing successfully correct nodes fraction nodes faulty independent root node key may faulty 
discussed applications tolerate root faults replicating information associated key nodes replica roots 
probability routing successfully correct replica root value depends overlay log pastry tapestry 
chord log ran simulations pastry validate model 
model predicts probability success slightly lower probability observed simulations number pastry hops slightly prob 
successful routing fraction nodes compromised probability routing correct replica 
log average error 
plots probability routing correct replica pastry computed model different values 
probability drops quite fast increase 
nodes compromised probability successful routing nodes pastry overlay 
pastry tapestry applications reduce number hops increasing value fewer hops increase probability routing correctly 
example probability successful delivery nodes pastry 
increasing increases cost routing table maintenance high probability routing success requires impractically large value chord currently uses fixed results low probability success probability conditions 
solution detect faults diverse routes results show important devise mechanisms route securely 
want secure routing primitive takes message destination key ensures high probability copy message reaches correct replica root key 
question efficiently 
approach route message efficiently apply failure test determine routing worked 
expensive redundant routing failure test returns positive 
detail secure routing primitive routes message efficiently root destination key locality aware routing table 
collects prospective set replica roots prospective root node applies failure test set 
test negative prospective replica roots accepted correct ones 
positive message copies sent diverse routes various replica roots high probability correct replica root reached 
start ing implement failure test 
explain redundant routing rejected alternate approach called iterative routing 
routing failure test failure test takes key set prospective replica roots key 
returns negative set roots correct key 
returns positive 
course routing fail sender receiving set prospective replica roots 
sender detects starting timer sends message 
receive response timer expires failure test returns positive triggering redundant routing 
detecting routing failures difficult coalition faulty nodes pretend legitimate replica roots key 
replica roots determined structure overlay node nodeid far key rely overlay routing determine correct set replica roots 
message routed faulty node adversary fabricate credible route replica root set contain nodes controls 
furthermore case adversary just happens legitimately control actual replica roots 
problem common structured overlay protocols 
routing failure test observation average density nodeids unit volume id space greater average density faulty nodeids 
test works comparing density nodeids neighbor set sender density nodeids close replica roots destination key 
describe test detail context pastry simplify presentation generalization overlays straightforward 
overlays distribute replica keys key uniformly id space check comparing density sender average distance replica key root nodeid 
pastry set replica roots key subset neighbor set key root node called key root set 
correct node computes average numerical distance consecutive nodeids neighbor set 
neighbor set contains live nodes nodes closest nodeids nodes closest nodeids greater test prospective root neighbor set id rn key checks idl 
nodeids rn valid nodeid certificate closest nodeid key middle nodeids satisfy definition neighbor set 
average numerical distance rn consecutive nodeids rn satisfies rn rn satisfies conditions test returns negative returns positive 
test inaccurate ways return false positive prospective root neighbor set correct return false negative prospective set incorrect 
call probability false positives probability false negatives 
parameter controls tradeoff 
intuitively increasing decreases increases 
assuming live nodes nodeids uniformly distributed id space length distances consecutive nodeids approximately independent exponential random variables mean large holds distances consecutive nodeids faulty nodes collude mean interesting note independent depend upper bound fraction colluding nodes faulty nodes know identities faulty nodes collude 
assumptions derived expressions compute see detailed derivation appendix un expressions compute nu 
computed closed form upper bounds exp log log exp log log number distance samples compute number distance samples compute rn test analysis shows independent provided test accuracy improved increasing number distance samples compute means 
easy increase number samples compute augmenting mechanism place stabilize neighbor sets 
mechanism propagates nodeids added removed neighbor set members set extended propagate nodeids omit details due lack space 
hard increase number samples compute rn attacks describe 
keep ran simulations evaluate effectiveness routing failure test 
simulations ran system random nodeids 
plots values different values alpha beta beta upper bound beta predicted beta measured alpha measured alpha predicted alpha upper bound gamma routing failure test probability false positives negatives 
predicted curves indistinguishable simulation measurements upper bounds tight 
number samples sender number root neighbors 
shows predicted values computed numerically upper bounds values measured simulations 
predicted curves match measured curves exactly upper bounds tight 
minimum error obtained equal case 
attacks attacks invalidate analysis weaken routing failure test 
attacker collect nodeid certificates nodes left overlay increase density prospective root neighbor set 
second attacker include nodeids nodes controls nodeids correct nodes prospective root neighbor set 
attacks reduce probability messages reach correct replica roots 
second attack harder counter overlays distribute replica keys id space replica roots detailed knowledge nodeids close replica keys 
attacks avoided having sender contact prospective root neighbors determine live nodeid certificate omitted prospective root neighbor set 
implement efficiently prospective root returns sender message list nodeid certificates list secure hashes neighbor sets reported prospective root neighbors set nodeids prospective root neighbor set compute hashes list 
sender checks hashes consistent identifiers prospective root neighbors 
sends prospective root corresponding neighbor set hash confirmation 
absence faults root neighbors confirm hashes sender perform density com alpha beta percentage nodes compromised routing failure test minimum error probability nodeid suppression attacks varying number samples 
parison immediately 
sufficiently large timeout happens probability binomial distribution number root neighbors 
faulty nodes prospective root neighbor set routing failure test may require communication density check run 
studying best strategy deal case 
currently consider test failed prospective root neighbors don agree redundant routing 
may worthwhile investing additional communication reverting redundant routing 
addition attacks nodeid suppression attack unavoidable significantly decreases accuracy test 
attacker suppress nodeids close sender leaving overlay increases 
similarly attacker suppress nodeids root neighbor set increases 
furthermore attacker alternate modes honest nodes way detecting mode operating 
ran simulations compute minimum error probability nodeid suppression attacks different values probability error increases fast higher samples sender 
nodeid suppression attack increases minimum probability error large percentages compromised nodes probability error higher samples sender 
figures show results nodeid suppression attacks respectively 
results indicate routing failure test accurate 
fortunately trade increase achieve target redundant routing disambiguate false positives 
ran simulations determine minimum achieved target different values different numbers samples sender 
shows alpha beta percentage nodes compromised routing failure test minimum error probability nodeid suppression attacks varying number samples 
alpha beta percentage nodes compromised routing failure test probability false positives false negative rate nodeid suppression attacks varying number samples 
results nodeid suppression attacks 
results show test meaningful target nodeid suppression attacks 
setting samples sender enables routing failure test achieve target 
value nodeid suppression attacks increase 
nodeid suppression attacks value redundant routing required time 
redundant routing redundant routing technique invoked routing failure test positive 
idea simply route copies message multiple routes destination key replica roots 
copies message sent diverse routes replica key correct replica roots receive copy message high probability 
issue ensure routes diverse 
approach ask members sender neighbor set forward copies message replica keys 
technique sufficient overlays distribute replica keys uniformly id space tapestry 
sufficient overlays choose replica roots neighbor set key root chord pastry routes converge key root faulty 
overlays developed technique called neighbor set anycast sends copies message destination key reach node key root neighbor set 
uses detailed knowledge node portion id space destination key ensure correct replica roots receive copy message 
simplify presentation describe detail redundant routing works pastry 
correct node sends message destination key routing failure test positive sends messages destination key message forwarded different member neighbor set causes messages diverse routes 
messages forwarded constrained routing table include nonce 
correct node receives messages root neighbor set returns nodeid certificate nonce signed private key 
collects set nodeid certificates numerically closest left closest right 
certificates valid signed nonces added marked pending 
timeout replies received sends list nodeids node marked pending marks nodes done 
correct node receives list forwards original message nodes neighbor set list sends confirmation nodes 
may cause steps repeated 
received confirmation nodes step executed times computes set replica roots timeout sufficiently large correct nodes correct node half neighbor set probability reaching correct replica roots approximately equal probability anycast messages forwarded route faults correct node key root neighbor set 
assuming independent routes probability log bn binomial distribution successful routes trials probability routing successfully trial log counts neighbor set size chosen ensure high probability extra hop messages routed neighbor set member 
probability success technique depends independent ran simulations determine probability reaching correct replica roots redundant routing technique 
plots predicted probability probability measured simulator nodes 
analytic model matches results high success proba bilities 
results show probability success greater 
technique combined routing failure test achieve reliability approximately 
prob 
successful routing percentage nodes compromised measured predicted model simulation results probability reaching correct replica roots redundant routing neighbor set anycast 
studied versions redundant routing achieve probability success perform differently 
example signed nonces ensure nodeid certificates belong live nodes 
nodes avoid signing nonces periodically signing clock reading system loosely synchronized clocks signatures necessary attacker forge ip source addresses 
exploring design space 
example possible improve performance significantly sending anycast messages time version routing failure test 
approach reading data 
putting performance performance pastry secure routing primitive depends cost routing failure test cost redundant routing probability redundant routing avoided 
section presents analysis costs probability 
simplicity assume faulty nodes collude number probes redundant routing equal neighbor set size number samples source routing failure tests number nodes overlay 
cost routing failure test returns negative extra round trip delay messages 
total number bytes messages pss signing nodeid certificates bit modulus bit modulus node public keys nodeid certificate size 
extra bandwidth consumed routing failure test approximately kb kb plus space message headers 
test returns positive adds number messages bytes extra delay timeout period 
cost redundant routing depends value best case occurs root neighbor set added iteration 
case redundant routing adds log extra message delays log messages 
total number bytes messages log pss signing nonces signed nonce size 
extra bandwidth consumed case kb kb plus space message headers 
attack redundant routing adds delay timeout periods expected number extra messages log log bn expected number correct nodes root neighbor set added iteration 
expected number messages 
total number bytes sent attack similar best case value sender sends additional bytes nodeid lists number messages increases 
additional kb kb plus space message headers 
probability avoiding redundant routing probability overlay routes message correct replica root probability faulty nodes neighbor set root false positive rate log routing failure test 
assumes routing tables average random bad entries 
assumption holds locality aware routing table absence attacks discussed section holds constrained routing table attacks 
model effect attacks locality aware routing table believe hard mount small values 
prob 
redundant routing scenario scenario fraction nodes compromised probability avoiding redundant routing scenarios 
parameters set desired security level expressed probability correct replica roots receive copy message 
overlay size assignment values parameters implicitly define bound bound exceeded drop 
example saw 
redundant routing invoked time value faults 
trade security improved performance increasing reduce decreasing reduce cost routing failure test redundant routing increase 
example consider scenarios 
plots probability avoiding redundant routing scenarios different values faults redundant routing invoked time scenario 
common case fraction faulty nodes small routing failure test improves performance significantly avoiding cost redundant routing 
rejected checked iterative routing alternative redundant routing iterative routing suggested sit morris sender starts looking hop routing table setting variable point node sender asks hop updates point returned value 
process repeated value root destination key 
iterative routing doubles cost relative traditional recursive solution may increase probability routing successfully allows sender pick alternative hop fails receive entry node 
strong defense attacker provide faulty node hop 
iterative routing augmented hop tests check hop route correct 
hop tests effective systems chord pastry constrained routing table routing table entry contain nodeid closest specific point id space 
mechanism identical nodeid density checking routing failure test 
difference average distance consecutive nodeids close sender compared distance nodeid routing table entry desired point ran simulations compute false positive false negative rates approach different values rates independent 
example minimum error hop test equal approximately samples compute mean sender 
error high single sample destination hop 
simulations indicate iterative lookups pastry constrained routing table hop check improve probability routing successfully 
example probability routing suc samples compute mean sender improves 
adds extra hops route average false positives 
tried increase number samples having sender fetch entire routing table row iterative routing step revealing index required slot 
unfortunately performs worse obtaining single sample attacker combine bad routing table entries obtain high average density 
tried combine checked iterative routing redundant routing technique described 
checked iterative routing neighbor set anycast messages hope improved success probability iterative routes result improvement redundant routing recursive routes 
visible improvement iterative routes independent recursive routes 
conclude routing failure test combined redundant routing effective solution implementing secure routing 
self certifying data secure routing primitive adds significant overhead conventional routing 
section describe secure routing minimized self certifying data 
reliance secure routing reduced storing self certifying data overlay data integrity verified client 
allows clients efficient routing request copy object 
client receives copy object check integrity resort secure routing integrity check fails response timeout period 
self certifying data help inserting new objects overlay verifying object stored overlay 
cases secure routing primitive ensure correct replica roots reached 
similarly node joining requires secure routing 
self certifying data eliminate overhead secure routing common cases 
self certifying data systems 
example cfs uses cryptographic hash file contents key insertion lookup file past inserts signed files overlay 
technique extended support mutable objects strong consistency guarantees 
system past store self certifying group descriptors identify set hosts responsible replicating object 
group descriptors follows 
object creation time owner object uses secure routing insert group descriptor overlay key identifies object 
descriptor contains public keys ip addresses object replica holders signed owner 
replica group run byzantine fault tolerant replication algorithm bft initial group membership set replica roots associated key :10.1.1.127.6130:10.1.1.127.6130
setting read write operations performed follows client uses efficient routing retrieve group descriptor overlay checks descriptor signature correct uses information descriptor authenticate replica holders invoke replicated operation 
client fails retrieve valid descriptor fails authenticate replica holders uses secure routing primitive obtain correct group descriptor assert object exist 
procedure provides strong consistency guarantees linearizability reads writes avoiding routing failure test common case 
changing membership group responsible replicating object trivial requires securely inserting new group descriptor overlay ensuring clients reliably detect stale group descriptors 
technique allows groups change membership retaining strong consistency guarantees 
group hosts stores replicas object maintains private public key pair associated group 
group membership changes host new membership generates new key pair group hosts old membership old keys sign new group descriptor containing new keys delete old keys 
operation performed quorum replica holders bound number faulty group members exceeded old replica holders fail able collude pretend current group form quorum necessary authenticate client :10.1.1.127.6130
group descriptors authenticated signature chain starts owner signature signatures quorum replicas subsequent membership change 
chain shortened new signature owner alternatively replicas proactive signature sharing avoid need chaining signatures 
related sit morris framework performing security analyses networks 
adversarial model allows nodes generate packets arbitrary contents assumes nodes intercept arbitrary traffic 
taxonomy possible attacks 
routing layer identify node lookup routing table maintenance network partitioning virtualization security risks 
discuss issues higher level protocols file storage nodes may necessarily maintain necessary invariants storage replication 
discuss various classes denial service attacks including rapidly joining leaving network arranging nodes send bulk volumes data overload victim network connection distributed denial service attacks 
dingledine douceur discuss address spoofing attacks :10.1.1.17.1073
large number potentially malicious nodes system trusted central authority certify node identities difficult know trust claimed identity somebody communicated 
dingledine proposes address various schemes including micro cash allow nodes build reputations 
bellovin identifies number issues napster gnutella 
discusses difficult limit napster gnutella firewalls leak information users consider private search queries issue network 
bellovin expresses concern gnutella push feature intended firewalls useful distributed denial service attacks 
considers napster centralized architecture secure attacks requires users trust central server 
worthwhile mentioning elegant alternative solution secure routing table maintenance forwarding rejected 
solution replaces node group diverse replicas suggested lynch 
replicas coordinated state machine replication algorithm bft tolerate byzantine faults :10.1.1.127.6130:10.1.1.127.6130
bft replicate arbitrary state machines replicate pastry routing table maintenance forwarding protocols 
additionally algorithm provides strong consistency guarantees overlay routing maintenance 
disadvantages solution expensive faults resilient solution propose 
routing step expensive requires agreement protocol replicas 
replicas geographically dispersed reduce probability correlated faults agreement latency high 
additionally group replicas nodes faulty 
bound number faulty replicas group results relatively low probability successful routing 
probability replica group replicas correct fraction nodes pastry overlay compromised de notes binomial distribution successes trials probability success example probability replica group correct nodes compromised replicas 
example probability routing correctly nodes overlay 
structured peer peer overlay networks previously assumed fail model nodes node accessible network assumed correctly follow protocol 
nodes malicious conspire possible small number nodes compromise overlay applications built 
design analysis techniques secure node joining routing table maintenance message forwarding structured overlays 
techniques provide secure routing combined existing techniques construct applications robust presence malicious participants 
routing failure test allows efficient proximity aware routing common case resorting costly redundant routing technique test indicates possible interference attacker 
show secure routing reduced self certifying application data 
techniques allow tolerate malicious nodes providing performance fraction compromised nodes small 
acknowledgments wish robert morris rodrigo rodrigues fabien petitcolas shepherd david wetherall anonymous referees helpful comments 
wish adam discussions nodeid assignment problem 
supported part texas atp nsf ccr 
bellare rogaway 
exact security digital signatures sign rsa rabin 
advances cryptology eurocrypt lecture notes computer science vol 

springer verlag 
steve bellovin 
security aspects napster gnutella 
usenix annual technical conference boston massachusetts june 
invited talk 
miguel castro peter druschel charlie hu antony rowstron 
exploiting network proximity peer peer overlay networks 
technical report msr tr microsoft research may 
miguel castro barbara liskov :10.1.1.127.6130
practical byzantine fault tolerance 
proceedings third symposium operating systems design implementation osdi new orleans louisiana february 
ian clarke oskar sandberg brandon wiley theodore hong 
freenet distributed anonymous information storage retrieval system 
workshop design issues anonymity unobservability pages july 
icsi berkeley california 
thomas cormen charles leiserson ronald rivest 
algorithms 
mit electrical engineering computer science series 
mit press 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proc 
acm sosp banff canada october 
drew dean adam 
client puzzles protect tls 
th usenix security symposium pages washington august 
roger dingledine michael freedman david molnar 
accountability measures peer peer systems 
peer peer harnessing power disruptive technologies 
reilly associates november 
john douceur :10.1.1.17.1073
sybil attack 
proceedings st international workshop peer peer systems iptps cambridge massachusetts march 
herlihy wing 
axioms concurrent objects 
proceedings th acm symposium principles programming languages pages january 
herzberg jakobsson jarecki krawczyk yung 
proactive public key signature systems 
proc 
acm conference computers communication security 
ari juels john 
client puzzles cryptographic defense connection depletion attacks 
internet society symposium network distributed system security ndss pages san diego california february 
nancy lynch malkhi david 
atomic data access content addressable networks 
proceedings st international workshop peer peer systems iptps cambridge massachusetts march 
ralph merkle 
secure communications insecure channels 
communications acm april 
sylvia ratnasamy paul francis mark handley richard karp scott shenker 
scalable content addressable network 
proc 
acm sigcomm san diego california august 
antony rowstron peter druschel :10.1.1.28.5987
pastry scalable distributed object location routing large scale peer peer systems 
proc 
ifip acm middleware heidelberg germany november 
antony rowstron peter druschel 
storage management caching past large scale persistent peer peer storage utility 
proc 
acm sosp banff canada october 
emil sit robert morris 
security considerations peerto peer distributed hash tables 
proceedings st international workshop peer peer systems iptps cambridge massachusetts march 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm san diego california august 
ben zhao john kubiatowicz anthony joseph 
tapestry infrastructure fault resilient wide area location routing 
technical report ucb csd berkeley april 
appendix appendix describes analytic model probability false positives negatives routing failure test 
assume exist nodeids distributed uniformly random interval length large look nodeids closest arbitrarily chosen location interval location nodeids approximated distribution poisson process rate particular inter point distances approximately independent exponential random variables mean denote exponential distribution mean exponential distribution mean fraction faulty nodes 
suppose yk independent identically distributed iid drawn distributions required identify distribution drawn yk prospective set replica roots pastry trying determine set correct contains faulty nodes 
optimal hypothesis test comparing likelihood ratio threshold writing likelihood ratio see equivalent comparing sample mean denoted threshold situation unknown samples xn samples collect nodeids close sender id space 
propose hypothesis test choose threshold form constant accept reject hypothesis yi iid comparing threshold 
compute false positive probability false negative probability test 
denote assume loss generality integer 
define zi yi xir note zi iid random variables 
denote sum iid exponential random variables mean event event zi 
zi sk sn write denote probabilities yi distribution 
recalling gamma distribution shape parameter scale parameter rewrite un vk change variables obtain equality 
expression compute numerically 
derive simple closed form expression upper bound 
bound shows decays exponentially sample size fact captures exact exponential rate decay 
arbitrary chernoff bound exp zi exp exponential distribution mean 
log log log rk tightest upper bound obtained minimising expression right minimum attained substituting yields bound exp log log derive expression false negative probability similar lines 
yi iid distribution exponentially distributed mean interested event 
happens fail reject hypothesis yi distribution 
zi write denote probabilities yi exponential mean case distribution yi distribution xi obtain rk allows compute numerically combining obtain closed form upper bound exp log log 
