correspondence continuation passing style static single assignment form richard kelsey nec research institute kelsey research nj nec com define syntactic transformations convert continuation passing style cps programs static single assignment form ssa vice versa 
cps programs converted ssa produced usual cps transformation 
cps ssa transformation especially helpful compiling functional programs 
optimizations normally require flow analysis performed directly functional cps programs viewing ssa programs 
simple program transformation merges cps procedures doing greatly increases scope ssa flow information 
transformation useful analyzing loops expressed recursive procedures 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
ir san francisco california usa proceedings acm sigplan notices march fl acm continuation passing style intermediate language number compilers functional languages 
static single assignment form optimizations targeted imperative languages example eliminating induction variables partial redundancies 
define syntactic transformations converting continuation passing style cps programs static single assignment form ssa vice versa 
similarities cps ssa noted 
cps exactly binding form variable variable uses lexically scoped 
ssa exactly assignment statement variable statement dominates uses variable 
main difference restriction variable cps lexical ssa dynamic 
forms generally different contexts 
cps compilers functional languages ssa imperative ones 
result problem flow analysis come viewed difficult cps 
really artifact programs compiled problem cps intermediate language 
functional programs express control flow procedures resulting large collections small procedures opposed small collections large procedures imperative languages large procedure mean large contain loop 
writers compilers imperative languages quite successful ssa express results intraprocedural flow analysis analyzing ssa program 
cps uses procedures express practically local optimization appears require interprocedural analysis hard language 
going concern interprocedural flow analysis 
restrict notion constitutes procedure cps 
forms cps programs annotated indicate represent full procedures continuations 
reduces number full procedures greatly simplifies analyzing program 
assume lexical scoping source program implemented introducing explicit environments described 
assume cps programs continuations created manner see section discussion 
restriction affects way nonlocal returns call continuation scheme expressed cps 
proceeds follows 
section contains definition ssa language 
section defines source language annotated cps language algorithm converting source programs cps programs 
sections define functions convert cps procedures ssa procedures vice versa 
remainder discussion practical differences ssa cps followed comparison previous 
static single assignment ssa imperative form exactly assignment variable assignment dominates uses variable see overview ssa 
control flow graph explicit control flow expressed entirely terms goto 
allow expressions nonstandard places example arguments oe functions removing requires introducing additional assignment statements 
syntax expressions matter left unspecified restriction may contain procedure calls typically don ssa languages 
grammar procedure ssa language proc oe goto return return ej variables labels semantics obvious 
assignment procedure call return returns current procedure 
oe functions block take argument goto jump block 
th argument returned control reaches block goto cytron describe translation algorithm efficiently converts programs ssa introducing minimum number oe functions 
variable unique assignment definition chains trivial compute 
analyses optimizations simpler applied program ssa form original source program 
example ssa procedure counts number times zero appears sequence limit function integer limit 
note computation occurs oe functions 
particular second sense context oe function label example 
proc limit goto oe oe limit return goto goto oe goto annotated cps continuation passing style procedures return 
passed additional argument continuation applied procedure return value see chapter full discussion 
correspondence cps ssa requires slightly modified algorithm converting programs cps 
modified algorithm annotates forms cps code show 
annotations semantic content introduced cps algorithm added program suitable analysis assuming cps program suitable form see section 
source language subset scheme subset chosen compromise simplicity realism 
simplicity assume source cps languages expressions ssa language previous section 
context scheme programs refer equivalents ssa expressions trivial expressions keep confusing scheme expressions 
described main restriction trivial expressions contain procedure calls 
simplify cps algorithm source language restricted allow non trivial expressions tail position bound value 
actual compiler source program put form pre pass part complex cps algorithm 
assume identifier unique 
loop expression version scheme named restriction calls label may occur tail position 
included show iterative constructs loops may converted cps 
grammar scheme subset loop variables labels semantics source language scheme 
subset sufficient implement scheme explicit cells added variables targets set 
expressions source program 
done rabbit compiler theta cont bound letrec cont cont letrec jump new loop initial letrec jump initial proc conversion cps conversion cps treat trivial expressions values introduce continuations 
cps grammar annotated proc cont jump 
annotations indicate equivalently compiled 
proc translation forms source program 
full procedures eventually return value reason take continuation argument 
cont jump forms continuations slightly different ways 
cont continuations return points calls proc 
jump indicates continuation called current procedure passed 
cps algorithm introduces jump continuations arms conditional rejoin common point bodies loop 
terms compilation strategy cont return points jump compiled gotos proc require complete procedure call mechanism 
grammar cps language follows letrec cont proc jump variables semantics obvious call value semantics 
annotated just syntactic sugar 
identifiers grammar members syntactic class 
making syntactically distinct done restricts continuations cps ssa entirely equivalent see section 
function defined translates proc limit letrec jump limit cont letrec jump example program cps source expressions cps expressions takes continuation identifier cont second argument 
rules applications 
rule continuation argument identifier bound letrec rule ensures uses identifiers called directly 
second cases 
new continuation created value 
identifier continuations propagated avoid code expansion continuations opposed continuations just identifier marked jump bound identifier 
loop translated recursive continuation 
loop begins calling continuation initial values iterative variables 
calls loop label calls recursive continuation ignoring current continuation 
interested interprocedural analysis treat proc separate program depend assumption explicit environments introduced take care lexical scoping nested proc 
called point created cont considered inlined procedures 
call sites jump easily jump occur bound value letrec 
furthermore variables jump bound calls variables 
sample ssa procedure written source language cps transformation limit loop limit presents cps version procedure 
cont introduced continuation call jump join point loop 
converting cps ssa section define syntactic translation converts cps procedures ssa procedures 
function translates nontrivial cps expressions ssa statements 
cont return return goto letrec proc proc proc proc jump jump jump theta jump jump jump oe translation cps ssa 
right hand side definition jump left hand side definition 
simple binding forms cont assignments 
essentially syntaxes 
uses proc continuation variable return calls letrec bound continuation variables translated gotos 
jump program ignored jump lifted labeled block ssa procedure 
arguments jump ignored arguments oe function defines value corresponding variable ssa program 
definition jump argument second call arbitrary ordering variable bound jump 
call translated goto translated program syntactically correct obeys ssa restriction exactly assignment variable variable bound exactly cps program variables translated program assigned values expressions bound cps program evaluation order preserved programs produce identical results 
applying proc cps example produces original ssa example 
converting ssa cps produce inverse convert ssa programs cps 
function produced simple editing definition inverse difficulty rule letrec bind jump 
translating jump labeled blocks ignores position cps program 
translating labeled block back jump straightforward need bind jump letrec newly created cps program 
jump need placed variable referred outside form binds 
placement algorithm uses dominator tree ssa program 
statement said dominate appears execution path start program dominates dominates vice versa 
dominator relation organizes program statements tree 
immediate dominator parent dominator tree 
labeled block ssa cont return return goto proc proc proc fb proc jump 
jump jump oe jump translation ssa cps 
right hand side definition goto left hand side definition jump program immediate dominator replace letrec jump cps procedure 
labels immediate dominator jump placed single letrec 
theorem uses variables cps program produced properly scope 
proof know variable ssa program dominated variable assignment statement 
assignment statements ssa program correspond binding forms cps program 
inspection preserves dominator tree sufficient show statement cps program lexically inferior immediate dominator dominators including binding forms referenced variables 
inspecting definition see produced body proc cont arm lexically inferior immediate dominator 
remaining possible location body jump jump construction lexically inferior dominators immediate dominator 
lead problem immediate dominator binding form happen 
cont dominates jump 
arguments oe functions placed lexically inferior dominators 
qed 
convert original ssa example cps produces program identical cps program shown 
cps ssa identical function applied cps programs 
depends correctly annotated turn depends continuations somewhat restricted fashion 
non local returns current continuation scheme translated uses continuations cps program way label continuations 
simply passed procedure continuation calls calls procedure created cont jump appropriate 
fourth annotation introduced proc limit letrec proc limit cont letrec jump example program scheme named translated cps 
continuations created procedure called 
direct way represent program ssa 
compiling imperative programs shown programs translated cps ssa programs series syntactic transformations 
producing ssa program normally requires flow analysis program directly expresses definition chaining 
flow information cps program coming 
source program cps transformation functional program contained required flow information 
started imperative program meaning set 
modify values variables translation cps source language required adding explicit cells hold values variables targets set 
expressions 
jump resulting cps program take arguments oe functions corresponding ssa program lot stores fetches 
transforming program useful form require doing flow analysis similar done translating imperative programs ssa 
compiling functional programs programs side affect values variables viewing cps procedures ssa procedures shows cps nicely reflects intraprocedural definition associations need flow analysis 
problem 
programs written languages ml scheme tend side affected variables making dataflow visible discussed 
difficulty languages recursion express iteration 
iterative constructs loop cps source language 
get intraprocedural flow information free really want interprocedural information 
interprocedural analysis difficult take approach increasing size procedures 
idea find set procedures called continuation substitute continuation procedures continuation variables 
procedures continuations nested single large procedure removing need interprocedural information 
precisely set procedures bound letrec forms identifiers continuation tail recursive call non tail recursive call passed continuation perform transformation 
proc 
cont new identifier identifier identifier 

replace remove variable lists changing proc jump 

remove continuation calls 
smallest form containing non tail recursive call replace letrec binds cont binds original binding form lexically apparent restricted having bound letrec called directly opposed passed procedure called example purely syntactic transformation 
sophisticated versions clearly possible 
simple syntactic version applies common uses recursive procedures 
cps source program scheme named syntax restricted loop version applying produce program shown 
recursive procedure full procedure 
applying transformation program proc produces procedure shown 
need show transformation correct preserves map ssa 
substituting value identifier bound variables safe bound value 
scoping preserved free identifiers scope scope occurrence original program 
moving lexically inferior form preserves scoping uses inserted letrec binds 
function applied transformed program produce equivalent ssa version 
created jump obey restrictions ones created cps algorithm jump bound letrec uses variables bound tail calls bindings uses lie single proc outlying moved step transformation 
related similarity cps ssa noted 
appel donnell briefly describe relationship oe functions parameters procedures call sites known 
shown correspondence exact importantly goes ways 
main difference cps procedure ssa procedure syntax 
compiler writers single representation take advantage intraprocedural optimizations done ssa interprocedural optimizations done cps 
contribution correspondence useful 
long procedures small contain loops considering ssa procedures help 
shown merge looping procedures result treated single procedure restricted somewhat complex version transformation mentioned earlier papers discussion implications program analysis :10.1.1.9.6252
transformation analyzing loops expressed recursive procedures requires interprocedural analysis case cps may difficult necessary 
andrew appel 
compiling continuations 
cambridge university press cambridge 
preston briggs keith cooper 
effective partial redundancy elimination 
proceedings acm sigplan conference programming language design implementation pages 
william clinger jonathan rees 
revised report algorithmic language scheme 
acm lisp pointers 
ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems 
daniel friedman mitchell wand christopher haynes 
essentials programming languages 
mit press cambridge ma 
mcgraw hill chicago 
richard kelsey 
compilation program transformation 
technical report yaleu dcs tr department computer science yale university new haven ct 
richard kelsey paul hudak 
realistic compilation program transformation 
conf 
rec 
acm symposium principles programming languages pages 
david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction 
sigplan notices july 
donnell 
high level compiling low level machines 
phd thesis ecole nationale sup erieure des el 
amr sabry matthias felleisen 
passing useful data flow analysis 
proceedings acm sigplan conference programming language design implementation pages 
olin shivers 
control flow analysis higher order languages taming lambda 
phd thesis school computer science carnegie mellon university 
guy steele 
rabbit compiler scheme 
technical report massachusetts institute technology cambridge ma may 
michael wolfe 
induction variables 
proceedings acm sigplan conference programming language design implementation pages 

