nd difference algorithm variations eugene myers department computer science university arizona tucson az problems finding longest common subsequence sequences shortest edit script transforming long known dual problems 
shown equivalent finding shortest longest path edit graph 
perspective simple nd time space algorithm developed sum lengths size minimum edit script algorithm performs differences small sequences similar consequently fast typical applications 
algorithm shown expected time performance basic stochastic model 
refinement algorithm requires space suffix trees leads time variation 
key words longest common subsequence shortest edit script edit graph file comparison 
problem determining differences sequences symbols studied extensively 
algorithms problem numerous applications including spelling correction sys tems file comparison tools study genetic evolution 
formally problem statement find longest common subsequence equivalently find minimum script symbol deletions tions transform sequence 
earliest algorithms wagner fischer takes time space solve generalization call string string correction problem 
refinement hirschberg delivers longest common subsequence linear space 
algorithms arbitrary alphabets equal unequal comparisons characterized terms size input shown time necessary 
russians approach leads slightly better lgn lgn time algorithms arbitrary finite alphabets respectively 
existence faster algorithms comparison formats open 
algorithms equal greater comparisons time best lower bound known 
supported part national science foundation mcs 
improves basic time arbitrary alphabet algorithm sensitive prob lem size parameters 
output parameter length longest common subsequence dual parameter length shortest edit script 
assumed strings length 
best output sensitive algorithms hirschberg take nl time 
algorithm hunt szymanski takes lgn time parameter total number ordered pairs positions input strings match 
note algorithms worse terms 
practical situations usually parameter small 
programmers wish know altered text file 
biologists wish know dna strand mutated 
situations nd time algorithm superior hirschberg algorithms small 
furthermore approach hunt szymanski predicated hypothesis small practice 
fre quently true noted correlation size input size output situations 
example lines file blank file compared greater dna molecules alphabet size implying arbitrary molecule compared similar molecule 
nd time algorithm 
algorithm simple intuitive edit graph formalism 
employs greedy design paradigm exposes relationship long est common subsequence problem single source shortest path problem 
nd algorithm 
uses different design paradigm share features 
algorithm refined linear space expected case time behavior shown 
method admits time worst case variation 
asymptotically previous algorithms 
exception worst case variation algorithms practi cal basic nd algorithm served basis new implementation unix diff program 
version usually runs times faster system implementation hunt szymanski algorithm 
cases large algorithm superior files completely different 
linear space roughly twice slow basic nd algorithm competitive perform extremely large compares range algorithms 
instance byte sequences compared minutes vax running bsd unix difference greater 

edit graphs 

sequences length respectively 
edit graph vertex point grid 
vertices edit graph con nected horizontal vertical diagonal directed edges form directed acyclic graph 
horizontal edges con vertex right neighbor 

vertical edges connect vertex neighbor 

diagonal edge connecting vertex vertex 
points called match points 
total number match points parameter characterizing hunt szymanski algorithm 
number diagonal edges edit graph diagonal edges correspondence match points 
depicts edit graph sequences 
path trace common subsequence caba edit script ib ic fig 

edit graph trace length sequence match points 
successive points 
trace exact correspondence diagonal edges path edit graph 
sequence match points visited traversing path start finish easily verified trace 
note number diagonal edges corresponding path 
construct path trace take sequence diagonal edges corresponding match points trace connect successive diagonals series horizontal vertical edges 
done successive match points 
note paths differing non diagonal edges correspond trace 
illustrates relation paths traces 
subsequence string string obtained deleting zero symbols string 
com mon subsequence strings subsequence 
trace gives rise common subsequence vice versa 
specifically 

common subsequence 
trace edit script set insertion deletion commands transform delete com mand xd deletes symbol insert command 
inserts sequence sym 
immediately script commands refer symbol positions commands performed 
think set commands script executed simultaneously 
length script number symbols inserted deleted 
trace corresponds uniquely edit script 

trace 

associated script consists commands xd 


script deletes symbols inserts sym 
trace length corresponding script length 
map edit script trace simply perform delete commands observe result common subsequence map subsequence unique trace 
note inverting action insert commands gives set delete commands map common subsequence 
common subsequences edit scripts traces paths edit graph isomorphic formalisms 
edges path direct interpretations terms corresponding com mon subsequence edit script 
diagonal edge gives symbol common subsequence horizontal edge point corresponds delete command sequence vertical edges corresponds insert command 

number vertical horizontal edges path length corresponding script number diagonal edges length corresponding subsequence total number edges illustrates obser 
problem finding longest common subsequence lcs equivalent finding path maximum number diagonal edges 
problem finding shortest edit script ses equivalent finding path minimum number non diagonal edges 
dual problems path maximum number diagonal edges minimal number non diagonal edges 
consider adding weight cost edge 
give diagonal edges weight non diagonal edges weight 
lcs ses problem equivalent finding minimum cost path weighted edit graph special instance single source shortest path problem 

greedy algorithm problem finding shortest edit script reduces finding path fewest number horizontal vertical edges 
path path starting exactly non diagonal edges 
path consist solely diagonal edges 
simple induction follows path consist path followed non diagonal edge possibly empty sequence diagonal edges called snake 
number diagonals grid edit graph vertices diagonal consists points definition diagonals numbered note vertical horizontal edge start point diagonal point diagonal snake remains diagonal starts 
lemma path diagonal 

proof path consists solely diagonal edges starts diagonal 
diagonal 
assume inductively path diagonal 

path consists prefix path say diagonal non diagonal edge diagonal snake diagonal 
follows path diagonal 


result holds induction 
lemma implies paths solely odd diagonals odd diagonals 
path furthest reaching diagonal paths diagonal point greatest possible row column number paths 
informally paths diagonal ends furthest origin 
lemma gives inductive characterization furthest reach ing paths embodies greedy principle furthest reaching paths obtained greedily extending furthest reaching paths 
lemma furthest reaching path ends min 
furthest proof reaching path diagonal loss generality decomposed furthest reaching path diagonal followed horizontal edge followed longest possible snake may decomposed furthest reaching path diagonal followed vertical edge followed longest possible snake 
basis paths straightforward 
noted path consists path non diagonal edge snake 
path ends diagonal follows path diagonal depending vertical horizontal edge precedes final snake 
final snake maximal path furthest reaching snake extended 
suppose path furthest reaching diagonal 
reaching path connected final snake path appropriate non diagonal move 
path decomposed desired 
endpoints furthest reaching paths diagonal say respectively lemma gives procedure computing endpoint furthest reaching path diagonal take reaching diagonal follow diagonal edges longer possible boundary edit graph reached 
furthermore lemma diagonals path 
suggests computing endpoints paths relevant diagonals successively increasing values furthest reaching path diagonal reaches 
steps find endpoint furthest reaching path diagonal endpoint path optimal solution 
outline stops smallest encountered furthest reaching path 
happen outer loop terminates equal construction path minimal respect number non diagonal edges 
solution lcs ses problem 
presenting detailed algorithm number simple optimizations employed 
array contains endpoints furthest reaching paths elements 

lemma set elements disjoint endpoints paths stored iteration outer loop 
array simultaneously hold endpoints paths path endpoints computed 
furthermore record endpoint diagonal suffices retain just known consequently array integers contains row index endpoint furthest reaching path diagonal constant max var array max 
max integer 

max 
steps 








length ses 

length ses greater max greedy lcs ses algorithm practical matter algorithm searches paths max path reaches reports edit script longer max line 
setting constant max outline algorithm guaranteed find length lcs ses 
illustrates paths searched algorithm applied example 
note fictitious endpoint set line algorithm find endpoint furthest reaching path 
note paths extend left lower boundaries edit graph proper algorithm progresses 
boundary situa tion correctly handled assuming diagonal edges region 
extensions diagonals odd extensions envelope path endpoints fig 

furthest reaching paths 
edit graph boundary greedy algorithm takes time 
lines consume time 
inner loop line repeated times outer loop line repeated times dur ing th iteration inner loop repeated times 
lines inner loop take constant time loop line 
time spent executing lines 
loop iterated diagonal traversed extension furthest reaching paths 
traversed paths lie diagonals min points band 
algorithm requires total time 
note just line traversal snakes limiting step 
rest algorithm 
furthermore algorithm takes max time practical case threshold max set value search greedy algorithm traces optimal paths 
current set furthest reaching endpoints retained consequently length ses lcs reported line 
explicitly generate solution path space store copy iteration outer loop 
copy kept th iteration 
list optimal path point deter mine maximal snake vertical edge horizontal edge 
concrete suppose 
recursively list optimal path point list vertical edge maximal snake 
recursion stops case snake listed 
additional time space optimal path listed replacing line call recursive procedure initial point 
refinement requiring space shown section 
noted section lcs ses problem viewed instance single source shortest paths problem weighted edit graph 
suggests efficient algorithm obtained specializing dijkstra algorithm 
basic exercise shows algorithm takes time number edges number vertices subject graph 
edit graph point outdegree 
term comes cost managing priority queue 
case hand priorities integers edge costs longest possible path point conditions priority queue operations implemented constant time bucket ing linked list techniques 
dijkstra algorithm specialized perform time linear number vertices edit graph mn 
final refinement stems noting needed shortest path source point 
dijkstra algorithm determines minimum distances vertices source increasing order vertex iteration 
lemma points distant previous refinements reduce cost iteration 
algorithm soon minimum distance ascertained spends time doing 
shown specialization dijkstra algorithm gives nd time algorithm lcs ses problem 
resulting algorithm involves relatively complex discrete priority queue queue may contain nd entries case just length lcs ses com puted 
argue refinement leads simple algorithm connection direct easily motivated derivation section preferable 
aim discussion expose close relationship shortest paths lcs ses problems algo rithms 
space allocated algorithm run determine space space allocated algorithm run determine solution path 

refinements basic algorithm number ways 
algorithm expected performance superior worst case prediction 
shown experi ments reveal variance mean small especially alphabet size large 
pathological cases require time extremely rare problems quicksort 
second algorithm refined linear space reporting edit script 
algorithm shown admit refinement basic mn dynamic programming algo rithm 
linear space algorithm practical import large problems reasonably solved time space 
lg worst case time variation obtained speeding traversal snakes previously developed techniques 
variation impractical due sophistication underlying methods superior asymptotic worst case complexity theoretical interest 

probabilistic analysis consider stochastic model sequences shortest edit script problem 
sequences alphabet symbol occurs probability 
symbols randomly independently chosen probability densities 
symbol sequence obtained randomly deleting symbols randomly inserting randomly chosen symbols 
deletion insertion positions chosen uniform probability 
equivalent model generate random sequence length randomly insert randomly generated symbols sequence pro duce respectively 
note lcs consist symbols may longer 
alternate model consider randomly generated sequences length con strained lcs length model equivalent limit size arbitrarily large probability goes zero 
ensuing treatment applied model asymptotic results 
model chosen reflects edit scripts mapping assumed ses problem 
edit script commands transfers moves exchanges reflective actual editing sessions inclusion results distinct zation problems ses problem discussed 
stochastic models edit process considered 
edit graph diagonal edges corresponding randomly generated lcs diagonal edge say occurs probability symbols obtained independent random trials 
probability lcs diagonal ses algorithm searches extending furthest reaching paths point reached 
extension consists horizontal vertical edge followed longest possible snake 
maximal snakes consist number lcs lcs diagonals 
probability exactly lcs diagonals extension snake 
expected number lcs diagonals extension 
extensions th iteration outer loop ses algorithm 
lcs diagonals traversed expected case 
lcs traversed 
consequently critical loop algorithm executed average times bounded away 
remainder algorithm observed take worst time 
letter nonzero probability alphabet consists repetitions letter probability 
case algorithm runs time 
ses algo rithm takes time expected case 

linear space refinement lcs ses problem symmetric respect orientation edit graph edges 
consider reversing direction edge edit graph sequences subsequences edit scripts modeled paths reverse edit graph paths start 
interpretation paths alters just slightly reflect reversal direction 
diagonal edge gives symbol common subsequence horizontal edge point corresponds delete command lcs ses problem solved starting progressively extending furthest reaching paths reverse edit graph reaches 
forward paths refer edit graph reverse paths refer reverse edit graph 
paths opposing directions exact correspondence direction path distinguished operational importance 
linear space algorithm hirschberg divide conquer strategy employed 
path snakes may empty 
divide step requires finding middle snake optimal path 
idea doing simultaneously run basic algorithm forward reverse directions furthest reaching forward reverse paths starting opposing corners overlap 
lemma pro vides formal observation underlying approach 
lemma path path point proof path point feasibility overlap paths contained paths 
suppose path 
partitioned start middle snake path path 
path non diagonal edges path implying path non diagonal edges path implying 
conversely suppose paths exist 
implies path lemma multiple path path diagonal 
path diagonals replacing diagonals path pair horizontal vertical edges path obtained 
path consisting path path 
note path part path 
symmetric argument path part path 
outline gives procedure finding middle snake optimal path 
successive values compute endpoints furthest reaching forward paths compute furthest reach ing reverse paths 
vectors direction basic algorithm 
point computed check see overlaps path diagonal opposite direction 
check needed ensure opposing path diagonal forward paths diagonals cen tered reverse paths diagonals centered lemma optimal edit script length odd odd 
odd check overlap extending forward paths check overlap extending reverse paths 
soon pair opposing furthest reaching paths overlap report overlapping snake middle snake optimal path 
note endpoints snake readily delivered snake just computed previous step 
steps find furthest reaching forward path diagonal odd path overlaps furthest reaching reverse path diagonal length ses 
snake forward path middle snake 
steps find furthest reaching reverse path diagonal 
path overlaps furthest reaching forward path diagonal length ses 
snake reverse path middle snake 
correctness procedure relies heavily lemma 
loss generality suppose 
algorithm stops soon smallest encountered furthest reaching paths opposite directions overlap 
overlapping paths shown satisfy feasibility condition lemma 
suppose reverse furthest reaching path ends path non diagonal edges combined reverse path forms path 
path lemma imply overlapping paths divisible 
certainly overlapping furthest reaching paths 
contradicting fact furthest reaching paths overlap 
desired 
similar argument shows furthest reach ing forward path satisfies feasibility constraint lemma 
feasible overlapping paths lemma imply solution path length 
optimal path lemma implies paths overlap 
implies overlapping furthest reaching paths contradicting fact overlapping paths smaller lemma overlapping paths parts optimal paths 
drawn odd 
remains show chosen snake middle snake optimal path part 
odd snake st forward reverse path part optimal path 
case snake st optimal path containing 
procedure finding middle snake optimal path requires total working storage vectors 
procedure requires time forward reverse path extension portions consume time argument basic algorithm 
fact number snakes traversed extending forward reverse paths half basic algorithm diagonals searched 
feature practical import experiments reveal procedure determining length ses efficient basic algorithm rapidly twice fast increases 
middle snake procedure linear space algorithm finding optimal path edit graph sizes devised 
simplicity divide conquer algorithm just lists long est common subsequence 
producing shortest edit script left exercise 
divide prob lem finding middle snake say optimal path 
problem recursively finding path listing lcs 
list middle snake output lists 
recursively find path list lcs 
recursion ends ways 
list 
case 
obtained deleting inserting symbol 
follows shorter lcs listed 
lcs find middle snake length optimal path suppose 
lcs output 
lcs output 
output 
time taken algorithm follows satisfies recurrence ine quality pd suitably large constants 
noting straightforward induction argument shows pd divide conquer algorithm takes just time despite lg levels recursion descends 
furthermore algorithm requires working storage 
middle snake procedure requires space vectors 
step completed engaging recursion 
pair global vectors shared invocations procedure 
levels recursion traversed implying storage needed recursion stack 
unfortunately input sequences kept memory implying total space needed 

lg worst case variation final topic involves previous results just sketched 
suffix trees efficiently record common sublists sequences compared 
term sublist opposed subsequence emphasize symbols contiguous 
second ram algorithm line queries lowest common ancestors vertices fixed vertex tree takes time 
efficient variation centers quickly finding length endpoint maximal snake starting point 
shown reduce finding lowest common ancestor leaves suffix tree 
done lg pre processing time time query techniques 
ensuing paragraphs ideas 
suffix patricia tree sequence length edges labelled sublists leaves labelled positions satisfies properties 

concatenating edge labels traversed path root leaf position gives suffix starting path tree denotes sublist 
interior vertex degree greater 

labels edges vertex distinct symbols 
properties satisfied symbol distinct symbol condition usually met appending special symbol target sequence satisfied suffix tree unique 
property guarantees interior vertices 
substrings labelling edges represented just storing indices characters suffix trees stored space 
efficient construction suffix trees scope 
reader referred mccreight giving algorithm constructs suffix tree steps 
steps easily done time require selecting edge symbol 
finite degree vertices finite selection takes time 
alphabet unrestricted height balanced trees worst case efficient search structure permits selection time 
suffix tree construc tion takes time finite alphabets time 
consider paths root suffix tree leaves path root common ancestor denotes common prefix suffixes 
property follows path lowest common ancestor denotes longest prefix respective suffixes 
observa tion motivates suffix tree characterization maximal snake starting point edit graph lengths respectively 
form position tree sequence sym equal symbol maximal snake starting denoted path root suffix tree lowest common ancestor positions 
follows part longest common prefix suffixes 
find endpoint snake starting find lowest common ancestor leaves suffix tree return length sublist denoted path ances tor 
linear preprocessing pass sublist lengths vertex computed auxiliary structures needed lowest common ancestor algorithm harel tarjan constructed 
ram algorithm requires preprocessing time answer line query time 
lg preprocessing time building suffix tree dominant cost collection line queries endpoints maximal snakes answered time query 
modify basic algorithm section preprocessing needed maximal snake queries replacing line query primitives 
recall line innermost loop line loop repeated times 
line takes time follows modification results algorithm runs lg time 
note variation pri theoretical interest 
coefficients proportionality larger algorithm fragments employed implying problems large variation faster 
suffix trees particularly space inefficient auxiliary trees equal size needed fast lowest common ancestor algorithm 
problems large time savings worthwhile memory accomodate additional structures 
webb miller originally proposed problem finding nd algorithm 
author helpful suggestions 
referees comments corrections improved greatly 

aho hirschberg ullman bounds complexity longest common subsequence problem journal acm 

aho hopcroft ullman data structures algorithms 
addison wesley reading mass 


dijkstra note problems connexion graphs numerische mathematik 

gosling redisplay algorithm proceedings acm sigplan symposium text manipulation 

hall dowling approximate string matching computing surveys 

harel tarjan fast algorithms finding nearest common ancestors siam journal computing 

hirschberg linear space algorithm computing maximal common subsequences communications acm 

hirschberg algorithms longest common subsequence problem journal acm 

hirschberg information theoretic lower bound longest common subsequence problem information processing letters 

hunt mcilroy algorithm differential file comparison computing science technical report bell laboratories 

hunt szymanski fast algorithm computing longest common subsequences communications acm 

knuth art computer programming vol 
sorting searching 
addison wesley reading mass 


paterson faster algorithm computing string edit distances computer systems sciences 

mccreight space economical suffix tree construction algorithm journal acm 

miller myers file comparison program software practice experience 

longest common subsequence algorithm suitable similar text strings acta informatica 

source code control system ieee transactions software engineering 

sankoff kruskal time warps string edits macromolecules theory practice sequence comparison 
addison wesley reading mass 


tichy string string correction problem block moves acm transactions computer systems 

wagner fischer string string correction problem journal acm 

