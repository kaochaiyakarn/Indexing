technique drawing directed graphs emden gansner koutsofios stephen north phong vo bell laboratories murray hill new jersey describe pass algorithm drawing directed graphs 
pass finds optimal rank assignment network simplex algorithm 
second pass sets vertex order ranks iterative heuristic incorporating novel weight function local transpositions reduce crossings 
third pass finds optimal coordinates nodes constructing ranking auxiliary graph 
fourth pass splines draw edges 
algorithm drawings runs fast 

drawing graphs topic ongoing research having applications visualization programs data structures document preparation 
describes technique drawing directed graphs plane 
goal high quality drawings quickly interactive 
algorithms basis practical implementation 
aesthetic criteria drawings helps assume directed graph flow direction top bottom assumed examples left right 
flows seen drawings finite automata flow initial terminal states data flow graphs input output 
observation motivated collection methods drawing digraphs aesthetic principles 
expose hierarchical structure graph 
particular aim edges general direction possible 
aids finding directed paths highlights source sink nodes 

avoid visual anomalies convey information underlying graph 
example avoid edge crossings sharp bends 

keep edges short 
easier find related nodes contributes 

favor symmetry balance 
aesthetic secondary role places algorithm 
way optimize aesthetics simultaneously 
instance placement nodes orientation edges preferred may force edge crossings undesirable 
computationally intractable minimize edge crossings find subgraphs having symmetry 
simplifying assumptions rely heuristics run quickly layouts common cases 
survey aesthetic principles refer reader annotated bibliography graph drawing algorithms eades tamassia 
problem description input drawing algorithm attributed graph possibly containing loops multi edges 
assume connected connected component laid separately 
attributes size bounding box node minimum horizontal separation node boxes 
minimum vertical separation node boxes 
weight edge usually 
weight signifies edge importance translates keeping edge short vertically aligned 
algorithm assigns node rectangle plane center point assigns edge sequence spline control points 

unit dimensions specified convenient traditional coordinate system units inch implementation 
layout generally guided aesthetic criteria specifically graph attributes 
details constraints supplied sections 
user constrain layout way useful drawing graphs time lines highlighting source sink nodes 
initial pass algorithm described section assigns nodes discrete ranks max rank 
nodes rank receive coordinate value 
user may provide sets max min 
subset possibly empty sets nodes placed maximum minimum rank respectively 
related drawing digraphs iterative method reduce edge crossing studied warfield wa similar methods discovered ca sugiyama toda stt 
di battista tamassia describe algorithm embedding planar acyclic digraphs edges flow direction dt 
view building approach warfield sugiyama overview graph drawing algorithm passes shown 
pass places nodes discrete ranks 
second sets order nodes ranks avoid edge crossings 
third sets actual layout coordinates nodes 
final pass finds spline control points edges 

procedure draw graph 

rank 
ordering 
position 
splines 

main algorithm contributions efficient way ranking nodes network simplex algorithm improved heuristics reduce edge crossings method computing node coordinates rank assignment problem method setting spline control points 
techniques implemented graph drawing program dag described 
especially incorporated dot kn successor dag 
figures samples dot output corresponding input files 

sec 
user time sun digraph world dynamics size 
graph file listing sh rc bourne ksh system ksh perl ksh posix 
bash thompson sec 
user time sun digraph shells size node shape plaintext node shape box rank bourne rank csh rank rank ksh system rank sh rank ksh rank perl rc rank tcl bash rank posix ksh posix posix thompson bourne csh csh bourne ksh system sh sh rc bourne ksh bash csh ksh system posix ksh ksh ksh posix bourne invisible edges adjust node placement edge style sh rc csh perl 
graph file listing csh tcl 
optimal rank assignment pass assigns node member integer rank consistent edges 
means member length defined represents minimum length constraint 
usually take non negative integer value 
may set internally technical reasons described externally user wants adjust rank assignment 
pass nonempty sets max min 
temporarily merged node 
addition loops ignored multiple edges merged edge weight sum weights merged edges 
efficiency leaf nodes member sets may ignored rank leaf trivially determined optimal ranking 
making graph acyclic graph acyclic consistent rank assignment 
input graph may contain cycles preprocessing step detects cycles breaks reversing certain edges 
course edges reversed internally arrowheads drawing show original direction 
useful procedure breaking cycles depth search 
edges searched natural order graph input starting source sink nodes exist 
depth search partitions edges sets tree edges non tree edges ahu 
tree defines partial order nodes 
partial order non tree edges partition sets cross edges forward edges back edges 
cross edges connect unrelated nodes partial order 
forward edges connect node descendants 
back edges connect descendant ancestors 
clear adding forward cross edges partial order create cycles 
reversing back edges forward edges cycles broken procedure 
reasonable try reverse smaller minimal set edges 
difficulty finding minimal set feedback arc set problem np complete gj 
important probably improve drawings 
implemented heuristic reverse edges participate cycles 
heuristic takes non trivial strongly connected component time arbitrary order 
component counts number times edge forms cycle depth traversal 
edge maximal count reversed 
repeated non trivial strongly connected components 
experiments heuristic show directed graphs arising practical applications natural edge direction contain cycles 
graph input usually reflects natural direction 
fact graphs created graph search performed tool 
reversing inappropriate edge drawing 
instance procedure call graph cycles expects see top level functions near top drawing middle 
standpoint stability depth cycle breaking heuristic preferable 
informative drawings obtained collapsing nodes cycle node placing nodes cycle rank duplicating nodes cycle various researchers suggested ca ro stt 
detail nodes representing max min maximum minimum rank assignments 
property ensured reversing edges max edges min 
nodes edge temporary edge min nodes edge temporary edge max 
min max problem definition principle prescribes making short edges 
making better layouts short edges reduce running time passes time depends total edge length 
desirable find optimal node ranking sum weighted edge lengths minimal 
finding optimal ranking reformulated integer program min member subject weight function minimum length function previously described map edge set non negative rational numbers non negative integers respectively 
various ways solve integer program polynomial time 
method solve equivalent linear program transform solution integer polynomial time 
involves converting optimal rank assignment problem equivalent min cost flow circulation problem polynomial time algorithms see gt 
constraint matrix totally unimodular problem solved necessarily polynomial time applying simplex method 
complete discussion techniques reported 
network simplex describe simple approach problem network simplex formulation ch 
time complexity proven polynomial practice takes iterations runs quickly 
definitions observations 
feasible ranking satisfying length constraints ranking necessarily feasible slack edge difference length minimum length 
ranking feasible slack edge non negative 
edge tight slack zero 
spanning tree graph induces ranking family equivalent rankings 
note spanning tree underlying unrooted undirected graph necessarily directed tree 
ranking generated picking initial node assigning rank 
node adjacent spanning tree ranked node assign rank adjacent node incremented decremented minimum length connecting edge depending head tail connecting edge 
process continued nodes ranked 
spanning tree feasible induces feasible ranking 
construction edges feasible tree tight 
feasible spanning tree associate integer cut value tree edge follows 
tree edge deleted tree breaks connected components tail component containing tail node edge head component containing head node 
cut value defined sum weights edges tail component head component including tree edge minus sum weights edges head component tail component 
typically degeneracy negative cut value indicates weighted edge length sum reduced lengthening tree edge possible head component tail component edges tight 
corresponds replacing tree edge spanning tree newly tight edge obtaining new feasible spanning tree 
simple see optimal ranking generate optimal ranking induced feasible spanning tree 
observations key solving ranking problem graphical algebraic context 
tree edges negative cut values replaced appropriate non tree edges tree edges non negative cut values 
guarantee termination implementation employ anti cycling technique necessary practice 
resulting spanning tree corresponds optimal ranking 
discussion termination network simplex algorithm optimality result interested reader referred literature ch cu 
describes version network simplex algorithm 

procedure rank 
feasible tree 
leave edge nil 
enter edge 
exchange 

normalize 
balance 

network simplex remarks 
function feasible tree constructs initial feasible spanning tree 
procedure described fully 
simplex method starts feasible solution maintains invariant 
leave edge returns tree edge negative cut value nil meaning solution optimal 
edge negative cut value may selected edge remove 
enter edge finds non tree edge replace done breaking edge divides tree head tail component 
edges going head component tail considered edge minimum slack chosen 
necessary maintain feasibility 
edges exchanged updating tree cut values 
solution normalized setting rank zero 
nodes having equal edge weights multiple feasible ranks moved feasible rank fewest nodes 
purpose reduce crowding improve aspect ratio drawing principle 
adjustment change cost rank assignment 
nodes adjusted greedy fashion works sufficiently 
globally balancing ranks considered forthcoming 

procedure feasible tree 
init rank 
tight tree 
non tree edge incident tree 
minimal amount slack 
delta slack 
incident node head delta delta 
tree rank rank delta 

init 

finding initial feasible tree remarks 
initial feasible ranking computed 
brevity init rank 
version keeps nodes queue 
nodes placed queue edges 
nodes taken queue assigned rank satisfies edges edges marked scanned 
simplest case edges corresponds viewing graph poset assigning minimal elements rank 
nodes removed poset new set minimal elements assigned rank function tight tree finds maximal tree tight edges containing fixed node returns number nodes tree 
note maximal tree just spanning tree subgraph induced nodes reachable fixed node underlying undirected graph tight edges 
particular trees number nodes 
finds edge non tree node adjacent tree adjusts ranks tree nodes edge tight 
edge picked minimal slack resulting ranking feasible 
iteration maximal tight tree gains node algorithm eventually terminates feasible spanning tree 
technique essentially described sugiyama stt 
init function computes cut values tree edges 
tree edge computed marking nodes belonging head tail component performing sum signed weights edges head tail different components sign negative edges going head tail component 

finding optimal feasible tree small example running network simplex algorithm shown 
non tree edges dotted edges weight 
graph shown initial ranking cut values indicated 
instance cut value edge corresponding weight edge tail component head component minus weights edges head component tail component 
edge negative cut value replaced non tree edge new cut values shown 
non negative solution optimal algorithm terminates 
implementation details versions network simplex algorithm understood results literature help tune implementation ch 
feel worth pointing specific points prospective implementors 
optimizations useful crucial network simplex section applied larger graphs 
computing initial feasible tree initial cut values frequently significant proportion cost solving network simplex algorithm 
graphs practice initial solution close optimal requiring just iterations reach final solution 
naive implementation initial cut values tree edge turn breaking labeling node belongs head tail component performing sum 
takes time 
reduce cost note cut values computed information local edge search ordered leaves feasible tree inward 
trivial compute cut value tree edge endpoints leaf tree head tail component consists single node 
assuming cut values known edges incident node cut value remaining edge sum known cut values plus term dependent edges incident node 
illustrate computation case tree edges known cut values join third shown orientations 
cases handled similarly 
assume cut values known 
edges labeled capital letters represent set non tree edges direction heads tails belong components shown 
cut values respectively 
cut value expression involving local edge information known cut values 
computing cut values incrementally ensure edge examined twice 
greatly reduces time spent computing initial cut values 

incrementally computing cut values 
valuable optimization similar technique described ch perform postorder traversal tree starting fixed root node root labeling node postorder traversal number lim number low descendant search edge parent node reached see 
root 
postorder traversal nodes labeled low lim 
provides inexpensive way test node lies head tail component tree edge non tree edge crosses components 
example tree edge root head component edge lim lim node tail component low lim lim 
numbers update tree efficiently network simplex iterations 
entering edge edges cut values adjusted path connecting tree 
path determined parent edges back common ancestor reached node low lim lim lim 
course postorder parameters adjusted exchanging tree edges nodes network simplex sensitive choice negative edge replace 
observed searching cyclically tree edges searching list tree edges time save iterations 

vertex ordering ranks rank assignment edges nodes rank apart replaced chains unit length edges temporary virtual nodes 
virtual nodes placed intermediate ranks converting original graph edges connect nodes adjacent ranks 
ignored pass multi edges merged previous pass 
vertex order ranks determines edge crossings layout ordering crossings 
heuristics appropriate minimizing edge crossings layouts ranked graphs np complete ranks 
important heuristics reducing edge crossings ranked graphs scheme suggested warfield wa 
initial ordering rank computed 
sequence iterations performed try improve orderings 
iteration traverses rank vice versa 
visiting rank vertices assigned weight relative positions incident vertices preceding rank 
vertices rank re ordered sorting weights 
common vertex weighting methods barycenter function stt median function ew 
vertex list positions incident vertices appropriate adjacent rank 
note position adjacent node ordinal number current ordering 
barycenter method defines weight average elements median method defines weight median elements number elements medians 
gives rise median methods left median right median 
median method consistently performs better barycenter method slight theoretical advantage eades wormald ew shown median layout level graph times minimum number crossings 
bound known barycenter method 
node ordering heuristic refinement median method major innovations 
median values interpolated value biased side vertices closely packed 
second improvement uses additional heuristic reduce obvious crossings vertices sorted transforming ordering locally optimal respect transposition adjacent vertices 
typically provides additional reduction edge crossings 
refer reader detailed statistics 
shows node ordering algorithm 

procedure ordering 
order init order 
best order 
max iterations 
order 
transpose order 
crossing order crossing best 
best order 

return best 

vertex ordering algorithm remarks 
init order initially orders nodes rank 
may done depth breadth search starting vertices minimum rank 
vertices assigned positions ranks left right order search progresses 
strategy ensures initial ordering tree crossings 
important crossings obvious mistakes max iterations maximum number iterations 
set max iterations 
iteration number crossings improves new ordering saved 
actual implementation prefer adaptive strategy iterates long solution improved percent iterations 
re orders nodes rank weighted median heuristic 
transpose repeatedly exchanges adjacent vertices rank decreases number crossings 
functions described completely 
weighted median heuristic shown 
depending parity current iteration number ranks traversed top bottom bottom top 
simplify presentation shows direction detail 

procedure order iter 
iter mod 
max rank 
order 
median median value 
sort order median 



endif 


procedure median value rank 
position rank 


return 
elseif mod 
return 
elseif 
return 

left 
right 
return right left left right 
endif 

weighted median heuristic remarks 
forward traversal ranks main loop starts rank ends maximum rank 
rank vertex assigned median adjacent vertices previous rank 
vertices rank sorted medians 
important consideration vertices adjacent vertices previous rank 
implementation vertices left fixed current positions non fixed vertices sorted remaining positions 
median value vertex defined median position adjacent vertices uniquely defined 
interpolated median positions measure tightness 
generally weighted median biased side vertices closely packed 
position function returns ordered array positions nodes adjacent adjacent rank 
nodes adjacent vertices median value 
sort function indicate nodes left current positions 
shows transposition heuristic 

procedure transpose rank 
improved true 
improved 
improved false 
max rank 
rank 
rank 
rank 
crossing crossing 
improved true 
exchange rank rank 
endif 




transposition heuristic reducing edge crossings remarks 
main loop iterates long number edge crossings reduced transpositions 
loop ordering function adaptive strategy applied terminate loop improvement sufficiently small fraction number crossings 
adjacent pair vertices examined 
order switched reduces number crossings 
function crossing simply counts number edge crossings appears left rank 
small point original graph may edges nodes rank 
call flat edges criterion try aim direction rank 
ranks ordered top bottom flat edges generally point left right 
involves minor modifications vertex ordering algorithms 
flat edges transitive closure computed finding vertex order 
vertex order embed partial order 
particular initial order consistent transpose sort routines exchange nodes partial order 
sorting nodes medians transposing adjacent nodes equality occur comparing median values number edge crossings 
helpful keeping spirit flip nodes equal values sorting transposing passes forward backward traversal 
final point generally worth extra cost run vertex ordering algorithm twice initial order determined starting vertices minimal rank searching edges second time starting vertices maximal rank searching edges 
allows pick better different solutions 

node coordinates third pass sets node coordinates 
previous treated postprocessing step barycenter median methods making local adjustments avoid bad layouts 
considering node placement separate defined problem yields better layouts provides foundation extensions trying set vertex order methods topological geometric 
coordinates computed separate steps 
step assigns coordinates nodes including virtual nodes subject order ranks determined 
second step assigns coordinates giving value nodes rank 
coordinate assignment maintains minimum separation node boxes 
optionally separation adjacent ranks increased improve slope nearly horizontal edges readable 
coordinate step straightforward remainder section deals coordinates 
aesthetic principles mentioned short straight edges preferable long ones 
property coordinates captured integer optimization problem min subject left neighbor rank internal value distinct input edge weight defined favor straightening long edges 
edges real nodes adjacent ranks drawn straight lines important reduce horizontal distance virtual nodes chains may aligned vertically straightened 
failure straighten long edges result spaghetti effect edges having different slopes 
accordingly edges divided types depending vertices real nodes real node virtual node virtual nodes 
edges types respectively 
implementation uses 
function pairs adjacent nodes rank giving minimum separation center points 
standard techniques transforming problem linear program addition auxiliary variables inequalities remove absolute values ch 
resulting constraints totally unimodular solving linear program simplex method produces solution integer program 
easy program layouts gives aesthetically pleasing 
unfortunately transformation increases size simplex matrix entries 
graphs dozen nodes edges drawn seconds larger graphs take longer amount memory available limitation 
completely satisfactory way layouts particularly smaller computers 
heuristic approach approach replaces linear program heuristic finding coordinates 
heuristic finds initial placement iteratively tries improve sweeping ranks similar vertex ordering algorithm described previous section 
heuristic sketched 

procedure 
xcoord init xcoord 
xcoord 
max iterations 
xcoord 
xcoord 
xcoord 
xcoord 
xcoord 
xcoord 
xcoord 

return 

assigning coordinates vertices remarks 
initial set coordinates computed follows 
rank left node assigned coordinate 
coordinate node assigned value sufficient satisfy minimal separation previous 
rank nodes initially packed far left possible 
iteration collection heuristics applied improve coordinate assignment 
results improvement previous best assignment coordinates saved 
function implements objective function optimization problem 
implementation max iterations 
median heuristic observation value 
minimized median heuristic assigns node upward downward priority weighted sum edges respectively 
downward iterations nodes processed downward priority order placed median position downward neighbors subject placement higher priority nodes space requirements nodes placed 
medians mean improves symmetry 
upward placement handled similarly 
similar considers edges real nodes 
places edge oriented vertically close possible median nodes adjacent endpoint edge 
performs local optimization node time queue 
initially nodes queued 
node removed queue placed close possible median neighbors subject separation function 
node placement changed neighbors re queued queue 
terminates achieves local minimum 
chains virtual nodes sequentially finding sub chains may assigned coordinate 
sweeps layout left right searching blocks compacted 
node nodes right shifted left increment violating positioning constraints shift performed 
performed algorithm operates list nodes sorted order coordinates 
algorithm quadratic worst case performs practice possible cut needs search nodes neighborhood affected candidate shift 
heuristics layouts quickly complicated program results noticeably imperfect 
fine tuning difficult heuristics interfere 
optimal node placement noticed heuristic find subgraphs compacted improve solution 
considered general heuristic search subgraphs shift 
observed similar way network simplex algorithm moves entire subgraphs find optimal rank assignment see section 
suggested apply network simplex algorithm find optimal node coordinates coordinates ranks method involves constructing auxiliary graph illustrated 
transformation graphical analogue algebraic transformation mentioned removing absolute values optimization problem 
nodes auxiliary graph nodes original graph plus edge new node kinds edges 
edge class encodes cost original edges 
edge replaced edges 
class edges separates nodes rank 
left neighbor edge 
edge forces nodes sufficiently separated affect cost layout 

consider level assignment problem solved network simplex method 
solution positioning problem corresponds solution level assignment problem cost 
achieved assigning value min notation coordinates assigned conversely level assignment induces valid positioning addition optimal level assignment length length means cost original edge equals sum cost edges globally solutions cost optimality implies optimality solving gives solution auxiliary graph permits specification node ports edge endpoints offset direction center node 
possible draw pictures flat records shown graphs fun mid right 
node ports graph drawing 
computing coordinates nodes diagrams edge lengths include displacements node ports distance node center points 
edge specified displacements endpoints centers respectively 
indicates port left vertex center 
loss generality assume constant depends node ports assignments solve optimization problem cost edge auxiliary graph set 
extend argument show positioning corresponds level assignment optimal level assignment induces valid positioning cases edges represents length function level assignment 
equation implies optimal costs problems differ constant minimal assignment corresponds minimal assignment left part exemplifies port offsets translated value edges auxiliary graph 
right part shows solution relates original edge 
implementation details revisited 
auxiliary graph considerably larger original 
original graph nodes edges ranks graph virtual nodes added nodes edges number virtual nodes auxiliary graph nodes edges 
graph requires disproportionately time network simplex approach 
consequently optimizations network simplex algorithm described section crucial pass 
improvement possible noting easy construct initial feasible tree auxiliary graph advantage structure 
construct feasible tree edges connecting nodes rank 
pair adjacent ranks pick edge ranks add tree 
determines relative placement nodes ranks 
edge ranks add tree depending placed leftmost 
improvements network simplex position nodes took times longer 
improvements implementation runs fast faster heuristic implementation 
doubt heuristic turn tuned real advantage network simplex simpler code produces optimal solutions 
improvements difficult program heuristic handled network simplex 
example local symmetry may improved scanning graph network simplex terminates 
tree edges cut value exactly identify subgraphs may adjusted equalize slack incident edges changing cost solution 
increase symmetry centering node number descendants 

drawing edges method edges drawn spline curves 
graph drawing programs aware line segments attempt avoid situations line segments overlap unrelated nodes 
splines difficult program yield better drawings help satisfy aesthetic criterion 
dag edge splines collection heuristics replace path line segments virtual nodes various straight curved segments described 
drawback splines bend sharply turn inside virtual node boxes avoid nearby nodes 
virtual nodes visible final layout 
method available space effectively 
better try find smoothest curve points avoids obstacles nodes splines 
divide spline routing algorithm top half bottom half 
top half computes polygonal region layout spline may drawn 
calls bottom half compute best spline region 
final step top half virtual nodes bounding box spline splines clips spline boundaries endpoint node shapes 
region spline illustrated associated edge unix ts 
formally draw splines creating solving instances sub problem 

boxes parallel coordinate axes edges common points inside box respectively find 
bb 
bb control points piecewise bezier curve bb boxes parallel coordinate axes 
curve endpoints 
optional specified curve slope corresponding endpoint 
bb correspond smallest boxes contain generated splines 
describe parts algorithm 
graph data courtesy ian darwin geoffrey software tool die 
finding region kinds edges drawing edges nodes different ranks flat edges different nodes rank self edges loops 
th edition th edition th edition th edition pwb bsd mini unix pwb bsd bsd bsd bsd ultrix edges ranks bsd bsd bsd bsd th edition ultrix unix ts 
region spline sec 
user time sun pwb unix ts ts cb unix cb unix cb unix unix ts pdp sys practice edges connect nodes different ranks 
region kind edge boxes near tail port alternating sequence inter rank boxes virtual node boxes boxes near head port 
tail head port boxes route spline appropriate side node 
curve smoothly possible spline allowed space available 
region include virtual node boxes extra space 
spline computed virtual node boxes updated bb splines computed afterward able space remaining come close splines drawn 
splines drawn greedy strategy depend order computed 
reasonable route shorter splines drawn straight lines order affect drawing quality 
system system system details help improve appearance splines 
edges cross constrain 
spline may awkward sharp turn 
easily avoided making adjustment boxes 
setting size box ignore virtual nodes left right correspond edges cross ranks 
crossings away considered unintended multiple crossings occur boxes sloppy 
second edge section vertical looks better just draw vertical line 
obvious edges run alongside parallel line segments look better long segments slightly different slopes 
region finding procedure detects long vertical section terminates current region draws spline draws vertical line segment begins region rest edge 
situations splines vertical tangent endpoint join vertical line segment 
third splines approach common termination point important avoid accidental intersections 
check previously computed splines endpoint 
find closest ones right left 
subdivide inter rank space evaluate left right splines intervals 
points boundaries layout left right splines exist determine set boxes separate new spline existing ones approach terminal node 
left right splines boxes result seen 
subdivision inter rank box viewed approximating polygonal region necessarily aligned coordinate axes 
layouts places non aligned boxes polygons prevent unintended 
writing program try general polygons boxes 
far mentioned multiple edges pair nodes 
exist spline computed edges rest edges drawn adding increasing coordinate displacement multiples 
space multiple edges reserved previous pass described section setting separation nodes 
flat edges flat edges handled inter rank edges region routes past intervening nodes spaces nodes 
omit details quite similar 
difference edge connects adjacent nodes drawn single spline control points dx dx dx multiple flat edges spline computed succeeding edges drawn adding coordinate displacements 
edge label label positioned halfway edge 
self edges self edges drawn loops sides nodes 
edge specifies tail head ports polygonal region generated connects ports 
orientation region may clockwise counter clockwise depending positions ports 
edge specify tail head ports drawn sequence splines 


control points computed follows dx dy dx dy dx dy dx dx dy dx dy multiple edges loops nested 
edge label label positioned halfway edge 
simple case mentioned label positioned right point 
case multiple edges labels sizes labels added displacement edges 
prevents curve edge crossing label edge 
space self edges allocated previous pass described section setting separation adjacent nodes 
computing splines computation splines stages 
piecewise linear curve path lying entirely inside region computed 
endpoints path hints computation piecewise bezier spline 
actual space curve computed terms original boxes 
data structures computed stages shown 
region shown 
example contains boxes 
stages outlined 

procedure compute splines array theta theta theta theta 
compute array array 
compute array array array 
theta vector theta 
vector zero vector 
theta vector theta 
vector zero vector 
compute array array array array vector vector 
compute 

computing splines remarks 
compute array computes array 
line segment intersection box box line segments shown thicker lines boxes 
segments 
compute array computes array points 
defining feasible path connects points 
theta theta true curve constrained approach corresponding endpoint specified angles 
vector vector normalized vectors 
compute array computes array points 
defining piecewise bezier spline connects lies entirely inside region 
worst case bezier spline box 
cases approach generates significantly fewer splines 
example splines 
complex paths may fewer splines line segments line spline curve obstacles 
compute computes space taken curve 
computes array bb 
bb bb narrowest sub box containing curve 
compute array compute array implemented divide conquer methods shown 

procedure compute array array array 
line fits array array return 
compute array array 
addto array 
compute array array array 
compute array array array 

procedure compute array array array array vector vector 
spline generate spline array vector vector 
size array 
spline fits spline array array false 
straighten spline spline 
elseif spline fits spline array array false 
count 
spline 
repeat 
spline refine spline array 
mode count max iterations 
fits spline fits spline array array 
count count 
fits false count max iterations 
fits false 
compute spline array 
compute array array array array 
vector vector 
compute array array array array 
reverse vector vector 
return 
endif 
endif 
addto array spline 

spline drawing remarks 
line fits checks line defined lies entirely inside feasible region 
line clipped box line intersects box corresponding segments 
line fit compute finds segment furthest line subdivides array array segment 
endpoints subdivision segment closer line 
example path subdivided 
addto array adds array endpoints path 
recursive calls compute array complete computation path 
compute array guaranteed shortest path works developed 
important shortest path linear time convex hulls su 
generate spline computes bezier spline approximates path 
done common technique gl 
case segment path handled 
spline fits checks spline lies entirely inside region 
spline sampled length samples clipped linear path box region 
process similar line fits 
long spline fit straighten spline adjusts control points spline reduce curvature 
worst case spline line known fit inside path 
worst case produce sharp turns 
time spline fits inside region just iterations process produce visual anomalies 
region sharp turns worst case may happen 
second case path segment 
spline fit refine spline perturbs control points spline attempt spline fit 
approach similar straightening approach lines 
try decrease curvature spline 
improve fit try increase curvature 
process may terminate max iterations controls times try 
mode returns flag indicate curvature increased decreased 
spline fit refinement subdivide problem 
compute finds endpoint segment path furthest spline subdivides box path arrays point 
recursive calls compute array compute piecewise bezier splines fitting inside corresponding part region 
force curves join smoothly subdivision point force splines unit tangent vector point 
continuity subdivision point 
forcing continuity produce better results expensive compute 
straightening refining heuristics save lot time assumption tangent vectors endpoints spline scaled independently tangent vectors adjacent splines 
maintain continuity tangent vector scaled tangent vector adjacent spline scaled vectors continue length 
scaling propagate way region 
addition splines may fit scaling require subdivisions including subdivisions inside single box 
trouble worth 
addto array adds spline piecewise bezier spline 
edge labels bb 
stages dag edge labels placed midpoint spline 
oversimplification placement avoid detect overlapping splines labels nodes 
graphs edge labels small sparse technique adequate 
dot edge labels inter rank edges represented center virtual nodes 
guarantees labels overlap nodes edges labels 
certain adjustments needed sure adding labels affect length edges 
setting minimum edge length effectively doubling ranks virtual nodes created halving separation ranks compensates label nodes 
twice expensive draw graph labels labels readable 
shows drawing graph edge labels 
edge labels self edges easy handle flat edges complicated 
choose left right order virtual node label coordinate lies endpoint coordinates right left 
working problem 
sophisticated placement labels diagrams geographic maps difficult research problem deserving study 
worth remarking label placing program described freeman ahn fa larger graph drawing program 
lr ss ss 
lr lr ss lr lr lr ss lr 
finite state machine labeled transitions sec 
user time sun described method drawing digraphs 
contributions application network simplex assigning ranks final node coordinates improved heuristic reducing edge crossing method making edge splines 
method finding node coordinates allows edges coordinate endpoint displacements 
techniques straightforward program run fast interactive drawings compare previous readable visually pleasing 
address understand modify graph layout enhance readability 
lr lr improve edge crossing spline drawing heuristics 
allow interaction layout passes 
different solutions having cost phase may affect results great deal phase 
instance layouts number crossings different final coordinates 
support incremental line graph drawing animation 
stability drawing essential 

acknowledgments referees detailed comments helped clarify presentation particularly section 
wish guy jacobson steve criticisms content style 
ahu aho hopcroft ullman design analysis computer algorithms addison wesley reading massachusetts 
ca automatic display graphs computer aided decision analysis ieee transactions software engineering se pp 

ch linear programming freeman new york 
cu cunningham network simplex method mathematical programming pp 

dt di battista tamassia algorithms plane representations acyclic digraphs theoretical computer science pp 

eades mckay wormald edge crossing problem proc 
th australian computer science conf pp 

eades roberto tamassia algorithms automatic graph drawing annotated bibliography technical report cs revised version brown university department computer science providence ri october 
ew eades wormald median heuristic drawing layers networks technical report dept computer science univ queensland 
fa freeman herbert john ahn problem placing names geographic map international journal pattern recognition artificial intelligence pp 

gj garey michael david johnson computers intractability freeman san francisco 
gl glassner andrew graphics gems editor academic press san diego 
gansner north 
vo dag program draws directed graphs software practice experience pp 

gansner north 
vo rank assignment problem submitted 
gt goldberg tarjan finding minimum cost successive approximation mathematics operations research pp 

ka karmarkar new polynomial time algorithm linear programming proc 
th acm stoc washington pp 

kh khachiyan polynomial algorithm linear programming sov 
math 
doklady pp 
kn koutsofios north drawing graphs dot technical report available authors bell laboratories murray hill nj 
ro robbins isi grapher portable tool graphs pictorially helsinki finland technical report ist rs information sciences institute marina del rey ca 
rowe davis meyer spirakis browser directed graphs software practice experience january pp 

stt sugiyama toda methods visual understanding hierarchical system structures ieee transactions systems man cybernetics smc february pp 

su suri subhash 
linear time algorithm minimum link paths inside simple polygon computer vision graphics image processing pp 

ta tarjan depth search linear graph algorithms siam journal computing pp 

wa warfield john crossing theory hierarchy mapping ieee transactions systems man cybernetics smc july pp 

