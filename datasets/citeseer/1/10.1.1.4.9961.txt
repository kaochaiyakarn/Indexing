computer science department june genetic programming paradigm genetically breeding populations computer programs solve problems john koza koza stanford edu computer science department stanford university margaret hall stanford ca table contents 
overview 
examples problems requiring discovery computer program 
solving problems requiring discovery computer program 
background genetic algorithms 
genetic programming paradigm 
structures undergoing adaptation 
search space 
initial structures 
fitness function 
operations modify structures 
fitness proportionate reproduction operation 
crossover recombination operation 
state system 
identifying results terminating algorithm 
parameters control algorithm 
experimental results 
machine learning function 
boolean multiplexer function 
boolean multiplexer multiplexer functions 
non randomness results 
planning 
block stacking 
correctly stacking blocks 
efficiently stacking blocks 
parsimonious expression stacking blocks 
artificial ant traversing john muir trail 
symbolic function identification 
sequence induction 
fibonacci sequence 
hofstadter sequence 
symbolic regression 
simple example symbolic regression 
symbolic regression constant creation 
empirical discovery 
econometric time series 
kepler third law 
chaos 
trigonometric identities 
data function symbolic integration 
data function symbolic differentiation 
solving equations 
differential equations 
power series solution differential equation 
integral equations 
inverse problems 
solving functional equations 
solving general mathematical equations numeric values 
concept formation 
automatic programming 
solving pairs linear equations 
quadratic equations 
computational problems finding primes 
pattern recognition 
non linear optimal control strategy balancing broom 
case 
case ii 
finding game playing strategies 
differential pursuer evader game 
discrete game extensive form 
problems structure preserving crossover 
multiple regression 
neural network design 
summary algorithm 
identifying set terminals 
identifying function set 
establishing environmental cases 
identifying fitness function 
selecting parameters runs 
termination solution identification 
computer implementation 
computer interface 
special problems computer implementation 
minor parameters controlling algorithm 
additional operations 
mutation operation 
permutation operation 
editing operation 
define building block operation 
robustness 
performance measurement 
factors involved comparing machine learning paradigms 
premature convergence niches 
amount processing required 
theoretical discussion 

general discussion 

acknowledgments 
genetic programming paradigm genetically breeding populations computer programs solve problems john koza computer science department stanford university margaret hall stanford ca koza stanford edu seemingly different problems artificial intelligence symbolic processing machine learning viewed requiring discovery computer program produces desired output particular inputs 
viewed way process solving problems equivalent searching space possible computer programs fit individual computer program 
new genetic programming paradigm described provides way search fit individual computer program 
new genetic programming paradigm populations computer programs genetically bred darwinian principle survival fittest genetic crossover recombination operator appropriate genetically mating computer programs 
process formulating solving problems new paradigm illustrated examples various areas 
examples come areas machine learning function planning sequence induction symbolic function identification including symbolic regression empirical discovery data function symbolic integration data function symbolic differentiation solving equations including differential equations integral equations functional equations concept formation automatic programming pattern recognition time optimal control playing differential games neural network design finding game playing strategy discrete game extensive form 
overview seemingly different problems artificial intelligence symbolic processing machine learning viewed requiring discovery computer program produces desired output particular inputs 
depending terminology particular field involved computer program may called robotic action plan optimal control strategy decision tree econometric model set state transition equations transfer function game playing strategy generically composition functions 
similarly inputs computer program may called sensor values state variables independent variables attributes merely arguments function 
regardless different terminology underlying common problem discovery computer program produces desired output particular inputs 
purpose show reformulate seemingly different problems common form problem requiring discovery computer program describe single unified approach solving problems formulated common form 

examples problems requiring discovery computer program problems problems viewed problems discovering computer program produces desired output particular inputs machine learning function requires discovering composition functions return correct value function seeing relatively small number specific examples associating value function particular combinations arguments 
problem learning boolean multiplexer function example machine learning function 
show discover composition elementary boolean functions boolean multiplexer function section 
planning artificial intelligence robotics requires finding plan receives information sensors state various objects system uses information select sequence actions change state objects system 
show generate general plan correctly stacking labeled blocks target tower specified order 
show generate efficient plan solve problem including plan efficiency component fitness measure 
show generate plan allowing artificial ant traverse trail gaps various types section 
symbolic function identification requires finding function symbolic form fits discrete set data points 
symbolic function identification problems appear various forms 
simplest form sequence induction 
sequence induction requires developing computational procedure generate arbitrary element sequence sj seeing relatively small number specific examples values sequence 
example easily induce computational procedure sequence values sequence positions 
hand considerably harder identify computational procedure 
case induction heart learning ability correctly perform induction widely accepted means measuring human intelligence 
demonstrate perform sequence induction genetic programming paradigm find correct computational procedure fibonacci hofstadter sequences section 
symbolic regression form problem symbolic function identification 
symbolic regression requires finding function symbolic form fits sampling values dependent variable associated particular values independent variable 
conventional linear quadratic higher order polynomial regression requires merely finding numeric coefficients function pre specified functional form symbolic regression involves finding appropriate functional form appropriate numeric coefficients model 
show find composition mathematical functions numeric constants fits sampling data section 
empirical discovery requires finding function symbolic form fits numeric data points representing observed system 
finding empirical model system forecasting values state variables system 
rediscover known non linear econometric exchange equation pq relating time series money supply price level gross national product velocity money economy 
rediscover kepler third law empirically observed planetary data discover functional form simple chaotic function section 
symbolic data function integration symbolic data function differentiation involve finding integral derivative symbolic form unknown curve represented sampling discrete data points sections 

solving functional equations involves finding function satisfies functional equation 
show solve differential equation function symbolic form satisfies approximately satisfies differential equation associated initial conditions 
discover taylor power series solution differential equation 
similarly solve integral equations function symbolic form satisfies approximately satisfies integral equation 
solve inverse problem general functional equations 
special case solving equation numeric non functional roots 
section 
concept formation requires developing decision tree classifying object universe particular class basis attributes object 
show induce decision tree classify objects classes section 
automatic programming requires developing computer program produce desired output set inputs 
show find computational procedure solving pair linear equations real valued variable find computational procedure solving quadratic equation ax bx complex valued root solve certain trigonometric identities 
show solve computational problems finding prime numbers section 
pattern recognition requires finding computational procedure processes digitized input image determine particular pattern input image 
show translation invariant pattern recognition simple dimensional shape linear retina section 
time optimal control requires finding control strategy uses values state variables system select sequence actions change state system desired new state minimal time 
example time optimal control problem involves discovering non linear bang bang control strategy centering cart balancing broom minimal time section 
game playing requires finding strategy player specifies move player point game 
show find minimax strategy pursuer catch evader differential game simple pursuit played plane show find minimax game playing strategy discrete game extensive form section 
multiple regression form problem symbolic function identification 
multiple regression requires finding multiple valued function symbolic form fits sampling values dependent variables associated particular values independent variable 
problem multiple regression illustrates additional requirement creating random random individuals comply particular set syntactic restrictions performing structure preserving crossover individuals show find complex multiplication function section 
neural network design training involves finding neural network architecture associated set weights neural network perform desired task 
particular show discover appropriate number layers neural net number processing elements layer connections processing elements required weights 
problem neural network design illustrates additional requirement creating random random individuals comply particular set syntactic restrictions performing structure preserving crossover individuals section 

solving problems requiring discovery computer program problems type described solved flexibility computer programs available 
flexibility seek includes ability create execute computer programs size shape complexity specified advance perform alternative computations conditioned outcome intermediate calculations perform computations variables different types perform iterations recursions achieve desired result define subsequently computed values sub programs perform operations hierarchical way claim process solving problems reformulated search fit individual computer program space possible computer programs 
particular search space hyperspace lisp symbolic expressions called expressions composed functions terminals appropriate problem domain 
seen lisp expression solves problems described emerge simulated evolutionary process new genetic programming paradigm hierarchical genetic algorithm 
case simulated evolutionary process starts initial population randomly generated lisp expressions composed functions terminals appropriate problem domain 
functions may standard arithmetic operations standard programming operations standard mathematical functions various domain specific functions 
fitness function measures individual lisp expression population performs particular problem environment 
problems fitness measured sum distances taken environmental cases point range space boolean valued integer valued real valued complex valued vector valued multiple valued created expression set arguments correct point range space 
closer sum zero better expression 
predictably initial random individual expressions exceedingly poor fitness 
individuals population somewhat fit 
valley blind man king 
algorithm darwinian model reproduction survival fittest genetic recombination create new population individuals current population individuals 
particular genetic process sexual reproduction parental create offspring expressions 
participating parental expressions selected proportion fitness 
resulting offspring expressions composed subexpressions building blocks parents 
new population offspring new generation replaces old population parents old generation 
individual new population measured fitness function process repeated 
stage highly parallel locally controlled decentralized process state process consist current population individuals 
input algorithmic process observed fitness individuals current population problem environment 
seen algorithm produce populations period generations tend exhibit increasing average fitness dealing environment addition tend robustly rapidly effectively adapt changes environment 
solution produced algorithm time viewed entire population disjunctive alternative solutions typically improved average fitness compared algorithm commonly single best individual population time winner take 
hierarchical character computer programs produced genetic programming paradigm important feature genetic programming paradigm 
results genetic programming paradigm process inherently hierarchical 
cases results contain default hierarchies solve problem relatively parsimonious way 
dynamic variability computer programs developed way solution important feature genetic programming paradigm 
case difficult unnatural try specify restrict size shape eventual solution advance 
advance specification restriction size shape solution problem narrows window system views world preclude finding solution problem 
important feature genetic programming paradigm absence preprocessing inputs fact solution expressed directly terms functions arguments problem domain 
results immediately comprehensible intelligible terms problem domain 
importantly genetic programming paradigm general provides single unified approach variety seemingly different problems variety areas 
background genetic algorithms observing sexual reproduction conjunction darwinian natural selection reproduction survival fittest enables biological species robustly adapt environment professor john holland university michigan pioneering mathematical formulation simulated evolution genetic algorithms fixed length typically binary character strings adaptation natural artificial systems holland 
holland demonstrated wide variety different problems adaptive systems susceptible reformulation genetic terms potentially solved highly parallel mathematical genetic algorithm simulates darwinian evolutionary processes naturally occurring genetic operations chromosomes 
genetic algorithms superficially process particular individual binary character strings current population 
holland focused attention fact implicitly process parallel large amounts useful information concerning unseen boolean hyperplanes called schemata representing numerous additional similar individuals current population 
genetic algorithms property intrinsic parallelism enable create individual strings new population way hyperplanes representing unseen similar individuals automatically expected represented proportion fitness hyperplane relative average population fitness 
additional computation accomplished explicit computation memory population 
schaffer points hyperplanes represented population strings constitutes known example combinatorial explosion working advantage disadvantage 
addition holland established seemingly genetic operation crossover conjunction straight forward operation fitness proportionate reproduction causes unseen hyperplanes schemata grow decay generation generation rates mathematically near optimal 
particular holland established genetic algorithm mathematically near optimal approach adaptation sense maximizes expected payoff adaptive process viewed set multi armed slot machine problems allocating trials search space currently available information 
holland highlighted relative mutation evolutionary process 
regard contrasts sharply numerous efforts solve adaptive systems problem merely saving mutating best artificial intelligence simulated evolution fogel asexual mutation dawkins lenat lenat lenat 
genetic algorithms surveyed special issue machine learning journal genetic algorithms goldberg holland goldberg schaffer grefenstette grefenstette davis survey article booker special issue machine learning artificial intelligence journal 
representation key issue genetic algorithm representation scheme severely limit window system observes world 
davis steenstrup point holland students chromosomes bit strings 
string representation schemes difficult unnatural problems need powerful representations recognized time de jong de jong de jong 
smith departed early fixed length character strings introducing variable length strings including strings elements rules single characters 
various application specific variations basic genetic algorithm reported grefenstette grefenstette 
variations include structures undergoing adaptation complex strings genetic operations modified meet needs particular applications 
classifier system holland holland holland burks holland burks continued trend increasing complexity structures undergoing adaptation 
classifier system cognitive architecture genetic algorithm embedded allow adaptive modification population string rules condition action parts fixed length binary strings 
classifier system architecture blends desirable features rules expert systems precisely targeted allocation credit specific rules performance creative power genetic algorithm 
addition embedding genetic algorithm classifier system architecture creates computationally complete system example realize functions exclusive function 
exclusive function realizable early single layer linear perceptrons minsky papert exclusive function yields totally uninformative schemata similarity templates realizable conventional linear genetic algorithms fixed length binary strings 
friedberg early efforts generating computer programs simplified assembly language genetic algorithm cramer genetic algorithm generate computer programs fixed structure reported highly epistatic nature problem generating programs 
applied mutation operation lisp programs 
discussed desirability applying genetic operations lisp programs 
subsequently dickinson implemented genetic operations manipulate ifthen clauses lisp computer program consisting single cond conditional statement specifying strategies playing iterated prisoner dilemma game 
string representation schemes provide hierarchical structure central organization computer programs programs subroutines organization behavior tasks subtasks 
done alleviate problem notably wilson modification holland bucket brigade algorithm credit allocation classifier systems 
wilson hierarchical credit allocation algorithm designed encourage creation hierarchies rules discourage exceedingly long linear sequences rules characteristic classifier systems 
string representation schemes provide convenient way representing arbitrary computational procedures incorporating iteration recursion capabilities inherently necessary solve problem 
string representation schemes dynamic variability initial selection string length limits advance number internal states system computational complexity system learn 
string representation schemes facilitate representation situations computer programs modify execute 
size shape solutions pre identification particular components solutions bane machine learning systems earliest times samuel efforts automatic programming green lenat lenat brown 
genetic programming paradigm section describe genetic programming paradigm hierarchical genetic algorithms specifying nature structures undergo adaptation paradigm search space structures initial structures environment fitness function evaluates structures interaction environment operations performed modify structures state memory algorithmic system point time method terminating algorithm identifying output parameters control process 

structures undergoing adaptation structures undergo adaptation genetic programming paradigm hierarchically structured computer programs size shape complexity dynamically change process 
contrast dimensional linear strings fixed variable length characters objects cited previously 
set possible structures undergo adaptation genetic programming paradigm set possible composition functions composed recursively available set functions 
fn available set terminals 
am 
particular function takes specified number arguments bz depending particular problem interest functions may standard arithmetic operations addition subtraction multiplication division standard mathematical functions sin exp boolean operations domain specific functions logical operators iterative operators assume function function set defined value range functions 
terminals may variable atomic arguments state variables system constant atomic arguments cases may atomic entities functions arguments argument implicit real functionality function side effect function state system 
virtually programming language capable expressing evaluating compositions functions described pascal fortran forth lisp 
chosen lisp programming language developed john mccarthy described article reasons 
programs data form lisp 
means possible genetically manipulate computer program immediately execute eval function lisp 
second mentioned common form programs data lisp equivalent parse tree computer program 
spite different appearance syntax compiled programming languages convert time compilation program parse tree representing underlying composition functions 
programming languages parse tree accessible programmer 
seen need access parse tree want genetically manipulate sub parts computer programs sub trees parse tree 
lisp gives convenient access parse tree 
third lisp facilitates programming structures size shape changes dynamically predetermined advance 
lisp dynamic storage allocation garbage collection provides administrative support programming dynamically changing structures 
fourth lisp facilitates handling hierarchical structures 
fifth lisp programming language reentrant 
sixth software environments rich collection tools commercially available lisp programming language 
reasons chosen lisp programming language described 
particular chosen common lisp dialect lisp steele 
structures undergo adaptation genetic programming paradigm lisp computer programs lisp symbolic expressions 
important note choose lisp programming language described article intended list data structure list manipulation functions unique peculiar lisp programming language 
general nature lisp programming language illustrated simple example 
example lisp symbolic expression expression evaluates 
addition function appears just inside left parenthesis 
prefix form polish notation represents application function arguments convenient way express composition functions 
expression composition functions evaluates 
similarly expression time demonstrates function applied variable atom time constant atom 
sub expression time evaluates true nil false value argument function 
function returns second argument constant atom argument returns third argument constant atom argument nil 
expression evaluates depending current value time 
consider boolean exclusive function expressed disjunctive normal form represented lisp expression 
set functions set terminals 
purposes terminals viewed functions requiring zero arguments order evaluated 
combine set functions terminals combined set arguments respectively 
lisp expression graphically depicted rooted point labeled tree ordered branches 
tree corresponding lisp expression exclusive function shown graphical depiction internal points tree labeled functions external points leaves tree labeled terminals variable atoms root tree labeled function appearing just inside outermost left parenthesis lisp expression 
tree equivalent parse tree compilers construct internally represent computer program 
note set functions terminals particular problem selected capable solving problem composition available functions terminals yield solution 
removing function function set example create insufficient function set expressing boolean exclusive function 

search space search space genetic programming paradigm hyperspace valid lisp recursively created compositions available functions available terminals problem 
search space equivalently viewed hyperspace rooted point labeled trees ordered branches having internal points labeled available functions external points leaves labeled available terminals 

initial structures generation initial random population begins selecting functions set random root tree 
point labeled function takes arguments lines created point 
line created element selected random entire combined set label endpoint line 
terminal chosen label point process complete portion tree 
function chosen label point process continues 
probability distribution terminals functions combined set number arguments taken function implicitly determines average size trees generated initial random generation process 
distribution uniform random probability distribution entire set exception root tree function 
problems bias initial random generation process nonuniform distribution seeding particular individuals population 

fitness function individual population assigned fitness value result interaction environment 
fitness driving force darwinian natural selection likewise genetic algorithms 
environment set cases provides basis evaluating fitness population 
example exclusive function obvious choice environment set combinations possible values variable atoms associated value exclusive function combinations 
problems described raw fitness lisp expression sum distances taken environmental cases point range space returned expression set arguments correct point range space 
expression may boolean valued integer valued real valued complex valued multiple valued symbolic valued 
expression integer valued real valued sum distances sum absolute values differences numbers involved 
particular raw fitness individual lisp expression population size generational time step value returned expression environmental case ne environmental cases correct value environmental case expression boolean valued symbolic valued sum distances equivalent number mismatches 
expression complex valued vector valued sum distances sum distances separately obtained component vector list 
closer sum distances zero better expression 
expression component vector list real valued integer valued square root sum squares distances alternatively measure fitness increasing influence distant points 
problems described fitness function actual value returned individual expression number elapsed time total score cases handled indirectly created action expression 
raw fitness function defined way raw fitness smaller better individuals population 
problem described raw fitness adjusted scaled produce adjusted fitness measure 
adjusted fitness value raw fitness individual time raw fitness adjusted fitness larger better individuals population 
adjusted fitness lies 
adjusted fitness value normalized 
normalized fitness value normalized fitness ranges larger better individuals population sum normalized fitness values 
phrases proportional fitness fitness proportionate referring normalized fitness 
seen possible fitness function consider secondary factors efficiency expression parsimony expression compliance initial conditions differential equation 
number environmental cases large compute fitness function sampling possible environmental cases including possibly sampling varies generation generation minimize possible bias resulting sampling 

operations modify structures primary operations modifying structures undergoing adaptation darwinian fitness proportionate reproduction crossover recombination 
described 
additional operations described section 

fitness proportionate reproduction operation operation fitness proportionate reproduction genetic programming paradigm basic engine darwinian reproduction survival fittest 
operates parental expression produces offspring expression time performed 
asexual operation 
si fitness individual si population generation time operation performed individual population probability si sj copied generation operation fitness proportionate reproduction 
note parents remain population operation performed potentially participate repeatedly operation operations current generation 
selection parents done replacement allowed 

crossover recombination operation crossover recombination operation genetic programming paradigm creates variation population producing offspring combine traits parents 
crossover operation starts parental expressions produces offspring expression 
sexual operation 
offspring produced occasion crossover operation performed 
general parent chosen population probability equal respective normalized fitness values 
parents chosen 
operation begins randomly independently selecting point parent probability distribution 
note number points parents typically equal 
seen crossover operation defined expressions 
expressions crossover points resulting offspring valid lisp expressions 
offspring consist parts taken parent 
crossover fragment particular parent rooted sub tree root crossover point parent sub tree consists entire sub tree lying crossover point distant root original tree 
viewed terms lists lisp crossover fragment sub list starting crossover point 
offspring produced deleting crossover fragment parent parent crossover fragment second parent crossover point parent 
producing offspring parent acts base parent female parent second parent acts parent male parent 
second offspring produced symmetric manner 
example consider parental lisp expressions 
terms lisp expressions parents assume points trees numbered depth way starting left 
suppose second point points parent selected crossover point parent sixth point points second parent selected crossover point second parent 
crossover points function parent function second parent 
bold underlined portion parent crossover fragments 
crossover fragments shown offspring resulting crossover shown 
note offspring perfect solution exclusive function 
note entire sub trees swapped genetic crossover recombination operation produces valid lisp expressions offspring regardless point selected parent 
root tree happens selected crossover point crossover operation insert entire parent second tree crossover point second parent 
addition sub tree second parent case second offspring 
roots parents happen chosen crossover points crossover operation simply degenerates instance fitness proportionate reproduction parents 
note individual mates resulting offspring generally different crossover points selected different 
terminal located crossover point precisely parent sub tree second parent inserted location terminal parent terminal parent inserted location sub tree second parent 
case crossover operation effect increasing depth tree decreasing depth second tree 
terminals located crossover points selected crossover operation merely swaps terminals tree tree 

state system state hierarchical genetic algorithm system generation consists current population individuals population 
additional memory centralized bookkeeping directing adaptive process 

identifying results terminating algorithm solution produced algorithm time viewed entire population disjunctive alternatives presumably improved average fitness commonly single best individual population time winner takes 
algorithm terminated specified total number generations run performance criterion satisfied 
problems performance requirement termination may sum distances reaches value zero 
solution recognized encountered algorithm terminated time single best individual considered output algorithm 

parameters control algorithm algorithm controlled various parameters including major parameters minor parameters 
major parameters population size number generations run 
population size problems described section exception multiplexer problem 
boolean multiplexer solved common population size noted search space larger version multiplexer problem search space size approximately multiplexer problem indicate larger population size particular problem 
especially large population size chosen particular problem order force number generations required arrive solution practical create complete genealogical audit trail problem 
number generations initial random generation subsequent generations 
note termination algorithm control performance criterion case parameter merely provides maximum number generations run 
major parameters problems described section exception noted 
minor parameters discussed section problems described article 
reason think selection major parameters minor parameters optimal 
fact clear computational resources needlessly wasted problems described convergence needlessly hampered problems specific choice parameters decision parameters problems described article 
problem optimal parameter selection interesting important issue affecting string genetic algorithms hierarchical genetic algorithms machine learning paradigms 
problem optimal parameter selection deserving 
discovery theoretical framework making parameter selections optimal way welcome 
purpose study optimization parameters illustrate surprising range seemingly different problems couched solved new common unified approach described 
common approach consists viewing original problem problem requiring discovery computer program solve problem making original problem problem searching space possible computer programs fit individual computer program 
genetic programming paradigm provides way finding individual computer program 
fact admittedly non optimal essentially arbitrary set parameters problems described section help focus attention fact variety different problems different areas successfully handled result depend parameter selection 
experimental results section describes experiments machine learning genetic programming paradigm 
section show approached problem solved genetic programming paradigm result particular run problem 
experiments selected illustrate variety different types problems various different areas 
sample problems selected involve functions integer valued realvalued boolean valued vector valued complex valued symbolic valued 
problems require recursion solution 
problems require types iteration described 
problems involve functions real functionality side effects cause state system involved return values 
problems involve functional abstractions give name useful sub program computed value subsequently computer program 
order provide degree comparability previous research problems described benchmark problems previously reported literature connection existing paradigms machine learning artificial intelligence induction neural nets decision trees classifier systems 
cases previously studied problems certain difficulties paradigms machine learning artificial intelligence induction neural nets classifier systems 
algorithm probabilistic get precisely result twice 
get solution problem form contemplated solutions may equivalent contemplated 
particular run particular solution truly typical representative 
purpose section illustrate genetic programming paradigm showing particular illustrative result particular run 
choosing particular result run illustrative purposes section avoided showing solution similarly avoided showing convoluted solution 
section way statistically measuring performance genetic programming paradigm amount computer processing required produce solution probability run involved particular population size run cut particular number generations 
problems repeatedly solved numerous occasions typically dozens hundreds times 
experiment reported author believes sufficient information provided allow experiment independently replicated produce substantially similar results limits inherent process involving stochastic operations 
discussion computer implementation computer interface monitor runs unique programming problems associated executing ill behaved randomly generated genetically modified computer programs section 

machine learning function problem machine learning function requires developing composition functions return correct value function seeing relatively small number specific examples value function associated particular combinations arguments 

boolean multiplexer function experiment problem learn boolean multiplexer function 
general input boolean multiplexer function consists address bits ai data bits di string length form value multiplexer function value particular data bit singled address bits multiplexer 
example multiplexer address bits multiplexer singles sixth data bit output 
output example considerable detail order show interplay genetic programming paradigm genetic variation inevitably created initial random generation small improvements localized hill climbing generation generation way particular individuals specialized able correctly handle certain sub cases problem case splitting creative role crossover recombining valuable parts fit parents large population disjunctive alternative solutions problem single point solution space helps avoid false peaks 
boolean multiplexer problem reasons 
problem easily quantifiable search space 
secondly especially easy understand components boolean expression contribute performance boolean expression contrast problems discussed 
third boolean problems fewer computer implementation problems problems discussed 
fourth boolean multiplexer problem previously test function studies neural nets barto classifier systems wilson decision trees quinlan 
step applying genetic programming paradigm problem select set functions arguments available algorithm constructing computer programs expressions try solve problem 
problems particular boolean function learning problems choice especially straight forward obvious 
set available functions problem 
set basic logical functions sufficient problem involving boolean function addition convenient set produces easily understood expressions 
functions take arguments 
function takes argument 
function common lisp function takes arguments 
function set boolean problems described 
set available terminals problem elements correspond inputs boolean multiplexer 
terminal set 

potential set structures undergoing adaptation problem set lisp expressions recursively composed set available functions set available terminals 
boolean multiplexer function arguments possible boolean functions arguments 
search space boolean multiplexer size search space size approximately possible boolean function arguments realized lisp expression composed functions terminals 
disjunctive normal form way 
environment consists possible combinations arguments associated correct value multiplexer function 
multiplexer combinations arguments environment 
particular problem entire set combinations arguments sampling environment 
raw fitness lisp expression sum distances taken environmental cases point returned expression set arguments correct point 
boolean value returned expression distance return value matches correct value match 
sum distances environmental cases equivalent number mismatches 
raw fitness range different values 
raw fitness denotes correct individual 
note fitness particular problem takes specific value correct individual way recognize attainment solution problem 
highly useful define auxiliary measure monitoring progress runs counts number hits expression correct value 
problem number hits simply minus raw fitness mismatches 
problems involving integer values discussed auxiliary measure counts number hits expression correct environmental value raw fitness cumulative distance measure 
real valued problems discussed auxiliary measure counts number near hits expression comes small specified tolerance called criterion correct environmental value 
hits near hits measures monitoring runs accessible genetic algorithm problem discussed 
illustrate process discussing particular run boolean multiplexer detail 
process begins generation initial random population generation 
predictably initial random population includes variety highly unfit individuals 
individual expressions involve logical contradictions 
involve inefficiencies 
passive merely pass input output 
initial random individuals base decision precisely wrong arguments data bits 
initial random individuals partially blind incorporate arguments known necessary solution problem 
expressions just nonsense 
highly unfit initial random population individuals somewhat fit 
run question individuals initial random population generation raw fitness values ranging mismatches hits mismatches hits 
happens total individuals tied high score hits generation 
individual expression 
spite obvious shortcomings partially blind uses necessary terminals problem individual things right 
uses address bit basis action 
addition uses data bits output 
low order binary bit bit address true odd numbered data bit selected nil numbered data bit selected 
individual far perfect fit 
worst individual population raw fitness hits 
average raw fitness generation 
hits histogram provides additional details population particular generation 
horizontal axis number hits vertical axis number individuals population scoring number hits 
example total different levels raw fitness represented population generation 
individuals raw fitness highest score generation 
shows histogram population generation run problem 
new population created current population operations fitness proportionate reproduction crossover 
operations completed new population new generation replaces old population 
starting generation average raw fitness population immediately begins improving decreasing baseline value generation 
typically see kind generally improving trend average raw fitness generation generation 
happens particular run average raw fitness improves monotonically generation generation assumes values 
time typically see generally improving trend raw fitness best individual population generation generation 
happens particular run raw fitness number mismatches best single individual population improves monotonically generation generation assumes values hits perfect score hits respectively 
hand raw fitness worst individual population typically fluctuates considerably 
particular run number starts deteriorates hits generation 
number hits best single individual population rises generations run 
generation example individual population score 
note individual performs better best individual generation considers address bits deciding data bit choose output incorporates data bits potential output 
contrast best individual generation considered address bit incorporated data bits potential output 
far perfect best individual generation blind complex best individual previous generation 
generation number individuals sharing high score hits rose 
high point histogram generation advanced generation 
individuals hits 
generation individual population attained new high score hits 
individual 
generation shows advances fitness population 
number individuals fitness high point generation risen generation 
center gravity fitness histogram shifted left right 
particular number individuals fitness better risen generation generation 
generations best individual score hits 
score attained individual generation individuals generation 
best individual 
note individual uses address bits deciding output 
uses data bits 
generation high point histogram moved individuals 
generation individuals attain score 
high point histogram moved 
generation individuals attain score 
generation individuals attain score 
high point histogram moved individuals share value 
addition individuals score 
generation individual emerges perfect score hits 
individual correct individual depicted graphically correct individual simplified manually editing operation described 
rewritten seen individual correctly performs multiplexer function examining address bits choosing appropriate possible data bits 
progresses generation left right slinky movement center mass histogram single best individual high point histogram 
insight gained studying genealogical audit trail process 
audit trail consists complete record details instance operations 
case operations fitness proportionate reproduction crossover details consist individual chosen operation particular point chosen participating individual 
construction audit trail starts individuals initial random generation generation 
certain additional information individual rank location population sorting normalized fitness raw fitness carried convenience interpreting genealogy 
operation performed create new individual generation list recursively formed consisting operation performed individual participating operation details operation pointer audit trail accumulated far individual participating operation 
individual occurring generation ancestors 
number ancestors extent operations crossover involved crossover far frequent operation 
example individual occurring generation ancestors 
note particular ancestor appears genealogy selections individuals participate basic genetic operations skewed proportion fitness 
modest sized value typically greater population size 
repetition course reduce size genealogical tree 
pointers descendants back ancestors construction complete genealogical audit trail exponentially expensive computer time memory space 
note audit trail constructed individual generation identity correct individual eventually solving problem known advance 
audit trails 
generation audit trails recursively incorporates information operations involving ancestors 
order minimize size audit trail depends number generations involved selected relatively large population force number generations needed produce correct individual 
audit trail single individual interest generation occupies densely printed pages 
creative role crossover case splitting illustrated examination genealogical audit trail correct individual emerging generation 
correct individual emerging generation child resulting common genetic operation process crossover 
male parent generation rank location population scored hits 
female parent generation rank location scored hits 
note entirely typical individuals selected participate crossover relatively rank locations population crossover performed individuals mating pool created fitness proportionate reproduction 
male parent generation scoring 
male parent shown note male parent starts examining address bit 
underlined portion examines address bit partially blindly output equal considering address bit 
underlined portion individual contain data bits 
hand nil individual correct 
case examines examines output equal nil 
nil twice unnecessarily correctly output equal 
words imperfect individual handles part environment correctly part environment incorrectly 
particular father correctly handles numbered data bits incorrectly handles odd numbered data bits 
tree representing male parent points 
crossover point chosen second occurrence function 
crossover fragment consists incorrect underlined sub expression 
female parent generation scoring female parent generation shown tree representing female parent points 
crossover point chosen third occurrence function 
crossover fragment consists underlined sub expression 
sub expression correctly handles case making output equal address bits making output equal address bits making output equal address bits making output equal address bits 
female parent correctly nil 
words mother correctly handles data bits incorrectly handles numbered data bits 
imperfect individuals contain complementary adapted portions mated produce correct offspring individual 
effect creative effect crossover operation blended cases implicitly case split environment single correct solution 
course combinations individuals correctly handle groups cases environment useful productive 
fact large fraction individuals produced genetic operations useless 
existence population alternative disjunctive solutions problem provides ingredients genetic recombination crossover produce improved individuals 
pressure natural selection fitness causes improved individuals preserved proliferate 
genetic variation existence population alternative disjunctive solutions problem prevents entire process trapped local maxima 
interestingly crossover produced correct individual produced runt scoring hits 
particular crossover crossover fragments correct individual combined produce unusually unfit individual 
reasons considerable variability generation generation worst single individual population usually generally monotonic improvement generation generation best single individual population average fitness population 
traces ancestry correct created individual generation deeper back genealogical audit tree earlier generations encounters parents scoring generally fewer fewer hits 
encounters expressions perform irrelevant counterproductive partially blind incorrect 
look sequence hits forwards direction see localized hill climbing search space occurring parallel population creative operation crossover complementary adapted portions parents produce improved offspring 
boolean multiplexer multiplexer functions applied genetic programming paradigm simple boolean multiplexer multiplexer 
example run koza obtained correct solution boolean multiplexer problem 
note result genetic programming paradigm inherently hierarchical 
addition default hierarchies emerge genetic programming paradigm 
default hierarchies incorporate partially correct sub rules perfect procedure allowing partially correct sub rules handle majority cases dealing way certain specific cases 
solution default hierarchy 
expression output defaults specific case address bits multiplexer problem output data bit 
default hierarchies considered desirable induction problems classifier systems goldberg holland holland parsimonious human way dealing situations 
wilson noteworthy boole experiments originally set classifier system rules boolean multiplexer correctly exhaustively handled particular subcase problem 
subsequently wilson modified credit allocation algorithm holland classifier system successfully produced default hierarchy parsimoniously solved problem 
default hierarchies emerge genetic programming paradigm 
addition tried multiplexer function function deleted function set 
function set 
run obtained correct solution 
tried multiplexer function equivalent simple function function set 
run obtained correct solution disjunctive normal form equivalent 
non randomness results number possible compositions available set functions terminals large 
particular number possible trees representing compositions functions increases rapidly function number points tree 
true large number ways labeling points tree functions terminals 
number possible compositions functions large relation individuals processed generations involved run 
theoretic possibility probability solution problem may low original search space multiplexer problem boolean functions arguments probability randomly generating composition functions solves problem significantly higher space randomly generated compositions functions 
boolean multiplexer function unique function possible boolean functions arguments output 
probability randomly choosing zeroes ones lines truth table create particular boolean function 
theoretic possibility probability randomly generating composition functions performs multiplexer function higher priori reason believe case 
priori reason believe compositions functions solve boolean multiplexer problem problems discussed denser space randomly generated compositions functions solutions problem original search space problem 
possibility case priori reason think case 
test possibility performed control experiment boolean multiplexer problem 
generated random expressions check randomly generate composition functions solved problem 
control experiment algorithm parameters generate initial random population normal runs problem 
correct individual random search 
fact high score random search hits possible hits low score hits 
individuals achieved high score 
high point histogram distribution hits random individuals came hits individuals second highest point came hits individuals third highest point came hits individuals 
similar control experiment conducted boolean multiplexer problem search space 
environment problem environmental cases compared cases multiplexer practical evaluate randomly generated individuals control experiment 
correct individual random search 
fact individual possible hits 
multiplexer size search space large relation number individuals processed typical run solving problem 
additional control experiments involving individuals run problems described encountering correct solutions 
conclude solutions problems space randomly generated compositions functions denser solutions original search space problem 
conclude results described fruits random search 
matter fact evidence suggesting solutions problems described appreciably sparser space randomly generated compositions functions solutions original search space problem 
consider example exclusive function 
exclusive function parity function boolean arguments 
parity function boolean arguments returns number arguments equal odd returns 
boolean functions arguments boolean functions arguments boolean functions boolean arguments 
exclusive function possible boolean functions boolean arguments output 
search space boolean functions probability randomly choosing zeroes ones lines truth table realizes particular boolean function 
generated random individuals function set consisting basic boolean functions 
randomly generated compositions basic boolean functions realize exclusive function dense solutions original search space problem space boolean functions arguments expect random compositions functions realize exclusive function 
randomly generated compositions realized exclusive function 
frequency compared expected frequency 
words randomly generated compositions functions realizing exclusive function times sparser solutions original search space boolean functions 
similarly generated additional random individuals function set consisting basic boolean functions 
randomly generated compositions realized exclusive function frequency 
new function set randomly generated compositions functions realizing exclusive problem times sparser solutions original search space boolean functions 
addition performed similar experiments boolean functions boolean arguments parity function multiplexer function function 
boolean functions boolean arguments 
randomly generated composition functions random compositions functions realized parity function multiplexer function 
probability randomly generating composition functions realizing problems high probability randomly choosing zeroes ones lines truth table expected random compositions realize boolean functions arguments 
results concerning exclusive function parity functions parity function multiplexer functions surprising parity multiplexer functions long identified researchers functions pose difficulties paradigms machine learning artificial intelligence neural nets classifier systems 
recognized difficulty reason parity multiplexer functions various number arguments benchmark functions studies paradigms machine learning artificial intelligence neural nets classifier systems 
summary benchmark boolean functions compositions functions solving problem substantially dense solutions search space original problem 
reader remember origin concern compositions functions solving problem denser solutions problem search space original problem 
lenat discovering mathematical laws heuristic search related lenat mathematical laws sought stated cases directly terms list primitive data type lisp programming language 
addition lists lenat artificial mathematical am laws manipulated list manipulation functions unique peculiar lisp 
specifically experiments lenat mathematical laws sought stated directly terms lists list manipulation functions car returns element list cdr returns tail list lenat mea article am appear lenat brown lenat recognized lisp syntax may overly facilitated discovery previously reported results mathematical laws stated terms lisp list manipulation functions lisp primitive object list 
contrast problems described stated solved terms objects operators unique peculiar lisp 
solution boolean multiplexer function expressed terms ordinary boolean functions 
solutions numerical problems discussed symbolic regression broom balancing expressed terms ordinary arithmetic operations addition subtraction multiplication division 
solutions planning problems block stacking expressed terms ordinary iteration operations various domain specific robotic actions robotic actions move block place 
virtually programming language express solutions problems 
previously discussed lisp programming language chosen reported primarily convenient features lisp notably fact data programs form lisp common form corresponds parse tree computer program convenient features available implementations lisp notably ease computer programs manipulated data immediately executed 
lisp programming language chosen presence lisp list primitive data type lisp functions manipulating lists 
fact lists list manipulation functions involved problems described irrelevant indirect sense lisp programming language uses lists things unseen user programming languages different ways 
parse tree lisp conveniently available manipulation parse tree programming languages construct internally time compilation 
parse tree direct mapping composition functions computer program 
need access parse tree crossover way want sub parts computer programs 
lisp programming language gives convenient access parse tree ability conveniently manipulate program data convenient ability immediately execute newly created parse tree 
summary priori reason reason discovered think syntax programming language chose lisp easier discover solutions problems involving ordinary non list objects ordinary non list functions 
addition control experiments verify results obtained fruits random search 

planning planning artificial intelligence robotics requires finding plan receives information sensors state various objects system uses information select sequence actions change state objects system 

block stacking nilsson robotic action network solves planning problem described nilsson ginsberg involving rearranging uniquely labeled blocks various towers arbitrary initial arrangement arbitrary specified new order single target tower 
version problem involving blocks blocks labeled different letters universal 
experiment goal automatically generate plan nilsson solves problem 
problem typical problems artificial intelligence primarily symbolic 
problem illustrates technique associating lisp variable atoms state variables problem functions cause side effects altering state system 
problem typical computer programs general iterative operator du solution problem 
discussion follow formulation problem specific lists sensors functions described nilsson exist equivalent alternative versions problem 
lists involved formulation problem 
goal list ordered set specifying desired final order blocks stacked target tower universal 
stack ordered set blocks currently target tower order important 
table set blocks currently target tower order important 
initial configuration consists certain blocks stack remaining blocks table 
desired final configuration consists blocks stack order specified goal list blocks table sensors dynamically track system formulation problem nilsson ginsberg 
sensor tb top correct block dynamically specifies car element list longest cdr list remaining elements list stack matches cdr goal list 
sensor nn needed dynamically specifies needed block stack immediate predecessor tb goal list 
sensor cs dynamically specifies car stack top block stack 
set terminals available solving problem tb nn cs 
terminals variable atom may assume value block labels nil 
combined set functions available solving problem contains functions ms mt du eq 
functions eq usual boolean common lisp negation equality functions 
functions described 
function ms move stack argument 
expression ms moves block top stack table 
function ms stack table empty nil 
function function mt described returns nil real functionality side effects stack table return values 
function mt move table argument 
expression mt moves top item stack table stack contains stack 
function mt table stack empty nil 
iterative operator du arguments 
expression du predicate iteratively predicate satisfied 
du operator similar repeat loop programming languages 
note predicate arguments evaluated outside iterative du operator passed du operator du operator called 
arguments evaluated dynamically inside du operator iteration 
evaluated inside du operator 
predicate evaluated inside du operator 
separate evaluations performed sequence lisp function eval inside du operator 
note iterative construction execution change variable tested predicate 
usually purpose loop 
important suppress premature evaluation predicate arguments du operator 
evaluation arguments iterative summation operators described article similarly postponed 
problem iterative function du general indexing variable ii updated iteration 
genetic programming paradigm described involves executing randomly generated computer programs number computer implementation issues addressed 
particular individual expressions genetic population contain unsatisfiable termination predicate 
practical necessity working serial computer place limit number iterations allowed execution du operator 
individual expressions genetic population contain complicated deep nestings numerous du operators similar limit placed total number iterations allowed du functions may evaluated process evaluating individual expression particular environmental case 
termination predicate du opera tor implicit disjunction explicit predicate argument predicate additional implicit termination predicates 
typical time limits du operator times iterations evaluation single du operator total iterations du operators evaluated particular individual expression particular environmental case 
course execute individual lisp expressions parallel nature infeasibility individual population bring entire process halt need limits 
note du operator times returns value 
particular du operator evaluates implicit termination predicates times 
value resulting evaluation du operator course addition side effects du function state variables system particularly stack table block stacking problem 
predicate du operator satisfied operator called du operator simply returns note fact function returns value conditions addition side effects stack table inherent flexibility lisp language guarantee possible individual expression executed evaluated composition functions arguments may arise 
environment consists millions different environmental cases blocks distributed stack table 
raw fitness particular individual plan population number environmental cases particular plan produces desired final configuration blocks plan executed 
computation fitness problem genetic algorithm adaptive systems problems significantly shortened consolidating various inherently similar initial configurations sampling 
particular blocks cases blocks initial stack correct order blocks top correctly ordered blocks initial stack 
additional cases precisely order block initial stack top number correctly ordered blocks happen initial stack 
additional initial cases order blocks initial stack top various number correctly ordered blocks initial stack 
lieu environment environmental cases constructed environment consisting cases blocks stack correct order cases precisely order block initial stack top number blocks happen initial stack structured random sampling additional environmental cases correctly ordered blocks initial stack various random numbers order blocks top blocks 
complete structured random sampling problem contained total environmental cases raw fitness ranged values 
obviously consolidation sampling process done care process misled producing solutions correctly handle smaller environment correctly handle entire environment 

correctly stacking blocks version block stacking problem involves finding general plan correctly stack blocks stack desired order starting environmental cases 
plan executed evaluated environmental cases 
initial random population plans predictably low fitness 
initial random plans complicated inefficient pointless counter productive 
typical random initial plans plans eq mt cs nn ms tb 
plan unconditionally moves top stack table performs useless boolean comparison sensor value nn return value mt function 
second plan ms tb attempts move block tb stack table stack 
initial random plans ill formed perform action stack table 
leave untouched environmental case consisting perfectly arranged plans achieve raw fitness level maximum initial random plans unfit disrupt perfectly arranged initial stack 
plans achieve fitness level 
initial random plans achieve modest fitness levels contain particular specific action sequences happen specific small number environmental cases 
example plan eq ms nn eq ms nn ms nn moves needed block nn table stack times 
plan works particular specific environmental cases initial stack consists correct blocks order blocks 
run individual plan emerged generation correctly handled environmental cases 
plan correctly handles cases group blocks initially stack happen correct order order blocks top correctly ordered blocks 
plan du ms nn nn uses iterative operator du iteratively ms nn moving needed block stack table predicate nn satisfied 
predicate satisfied blocks needed finish stack needed sensor nn nil 
plan course produce correct final stack block initially stack incorrect 
shows partially correct plan moving needed blocks stack containing correct order 
plan performs incorrectly environment cases prove useful building block final correct plan 
additional generations run performance best single individual plan population typically increases somewhat generation generation correctly deals additional cases environment 
time average fitness population tends increase somewhat generation generation population begins contain additional higher scoring plans 
run best individual population generation achieved perfect score plan produced desired final configuration blocks stack initial environmental cases 
correct plan eq du mt cs cs du ms nn nn 
depicted graphically mt cs du cs eq ms nn du plan consists sub plans connected function eq merely serving connective 
sub plan du mt cs cs iteratively moving cs top stack table predicate cs top stack nil 
second sub plan iteratively moving needed block nn stack remaining needed block nn 
notice previously discovered partially correct plan du ms nn nn incorporated subplan final correct solution 
subplan part hierarchy created result crossover applied proportion fitness 

efficiently stacking blocks particular correct solution discovered typical vast majority plans generated inefficiently removed blocks stack correct order moved blocks table stack 
result plan block movements handle environmental cases 
efficient way solve problem terms minimizing total block movements remove order blocks stack move needed blocks stack 
happens block movements required environmental cases efficient approach 
simultaneously breed population attributes 
particular specifically breed population plans stack blocks correctness efficiency combined fitness measure assigns majority weight say correctness minority weight say secondary attribute efficiency 
run example best individual initial random population generation performed correctly environmental cases involved total block movements 
generation best individual population du eq du mt cs eq cs tb du ms nn nn nn plan correct efficient terms total block movements 
uses minimum number block movements correctly handle environmental cases 
plan graphically depicted nn mt cs du eq cs tb eq ms nn du du nn plan sub plan du mt cs eq cs tb iteratively moves cs top block stack table predicate eq cs tb satisfied 
predicate satisfied cs top stack equals tb top correct block stack 
shows order blocks moved table stack top stack 
top stack cs equals tb 
previously discovered second sub plan du ms nn nn iteratively moves needed blocks nn stack longer needed block 
notice function eq serves connective sub plans 
notice outermost du function performs function harm predicate nn satisfied time identical predicate second sub plan 
regard elements similar approximately nucleotide bases approximately molecule human acid get expressed protein 

parsimonious expression stacking blocks particular solution discovered correct efficient points tree corresponding expression 
including parsimony fitness function weight addition correctness weight bred population parsimony correctness obtained expression consisting points eq du mt cs eq cs tb du ms nn nn 
nn 
artificial ant traversing john muir trail jefferson collins 
devised complex task artificial ant attempting traverse trail produced noteworthy solution form finite state automaton multi layer recurrent neural net directing ant motions 
setting problem defined jefferson collins square grid containing stones cells remaining cells 
john muir trail winding trail stones single missing stones double missing stones missing stone corners double missing stones corners knight moves triple missing stones corners long knight moves 
santa fe trail devised farmer somewhat complicated trail features 
artificial ant begins cell identified coordinates facing particular direction east trail 
artificial ant sensor see single adjacent cell direction ant currently facing 
time step ant capacity execute operations move forward direction facing turn right move turn left move 
grid toroidal ant moves edge grid reappears continues opposite edge 
objective ant traverse entire trail 
ant moves particular cell stone stone credited ant account cell converted blank cell counted 
ant score measured total number stones finds certain time limit jefferson collins 
start jefferson collins started assuming finite automaton necessary solve problem fewer states 
represented individual population automata binary string representing state transition diagram initial state individual automaton 
ant sensory input time step coded bit output time step coded bits possible operations 
state automaton coded bits 
complete behavior automaton specified genome consisting binary string bits substrings length representing state transitions plus additional bits representing initial state automaton 
finite automaton executed time step 
processed population individual bit strings length connection machine genetic algorithm crossover mutation operating selected relatively small fraction population 
generations particular run hours connection machine jefferson collins reported single individual population emerged attained perfect score stones 
happened single individual completed task exactly operations 
jefferson collins similarly successful discovering multi layer recurrent neural net task 
effort assumed neural net necessary solve problem processing units input layer representing possible sensory inputs ant processing units inputs hidden layer processing units inputs output layer possible operations 
genome encoding neural net contained bits representing weights associated inputs thresholds initial activation levels processing units 
approach task genetic programming paradigm function set consisted functions sensor progn 
sensor function arguments evaluates argument ant sensor senses stone evaluates second argument 
progn function common lisp connective function sequentially evaluates executes arguments program terminal set advance turn right turn left consists functions arguments operate side effects ant state ant position grid ant facing direction 
notice equally acceptable place terminals function set zero arguments terminal set notice sensor advance turn right turn left correspond directly operators defined jefferson collins john muir trail 
allowed time steps timing 
randomly generated individuals generation usual highly unfit performing task 
individuals blind consult ant sensor decide 
runs best randomly generated individual individual sensor advance turn right sensor advance turn left equivalent 
individuals scored stones possible 
individuals successfully handle right left turns trail provided stone missing point trail turns 
score stones stone missing trail turns upper right area trail ant point stone having erased time step 
run involving usual population size individuals individual scoring emerged th generation sensor advance progn turn right sensor advance turn left progn turn left sensor advance turn right advance 
plan graphically depicted advance turn sensor progn sensor advance turn progn turn sensor advance advance turn individual plan moves ant forward stone sensed 
turns right moves ant forward stone sensed turns left returning original orientation stone sensed 
turns left moves forward stone sensed turns right returning original orientation stone sensed 
ant originally sense stone ant moves forward unconditionally fifth operation 
note testing backwards directions 
experiment repeated somewhat complicated santa fe trail designed farmer successfully produced equivalent plan 

symbolic function identification problems area symbolic function identification require finding function symbolic form fits sampling data points 

sequence induction sequence induction requires developing computational procedure generate arbitrary element infinite sequence sj seeing relatively small number specific examples values sequence 
example easily induce computational procedure sequence values 
hand considerably harder identify computational procedure 
case induction heart learning ability correctly perform induction widely accepted means measuring human intelligence section problem induce computational procedure lisp sequence seeing small number examples sequence 
examples sequence induction discussed recursion 

fibonacci sequence elements si fibonacci sequence computed recursive expression sj sj 
experiment environment adaptation take place consists elements actual fibonacci sequence 
lisp expression possible lisp expression correctly computes fibonacci sequence starting 
particular representation index sequence element computed 
elements sequence base cases 
expression call true recursive way function expression returns value current expression sequence position provided returns 
notice function returns value computed current expression actual correct value fibonacci sequence 
combined set functions terminals available problem having arguments respectively 
note set available function include sequence referencing function functional equivalent known previous sequence elements necessary order compute fibonacci sequence integral domain 
examples random expressions initial random population problem included expressions 
expression attempts compute th element sequence considering expression evaluates constant 
expression attempts compute fibonacci sequence making essential sequence referencing function generation best individual expression population perfect score matches 
individual correct albeit non parsimonious solution problem 
individual graphically depicted alternative approach induction fibonacci sequence values base cases discovered function arguments koza 
successfully performed induction fibonacci sequence values base cases discovered function set included function 
order save computer time elements sequence computed order previous elements sequence available expression attempts compute new element sequence recursively calling earlier elements sequence 

hofstadter sequence elements si hofstadter sequence wolfram computed recursive expression sj sj sj 
experiment environment adaptation take place consists elements highly irregular non monotonic hofstadter sequence 
run number hits generations respectively correct expression emerged generation 
symbolic regression linear regression set values various independent variable corresponding values dependent variable 
goal discover set numerical coefficients linear combination independent variable minimizes measure error sum squares values computed values dependent variable 
similarly quadratic regression goal discover set numerical coefficients quadratic expression similarly minimizes error 
fourier regression goal discover set numerical coefficients sin cos functions various periodicities similarly minimizes error 
course left researcher decide linear regression quadratic regression higher order polynomial regression try fit data points family functions sines cosines various periodicities 
issue deciding type function appropriately fits data merely computing numerical coefficients type function model chosen 
words problem discovery correct functional form fits data discovery appropriate numeric coefficients 
call problems symbolic regression 

simple example symbolic regression example suppose sampling numerical values unknown curve points domain interval 
pairs points xi yi 
points include pairs 
goal find function symbolic form perfect fit fit pairs numerical data points 
unknown curve happens example 
solution problem finding function symbolic form fits sample data viewed search function hyperspace functions composed set candidate functions arguments 
set terminals particular problem consists just independent variable 
set available functions include addition subtraction multiplication restricted division function sine function sin cosine function cos exponential function exp restricted logarithm function rlog 
restricted division function returns zero division zero attempted composition functions function set terminals terminal set produces valid result 
restricted logarithm function rlog returns argument returns logarithm absolute value argument 
functions restricted manner return valid floating point number 
function set sin cos exp rlog 
run worst single individual expression initial random population generation exp rlog rlog 
sum absolute values differences worst single expression data points approximately median th best individual initial random population cos cos 
individual equivalent cos cos raw fitness 
average distance curve individual function curve points 
cos cos second best individual initial random population rlog sin sin individual raw fitness 
average distance curve function curve points 
rlog sin sin best single individual population generation expression sin rlog exp exp 
expression equivalent xe sum absolute value differences expression data points average difference data point 
xe came criterion data cases 
scored near hits data 
note number near hits externally purposes monitoring describing process genetic algorithm 
particularly fit perfect fit better worst individual 
better median individual 
better randomly created expressions 
graphed bears similarity target 
addition gross characteristics target function 
example zero zero 
approaches approaches approaches somewhat nearby value 
generation best single individual improved equivalent raw fitness best individual improved 
scored near hits 
expression bears greater similarity target expression predecessors 
example polynomial correct order 
coefficients terms correct incorrect coefficients different correct coefficients 
notice numerical coefficients explicitly provided terminal set fractional coefficient created process creating dividing multiplying coefficient similarly created 
generation raw fitness best single individual population attained perfect value 
individual scored near hits 
individual 
expression equivalent 
symbolic regression constant creation discovery appropriate numeric coefficients problem addressed order successfully symbolic regression general 
foregoing simple example symbolic regression terminal set consisted independent variable explicit facility constant creation constant created algorithm dividing address issue constant creation 
problem constant creation solved extending terminal set ephemeral element called generation initial random population 
terminal set enlarged particular problem 
ephemeral atom chosen point tree generation initial random population random number specified range generated attached tree point 
realvalued problem problem random constants floating point numbers 
problem involving integers induction sequence integers random integers specified range generated ephemeral atoms 
boolean problems ephemeral atoms replaced true nil 
note random generation done anew point ephemeral atom encountered initial random population contains variety different random constants 
generated inserted population initial random generation constants remain constant 
initial random generation numerous different random constants arising ephemeral atoms moved tree tree crossover operation 
random constants embedded various sub trees carry various arithmetic operations 
moving random constants haphazard driven goal achieving better levels fitness 
example symbolic expression reasonably fit target function may better fit particular constant example decreased slightly 
slight decrease achieved different ways 
example may multiplication division subtraction addition 
notice decrease precisely particular value produce perfect fit decrease fit decrease 
pressure fitness function natural selection process determines direction magnitude numerical adjustments 
process combining random constants achieve desired goal direct simple example decrease desired 
particular problem discussed section needed solve problem 
problem finding 
value succession decreasing approximations steps 
starting available constant available function sin sin computed 
sin taken obtain smaller number 
result squared obtain smaller number 
sin function successively applied times obtain succession smaller numbers 

composition sin sin sin sin sin sin sin sin sin sin compute constant 
successive step step process produced constant closer needed 
successive expression slightly improved fitness predecessor 
illustrate symbolic regression constant creation suppose sampling numerical values unknown curve points domain interval 
run best individual expression population generation 
expression equivalent 
symbolic regression similarly successfully performed large number target expressions including expressions sin cos 
empirical discovery important problem area virtually area science finding empirical relationship underlying observed values variables measuring system langley zytkow 
practice observed data may noisy may known way express relationships involved precise way 

econometric time series problem discovering empirical relationships actual observed data illustrated known econometric exchange equation pq relates money supply price level gross national product velocity money economy koza 
suppose goal find relationship quarterly values money supply elements equation 
particular suppose quarterly values econometric time series 
time series annual rate united states gross national product billions dollars 
series conventionally called gnp economists conventional notation economists time series data 
second time series gross national product normalized called gd 
third series monthly interest rate yields month treasury bills averaged quarter called 
fourth series monthly values adjusted money stock billions dollars averaged quarter called 
time series obtained data base machine readable econometric time series 
data accessed apple macintosh ii computer software provided var econometrics 
doan 
actual long term historic value velocity money united states humphrey correct solution multiplicative non linear relationship gd gnp told priori functional relationship observed data independent variables target function dependent variable linear multiplicative polynomial exponential logarithmic 
set available functions problem exp rlog 
set available terminals problem gnp gd ephemeral random constant atom allowing various random floating point constants inserted random constant atoms initial random lisp expressions 
terminals gnp gd provide access values time series quarters 
effect terminals functions unstated implicit time variable 
notice told addition subtraction exponential logarithmic functions time series month treasury bill yields irrelevant problem 
initial random population predictably highly unfit 
run individual initial random population came environmental data points time series 
sum errors best expression actual time series large 
similarly best individuals generations came close actual time series small number cases cases respectively large sum error measures 
generation best individual came close actual time series environmental cases sum errors 
generation expression emerged gd gnp rlog 
individual graphically depicted gd gnp note expression equivalent gd gnp rlog gd gnp expression discovered th generation comes actual values points year time series 
sum absolute errors expression discovered points year time series 
expression discovered compares favorably correct exchange equation pq value sum errors came actual time series data points year time period studied 
process repeated additional samples time period consisting thirds available data points 
case expression emerged form denominator consisting constant near precisely equal constant 
performance expression discovered sample points compared remaining sample data points case close fit observed 

kepler third law langley 
discuss discovery various scientific laws empirical data 
example discovery kepler third law planetary motion states cube planet distance sun proportional square period 
rediscovering kepler third law genetic programming paradigm function set srt sin cos terminal set dist 
environment consisted cases relating distance dist astronomical units planet sun period planet 
object find expression terms dist parsimonious versions solutions expressions srt dist dist dist dist srt dist 
parsimonious correct solutions included expressions dist dist dist dist dist srt dist dist srt dist sin 
interestingly expression dist dist appeared times partially correct ancestor correct final solution runs 
years publishing correct version third law kepler published incorrect version 

chaos aspect study chaos involves finding function fits sample data 
functions interest recursive sense sequence values function time depends initial condition values 
simple example function function unit interval 
time step initial time value function computed value function previous time step 
environment consisted value function times 
value function time step initial condition 
object discover function time steps 
terminal prev allows access value function previous time step 
run best individual th generation prev prev 
note search value initial condition 

trigonometric identities group experiments problem derive various trigonometric identities 
environment consisted pairs random monte carlo pairs values radians 
experiment problem find lisp expression sin available functions sin cos multiplication addition subtraction 
expectation algorithm find sin cos sin cos non parsimonious equivalent version expression 
interestingly initial result sin 
algorithm rediscovered original hidden functional source original sequence 
avoid seeing result interesting informative experiment modified find cos 
expectation algorithm find sin cos algorithm produced simpler identity cos cos 
algorithm cos equivalent sin addition cosine function intentionally deleted repertoire available functions avoid merely getting anticipated cos 
correct expression sin sin sin sin obtained generations run somewhat parsimonious correct expression sin sin equivalent sin obtained generations run 
unexpected result arising experiment basis constant creation process described 
run attempting find trigonometric identity cos lengthy expression sin sin sin sin sin sin sin sin sin sin sin emerged generation 
expression near perfect zero raw fitness scored near hits 
hardly obvious incomprehensible expression represented 
graphical features mathematica software package wolfram graphical representation lengthy expression expression extremely fit cos 
clear sin sin sin sin sin sin sin sin radians approximately 
notice 
trigonometric identity sin cos discovered 
importantly algorithm created needed constant available ingredients sin function constant repeatedly applying sin function converge desired numerical result 

data function symbolic integration various approaches problem symbolic integration discussed mills 
data function symbolic integration numerical values sampling points unknown curve desire find function symbolic form integral unknown curve 
particular suppose sampling numerical values unspecified curve 
pairs domain may unspecified curve happens cos 
goal find symbolic form function perfect fit fit integral unspecified curve pairs numerical points 
goal find sin symbolic form pairs 
purposes programmed numerical integration routine perform numerical integration 
seen problem fact similar problem symbolic regression discussed additional numerical integration step 
numerically integrate curve domain starting running obtain value integral unspecified function point individual candidate function generated evaluate obtain pairs 
raw fitness individual candidate function sum absolute values differences individual candidate function domain point xi integral unspecified function domain point xi desired solution viewed function hyperspace functions composed available functions 
set terminals contains just single variable value combined set functions terminals problem sin cos rlog having arguments respectively 
generations expression sin emerged 
function small error respect numerical points perfect score near hits sense function criterion integral unspecified curve xi values 
expression equivalent sin summarize functional form sin data points 
experiment obtained symbolic integral 

data function symbolic differentiation data function symbolic differentiation numerical values sampling points unknown curve desire find function symbolic form derivative unknown curve 
particular suppose sampling numerical values unspecified curve domain 
pairs xi yi 
unspecified curve happens sin goal find symbolic form function perfect fit fit derivative unspecified curve pairs numerical points 
goal find cos symbolic form 
purposes programmed numerical differentiation routine perform numerical differentiation 
seen problem fact similar problems symbolic regression symbolic integration discussed numerical differentiation performed 
numerically differentiating curve xi yi points endpoints domain derivative average slope curve point xi xi slope curve point xi xi endpoints domain slope slope curve nearest point 
numerical differentiation performed desirable larger number points inherent relative inaccuracy numerical differentiation compared numerical integration 
generations expression cos cos emerged 
function small error respect numerical data points perfect score hits sense function criterion yi value xi values 
expression equivalent cos 
experiment obtained symbolic derivative 
solving equations genetic programming paradigm solve equations solution form function satisfies equation 

differential equations differential equations typically approached analytic methods numerical approximation methods 
problem solving differential equations may viewed search hyperspace compositions functions arguments particular composition satisfies equation initial conditions 
consider simple differential equation dy dx cos having initial value initial value 
goal find function satisfies equation sin start generating random values independent variable xi domain unit interval 
call set values values 
th individual candidate function fj population generated genetic algorithm evaluate fj xi obtain pairs xi fj xi 
call array numbers unknown curve 
numerically differentiate curve xi fj xi respect independent variable xi obtain value derivative curve xi fj xi points 
take cosine pairs random values xi obtain curve consisting values xi cos xi 
multiply values fj xi obtain pairs xi fj xi cos xi 
perform addition fj xi fj xi cos xi points 
extent fj xi fj xi cos xi close zero values xi unknown candidate function fj approximation solution differential equation 
facilitate input differential equations system toolkit written allow differential equation written terms independent variable called values unknown function sought called candidate function differentiation respect specified variable function 
functions include addition subtraction multiplication division sine cosine apply function curve special function name desired function 
adopt convention right hand side equation zero 
left hand side differential equation involves unknown candidate function 
function applied scalar constants curves 
example rewrite left hand side differential equation differentiate candidate function values candidate function cos values 
interpreted follows cosine function applied independent variable values 
result multiplied unknown function candidate function obtain intermediate result 
unknown function candidate function differentiated respect independent variable values result added previously obtained intermediate result 
sum absolute values differences left hand side equation right hand side equation zero function computed 
closer sum differences zero better 
fitness particular individual candidate unknown function expressed terms factors 
sum absolute differences mentioned represents raw fitness function 
raw fitness derived closeness candidate function initial condition absolute value difference value computed candidate unknown function fj initial condition value initial condition 
combined set functions terminals problem sin cos rlog exp having arguments respectively 
run best individual initial random population generation function ex raw fitness points near hits 
generation best individual population raw fitness points near hits 
generation best individual population equivalent sin raw fitness head dramatically improved decreased 
points near hits 
function fact exact solution differential equation 
second example differential equation dy dx initial condition 
run best individual th generation exp exp 
equivalent exact solution differential equation 
third example differential equation dy sin dx initial condition 
run best individual th generation cos cube root function 
equivalent cos exact solution differential equation 
note initial condition differential equation involves value function typically case differential equation involves derivatives point domain independent variable may initial condition 
hand initial condition differential equation involves value derivative function may case differential equation involves second derivatives higher derivatives necessary value independent variable involved initial condition points random set points xi preferably internal point domain 
necessary allow derivative higher derivative unknown candidate function evaluated initial condition point 

power series solution differential equation possible discover power series program ex exponential function part solution differential equation 
experiment demonstrate tools commonly computer programming iteration ability give name results calculation result sub program subsequently referred subsequently 
experiment problem find solution dy dx having initial value initial value 
effect problem compute ex power series 
functions available problem include addition multiplication modified division operation returns value zero division zero attempted set operator sa iterative summation operator sigma 
terminals available problem include variable iterative summation index ii settable variable aaa 
set operator sa argument sets global variable aaa equal value argument 
set function allows computer program assign name results calculation result sub program subsequently refer subsequently result 
writing computer programs computer programmers mistakenly variable defined program 
depending programming language machine involved undefined variables typically cause computer program halt assigned default value may inappropriate specific problem involved 
purposes best served having evaluation individual halt operation 
assign default value undefined variable 
problem involves realvalued variables default value floating point number 
order simplify particular problem default value undefined variables 
note expression typically changes value settable variable course program may times 
iterative summation operator sigma argument called performs function similar familiar summation operator mathematics 
particular operator sigma evaluates argument repeatedly summand encountered small absolute value 
operator sigma returns value accumulated sum 
operator sigma similar previously described iterative du operator indexing variable ii available inside sigma operator iterates 
sigma operator performing iterations iteration variable ii counts number iterations starting 
variable terminals set available terminals 
argument happens contain ii sigma operator summation indexing variable 
course sigma operator merely accumulates sum summands independent ii may change due operation settable variables side effects 
individual expressions population generally necessarily small absolute value guarantee operator sigma terminate 
practical necessity working serial computer place limits number iterations allowed execution sigma operator place similar limit total number iterations allowed sigma operators may evaluated process executing individual expression particular environmental case 
note sigma operator times returns sum accumulated time 
lisp expression sigma sa aaa ii parsimonious lisp expression computing value power series ex value expression consists sigma operator starts setting aaa result multiplying value aaa initially dividing iteration variable ii 
iterative process continues summands successively consist powers divided factorial iteration number 
current settable variable aaa gets near zero sigma operator terminates returns accumulated value sum 
note termination predicate ill formed iterative summation operator time limit number iterative steps reached 
run obtained sigma sa sa aaa sa ii best individual lisp expression th generation 
simplified lisp expression equivalent correct solution differential equation initial conditions 

integral equations integral equations equations involve integral unknown function 
integral equations solved general approach additional step integral candidate function 
example integral equation cos dr run solution integral equation te note process integration creates variable case similar indexing variable ii iterative loop described connection du sigma functions 

inverse problems suppose set data consisting various xi yi pairs symbolic regression reveal dependent variable yi twice square root independent variable xi 
yi xi 
problem finding inverse function starts set xi yi pairs data dependent variable yi square half independent variable xi 
xi yi seen problem finding inverse function set data similar problem symbolic regression discussed additional step switching roles independent dependent variables data set 

solving functional equations consider functional equation sin 
goal solve equation function substituted equation satisfies equation 
selecting set random points suitable domain 
particular select points xi domain real numbers 
store values vector 
compute vector values corresponding sine xi 
compute vector values corresponding square sine xi 
compute vector corresponding twice square sine xi 
computed vectors viewed curve think points sin plotted graphically axes 
similarly set vector constant occurrences constant constant curve 
subtract constant curve curve just computed sin consider expressions fj current populations individuals 
argument unknown function just perform step multiplying xi values 
compute curve expression fj 
happen function exactly satisfies equation new curve computed consist zeroes 
case value left hand side sin corresponds fitness function 
run expression emerged generation raw fitness zero cos 
expression equivalent cos solve functional equation 
cos substituted equation sin equation satisfied left hand side evaluates zero random xi 

solving general mathematical equations numeric values important special case process solving functional equations occurs set arguments atoms consists numeric constants 
variable arguments set arguments construct expressions 
special case process solve general mathematical equation numerical roots 
example consider simple equation identical roots conventionally write 
purposes rewrite equation functional equation function unknown variable unknown 
proceed set functions contains functions addition subtraction multiplication division 
set terminals arguments consists ephemeral random constant atom 
note appear set terminals arguments 
result set expressions contains random compositions random constants 
typical expressions 
random values xi selected suitable domains 
curve built squaring xi 
xi multiplied result subtracted square xi constant value added values 
step evaluate fitness individual expressions fj population 
expression problem particular numeric value initial population expressions contained constants 
value depend xi 
fj evaluated fitness value cases value fj depend xi 
sum identical values fitness fj 
expression causes left hand side equation raw fitness side zero expression fact numeric constant value satisfies equation 
run best individual expression nd generation evaluated 
value approximately 
note genetic approach solving equations numeric values produces quite precise values 
result contrary conventional view genetic algorithms searching general neighborhood correct answer large search space 
view correct applied conventional genetic algorithms operating character strings length fixed advance 
size shape solution allowed dynamically vary problem solved possible search large search space correct general neighborhood solution adaptively changing representation scheme converge closely precise correct value 

concept formation quinlan initiated development particularly effective family hierarchical classification systems inducing decision tree limited number training case examples 
id various systems id family goal partition universe objects classes 
object universe described terms various attributes 
system set training case examples consist attributes particular object class belongs 
system generates decision tree hopefully classify new object correctly class attributes new object 
external points leaves decision tree eventual class names 
internal points decision tree attribute tests branch emanating decision point possible outcome test 
induction decision trees classifying objects approached genetically breeding lisp expressions performing task 
particular set terminals set class names 
set functions set attribute tests 
note set attribute tests assumed available solving induction problems decision trees id family 
notice id similar genetic programming paradigm set functions 
function arguments possible outcomes particular test 
particular object lisp expression decision tree function expression tests attribute object returns particular arguments designated outcome test 
designated argument terminal function returns class name 
expression fully evaluated lisp usual left oriented depth way expression returns class name 
expression decision tree classifies new object classes 
demonstrate technique genetically inducing decision tree apply approach small training set objects quinlan 
quinlan problem object attributes belongs classes positive negative 
attribute temperature example assume possible values hot mild cool 
humidity assume values high normal 
outlook assume values sunny overcast rain 
assume values true false 
decision tree quinlan solution problem shown outlook sunny overcast rain humidity high normal true false example outlook particular object sunny humidity high object classified class negative 
order genetically induce decision tree attributes problem converted function 
example function temperature operates way current object temperature mild function returns second argument return value 
attributes problem humidity outlook similarly converted functions 
function set problem temp hum wind arguments respectively 
set terminals problem classes 
run lisp expression wind wind hum emerged th generation maximal fitness value correctly classified training cases 
wind equivalent just constant atom expression equivalent decision tree quinlan id 

automatic programming problem automatic programming requires developing computer program produce desired output set inputs 
early provocative area includes friedberg 

solving pairs linear equations experiment problem find computational procedure solving pair consistent non indeterminate linear equations real valued variables 
environment consisted suite pairs equations 
suite equations minimizes chance misled 
loss generality coefficients equations determinant 
set available functions set available terminals 
worst individual initial random population generation raw fitness value 
average raw fitness generation initial random generation 
value serves baseline measure non random performance 
average raw fitness population immediately begins improving baseline value generation addition worst individual population begins improving generation best individual generation raw fitness value 
best individual begins improving value generations generation generations generations 
computational procedure appeared generations fitness value differed known correct solution additive term 
best individual generations similarly close expression raw fitness value 
starting generation perfect solution emerges 
average normalized fitness generation shows gradual generally upwards trend generation generation starting generation improving generation reaching generation 
generation generation average normalized fitness rises sharply known perfect solution begins dominate population 

quadratic equations experiment problem solve quadratic equation bx root 
available functions multiplication subtraction modified division operation common lisp complex valued square root function sqrt denoted 
modified division function returns division zero attempted 
square root function returns lisp complex number 
example calls square root evaluate lisp complex number 
set terminals 
environment consisted suite quadratic equations purely real roots purely imaginary roots complex valued roots 
equations environment individual expression evaluated obtain generally complex number 
square root square real part complex number produced individual lisp expression square imaginary part complex number produced individual lisp expression computed 
distance values summed quadratic equations environmental test suite obtain fitness value expression 
run correct solution problem emerged generation expression equivalent wellknown solution 

computational problems finding primes wide variety computational problems viewed requiring generation computer program solve problem 
example finding prime numbers 
problem illustrate third iterative control structure operator equivalent loop programming languages 
prime number positive integer evenly divisible 
problem finding primes viewed finding function positive integers returns number divisors 
number divisors greater number prime composite number 
number divisors depending handles argument number prime 
test suite integers space possible valued functions problem size equals search space boolean multiplexer 
approaches problem 
approaches variable atom integer 
objective determine prime 
settable variable cnc available initially zero 
approaches function cz available 
function cz adds cnc modulo zero 
approach iterative operator 
operator equivalent loop programming languages du operator equivalent repeat loop sigma operator equivalent notation infinite series mathematics 
operator loop arguments number iterations performed 
similar previously described iterative operator du previously described iterative summation operator sigma iteration variable ii available inside operator possible incorporation argument argument time limits established operator 
combined set functions terminals approach cz ii 
expression returned value greater deemed prime 
deemed composite number 
fitness number integers correctly classified 
expression cz ii parsimonious completely correct solution problem 
solution obtained runs program 
second approach operative function available cz 
passive function progn included set available functions allow sequence functions performed 
available terminals cnc integers square root 
appropriate sequence cz functions appropriate arguments function sieve 
partially correct structures easily develop 
run cz appeared best individual generation 
progn cz cz cnc appeared slightly better fitness 
progn cz progn cz cz cnc appeared better fitness 
progn cz progn cz progn cz cz cnc appeared generation 
expression close solution possible available terminals functions 

pattern recognition hinton discussed problem translation invariant recognition dimensional shape linear binary retina wrap 
simplified experiment retina pixels wrap shape consists consecutive binary 
possible instances shape 
functions available zero sensing function sensing function ordinary multiplication disjunctive function terminals available integers universally quantified terminal function takes arguments returns integer position equal sum arguments modulo retina length returns integer 
argument functions potentially serve positional pointer potentially serve displacement 
universally quantified terminal assumes integral values retinal length 
disjunctive function takes arguments returns integer argument non zero returns integer arguments 
ordinary multiplication function serves conjunctive function returns integer arguments non zero returns integer argument 
functions defined resolve potential type problems arise integers identify positions retina 
lisp comparatively tolerant typing pattern recognition problems require ability freely combine numerical concepts positional location absolute universally quantified relative displacement symbol pixels right boolean concepts particular disjunctive conjunctive combination features indicates particular shape 
want specify restrict priori kind combination functions available solve problem 
initial random individuals include contradictions inefficiencies nonsense 
particular run number mismatches best individual generation rapidly improved generations 
improved mismatches generation individual 
ignoring extraneous outermost conjunction individual returns value integer binary retina positions displaced constant 

non linear optimal control strategy balancing broom problems centering cart balancing broom inverted pendulum applying bang bang force direction known problems control theory 
cart centering problem previously studied genetic algorithm field connection holland classifier systems goldberg 
broom balancing problem studied extensively connection neural networks widrow barto widrow anderson anderson 
genetic programming paradigm successfully solve cart centering problem dimensional broom balancing problem koza keane dimensional broom balancing problem koza keane 
dimensional broom balancing problem involves push cart mass mc moving dimensional frictionless track broom inverted pendulum mass mb pivoting top cart 
broom angle measured vertical angular velocity distance center mass broom pivot point cart state variables system position velocity angle angular velocity bang bang force fixed magnitude applied center mass cart left right direction time step constants mc mb gravity meters sec time step seconds length force force meters state transitions cart broom system expressed non linear differential equations 
discrete time step current state system force applied time step compute state system time step 
particular angular acceleration time anderson cos mc sin cos mc angular velocity broom time angle time euler approximate integration 
acceleration cart sin cos mc velocity time position time 
problem find control strategy lisp expression specifies apply bang bang force starting random initial state cart brought rest broom balanced minimal average time 
set functions problem consisted addition subtraction multiplication sign function sig absolute value function abs square root absolute value function srt square function sq cube function cub greater function gt 
greater function gt real valued logic function arguments returns argument greater second argument returns 
real valued logic allows arbitrary composition functions function set 
set terminals problem consisted velocity angle angular velocity ephemeral constant atom real valued random constants 
control strategy executed evaluated time step environmental case 
particular control strategy lisp expression evaluates positive value particular values state variables particular time step force applied positive direction 
force applied negative direction 
example current point space shown ball control space force applied positive direction 
case environment consists initial environmental starting condition cases 
position chosen randomly meters 
velocity chosen randomly meters second 
angle chosen randomly radians degrees radians 
angular velocity chosen randomly radians second 
force 
time discretized time steps seconds 
total time available system times control strategy seconds 
square root sum squares velocity angle angular velocity norm criterion system considered arrived target state broom balanced cart rest 
particular control strategy brings system target state particular environmental starting condition case fitness environmental case time required seconds 
control strategy fails bring system target state times fitness environmental case set seconds 
fitness control strategy average time strategy environmental cases 
initial population random control strategies generation includes highly unfit control strategies including totally blind strategies ignore state variables partially blind strategies ignore state variables strategies repetitively apply force direction strategies correct particular specific environmental cases strategies totally counter productive strategies cause wild oscillations meaningless 
run average time consumed initial random strategies generation averaged seconds times average time seconds consumed pseudo optimal strategy 
fact majority random individuals timed seconds timed time available 
highly unfit initial random population control strategies somewhat better 
best single control strategy generation non linear control strategy averaged seconds 
note control strategy partially blind consider state variable specifying apply bang bang force 
average population fitness improved seconds environmental case generations respectively 
generation best single individual non linear control strategy 
individual performed average seconds 
individual succeeded bringing environmental starting conditions cases target state 
compares hits best single individual generation fact thirds individuals population scored hit 
generation average population fitness improved seconds scored hits 
best single individual note individual partially blind considers state variables 
generation average fitness improved seconds 
time high point hits histogram moved started generation higher number 
generation individuals scored hits 
left right slinky motion hits histogram occurs system progressively learns 
generation attained individual scored hits 
best individual generation non linear control strategy individual fitness seconds 
generation population average fitness improved seconds 
generation time see linear control strategy best individual population 
best single individual population generation scored hits fitness seconds 
note computer program control strategy viewed defining optimal control surface separates state space parts 
case control surface merely plane generations non linear surface 
generation best single individual bears resemblance ultimate solution attain generation 
generation best single individual individual fitness seconds 
individuals population generation scored hits 
generation high point hits histogram population moved hits hits 
particular individuals population scored hits 
generation best single individual population term non linear control strategy discovery single best control strategy retested additional random environmental starting condition points 
performed average seconds 
test averaged seconds corners cube 
test took seconds worst corners cube velocity angle angular velocity sign 
timed internal point corner point cube 
benchmark pseudo optimum strategy averaged seconds random environmental starting condition cases retest 
averaged seconds corners cube 
unable handle worst corners cube 
results seconds summarized table case performance dimensional broom balancing problem control strategy points corners worst corners benchmark pseudo optimum infinite known solution problem specific test perform apparent solution obtain verify optimum 
know control strategy best time discovered discovered number control strategies slightly worse control strategy result kind convergent process slightly better benchmark optimum strategy 
histograms provide graphical picture learning population generation generation 
hits histogram shows number individuals population correctly handle particular number environmental cases 
fitness histogram shows number individuals population fitness value lies particular decile fitness values 
left right slinky motion hits histogram generations shown 

case ii environment consists initial environmental starting condition cases 
position chosen randomly meters 
velocity chosen randomly meters second 
angle chosen randomly radians degrees radians 
angular velocity chosen randomly radians second 
force 
note version problem angle lies degrees degrees angular velocity lies radians second 
angle limited domain degrees degrees sin approximately equals limited domain solution problem somewhat simplified cases simple hyperplane reasonably acceptable control surface 
domains state variables put problem clearly non linear area 
time discretized time steps seconds 
total time available system times control strategy seconds 
square root sum squares velocity angle angular velocity norm criterion system considered arrived target state broom balanced cart rest 
particular control strategy brings system target state particular environmental starting condition case fitness environmental case time required seconds 
control strategy fails bring system target state times fitness environmental case set seconds 
fitness control strategy average time strategy environmental cases 
initial population random control strategies generation includes highly unfit control strategies including totally blind strategies ignore state variables partially blind strategies ignore state variables strategies repetitively apply force direction strategies correct particular specific environmental cases strategies totally counter productive strategies cause wild oscillations meaningless 
run average time consumed initial random strategies initial random population averaged seconds 
fact random individuals timed seconds environmental cases timed time available 
highly unfit initial random population control strategies somewhat better 
best single control strategy initial random generation simple non linear control strategy averaged seconds 
control strategy correctly handled simpler environmental cases timed environmental cases 
notice control strategy partially blind consider state variable specifying apply bang bang force 
genetic crossover operation applied parents current generation selected probabilities proportionate fitness breed new population offspring control strategies 
vast majority new offspring control strategies highly unfit tend somewhat fit 
slightly better came 
example average population fitness improved seconds environmental case generations respectively 
generally improving necessarily monotonic trend average fitness typical genetic algorithms 
generation best single individual non linear control strategy required average seconds 
notice particular control strategy explicitly incorporated greater function strategy earlier control strategy merely polynomial defined control surface 
generation best single individual population correctly handled time environmental cases 
required average seconds 
generation best single individual non linear control strategy required average seconds 
correctly handles environmental cases 
note number correctly handled environmental cases hits statistic find useful monitoring runs statistic genetic algorithm 
generation average time required best single individual population dropped seconds time 
particular non linear control strategy required average seconds 
correctly handled environmental cases 
histograms provide graphical picture learning population generation generation 
hits histogram shows number individuals population correctly handle particular number environmental cases 
fitness histogram shows number individuals population fitness value lies particular decile fitness values 
histograms left right slinky motion population progressively learns 
generation best single individual population non linear control strategy discovery single best control strategy retested additional random environmental starting condition cases 
performed average seconds 
test averaged seconds corners cube handle corners cube 
sq sq benchmark pseudo optimum strategy averaged seconds random environmental cases retest 
averaged seconds corners cube 
unable handle worst corners cube 
results seconds summarized table case ii performance dimensional broom balancing problem control strategy points corners worst corners benchmark pseudo optimum infinite infinite known solution problem specific test perform apparent solution obtain verify optimum 
know control strategy best time discovered discovered number control strategies slightly worse control strategy result kind convergent process slightly better benchmark optimum strategy 

finding game playing strategies game independently acting players choices moves receive payoff choices 
strategy player game way specifying choice move player particular point game allowable moves time information state game available player time 
strategies games may expressed different ways 
conceptually simple tedious way specify player moves terms possible sequence previous moves player opponents 
way express strategy terms state game terms various features abstracted state game 

differential pursuer evader game game simple pursuit described isaac differential games person competitive zero sum simultaneous moving complete information game pursuing player trying capture evading player choices available player moment time consist choosing direction angle travel 
simple game pursuit players travel plane players may instantaneously change direction restriction smoothly abruptly 
player travels constant speed pursuing player speed wp greater evading player speed 
state variables game xp yp xe ye representing coordinate positions xp yp xe ye pursuer evader plane 
time step players know position state variables players 
choice player select value control variable angular direction travel 
pursuer control variable angle radians evader control variable angle players choose value control variable simultaneously 
analysis game simplified reducing number state variables 
state reduction accomplished simply viewing pursuer origin point new coordinate system times viewing evader position new coordinate system 
numbers representing position evader reduced state variables game 
pursuer travels particular direction coordinate system immediately adjusted pursuer repositioned back origin appropriately adjusting position evader reflect travel pursuer 
state transition equations evader follows cos cos sin cos order develop optimal playing strategies set random environmental starting condition cases consisting starting positions evader starting value 
players may travel plane 
regard pursuer having captured evader pursuer gets specified small distance evader payoff player measured time 
payoff pursuer total time takes capture evader environmental cases 
pursuer tries minimize time capture 
payoff evader total time survival evader tries maximize time survival 
particular simple game pursuit pursuer superior speed possible pursuer capture evader set environmental cases 
maximum time time time steps established pursuer capture amount time maximum time payoff particular environmental case particular strategy 
problem find strategy choosing control variable pursuer minimize total time capture set environmental cases playing optimal evader trying maximize total time survival set environmental cases 
particular simple game best strategy pursuer time step chase evader direction straight line currently connecting pursuer evader 
particular simple game best strategy evader race away pursuer direction straight line connecting pursuer evader 
comparison worst strategy pursuer avoid evader racing away evader direction precisely opposite straight line currently connecting pursuer evader 
worst strategy evader race pursuer straight line 
evader chooses action strategy racing away pursuer direction straight line connecting pursuer evader evader survive time follows best strategy 
evader initially chooses sub optimal direction chooses optimal direction time survival chosen optimal direction 
situation symmetric pursuer chase evader straight line fails minimize time capture 
value game payoff time matter evader evader hold longer amount time evader direct survival time shorter amount time 
conversely matter pursuer pursuer capture optimal evader amount time equal value game pursuer direct pursuit evader remain large longer amount time 
genetic programming paradigm paradigm solve differential game simple pursuit genetically evolving population pursuing individuals number generations 
environment consists optimal evader 
words individual population pursuing individuals tested optimal evader population pursuing individuals improve testing absolute fitness 
similarly optimal evader genetically evolved population evading individuals environment consists optimal pursuer 
genetic programming paradigm especially suited solving kind problem solution takes form mathematical expression size shape may known advance may dynamically vary process 
identification terminals solving problem genetic programming paradigm straight forward problem 
terminal set contains reduced state variables representing position evader plane 
terminal set random constant 
function set problem set arithmetic mathematical operations addition subtraction multiplication division operation returns zero division zero attempted exponential function exp function set exp 
population individuals represents pursuers attempting genetically breed optimal pursuing individual environment genetic algorithm consists optimal evading individual 
optimal evader travels established constant evader speed angular direction specified function 
function arguments value value 
function returns number radians degrees representing angle tangent happens zero sign determines value function 
particular function return radians degrees sign positive returns radians degrees sign negative 
function returns event zero 
set random environmental starting condition cases consisting ne starting positions xi yi evader starting value xi yi random number 
progresses generation generation population pursuing individuals typically improves 
generations best pursuing individuals population capture evader small fraction environmental cases certain amount time 
additional generations population improves best pursuing individuals population capture evader larger fraction environmental cases shorter amount time 
partially effective pursuers effective identifiable fraction plane identifiable range distances ineffective parts plane distances 
generations run population pursuing individuals typically continues improve 
run pursuer strategy emerged th generation correctly handled environmental cases 
expression shown exp 
expression depicted graphically expression equivalent ex exp turn equivalent ex apparent optimal pursuing individual re tested larger set environmental cases find successfully handles environmental cases 
expression optimal solution problem 
note apparent optimal solution dependent particular values parameters problem slightly different pursuing individuals emerge possible values parameters 
intentionally include function function set maclaurin infinite series function uses multiplication addition subtraction division converges limited domain argument values may combinations parameters problem apparent optimal solution may longer solution problem 
particular zone capture parameter currently substantially reduced require greater accuracy moment capture range environmental cases substantially expanded range direction time time substantially reduced find small fraction environmental cases large number environmental cases apparent optimal pursuing individuals successful 
minimax strategy evader discovered similar way 

discrete game extensive form consider simple discrete game game tree extensive form shown game person competitive zero sum game players alternating moves 
player starts choose go left right 
player choose go left right 
player moves player moves player receives player pays payoff shown particular endpoint game tree reached 
game game complete information player access information opponent previous moves previous moves 
historical information contained variables xm move om move xm move om move xm move 
variables assume possible values left right undefined 
variable undefined prior time move refers 
example game variables undefined particular variables defined undefined indicate point play progressed play game 
example players moved xm om defined variables xm om xm undefined value 
strategy particular player game specifies move player possible situation may arise player 
particular game strategy player specify move happens game 
strategy player specify second move player move specify third move player moves 
player moves player move conditioned previous move 
player second move depend player move om general move xm 
similarly player third move depend player moves general moves 
similarly strategy player specify choice player possible situation may arise player strategy computer program lisp expression inputs relevant historical variables output move left right player involved 
terminal set problem 
testing functions com com provide facility test historical variables relevant deciding player move 
functions specialized form case function common lisp 
example function arguments evaluates argument xm move undefined evaluates second argument xm left evaluates third argument xm right 
functions com com similarly defined 
function set problem com com arguments 
goal evolve game playing strategy player game 
minimax strategy player serves environment evolving game playing strategies player run best single individual game playing strategy player generation minimax value scored minimax hits 
strategy expression com com com com com 
expression simplifies com com 
om move om move undefined player move 
game root game tree 
situation argument com function embedded inside com function strategy specifies player move left move player game player minimax move takes game point minimax value player opposed point minimax value 
om move undefined om defined player second move 
situation strategy specifies player moves om move player moves om om move player moved point minimax value 
player move move take game point minimax value 
om player moved point minimax value 
move better moving player move move take game point minimax value 
om om undefined player third move 
om player choose payoff payoff 
case player moves om player choose payoff payoff 
case player moves situation expression specifies player moves om move player moves om player playing minimax strategy expression cause game finish endpoint payoff player player playing minimax strategy expression cause game finish payoff player total attainment values constitutes minimax hits 
proceeded evolve game playing strategy player game 
minimax strategy player serves environment evolving game playing strategies player run best single individual game playing strategy player generation minimax value scored minimax hits 
strategy expression com com com com com 
expression simplifies symbol indicates response situation arise 

problems structure preserving crossover section problems handled naturally efficiently recognized individuals population inherently complex structure unrestricted expression structure preserved crossover occurs 

multiple regression earlier examples symbolic regression empirical discovery econometric time series kepler law dependent variable independent variables 
problems dependent variable genetically solved 
problem illustrates need creating random random individuals comply particular set syntactic restrictions performing structure preserving crossover individuals 
consider problem independent variables dependent variables 
suppose set data points form tuples form xli 
unknown function relationships ix ix ix ix 
changes required previously described process order naturally efficiently solve problem 
root tree function just inside left parenthesis lisp expression function list arguments 
value returned expression list vector numbers single number 
lisp expression created initial generation desired structurally merely restraining choice function root tree function occurring just inside left parenthesis expression function list arguments 
choice function internal point tree unrestricted choice functions problem addition subtraction multiplication 
second choice points crossover operation restrained preserve structure just created initial generation 
particular structure problem individual population function list root function list tree 
restraining process viewed ways 
simplest general way view restraining process exclude root tree selected crossover point parent crossover operation 
exception crossover operation proceeds usual 
restraint guarantees crossover operation preserves structure required particular problem 
general way viewing restraining process crossover operation illustrates general principle involved structure preserving crossover generally applicable way 
point may selected crossover point parent 
restriction 
selection crossover point second parent restricted point type point just chosen parent 
multiple regression problem types points involved 
root tree type points tree second type 
non root points chosen crossover point parent non root point chosen crossover point second parent 
root happens chosen crossover point parent selection crossover point second parent restrained points type 
particular problem point second parent type root point second parent 
happens crossover operation selects roots parents crossover points operation merely swaps entire parental trees 
crossover operation degenerates instance fitness proportionate reproduction special case 
fact approach generally applicable way viewing restraining process clearer connection neural network design 
multiple values returned expression fitness function modified 
way fitness equal absolute value difference value dependent variable returned expression target value dependent variable plus absolute value difference value second dependent variable returned expression target value second dependent variable 
course ways measuring distances square root sum squares differences 
set terminals problem 
run best lisp expression st generation list 
list arguments list function desired functional relationships 
note complex multiplication implemented return values 
technique handling return value program associated calculation fitness situation applied problems 
example values may returned output neural network multiple values returned program performs task 

neural network design experiment show simultaneously design neural network weights architecture number layers neural net number processing elements layer connectivity processing elements 
neural networks networks directed lines containing linear threshold processors internal points network numerical weights non output lines 
neural network inputs external points connected directed line segment pointing internal point network outputs external points connected directed line segment pointing internal point network 
signal non output line segment multiplied numerical constant called weight associated line passes line segment 
linear threshold processing elements internal points network emit signal discrete set possibilities 
sum weighted inputs processor exceeds certain threshold value processor emits signal 
emits signal 
output oj linear threshold processing element neural network ij ij sij th input signal processing element wij th weight processing element tj threshold processing element bj bias processing element loss generality assume thresholds neural network processing elements biases network clear thresholds biases genetically discovered general way described 
wide variety different neural network architectures described literature hinton 
currently studied neural networks intermediate hidden layer processing elements lying inputs processing elements directly connected outputs rumelhart hinton williams 
contrasts early single layer perceptrons hidden layer processing element minsky papert 
neutral networks discussed current literature feed forward socalled recurrent neural networks allow feedback 
wide variety different neural network training paradigms described literature 
neural network training paradigms presuppose architecture neural network determined 
presuppose selection number layers linear threshold processing elements number processing elements layer nature allowable connectivity processing elements 
neutral network training paradigms discussed current literature training paradigm involves exposing neural network training cases training phase progressively modifying weights thresholds biases way depends network output matches desired correct output associated training case 
goal typically neural network learn perform task correctly perform task encounters repetitions importantly previously unseen inputs cases task 
function set neural network design problem contains functions 
particular function set 
function linear threshold processing function 
function weighting function give weight single going linear threshold processing function 
weighting function fact merely multiplication give special name distinguish ordinary arithmetic operation multiplication entirely different purpose creating modifying numerical constants neural network problem 
linear threshold processing function weighting function typically appear function set varying number arguments 
function set contains arithmetic operations addition subtraction multiplication restricted division function 
arithmetic operations create modify numerical constants weights neural network 
set terminals arguments contains input signals problem ephemeral random constant atom 
input signals particular problem terminal set 
possible compositions functions function set terminals terminal set correspond choose call neural network 
problem designing neural networks requires rules construction specify structures allowable particular problem 
expressions initially created conformity rules construction crossover performed structure preserving way 
particular rules construction neural networks output signal require root tree processing element function functions level immediately processing element function weighting functions 
level weighting function greater flexibility 
particular input data signal arithmetic function addition subtraction division multiplication random constant function 
level immediately arithmetic operation arithmetic operation random constant 
function appears tree rules construction require functions immediately function weighting functions rules applied recursively full tree constructed 
note external points tree input signals random constants 
rules construction produce tree expression call neural network 
structure consists linear threshold processing elements functions process weighted inputs produce discrete signal output 
number inputs processing element function vary inputs weighted signal lines 
weights may single numeric constant result composition arithmetic operations random constants 
signal lines input network outside output processing elements compositions arithmetic operations random constants 
signal line consists composition arithmetic operations random constants called bias 
consider lisp expression representing neural network correctly performs exclusive task inputs 
expression graphically depicted rooted tree root tree contains linear threshold processing function arguments 
functions level immediately function multiplication functions 
left argument left multiplication function random constant 
right argument left multiplication function output linear threshold processing function arguments 
functions level immediately second function multiplication functions 
arguments left multiplication function second function random constant input data signal 
arguments right multiplication function second function random constant input data signal 
expression converted form typically see neural network literature input signal weighted input signal weighted weighted input signals input linear threshold processing function input lines 
input input line 
similarly second input line 
linear threshold processing function adds weighted input lines emits sum exceeds threshold emits 
sum inputs threshold emit 
sum emit 
sum emit 
sum threshold 
emit 
words emits input lines 
similarly input signal weighted input signal weighted weighted input signals input linear threshold processing function input lines 
seen emit input signals 
output weighted output weighted weighted input signals input linear threshold processing function input lines 
seen effect weights weighted sum inputs exceeds threshold signals coming non zero words output output 
output exclusive function inputs 
output signal neural network output signals neural network returned list manner described multiple regression 
function set enlarged list 
rules construction neural networks output signal require root tree list function 
number arguments function list equals number output signals 
time list function expression 
rules construction require function level tree immediately list function linear threshold processing element functions previously described rules construction apply 
example lisp expression represents neural network output signals list 
argument list function shown underlined bold type 
argument represents output signals 
output signal output linear threshold processing element 
linear processing element input lines 
input line connected data signal line weighted multiplied comes linear threshold processing element 
second input line connected input data signal line weighted sum comes linear threshold processing element 
second argument list function second output signal similar interpretation 
note input data signal appear place tree 
possible create connectivity input data signal number processing elements 
similarly define building block operation section possible connectivity output linear processing element function inputs linear processing element functions 
connectivity created define building block operation create feedback recurrent neural network feed forward neural networks desired additional rule construction implement restriction 
follows show simultaneously find architectural design training neural network 
example seek design neural network perform task adding bit inputs produce output bits 
environment task adding bit inputs produce output bits consists cases representing combinations binary input signals appear 
correct outputs respectively associated environmental cases 
raw fitness function add differences output signals neural network correct value bit adder function 
crossover operation selects crossover point parent restriction 
crossover point selected parent crossover point second point type 
problem types points point containing processing element function point containing weighting function point containing input data signal point containing arithmetic operation random constant 
run individual emerged generation correctly performs bit adder task 
individual simplified consolidating sub expression consisting numerical constants arithmetic operations single numerical constant weight 
list df df 
individual graphically depicted 
df list df note expression contains defined functions df df 
defined function defined return expression shown df defined function df graphically depicted similarly defined function df defined return expression df defined function graphically depicted defined functions df df inserted expression obtain expression 
expression expanded version defined functions shown bold type 
list expression element list low order bit result 
examination element equivalent exclusive function input bits 
correct expression low order bit result 
second element list high order bit result 
examination second element equivalent equivalent 
correct expression high order bit result 
important recall numeric constants expressions consolidation sub expression involving arithmetic operations random constants 
illustrate highlighted numeric constants weights occurring approximately middle expression underlining placing bold type 
highlighted expression shown list 
process consolidating sub expressions consisting numerical constants arithmetic operations illustrated considering sub expression gave rise weight underlined bold type 
weight arose expression 
sub expression numerical constant weight depicted graphically 
summary algorithm section summarize major steps necessary genetic programming paradigm 
majors steps involve determining set terminals set function environmental cases fitness function parameters run termination criterion method identifying solution 

identifying set terminals major step identify set terminals problem 
set terminals course sufficient solve problem 
step correctly identifying variables explanatory power problem hand common science 
problems identification may simple straightforward 
example broom balancing problem physics problem dictate velocity cart angle broom angular velocity broom state variables having explanatory power problem 
sequence induction problem sequence index ii single necessary variable atom terminal 
needless say set variables sufficient express solution problem 
example diameter planet color surface able discover kepler third law period planet 
constant atoms required enter problem ways 
way constant creation procedure involving ephemeral random constant atom described earlier 
event type random initial constants chosen match problem 
example boolean domain constants nil integral domain constants integers certain range real valued problem domain constants floating point values certain range 
second way constant atoms enter problem explicitly including 
example include particular problem possibility particular constant useful 
course failed include problem genetic programming paradigm paradigm probably succeed approximately creating albeit certain cost computational resources manner described 

identifying function set second major step identify sufficient set functions problem 
problems identification function set may simple straightforward 
real valued domains obvious function set set arithmetic operations 
boolean function learning domain example function set choice computationally complete convenient function produces easily understood logical expressions 
ones interests lie domain design semiconductor logic layout function set consisting nand function convenient 
problem involves economics growth rates averages play role function set include exponential logarithmic moving average function addition basic arithmetic operations 
similarly sin cos functions useful additions function set problems 
functions may added function set merely possibly facilitate solution result obtained 
example include squaring function certain problems broom balancing result attained simple multiplication function albeit cost computational resources 
case set functions chosen composition available functions valid value available variable atom assume 
division division function modified division zero defined 
result division zero defined zero large constant new value common lisp keyword infinity 
defined result division zero keyword infinity functions function set written defined infinity value happens arguments 
similarly square root available functions specially defined real valued version takes square root absolute value argument broom balancing problem common lisp complex valued square root function sqrt quadratic equation problem 
common lisp quite lenient typing variables accommodate combinations types arise computer programs randomly generated recombined crossover 
example logical functions mixed numerical functions kind real valued logic lieu normal logical functions 
example greater function gt broom balancing problem assumed real value comparison relation satisfied real value 
note number arguments specified function 
cases specification obvious mandatory boolean function square root function 
cases multiplication latitude number arguments 
example include particular function function set differing numbers arguments 
function arguments example function function arguments function 
multiplication function arguments facilitate emergence certain cross product terms result achieved repeated multiplication function arguments 
useful include common lisp progn program form varying number arguments function set act connective unknown number steps may needed solve problem 
choice set available functions course directly affects character solutions attained 
set available function form basis set generating potential solutions 
example symbolic regression absolute value function interval function set containing function subtraction obtains solution familiar form conditional test returns 
hand function set happens contain cos cos cosine times argument cos cosine times argument function gets terms familiar fourier series approximation absolute value function 
similarly seen cases exponential function sigma summation operator available problem solution required exponential polynomial terms taylor series solution lieu missing ex noted necessary preliminary selection appropriate functions terminals common element machine learning paradigms 
example techniques id family inducing decision trees necessary preliminary selection set available attribute testing functions appear nodes tree exclusion possible functions corresponds process choosing functions 
similarly approaching problem puzzle soar necessary preliminary selection set operators moving tiles puzzle corresponds process choosing functions 
similarly approaching problem designing neural network control artificial ant jefferson collins successfully necessary preliminary selection functions turn left turn right sense move corresponds process choosing functions 
naturally extent function set terminal set contains irrelevant extraneous elements efficiency discovery process reduced 

establishing environmental cases third major step construction environment problem 
problems nature environment obvious straight forward 
example sequence induction symbolic function identification symbolic regression empirical discovery boolean function learning problems environment simply value independent variable associated certain sampling entire set possible values dependent variable 
problems block stacking broom balancing environment set starting condition cases 
problems environment large block stacking random sampling structured representative sampling 
example environmental cases symbolic regression problem equation involving problems differential game problem broom balancing problem randomly selected floating points numbers specified range 

identifying fitness function fourth major step construction fitness function 
problems fitness function sum distances taken environmental cases point range space returned expression set arguments correct point range space 
sum distances square root sum squares distances computation 
problems fitness function value returned individual population number elapsed time total score cases handled indirectly created evaluation expression 
example broom balancing problem raw fitness average time required expression balance broom 
goal minimize average time balance broom environmental cases 
artificial ant problem score number stones trail artificial ant successfully traverses allowed time 
goal maximize score raw fitness maximum score minus score attained particular expression 
block stacking problem real functionality functions individual expression population side effect expression state system 
interest focuses number environmental starting condition cases expression correctly handles 
goal maximize number correctly handled cases 
raw fitness defined raw fitness closer zero better expressions raw fitness number cases incorrectly handled 
saw second version block stacking problem efficiency correctness sought solution differential equations solution curve satisfaction initial conditions sought fitness function incorporate correctness secondary factor 
important fitness function return spectrum different values differentiate performance individuals population 
extreme example fitness function returns values say solution provides insufficient information guiding guide adaptive process 
solution discovered fitness function essentially accident 
inappropriate selection function set relation number environment cases problem create situation 
example boolean function function set exclusive problem function satisfies environment cases 
initial random population individuals certainly numerous expressions equivalent function effectively left distinguishing levels fitness solution 

selecting parameters runs fifth major step selection major minor parameters algorithm decision secondary genetic operations described section 
selection population size important choice 
population size chosen complexity problem mind 
general larger population better goldberg 
improvement due larger population may proportional increased computational resources required 
done theory optimally select population size string genetic algorithms goldberg offer corresponding theoretical basis tradeoff hierarchical genetic algorithms time 
selection population size lies category external decisions user 
respect decision similar selection number processing elements neural nets selection string size condition parts classifier system rules selection testing functions id type inductive systems 
problem optimally allocating computer resources particularly population size number generations runs problem optimally selecting key parameters percentage individuals participate crossover genetic operations problem optimally parallelizing runs cross migration versus independent isolated runs unsolved problems types genetic algorithms 

termination solution identification sixth major step selection termination criterion solution identification procedure 
approach termination depends problem 
cases termination criterion may implicitly selected merely selecting fixed number generations running algorithm 
problems recognize solution problem sees problems sum differences zero acceptably close zero 
problems time optimal control strategy problems analytic solution known necessarily recognize solution sees recognize current result better previous result current solution neighborhood estimate solution 
solution identification procedure identify best single individual generation termination criterion satisfied solution problem winner takes 
numerous opportunities domain specific heuristic knowledge connection genetic programming paradigm 
areas studied connection string genetic algorithms grefenstette 
may useful include domain specific heuristic knowledge creating initial random population 
example include sub programs believed useful solving problem hand initial random population 
probability distribution uniform distribution initially select functions terminals initial random individuals randomly generated 
secondly domain specific heuristic knowledge may helpful selecting selecting certain points computer programs crossover operation 
may include protecting certain points selection crossover certain circumstances requiring certain points selected crossover certain circumstances 
thirdly domain specific heuristic knowledge may useful varying parameters run information gained run 
fourth domain specific heuristic knowledge selection set available functions terminals problem set merely minimally sufficient solve problem set available functions terminals actively facilitates solution problem 
extent uses domain specific heuristics course dependent primary objective solve specific problem hand study process purest theoretical form 
chosen domain specific heuristics reported 
computer implementation author computer program consisting lines common lisp code primarily run texas instruments explorer ii computer lisp microprocessor chip megabytes internal memory half gigabyte external hard disk memory 
runs run computer apple macintosh ii computer texas instruments lisp expansion board run node parallel explorer mp computer 

computer interface robertson points informative interactive interface invaluable tool carrying computer experiments field machine learning 
accordingly computer program extensive interactivity including full color graphs additional panes 
various mouse sensitive points inspecting progress run executing 
shows computer interface 
upper left graph dynamically tracks average normalized fitness population 
graph tracks number hits best single individual generation problems exact matches possible number near hits real valued numerical problems 
number hits near hits genetic algorithm way 
number hits near hits monitoring progress runs making description run understandable 
second upper right graph dynamically tracks average raw fitness population generation raw fitness best individual population raw fitness worst individual population generation 
graph displays baseline average raw fitness initial random population dotted line 
third graph hits histogram showing number individuals population particular number hits near hits numerical problems particular generation 
histogram particularly informative view learning process 
horizontal axis hits histogram number hits 
vertical axis hits histogram represents number individuals population number hits 
initial random generation bulk population appears far left histogram hits 
generations center gravity hits histogram typically starts shifting left right 
learning takes place slinky movement left right continues run 
late stages run individuals representing perfect solution problem may start appearing far right histogram represents maximum number hits 
complete convergence occurs population concentrated far right histogram 
possibility premature convergence suggested concentration population single sub optimal number hits histogram verified fact individuals scoring number hits identical 
contrast normal progress solution typically indicated broad flowing distribution individuals different numbers hits histogram 
fourth graph fitness histogram showing number individuals population having fitness lying particular decile range fitness values 
fifth graph shows best single expression current generation graphical symbolic form 
internal external points tree representing expression labeled appropriate functions terminals 
sixth window shows entire single best expression regardless size 
seventh window subset problems described broom balancing problem 
shows current state cart broom 
eighth graph subset problems described graphically display single best individual population 
best expression typically changes generation 
vertical axis range target function 
problems sequence induction symbolic function identification symbolic regression symbolic integration symbolic differentiation symbolic solution differential equations chaos empirical discovery power series problems graph dynamically graphs target function best individual current generation 
symbolic integration symbolic differentiation problems graph integral derivative current best expression added additional item 
broom balancing problem graph dimensional graph control surface 
top pane non scrolling pane provides general information run 
second pane displays parameters run may updated individual associated statistics entire population generation selected generations run 
window scrolled progress run studied 
third pane displays number hits achieved generation previous run problem 
monitoring series runs 
fourth pane displays parameters run updated lines information generation run 
information includes single best individual expression generation raw fitness adjusted fitness normalized fitness number hits best single individual population generation number hits worst individual average fitness population generation 
window scrolled progress run studied 
fifth pane lisp command pane 

special problems computer implementation order replicate results reported explore potential genetic programming paradigm described article necessary implement algorithm computer 
paradigm described involves executing modifying computer programs non standard ways computer programs originally generated random created genetically number practical computer implementation issues come forefront 
techniques required described available documentation relevant programming languages computing machines reasonably expect 
section discuss pitfalls abound area 
noted experimenter chooses common lisp function eval implement measurement fitness individual lisp expressions evaluation correctly variable atoms appearing expressions global variables 
secondly efficient implementation crossover operation known author uses copy tree functions lisp 
copy tree function copy parent 
function destructively change pointer cons cell copy parent crossover point points crossover fragment subtree copy parent 
function destructively change pointer cons cell copy second parent crossover point points crossover fragment subtree copy parent 
destructively changing pointers copies resulting altered copies offspring 
original parents remain population repeatedly participate operations current generation 
selection parents done replacement allowed 
third genetic programming paradigm described involves executing randomly generated computer programs individuals initial random population individuals produced generations process sub expressions evaluate large numbers small numbers 
range integral mode automatically common lisp programming language 
mode integer numbers grow arbitrarily large limited virtual address space machine 
potential growth size integers produced randomly generated expressions presents problem practical matter 
hand range real valued floating point overflows underflows frequently occur 
problems involving floating point variables practical necessity wrap entire algorithm error handlers accommodate possible kind floating point underflow overflow applicable particular computer involved 
fourth important note hierarchical genetic algorithm genetic algorithms general probabilistic different ways initial population typically generated entirely random available functions terminals parental individuals participating crossover operation chosen random crossover points parent selected random probability distribution individuals undergoing operation fitness proportionate reproduction chosen randomly proportion normalized fitness 
implementing genetic algorithms computer important effective capable producing stream seemingly independent random integers needed algorithm 
originally written purpose generating random floating point numbers suitable purpose 
independent seeds 
important option seeding interesting runs potentially replicated additional details displayed audit trail mentioned 
fifth problems involving iteration du operator operator sigma summation operator necessary suppress premature evaluation predicate arguments operator 
argument predicate argument operators evaluated outside operator 
argument evaluated dynamically inside operator iteration 
evaluation model common lisp operators implemented directly functions common lisp 
reason argument evaluated prior entry function operator example merely repeatedly evaluate value opposed doing 
problem solved implementing iterative operators common lisp macro related function 
example iterative du operator expand example du predicate rice 
body related function du implemented desired iterative behavior 
loop eval eval predicate 
possible arguments sub expressions predicate bound global environment 
principle addressed problem introducing quoting operator set functions allow du semantics du 
approach results incorrect performance quote function happens occur crossover point separated intended argument 
implementations common lisp texas instruments explorer machines group technique called macro displacement side effect programs interpreted macro expanded version 
beneficial effect speeding execution incurring cost macro expansion 
technique side effects program macro displacement disabled genetic operators crossover occurs individuals macro expansion may see forms introduced macro expander forms really part problem 
texas instruments machines behavior disabled setting si inhibit displacing flag sixth iterative operators du sigma individual expressions population contain unsatisfiable termination predicates 
practical necessity working serial computer place limits number iterations allowed execution operator 
individuals expressions genetic population contain deep nestings operators similar limit placed total number iterations allowed operators may evaluated process evaluating individual expression particular environmental case 
termination predicate operator implicit disjunction explicit predicate operator additional implicit termination predicates 
typical time limits du operator times iterations evaluation single du operator total iterations du operators evaluated particular individual expression particular environmental case 
course execute individual lisp expressions parallel nature infeasibility individual population bring entire process halt need limits 
note du operator times returns value 
particular du operator evaluates implicit termination predicates times 
value resulting eval uation du operator course addition side effects du function state variables system particularly stack table block stacking problem 
predicate du operator satisfied operator called du operator simply returns operator sigma operator treated similarly 
seventh simplest problems discussed overwhelming majority computer time consumed evaluation fitness individuals suppose actual genetic operations administrative aspects program 
true genetic algorithm problems general 
fitness calculation consumes overwhelming majority computer time fine grained parallelism opposed coarsegrained parallelism techniques data parallelism confer particular advantage 
similarly concentration exists ones efforts optimization necessarily focused entirely relatively small number lines code compute fitness various environmental cases particular problem 
highly effective way optimize fitness calculation create look table expressions previously encountered fitness need recomputed 
hash table span generations runs provided environmental cases remain 
note technique look tables inconsistent technique changing environmental cases generation minimize possible bias arising necessarily small sampling environmental cases problems fitness computations time consuming 
eighth problems involve time consuming transcendental functions exp sin cos computed taylor power series 
problems initial randomly generated individuals genetically created individuals population contain multiple occurrences functions single individual 
problems functions appear state transition equations problem individual expressions 
cases considerable amount computer time saved evaluating functions table look direct computation 

minor parameters controlling algorithm minor parameters control process 
control frequency performing genetic operations controls percentage internal function points chosen crossover points help conserve computer time 
values minor parameters problems described article 
crossover performed population generation 
population size individuals pairs generation selected allowed population probability equal normalized fitness 
second fitness proportionate reproduction performed population generation 
individuals generation selected allowed population probability equal normalized fitness 
third non uniform probability distribution potential crossover points parents 
allocates crossover points equally internal function points tree 
allocates remainder crossover points allocated equally external terminal points tree 
believe non uniform probability distribution promotes recombining larger structures case uniform distribution points may inordinate amount mere swapping terminals tree tree manner akin point mutation opposed true recombining building block substructures 
fourth maximum depth established expressions created crossover operation 
limit prevents large amounts computer time expended extremely deep usually highly unfit individual expressions 
course execute individual lisp expressions parallel nature manner infeasibility individual population disproportionately jeopardize resources needed population need kind artificial limit 
crossover parents create individual depth exceed limit contemplated crossover operation simply aborted replaced instance fitness proportionate reproduction parents 
limit typically reached crossovers run 
fifth maximum depth established random individuals generated initial random generation generation 
minor parameters probably acceptable problems encountered 
advisable increase minor parameters problems structure solution highly complex 
additional operations addition primary genetic operations fitness proportionate reproduction crossover secondary operations modifying structures undergoing adaptation 
mutation permutation editing define building block operation 

mutation operation mutation operation provides means introducing small random mutations population 
mutation operation asexual operation operates parental expression 
individual selected proportional normalized fitness 
result operation offspring expression 
mutation operation selects point lisp expression random 
point internal function external terminal point tree 
operation removes currently selected point inserts randomly generated subtree randomly selected point tree 
operation controlled parameter specifies maximum depth newly created inserted sub tree 
special case operation involves inserting single terminal sub tree depth randomly selected point tree 
example third point expression shown left selected mutation point sub expression randomly generated inserted point produce expression shown right 
mutation operation potentially beneficial diversity population may tending prematurely converge 
experience run mutation fitness proportionate reproduction crossover produced solution problem solutions theoretically possible time 
words mutating saving best better hierarchical genetic algorithms string genetic algorithms 
negative relative mutation operation similar reached research string genetic algorithms holland goldberg 

permutation operation permutation operation extension inversion operation string genetic algorithms domain hierarchical genetic algorithms generalization inversion operation 
permutation operation asexual operation operates parental expression 
individual selected manner proportional normalized fitness 
result operation offspring expression 
permutation operation selects function internal point lisp expression random 
function selected point arguments random permutation selected random set 
possible permutations 
arguments function selected point permuted accordance random permutation 
notice function selected point happens commutative immediate effect permutation operation value returned expression 
inversion operation strings reorders order characters selected points single individual reversing order characters selected points 
operation described allows 
possible permutations occur reversal 
permutation operation potentially bring closer elements relatively high fitness individual subject disruption due crossover 
mutation operation experience including permutation operation numerous runs various problems described benefits operation purely potential observed 

editing operation editing operation provides means edit simplify expressions algorithm running 
editing operation applied new population created action operations 
editing operation asexual operation operates parental 
result operation offspring expression 
previously described operations operate individuals selected proportion fitness 
editing operation exception 
editing operation applied individual expression population 
editing operation recursively applies pre established set editing rules expression population 
problem domains sub expression constant atoms arguments editing operation evaluate sub expression replace value obtained 
addition editing operation applies particular sets rules apply various problem domains including rules numeric domains rules boolean domains numeric problem domains example set editing rules includes rules insert zero sub expression subtracted identical sub expression includes rule inserts zero sub expression multiplied zero 
boolean problem domains set editing rules includes rule inserts place editing operation controlled frequency parameter specifies applied generation merely certain number generations 
main reason editing operation convenience 
simplifies expressions saves computer resources 
appears improve performance slightly 
editing operation apparently improves performance reducing vulnerability expression disruption due crossover points potentially non parsimonious sub expression 
crossover points typically leads counter productive results 
example consider sub expression 
sub expression simplified parsimonious sub expression example crossover middle sub expression usually produce exactly opposite boolean result expression 
example editing operation prevent kind crossover occurring condensing sub expression single term 
define building block operation define building block operation means automatically identifying potentially useful building blocks algorithm running 
define building block operation asexual operation operates parental expression 
individual selected proportional normalized fitness 
operation selects function internal point lisp expression random 
result operation offspring expression new definition 
define building block operation works defining new function replacing sub tree located chosen point call newly defined function 
newly defined function arguments 
body newly defined function sub tree located chosen point 
newly defined functions named df df df df created 
occasion new function defined run df inserted point selected lisp expression 
newly defined function compiled 
function set problem augmented include new function 
mutation arbitrary new sub tree grown selected point potential include newly defined function 
example consider simple lisp expression shown graphical form suppose third point multiplication selected point applying define building block operation 
subtree replaced call new defined function dfo producing new expression df shown graphical form df new tree call df lieu sub tree 
time function dfo created 
new defined function written lisp written shown defun df implementing operation computer sub tree calling multiplication defined compiled execution run 
lisp programming language facilitates define building block operation ways 
form data program lisp program altered merely performing operations data 
secondly possible compile new function execution run execute 
effect replacement selected sub tree longer subject potentially disruptive effects crossover indivisible single point 
effect newly defined indivisible function potential building block generations may proliferate population generations fitness 
note original parent expression unchanged operation 
selection parental expression proportion fitness original unaltered parental ex pression may participate additional genetic operations current generation including replication fitness proportionate reproduction crossover recombination define building block operation 
robustness existence population disjunctive alternative solutions problem allows genetic programming paradigm perform effectively environment changes 
demonstrate environment generations quadratic polynomial generation environment abruptly changes cubic polynomial generation changes new quadratic polynomial 
perfect scoring quadratic polynomial environment created generation 
normalized average population fitness stabilized neighborhood generations genetic diversity maintained 
predictably fitness level abruptly dropped virtually generation environment changed 
fitness increased generation stabilized neighborhood generations creation perfect scoring cubic polynomial 
fitness level abruptly dropped virtually generation environment changed 
generation fitness level stabilized neighborhood creation new perfect scoring quadratic polynomial 
performance measurement difficult meaningfully compare performance disparate machine learning paradigms 

factors involved comparing machine learning paradigms comparison machine learning paradigms involves different factors 
factors machine resources required execute algorithm notably computer time computer memory generality algorithm terms range problems solved qualitative features output presence default hierarchies quantitative features output algorithm parsimony ability algorithm scale extent character preprocessing inputs required intelligibility solution terms easily understood terms appropriate problem domain involved amount information size shape ultimate solution explicitly implicitly provided user ability provide audit trail showing algorithms arrived solution problem ability verify validity output ability incrementally modify solution particular ability robustly rapidly effectively modify solution handle slightly different situations ability algorithm yield near linear speed ups highly parallel computer architectures solve large problems ability algorithm fault tolerant sense algorithm operate reasonably processors data lost point run accuracy paradigm probabilistic deterministic nature algorithm 
attempt thorough comparison various machine learning paradigms 
comparing seemingly quantitative factor computer time requires selecting benchmark problems infinity potential problems 
paradigms especially suited solving certain types problems 
importantly paradigms simply solve certain types problems 
slow solving particular problem 
limiting test suite problems lowest common denominator problems solvable existing machine learning paradigms merely favors specialized paradigms problemsolving power 
hand broadening test suite effect automatically negatively paradigms solve suited solving added problems 
comparing seemingly quantitative factor computer time requires selecting particular computer benchmark comparison 
various computers may suited executing certain paradigms 
example particular parallel computer architecture may advantageous disadvantageous certain paradigms machine modest amount memory may advantageous disadvantageous certain paradigms lisp workstation especially suited lisp paradigm nominally fast workstations require vast amounts time perform relatively simple lisp operations boolean multiplexer problem offers opportunity compare speed narrow interesting class problems studied literature connection machine learning paradigms neural nets classifier systems inductive decision trees 
wilson reported order magnitude fewer iterations neural net barto 
particular problem iterations compared 
somewhat different iterative steps involved paradigms types iterative steps corresponded number examples seen system 
quinlan reported faster performance wilson inductive decision trees paradigm 
processing individuals genetic programming paradigm uses considerably computational resources measured time memory wilson quinlan approach particular problem 
genetic programming paradigm solutions boolean multiplexer problem processing individuals generations 
usually produces solutions processing individuals generation 
number examples seen system considered higher neighborhood barto approach 
discussed requirement processing individuals considered reasonable measure processing requirements genetic programming paradigm particular problem effect unsuccessful runs considered 
range problems solved genetic programming paradigm described solve number types problems solved solved existing machine learning paradigms 
fact solutions come form computer programs contain mixture conditional logical operations mathematical functions domain specific operations functions recursions iterations widens range machine learning problems easily handled handled 
variety different problems discussed suggests wide variety problems susceptible genetic programming paradigm 
qualitative features output algorithm algorithm described inherently hierarchical 
addition genetic programming paradigm produces results expressed terms default hierarchies 
quantitative features output algorithm inherently hierarchical character output contributes parsimony results 
key issue artificial intelligence machine learning scale promising techniques succeed small sub problems larger problems 
way solve large problems general decompose large problem hierarchically smaller sub problems building blocks 
plausible having hierarchical results smaller problems precondition scaling larger problems 
inherently hierarchical character results turn lead relatively high ability scale specifically demonstrated 
define building blocks operation appears facilitate identification useful building blocks construct hierarchical solutions problems 
amount type preprocessing required algorithm requires preprocessing inputs 
inputs directly terms observed state variables problem domain involved 
lack preprocessing major distinction relative typical neural network machine learning algorithms 
intelligibility absence preprocessing direct functions come problem domain inherently hierarchical character algorithm editing operation contributes intelligibility results terms problem domain involved 
requiring advance information size shape ultimate solution genetic programming paradigm uses relatively little advance knowledge 
contrast pre specifying precise string size classifier system approach boolean multiplexer problem pre specifying maximum number states finite automaton string approach artificial ant problem pre specifying precise number processing units layer number layers required neural network paradigms 
genetic algorithms general allow construction audit trail showing algorithm arrived solution problem 
ability verify results fact preprocessing inputs final result expressed directly terms functions relevant problem domain sit relatively easy verify solutions generated algorithm 
ability incrementally robustly rapidly effectively modify solution handle different situations genetic algorithms ability contrasted say neural net back propagation paradigm 
ability profitably parallelize algorithm genetic algorithms general yield near linear speed ups executed parallel computer architectures 
fault tolerance genetic algorithms general fault tolerant sense algorithm continue operate population lost point run 
accuracy genetic algorithms general reasonably accurate arriving solutions guidance provided fitness function 
determinism genetic algorithms general probabilistic deterministic algorithms 
particular interesting runs re created seeding 
attempt thorough comparison various machine learning paradigms perform limited task determining processing individuals required solve problems discussed 

premature convergence niches genetic algorithms general produce results particular run algorithm 
thing genetic algorithms inherently involve probabilistic steps major points cited earlier algorithm 
probabilistic steps viewed initial conditions uncontrolled chaotic variables 
probabilistic steps runs simply produce desired results 
addition genetic algorithms simply fail converge run particular amount time 
commonly genetic algorithms may prematurely converge converge sub optimal result 
exponentially increasing allocation trials basis currently observed fitness statistics population strength weakness genetic algorithms 
allocation weakness may result premature convergence booker 
allocation strength fundamental reason genetic algorithms place 
believe premature convergence occasional non convergence reasons viewed inherent aspect genetic algorithms problem cured trying alter fundamental nature algorithm 
nature guide 
premature convergence manifests nature form niche preemption principle 
nature biological niches tend dominated single species 
premature convergence particular niche occasional complete failure particular niche norm nature 
particular run genetic algorithm viewed niche particular runs genetic algorithm dominated particular sub optimal species 
nature carries genetic experiments parallel niches time 
nature avoids effects randomness niche preemption premature convergence chaotic affects initial conditions conducting experiments times parallel func equivalent niches 
best individual multiple experiments separate isolated niches potentially available proliferate 
similarly effects randomness premature convergence initial conditions chaotic affects genetic algorithms minimized making entirely separate multiple independent runs 
multiple independent runs course lend parallel computer architectures yield complete linear speed point 
note multiple independent runs talking involve cross migration cf 
tanese 
best single individual multiple independent runs identified solution problem 

amount processing required undertake measure genetic algorithms terms number niches multiple independent runs needed produce desired result certain probability say 
example particular run genetic algorithm produces desired result probability success ps specified number generation population size probability achieving desired result runs ps seeking achieve desired result probability say number independent runs niches required log log ps log log ps 
number independent runs niches obtained formula multiplied amount processing required run 
amount processing required generally proportional product population size number generations executed 
example ran runs boolean multiplexer population size probability success ps finding individual expression produced correct boolean output combinations boolean inputs generations 
probability success ps independent runs required assure probability solving problem 
tried population probability success ps population generations 
probability success ps independent runs required assure probability solving problem 
runs adjusted times greater computing effort required process individuals population size produces desired solution third computational effort population size 
noted similar advantage population size problems including artificial ant problem 
purposes presenting performance statistics section population size section 
section determine number probability success ps test suite twelve problems boolean multiplexer block stacking artificial ant john muir trail sequence induction fibonacci sequence sequence induction hofstadter sequence symbolic regression target function symbolic data function integration function integrated desired result symbolic data function differentiation sin function differentiated cos desired result differential equations dy dx automatic programming solving pair linear equations pursuer evader differential game symbolic multiple regression complex multiplication function target function 
began running runs usually problems test suite 
problem population size run 
problem ran generations run 
problem noted probability success ps finding desired solution generation 
note total number individuals need processed function percentage affects probability ps 
probability success ps turn function primary parameters algorithm population size number generations fixed secondary parameters genetic algorithm described section fixed minor details implementation algorithm 
multiplexer problem probability success ps individual produces desired boolean output combinations boolean inputs displayed graph function number generations 
particular probability success ps generations 
hits multiplexer generation block stacking problem probability success ps individual plan blocks stack spelling iterative time limits environmental starting condition cases displayed graph function number generations 
particular probability success ps generations 
fact level achieved generation 
hits generation artificial ant problem john muir trail probability success ps individual plan expression causes ant traverse entire trail collect stones time limit displayed graph function number generations 
particular probability success ps generations 
hits artificial ant generation sequence induction problem involving fibonacci sequence probability success ps individual expression produces correct integer value sequence non base positions sequence displayed graph function number generations 
particular probability success ps generations 
hits fibonacci sequence generation sequence induction problem involving hofstadter sequence probability success ps individual expression produces correct integer value sequence non base positions sequence displayed graph function number generations 
particular probability success ps generations 
hits hofstadter sequence generation symbolic regression problem target function probability success ps individual expression comes target function random values independent variable displayed graph function number generations 
particular probability success ps generations 
hits regression generation symbolic data function integration problem function integrated desired result probability success ps individual expression comes integral target function random points displayed graph function number generations 
particular probability success ps generations 
hits integration generation symbolic data function differentiation problem sin function differentiated cos desired result probability success ps individual expression comes derivative target function random points displayed graph function number generations 
particular probability success ps generations 
hits differentiation generation symbolic differential equation problem dy dx probability success ps finding individual expression substituted left hand side differential equation comes right hand side equation random points displayed graph function number generations 
particular probability success ps generations 
hits differential equation generation automatic programming problem involving solving pair linear equations probability success ps individual expression comes solution random equations displayed graph function number generations 
particular probability success ps generations 
hits linear equations generation pursuer evader differential game probability success ps individual pursuer strategy expression captures minimax evader time limits environmental starting condition cases displayed graph function number generations 
particular probability success ps generations 
hits game pursuit generation symbolic multiple regression problem complex multiplication target function probability success ps individual pair values list expressions comes target pair values measured distance measure described random combinations independent variables displayed graph function number generations 
particular probability success ps generations 
hits multiple regression generation probability success ps generation computed number independent runs niches needed achieve desired result probability 
computed number individuals processed order solve particular problem multiplying number runs population size times number generations 
note total number individuals need processed function percentage affects probability success ps method far perfect 
fixed common population size fixed common number generations optimal problems test suite 
infinity alternative ways distributing fixed computational budget total number individuals processed primary parameters algorithm 
example problems larger population size operating proportionately fewer generations total number individuals processed produces higher percentage success problems tradeoff opposite way produces higher percentage success 
addition fact population size number generations optimal number individuals processed order solve particular problem significantly fact computer time run run full generations 
actual practice usually abort run achieves desired result 
especially significant problems high percentage success 
number individuals processed premature convergence manifestly obvious far fewer generations problems described certain runs heuristically aborted save computer time 
relatively simple method estimation offers rough estimate number individuals processed order solve particular problem 
determined amount computer time required run problem explorer ii computer 
vast majority computer time consumed fitness evaluation genetic operations administrative tasks 
problems involving simple fitness calculation relatively small number environmental cases fibonacci sequence symbolic regression take smallest amount time 
problems involving iterative du loops block stacking iterative summation sigma loops recursions execution strategy time steps artificial ant differential pursuer evader game optimal control problems broom balancing involving numerical integration time steps take considerably time 
problems especially time consuming early generations relatively unfit individuals including individuals time consume maximum amount time allowed problem 
table shows probability success ps number independent runs niches needed achieve desired result probability number individuals processed number niches times times computer time run full run generations total computer time needed number independent runs times computer time run 
problem percent runs successful niches needed total individuals processed time run minutes multiplexer total computer time minutes block stacking artificial ant fibonacci sequence hofstadter sequence symbolic regression symbolic integration symbolic differentiation differential equations linear equations pursuer evader game multiple regression describe difficulty particular problem terms number niches independent runs required number individual processed 
seen table number niches number individuals processed achieve desired result probability ranges niches individuals differential pursuer evader game niches individuals multiple regression complex multiplication operator 
calculation expected number processing steps desirable addition results algorithms machine learning neural networks artificial intelligence 
example non algorithms back propagation algorithm neural network training trapped local maxima produce desired result reasons 
number failed runs affect reported measures total number processing steps required execute algorithm 
theoretical discussion holland focused attention fact genetic algorithms general viewed processing numerous schemata similarity templates merely relatively modest number individuals population 
string length alphabet size schema identified string length extended alphabet consisting alphabet symbols meta symbol don care consists set individual strings population symbols match symbols identifier specific positions positions identifier don care symbol 
schemata 
individual string occurs schemata regardless population individual strings appearances schemata depending population diversity 
binary case schema specificity corresponds hyperplane dimensionality containing individuals hamming hypercube dimension average fitness schema average observed fitness values individual strings contained schemata 
average fitness associated variance depends number items summed compute average 
holland showed genetic algorithms fitness proportionate reproduction crossover expected number occurrences schema generation approximately average fitness population small 
particular viewed generations stationary remains constant amount means schema average average fitness appears succeeding generations approximately exponentially increasing decreasing rate 
holland showed mathematical form optimal allocation trials random variables multi armed slot machine problem involving minimizing losses exploring new seemingly non optimal schemata exploiting seemingly optimal schemata similarly approximately exponential processing schemata genetic algorithms fitness proportionate reproduction crossover mathematically near optimal 
particular allocation trials nearly optimal small 
strings computed dividing defining length schema involved distance outermost specific non symbols number points crossover may occur 
short short schema small short compact building block 
genetic algorithms process short defining length schemata favorably 
importantly result problems solutions incrementally built small building blocks optimally handled genetic algorithms 
genetic programming paradigm individuals population lisp expressions rooted point labeled trees ordered branches linear character strings 
set similar individuals sharing common features schema hyperspace lisp set rooted point labeled trees ordered branches sharing common features 
consider case common features single sub tree consisting specified points unspecified don care points sub tree 
set individuals sharing common feature hyperspace consisting rooted point labeled trees plane containing designated sub tree sub tree 
set trees infinite partitioned finite subsets number points tree partitioning parameter 
subset trees having particular number points sharing fully specified sub tree considered fitness proportionate reproduction causes growth decay size subset new population accordance relative fitness subset average population fitness near optimal way string linear genetic algorithms 
holland results concerning optimal allocation trials holland results concerning growth decay number occurrences schemata result fitness proportionate reproduction depend character individual objects population 
deviation optimal rate growth decay schema caused crossover operation 
nature deviation crossover depend character individual objects population 
strings deviation relatively small distances points defining common feature relatively small 
relevant measure distance strings maximum distance defined positions 
principle appears apply objects trees 
deviation relatively small distances points defining common feature relatively small 
particular specific positions schema single sub tree deviation smallest 
particular ratio number points sub tree number points tree relatively small sub tree relatively small 
case specific positions schema single sub tree effect fitness proportionate reproduction crossover subprograms subtrees sub lists relatively high fitness programs building blocks constructing new individuals approximately near optimal way 
period time concentrates search solution space sub hyperspaces lisp expressions decreasing dimensionality increasing fitness 
argument appears extend similarities defined sub tree containing points internal sub tree similarities defined disjoint set sub trees type 
deviation optimality relatively small extent number points defining common feature relatively small number disjoint subtrees relatively small 
effect subprograms sub trees relatively high fitness individuals building blocks constructing new individuals 
genetic programming paradigm natural extension string linear genetic algorithms way 
genetic algorithms general mathematical algorithms darwinian principles reproduction survival fittest transform population individuals fitness environment new population individuals operations analogous genetic operations observed nature 
view character particular position mathematical character string conventional string genetic algorithm considered analogous nucleotide bases adenine molecules acid dna 
observed fitness environment entire actual biological individual created passive information particular linear string dna computation average schema fitness schema represented individual 
contrast proactive computational procedure carried lisp expression genetic programming paradigm viewed analogous performed protein living cell 
observed fitness environment entire actual biological individual created result action proactive lisp expressions contribute way string genetic algorithms directly computation average schema fitness schema represented individual 
genetic programming paradigm employs automatic allocation credit inherent basic genetic algorithm described holland inherent darwinian reproduction survival fittest biological populations nature 
automatic allocation credit contrasts bucket brigade credit allocation reinforcement algorithm classifier systems holland holland reitman founded observed natural mechanism involving adaptation biological populations 
holland seminal operational variations basic string genetic algorithm tested studied 
number cases consensus developed practitioners genetic algorithms specifying relatively standard approach genetic algorithms areas 
areas consensus exists 
case operational issues affecting basic string genetic algorithm reappear connection genetic programming paradigm 
include studying tradeoffs fixed computational budget population size number generations number niches independent runs 
include determining optimum percentage population undergo crossover versus fitness proportionate reproduction generation determining secondary genetic operations mutation permutation editing define building block techniques maintaining population diversity minimizing premature convergence cf 
booker effect different ways select spouse parent proportionate fitness versus random probability distributions uniform distribution making various random selections run non standard fitness measures rank fitness value versus fitness standard probability form techniques varying parameters genetic algorithm run information gained run ways parallelizing algorithm conditions terminating algorithm 

general discussion problem automatically generating computer program solve problem generally viewed area fruitful 
pessimistic view may stem part personal experience seeing small mistake ones computer programs program completely 
true computer programs sensitive small errors 
true error small nucleotide base nucleotide bases human genome difference normality fatal disease 
opposites observations true 
example small changes human genome portions acid sequence translated protein merely produce slightly different functionally equivalent proteins net effect whatsoever 
similarly true small changes computer programs merely produce slightly different functionally equivalent programs net effect whatsoever 
people written computer programs recall particular small errors caused programs similarly recall inconsequential changes programs 
reason generally pessimistic view likelihood solving problem automatic program generation rarely focuses extent computer programs built portions code programmer successfully 
computer programs replete building blocks previously programs 
summary people written computer programs considerations computer programs automatic generation minimize considerations side argument 
reason generally pessimistic view likelihood solving problem automatic program generation standards applied knee jerk reaction problem program generation applied form machine learning artificial intelligence 
standard stated follows paradigm solve problems types human judgment 
surprisingly standard applied paradigm program generation wanting 
want clear claim genetic programming paradigm described meets straw man standard 

paradigms machine learning artificial intelligence neural nets genetic algorithms classifier systems claim meet straw man standard 

straw man standard manifests various ways 
manifestation revelation genetic programming paradigm described requires function set specified user 
fact need revealed 
contrary clear user genetic programming paradigm select function set problem 
genetic programming paradigm similar paradigms machine learning set elementary functions specified 
example id related algorithms inducing decision trees start user specified set functions test training case actual case certain attributes 
user id provides set attribute testing functions chess pieces merely test wood plastic test rank id able classify chess board positions winning losing positions 
similarly user soar provides set elementary operations moving blank square puzzle just users artificial intelligence paradigms stacking blocks provide elementary operations moving individual blocks stack table 
manifestation straw man standard revelation user select certain certain parameters population size number generations 
fact need revealed 
contrary clear user genetic programming paradigm select certain parameters 
genetic programming paradigm similar paradigms certain parameters specified 
example user neural network select number processing units input layer hidden layer output layer network depending particular neural network paradigm user selected thresholds biases nature connectivity allowed network feed forward recurrent 
similarly user classifier system select number bits condition parts rule number classifier rules allowed number cycles run numerous parameters 
choice number bits condition parts rule particular limits computational complexity solution produced 
addition users neural networks classifier systems usually extensively preprocess inputs external environment system manner paradigm accept 
way straw man standard manifests concerns assertion paradigm example solution known knowledge solution valid 
known paradigms literature example problems solution known 
fact example problems solution known opposite question immediately arises question knows paradigm worked 

demonstrated number seemingly different problems artificial intelligence symbolic processing machine learning reformulated problems require discovery computer program produces desired output particular inputs 
problems include function learning robotic planning sequence induction symbolic function identification symbolic regression symbolic data function integration symbolic data function differentiation solving differential equations solving integral equations finding inverse functions solving general equations numerical values empirical discovery concept formation automatic programming pattern recognition optimal control game playing multiple regression simultaneous architectural design training neural network 
shown problems solved genetically breeding computer programs genetic programming paradigm 
acknowledgments drs 
thomas college university london martin keane third millennium venture capital limited chicago john perry texas instruments san francisco numerous valuable comments early drafts 
eric texas instruments education center austin implemented method programming crossover operation lisp significantly improved execution time author previous recursive version 
james rice knowledge systems laboratory ksl stanford university palo alto implemented method programming crossover operation lisp significantly improved execution time identified corrected programming problems greatly expanded efficiency functionality author program particularly interfaces instrumentation numerous extremely helpful respects 
john holland university michigan stewart wilson institute cambridge massachusetts lawrence davis bbn cambridge james rice numerous valuable comments drafts 
anderson charles learning control inverted pendulum neural networks 
ieee control systems magazine 

pages 
april 
axelrod evolution strategies iterated prisoner dilemma 
davis lawrence editor genetic algorithms simulated annealing london pittman 
barto anandan anderson cooperativity networks pattern recognizing stochastic learning automata narendra adaptive learning systems 
new york plenum 
booker improving search genetic algorithms 
davis lawrence editor genetic algorithms simulated annealing london pittman 
booker goldberg david holland john classifier systems genetic algorithms 
artificial intelligence 
economic database machine readable magnetic data file 
new york 
cramer lynn 
representation adaptive generation simple sequential programs 
proceedings international conference genetic algorithms applications 
hillsdale nj lawrence erlbaum associates 
davis lawrence editor genetic algorithms simulated annealing london pittman 
davis lawrence steenstrup genetic algorithms simulated annealing overview 
davis lawrence editor genetic algorithms simulated annealing london pittman 
dawkins richard 
blind watchmaker 
new york norton 
de jong kenneth genetic algorithms year perspective 
proceedings international conference genetic algorithms applications 
hillsdale nj lawrence erlbaum associates 
de jong kenneth genetic algorithms search program spaces 
genetic algorithms applications proceedings second international conference genetic algorithms 
hillsdale nj lawrence erlbaum associates 
de jong kenneth learning genetic algorithms overview 
machine learning 
doan thomas user manual rats regression analysis time series 
evanston il var econometrics fogel owens walsh artificial intelligence simulated evolution 
new york john wiley 
friedberg learning machine part ibm journal research development 
friedberg dunham north learning machine part ii 
ibm journal research development 
cory dickinson john 
genetic algorithm generate lisp source code solve prisoner dilemma 
grefenstette john editor 
genetic algorithms applications proceedings second international conference genetic algorithms 
hillsdale nj lawrence erlbaum associates 
cory 
evaluation holland genetic algorithm applied program generator 
master science thesis department computer science moscow id university idaho 
goldberg david computer aided gas pipeline operation genetic algorithms rule learning 
phd dissertation 
ann arbor university michigan 

goldberg david genetic algorithms search optimization machine learning 
reading ma addison wesley 
goldberg david holland john 
editors 
special issue genetic algorithms 
machine learning volume numbers 
goldberg david sizing populations serial parallel genetic algorithms 
schaffer 
editor proceedings third international conference genetic algorithms 
san mateo ca morgan kaufmann publishers 
green progress report program understanding systems 
stanford artificial intelligence laboratory memo aim 
stanford university computer science department 
august 
grefenstette john editor 
proceedings international conference genetic algorithms applications 
hillsdale nj lawrence erlbaum associates 
grefenstette john editor 
genetic algorithms applications proceedings second international conference genetic algorithms 
hillsdale nj lawrence erlbaum associates 
grefenstette john incorporating problem specific knowledge genetic algorithms 
davis 
editor genetic algorithms simulated annealing london pittman 
jeffrey porter richard small david unit potential gnp anchor price level 
washington dc board governors federal reserve system 
staff study april 
joseph application genetic algorithm automatic program generation 
master science thesis department computer science 
moscow id university idaho 
hillis daniel 
evolving parasites improve simulated evolution optimization procedure 
forrest stephanie editor emergent computation self organizing collective cooperative computing networks 
cambridge ma mit press appear 
physica appear 
hillis daniel 
evolving parasites improve simulated evolution optimization procedure langton christopher farmer 
editors proceedings second conference artificial life 
redwood city ca addison wesley 
press 
hinton geoffrey 
neural networks artificial intelligence 
santa monica ca technology transfer institute 
documentation dated december 
hinton geoffrey 
connectionist learning procedures 
artificial intelligence 

holland john adaptation natural artificial systems ann arbor mi university michigan press 
holland john escaping brittleness possibilities general purpose learning algorithms applied parallel rule systems 
michalski carbonell jaime mitchell tom machine learning artificial intelligence approach volume ii 

los altos ca morgan kaufman 
holland john echo explorations evolution world 
langton christopher farmer 
editors proceedings proceedings second conference artificial life 
redwood city ca addison wesley 
press 
holland john burks arthur adaptive computing system capable learning discovery 
patent 
issued september 
holland john burks arthur method controlling classifier system 
patent 
issued november 
holland john holyoak nisbett thagard induction processes inference learning discovery 
cambridge ma mit press 
holland john reitman cognitive systems adaptive algorithms 
waterman hayes roth frederick pattern directed inference systems new york academic press 
humphrey thomas precursors star model 
economic review 
richmond va federal reserve bank richmond 
july august 
pages 
isaacs 
differential games 
new york john wiley 
jefferson david collins rob system evolution theme artificial life 
langton christopher farmer 
editors proceedings second conference artificial life 
redwood city ca addison wesley 

press 
koza john hierarchical genetic algorithms operating populations computer programs 
proceedings th international joint conference artificial intelligence ijcai 
san mateo ca morgan kaufman 
koza john genetic approach econometric modeling 
sixth world congress econometric society 
barcelona spain 
august 
press 

koza john econometric modeling genetic breeding mathematical functions 
proceedings international symposium economic modeling 
italy 
press 

koza john non linear genetic algorithms solving problems 
patent 
filed may 
issued june 

koza john non linear genetic algorithms solving problems finding fit composition functions 
patent continuation part application 
filed march 

koza john keane martin cart centering broom balancing genetically breeding populations control strategy programs 
proceedings international joint conference neural networks washington january 
volume 
koza john keane martin genetic breeding non linear optimal control strategies broom balancing 
proceedings ninth international conference analysis optimization systems antibes france june 
new york spring verlag 
laird john rosenbloom paul newell allen 
soar universal subgoaling chunking 
boston ma kluwer academic publishers 
langley pat zytkow jan data driven approaches empirical discovery 
artificial intelligence 

langley pat simon herbert bradshaw gary zytkow jan scientific discovery computational explorations creative process 
cambridge ma mit press 
lenat douglas am artificial intelligence approach discovery mathematics heuristic search 
phd dissertation 
computer science department 
stanford university 

lenat douglas role heuristics learning discovery case studies 
michalski carbonell jaime mitchell tom machine learning artificial intelligence approach volume 
los altos ca morgan kaufman 
lenat douglas brown john seely 
am appear 
artificial intelligence 


anne ecological diversity measurement 
princeton nj princeton university press 

miller john evolution automata repeated prisoner dilemma 
fe institute report 

miller john evolution automata repeated prisoner dilemma 
essays economics imperfect information 
phd dissertation department economics university michigan 
mills small algebraic manipulation system solve differential integral equations variational approximation techniques 
journal symbolic computation 



minsky marvin papert seymour perceptrons 
cambridge ma mit press 

nilsson nils principles artificial intelligence 
los altos ca morgan kaufman 
nilsson nils action networks 
draft stanford computer science department working october 
stanford ca stanford university 

nilsson nils private communication 

quinlan induction decision trees 
machine learning 
quinlan empirical comparison genetic decision tree classifiers 
proceedings fifth international conference machine learning 
san mateo ca morgan kaufmann 

rice james private communication 

robertson george 
parallel implementation genetic algorithms classifier system 
davis 
editor genetic algorithms simulated annealing london pittman 
rumelhart hinton williams learning internal representations error propagation 
rumelhart mcclelland parallel distributed processing 
volume chapter 
cambridge ma mit press 

samuel studies machine learning game checkers 
ibm journal research development 
schaffer effects selection procedures hyperplane sampling genetic algorithms 
davis 
editor genetic algorithms simulated annealing london pittman 
schaffer 
editor proceedings third international conference genetic algorithms 
san mateo ca morgan kaufmann publishers 
smith steven learning system genetic adaptive algorithms 
phd dissertation 
pittsburgh university pittsburgh 
smith steven flexible learning problem solving heuristics adaptive search 
proceeding eighth international conference artificial intelligence 
karlsruhe germany morgan kaufman 
steele guy jr common lisp 
digital press 

tanese 
distributed genetic algorithm function optimization 
phd 
dissertation 
department electrical engineering computer science 
university michigan 

thomas bucket brigade genetic 
proceedings internal conference genetic algorithms applications 
hillsdale nj lawrence erlbaum associates 
widrow bernard 
pattern recognizing control systems 
computer information sciences coins symposium proceedings 
washington dc spartan books 
widrow bernard 
original adaptive neural net broom balancer 
ieee international symposium circuits systems 
vol 

wilson stewart 
classifier systems animat problem 
machine learning 
wilson stewart 
hierarchical credit allocation classifier system 
proceedings tenth international joint conference artificial intelligence 
wilson stewart bid competition specificity reconsidered 
journal complex systems 

wolfram stephen 
mathematica system doing mathematics computer 
redwood city ca addison wesley 

