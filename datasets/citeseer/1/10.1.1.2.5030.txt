improving test suites operational abstraction michael harder jeff michael ernst mit lab computer science technology square cambridge ma usa lcs mit edu presents operational difference technique generating augmenting minimizing test suites 
technique analogous structural code coverage techniques operates semantic domain program properties syntactic domain program text 
operational difference technique automatically selects test cases assumes existence source test cases 
technique dynamically generates operational abstractions describe observed behavior syntactically identical formal specifications test suite executions 
test suites generated adding cases operational abstraction stops changing 
resulting test suites small detect faults suites branch coverage better detecting certain common faults 
presents area stacking techniques comparing test suite generation strategies techniques avoid bias due test suite size 
program specifications play valuable role dynamic analyses software testing gg rot crs ol 
previous research automated testing required software testers provide formal specification 
furthermore research generally focused systematic generation test suites evaluation comparison existing test suites 
applicability previous research limited fact programs formally specified lack assert statements 
additionally software engineers may desire improve existing test suites tools selecting test cases 
operational difference od technique new specification test case selection technique enables augmentation minimization generation test suites cooperation existing technique test case generation 
require specification provided priori require oracle indicates particular test case passes fails 
automatically provides users operational abstraction 
operational abstraction syntactically identical formal specification describes actual behavior may may desired behavior 
testing operational abstraction provide benefits priori specification assisting regression testing revealing removed functionality checking test results 
operational abstractions useful right 
research builds previous testing research structural coverage criteria applies semantic domain program properties syntactic domain program text 
key idea operational difference technique comparison operational abstractions dynamically generated program executions 
test case improves operational abstraction added test suite test case removed appropriate 
implemented technique experimentally demonstrated efficacy creating test suites fault detection 
remainder organized follows 
section describes automatically induce operational abstraction program test suite 
section presents operational difference technique generating augmenting minimizing test suites 
section details experimental methodology section reports experiments demonstrating operational difference technique compares favorably methods 
section provides intuition experimental data technique works 
section summarizes related research section concludes 
generating operational abstractions operational abstraction formal mathematical description program behavior collection logical statements program runtime operation 
operational abstraction identical form formal specification 
formal specification intended written code express desired behavior 
contrast operational abstraction expresses observed behavior induced dynamically program executions 
experiments daikon dynamic invariant detector generate operational abstractions ideas generalize particular implementation 
briefly daikon discovers invariants program executions running program examining values computes detecting patterns relationships values 
detection step uses efficient generate algorithm reports properties hold execution entire test suite 
output improved suppressing invariants statistically justified techniques ecgn 
dynamic invariant detection affected internal structure program component analyzed 
zhu terminology technique interface variety black box testing 
generation operational abstractions test suite unsound properties guaranteed hold general 
dynamic approaches testing profiling accuracy inferred invariants depends part quality completeness test cases 
reported invariant universally true possible executions indicates property program context environment deficiency test suite 
cases human automated tool examine output enhance test suite address issue 
operational abstractions match human written formal specifications ern ecgn proved correct ne ne 
operational difference technique depend properties generates test suites detect faults operational abstraction differs formal specification human written program incorrect 
operational difference technique section describes operational difference od technique generating augmenting minimizing test suites 
od technique compares operational abstractions induced different test suites order decide test suite superior 
operational difference technique automatic test suite generation augmentation assumes existence source test cases 
words technique selects generate test cases techniques code coverage 
test statistical tests user settable confidence parameter 
results default value 
repeated experiments values differences negligible 
procedure od generate program int int testcase return 
pseudocode implementation basic operational difference od test suite generation technique 
userspecified procedure generates candidate test case experiments randomly select test cases pool 
procedure generates operational abstraction program test suite experiments daikon invariant detector section 
cases may created human generated random grammar generated specification extracted observed usage produced fashion 
basic od generation technique starts empty test suite empty operational abstraction 
repeatedly adds candidate test cases change operational abstraction retained possibly incorrect assumption operational abstraction generated larger test suite better 
candidate cases consecutively considered rejected process complete 
value chosen tradeoff running time generation process quality generated suite quality test case generation procedure may influence best choice improve basic od generation technique evaluating candidate test cases time selecting case changes operational abstraction minimizing resulting test suite generation 
test suite augmentation technique identical starts non empty test suite 
od test suite minimization technique considers test case turn removes removal change operational abstraction 
intuition test cases affect operational abstraction different test cases affect operational abstraction 
minimization similar generation select subset test cases 
minimization differs starts suite removes cases considers case suite resulting suite guaranteed qualities coverage operational abstraction original suite 
minimization generation typically produce quite different suites 
minimization useful generation test cases may subsume earlier ones 
candidate operational abstraction abs final test case precond 
postcondition suite return return return return return empty return return return return return return 
example generating test suite od base technique 
candidate test cases considered order top bottom test case added suite changes operational abstraction 
process terminates test cases consecutively considered rejected 
final test suite 
final operational abstraction preconditions postconditions 
postconditions contain modified omitted brevity 
minimization techniques od technique guarantee minimized suite smallest set cases generate original operational abstraction 
furthermore guarantee removed test case detect fault 
software engineer minimization test suites questionable value ones randomly generated 
minimization test case prioritization valuable reducing test suite 
instance large test suite run night weekend developers run subset suite frequently 
statistical tests current implementation operational abstractions multiple entity criterion jh single test case may guarantee particular invariant reported reported 
necessary condition technique plan experiment ways combine operational abstractions individual test cases reduce cost suite generation 
illustrates od technique generates test suite absolute value procedure 
example uses operational abstraction generator reports properties procedure entries exits var constant var constant var constant var var property property experimental methodology section describes subject programs evaluate operational difference technique measurements performed controlled size comparing test suite generation strategies 
subject programs experiments analyze programs 
program comes faulty versions pool test cases 
discovered additional errors programs course research 
lists subjects 
programs created siemens research subsequently modified rothermel harrold rh 
siemens researchers generated tests automatically test specification scripts augmented white box tests feasible statement branch def pair covered test cases 
siemens researchers created faulty versions programs introducing errors considered realistic 
faulty version differs canonical version lines code 
discarded faulty versions detected fewer test cases considered discarded faults easy hard detect 
test suite detects fault outputs faulty correct versions differ 
eighth program space interprets array definition language inputs 
test pool space contains cases 
generated randomly frankl vf remainder added graves ghk edge control flow graph covered cases 
time error detected program development graves new faulty version program containing error created 
experiments test suites generated randomly selecting cases test pool 
experiments statement branch def coverage suites generated rothermel harrold rh 
suites generated picking tests pool random adding suite added coverage coverage conditions satisfied 
test suites type coverage statement def covering suites space 
threats validity 
subject programs moderate size larger programs different characteristics 
chose understood previous research access programs human generated tests faulty versions 
suspect programs differ large programs program size faulty test pool description program procedures loc ncnb versions cases calls op 
abs 
size program print tokens lexical analyzer print tokens lexical analyzer replace pattern replacement schedule priority scheduler schedule priority scheduler tcas altitude separation tot info information measure space adl interpreter 
subject programs experiments 
loc total lines code ncnb number non comment non blank lines code 
test suite size measured number test cases invocations subject program number dynamic non library procedure calls 
operational abstraction size number invariants generated daikon invariant detector run program full test pool 
machine generated tests faults differ real ones 
pool test cases generated test specification scripts augmented code coverage mind 
pool may relatively better code coverage techniques operational difference technique 
faults selected cases detected fault 
undetermined effect particularly previous researchers eliminated hardest faults detected test cases 
small number faults certain programs quantized fault detection ratio small number values making harder correlate measures 
combination statements high coverage similarly quantized statement coverage 
measurement details section describes measurements performed 
code size standard 
test suite size 
measured test suite size terms test cases procedure calls 
primary motivation measuring quantities control avoid effects 
test case input program test 
readily apparent static measure size 
single case execute machine instructions run hours 
number dynamic non library procedure calls approximates runtime required execute test suite relevant testers strong effect fault detection 
measured quantities results similar effect 
code coverage 
simplicity presentation term code coverage structural code coverage criterion 
measured statement coverage gcc fault detection test suite size fault detection test suite size 
pitfalls comparing test suites different sizes 
labeled points indicate natural size fault detection suites produced test suite generation techniques graphs natural test suites identical 
curves show size fault detection stacked suites generated randomly combining subsetting natural suites 
left hand graph technique superior 
right hand graph technique superior 
tool branch coverage testing technology cover tool 
unreachable code unrealizable paths programs prevent tools reporting coverage 
normalized code coverage measurements dividing number statements branches covered full set test cases 
fault detection 
test suite detects fault detects faulty version program output faulty version differs output correct version run test suite 
fault detection rate test suite ratio number faulty versions detected number faulty program versions 
section describes faulty versions 
comparing test suites stacking area misleading directly compare test suite generation techniques create suites different sizes test suite size strongly affects fault detection see section 
comparing test suites fault detection size ratio known efficiency unsatisfactory fault detection versus size curve straight line see doubling size double fault detec tion curve points arbitrarily low efficiency 
seriously efficiency address question technique detect greatest number faults test budget terms suite execution time 
propose area technique described compare test suite generation strategies simply comparing test suites 
observe test suite generation strategy produces suites particular size call natural size tester suites arbitrary runtime fit testing runtime budget process call stacking 
generated suite large tester subset random subset 
generated suite small tester combine suites generated technique reach goal size choosing subset generated suite 
assume test suite generator deterministic suites combined identical 
instance test suite generator may select test cases candidate test cases different orders create different suites 
stacked suites may suites directly generated equivalent size 
example may better generate suite covers statement twice stack single statement coverage suites size twice coverage suites 
directly generating arbitrary size may available testers testers may know technique create suite exactly fits testing budget 
testers stacking available test suite generator 
stacking permits comparison different test suite generation strategies arbitrary test suite sizes 
comparing particular size disadvantage strategy different projects different testing budgets necessary compare techniques multiple sizes 
sample fault detection versus size curves induced stacking compare areas curves 
gives idea techniques compare arbitrary size 
specifically create curves stacking test generation strategy natural sizes 
practice curves cross sense magnitude comparison determined single size 
fact curves cross suggests stacking tends preserve qualities test suites 
evaluation section experimentally evaluates operational difference od technique generating augmenting minimizing test suites 
test suite generation compared test suites generated operational difference statement coverage branch coverage def cov od statement branch def fault size fault size fault size fault size print tokens print tokens replace schedule schedule tcas tot info partial average space average 
test suites created automatic generation techniques 
fault fraction faults detected 
size number test cases suite similar results hold size measured terms number procedure calls runtime 
numbers averaged suites type program 
statement def coverage suites available space 
technique ratio def coverage branch coverage operational difference statement coverage random 
effectiveness test suite generation techniques measured area technique section compared random selection 
erage random selection techniques 
arbitrarily chose od technique meaning process terminated consecutive test cases considered changing operational abstraction 
different value change generation time suite quality 
structural coverage suites generated achieve perfect coverage know candidate test cases rejected row generating 
subject program generated test suites od technique measured average size fault detection 
compares automatically generated suites 
include suites achieving complete statement branch def coverage 
average line shows od test suites average size branch covering test suites achieve slightly better fault detection versus 
order better quantify differences test generation techniques employed area stacking methodology section compare 
generated operational difference statement coverage branch coverage def coverage suites 
stacked different od statement branch def random suites natural sizes total suites sizes describing fault detection versus size curves 
repeated process times program total approximately fault detection curves space statement def curves 
summed area un der curves technique computed ratios sums 
presents results performs best followed branch od nearly indistinguishable statement random 
constructing structural coverage suites difficult tedious impractical 
test cases covered structural element times generated hand see section 
contrast special test cases provided od technique 
detecting specific faults operational difference technique provides fault detection branch coverage area technique accurate simply noting average od suites smaller better fault detection branch coverage suites 
additionally od technique superior detecting certain types faults 
compared individual fault detection rates od technique branch coverage technique 
fault program measured proportion times fault detected technique 
nonparametric test determine statistically significant difference proportions level 
total faults programs examined 
od technique better detecting faults stacked branch coverage better detecting faults difference statistically significant faults 
wished determine qualitative difference faults detected best od technique faults detected best stacked branch coverage technique 
examined faulty version hand determine changed control flow graph cfg program 
treated basic blocks nodes cfg adding statement basic block change cfg 
examples cfg changes include adding removing statement adding removing case switch statement adding removing return statement 
examples non cfg changes include adding removing statement basic block changing variable name changing operator modifying expression condition statement 
fault cfg change change value expression program 
results table 
od better branch better total cfg change non cfg change total od technique better detecting value non cfg changes 
intuitive sense operational abstractions assertions values variables 
techniques equally detecting cfg changes 
expected branch coverage dominate case measured terms cfg 
target programs non cfg change faults outnumber cfg change faults factor 
faults real faults created people considered realistic representative distribution faults practice may similar 
test suite augmentation operational difference augmentation technique identical generation technique process started existing test suite empty test suite 
evaluated technique starting branch coverage suites table gives results evaluating area technique 
numbers differ slightly previous results compare def natural size experiment basic improved od technique 
raw numbers available technical report har 
technique ratio branch coverage operational difference branch operational difference random suggested section code coverage operational coverage techniques complementary combining effective isolation 
test suite minimization program generated random test suites cases 
minimized od technique maintaining branch coverage table gives results measured area technique 
technique ratio branch coverage operational difference random shows additional data od technique results better fault detection substantially larger test suites minimizing maintaining branch coverage 
works section explains justifies insights led operational difference test suite improvement techniques 
section defines operational coverage measures quality arbitrary operational abstraction orig od min random branch min fault size fault size fault size fault size print tokens print tokens replace schedule schedule tcas tot info space average 
test suites minimized automatic techniques 
fault fraction faults detected 
size number test cases suite 
numbers averaged suites type program 
oracle operational abstraction 
section shows tests added random suite suite operational coverage increases rapidly levels high value 
section shows operational coverage correlated fault detection test suite size code coverage held constant 
operational coverage operational coverage defined measures difference operational abstraction oracle goal specification 
coverage measures operational coverage value inclusive empty test suite ideal test suite 
accounts false assertions true assertions missing operational abstraction 
operational abstraction set assertions program chosen grammar 
assume exists oracle goal operational abstraction containing true assertions grammar 
oracle evaluate justify operational difference technique 
application od technique require existence oracle technique extended take advantage oracle 
test suite operational abstraction oa contains assertions true observations running program test suite 
define oa number true assertions oa 
precision oa fraction assertions oa true oa 
recall oa fraction assertions oa 
precision recall standard measures information retrieval sal vr 
define operational coverage oa weighted average precision recall giving ap simplicity choose giving 
example suppose oracle contains assertions operational abstraction contains assertions true false 
precision recall operational coverage suite size cases branch coverage branch coverage knee operational coverage operational coverage knee fault detection fault detection knee 
effect test suite size measured cases branch coverage operational coverage fault detection test suites replace program 
programs similar graphs graphs fault detection size terms calls similar 

oracles sections come 
oracle set invariants daikon grammar true 
exactly operational abstraction daikon generate test suite 
extreme infinitely large test suite containing valid inputs program surely 
test suites ran daikon full pool test cases program approximation 
believe pools sufficiently large diverse adding additional test cases change operational abstraction little 
effect test suite size fault detection tests added random suite operational coverage increases rapidly levels high value 
words distinct types test suites 
suites inducing relatively poor operational abstractions measurably improved augmentation 
suites inducing operational abstractions little affected augmentation operational abstractions close ideal substantially improved 
plots average branch coverage operational coverage fault detection suite size replace program randomly generated test suites case sizes 
plot statement coverage lies exactly branch coverage 
plots knee curve 
computed knee finding size minimizes summed mean square error lines regressed sets points left right 
knee intersection pair lines fit best 
knee necessarily lie cases knee calls knee cases coverage calls coverage statement cov 
operational cov 
branch cov 
fault detection 
table knee locations averaged programs 
numbers indicate plots statement coverage operational coverage fault detection branch coverage time switch nearly linear component indicate average positions knees plotted program 
table gives knees different metrics test suite size number cases number calls 
curve 
gives average positions knees programs 
intuitively knee appears size separates low coverage easily improved suites high coverage suites benefit little addition test cases 
knees significant reasons 
indicate roughly size coverage users expect generated suites encouraging small sizes high coverages 
significantly knee high coverage value slope knee horizontal generation process take longer terminate 
operational coverage fault detection section demonstrated high absolute levels operational coverage achievable 
section shows increasing operational coverage improving operational abstraction results greater fault detection 
section demonstrates result arbitrary test suites section demonstrates test suite achieves code coverage increasing operational coverage improves fault detection 
random suites analyzed randomly generated test suites programs 
suite sizes cases uniformly distributed number cases fault detection knee section 
consider larger suites augmenting large test suite little effect 
test suite calculated size cases calls statement coverage branch coverage operational coverage fault detection 
performed multiple regressions program 
regressions indicate predictor affects result holding factors constant example avoids effect size coverage larger suites tend coverage 
independent dependent variable variable op 
cov 
stmt 
cov 
fault detection cases calls op 
cov 
stmt 
cov 
independent dependent variable variable op 
cov 
branch cov 
fault detection cases calls op 
cov 
branch cov 

standardized multiple regression coefficients averaged programs 
standardized coefficients coefficients produced data analyzed standard score form 
standard score form means variables standardized mean zero standard deviation 
standardized coefficients reflect relative importance predictor variables 
column table presents results separate multiple regression 
column presents results multiple regression 
instance upper left regression uses size statement coverage independent variables uses operational coverage dependent variable 
performed sets multiple regressions set involving variables statement coverage branch coverage highly correlated fail test non collinearity bias results 
separating variables avoids problem 
means coefficients statement branch coverage directly compared 
significant interaction effect predictor variables level 
computed show raw correlation coefficients 
example operational coverage predict fault detection coefficient 
means operational coverage increased percent predictors held constant fault detection increases percent 
standardized coefficients indicate direction relative magnitude correlation independent dependent variables 
test suite runtime important predictor fault detection followed branch coverage number cases statement coverage operational coverage 
important draw experiment operational coverage useful predictor fault detection test suites operational coverage detect faults better 
operational coverage predictor fault detection statement coverage metrics test suite size 
effect code coverage final experiment demonstrates value operational coverage test suite quality metric indepen coverage op 
cov 
mean mean stat 
type coefficient op 
cov 
fault detect sig 
sig 
statement branch def 
multiple regression coefficient operational coverage regressed fault detection 
coefficient size statistically significant programs omitted table 
coefficient operational coverage statistically significant programs 
stat 
sig column contains number sig column contains number programs coefficient statistically significant 
value averaged programs operational coverage coefficient statistically significant 
dent code coverage metrics 
subject programs space analyzed suites statement coverage suites branch coverage suites def coverage 
space analyzed suites branch coverage 
obtained suites rothermel harrold rh statement def covering suites space able generate 
section describes test suites presents average sizes cases 
statement branch coverage suites number cases def coverage suites times large 
calculated size operational coverage fault detection rate test suite 
type coverage program performed multiple regression size operational coverage independent variables fault detection dependent variable 
performed multiple regressions total programs coverage criteria plus coverage criterion space 
summarizes results 
coefficient describes relationship operational coverage fault detection 
example coefficient statement coverage suites suggests operational coverage suite increased percent factors held constant fault detection rate increase approximately percent 
mean operational coverage fault detection indicate improvement possible maximum values 
results show test suites branch statement coverage increasing operational coverage increase fault detection 
suites def coverage fault detection independent operational coverage programs statistically significant coefficients operational coverage near perfect test suites little room improvement 
results show operational coverage complementary code coverage detecting faults 
statement branch coverage increasing operational coverage increase fault detection test suite increasing test suite size 
stated way operational coverage indicates indistinguishable respect code coverage test suites best 
effort improve test suites demonstrated code coverage operational coverage correlated fault detection improving operational coverage tends detect different faults improving code coverage section 
indicate relative effort software tester invest improving types coverage 
assess difficult programmer increase operational coverage relative takes achieve similar gain statement coverage 
percent code coverage hardest achieve 
operational coverage similar 
related complements extends research specification testing 
part previous research focused systematic generation evaluation test suites required users provide specification priori 
relax constraints provide new applications show bring new benefits specification testing 
specifications test suite generation goodenough gerhart gg gg suggest users partition input domain equivalence classes select test data class 
specification testing formalized richardson rot extended implementation test generation techniques formal specification languages 
derive test cases precondition postcondition pair specifications 
test cases test adequacy metrics 
early emphasizes techniques complement supplement structural techniques effective certain circumstances results reinforce point 
category partition method ob calls writing series formal test specifications test generator tool produce tests 
formal test specifications consist direct inputs environmental properties plus list categories partitions input derived hand high level specification 
automate category partition method writing test scripts tests generated obeying certain constraints 
specifications describe tests code really declarative programming languages specifications 
syntax may characterize program tests serve different purpose program specifications 
don distinguishes specifications test classes test frames 
gives procedure converting goal proposed earlier leaves converting test frames test cases human tool 
dick faivre df building bgm vdm generate test cases preconditions postconditions invariants 
uses variety vdm called vdm sl generate test sets high level specification intended behavior 
offutt generate tests constraints describe path conditions erroneous state specifications ol 
assumes priori specification form generate test cases test suites composed test cases 
contrast operational difference technique assumes existence test case generator serve generates test suite operational abstraction 
specifications test suite evaluation chang richardson structural specification testing sst technique cr uses formal specifications provided test engineer test selection test coverage measurement 
tool converts specifications written adl hs series checks code called coverage condition functions crs 
specification large original program converted code statement coverage techniques applied directly run test suite count checks covered 
uncovered test indicates aspect specification inadequately exercised testing 
technique validated discovery exhaustively automatically generated program mutants 
similar assume test case generation strategy evaluate test suites test cases inclusion test suite 
sst requires existence priori specification operational difference technique provides operational abstraction 
related coverage criteria researchers proposed specification notions coverage similar definition operational coverage section 
case test suite evaluated respect goal specification 
related extends structural coverage specifications computing specification covered execution test suite 
contrast operational coverage compares operational abstractions 
burton bur uses term specification coverage refer coverage statements specification execution concept introduced named chang richardson cr 
burton suggests applying boolean operand effectiveness modified condition decision coverage mc dc reified specifications coverage criterion requires boolean subterm branch condition take possible value 
extensions structural coverage criteria specification checks possible don evaluated 
hoffman hs techniques generating test suites include tests combinations extremal values 
suites said boundary value coverage variety data coverage 
tool constructs suites supports dependent domains reduce size test suites compared full cross product domains 
ernst ern uses term value coverage refer covering variable values including boundary values current research builds 
hamlet probable correctness theory ham calls uniformly sampling possible values variables 
random testing operational testing competitive superior partition testing debug testing directed testing strategies terms delivered reliability dn ht 
reasonable assumptions testers perfect intuition small number tests may performed 
operational coverage assist operational random testing permitting improved test coverage better understanding test cases situations 
chang richardson operator coverage cr measure test suite quality concerns creation mutant faulty versions programs 
operator coverage achieved operator program changed mutant version 
mutants assess test suite comprehensiveness terms fault detection mutants 
black ab measure test suite coverage terms number mutant specifications form ctl formulae killed 
mutant version specification contains specific small syntactic error test suite said kill mutant test suite gives different result faulty version correct version 
black model checking check test cases ctl specifications 
mutant killed component specification covered component specification mutated 
operational difference od technique generating augmenting minimizing test suites 
technique selects test cases comparing operational abstractions dynamically generated test suites 
operational abstraction describes observed behavior syntactically identical formal specification 
test case considered interesting addition removal changes operational abstraction 
od technique automatic generation augmentation assumes existence test case generator provides candidate test cases 
od generation technique produced test suites smaller slightly effective fault detection branch coverage suites 
od suites equally detecting errors change control flow graph effective detecting non cfg changing errors 
techniques complementary combining structural operational coverage techniques effective isolation 
characteristics technique inducing operational abstractions explain efficacy od technique 
possible create high quality operational abstraction knowing precisely ideal randomly adding test cases operational abstraction stabilizes 
second improvements operational abstraction correlated fault detection test suites code coverage 
statement branch coverage longer differentiate test cases od technique determine test cases advantageous 
results depend generated operational abstraction describes actual intended behavior close formal specification human write practice 
likewise results depend program correct od technique produces test suites fault detection buggy programs 
experiments test programs generate operational abstractions contained errors experiments confirmed od technique hindered errors program operational abstraction induced 
need oracle determines test case passes fails subsequent generated test suites require creation oracle 
operational difference technique automatic takes input test case generator test suite sample inputs require programmer provide priori formal specification 
specifications rare programmers write programmers perceive cost high benefit low od technique expands applicability specification testing 
technique added benefit generating high quality operational abstraction program benefits users interested benefit need examine operational abstraction 
od technique directly analogous techniques creating code coverage suites operates program properties semantic domain source code constructs syntactic domain 
believe experiments validate operating automatically generated program properties program text holds substantial promise testing software engineering tasks 
acknowledgments benjamin morse wrote front daikon system assisted data collection 
members daikon project notably jeremy nimmer assistance research tools 
gregg rothermel provided siemens programs answered questions 
provided statistical consulting 
research supported ntt nsf career ccr gift edison design group 
ab paul paul black 
coverage metric evaluate test sets 
international journal reliability quality safety engineering 
bgm gilles marie claude gaudel bruno 
software testing formal specifications theory tool 
iee software engineering journal november 
marc william thomas ostrand 
automatic generation test scripts formal test specifications 
richard kemmerer editor proceedings acm sigsoft third symposium testing analysis verification tav pages december 
bur simon burton 
automated unit testing statechart implementations 
technical report department computer science university york uk 
cr chang debra richardson 
structural specification testing automated support experimental evaluation 
proceedings th european software engineering conference th acm sigsoft symposium foundations software engineering pages september 
crs chang debra richardson sriram sankar 
structural specification testing adl 
proceedings international symposium software testing analysis issta pages 
df dick faivre 
automating generating sequencing test cases model specifications 
fme industrial strength formal methods th international symposium formal methods europe pages 
dn joe duran simeon ntafos 
evaluation random testing 
ieee transactions software engineering july 
don michael 
automating formal testing 
tapsoft theory practice software development th international joint conference caap fase pages 
springer verlag april 
ecgn michael ernst adam william griswold david notkin 
quickly detecting relevant program invariants 
icse proceedings nd international conference software engineering pages limerick ireland june 
ecgn michael ernst jake cockrell william griswold david notkin 
dynamically discovering program invariants support program evolution 
ieee transactions software engineering february 
previous version appeared icse proceedings st international conference software engineering pages los angeles ca usa may 
ern michael ernst 
dynamically discovering program invariants 
phd thesis university washington department computer science engineering seattle washington august 
frankl richard hamlet littlewood lorenzo 
evaluating testing methods delivered reliability 
ieee transactions software engineering august 
special section international conference software engineering icse 
frankl dick hamlet littlewood lorenzo 
correction evaluating testing methods delivered reliability 
ieee transactions software engineering march april 
gg john goodenough susan gerhart 
correction theory test data selection 
ieee transactions software engineering december 
gg john goodenough susan gerhart 
theory test data selection 
ieee transactions software engineering june 
ghk todd graves mary jean harrold jung min kim adam porter gregg rothermel 
empirical study regression test selection techniques 
acm transactions software engineering methodology april 
ham richard hamlet 
probable correctness theory 
information processing letters april 
har michael harder 
improving test suites generated specifications 
technical report mit laboratory computer science cambridge ma june 
revision author master thesis 
monica hutchins herb foster thomas ostrand 
experiments effectiveness controlflow test adequacy criteria 
proceedings th international conference software engineering pages sorrento italy may 
hs roger hayes sriram sankar 
specifying testing software components adl 
technical report tr sun microsystems research palo alto ca usa april 
hs daniel hoffman paul 
tools techniques java api testing 
proceedings australian software engineering conference pages 
daniel hoffman paul lee white 
boundary values automated component testing 
software testing verification reliability march 
ht dick hamlet ross taylor 
partition testing inspire confidence 
ieee transactions software engineering december 
jh james jones mary jean harrold 
test suite reduction prioritization modified condition decision coverage 
icsm proceedings international conference software maintenance pages florence italy november 
christophe 
automatic generation software test cases formal specifications 
phd thesis queen university belfast 
ne jeremy nimmer michael ernst 
automatic generation program specifications 
issta proceedings international symposium software testing analysis pages rome italy july 
ne jeremy nimmer michael ernst 
invariant inference static checking empirical evaluation 
proceedings acm sigsoft th international symposium foundations software engineering fse pages charleston sc november 
toh ne win michael ernst stephen garland nancy lynch 
simulated execution verifying distributed algorithms 
fourth international conference verification model checking interpretation pages new york new york january 
ob ostrand 
category partition method specifying generating functional tests 
communications acm june 
jefferson offutt 
integrated automatic test data generation system 
journal systems integration november 
ol jefferson offutt liu 
generating test data specifications 
journal systems software december 
rh gregg rothermel mary jean harrold 
empirical studies safe regression test selection technique 
ieee transactions software engineering june 
rot debra richardson owen malley cindy 
approaches specification testing 
richard kemmerer editor proceedings acm sigsoft third symposium testing analysis verification tav pages december 
sal gerard salton 
automatic information organization retrieval 
mcgraw hill 
kalman toth michael jeffrey joyce 
generating test cases formal specifications 
th annual symposium international council systems engineering boston july 
vf frankl 
empirical evaluation textual differencing regression testing technique 
proceedings international conference software maintenance pages 
vr van rijsbergen 
information retrieval 
butterworths london second edition 
hong zhu patrick hall john may software unit test coverage adequacy 
acm computing surveys december 

