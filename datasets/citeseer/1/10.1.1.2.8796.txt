macedon methodology automatically creating evaluating designing overlay networks rodriguez charles killian bhat duke university razor cs duke edu amin vahdat uc san diego vahdat cs ucsd edu currently researchers designing implementing largescale overlay services employ disparate techniques stage production cycle design implementation experimentation evaluation 
result complex tedious tasks duplicated leading ine ective resource di culty fairly comparing competing algorithms 
macedon infrastructure provides facilities specify distributed algorithms concise domainspecific language ii generate code executes popular evaluation infrastructures live networks iii leverage overlay generic api simplify interoperability algorithm implementations applications iv enable consistent experimental evaluation 
macedon implement evaluate number algorithms including bullet chord nice overcast pastry scribe splitstream typically lines macedon code 
infrastructure able accurately reproduce exceed published results behavior demonstrated current publicly available implementations 
designing implementing robust high performance networked systems di cult 
overcoming di culty increasingly important larger fraction world infrastructure comes rely networked systems 
challenges include network host failures highly variable communication patterns race conditions reproducing bugs security 
research supported part national science foundation eia itr hewlett packard ibm intel microsoft 
additional information available macedon website www cs duke edu razor macedon 
student georgia institute technology cc gatech edu supported nsf career award ccr 
advent higher level programming languages java raised level abstraction somewhat eased burden programmers faced daunting task re inventing appropriate techniques dealing asynchronous failure prone network environments known handful elite programmers 
seek explore appropriate programming models development environments twin goals making easier advance state art building robust networked systems ii bringing state art programmers large 
ambitious ort attempts uncover relevant issues focusing programming language runtime support designing implementing evaluating emerging class distributed services overlay networks 
initially focus types overlays distributed hash tables dhts application layer multicast believe framework applicable classes overlays indirect routing ron bone bgp :10.1.1.159.9358:10.1.1.111.1818:10.1.1.1.4196:10.1.1.161.2760:10.1.1.28.5987
view current overlay research cycle consisting phases su ers number challenges 
overlay researcher designs algorithm optimizes network metrics latency provides application behavior lg routing hops dhts 
second phase implementations created evaluate algorithm performance 
example researchers create hand crafted simulators evaluating performance scale live implementations evaluation real settings 
creating implementations tedious di cult due size software components needed complexity functionality 
algorithm implementations researchers experimentation gather run time performance data third phase 
usually includes simulation network simulator ns small scale live internet runs planetlab :10.1.1.109.4681
unfortunately custom simulation capture full intricacies network behavior congestion queuing 
ns address shortcoming faces scalability limitations nodes making overlay evaluation problematic 
live deployment certainly provides existence proof enable evaluation scale highly dynamic conditions 
final phase evaluation involves processing information generated experimentation hand crafted tools 
researchers subsequently modify implementations light code bugs suboptimal performance 
employ disparate implementation techniques causing evaluation competing overlays reflect di erences implementation methodologies algorithmic principles design 
address limitations macedon infrastructure simplify design development evaluation comparison large scale overlays 
macedon researchers specify algorithm behavior terms event driven finite state machines fsms consisting system states events message reception remote node failure transitions indicating actions take response events 
highlevel specification macedon generates code variety experimentation infrastructures leveraging shared extensible libraries 
libraries implement base overlay maintenance functionality thread timer management network communication debugging state serialization 
improvements system support equally applied protocols 
ultimately system mechanisms enable fair comparisons merits individual algorithms artifacts particular implementations 
macedon currently generates native runs unmodified live internet settings including planetlab modelnet large scale network emulator 
modelnet enables subject overlays thousands nodes characteristics large network topologies capturing scale realism 
macedon eliminates need maintain multiple versions algorithm di erent evaluation infrastructures 
provide built support tracking popular overlay evaluation metrics average delay penalty communication overhead communication stretch 
evaluation tools enable researchers gain deeper understanding complex behavior algorithms closing streamlined development cycle 
validate utility approach implemented number overlays macedon framework 
leveraged macedon guide design bullet 
macedon implementations include chord nice overcast pastry scribe splitstream :10.1.1.16.8178:10.1.1.1.4196:10.1.1.28.5987
compare generated code published results publicly available implementations 
comparison indicates macedon able reproduce exceed performance systems concise system descriptions consisting lines 
standard api applications protocols coded services overlay may easily switch providing similar functionality 
instance scribe application layer multicast protocol switched pastry chord changing single line macedon specification 
isolation protocol implementations constitute important contribution validation results published separately authors 
taken demonstrate generality utility macedon framework developing comparing overlays 
time hope code wide variety overlays publicly available lowering barrier experiment new ideas space 
organized follows 
define overlays terms abstraction section 
section gives details overlay implementation macedon language 
validation methodology section 
section compares macedon implementation infrastructures describes related 
conclude section 
overlay abstraction seek provide representation distributed algorithms expressive characterize intricacies di erent protocols simple facilitate implementation 
identify common characteristics overlays describe fsm approach describing 
show unifying abstraction enable concise descriptions wide array network protocols 
feasible prove overlays share characteristics encounter 
high level overlay network distributed algorithm nodes establish logical peer neighbor relationships subset global participants forming logical network overlayed atop ip substrate 
examples include advanced communication semantics provided multicast overlays network maintenance performed bgp routers 
subset overlays export apis allow applications transmit data 
initial macedon implementation focuses algorithms note macedon generic framework developing wide variety distributed systems 
particular initial targets distributed hash tables dhts applicationlevel multicast described section 
fsm representation overlay nodes maintain local state regarding current activities communicate neighbors control messages 
periodic timers schedule processing may receive application commands instructing perform operation 
fundamental premise approach characteristics succinctly described event driven finite state machines fsms 
model events message reception scheduled completion timers application commands trigger overlay protocol perform protocol actions 
actions include setting local node state transmitting new messages scheduling timers delivering application data exhaustive list 
events may occur nearly simultaneously requiring serialization local state 
addition events may cause protocol move system state phase execution 
behavior event certain system state may di erent state 
summary believe su ciently capture overlay intricate behavior describing system states local node state events response events fsm framework 
subsections describe components macedon fsm abstraction 
node state overlay node maintains local state describing current position activities 
local state determines node relationship current neighbors 
example tree overlay overcast parent children neighbors 
behavior node peer may di erent depending peer type 
may maintain list potential peers establish peer relationships 
functionality required certain overlays nodes establish peer relationship delete knowledge potential peer 
overlays ron state may include list nodes overlay :10.1.1.161.2760
node state may include specialized information identifies characteristics node position overlay 
examples include bandwidth estimates neighbor nodes overcast routing tables dhts 
term type node state state variables 
addition algorithms system states represent high level phases processing 
example initialization node overlay may enter joining phase join request message transmitted node overlay 
probing state nodes probe certain population overlay participants instance reduce latency overlay 
events target systems asynchronous events move node system state performing subsequent actions sending message 
events include timer expirations message reception api function calls 
message reception node processes message performing appropriate actions response 
instance node receiving join request may attempt add joining node neighbor 
scheduled timer expires node performs functions appropriate timer 
example nice node schedules timers check protocol invariants :10.1.1.16.8178
node cluster large small node initiates cluster split merge 
node change system state perform number coordinating actions 
event application issues commands overlay 
receiving call node may change state perform appropriate actions 
application commands fall categories control commands administrative operations data commands transmitting data overlay 
distinction control data operations central macedon handling asynchronous events 
control operations modify node state exclusively serialized protocol instance 
data operations simply read node state enabling shared protocol access 
macedon events may occur simultaneously 
example application may spawn multiple threads api call control data overlay instance leading potential race conditions 
likewise multiple timer transport threads may execute simultaneously 
allowing multiple data operations proceed simultaneously macedon exploits advantages multithreaded programming achieve superior performance delivering data overlay 
overlay developers classify transitions control requiring write access node state data read access 
classification determine proper level protocol instance locking transition basis 
instance secured read write lock 
control operations secure lock exclusively writing data operations read locking allow multiple threads execute parallel increasing performance working threads block multi processor available 
actions transition representing series related actions uniquely identified event fsm state 
current system state determines algorithm response specific events 
example node joined portion overcast algorithm representation 
circles represent fsm states 
directed edges identify transitions events unshaded text actions shaded text boxes 
overlay may transition joining phase transmit confirmation 
actions include scheduling timer transmitting message changing node state 
overlays employ periodic timers execute overlay maintenance check invariants periodic action 
example chord periodically checks repairs routing finger table entries 
messages provide fundamental mechanism coordinating distributed actions transmitting data 
chord node transmits route repair requests neighbors 
chord nodes transmit data messages overlay enabling application application communication 
overlay protocol specifies state variables change event 
chord node gathers route replies determine route entries stale updates accordingly 
example overcast overlay fsm behavior specified mac file 
aid specification helpful describe highlevel behavior algorithm graphically illustrated 
shows overcast system states associated transitions 
protocol begins init state transitions joined state node bootstrap node designated root overlay 
transmits join request bootstrap 
joined node including bootstrap receiving join request add incoming node child neighbor list transmit join reply confirm process 
receiving join reply joining node stores new parent parent neighbor list transitions joined state 
timer allows joined nodes periodically evaluate position 
timer expires node initiates probes grandparent siblings omit details node acquires information enters probed state 
uses state field count number nodes probing 
receiving probe request nodes send equally spaced probes defined rate timer 
probes transmitted probing node transmits probe reply returns joined state 
probed node gathers necessary replies nodes count decides move new parent 
moves enters joining state sends join request new parent 
simply returns joined state 
section describes high level representation captured overcast mac file 
macedon api overlay algorithms typically target specific types applications 
important characteristic implementation api export 
example multicast overlay export send function disseminate macedon protocol stack 
data overlay 
obfuscated design believe imperative overlay implementations provide appropriate apis application developers 
number orts initial steps creating single standard api 
adopt api similar enable api extensibility protocol specific functionality 
standard api enables macedon applications select underlying overlays modification 
general overlays support multicast route primitives route data source destination overlay 
typically overlays provide upcalls routing hop intermediate nodes perform application specific functionality 
example intermediate scribe node receiving join request group add group list multicast sessions propagate request destination building reverse path distribution tree 
protocol layering central implementing algorithms macedon 
macedon protocol stack divided components application multiple protocol layers network substrate ns tcp ip 
tcp ip stack higher layers macedon services lower layers 
bullet example uses simple randomly constructed tree baseline data distribution 
illustrates simplified version api macedon overlays export 
provide extensible upcall mechanism perform collaboration layers stack 
instances mechanism describe forward deliver notify extensible upcalls handled generic handler 
node calls forward typedef int macedon forward handler char msg int size int type int nexthop macedon key typedef void macedon deliver handler char msg int size int type typedef void macedon notify handler int type int size int neighbors typedef int macedon upcall handler int operation void arg macedon init macedon key bootstrap int prot void macedon register handlers macedon forward handler macedon deliver handler macedon notify handler macedon upcall handler int macedon create group macedon key groupid void macedon join macedon key groupid void macedon leave macedon key groupid int macedon route macedon key dest char msg int size int priority int macedon multicast macedon key groupid char msg int size int priority int macedon anycast macedon key groupid char msg int size int priority int macedon int dest char msg int size int priority simplified macedon api 
message routing decision 
intermediate nodes change message destination message altogether 
notify upcall allows lower layer protocols inform higher layers changes neighbor lists higher layer may require direct knowledge 
application optionally registers upcall handlers macedon register handlers function 
handler necessary application receive data overlay having null handlers evaluating just construction process di erent overlays 
shows macedon init initializes overlay identified application specified wellknown protocol value akin protocol values ip 
application initializes registers handlers send receive data 
unicast data overlay implement routing functionality determines neighbor receives data packets 
macedon route function accepts message destination form macedon key meaning necessarily ip address hash ip address name 
similar primitive macedon enables native ip communication ip host 
multicast primitives include macedon create group create sessions 
sole input value handle associated session group 
receivers join leave session macedon join protocol uses addressing hash ip trace low med high states transports tcp udp swp messages auxiliary data fail detect timer transitions api init route multicast 
join upcall ext timer forward recv macedon grammar highlights 
macedon leave specifying group value 
similar macedon route macedon multicast requires session id node destination address 
macedon collect introduces new primitive traditional overlay apis 
essentially performs opposite multicast data originates non root nodes collected distribution tree root 
intermediate nodes summarize data applicationspecific manner ultimately delivering global summary tree root 
believe number applications benefit communication paradigm 
macedon framework section describes developer specify overlay behavior macedon 
give overview language discuss expressiveness 
describe macedon captures subtle implementation details greatly influence overlay performance 
grammar overview highlights macedon language grammar 
allows developer define protocol specification macedon translates working code 
main headers mac file 
protocol header specifies name protocol optionally base protocol layering 
example specify protocol scribe uses pastry run scribe pastry protocol scribe uses chord change underlying dht 
manner perform direct comparison dhts support application layer multicast 
addressing header specifies protocol uses ip hash addressing 
add types addressing example test new hashing algorithms node identifier schemes 
tracing header set increasing levels automatic tracing 
state data section includes definitions states neighbor types transports messages state variables 
states portion defines allowed set protocol fsm states 
init state automatically generated starting state protocols 
overcast state definitions refer states joining probing probed joined neighbor types section specifies sets neighbors protocol tracks maximum number 
neighbor types may specify optional fields delay track neighbor basis 
note field set neighbors 
returning example overcast nodes parent children neighbors neighbor types 
fields omitted max children 
fields omitted protocol specifies persistent state variables 
addition standard language types neighbor sets multidimensional arrays types state variables specify timers specified expiration period 
neighbor list may labeled fail detect instructing macedon monitor neighbors failure 
detecting failure macedon invoke overlay error api transition 
overcast specification includes state variables state variables parent neighbor kids children neighbors grandparent neighbor brothers sibling neighbors int probed node node probing int probes send count probes left timer keep probing timer timer probe requester timer 
fields omitted brevity macedon lowest layer protocol specifies transports uses associates transport instances message transports messages definitions 
messages may contain fields including standard language types neighbor sets 
communication macedon reliable congestion friendly tcp unreliable congestion unfriendly udp reliable congestion unfriendly simple sliding window protocol swp 
advantageous multiple blocking transports tcp type 
particularly evident message higher priority 
transport blocked sending low priority messages unable send available high priority messages connection unblocked 
defining multiple transport priority problem easily overcome 
example overcast includes transports swp highest tcp high tcp med tcp low udp best effort messages best effort join highest join reply int response highest probe request 
fields omitted overcast includes tcp transports swp udp associates message appropriate transport 
higher layers specification associates messages default service class priority 
higher layer invokes layer transmit message passing desired priority 
lower layer determines process message priority 
transitions section describes bulk overlay behavior 
developer uses set macedon primitives describe actions result triggered events 
transitions scoped fsm state expression allowing protocol specify di erent behavior current system state 
developer may specify transition specific options write versus read serialization write semantics assumed default 
types transitions api timer message 
overcast specification large include summarize transitions actions removed brevity transitions api route locking read 
probing timer keep probing locking read 
joining init recv join 
api transition enables layers communicate layers directly macedon stack 
init api called higher layer initialize protocol state schedule necessary timers 
route multicast anycast collect represent requests transmit data 
example shows declaration overcast route api read locking semantics 
create group join leave control calls managing multicast session state 
remaining api calls represent atypical extensible calls code including notifying upper layers changed neighbor set generic upcall ext ext provide extensible specification layer layer collaboration failure detection error 
current implementation assumes failure peer node message received seconds configurable parameter 
communication ceased seconds parameter macedon triggers heartbeat request response sequence solicit communication 
appropriate failure detection ongoing area research 
consider macedon appropriate framework research 
timer transition occurs timer expiration 
overcast keep probing timer fires node transmitting probes 
case node probing state follows read locking semantics node state modified transition 
message transition called response message reception 
addition state scoping transitions scoped message type enabling di erent transitions di erent messages 
macedon messages delivered final destination forwarded node forward message 
example specified join message reception state matches expression joining init overcast node joined probing probed states 
transition modifies state variables default write locking semantics 
code generation macedon generates api consistent code termed macedon agent algorithm specification 
macedon parses specification translates executable code uses library functions macedon code engine including timer transport subsystems partial support generating ns code better reproducibility results 
engine code libraries common overlay implementations increasing evaluation consistency code reuse 
current infrastructure support programming languages java subject ongoing 
translation phase involves declaration protocol messages states neighbor types state variables transitions 
create demultiplexing function receive data packets macedon interoperability layer turn interfaces ns native tcp ip sockets 
receiving message 
macedon agents 
function calls appropriate transition function node current state message type 
macedon translates api specifications timer transitions way 
outlines resulting structure macedon agents 
macedon subsystems implemented thread pools process timer transport events 
application threads invoke transitions agents 
timers employed layer macedon stack 
lowest layer agent may interact directly transport subsystem 
likewise highest layer agent interacts directly application 
example shows layered agents macedon supports layering arbitrary number agents 
specifying actions section describes overlay developer invokes transition actions macedon 
done solely target programming language macedon provides libraries invoking commonly actions including necessary functions interface timer transport subsystems invoking cross layer upcalls 
macedon library collection extensible allowing users add library routines 
example created library manipulates bloom filters 
remainder section describes support commonly actions sample transition overcast specification 
line sample transition shows access response field incoming join reply message 
joining recv join reply field response neighbor size neighbor pops neighbor random route remove pops neighbor clear neighbor add state change joined timer probe requester pint neighbor pops neighbor random neighbor query brothers neighbor newp neighbor entry brothers pops delay newp delay upcall notify nbr type parent neighbor size state change joined 
omitted sample overcast transition 
basic action specified transitions changing system state specified lines 
line shows invoke macedon timer subsystem schedule timer event 
demonstrate upcall invocation line 
transmitting messages overlay protocols transmit messages lower layers underlying network substrate 
macedon built transmission primitives form api msg dest fields bu addr bu size pri line sample overcast transition illustrates transmit remove message old parent determined move occur 
specifying bu er address size zero message appending application data 
priority requests message default transport 
neighbor management macedon provides primitives simplify neighbor list management 
sample transition heavy facilities 
lines illustrate neighbor size function returns size neigh bor list 
line adds neighbor line shows clear neighbor list 
neighbor lists queried line source address inbound join reply message accessed directly line 
lines illustrate selecting random entry neighbor list 
typically overlays compare potential edges performance metric round trip time nice 
overcast estimates bandwidth measuring delay associated receiving number probes sustained bandwidth 
line shows neighbor entries store information 
additional neighbor entry fields maintained manner 
explicit thread serialization locking behavior specified transition declarations overlay developer may required explicit access agent protocol instance lock 
conditions locking required may depend intricate behavior transition 
case transition employ lock write lock read unlock primitives 
experience transition locking adequate overlays considered 
evaluation section evaluate macedon ability facilitate overlay design implementation evaluation ii implement broad range algorithms performance scalability characteristics iii enable comparisons competing overlay technologies 
practical prove macedon able meet demands distributed algorithms success broad variety modern overlays support goal qualitatively improving way overlay research conducted 
expressiveness key contribution implementation validation broad range network overlays macedon environment including bullet chord nice overcast pastry scribe splitstream :10.1.1.16.8178:10.1.1.1.4196:10.1.1.28.5987
summarizes lines code loc counts macedon specifications 
nice complex protocol required approximately weeks skilled programmer time implement debug 
macedon specification approximately loc lines code various algorithm specifications 
generated code 
macedon operating environment loc yielding estimated total loc completely implement nice scratch 
spectrum splitstream macedon specification lines code primarily splitstream layered top scribe pastry exploits functionality provided systems 
implementing splitstream required small changes scribe implementation primarily description splitstream requires changes scribe pushdown function 
splitstream scribe originally designed run pastry note macedon layering feature conjunction standard api allows switch underlying dht layers easily 
instance experiments show results splitstream running pastry currently experimenting chord underlying dht 
validation section provides validation subset abbreviated space reasons macedon generated implementations compared published results freely available code distributions mit lsd chord freepastry 
note results included achieved macedon mac specifications described 
believe results confirm generality accuracy performance infrastructure 
modelnet infrastructure emulate large scale internet topologies capturing hop hop congestion queuing behavior 
nice validation extracted information re create authors internet topology :10.1.1.16.8178
evaluation infrastructure stretch sites distribution stretch members nice macedon nice sigcomm observed stretch published macedon nice implementations 
allows extract features resulting overlay modelnet routing topology information 
experiments node inet topologies varying numbers clients 
cases run experiments ghz pentium iii machines running linux 
multiplex multiple node instances machines 
traffic passes ghz pentium iii modelnet cores running freebsd 
results modelnet note successfully run smaller experiments nodes planetlab refer sample results :10.1.1.109.4681
nice validate implementation nice run experiments described small scale internet scenarios nodes compare results published values :10.1.1.16.8178
figures show average observed stretch latency nice nodes di erent internet sites reported figures versus macedon implementation :10.1.1.16.8178
slightly set macedon values right clarity 
results closely match published results minor discrepancy sites 
believe due implementation lacking probe time binning strategy adding implementation straightforward :10.1.1.16.8178
chord validated macedon chord implementation comparing mit distribution lsd 
node inet topology chord overlay latency ms sites distribution latency members nice macedon nice sigcomm observed latencies published macedon nice implementations 
pants experiment 
modifications mit code dump routing tables seconds available macedon implementation debugging features smaller hash function implementation chord uses bit hash address space nodes hash hash address macedon lsd 
calculated correct routing tables node global knowledge nodes joining system 
shows convergence routing tables correct values time averaged node macedon lsd 
graphs shows macedon curves corresponding di erent settings fix fingers timer 
timer triggers chord route repair request message random finger routing table entry 
ultimate destination message responds allowing requesting node verify correctness route entry 
lsd code dynamically adjusts period fix fingers timer current macedon implementation supports static periods seconds experiment 
optimal strategy dynamically adjusting protocol parameters timer periods unclear 
example static second strategy outperforms lsd dynamic strategy 
converse true second timer setting convergence slower case 
macedon cases routing tables converge steadily nodes join chord ring eventually leveling nodes joined 
lsd convergence steady fix fingers timers dynamically adjusted 
goal experiment demonstrate macedon ability match exceed lsd 
note macedon enables researchers ectively explore di erent dynamic timer strategies 
average number correct route entries time macedon sec timer mit lsd macedon sec timer convergence correct routing tables mit macedon chord implementations 
pastry goal macedon framework enable rapid prototyping distributed systems maintaining performance low level optimizations available hand crafted implementations 
initial validation success metric compare performance pastry algorithm implemented macedon freepastry :10.1.1.28.5987
macedon provides high level specification language benefits java libraries routines specifically tailored dhts overlays 
produces code su er memory performance overheads associated java rmi 
macedon pastry implementation consists semicolons versus approximately semicolons java freepastry implementation quantify benefits developed simple test application validate pastry implementation 
application instance streams target data rate kbps example sending byte packets interval 
data send application chooses destination id uniformly random hash address space 
estimate delays macedon pastry freepastry rmi protocol 
varied number randomly selected nodes node topology 
systems allowed routing tables converge seconds streaming data 
due low streaming rate intended targets received essentially packets transmitted 
sys freepastry distribution consists semicolons significant functionality pastry 
estimate conservative count manual inspection source tree 
average latency seconds number nodes freepastry macedon average latency received pastry packets 
tems node received approximately number packets corresponding size hash address space portion owns 
illustrates average packet delays 
unable run freepastry participants instances physical machine due insu cient memory hardware 
successfully run macedon instances machines 
graph shows average latency macedon approximately lower freepastry largely attributable java rmi overhead 
freepastry wire protocol yielded favorable results comparable macedon cases unstable current freepastry release 
results show promise macedon ability enable rapid prototyping maintaining system performance 
comparing overlays important contribution macedon creation fair consistent overlay evaluation framework 
macedon generates native tcp ip code allowing leverage modelnet emulation live deployment internet including planetlab testbed support simulation environments provide limited ns compatibility 
macedon automatically extract vital topology information ns modelnet allowing evaluate overlays wide array metrics 
global information impossible accurately gauge overlay performance certain metrics 
example macedon extract routing tables ns modelnet report expected performance metrics link stress latency stretch relative delay penalty rdp 
bandwidth kbps time avg bandwidth cache evictions avg bandwidth sec cache lifetime splitstream bandwidth cache policies 
disparate evaluation techniques led di erent performance evaluation metrics overlay comparison 
evaluation may concerned low link stress unclear relevant applications 
high bandwidth link link stress hundreds chat application perform link stress modem link video distribution unacceptable 
result challenging choose appropriate evaluation metric 
macedon attempts bridge gap providing framework report variety popular evaluation metrics 
believe macedon encourage evaluation performance metrics allowing metrics evaluated 
splitstream experiments designed demonstrate macedon ability experiment variety protocol features 
tests created node splitstream forests 
developed multicast application streams byte packets predetermined rate kbps experiments 
node designated stream source nodes join multicast session receivers 
allow pastry routing tables converge idling system seconds 
shows resulting node average bandwidth time convergence period splitstream flavors 
splitstream scribe macedon requesting data delivered directly ip 
pastry maintaining location cache maps hash addresses ips 
cache entries associated lifetime avoiding stale mappings lead ine cient routing node receive packets hash address longer owns 
cache eviction disabled splitstream delivers average kbps node additional nodes enter overlay cache entries remain correct 
second cache lifetime bandwidth drops kbps additional bandwidth consumed re establish stale cache entries 
summary believe macedon appropriate carrying detailed uniform protocol comparisons 
related macedon currently supports types overlays distributed hash tables dhts application level multicast 
dhts applications hashing map data objects nodes logical address space request routing 
hash value node determines portion hash address space owns data objects serve 
ensuring sublinear node routing table state overlay width depending uniform server distribution consistent hashing overlay algorithms exhibit high performance scalability 
built top pastry dht scribe creates multicast distribution trees rooted dht node owning multicast session id receivers enter session routing join requests root :10.1.1.1.4196
intermediate nodes path subsequently create reverse path forwarding tree 
building scribe success splitstream uses multiple scribe trees data striping achieving higher bandwidth 
popular multicast overlays dhts 
including overcast nice create distribution trees optimized application specific performance :10.1.1.16.8178
contrast bullet creates mesh nodes exchange summary tickets select data peers 
nodes disjoint data peer 
data received number carefully selected peers bullet nodes receive higher bandwidth relative tree overlays 
evaluation methodologies ns network simulator provides standard framework accurate simulation network protocols 
unfortunately packet level congestion aware simulation costly leading inadequate scaling properties evaluating overlays size 
smaller scale scenarios ns provides cient inexpensive mechanism system evaluation 
researchers created simulators sacrificing accuracy scale 
simulators tend provide packet level simulation fail account congestion packet loss queuing delays 
scale limitations overcome network emulation modelnet 
enables emulation native ip applications subjecting packets link restrictions specified network topology 
emulates routers queuing delay congestion 
experiences thousands overlay nodes run commodity pcs modelnet environment 
code runs unmodified production internet environments testbeds including planetlab :10.1.1.109.4681
result modelnet accuracy scalability appropriate choice large scale evaluation 
environment developing evaluating distributed algorithms 
similar macedon allows algorithm specification simulator live system 
macedon provides dsl set libraries address common issues distributed algorithm development generic api facilitates interoperability overlay algorithms applications 
related languages macedon broadly related domain specific languages dsls typically generate functional code domain specific representations 
teapot dsl writing cache coherence protocols 
macedon teapot describes protocol behavior event driven finite state machines 
teapot generate continuations allow nodes suspend processing waiting particular event 
macedon code generated teapot self contained user hand code message handling functions 
additionally teapot target domain cache coherence protocols somewhat smaller macedon domain 
domain specific language devil interface description language idl designed substantially di erent domain macedon related design 
idl documentation hardware interfaces help driver development reducing burden low level programming 
devil includes semantics verifying specifications 
substantial research network protocol specification implementation 
uses context free attribute grammar protocol specification emphasizing simplicity portability 
grammar capture event sequences allowed protocol 
morpheus object oriented language tailored high performance protocol implementations 
constrains protocol designer set design disciplines derived experience advocates simple protocols selected combined runtime capitalizes knowledge common patterns protocol processing optimize generated object code 
lightweight object oriented language focuses readability modularity extensibility 
authors er positive experiences tcp implementation 
actions allow arbitrary code included inserted code produced compiler 
relative orts macedon specifically geared overlay networks focusing standard api explicit support protocol layering language support common overlay functionality 
system specification number languages target high level design protocol verification 
range highly mathematical ioa programmatic languages tla 
contrast macedon generates functional code 
ioa input output automaton specification language allowing designers specify describe system 
ioa tools perform simulated execution suggest invariants automatically prove seemingly tedious portions system specification 
formal verification 
tla high level specification highly mathematical language 
intended design aid combined model checker find remove flaws system designs system implementation 
macedon facilitate design implementation overlay algorithms 
system provides domain specific language specifying high level behavior overlays dhts application level multicast 
macedon provides common infrastructure enables fair consistent overlay evaluation 
overlay generic api enables protocol layering facilitates porting applications overlay 
results show macedon greatly decrease development evaluation ort yielding overlay implementations closely resemble outperform published results including bullet overcast nice chord pastry scribe splitstream 
believe macedon educational tool understand intricacies overlay algorithms 
believe macedon vision extends overlay algorithms include wider class distributed algorithms subject 
acknowledgments david becker ken help modelnet 
addition shepherd timothy roscoe rebecca anonymous reviewers provided excellent feedback 
mark abbott larry peterson 
language approach protocol implementation 
ieee acm transactions networking 
david andersen hari balakrishnan frans kaashoek robert morris :10.1.1.161.2760
resilient overlay networks 
proceedings sosp october 
david anderson lawrence landweber 
methodology protocol specification implementation 
proceedings ninth symposium data communications pages 
acm press 
banerjee bobby bhattacharjee christopher :10.1.1.16.8178
scalable application layer multicast 
proceedings acm sigcomm pages 
leslie lamport 
high level specifications lessons industry 
proceedings international symposium formal methods comp objects leiden netherlands march 
miguel castro peter druschel anne marie kermarrec nandi antony rowstron atul singh 
splitstream high bandwidth multicast cooperative environments 
proceedings th acm symposium operating system principles october 
satish chandra bradley richards james larus 
teapot domain specific language writing cache coherence protocols 
ieee transactions software engineering may june 
chang ramesh govindan sugih jamin scott shenker walter willinger 
capturing representative level internet topologies 
proceedings acm sigmetrics june 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proceedings th acm symposium operating systems principles sosp october 
frank dabek ben zhao peter john kubiatowicz ion stoica 
common api structured peerto peer overlays 
nd international workshop peerto peer systems iptps february 
gupta ken birman prakash demers robbert van renesse 
kelips building cient stable dht increased memory background overhead 
proceedings nd international workshop peer peer systems iptps 
yang hua chu sanjay rao srinivasan seshan hui zhang 
enabling conferencing applications internet overlay multicast architecture 
proceedings acm sigcomm august 
john jannotti david gi ord kirk johnson frans kaashoek jr james toole 
overcast reliable multicasting overlay network 
proceedings operating systems design implementation osdi october 
eddie kohler frans kaashoek david montgomery 
readable tcp protocol language 
sigcomm pages 
rodriguez albrecht amin vahdat 
random subsets build scalable network services 
proceedings usenix symposium internet technologies systems march 
rodriguez albrecht amin vahdat 
bullet high bandwidth data dissemination overlay mesh 
proceedings th acm symposium operating system principles october 
massachusetts institute technology 
lsd 
www pdos lcs mit edu chord 
fabric laurent charles consel renaud marlet gilles muller 
devil idl hardware programming 
proceedings th usenix symposium operating systems design imp osdi san diego california october 
larry peterson tom anderson david culler timothy roscoe :10.1.1.109.4681
blueprint introducing disruptive technology internet 
proceedings acm hotnets october 
rice university 
freepastry 
www cs rice edu cs systems pastry freepastry 
rodriguez amin vahdat 
scalability adaptive multi metric overlays 
th international conference distributed computing systems icdcs march 
antony rowstron peter druschel :10.1.1.28.5987
pastry scalable distributed object location routing large scale peerto peer systems 
middleware november 
antony rowstron peter druschel 
storage management caching past large scale persistent peer peer storage utility 
proceedings th acm symposium operating systems principles sosp october 
antony rowstron anne marie kermarrec miguel castro peter druschel :10.1.1.1.4196
scribe design large scale event notification infrastructure 
third international workshop networked group communication november 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
proceedings sigcomm august 
peter urban xavier andre schiper 
single environment simulate prototype distributed algorithms 
pages 
amin vahdat ken kevin walsh mahadevan je chase david becker 
scalability accuracy large scale network emulator 
proceedings th symposium operating systems design implementation osdi december 
toh ne win michael ernst stephen garland nancy lynch 
simulated execution verifying distributed algorithms 
fourth international conference verification model checking interpretation pages new york january 
ellen zegura kenneth calvert je 
quantitative comparison graph models internet topology 
ieee acm transactions networking december 
ben zhao john kubiatowicz anthony joseph 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd uc berkeley april 
shelley zhuang ben zhao anthony joseph randy katz john kubiatowicz 
bayeux architecture scalable fault tolerant wide area data dissemination 
proceedings eleventh international workshop network operating system support digital audio video 
