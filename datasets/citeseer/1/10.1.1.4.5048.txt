cloning context sensitive pointer alias analysis binary decision diagrams john whaley monica lam computer science department stanford university stanford ca lam stanford edu presents scalable context sensitive pointer alias analysis java programs 
approach context sensitivity create clone method context interest run context insensitive algorithm expanded call graph get context sensitive results 
precision generate clone acyclic path program call graph treating methods strongly connected component single node 
normally formulation hopelessly intractable call graph acyclic paths 
show exponential relations computed efficiently binary decision diagrams bdds 
key scalability technique context numbering scheme exposes commonalities contexts 
applied algorithm popular applications available sourceforge largest programs hundreds thousands java bytecodes analyzed minutes 
shows pointer analysis queries algorithms described succinctly declaratively datalog logic programming language 
developed system called bddbddb automatically translates datalog programs highly efficient bdd implementations 
approach develop variety context sensitive algorithms including side effect analysis type analysis escape analysis 
categories subject descriptors programming languages processors compilers data data storage representations general terms algorithms performance design experimentation languages keywords context sensitive inclusion pointer analysis java scalable cloning binary decision diagrams program analysis datalog logic programming permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june washington dc usa 
copyright acm 

applications program analysis program optimization parallelization error detection program understanding need pointer alias information 
scalable pointer analyses developed date imprecise contextinsensitive unification 
contextinsensitive analysis distinguish different calling contexts method allows information caller propagate erroneously caller method 
unification approaches pointers assumed pointing set locations :10.1.1.11.3368
contrast inclusion approaches efficient expensive allow aliased pointers point overlapping different sets locations 
developed context sensitive inclusion pointer alias analysis scales hundreds thousands java bytecodes 
analysis field sensitive meaning tracks individual fields individual pointers 
analysis flow insensitive flow sensitivity analysis local pointers function 
results analysis show easily answer users queries build advanced analyses programming tools 
cloning achieve context sensitivity approach context sensitivity notion cloning 
cloning conceptually generates multiple instances method distinct calling context invokes different instance preventing information context flow 
cloning generating context sensitive results algorithmically trivial simply apply context insensitive algorithm cloned program obtain context sensitive results 
note analysis clone code se simply produces separate answer clone 
context method invocation distinguished call path simply call sites return addresses invocation call stack 
case recursive program unbounded number calling contexts 
limit number calling contexts shivers proposed concept cfa control flow analysis remembers call sites 
emami suggested distinguishing contexts full call paths acyclic 
cyclic paths suggested including call site recursive cycles :10.1.1.25.6013
approach uses entire call paths distinguish contexts programs recursion 
handle recursion call paths reduced eliminating invocations callers callees belong strongly connected component call graph 
reduced call paths identify contexts 
obvious project cloning approach feasible 
number reduced call paths program grows exponentially number methods cloning approach compute result contexts 
emami reported context sensitive points results small programs :10.1.1.25.6013
realistic programs contexts example application contexts see section 
size final results appears prohibitive 
show scale cloning points analysis representing context sensitive relations ordered binary decision diagrams bdds :10.1.1.1.5124
bdds originally designed hardware verification previously number program analyses points analysis :10.1.1.37.4968
show possible compute context sensitive pointsto results contexts 
contrast context sensitive pointer alias analyses developed date summary :10.1.1.22.4648:10.1.1.12.2189
parameterized summaries created method creating summaries callers 
necessary represent results exponentially contexts explicitly approach result context computed independently summaries 
answer queries simple variables point certain object require results computed 
readers may interested know despite effort tried succeed creating scalable summary algorithm bdds 
contributions contributions limited just algorithm computing context sensitive inclusion points information 
methodology specification language representation tools deriving pointer analysis applicable creating algorithms 
demonstrate approach create variety queries algorithms 
scalable cloning context sensitive points analysis bdds 
algorithm developed remarkably simple 
create cloned call graph clone created distinct calling context 
run simple contextinsensitive algorithm cloned call graph get contextsensitive results 
handle large number contexts representing bdds encoding scheme allows commonalities similar contexts exploited 
improve efficiency algorithm automatic tool searches effective variable ordering 
datalog high level language bdd program analyses 
writing program analyses directly terms bdd operations store program information results relations express analyses datalog logic programming language deductive databases 
datalog succinct declarative express points analyses algorithms simply intuitively just datalog rules 
datalog set operation semantics matches semantics bdd operations 
aid algorithm research developed deductive database system called bddbddb bdd deductive database automatically translates datalog programs bdd algorithms 
provide high level summary optimizations details scope 
experience programs generated bddbddb faster manually optimized counterparts 
importantly datalog programs orders magnitude easier write 
succinct easy understand explain algorithms directly 
experimental results reported obtained running bdd programs automatically generated bddbddb 
context sensitive queries analyses 
contextsensitive points results simple cloning approach context sensitivity bddbddb system easy write new analyses 
show representative examples categories 
simple queries 
results context sensitive pointer analysis provide wealth information interest programmers 
show lines datalog help programmers debug memory leak find potential security vulnerabilities 

algorithms context sensitive points results 
show context sensitive points results create advanced analyses 
include examples contextsensitive analysis compute side effects mod ref analysis refine declared types variables 

context sensitive algorithms 
cloning trivially generate kinds context sensitive results points relations 
illustrate contextsensitive type analysis context sensitive thread escape analysis 
previous escape analyses require thousands lines code implement algorithm datalog rules :10.1.1.12.2189
experimental results 
analysis time memory usage analyses popular java applications sourceforge 
context sensitive pointer analysis analyze largest programs minutes 
compare precision context insensitive pointer analysis context sensitive pointer analysis context sensitive type analysis show effects merging versus cloning contexts 
organization overview rest 
section explains methodology 
context insensitive pointsto algorithm example explain analysis expressed datalog briefly bddbddb translates datalog efficient bdd implementations 
section shows easily extend basic points algorithm discover call graphs fly adding datalog rules 
section presents cloning approach compute context sensitive points results 
section shows representative queries algorithms built points results cloning approach 
section presents experimental results 
report related section conclude section 
datalog bdds section start brief datalog 
show datalog describe contextinsensitive points analysis due high level 
describe bddbddb system translates datalog program efficient implementation bdds 
datalog represent program analysis results relations 
conceptually relation dimensional table 
columns attributes domain defining set possible attribute values 
rows tuples attributes share relation 
tuple relation say predicate true 
datalog program consists set rules written notation predicate defined conjunction predicates 
example datalog rule 
says true true 
variables predicates replaced constants surrounded double quotes don cares signified underscores 
predicates right side rules inverted 
datalog powerful sql relational calculus datalog predicates recursively defined 
predicates datalog program inverted guaranteed minimal solution consisting relations number tuples 
conversely programs inverted predicates may unique minimal solution 
bddbddb system accepts subclass datalog programs known stratified programs minimal solutions exist 
informally rules programs grouped strata unique minimal solution solved sequence 
context insensitive points analysis review context insensitive points analysis introducing datalog notation 
algorithm assumes call graph computed simple class hierarchy analysis available priori 
heap objects named allocation sites 
algorithm finds objects possibly pointed variable field heap objects program 
shown algorithm exact datalog program fed bddbddb implements algorithm 
keep example simple defer discussion types improve precision section 
algorithm 
context insensitive points analysis precomputed call graph 
domains variable map heap map field map relations input vp variable heap input store base field source input load base field dest input assign dest source output vp variable heap output hp base field target rules vp vp 
vp assign vp 
hp store vp vp 
vp load vp hp 
datalog program sections domains relations rules 
domain declaration name size optional file name provides name element domain internally represented ordinal number 
allows bddbddb communicate users meaningful names 
relation declaration optional keyword specifying input output relation name relation name domain attribute 
relation declared input output temporary relation generated analysis written 
rules follow standard datalog syntax 
rule numbers introduced sake exposition actual program 
express information intermediate representation program relations 
avoid readers definitions define relations 
domains relations algorithm domain variables 
represents allocation sites formal parameters return values thrown exceptions cast operations dereferences program 
special global variable accessing static variables 
domain heap objects 
heap objects named invocation sites object creation methods 
increase precision statically identify factory methods treat object creation methods 
domain field descriptors program 
field descriptors loading field storing field 
special field descriptor denote array access 
vp initial variable points relation extracted object allocation statements source program 
vp means invocation site assigns newly allocated object variable store represents store statements 
store says statement program 
load represents load statements 
load says statement program 
assign assignments relation due passing arguments return values 
assign means variable includes points set variable cover exceptions analogous manner 
vp output variable points relation 
vp means variable point heap object hp output heap points relation 
hp means field heap object point heap object note local variables assignments factored away flow sensitive analysis 
assign relation derived precomputed call graph 
sizes domains determined number variables heap objects field descriptors input program 
rule incorporates initial variable points relations vp rule finds transitive closure inclusion edges 
includes variable point object point rule models effect store instructions heap objects 
statement point point point rule resolves load instructions 
statement point point point applying rules results converge finds possible context insensitive points relations program 
improving points analysis types java type safe variables point objects assignable types 
similar subtype relation algorithm 
context insensitive points analysis type filtering 
domains domains algorithm plus type map relations relations algorithm plus input vt variable type input ht heap type input supertype subtype variable heap rules vt tv ht tv 
vp vp 
vp assign vp 
hp store vp vp 
vp load vp hp 
interfaces null values arrays 
dropping targets types assignments load statements eliminate impossible points relations result imprecision analysis 
adding type filtering algorithm simple datalog 
add new domain represent types new relations represent type declarations variables heap objects 
compute type filter modify rules algorithm filter unsafe assignments load operations 
domain type descriptors classes program 
vt represents declared types variables 
vt means variable declared type ht represents types objects created particular creation site 
java type created new instruction usually known statically 
ht means object created type relation assignable types 
means type assignable type type filter relation 
means type safe assign heap object variable rule algorithm defines relation typesafe assign heap object type variable type assignable th rules rules algorithm 
rules analogous rules additional constraint points relations match type filter inserted 
similarly perform type filtering stores heap objects 
stores go variables type filter catch extra case base object null constant 
type created object may known precisely example object returned native method reflection 
types modeled conservatively possible types 
translating datalog efficient bdd implementations describe datalog rules translated operators relational algebra join project show translate operations bdd operations 
query resolution find solution query stratum stratified query simply applying inference rules repeatedly output relations change 
apply datalog rule performing series relational natural join project rename operations 
natural join operation combines rows relations rows share value common attribute 
project operation removes attribute relation 
rename operation changes name attribute 
example application rule implemented rename vp variable source project join assign source vp vp rename dest variable rename attribute relation vp variable source joined relation assign create new points relation 
attribute dest resulting relation changed variable tuples added vp tuples accumulated far 
bddbddb system uses optimizations speed query resolution 
attributes naming 
names attributes match relations joined choice attribute names affect costs rename operations 
renaming cost highly sensitive relations implemented bddbddb system takes representation account minimizing renaming cost 
rule application order 
rule needs applied input relations changed 
bddbddb optimizes ordering rules analyzing dependences rules 
example rule algorithm depend rules applied query resolution 

need re apply rule combinations tuples seen 
technique known bdd literature semi nave fixpoint evaluation database literature 
system identifies loop invariant relations avoid unnecessary difference rename operations 
shown result repeated application rule vp repeat rename variable source project join assign source rename dest variable vp vp vp relational algebra bdd explain bdds implement relations relational operations 
bdds binary decision diagrams originally invented hardware verification efficiently store large number states share commonalities :10.1.1.1.5124
efficient representation boolean functions 
bdd directed acyclic graph dag single root node terminal nodes representing constants zero 
non terminal node dag represents input variable exactly outgoing edges high edge low edge 
high edge represents case input variable node true low outgoing edge represents case input variable false 
path dag root terminal node value function truth values input variables path value terminal node 
evaluate bdd specific input simply starts root node node follows high edge input variable true low edge input variable false 
value terminal node reach value bdd input 
variant bdds called ordered binary decision diagrams obdds :10.1.1.1.5124
ordered refers constraint paths graph variables respect linear order 
addition obdds maximally reduced meaning nodes variable name low high successors collapsed nodes identical low high successors bypassed 
commonalities paths leading terminals compact obdds 
accordingly amount sharing size representation depends greatly ordering variables 
bdds represent relations follows 
element element domain represented integer log bits 
relation 
dn represented boolean function 
dn 
dn iff 
dn 
dn iff 
dn 
number highly optimized bdd packages available operations provide directly implement relational operations efficiently 
example replace operation bdd semantics rename operation operation bdd finds natural join relations projects away common domains 
concrete example illustrate significance variable ordering 
suppose relation contains tuples 
relation contains tuples 

variable order bits attribute come bits second bdd need represent sequence 
separately relation 
bits second attribute come bdd share representation sequence 
unfortunately problem finding best variable ordering np complete 
bddbddb system automatically explores different alternatives empirically find effective ordering 

call graph discovery call graph generated class hierarchy analysis spurious call targets lead spurious pointsto relations 
get precise results creating call graph fly points relations 
algorithm generates points results identify receiver types methods invoked bind calls target methods call graph edges discovered find points relations 
algorithm converges new call targets new pointer relations 
modifying algorithm discover call graphs fly simple 
input assign relation computed call graph derive method invocation statements points relations 
algorithm 
context insensitive points analysis computes call graph fly 
domains domains algorithm plus invoke map name map method map relations relations algorithm modification assign computed relation plus input cha type name target input actual invoke param var input formal method param var input invoke target input mi method invoke output invoke target rules rules algorithm plus 
mi actual vp ht cha 
assign formal actual 
domain invocation sites program 
invocation site method invocation form 
pk 
note domain method names invocations 
invocation 
pk method name 
domain implemented methods program 
include interface methods 
domain numbering parameters 
cha encodes virtual method dispatch information class hierarchy 
cha means target dispatching method name type actual encodes actual parameters invocation sites 
actual means passed parameter number invocation site formal encodes formal parameters methods 
formal means formal parameter method represented variable initial invocation edges 
record invocation edges targets statically bound 
java calls static non virtual 
additionally local type analysis combined analysis class hierarchy allows determine calls single target 
means invocation site analyzed statically call method mi represents invocation sites 
mi means method contains invocation site virtual method name non virtual invocation sites special null method name appear cha relation 
output relation encoding invocation edges 
means invocation site calls method rules algorithm compute assign relation algorithm 
rules find invocation edges handling statically bound targets handling virtual calls 
rule matches invocation sites type pointer class hierarchy information find possible target methods 
invocation site method name invoked variable point type invoking type leads method possible target invocation rule handles parameter passing 
invocation site target method variable passed argument number formal parameter method points set includes points set return values handled likewise manner inclusion relation opposite direction 
see discovery variable pointsto vp create invocation edges turn create assignments assign points relations 
algorithm converges relations stabilize 

context sensitive points context insensitive monomorphic analysis produces just set results method regardless ways method may invoked 
leads imprecision information different calling contexts merged information calling context propagate calling contexts 
context sensitive polymorphic analysis avoids imprecision allowing different contexts different results 
context sensitive version context insensitive analysis follows 
clone method path call graph linking call site unique clone 
run original context insensitive analysis exploded call graph 
technique require exponential presence cycles potentially unbounded number clones created 
observed different contexts method similarities 
example parameters method types similar aliases 
observation led concept partial transfer functions ptf summaries input pattern created fly discovered :10.1.1.22.4648
ptfs notoriously difficult implement get correct programmer explicitly calculate input patterns manage summaries 
furthermore technique shown scale large programs 
approach allow exponential explosion occur rely underlying bdd representation find exploit commonalities contexts 
bdds express large sets redundant data efficient manner 
contexts identical information automatically shared data structure level 
furthermore bdds operate bit level exploit commonalities contexts different information 
bdd operations operate entire relations time tuple time 
cost bdd operations depends size shape bdd relations depends greatly variable ordering number tuples relation 
due caching bdd packages identical subproblems computed 
right variable ordering results contexts computed efficiently 
numbering call paths call path sequence invocation edges 
invocation site match thread objects corresponding run methods edges explicitly appear call graph 
example path numbering 
graph left original graph 
nodes cycle placed equivalence class 
edge marked path numbers source target edge 
graph right graph paths expanded 
call paths reduced call paths reaching reaching cd eh aeh dc beh cd afh dc fh bfh cd cgi agi dc gi contexts function example entry method typically main invocation site method mk 
programs recursion call path method defines context method 
handle recursive programs unbounded number call paths find strongly connected components sccs call graph 
eliminating method invocations caller callee belong scc call paths get finite set reduced call paths 
reduced call path scc defines context methods scc 
information different paths leading sccs kept separate methods scc invoked incoming call path analyzed 
example 
shows small call graph just methods set invocation edges 
invocation edge name source labeled context number caller sink context number callee 
numbers explained example 
methods belong strongly connected component invocations edges eliminated computation reduced call graphs 
infinitely call paths reaching method reduced call paths reaching shown 
clones reduced call path 
definition context sensitivity large programs contexts 
example pmd test programs methods contexts 
bdd representation give reduced call path reaching method distinct context entry methods typical programs static class initializers object thread run methods 
number 
important find context numbering scheme allows bdds share commonalities contexts 
algorithm shows scheme 
algorithm 
generating context sensitive invocation edges call graph 
input call multigraph 
output context sensitive invocation edges domain context numbers 
cm means invocation site context calls method context cm method 
method clones numbers 
nodes predecessors singleton context numbered 
find strongly connected components input call graph 
ith clone method calls ith clone method belonging component 

collapse methods strongly connected component single node get acyclic reduced graph 

node reduced graph topological order set counts contexts created 
incoming edge predecessor edge contexts create clones node add tuple example 
show results applying algorithm example 
root node context number 
shall visit invocation edges left right 
nodes members strongly connected component represented node 
strongly connected component reached edges context create clones reached edge 
method predecessor incoming edges contexts clones 
method clones clone invokes method clones clones method invoke clones clones method call clones respectively 
cloned graph shown 
numbering scheme algorithm plays strengths bdds 
method assigned contiguous range contexts represented efficiently bdds 
contexts callees computed simply adding constant contexts callers operation cheap bdds 
information contexts share common tail sequences similar numbering allows bdd data structure share effectively common contexts 
example sequentially numbered clones common tail sequence eh 
contexts similar bdd take advantage redundancies 
optimize creation cloned invocation graph defined new primitive creates bdd representation contiguous ranges numbers operations number bits domain 
essence algorithm creates bdd represent numbers upper bound represent numbers lower bound computes conjunction bdds 
context sensitive pointer analysis pre computed call graph ready context sensitive pointer analysis 
assume presence pre computed call graph created example context insensitive points analysis algorithm 
apply algorithm call graph generate context sensitive invocation edges created simply apply context insensitive points analysis exploded call graph get context sensitive results 
keep results separate clone adding context number methods variables invocation sites points relations algorithm 
context sensitive points analysis precomputed call graph 
domains domains algorithm plus relations relations algorithm plus input caller invoke callee tgt assign dest src output vp context variable heap rules vt ht 
vp vp 
vp assign vp 
hp store vp vp 
vp load vp hp 
assign formal actual 
domain context numbers 
bdd library uses signed bit integers represent domains size limited set context sensitive invocation edges 
cm means invocation site context calls method context cm relation computed algorithm 
assign context sensitive version assign relation 
assign means variable context includes points set variable context due parameter passing 
return values handled analogously 
vp context sensitive version variable points relation vp 
vp means variable context point heap object rule interprets context sensitive invocation edges find bindings actual formal parameters 
rest rules context sensitive counterparts algorithm 
algorithm takes advantage pre computed call graph create efficient context numbering scheme contexts 
compute call graph fly enjoying benefit numbering scheme numbering possible contexts conservative call graph delaying generation invocation edges warranted points results 
reduce iterations necessary exploiting fact invocation sites call graph created context insensitive analysis single targets 
algorithm execution time similar algorithm primarily academic interest call graph rarely improves due extra precision contextsensitive points information 

queries analyses algorithms sections generate vast amounts results form relations 
declarative programming interface conveniently query results extract exactly information interested 
section shows variety queries analyses pointer information context sensitivity 
debugging memory leak memory leaks occur java object remains longer 
common approach debugging memory leaks dynamic tool locates allocation sites memory consuming objects 
suppose reviewing information programmer thinks objects allocated line file java freed 
may wish know objects may holding pointers leaked objects operations may stored pointers 
consult static analysis results supplying queries hp java 
store vp java 
query finds objects fields may point objects allocated java second finds store instructions contexts executed create 
finding security vulnerability java cryptography extension library cryptographic algorithms 
misuse api lead security vulnerabilities false sense security 
example operations secret key supplied programmer 
important secret keys cleared recovered attackers access memory 
string objects immutable cleared secret keys stored string objects array characters bytes 
guard misuse function accepts secret key init allows arrays characters bytes input 
programmer versed security issues may stored key string object routine string class convert array characters 
write query audit programs presence idioms 
input relation specifying variable return value method define relation indicates object directly derived string 
specifically records objects returned call method string class 
invocation method init vulnerability argument points object derived string 
cha string vp 
init actual vp 
notice query find cases object derived string immediately supplied init 
query identify cases object passed variables heap objects 
type refinement libraries written handle general types objects possible full generality typically applications 
analyzing actual types objects application refine types variables object fields 
type refinement reduce overheads cast operations resolve virtual method calls gain better understanding program 
say variable legally declared written supertype types objects point 
type variable refinable variable declared precise type 
compute super types find types objects pointed intersect supertypes exact types get desired solution datalog finding complement union complement exact types 
vp ht 
tv tv 

refinable vt td tc td tc shows context insensitive type refinement query 
find variable type refined regardless context 
result context insensitive precise take advantage context sensitive points results available determine exact types shown rule 
section compare accuracy context insensitive query context sensitive version 
context sensitive mod ref analysis mod ref analysis determine fields objects may modified referenced statement call site 
context sensitive points results solve contextsensitive version query 
define mv mean local variable mv relation specifies set variables contexts methods transitively reachable method 
mv means calling method context transitively call method local variable context mv mv 
mv mi mv 
rule simply says method context reach local variable 
second rule says method context calls method context context reach variables reached method context define mod ref set method follows mod mv cv store vp cv 
ref mv cv load vp cv 
rule says method context reach variable context cv store variable field object context modify field object second rule defining ref relations analogous 
context sensitive type analysis cloning technique applied add context sensitivity context insensitive algorithms 
example show type inference variables fields 
distinguishing instances heap objects analysis generate results precise extracted running complete context sensitive pointer analysis discussed section faster 
basic type analysis similar cfa 
variable field program set concrete types refer 
sets propagated calls returns loads stores 
path numbering scheme algorithm convert basic analysis context sensitive essence making analysis cfa analysis depth call graph recursive cycles collapsed 
algorithm 
context sensitive type analysis 
domains domains algorithm relations relations algorithm plus output vt context variable type output ft field target variable type rules vt 
vt vp ht vt cv assign cv cv vt cv 
ft store vt 
vt load ft 
assign formal actual 
vt context sensitive variable type relation 
vt means variable context cv refer object type analogue vp pointsto analysis 
ft field type relation 
ft means field point object type type filter relation 
means type safe assign object type variable rule initializes vt relation initial local points information contained vp combining ht get type get context numbers 
rule transitive closure vt relation filtering enforce type safety 
rules handle stores loads respectively 
differ counterparts pointer analysis base object field 
rule models effects parameter passing context sensitive manner 
thread escape analysis example thread escape analysis determines objects created thread may 
results analysis optimizations synchronization elimination allocating objects thread local heaps understanding programs checking possible race conditions due missing synchronizations :10.1.1.12.2189
example illustrates vary context sensitivity fit needs analysis 
say object allocated thread escaped may accessed thread 
notion stronger formulations object said escape reached thread :10.1.1.12.2189
java threads subclasses java lang thread identified creation sites 
special case thread creation execute thread simply named creation site 
thread exists virtual machine startup example thread created 
creation site reached different call paths embedded loops recursive cycles may generate multiple threads 
distinguish thread instances created site create thread contexts represent separate thread instances 
object created instance accessed clone accessed instances created call site 
scheme creates twice contexts thread creation sites 
clone thread run method thread context place clones list entry methods analyzed 
methods transitively invoked context run method inherit context 
clone method cloned variables cloned object creation sites 
way objects created separate threads distinct 
run points analysis slightly expanded call graph object created thread context escapes accessed variables thread context 
algorithm 
thread sensitive pointer analysis 
domains domains algorithm relations relations algorithm plus input heap input vp cv variable ch heap output vp cv variable ch heap output hp cb base field ct target rules vt tv ht tv 
vp vp 
vp vp 
vp ch assign vp ch 
hp store vp vp 
vp load vp hp 
encodes non thread objects created thread 
means thread context may execute allocation site words call path run method context allocation site vp set initial inter thread points relations 
includes points relations thread creation sites global object 
vp means thread thread allocation site points newly created thread context 
usually contexts assigned allocation site 
global objects contexts context 
vp thread sensitive version variable points relation vp vp means variable context point heap object created context hp thread sensitive version heap points relation hp hp means field heap object created context point heap object created context rule incorporates initial points relations thread creation sites 
rule incorporates points information non thread creation sites context numbers threads reach method 
rules analogous context sensitive pointer analysis additional context attribute heap objects 
analysis results easily determine objects escaped 
object created thread context escaped written escaped accessed different context cv complications involving unknown code native methods handled technique 
escaped vp cv cv conversely object created context captured written captured escaped 
captured object allocated thread local heap 
captured vp escaped 
escape analysis eliminate unnecessary synchronizations 
define relation syncs indicating program contains synchronization operation performed variable synchronization variable context necessary written syncs point escaped object 
syncs vp ch escaped ch notice context sensitive 
distinguish synchronization necessary certain threads generate specialized versions methods threads 

experimental results section experimental results bddbddb datalog algorithms 
describe testing methodology benchmarks analysis times evaluate results analyses provide insight experience developing analyses bddbddb tool 
methodology input bddbddb datalog programs exactly 
added rules handle return values threads added annotations physical domain assignments input relations 
input relations generated compiler infrastructure 
entire bddbddb implementation lines code 
bddbddb uses library open source library buddy library 
entire system available opensource hope find useful 
experiments performed ghz pentium sun jdk running linux core 
contextinsensitive context sensitive experiments respectively initial bdd table sizes tables grow garbage collection bdd operation cache sizes 
test scalability applicability algorithm applied technique popular java projects sourceforge november 
simply walked list java projects sorted activity selecting ones compile directly standalone applications 
real applications tens thousands users 
far know largest benchmarks reported context sensitive java pointer analysis 
point comparison largest benchmark specjvm suite javac rank th list 
application chose applicable main method entry point application 
included class initializers thread run methods 
ignored null constants analysis points set automatically assumed include null 
exception objects type merged 
treated reflection native methods returning unknown objects 
native methods special fields modeled explicitly 
short description benchmarks included vital statistics 
number classes methods bytecodes discovered context insensitive fly call graph construction algorithm include reachable parts program class library 
number context sensitive paths part correlated number methods program exception pmd 
pmd paths call graph requires bits represent 
pmd different characteristics contains code generated parser generator javacc 
machine generated methods call class library routines leading particularly exponential blowup 
library supports physical domains bits contexts numbered merged single context 
large number paths caused algorithm require rule applications reach fixpoint solution 
analysis times measured analysis times memory usage algorithms 
algorithm call graph discovery iteration computes call graph points relations previous iteration 
number iterations taken algorithm included 
timings reported wall clock times cold start include various overheads java garbage collection bdd garbage collection growing node table memory numbers reported sizes peak number live bdd nodes course algorithm 
measured peak bdd memory usage setting initial table size maximum table size increase mb allowed table grow node table full garbage collection 
avoid garbage collections recommended memory 
timing runs default setting 
name description classes methods bytecodes vars paths speech synthesis system scalable distributed chat client server servlet container java workflow engine java neural net framework jboss ee application server ee ssh daemon pmd java source code analyzer azureus java bittorrent client freenet anonymous peer peer file sharing system ssh terminal mathematical graph theory objects algorithms uml class diagrams java code auction site bidding tracking tool graphical email client gantt plan projects gantt charts ldap browser jedit programmer text editor networked game graphical cvs client information benchmarks test analyses 
context insensitive analyses algorithms remarkably fast type filtering version able complete seconds benchmarks 
interesting notice introducing type filtering improved analysis time memory usage 
accurate points sets smaller type filtered version leading faster analysis times 
algorithm call graph discovery took iterations complete effective reducing size call graph compared cha 
complexity call graph discovery algorithm vary number virtual call sites need resolving jedit methods declared final leading call targets resolve longer analysis times 
analysis times memory usages context sensitive points analysis algorithm reasonable 
analyze small medium size benchmarks minutes successfully finishes analyzing largest benchmarks minutes 
remarkable considering context sensitive formulation solving times relations context insensitive version 
scheme numbering contexts consecutively allows bdd efficiently represent similarities calling contexts 
analysis times directly correlated number paths call graph 
experimental data appears analysis time context sensitive algorithm scales approximately lg number paths call graph experiments necessary determine trend persists programs 
context sensitive type analysis algorithm expected quite bit faster memory intensive contextsensitive points analysis 
uses number contexts order magnitude faster context sensitive points analysis 
type analysis number objects pointed smaller greatly increases sharing bdd 
thread sensitive pointer analysis algorithm analysis times memory usages roughly comparable context insensitive pointer analysis includes thread context information 
number thread creation sites relatively small contexts thread 
evaluation results depth analysis accuracy analyses respect queries section scope 
show results specific queries thread escape analysis section type refinement section 
results escape analysis shown 
columns give number captured escaped object creation sites respectively 
columns give number unneeded needed synchronization operations 
singlethreaded benchmarks escaped object global object static variables accessed 
multi threaded benchmarks analysis effective finding allocation sites captured synchronization operations unnecessary 
static numbers fully evaluate results require dynamic execution counts outside scope 
results type refinement query shown 
tested query different analysis variations 
left right context insensitive pointer analysis type filtering context sensitive pointer analysis context sensitive type analysis context projected away context sensitive pointer type analysis fully cloned graph 
projecting away context context sensitive analysis result context insensitive precise context insensitive analysis extra precision intermediate steps analysis 
measured percentages variables point multiple types variables types refined 
including type filtering algorithm strictly precise 
likewise context sensitive pointer analysis strictly precise context insensitive pointer analysis context sensitive type analysis 
see trend results 
precision increases percentage multi typed variables drops percentage refinable variables increases 
context insensitive pointer analysis context sensitive type analysis directly comparable cases point context insensitive pointers context sensitive thread sensitive name type filter type filter cg discovery pointer analysis type analysis pointer analysis time mem time mem iter time mem time mem time mem time mem jboss pmd azureus freenet gantt jedit analysis times peak memory usages benchmarks analyses 
time seconds memory megabytes 
ers precise cases context sensitive types precise 
project away context context sensitive results remarkably precise percentage multi typed variables greater pointer analysis type analysis 
projecting away context loses benefit context sensitivity noticeably precise context insensitive analysis 
heap objects sync operations name captured escaped needed needed jboss pmd azureus freenet gantt jedit results escape analysis 
experience experimental results reported generated bddbddb 
early stages research hand coded points analysis bdd operations directly spent considerable amount time tuning performance 
scheme reason analysis finish small programs 
optimizations described section carried manually 
considerable effort took hours analyze complete 
difficult get correct subtle bug months implementation completed 
outermost loops tedious error prone 
difficult experiment different rule application orders 
get better performance importantly easier develop new queries analyses created bddbddb 
automated extended optimizations manual implementation implemented new ones empirically choose best bdd library parameters 
result code generated bddbddb outperforms manually tuned context sensitive pointer analysis order magnitude 
better bddbddb quickly develop new analyses highly efficient type analysis section thread escape analysis section 
related describes scalable cloning points analysis context sensitive field sensitive inclusion implemented bdds 
program analyses expressed datalog translated bddbddb bdd implementation automatically 
example queries system check vulnerabilities infer types find objects escape thread 
due space constraints describe closely related 
scalable pointer analyses 
scalable algorithms proposed context insensitive flow insensitive 
scalable pointer analysis proposed unification algorithm due steensgaard :10.1.1.11.3368
das extended unification approach include level flow level context sensitivity 
subsequently number inclusion algorithms shown scale large programs 
number context sensitive flow insensitive analyses developed 
pointer analysis due context insensitive pointers projected context sensitive context sensitive name type filter type filter pointer analysis type analysis pointer analysis type analysis multi refine multi refine multi refine multi refine multi refine multi refine jboss pmd azureus freenet gantt jedit results type refinement query 
numbers percentages 
columns labeled multi refine refer multi type variables refinable type variables respectively 
fahndrich demonstrated line gcc program 
algorithm unification field independent meaning fields structure modeled having location 
context sensitive analysis discovers targets function pointers fly 
algorithm computes call graph context insensitive pointer alias analysis significantly indirect calls java programs target technique due virtual method invocations 
algorithm uses cfl reachability queries implement context sensitivity 
computing context sensitive solutions demand compute context sensitive results represent form convenient analysis 
context sensitive pointer analysis 
earlier attempts context sensitive analysis flow sensitive 
analysis similar emami compute context sensitive points results directly different contexts 
analysis flow sensitive uses flow sensitivity summarizing method 
technique treats members strongly connected component call graph unit technique ignores subsequent invocations recursive cycles 
hand technique demonstrated programs lines 
discussed section summaries common approach context sensitivity 
difficult compute compact summary fully flow sensitive result desired 
solution concept partial transfer functions create summaries observed calling contexts :10.1.1.22.4648
summary reused multiple contexts share relevant alias patterns 
technique shown handle programs lines 
solution allow weak updates write variable adds value contents variable removing previously held value :10.1.1.12.2189
greatly reduces power flow sensitive analysis 
approach handle programs lines code 
larger programs representation large deal 
goal prior escape analysis necessary maintain precise points relations locations escape algorithm achieved scalability collapsing escaped nodes 
bdd pointer analysis 
bdds number program analyses predicate abstraction shape analysis particular points analysis 
zhu proposed summary context sensitive points analysis programs reported preliminary experimental results programs lines 
showed bdds compute context insensitive points results large java programs efficiently 
conference zhu describe cloning context sensitive analysis pointers assuming safe subset 
largest program reported experiment lines contexts 
high level languages tools program analysis 
datalog logic programming languages previously proposed describing program analyses 
bddbddb system implements datalog bdds compute context sensitive points results advanced analyses 
examples systems translate program analyses queries written logic programming languages implementations bdds include crocopat 
java language extension provides relational algebra abstraction bdds 

shows bdds possible obtain efficient implementations context sensitive analyses extremely simple technique clone methods call graph context interest simply apply context insensitive analysis cloned graph get context sensitive results 
numbering similar contexts contiguously bdd able handle exponential blowup contexts exploiting commonalities 
showed approach applied type inference thread escape analysis fully context sensitive pointsto analysis large programs 
shows create efficient bdd analyses easily 
keeping data analysis results relations express queries analyses terms datalog 
bddbddb system developed automatically converts datalog programs bdd implementations efficient hand tuned 
context sensitive pointer analysis cornerstone deep program analysis modern programming languages 
combining context sensitive points results simple approach context sensitivity simple logic programming query framework believe easier create advanced program analyses 
acknowledgments material supported national science foundation nsf graduate student fellowship 
anonymous referees helpful comments 

ramamohanarao 
generalization differential approach recursive query optimization 
journal logic programming sept 
ball rajamani 
symbolic model checker boolean programs 
proceedings spin workshop model checking software pages aug 
qian hendren 
points analysis bdds 
proceedings sigplan conference programming language design implementation pages june 
beyer lewerentz 
simple efficient relational querying software structures 
proceedings th ieee working conference reverse engineering nov 
wegener 
improving variable ordering obdds np complete 
ieee transactions computers sept 
bryant :10.1.1.1.5124
graph algorithms boolean function manipulation 
ieee transactions computers aug 
chandra harel 
horn clauses generalizations 
journal logic programming 

choi gupta serrano sreedhar midkiff 
escape analysis java 
proceedings conference object oriented programming systems languages applications pages nov 

charlier 
efficient bottom interpretation prolog means constraint solving symbolic finite domains 
proceedings international symposium programming language implementation logic programming pages aug 
das 
unification pointer analysis directional assignments 
proceedings sigplan conference programming language design implementation pages june 
das ahndrich rehof 
estimating impact scalable pointer analysis optimization 
proceedings th international static analysis symposium pages july 
dawson ramakrishnan warren 
practical program analysis general purpose logic programming systems case study 
proceedings sigplan conference programming language design implementation pages may 
dean grove chambers 
optimization object oriented programs static class hierarchy analysis 
proceedings th european conference object oriented programming pages aug 
emami ghiya hendren :10.1.1.25.6013
context sensitive interprocedural points analysis presence function pointers 
proceedings sigplan conference programming language design implementation pages june 
ahndrich rehof das 
scalable context sensitive flow analysis instantiation constraints 
proceedings sigplan conference programming language design implementation pages june 
foster fahndrich aiken 
polymorphic versus monomorphic flow insensitive points analysis proceedings th international static analysis symposium pages apr 
heintze 
ultra fast aliasing analysis cla lines code second 
proceedings sigplan conference programming language design implementation pages june 
landi ryder zhang 
interprocedural modification side effect analysis pointer aliasing 
proceedings sigplan conference programming language design implementation pages june 
ak hendren 
scaling java points analysis spark 
proceedings th international conference compiler construction pages april 
hendren 
bdd relational extension java 
proceedings sigplan conference programming language design implementation june 
lind nielsen 
buddy binary decision diagram package 
www itu dk research buddy 
lindholm yellin 
java virtual machine specification 
addison wesley nd edition 
ramalingam field goyal sagiv 
compactly representing order structures static analysis 
proceedings th international static analysis symposium pages sept 
reps horwitz sagiv 
precise interprocedural dataflow analysis graph reachability 
proceedings th annual symposium principles programming languages pages jan 
reps demand interprocedural program analysis logic databases pages 
kluwer 
shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon university may 
somenzi 
cu decision diagram package release 
steensgaard :10.1.1.11.3368
points analysis linear time 
symposium principles programming languages pages jan 
java cryptography extension 
java sun com products 
ullman 
principles database knowledge base systems 
computer science press rockville md volume ii edition 
whaley 
library 
sourceforge net 
whaley 
virtual machine compiler infrastructure 
proceedings sigplan workshop interpreters virtual machines emulators pages june 
whaley lam 
efficient inclusion points analysis strictly typed languages 
proceedings th international static analysis symposium pages sept 
whaley rinard :10.1.1.12.2189
compositional pointer escape analysis java programs 
conference object oriented programming systems languages applications pages nov 
whaley lam 
bdd deductive database program analysis 
suif stanford edu bddbddb 
wilson 
efficient context sensitive pointer analysis programs 
phd thesis stanford university dec 
wilson lam 
efficient context sensitive pointer analysis programs 
proceedings sigplan conference programming language design implementation pages june 

automated verification concurrent linked lists counters 
proceedings th international static analysis symposium pages sept 
zhu 
symbolic pointer analysis 
proceedings international conference computer aided design pages nov 
zhu 
symbolic pointer analysis revisited 
proceedings sigplan conference programming language design implementation june 
