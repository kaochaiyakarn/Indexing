epidemic style proactive aggregation large overlay networks rk jelasity university bologna italy jelasity cs unibo aggregation computation global properties average maximal load number nodes important basic functionality fully distributed environments 
cases include protocols responsible self organization large scale systems collaborative environments useful nodes know value aggregates continuously 
analyze novel protocols capable providing service 
proposed anti entropy aggregation protocols compute different aggregates component properties extremal values average counting 
protocols inspired anti entropy epidemic protocol random pairs databases periodically resolve differences 
case aggregation resolving difference generalized arbitrary numeric computation states communicating peers 
advantage approach proactive democratic means performance bottlenecks approximation aggregates continuously nodes 
properties protocol suitable implementing collective decision making automatic system maintenance global information fully distributed fashion 
main contribution provide fundamental theoretical results proposed averaging protocol 

latest generation peer peer networks typically self organizing fully distributed systems 
traditional distributed systems central authority controls various components 
dynamically changing overlay network maintained nodes appear disappear continuously dynamic cooperation links nodes created removed requirements particular application 
systems attractive reasons lack single points failure potential scale proc 
icdcs pp 

mta hungary alberto montresor university bologna italy cs unibo millions nodes resulting distributed computing platforms 
fully distributed platforms certain drawbacks 
control monitoring difficult performing computations poses challenge orchestrating potentially huge number participating nodes 
useful functional building block emerged aggregation 
aggregation collective name functions provide global information system extremal values property average counts aggregation provide users participants network important information number nodes connected network identity powerful peer grid total amount free space distributed storage 
cases useful nodes knew value aggregate continuously adaptive fashion 
adaptivity means aggregate changes due network dynamism variations values aggregated output aggregation protocol follow change reasonably quickly 
potential beneficiaries efficient implementation functionality include protocols responsible self organization large scale systems collaborative environments 
motivation offer efficient robust solution problem 

anti entropy aggregation approach modified generalized anti entropy protocol 
assume node ni network non empty set neighbors numeric attribute value ai 
aggregation performed set values 
node ni stores approximation xi aggregate 
core algorithm run node shown 
algorithm subject theoretical analysis 
functions ag determine dynamics system neighbor set defines overlay topology 
stated returns constant parameter protocol shall call cycle length real cycles system node au active process protocol node ni forever wait nj perform elementary aggregation step send xi nj receive xj nj xi aggregate xi xj reply node nj xi ni send xj ni xj aggregate xj xi 
skeleton anti entropy aggregation protocol run nodes 
active process shown node ni passive reply node nj activated active process sending approximation xi 

section introduce randomized versions interesting theoretical point view 
function aggregate implement desired aggregation function 
example finding maximum implemented aggregate max returns maximum parameters 
discuss algorithm behavior protocol point view spreading true maximum identical push pull epidemic broadcast studied 
interesting point application 
focus aggregate avg returns average parameters 
able calculate average possible calculate moments averages different powers value set size system sum value set simplistic presentation protocol assume synchronized starting time time nodes xi ai 
cycle protocol lasts time point integer expected return value 
section analyze version protocol 

related epidemic protocols epidemic protocols popular publication seminal demers 
completed survey eugster provides excellent field 
epidemic algorithms applied solving practical problems database replication failure detection resource monitoring 
large body theoretical available due general importance understanding epidemics close relation random graph theory 
introduce new epidemic protocols 
show apply anti entropy known epidemic protocol aggregation problem 
resulting solution efficient enables network nodes collectively find aggregates way nodes know value aggregate adaptive fashion 
aggregation distributed environments field distributed computation aggregates established epidemic protocols 
overview problem 
prominent approach astrolabe hierarchical architecture aggregation large distributed systems 
anti entropy aggregation substantially different extremely simple lightweight targeted unstructured highly dynamic environments 
case protocol overhead implementation maintenance diminishing 
related approach hierarchical approach 
building hierarchies reduces cost finding aggregates introduces additional overhead having maintain hierarchical topology dynamic distributed environment 
due hierarchical needs extra effort protocols broadcast result continuously network nodes need know result continuously 
discusses approaches spanning tree induction redundant topologies 
main difference approach protocols described reactive aggregation initialized certain point result known node 
hard adopt solving research problem similarly approaches mentioned 
membership management area relevant help put results right context 
anti entropy aggregation protocol assumes node neighbor set set nodes network potentially communicate 
protocol address issue maintenance sets 
membership management protocol 
focus random networks important mention membership protocols maintain approximately random topology 

contribution light related contribution summarized follows proposing anti entropy aggregation efficient simple lightweight protocol solving proactive aggregation problem sketched ii theoretical analysis anti entropy averaging includes giving exponential convergence rates versions protocol 

outline section summarize assumptions adopt discussion 
section focus speed convergence approximations true average 
give explicit convergence rates hold slightly different assumptions 
particular show convergence exponentially fast 
discuss effects node failures message loss 
experimental validation 
section contains illustrative example application protocol network size estimation 

system model consider network large collection nodes communicate exchange messages assigned unique identifier 
assume nodes connected existing physical network 
protocols suggest deployed arbitrary physical networks including sensor ad hoc networks consider fully connected networks internet node potentially communicate node 
physical network provides possibility communication 
communicate node know identifiers set nodes neighbors 
neighborhood relation nodes defines topology overlay network 
theoretical analysis assumes node access hardware clock drift common point known time 
assume communication takes zero time 
assumptions strong offer solutions practical aspects protocol relaxing synchronization assumption introducing mechanisms adaptivity fault tolerance 
section contains illustrative example points direction 

theoretical analysis introducing conceptual framework notations purpose mathematical analysis 
proceed proving convergence rates various algorithms 
results validated illustrated numerical simulation necessary 
vector input times getpair perform elementary variance reduction step ai aj ai aj return 
skeleton algorithm avg 

basic concepts notations purpose mathematical analysis translate networking terminology mathematical structures concepts 
treat anti entropy averaging iterative variance reduction algorithm vector numbers 
framework formulate approach follows 
initial vector numbers 

shall model vector assuming 
independent random variables identical expected values finite variance 
assumption identical expected values strong 
protocol sensitive ordering values permutation initial values statistical behavior remains 
starting random variables 
arbitrary expected values random permutation new value index bi distribution bi aj 
obtain equivalent probability model distribution random variables 
bn identical 
note case assumption independence violated case large networks insignificant extent 
considering network cycle anti entropy averaging looked algorithm call avg takes vector parameter produces new vector length 
furthermore consecutive cycles protocol result series vectors 
ai avg ai 
elements vector ai denoted ai ai 
ai shows algorithm avg takes parameter modifies place producing new vector 
note practical aspects overlay topology synchronization lack eventual node failures modeled properties constraints function getpair 
example node neighborhood node pair returned 
node reachable pairs containing returned 
distributed local nature epidemic protocol underlying model expressed constraint returned pair determined affected global property value vector maximum values instance 

convergence introduce notations empirical statistics ai ai ai ai ai linear operations performed vector elements loss generality assume common expected value elements zero 
purpose choice merely simplify expressions 
particular vector elements independent random variables zero expected value 
furthermore elementary variance reduction step selected elements replaced average change sum elements vector ai cycles 
property important guarantees algorithm introduce errors approximation 
means focus variance 
clearly expected value tends zero tending infinity variance vector elements tend zero correct average approximated locally arbitrary accuracy node 
analysis convergence variance fundamental observations 
lemma 
vector get replacing ai aj ai aj vector contains uncorrelated random variables expected value expected value resulting variance reduction 
proof 
simple calculation fact ai aj uncorrelated ai aj 
considering intuitive interpretation lemma elementary variance reduction step participating nodes contribute approximately half original contribution expected variance provided uncorrelated 
extreme case maximal correlation ai aj variance reduction zero 
seen assumption crucial 
having observation mind con sider average vector values si 
defined follows 
initial vector 
si produced parallel ai pair returned getpair performing elementary averaging step see perform step si sj si sj 
way lemma si emulate evolution high accuracy provided pair values ai aj selected call getpair practically uncorrelated 
intuitively assumption expected hold original values uncorrelated getpair random introduce significant correlations 
working si easier mathematical sense time capture dynamics system high accuracy confirmed empirical simulations 
simplified model turn theorem basis results specific implementations getpair 
define random variable number times index selected member pair returned getpair algorithm avg calculation ai input ai 
networking terms number peer communications node involved cycle theorem 
assume getpair properties 

random variables 
identically distributed 
denote random variable common distribution 

returned getpair number times selected remaining calls get pair identical distribution 
si si proof 
sketch proof 
basic idea thinking value si quantity material 
definition si time selected getpair loose half material remaining material divided locations 
assumption observe matter piece original material ends chance loosing half proportion stays original location 
means original material lose half times average expected number selection getpair term si si 
applying summing terms proof 
theorem allow concentrate 
arguments role si expect true 

case studies section give explicit convergence rates specific implementations getpair 
cases assumed overlay topology complete graph random neighbor selected considered sampling set nodes 
note node uses limited number random neighbors results hold random graphs connected sufficient number normally small constant number random edges node 
type graph unrealistic fully connected scalable robust protocols available approximate random structure 

perfect matching optimal strategy artificial example represents optimal implementation getpair 
call implementation getpair pm pm stands perfect matching 
unfortunately implementation mapped efficient distributed protocol requires global knowledge system 
interesting fact optimal assumptions theorem serve comparison practical approaches 
getpair pm works follows 
call pairs created assume way index exactly pair 
words perfect matching overlay topology created 
subsequently pairs returned exactly 
pairs run th call perfect matching created contains pairs perfect matching pairs returned second calls 
assumption pair values ai connected edge overlay topology uncorrelated easily construct non overlapping perfect matchings define uncorrelated pairs 
verify assumptions theorem algorithm clearly value index blind ii selection index guaranteed selected exactly 
apply theorem getpair pm 
convergence rate 
prove optimality convergence rate assumptions theorem 
lemma 
random variable expected value minimal 
proof 
proof straightforward technical sketch 
shown distribution different decrease value transforming distribution new satisfies constraint 
basic observation 
technically verified reduce increasing amount way holds decrease 

random selection moving practical implementations get pair example getpair rand works simply choosing random edge underlying overlay topology picking edge probability 
getpair rand easily implemented distributed protocol 
iterating alg waiting time selection node described exponential distribution 
distributed implementation node approximate behavior waiting time interval randomly drawn distribution initiating communication 
see getpair rand efficient pair selector serves stepping stone analysis practical protocol 
getpair pm assumptions theorem hold algorithm clearly value index blind ii exactly probability selected elementary variance reduction step 
strict guarantee correlated pairs returned 
due randomness algorithm fully connected random respectively overlay topology expect observe negligible correlation 
get convergence rate distribution approximated poisson distribution parameter 

substituting expression get 


comparing performance getpair rand getpair pm see convergence significantly slower optimal case rates vs 
ran avg getpair rand network sizes fully connected topology random topology fixed view size 
results shown 
see convergence independent network size theory predicts observed convergence rate high accuracy case fully connected topology 
expected case random regular graph observe slightly slower convergence due violation constraints theorem difference insignificant 
reveals difference significant iteration avg 
possible reason correlation accumulates cycles due limited amount neighborhood information available 

practical protocol building results far possible analyze practically relevant version protocol assuming fully connected random overlay topology 
implementation pair selection iterate node set fixed order picking random neighbor node generating pair 
call algorithm getpair seq 
algorithm implemented distributed protocol easily 
node pick neighbor periodically regular intervals perform variance reduction step neighbor 
see protocol implementable distributed way performance superior getpair rand reaching getpair pm 
unfortunately getpair seq satisfy assumption theorem 
therefor apply trick framework applicable 
note getpair seq poisson distribution parameter 
introduce implementation getpair seq distribution 
new implementation called getpair combines getpair pm getpair rand cycle 
calls getpair behaves getpair pm remaining calls behaves getpair rand 
obviously getpair calling frequency node 
argumentation connection getpair pm getpair rand apply theorem getpair 
distribution approximated poisson distribution parameter 

substituting expression get 


comparing performance getpair rand getpair pm see convergence slower optimal case faster random case rates respectively 
saw experimental analysis getpair rand theorem considered extremely accurate approximation case get pair pm convergence theorem exact 
means assumption remains validated experimentally substitution getpair seq get pair 
ran avg getpair seq network sizes fully connected topology random topology fixed view size 
similarly getpair rand see convergence independent network size 
interesting topologies result slightly better convergence predicted 
effect due fact derive convergence rate getpair getpair seq 
notice observable difference random fully connected topologies 
difference significant iterating avg shows just case get pair rand 
probably due regular nature getpair seq sensitive accumulation correlation tolerates random topology better 

example network size estimation offer solutions practical aspects protocol relaxing synchronization assumption introducing mechanisms adaptivity fault tolerance 
section contains illustrative example points direction 
allow protocol adaptive need extend anti entropy aggregation restarting mechanism 
solve problem termination 
solution variance reduction getpair rand complete getpair rand reg 
random getpair seq complete getpair seq reg 
random network size average variance reduction execution avg vector uncorrelated values 
variance reduction getpair rand complete getpair rand reg 
random getpair seq complete getpair seq reg 
random cycle average variance reduction network size iterating algorithm avg 

simulation results network sizes fully connected topology random topology fixed view size 
values averages independent runs 
dotted lines show theoretically predicted reduction rates 
adopt node executes protocol predefined number cycles depending required accuracy output see convergence rates section 
protocol truly adaptive divide execution aggregation protocol consecutive epochs length start new instance protocol epoch 
depending ratio possible different epochs protocol executed concurrently network 
messages exchanged particular epoch tagged unique identifiers obtained monotone counter maintained node 
node joins network contacts nodes participating aggregation protocol 
assume existence band mechanism discover nodes 
existing node provides new node epoch identifier amount time left run starts 
node start actively participate aggregation protocol specified units time measured local clock tagging messages suggested identifier 
additionally avoid drift node receives message identifier larger current switches new epoch immediately 
solution sufficient way new epoch start spreads epidemic broadcast exponentially fast 
example application network size estimation 
base protocol observation exactly values stored nodes equal equal average exactly calculated directly 
implement idea enabling multiple nodes start concurrent instances averaging protocol 
concurrent instance lead different node 
messages data related instance tagged unique identifier address leader 
leader initialize approximation rest nodes reached instance start behave initial value 
bound number instances running concurrently allow node leader epoch sufficiently small probability depend previous approximation network size 
simulations reported 
new epoch started cycles 
values reported actual size network observed estimate 
converged estimates reported epoch 
error bars show range estimates obtained nodes participated full epoch 
behavior network follows size oscillates 
addition nodes added removed nodes removed network nodes added simulate fluctuation 
nodes join network allowed participate current epoch described earlier 
necessary sure epoch converges correct average start epoch 
continuously adding new nodes impossible achieve convergence 
network size size estimate actual size network cycles 
network size estimation counting 
scenario close realistic network size constant oscillates minimum maximum example day night alternation basis 
see curve estimates similar actual size curve translated epoch 
new nodes participate aggregation final estimate describes state network epoch started 

summarize practical implications theoretical results 
protocol scalable convergence results independent network size furthermore distributions number communications fixed node independent getpair rand getpair seq 
words increasing system size slow convergence increase resource requirements particular nodes 
furthermore independent location performance peaks costs distributed smoothly network 
traffic entire network grow linearly 
protocol efficient approximation average obtained quickly nodes due exponential convergence 
worst case examined getpair rand variance network decrease ln cycles avg 
recall main assumption overlay network fully connected topology connected unbiased random topology 
seen limiting factor practical applicability mentioned effort devoted developing protocols provide nodes approximately random neighbors care connectivity 
targeted extending analysis realistic topologies combining anti entropy aggregation membership protocols maintain sufficiently random predictable topology 
acknowledgment partially supported emerging technologies unit european commission project bison ist 
basic idea epidemic style variance reduction countless ideas emerged inspiring discussions maarten van steen kowalczyk 
bailey 
mathematical theory infectious diseases applications 
griffin london second edition 
bawa garcia molina gionis motwani 
estimating aggregates peer peer network 
submitted publication 
bollob random graphs 
cambridge university press cambridge new york second edition 
demers greene hauser irish larson shenker sturgis swinehart terry 
epidemic algorithms replicated database management 
proceedings th annual acm symposium principles distributed computing podc pages vancouver aug 
acm 
eugster guerraoui 
kermarrec 
lightweight probabilistic broadcast 
acm transactions computer systems 
eugster guerraoui 
kermarrec 
epidemics distributed computing 
ieee computer 
appear 
ganesh 
kermarrec 
peer topeer membership management gossip protocols 
ieee transactions computers feb 
gupta van renesse birman 
scalable faulttolerant aggregation large process groups 
proceedings international conference dependable systems networks dsn teborg sweden 
jelasity van steen 
large scale newscast computing internet 
technical report ir vrije universiteit amsterdam department computer science amsterdam netherlands oct 
milojicic lukose pruyne richard rollins xu 
peer peer computing 
technical report hpl hp labs palo alto 
montresor jelasity babaoglu 
robust aggregation protocols large scale overlay networks 
technical report ublcs university bologna department computer science bologna italy dec 
oram editor 
peer peer harnessing benefits disruptive technology 
reilly mar 
van renesse 
importance aggregation 
schiper shvartsman weatherspoon zhao editors directions distributed computing number lecture notes computer science pages 
springer 
van renesse birman vogels 
astrolabe robust scalable technology distributed system monitoring management data mining 
acm transactions computer systems may 
van renesse minsky hayden 
gossip style failure detection service 
davies raymond seitz editors middleware pages 
springer 
