pattern growth methods frequent pattern mining jian pei eng shanghai university eng shanghai university ph candidate university thesis submitted partial fulfillment requirements degree doctor philosophy school computing science jian pei simon fraser university june rights reserved 
may reproduced part photocopy means permission author 
name jian pei approval degree doctor philosophy title thesis pattern growth methods frequent pattern mining examining committee dr ramesh date approved chair dr jiawei han senior supervisor dr arthur supervisor dr martin ester sfu examiner dr raymond ng external examiner professor computer science university british columbia ii mining frequent patterns large databases plays essential role data mining tasks broad applications 
previously proposed methods adopt apriori candidate generation test approaches 
methods may encounter se challenges mining datasets prolific patterns long patterns 
develop class novel efficient pattern growth methods mining various frequent patterns large databases 
pattern growth methods adopt divide conquer approach decompose mining tasks databases 
pattern fragment growth method avoid costly candidate generation test processing completely 
effective data structures proposed compress crucial information frequent patterns avoid expensive repeated database scans 
com performance study shows pattern growth methods fp growth mine efficient scalable 
faster reported new frequent pattern mining methods 
interestingly pattern growth methods efficient effective 
pattern growth methods interesting patterns mined efficiently patterns tough non anti monotonic constraints sequential patterns 
techniques strong implications data mining tasks 
iii iv family feel obliged believe god endowed sense reason intellect intended forgo galileo gathered men flowers thread binds mine michel de acknowledgments wish express deep gratitude supervisor mentor dr jiawei han 
continuous encouragement confidence support sharing knowledge experience 
advisor taught practices skills academic career 
am thankful supervisor dr arthur insightful comments advice 
helpful discussion research career development 
really appreciate help improve quality thesis 
part done collaboration dr laks lakshmanan dr dong dr ke wang 
knowledge skills imparted collaboration 
working enjoyable 
gratitude appreciation goes dr martin ester dr raymond ng serving thesis 
want ms joyce lam proofreading thesis 
deepest professor tang professor yang university professor xu shanghai university educating training career 
people department support staff faculty helpful years 
friends simon fraser university help 
particular goes carole edwards kan hu eddie kim joyce lam li mao asl helen pinto wei wang jack yeung yin za ane zhou hua zhu 
am grateful parents wife continuous moral support encouragement 
hope proud achievements am proud 
love accompanies go 
vi contents approval ii iii dedication iv quotation acknowledgments vi list tables xi list figures xii motivation 
contributions 
organization thesis 
problem definition related frequent pattern mining problem 
apriori heuristic algorithm 
improvements apriori 
treeprojection going apriori methods 
fp growth pattern growth method frequent pattern tree design construction 
vii frequent pattern tree 
completeness compactness fp tree 
mining frequent patterns fp tree 
principles frequent pattern growth fp tree mining 
frequent pattern growth single prefix path fp tree 
frequent pattern growth algorithm 
scaling fp tree fp growth database projection 
experimental evaluation performance study 
environments experiments 
compactness fp tree 
scalability study 
comparison fp growth treeprojection 
summary 
mine scalable space preserving mining mine mem memory hyper structure mining 
general idea mine mem 
mine mem algorithm memory hyper structure min ing 
space usage mine mem 
mine mem mine efficient mining different occasions 
mine mining frequent patterns large databases 
handling dense data sets dynamic integration struct fp tree mining 
performance study experimental results 
mining transaction databases main memory 
mining large databases 
summary 
constraint pattern growth mining problem definition frequent itemset mining constraints 
convertible constraints classification 
convertible constraints 
strongly convertible constraint 
viii summary classification constraints 
mining algorithms 
mining frequent itemsets convertible constraints example fic mining frequent itemsets convertible anti monotone con straint 
fic mining frequent itemsets monotone constraints 
mining frequent itemsets strongly convertible constraints 
experimental results 
evaluation fic 
evaluation fic 
mining frequent itemsets multiple convertible constraints 
summary 
pattern growth sequential pattern mining problem definition related works 
problem definition 
algorithm gsp 
mining sequential patterns projections 
freespan frequent pattern projected sequential pattern mining 
prefixspan prefix projected sequential patterns mining 
scaling pattern growth bi level projection pseudo projection bi level projection 
pseudo projection 
experimental results performance study 
discussion 
summary 
discussion characteristics pattern growth methods 
extensions applications pattern growth methods 
mining closed association rules 
associative classification pattern growth methods 
mining multi dimensional sequential patterns 
computing iceberg cubes complex measures 
ix summary 
summary thesis 
research directions 
final thoughts 
bibliography list tables transaction database db 
transaction database 
mining frequent patterns creating conditional sub pattern bases 
projected databases fp trees 
single item projected databases partition projection 
transaction database db running example 
local frequent patterns partitions 
characterization commonly sql constraints 
transaction database example 
frequent itemsets support threshold transaction database table 
values profit items example 
characterization commonly sql convertible constraints 
means depends specific constraint 
strategies mining multiple convertible constraints conflict item ordering 
strategies mining multiple convertible constraints conflict item ordering 
sequence database 
projected databases sequential patterns 
matrix 
matrix ab projected database 
xi list figures lexicographical tree 
fp tree example 
fp tree constructed frequency descending ordering may minimal 
mining fp tree conditional fp tree item 
mining fp tree single prefix path 
parallel projection vs partition projection 
compactness fp tree data set connect 
compactness fp tree data set 
compactness fp tree data set 
scalability threshold sparse data set 
scalability threshold dataset abundant mixtures short long frequent patterns 
scalability threshold connect 
scalability fp growth number transactions 
divide conquer tree frequent patterns 
struct hyper structure storing frequent item projections 
header table ha ac queue 
header table hac 
header table ha ad queue 
adjusted hyper links mining projected database 
runtime data set gazelle 
space usage data set gazelle 
xii runtime data set 
space usage data set 
runtime pattern data set gazelle 
runtime pattern data set 
scalability respect number transactions 
scalability mine large data set 
effect memory size mining large data set 
ratio patterns checked mine third scan 
classification constraints relationships 
mining frequent itemsets satisfying constraint avg 
scalability constraint selectivity 
scalability support threshold 
scalability number transactions 
scalability constraint selectivity 
scalability support threshold 
candidates sequential patterns gsp 
runtime comparison prefixspan freespan gsp data set runtime comparison prefixspan variations data set 
cost comparison prefixspan variations data set kt 
scalability prefixspan variations 
xiii chapter universe full magical things patiently waiting wits grow sharper data mining find valid novel potentially useful ultimately understandable patterns data 
general kinds patterns knowledge discovered data 
example association rules mined market basket analysis classification rules accurate classifiers clusters outliers identified customer relation management 
frequent pattern mining plays essential role data mining tasks mining association rules kmr correlations bms causality se patterns episodes mtv multi dimensional patterns lsw max patterns bay partial periodicity emerging patterns dl 
fre quent pattern mining techniques extended solve problems iceberg cube computation br classification lhm 
effective efficient frequent pattern mining important interesting research problem 
motivation previous studies frequent pattern mining kmr son lsw sta sva glw adopt apriori approach anti monotone apriori heuristic length pattern frequent database length super pattern frequent 
essential idea eden english writer poet 
chapter 
iteratively generate set candidate patterns length set frequent patterns length check corresponding occurrence frequencies database 
apriori heuristic achieves performance gain possibly significantly reduc ing size candidate sets 
situations prolific frequent patterns long patterns quite low minimum support thresholds apriori algorithm may suffer nontrivial costs costly handle huge number candidate sets 
example frequent itemsets apriori algorithm need generate length candidates test occurrence frequencies 
discover frequent pattern size 
generate length candidates length candidates 
ultimately generates candidates total 
inherent cost candidate generation matter implementation technique applied 
tedious repeatedly scan database check large set candidates pattern matching especially true mining long patterns 
frequent pattern mining essential data mining task developing efficient frequent mining techniques important research direction data mining 
interesting questions need answered 
apriori basic principle frequent pattern mining 
analyzed advantages disadvantages 
improve efficiency frequent pattern mining substantially way obtain advantage avoiding costly candidate generation test repeated database scan operations 
frequent pattern mining suffers lack efficiency lack effectiveness huge number frequent patterns chapter 
generated database 
develop method derive succinct expression frequent patterns push users interest focus mining process 
frequent pattern mining potential applications 
extend effective efficient frequent pattern mining methods solve interesting data mining problems 
thesis tries progress answering questions 
contributions thesis study problem efficient effective frequent pattern mining extensions applications 
particular butions 
systematically develop pattern growth method frequent pattern mining 
novel algorithm fp growth proposed efficiently mining frequent patterns large dense datasets 
furthermore achieve efficient frequent pattern mining various situations design mine highly scalable space preserving large databases 
inherent problem frequent pattern mining may return patterns 
constraint data mining important approach solve problem effec tive data mining 
study problem constraint frequent pattern mining pattern growth methods 
study shows pattern growth methods push constraints deeper mining process including constraints aggregate av sum methods handle 
extend pattern growth method allow mining sequential patterns 
study shows pattern growth methods efficient mining large sequence databases 
interesting techniques developed solve sequential pattern mining problem effectively 
chapter 
organization thesis remainder thesis structured follows chapter frequent pattern mining problem overview related systematically 
chapter novel frequent pattern method fp growth developed 
correct ness efficiency fp growth verified theoretical analysis experimental tests 
fp growth efficient mining large dense databases may problem building recursive projected databases fp trees may costly space 
chapter propose mine retains advantages fp growth avoids redundant sub database tree building 
performance study shows mine achieves scalability mining large databases efficient space 
problem constraint frequent pattern mining studied chapter pattern growth methods 
examine constraints proposed previous studies attempt attack tough ones 
new kind constraint called convertible constraint identified 
pattern growth methods developed pushing various constraints deep mining process 
extend pattern growth methods solve sequential pattern mining prob lem chapter 
study indicates modification tion pattern growth methods applied mine patterns various kinds databases 
summarize characteristics pattern growth methods chapter 
interesting extensions applications pattern growth methods discussed 
thesis concludes chapter 
interesting applications pattern growth methods discussed directions 
chapter problem definition related chapter define problem frequent pattern mining revisit apriori heuristic algorithm 
improvements apriori algorithm discussed 
frequent pattern mining problem frequent pattern mining problem introduced agrawal ais mining association rules sets items 

im set items 
itemset subset items 
write itemsets ij ijn omitting set brackets 
particularly itemset items called itemset 
transaction tid tuple tid transaction id itemset 
transaction tid said contain itemset transaction database db set transactions 
support itemset transaction database db denoted db sup number transactions db containing sup tid tid db problem statement 
user specified support threshold min sup called chapter 
problem definition related frequent itemset frequent pattern sup min sup 
problem mining frequent itemsets find complete set frequent itemsets transaction database db respect support threshold min sup 
association rules derived frequent patterns 
association rule implication form itemsets 
rule support transaction database db db rule sup sup transaction database db support threshold min sup confidence thresh holds transaction database db confidence old min conf problem association rule mining find complete set asso ciation rules support confidence user specified thresholds respectively 
association rule mining divided steps 
frequent patterns respect support threshold min sup mined 
second association rules generated respect confidence threshold min conf 
shown studies step mining frequent patterns significantly costly terms time rule generation step 
shall see frequent pattern mining association rule mining 
frequent pattern mining basis data mining tasks sequential pattern mining associative classification 
broad applications basket data analysis cross marketing catalog design sale campaign analysis web log click stream analysis apriori heuristic algorithm achieve efficient mining frequent patterns anti monotonic property frequent item sets called apriori heuristic identified 
theorem apriori superset infrequent itemset frequent 
words subset frequent itemset frequent 
proof 
prove theorem need show sup sup transaction database db 
itemsets transaction containing itemset contains subset sup sup 
chapter 
problem definition related apriori heuristic prune candidates dramatically 
property fast frequent itemset mining algorithm called apriori developed 
illustrated example 
example apriori transaction database db table mini mum support threshold 
tid itemset ordered frequent items table transaction database db 
apriori finds complete set frequent itemsets follows 

scan db find frequent items items appearing transactions 
items forms length frequent itemset 
complete set length frequent itemsets 

set length candidates denoted generated 
apriori heuristic prune candidates 
candidates consist frequent subsets potentially frequent 
itemset xy 
ab ac 
ap bc 
mp 
itemsets 
form candidate set 

scan db count support itemset 
itemsets passing support threshold form length frequent itemsets 
example contains itemsets ac af am cf cm fm 

form set length candidates 
length itemsets length sub itemset qualified candidates 
example acf length candidate ac af cf 
scan db identifies subset length candidates passing support threshold form set length frequent itemsets 
similar process goes candidate derived candidate frequent 
chapter 
problem definition related verify process eventually finds complete set frequent itemsets database db 
apriori algorithm follows 
algorithm apriori input transaction database db support threshold min sup output complete set frequent patterns db respect support threshold method min sup 
scan transaction database db find set frequent itemsets 
lk generate ck set length candidates 
itemset ck length subset lk ck go step scan transaction database db count support itemset ck lk ck sup min sup 
return li analyze efficiency apriori algorithm example 
apriori heuristic helps reducing number candidates significantly 
total items appearing database possible length itemsets 
shown example apriori heuristic need check support counts length candidates 
apriori cuts length itemset level 
length candidates longer number possible combinations larger cutting effect apriori heuristic sharper 
chapter 
problem definition related apriori cut lot candidates costly handle huge number candidate itemsets large transaction databases 
example items items frequent length itemsets apriori generate length candidates test support save length candidates generation 
tedious repeatedly scan database check large set candidates pattern matching particularly true long pattern exists 
apriori level level candidate generation test algorithm 
find frequent itemset apriori scan database times 
apriori encounters difficulty mining long patterns 
example find frequent itemset generate test candidates 
improvements apriori past years improvements apriori algorithm pro posed 
section review important proposals 
shown section major bottlenecks apriori algorithm aspects 
apriori algorithm needs scan database multiple times 
mining huge database multiple database scans costly 
feasible strategy improve efficiency apriori algorithm reduce number database scans 
apriori algorithm generate huge number candidates 
storing counting candidates tedious 
attack problem studies focus reducing number candidates 
dominant operation apriori algorithm support counting 
speed apriori algorithms facilities proposed 
typical example effort reducing number database scans 
study brin propose dic dynamic itemset counting algorithm 
intuitively dic works train running data stops intervals transactions apart 
algorithm reads transactions time update appropriate support counts 
train reaches transaction database chapter 
problem definition related scan data starts scan 
passengers train candidate itemsets 
itemset train support updated time transaction containing itemset scanned 
start scan passengers train set length 
dic checks passengers train rules 

support count candidate itemset passes support threshold check joined frequent itemsets length generate new candidates 
add new candidate train 
generate length itemset ak length subsets accumulated support greater equal support threshold 
example counter corresponding itemset abc passes support threshold check abc joined length frequent itemsets 
bcd acd abd determined frequent itemsets generate length candidate abcd 

candidate itemset travelled complete scan removed train 
time support greater equal support threshold output support frequent pattern 
example consider mining transaction database db transac tions support threshold 
interval stops 
itemset get support counts greater transactions dic start counting itemset ab transactions 
similarly ab ac bc contained transactions second transactions dic start counting itemset abc transactions 
dic gets trans action database db counting itemsets go back start database count itemsets 
transactions dic finish counting ab transactions finish counting abc 
overlapping counting different lengths itemsets dic save database scans 
hand dic explores efficient support counting 
optimizes trie structure apriori algorithm counting candidates 
frequent items candidate sorted support ascending order popularity chapter 
problem definition related transactions 
order reduce number inner loops counting 
reordering items incurs overhead data may beneficial 
experimental results reported indicates dic faster apriori support threshold low 
interesting study reducing number database scans savasere son :10.1.1.103.5437
large transaction database divided multiple partitions partition held main memory 
database scanned twice 
scan partitions read main memory 
local frequent patterns mined respect relative support threshold apriori method 
second scan global frequent patterns 
global frequent pattern frequent partition 
local frequent patterns counted tested second scan 
major challenges partitioning method aspects 
hand partitioning database non trivial database biased 
hand low global support threshold may lead lower local threshold produce huge number local frequent patterns 
extreme example global absolute support threshold global database divided partitions partitions may local threshold means itemset partitions local frequent pattern 
counting huge number patterns second scan costly 
toi toivonen proposes frequent pattern mining method sampling 
mining database directly sampling method mine sample database apriori algorithm 
sample small fit main memory 
database scanned verify frequent itemsets sample 
frequent patterns having frequent super pattern checked 
rare cases sampling method may produce frequent patterns missing patterns pass database 
performance study toi shows sampling algorithm faster apriori partitioning method son :10.1.1.103.5437
cases mining sample database sampling method needs scan find frequent patterns 
park illustrate frequent pattern mining sped reducing number candidates 
dhp direct hashing pruning hashing algorithm introduced 
dhp apriori algorithm improvement candidate generation chapter 
problem definition related counting 
th scan dhp counts length candidates buckets length potential candidates 
example items transaction database 
scan dhp counts supports length candidates 
time potential length candidates ab ac 
de generated grouped buckets 
suppose ab ad ae bucket 
transaction containing ab ad ae results increment support count bucket 
scan support count bucket support threshold ab ad ae length candidate frequent 
dhp especially effective generation candidate set large itemsets 
explicitly number candidate itemsets generated proposed algorithm orders magnitude smaller generated previous methods 
treeprojection going apriori methods agarwal propose treeprojection frequent pattern mining algorithm apriori framework 
treeprojection mines frequent patterns constructing lex tree projecting large database set reduced item sub databases frequent patterns mined far 
general idea shown example 
example transaction database example construct lexicographical tree method described aap 
resulting tree shown construction process follows 
scanning transaction database frequent itemsets identified 
recommended aap frequency ascending order chosen ordering items 
order 
top level lexicographical tree constructed root nodes labelled length patterns 
stage root node labelled null nodes store frequent itemsets generated 
transactions database projected root node infrequent items removed 
node lexicographical tree contains pieces information pattern node represents ii set items adding pattern current node may generate longer patterns 
piece information recorded active extensions active items 
chapter 
problem definition related pc ma mac cf cf cf null acf acf acf cf cf cf maf mc mf mcf pbc bf ac af acf lexicographical tree 
matrix root node created shown 
matrix computes cies length patterns pairs frequent items included matrix 
items arranged ascending order 
matrix built adding counts transac tions projected database computing frequent itemsets transactions stored root node 
time matrix built transactions root projected level nodes follows 
transaction items listed ascending order 
transaction projected node ai ai ai ai 
matrix frequent itemsets pc ma mc mf ac af cf 
nodes lexicographical tree frequent itemsets generated 
stage active nodes itemsets nodes contain cf chapter 
problem definition related descendants potentially generate longer frequent itemsets 
itemset nodes pruned 
way lexicographical tree grown level level 
matrix node nodes labelled mac maf mcf added ma active frequent itemsets 
easy see lexicographical tree total contains nodes 
number nodes lexicographical tree exactly frequent itemsets 
treeprojection proposes efficient way enumerate frequent patterns 
efficiency treeprojection explained main factors hand transaction projection limits support counting relatively small space related portions transactions considered 
hand lexicographical tree facilitates management counting candidates provides flexibility picking efficient strategy tree generation phase transaction projection phase 
aap reports algorithm order magnitude faster techniques literature 
chapter fp growth pattern growth method conventional frequent pattern mining method apriori section 
analyzed major costs apriori methods generation huge number candidates repeated scanning large transaction databases test candi dates 
short candidate generation test operation bottleneck apriori methods 
avoid candidate generation test frequent pattern mining 
attack problem develop fp growth pattern growth method frequent pattern mining chapter 
develop effective data structure fp tree section 
section propose efficient algorithm mining frequent patterns fp tree verify correctness 
section discuss scale method mine large databases held main memory 
experimental results performance studies reported section 
frequent pattern tree design construction information transaction databases essential mining frequent patterns 
extract concise information frequent pattern mining store compact structure may facilitate frequent pattern mining 
motivated thinking section develop compact data structure called fp tree store chapter 
fp growth pattern growth method complete redundant information frequent pattern mining 
frequent pattern tree design compact data structure efficient frequent pattern mining examine example 
example transaction database db columns table transaction database example minimum support threshold min sup 
tid items bought ordered frequent items table transaction database 
compact data structure designed observations 
frequent items play role frequent pattern mining necessary perform scan transaction database db identify set frequent items frequency count obtained product 

set frequent items transaction stored compact structure may possible avoid repeatedly scanning original transaction database 

multiple transactions share set frequent items may possible merge shared sets number occurrences registered count 
easy check sets identical frequent items transactions listed fixed order 

transactions share common prefix sorted order frequent items shared parts merged prefix structure long count registered properly 
frequent items sorted frequency descending order better chances prefix strings shared 
chapter 
fp growth pattern growth method item header table head node links root fp tree example 
observations may construct frequent pattern tree follows 

scan db derives list frequent items number indicates support items ordered frequency descending order 
case items exactly support count sorted alphabetically 
ordering important path tree follow order 
convenience discussions frequent items transaction listed ordering rightmost column table 
root tree created labelled null 
fp tree constructed follows scanning transaction database db second time 
scan transaction leads construction branch tree notice frequent items transaction listed order list frequent items 
second transaction ordered frequent item list shares common prefix existing path count node prefix incremented new node created linked child new node created linked child 
chapter 
fp growth pattern growth method third transaction frequent item list shares node prefix subtree count incremented new node created linked child 
scan fourth transaction leads construction second branch tree 
transaction frequent item list identical path shared count node path incremented 
facilitate tree traversal item header table built item points occurrence tree node link 
nodes item name linked sequence node links 
scanning transactions tree associated node links shown 
example frequent pattern tree designed follows 
definition fp tree frequent pattern tree fp tree short tree structure defined 

consists root labeled null set item prefix subtrees children root frequent item header table 

node item prefix subtree consists fields item name count node link item name registers item node represents count registers number transactions represented portion path reaching node node link links node fp tree carrying item name null 

entry frequent item header table consists fields item name head node link pointer pointing node fp tree carrying item name 
definition fp tree construction algorithm 
algorithm fp tree construction input transaction database db minimum support threshold min sup 
chapter 
fp growth pattern growth method output fp tree frequent pattern tree db 
method fp tree constructed follows 

scan transaction database db 
collect set frequent items support frequent item 
sort support descending order list list frequent items 

create root fp tree label null 
transaction db 
select frequent items transaction sort order list 
sorted frequent item list element remaining list 
call insert tree 
function insert tree performed follows 
child item name item name increment count create new node count initialized parent link linked node link linked nodes item name node link structure 
nonempty call insert tree recursively 
analysis 
fp tree construction takes exactly scans transaction database 
scan collects set frequent items 
second constructs fp tree 
cost inserting transaction fp tree freq freq set frequent items section show fp tree contains complete information frequent pattern mining 
completeness compactness fp tree important properties fp tree observed fp tree construction process 
transaction database db support threshold min sup 
frequent items db 
transaction freq set frequent items freq called frequent item projection transaction apriori principle set frequent item projections transactions database chapter 
fp growth pattern growth method sufficient mining complete set frequent patterns infrequent items play role frequent patterns 
lemma transaction database db support threshold min sup sup port frequent itemset derived db fp tree 
proof 
fp tree construction process transaction db frequent item projection mapped path root fp tree 
frequent itemset xn items sorted support de order 
side link item xn visit nodes label xn tree 
path root node label xn support count node number transactions represented 
xn appear transactions represented contain accumulate support counts 
sum support lemma fp tree db constructed contains complete information mining frequent patterns transaction database 
fp tree needed remaining mining process regardless number length frequent patterns 
lemma transaction database db support threshold min sup num ber nodes fp tree db freq 
number nodes longest path root maxt db freq 
proof 
fp tree construction process transaction db freq xk 
exists path root xk fp tree 
node tree root node corresponds frequent item occurred transaction database 
worst case overlap frequent item projections transactions paths root leaves share root node 
number nodes tree db freq 
longest path root tree maxt db freq nodes 
lemma shows important benefit fp tree size fp tree bounded size corresponding database transaction contribute path fp tree length equal number frequent items transaction 
transactions share frequent items size tree usually chapter 
fp growth pattern growth method smaller original database 
fp tree breaks transaction pieces 
apriori method may generate exponential number candidates worst case circumstances may fp tree exponential number nodes generated 
fp tree highly compact structure stores information frequent pattern mining 
single path prefix subtree registers transactions maximal frequent set form ak size fp tree substantially smaller size database candidate sets generated association rule mining 
items frequent item set ordered support descending order frequently occurring items shared arranged closer top fp tree 
general ordering provides relatively compact fp tree structure 
feasible construct fp tree order properties discussed hold 
support descending order heuristic reduce size tree 
mean tree constructed achieves maximal compactness 
knowledge particular data characteristics possible achieve better compression frequency descending ordering 
con sider example 
transactions cdef minimum support threshold 
frequent item set associated support count 
item frequency ordering fp tree constructed contain nodes shown 
item ordering contain nodes shown 
compactness fp tree verified experiments 
small fp tree results quite large database 
example database connect bay contains transactions items transaction support threshold experiments bay total number occurrences frequent items total number nodes fp tree represents reduction ratio holds hundreds thousands frequent patterns 
notice databases short transactions reduction ratio high 
surprising gigabyte transaction database containing long patterns may generate fp tree chapter 
fp growth pattern growth method fp tree follows support ordering fp tree follow support ordering fp tree constructed frequency descending ordering may minimal 
fits main memory 
mining frequent patterns fp tree construction compact fp tree ensures subsequent mining performed compact data structure 
automatically guarantee highly efficient may encounter combinatorial problem candidate generation simply fp tree generate check candidate patterns 
section study explore compact information stored fp tree develop principles frequent pattern growth examination running example explore perform optimization exists single prefix path fp tree propose frequent pattern growth algorithm fp growth mining complete set frequent patterns fp tree 
principles frequent pattern growth fp tree mining subsection examine interesting properties fp tree structure facilitate frequent pattern mining 
property node link property frequent item ai possible patterns containing frequent items ai obtained ai node links starting ai head fp tree header 
chapter 
fp growth pattern growth method property directly fp tree construction process facilitates access frequent pattern information related ai traversing fp tree ai node links 
facilitate understanding properties fp tree related mining go example performs mining constructed fp tree example 
example examine mining process constructed fp tree shown 
list frequent items frequent patterns database divided subsets overlap 
patterns containing item 
patterns containing item item 
patterns containing item 
patterns containing item 
patterns containing item 
patterns containing item mine subsets 

mine patterns having item immediate frequent pattern subset 
find patterns having item need access frequent item projections containing item property projections collected starting node link head node links 
node links find paths fp tree path indicates string appears twice database 
notice path indicates string appears times appears times 
appear twice study string appear prefix path simply fcam counts 
similarly second path indicates chapter 
fp growth pattern growth method root global fp tree conditional pattern base item fca header table head node links conditional fp tree root conditional pattern base am fc conditional fp tree am root root conditional pattern base cm conditional fp tree cm mining fp tree conditional fp tree item conditional pattern base cam conditional fp tree cam string appears set transactions db prefix path cb prefix paths fcam cb form subpattern base called conditional pattern base subpattern base condition existence 
construction fp tree conditional pattern base called conditional fp tree leads branch 
frequent pattern cp derived 
notice pattern itemset denoted string 
search frequent patterns associated terminates 

turn patterns having item item immediately iden tify frequent pattern 
node links paths fp tree 
notice appears need include analysis frequent patterns involving analyzed previous examination pat terns having item similar analysis conditional pattern base fca 
constructing fp tree derive conditional fp tree single frequent pattern path shown 
conditional fp tree mined recursively calling mine 
shows mine involves mining items sequence 
derives frequent pattern am conditional pattern base fc call mine am second derives frequent pattern cm conditional pattern base call mine cm third derives frequent pattern fm 
recursive call mine am derives cam fam conditional pattern base call root chapter 
fp growth pattern growth method mine cam derives longest pattern fcam 
similarly call mine cm derives pattern fcm 
set frequent patterns involving am cm fm cam fam fcam fcm 
indicates single path fp tree mined outputting combinations items path 

similarly mine patterns containing item node derives paths condi tional pattern base fca generates frequent item mining terminates 

patterns having item node derives frequent pattern subpattern base fc single path conditional fp tree 
set frequent patterns generated combinations 
concatenating fa ca fca 

turn mine patterns having item node derives subpattern base set frequent patterns associated fc 

subset pattern having item items output 
conditional pattern base need constructed 
item conditional pattern base conditional fp tree fcam cb fca fca fc table mining frequent patterns creating conditional sub pattern bases conditional pattern bases conditional fp trees generated summarized table 
correctness completeness process example justified 
accomplished introducing important properties related mining process 
chapter 
fp growth pattern growth method property prefix path property calculate frequent patterns suffix ai prefix sub nodes labelled ai fp tree need accumulated frequency count node prefix path carry count corresponding node ai path 
proof 
nodes path labelled 
order root prefix subtree leaf subtree ai node referenced 
process fp tree construction algorithm prefix node ak prefix sub path node ai occurs ak exactly ai count times 
prefix node carry count node ai 
notice postfix node am path occurs node ai 
patterns am generated examination postfix node am enclosing lead redundant generation patterns generated am 
need examine prefix sub path ai example example node involved path calculate frequent patterns node path prefix sub path node need extracted frequency count node prefix path carry count node node counts prefix path adjusted property prefix sub path node ai path copied transformed count adjusted prefix sub path adjusting frequency count node prefix sub path count node ai 
transformed prefix path called transformed prefix path ai path notice set transformed prefix paths ai form small database patterns occur ai 
database patterns occurring ai called ai condi tional pattern base denoted pattern base ai 
compute frequent patterns associated ai ai conditional pattern base creating small fp tree called ai conditional fp tree denoted fp tree ai 
subsequent mining performed small conditional fp tree 
process constructing conditional pattern bases conditional fp trees demonstrated example 
process performed recursively frequent patterns obtained pattern growth method lemmas corollary 
chapter 
fp growth pattern growth method lemma fragment growth itemset db conditional pattern base itemset support db equivalent support proof 
definition conditional pattern base sub transaction occurs condition occurrence original transaction database db 
itemset appears times appears db times 
items collected conditional pattern base occurs exactly times db 
lemma 
lemma directly derive important corollary 
corollary pattern growth frequent itemset db condi tional pattern base itemset frequent db frequent proof 
corollary case frequent itemset db support conditional pattern base minimum support threshold 
prove part 
suppose frequent appears times 
conditional pattern base transaction appears existence 
appears db times 
frequent db 
prove part 
suppose frequent appears times 
conditional pattern base itemsets containing occurring occurs times 
frequent db 
corollary mining performed identifying set frequent itemsets db frequent itemset constructing conditional pattern bases mining set frequent itemsets conditional pattern base 
indicates process mining frequent patterns viewed mining frequent itemset progressively growing itemset mining conditional pattern base turn done similarly 
doing frequent itemset mining problem successfully transformed sequence frequent itemset mining problems set conditional pattern bases 
mining done pattern growth need generate candidate sets entire mining process 
chapter 
fp growth pattern growth method notice construction new fp tree conditional pattern base obtained mining fp tree items frequent itemset ordered frequency descending order node occurrence item support represents item occurrence 
node fp tree may represent occurrences item node represents single unit itemset elements occur construction item associated fp tree 
frequent pattern growth single prefix path fp tree frequent pattern growth method described works kinds fp trees 
optimization explored special kind fp tree called single prefix path fp tree optimization especially useful mining long frequent patterns 
single prefix path fp tree fp tree consists single path single prefix path stretching root branching node tree branching node node containing child 
examine example 
example single prefix path fp tree consists prefix path stretching root tree branching node 
mined frequent pattern growth method described better method split tree fragments single prefix path shown multiple path part root replaced pseudo root shown 
parts mined separately combined 
examine separate mining processes 
frequent patterns associated part single prefix path mined enumeration combinations sub support set minimum support items contained sub path 
sub path distinct occurs number times minimum occurrence frequency items sub path equal support item sub path 
path generates set frequent patterns freq pattern set ab ac bc abc 
second fp tree multiple path part rooted mined follows 
chapter 
fp growth pattern growth method root root single prefix path tree single path portion multipath portion mining fp tree single prefix path 
treated null root forms multiple path fp tree mined typical frequent pattern growth method 
mining result freq pattern set df second frequent itemset viewed conditional frequent pattern base itemset pattern generated may form distinct frequent pattern 
example freq pattern set viewed conditional pattern base pattern generated generate new frequent itemset ad appears times 
set frequent patterns generated freq pattern set ad bd cd abd acd bcd abcd means pattern combined form cross product larger itemset support minimum support patterns 
complete set frequent patterns generated combining results freq pattern set freq pattern set support support itemset support itemset 
chapter 
fp growth pattern growth method summary set frequent patterns generated single prefix path con sists distinct sets freq pattern set set frequent patterns gener ated single prefix path freq pattern set set frequent patterns generated multiple path part fp tree freq pattern set freq pattern set set frequent patterns involving parts 
show fp tree consists single path generate set frequent patterns lemma 
lemma pattern generation fp tree consisting single path suppose fp tree consists single path root ak sk itemset ai aij ij frequent pattern sup equals support count registered node aij tree proof 
construction fp tree 
ak frequent items 
path tree transaction having ak 
ak 
sup ak sup ak sk min sup min sup support threshold 
apriori property itemset stated lemma frequent pattern 
itemset stated lemma tree path transaction containing correspond sub path root tree node ij increases support count node aij tree construction 
means support count registered node aij sup 
hand apriori property support aij larger sup exactly support count registered aij show fp tree consists single prefix path set frequent patterns generated splitting tree lemma 
lemma pattern generation fp tree consisting single prefix path suppose fp tree similar tree consist single prefix path similar tree multi path part viewed independent fp tree pseudo root similar tree 
complete set frequent patterns consists portions 
set frequent patterns generated enumeration combinations items path support minimum support items pattern contains 
chapter 
fp growth pattern growth method 
set frequent patterns generated root null 
set frequent patterns combining formed taken cross product frequent patterns generated denoted freq pattern set freq pattern set frequent itemset union frequent itemset support minimum supports itemsets 
proof 
fp tree construction rules node ai single prefix path fp tree appears tree 
single prefix path fp tree forms new fp tree multiple path part forms fp tree share nodes representing item 
fp trees mined separately 
show pattern generated portions pattern generation rules distinct frequent 
lemma pattern generated fp tree formed single prefix path distinct frequent 
set frequent patterns generated root null distinct frequent patterns exist combining items conditional databases items set frequent patterns generated combining cross product frequent patterns generated support minimum supports itemsets distinct frequent 
frequent pattern generated considered frequent pattern conditional pattern base frequent item support minimum supports frequency patterns appear 
second show patterns generated portions 
lemma fp tree split fp trees generates complete set frequent patterns pattern growth 
pattern generated generated portion combination method generates complete set frequent patterns 
frequent pattern growth algorithm lemmas properties algorithm mining frequent patterns fp tree 
chapter 
fp growth pattern growth method algorithm fp growth mining frequent patterns fp tree pattern fragment growth input database db represented fp tree constructed algorithm minimum support threshold 
output complete set frequent patterns 
method call fp growth fp tree null 
procedure fp growth ree ree contains single prefix path mining single prefix path fp tree single prefix path part ree multiple path part top branching node replaced null root combination denoted nodes path generate pattern support minimum support nodes freq pattern set set patterns generated ree item ai mining multiple path fp tree generate pattern ai support ai support construct conditional pattern base conditional fp tree ree ree call fp growth ree freq pattern set set patterns generated return freq pattern set freq pattern set freq pattern set freq pattern set analysis 
properties lemmas sections show algorithm correctly finds complete set frequent itemsets transaction database db 
shown lemma fp tree db contains complete information db relevance frequent pattern mining support threshold 
fp tree contains single prefix path lemma generation complete set frequent patterns partitioned portions single prefix path portion multiple path portion combinations 
lines chapter 
fp growth pattern growth method line procedure 
lemma generated patterns single prefix path enumerations sub paths prefix path support minimum support nodes sub path 
lines procedure 
treat multiple path portion fp tree contain single prefix path portion lines construct conditional pattern base mine conditional fp tree frequent itemset ai 
correctness completeness prefix path transformation shown property 
conditional pattern bases store complete information frequent pattern mining lemmas corollary patterns successively grown conditional fp trees set sound complete frequent patterns 
especially fragment growth property support combined fragments takes support frequent itemsets generated conditional pattern base 
lines procedure 
line sums complete result lemma 
examine efficiency algorithm 
fp growth mining process scans fp tree db generates small pattern base bai frequent item ai consisting set transformed prefix paths ai 
frequent pattern mining recursively performed small pattern base bai constructing conditional fp tree bai reasoned analysis algorithm fp tree usually smaller size db 
similarly conditional fp tree fp tree ai constructed pattern base bai usually smaller bigger bai pattern base bai usually smaller original fp tree consists transformed prefix paths related frequent items ai 
subsequent mining process works set usually smaller pattern bases conditional fp trees 
mining operations consist mainly prefix count adjustment counting local frequent items pattern fragment concatenation 
costly generation test large number candidate patterns 
algorithm efficient 
algorithm reasoning see fp growth mining process divide conquer process scale shrinking usually quite dramatic 
shrinking factor constructing fp tree database expected hundreds times reduction constructing conditional fp tree chapter 
fp growth pattern growth method quite small conditional frequent pattern base 
notice case database may generate large number frequent patterns size fp tree usually quite small 
example frequent pattern length fp tree construction results path length 
fp growth algorithm generate frequent patterns time permits 

fp tree contains frequent pattern path nodes lemma need construct conditional fp tree order find patterns 
fp tree derive condensed expression frequent patterns 
case long pattern output long pattern omit proper sub patterns 
scaling fp tree fp growth database tion fp growth proposed section essentially main memory frequent pattern mining method 
database large minimum support threshold quite low unrealistic assume fp tree database fit main memory 
disk method worked ensure mining highly scalable 
section develop method partition database set projected databases projected database construct mine corresponding fp tree 
revisit mining problem example 
example suppose fp tree held main memory 
constructing global fp tree project transaction database set frequent item related projected databases follows 
starting tail frequent item list set transactions contain item collected projected database 
infrequent items item removed infrequent items useful frequent pattern mining item default associated projected transaction 
projected database fcam cb fcam 
similar conditional pattern base shown table fcam fcam expressed table 
chapter 
fp growth pattern growth method conditional fp tree built projected database fp tree construction algorithm 
similarly set transactions containing item projected projected database 
notice infrequent items item item excluded set projected items item association considered projected database 
reason projected database formed collecting transactions containing item infrequent items items excluded 
process continues deriving projected database projected database 
complete set item projected databases derived transaction database listed table corresponding conditional fp trees 
easily see processes constructing global fp tree forming conditional fp trees projecting database set projected databases constructing conditional fp trees yield identical conditional fp trees 
item projected database conditional fp tree fcam cb fcam fca fca fca fc fc fc table projected databases fp trees shown section conditional fp tree usually orders magnitude smaller global fp tree 
construction conditional fp tree projected database mining dramatically reduce size fp trees handled 
conditional fp tree projected database fit main memory 
project projected database process go recursively conditional fp tree fits main memory 
define concept projected database formally 
definition projected database ai frequent item transaction database db 
ai projected database ai denoted db ai derived follows 
transactions containing ai selected 
remove infrequent items selected transaction 
delete chapter 
fp growth pattern growth method selected transaction ai items follow ai list frequent items 
ai projected database derived projecting set items transactions containing ai projected database 
alternatively achieved collecting set items ai subtree fp tree 
methods derive sets conditional fp trees 
tion 
methods database projection parallel projection partition parallel projection implemented follows scan database projected database transaction database projected database 
transaction database frequent item ai project ai projected database transaction projection rule specified definition projected database 
transaction projected parallel projected databases scan called parallel projection 
set projected databases shown table example demonstrates result parallel projection 
process illustrated 
parallel projection facilitates parallel processing projected databases available mining scan projected databases mined parallel 
transaction database projected multiple projected databases database contains long transactions multiple frequent items total size projected databases multiple times original 
transaction contains average frequent items 
transaction projected projected database 
total size projected data transaction implies total size single item projected databases times original database 
avoid overhead propose partition projection method 
partition tion implemented follows 
transaction projected ai projected database ai item appearing transaction projected projected database database scan 
scan database partitioned projection set projected databases called partition projection 
projected databases mined reverse order list frequent items 
projected database frequent item mined 
chapter 
fp growth pattern growth method proj 
db fcam cb fcam proj db fca fca transaction database tdb proj 
db fca proj 
db fc fc fc list proj 
db proj 
db empty proj 
db proj 
db proj 
db fcam cb fcam fca 
transaction database tdb proj 
db fc 
parallel projection partition projection parallel projection vs partition projection 
list proj 
db proj 
db empty projected database db ak mined transactions db ak projected 
transaction db ak projected aj projected database db ak aj frequent item aj partition projection process database example illustrated 
advantage partition projection total size projected databases level smaller original database usually takes memory os complete partition projection 
processing order projected databases important process projected databases sequential manner 
processing projected database needs project processed transactions corresponding projected databases may take 
due low memory requirement partition projection promising method frequent pattern mining 
example examine database example projected par projection 
scan transaction database transaction projected projected database 
transaction projected projected database frequent item list frequent items 
fcam chapter 
fp growth pattern growth method infrequent items removed inserted projected database 
similarly transaction projected projected database projected database projected database cb projected database fcam 
phrase entries projected databases shown table 
item projected databases fcam cb fcam table single item projected databases partition projection 
projection original database replaced set single item projected databases total size smaller original database 
second projected database processed construction conditional fp tree item list frequent items 
processing projected database transaction projected corresponding projected database partition projection rule 
example fcam projected projected database fca cb projected projected database 
process continues single item projected database completely processed 
experimental evaluation performance study section performance comparison fp growth classical fre quent pattern mining algorithm apriori proposed database projection algorithm treeprojection 
environments experiments experiments performed mhz pentium pc machine megabytes main memory running microsoft windows nt 
programs written mi visual 
notice directly compare absolute number runtime published reports running risc workstations chapter 
fp growth pattern growth method different machine architectures may differ greatly absolute runtime gorithms 
implement algorithms best knowledge published reports machine compare running environment 
please note run time means total execution time pe input output cpu time measured experiments literature 
feel run time comprehensive measure takes total running time consumed measure cost cpu time considers cost cpu resource 
reports runtime fp growth include time constructing fp trees original databases 
experiments pursued synthetic real data sets 
synthetic data sets experiments generated procedure described 
refer readers details generation data sets 
report experimental results synthetic data sets 
items 
data set average transaction size average maximal potentially frequent itemset size set respectively number transactions dataset set 
sparse dataset 
frequent itemsets short numerous 
second synthetic data set items 
average transaction size average maximal potentially frequent itemset size set respectively 
exist exponentially numerous frequent itemsets data set support threshold goes 
pretty long frequent itemsets large number short frequent itemsets 
contains abundant mixtures short long frequent itemsets 
test capability fp growth dense datasets long patterns real data set connect compiled connect game state information 
data set uc irvine machine learning database repository contains transactions transaction items 
dense dataset lot long frequent itemsets 
compactness fp tree test compactness fp trees compare sizes structures 
www ics uci edu mlearn mlrepository html chapter 
fp growth pattern growth method alphabetical fp tree 
includes space links 
fp tree alphabetical order items frequency descending order 
ordered fp tree 
size covers links 
fp tree items sorted frequency descending order 
transaction database 
item transaction stored integer 
simply sum occurrences items transactions 
frequent transaction database 
sub database extracted original removing infrequent items 
real dataset connect fp tree achieves compactness 
seen result shown size ordered fp tree smaller size transaction database frequent transaction database 
dense database size database frequent database close 
size alphabetical fp tree smaller databases cases slightly larger times larger size ordered fp tree 
indicates frequency descending ordering items benefits data compression case 
size kb tran 
db freq 
tran 
db alphabetical fp tree ordered fp tree support threshold compactness fp tree data set connect 
dataset contains abundant mixture long short frequent patterns fp tree compact time 
result shown 
chapter 
fp growth pattern growth method support threshold lower size fp tree larger frequent database 
long support threshold fp tree smaller transaction database 
difference sizes ordered fp tree alphabetical fp tree quite small dataset 

size kb tran 
db freq 
tran 
db alphabetical fp tree ordered fp tree support threshold compactness fp tree data set 
sparse dataset fp tree achieves compactness support threshold 
difference ordered fp tree alphabetical fp tree trivial 
result shown 
experiments 
fp tree achieves compactness time 
especially dense datasets compress database times 
clearly overhead pointers counters 
gain sharing frequent projections transactions substantially overhead fp tree space efficient cases shown performance study 
support low fp tree bushy 
cases degree sharing branches fp tree low 
overhead links size fp tree large 
building fp tree construct projected databases 
reason build fp tree transaction database projected database passes certain density threshold 
experiments see chapter 
fp growth pattern growth method size kb support threshold tran 
db freq 
tran 
db alphabetical fp tree ordered fp tree compactness fp tree data set 
threshold pretty low easy touch 
large sparse database rounds database projection fp tree remaining mining tasks 
experiments employed implementation fp growth inte database projection fp tree mining 
density threshold set items listed frequency descending order 
scalability study scalability apriori treeprojection fp growth synthetic data set support threshold decreases shown 
fp growth faster apriori treeprojection 
treeprojection faster scalable apriori 
dataset sparse support threshold high frequent itemsets short number large advantages fp growth treeprojection apriori impressive 
support threshold goes gap wider 
fp growth finish computation support threshold time apriori 
treeprojection scalable slower fp growth 
advantages fp growth apriori obvious dataset contains chapter 
fp growth pattern growth method runtime seconds apriori treeprojection fp growth support threshold scalability threshold sparse data set 
abundant mixtures short long frequent patterns 
shows experimental results scalability threshold dataset 
fp growth mine support threshold low apriori reasonable time 
treeprojection scalable faster apriori slower fp growth 
advantage fp growth dramatic datasets long patterns ing algorithms mine complete set frequent patterns 
result mining real dataset connect shown 
best knowledge algorithm handles dense real dataset performance study 
see fp growth scalable long patterns 
candidate generation fp growth enumerates long patterns efficiently 
datasets nei ther apriori treeprojection comparable performance fp growth 
deal long patterns apriori generate tremendous number candidates costly process 
main costs treeprojection matrix computation transaction projection 
database large number frequent items matrices quite large computation cost jumps substantially 
contrast height fp tree limited maximal length transactions transactions share prefix paths fp tree 
explains fp growth distinct advantages support threshold low number transactions large 
test scalability fp growth number transactions set synthetic chapter 
fp growth pattern growth method runtime seconds apriori treeprojection fp growth support threshold scalability threshold dataset abundant mixtures short long frequent patterns 
datasets generated parameters number transactions ranges 
fp growth tested support threshold percentage 
result shows linear increase runtime number transactions 
please note way reported literature replicate transactions real data sets test scalability 
matter times transactions replicated fp growth builds fp tree size identical original scaling databases trivial 
comparison fp growth treeprojection treeprojection described section 
comparison fp growth method treeprojection suffers problems related efficiency scalability implemen tation complexity 
analyze follows 
treeprojection may encounter difficulties computing matrices database huge lot transactions containing frequent items support threshold low 
cases exist large number frequent items 
size matrices high level nodes lexicographical tree huge shown section 
study treeprojection aap chapter 
fp growth pattern growth method runtime seconds apriori treeprojection fp growth support threshold scalability threshold connect 
developed smart memory caching methods overcome problem 
wise generate huge matrices finding smart caching techniques reduce cost 
matrix cached efficiently computation involves nontrivial overhead 
compute matrix node projected transactions cost ti ti length transaction 
number transaction large length transaction long computation costly 
fp growth method need build matrices compute itemset frequency avoids generation candidate itemsets applying pattern growth method 
pattern growth viewed successive computation frequent itemset database conditional pattern bases assembling longer patterns 
computing frequent itemsets expensive computing frequent itemsets cost substantially reduced 
second transaction may contain frequent itemsets transaction treeprojection may projected times different nodes lexicographical tree 
long transactions containing numerous frequent items trans action projection nontrivial cost treeprojection fp growth method constructs fp tree highly compact form transaction database 
size cost computation conditional pattern bases corresponds roughly compact form projected transaction databases substantially reduced 
chapter 
fp growth pattern growth method runtime seconds number transactions scalability fp growth number transactions 
third treeprojection creates node lexicographical tree frequent item set 
glance highly compact fp tree ensure frequent node mapped node tree 
branch fp tree may store hidden frequent patterns due potential generation combinations prefix paths 
notice total number frequent itemsets large large database database quite long frequent itemsets 
example frequent itemset number frequent itemsets th level lexicographic tree 

frequent itemset fp tree fp growth need path nodes 
summary fp growth mines frequent itemsets constructing highly compact fp trees share numerous projected transactions hide carry numerous frequent patterns applying progressive pattern growth frequent itemsets avoids generation potential combinations candidate itemsets implicitly explicitly treeprojection generate candidate itemsets projected database 
fp growth efficient scalable treeprojection especially number frequent itemsets really large 
observations analyses supported experiments reported section 
chapter 
fp growth pattern growth method summary chapter proposed novel data structure frequent pattern tree fp tree storing compressed crucial information frequent patterns developed pattern growth method fp growth efficient mining frequent patterns large databases 
advantages fp growth approaches 

constructs highly compact fp tree usually substantially smaller original database saves costly database scans subsequent mining processes 

applies pattern growth method avoids costly candidate generation test successively concatenating frequent itemset conditional fp trees 
ensures generates combinations new candidate sets database itemset transaction encoded corresponding path fp trees 
context mining apriori restricted generation test frequent pattern fragment growth 
major operations mining count accumulation prefix path count adjustment usually costly candidate generation pattern matching operations performed apriori algorithms 

applies partitioning divide conquer method dramatically reduces size subsequent conditional pattern bases conditional fp trees 
optimization techniques including direct pattern generation single tree path employing frequent events suffix contribute efficiency method 
implemented fp growth method studied performance comparison influential frequent pattern mining algorithms large databases 
formance study shows method mines short long patterns efficiently large databases outperforming current candidate pattern generation algorithms 
fp growth method implemented new version dbminer system tested large industrial databases london drugs databases satisfactory performance 
lot interesting research issues related fp tree mining includ ing study implementation sql highly scalable fp tree structure chapter 
fp growth pattern growth method constraint mining frequent patterns fp trees extension fp tree mining method mining sequential patterns closed patterns max patterns bay partial periodicity interesting frequent patterns 
addressed chapters 
chapter mine scalable space preserving mining chapter developed fp growth pattern growth method frequent pattern min ing 
fp growth efficient apriori cases may encounter difficulties cases illustrated 
huge space required serve mining 
fp growth avoids candidate generation compressing transaction database fp tree pursuing partition mining recursively 
database huge sparse fp tree large space requirement recursion challenge 
real databases contain cases 
real data sets sparse dense different applications 
example telecommunication data analysis calling pat terns home users vs business users different frequent dense family members close friends huge sparse 
similar situations arise market basket analysis census data analysis classification predictive modelling hard select appropriate mining method fly algorithm fits 
large applications need scalability 
existing methods efficient data set large 
core data structures fp tree intermediate results set candidates apriori recursively generated conditional databases fp growth may fit main memory easily chapter 
mine scalable space preserving mining cause thrashing 
poses new challenge better method efficient occasions dense vs sparse huge vs memory data sets space requirement small large databases chapter propose new data structure struct new mining method mine overcome difficulties 
major feature mine space preserving meaning mine moderate memory usage fully utilize available main memory space necessary performs small main memory 
progress 

memory efficient pattern growth algorithm mine mem proposed mining frequent patterns data sets fit main memory 
simple memory hyper structure struct designed fast mining 

show theoretically mine mem polynomial space usage space efficient fp growth treeprojection mining sparse data sets efficient apriori methods generate large number candidates 
experimental results show mine mem exactly predictable space overhead cases faster memory apriori fp growth limited space usage 

mine mem propose mine scalable algorithm mining large databases partitioning database mining partition memory mine mem consolidating global frequent patterns 

dense data sets mine integrated fp growth dynamically detecting swapping condition constructing fp trees efficient mining 

efforts ensure mine scalable large medium sized databases sparse dense data sets 
comprehensive performance study con firms mine highly scalable faster apriori fp growth occasions 
remainder chapter organized follows 
section devoted mine mem efficient algorithm memory frequent pattern mining 
section chapter 
mine scalable space preserving mining mine mem extended huge disk databases optimization techniques 
performance study reported section 
discuss related issues conclude chapter section 
mine mem memory hyper structure mining section mine mem memory hyper structure mining frequent patterns developed section method extended handle large dense databases 
general idea mine mem general idea mine mem illustrated example 
example columns table running transaction database db 
minimum support threshold min sup 
transaction id items frequent item projection table transaction database db running example 
apriori property theorem frequent items play roles frequent patterns 
scanning db complete set frequent items output notation means item support occurrence frequency 
freq frequent item projection set frequent items itemset ease explanation frequent item projections transactions table shown third column table 
alphabetical order frequent items called list complete set frequent patterns partitioned subsets follows containing item containing item item containing item item ordering alphabetical ordering just convenience explanation 
chapter 
mine scalable space preserving mining containing item item containing item shown 
patterns having mine proj db local freq 
items patterns tdb freq items patterns having mine proj db pattern patterns having patterns having pattern ae mine ac proj db mine ad proj db local freq 
items local freq 
item pattern ac pattern acd pattern ad pattern ade patterns having mine proj db divide conquer tree frequent patterns 
patterns having mine proj db pattern frequent item projections transactions database held main memory organized shown 
items frequent item projections sorted list 
example frequent item projection transaction listed 
occurrence frequent item stored entry fields item id hyper link 
frequent projections header table struct hyper structure storing frequent item projections 
header table created frequent item entry fields item id support count hyper link 
frequent item projections loaded memory item order list linked chapter 
mine scalable space preserving mining hyper links queue entries header table act heads queues 
example entry item header table head queue links frequent item projections transactions 
projections item frequent item order list 
similarly frequent item projection transaction linked queue headed item queues empty frequent item projection begins items 
clearly takes scan second scan transaction database db build memory structure called struct 
remaining mining performed struct referencing information original database 
subsets frequent patterns mined follows 
consider find set frequent patterns subset frequent patterns containing item requires search frequent item projections containing item projected database denoted db interestingly frequent item projections projected database linked queue traversed efficiently 
mine projected database header table ha created shown 
ha frequent item entry fields item id support count hyper link 
support count ha records support corresponding item projected database 
example item appears twice projected database frequent item projections queue support count entry ha 
traversing queue set locally frequent items items appearing twice projected database note locally frequent considered 
scan outputs frequent patterns ac ad ae builds links ha header shown 
set frequent patterns containing item partitioned subsets pattern containing containing containing pattern ae 
divide conquer tree frequent patterns shown 
subsets mined follows 
projected database consists frequent item projections containing item virtual projections physical projections performed create new database 
chapter 
mine scalable space preserving mining header table frequent projections header table ha header table ha ac queue 

subset contains frequent pattern 
queue traversed recursively find frequent patterns containing frequent item projections local frequent item linked hyper links queue entries header table ha act heads queues 
frequent item projections transactions added ac queue order 
transaction added ad queue 
moment ae queue empty 
situation shown 
process continues recursively ac projected database examining queue ha 
process creates ac header table hac shown 
header table header table ha frequent projections header table hac header table hac 
item locally frequent item ac projected database acd output search path completed 
chapter 
mine scalable space preserving mining 
recursion backtracks find frequent patterns containing queue started header table ha ad queue links frequent item projections containing items excluding item projection get complete ad projected database inserting frequent item projections having item ac queue ad queue 
involves traversal ac queue 
frequent item projection ac queue appended queue frequent item projection list 
frequent item projections ac queue item inserted ad queue shown 
header table frequent projections header table ha header table ha ad queue 
seen adjustment ad queue collects complete set frequent item projections containing items set frequent patterns containing items mined recursively 
please note item appears frequent item projections ad projected database consider locally frequent item recursive projected database considered mining ac queue 
mining generates pattern ade 
notice third level header table table hac search hac done previous round 
need header table third level 
see header table needed level mining process 

transaction ae projected database frequent pattern projected database ae 
search terminates 
chapter 
mine scalable space preserving mining frequent patterns containing item transactions projected database queue projected projected databases 
queue includes frequent item projections containing item projections containing items queue 
mine frequent patterns containing item subsets frequent patterns need insert projections queue proper queues 
traverse queue 
frequent item projection queue appended queue item projection list shown 
example frequent item projection inserted queue inserted queue 
frequent projections header table adjusted hyper links mining projected database 
mining projected database recursively shared header table level find set frequent patterns containing item notice item included projected database frequent patterns having 
similarly mining goes 
section verify mining process finds complete set frequent patterns duplication 
remaining mining process left exercise interested readers 
notice depth search mining set frequent patterns depth done database scan constructing header tables levels simultaneously 
chapter 
mine scalable space preserving mining mine mem algorithm memory hyper structure mining summarize justify mining process shown example 
transaction database db support threshold min sup set frequent items 
list list frequent items global order frequent items 
denote list 
example list example 
frequent item projections transactions db organized struct defined 
struct contains set frequent item projections transaction database 
item frequent item projection represented entry fields item id hyper link 

struct header table 
header table array frequent items order list 
support count hyper link attached item header table 

struct created items header table heads queues frequent item projections linked hyper links 
hyper structure shown example struct 
struct lemma 
lemma struct transaction database db support threshold min sup list 

struct unique considering order frequent item projections queues frequent item projections 

space requirement struct db freq freq projection transaction constant 

scans transaction database needed build struct 
proof 
transaction struct stores frequent item projection 
frequent item projections struct stores header table 
maximal number entries chapter 
mine scalable space preserving mining table number frequent items size entry fixed 
space needed struct 
space requirement shown formula item 
remaining part lemma follows definition struct immediately 
transaction database db list complete set frequent patterns partitioned series subsets overlap stated lemma 
lemma partition search space transaction database db sup port threshold min sup list 
xn list frequent items 
complete set frequent patterns partitioned subsets overlap follows th subset contains patterns having item xk item xi 
proof 
frequent pattern 
sort items list 
exists xk item pattern belongs th subset 
hand suppose belongs th subset loss generality suppose th subset requires contain item xk contain xk 
leads contradiction 
mine subsets frequent patterns introduce concept projected database 
frequent pattern 
projected database collection frequent item projections containing pattern denoted db clearly mine th subset frequent patterns lemma need look xk projected database db xk ignore occurrences items xi 
struct facilitate construction projected databases 
lemma 
lemma projected databases transaction database db support thresh old min sup list 
xn list frequent items 
struct 
projected database queue header table 

projected database queue header table frequent item projections starting item queue 

general xk projected database xk queue header table frequent item projections starting xk xi queues 
chapter 
mine scalable space preserving mining proof 
lemma follows definitions struct projected databases 
lemma find complete set frequent patterns containing queue available struct 
conceptually treat queue frequent item projections projected database sub struct apply techniques recursively 
find locally frequent items partition subset frequent patterns doing recursive mining 
storage frequent item projections struct shared 
need new header table form queues projected database 
insert frequent item projections queue starting item queue header table form complete projected database 
projections exclude projected database starting find complete set frequent patterns containing item item 
similarly find complete set frequent patterns 
reason ing algorithm 
algorithm mine mem main memory hyper structure mining frequent patterns 
input transaction database db support threshold min sup 
output complete set frequent patterns 
method 
scan db find output set frequent items 
list 
xn list frequent items 

scan db construct struct header table xi queue linked corresponding entry 
call mine xi list traverse xi queue header table frequent item projection link xj queue header table xj item xi immediately 
chapter 
mine scalable space preserving mining procedure mine list frequent pattern note frequent item projections projected database linked queue header table 
traverse queue find output locally frequent items derive xj 
xj 
note items list located right considered 
items follow order list 

construct header table hp scan projected database frequent item projection projected database hyper link xji link xji queue header table hp xji locally frequent item 
call mine xji hp 
traverse xji queue header table hp frequent item projection link xjk queue header table hp xjk item xji immediately list 
analysis 
correctness completeness algorithm shown induction enumeration frequent patterns lemma 
lemma guarantees properly adjusting hyper links algorithm correctly finds subsets patterns right projected database 
space usage mine mem analyze space usage algorithm 
shown lemma space usage constructing struct db freq constant 
mine struct space overhead set local header tables 
glance number header tables scale frequent patterns 
close look algorithm finds limited number header tables exist simultaneously 
example find pattern bcde chapter 
mine scalable space preserving mining header tables prefixes hb hbc needed 
header tables freed generated 
header tables patterns item freed patterns having item pattern bcde 
hand header tables patterns need generated moment 
number header tables maximal length single frequent pattern 
lemma 
lemma number header tables maximum number header tables needed hyper structure mining frequent patterns 
mine mem max length single frequent pattern 
maximal length single frequent pattern exceed maximal length transaction general maximal length transaction smaller number transactions theorem space usage mine mem 
theorem space usage space usage algorithm db freq freq frequent item projection transaction constant 
proof 
shown lemma space requirement struct db freq space required remaining set header tables smaller struct worst case scale struct maximal length transaction db 
comparing frequent pattern mining methods efficiency mine mem comes aspects 

mine mem avoids candidate generation test adopting frequent pattern growth methodology 
mine mem absorbs advantages pattern growth 

mine mem confines search dedicated space 
fp growth need physically construct memory structures projected databases 
fully utilizes information organized struct collects information projected databases header tables light weight structures 
saves lot efforts managing space 
chapter 
mine scalable space preserving mining 
mine mem need store frequent patterns memory 
fre quent pattern output disk 
contrast candidate generation test method save frequent patterns current round generate candidates round 
analysis verified extensive performance study section mine mem mine efficient mining dif ferent occasions section extend algorithm mine mem mine mines frequent patterns large data sets fit main memory 
explore integrate fp growth data sets mined dense 
mine mining frequent patterns large databases mine mem efficient frequent item projections transaction database plus set header tables fit main memory 
expect case 
fit memory database partitioning technique developed follows 
db transaction database transactions min sup support threshold 
scanning db find set frequent items 
db partitioned parts db 
dbi frequent item projections transactions dbi held main memory dbi ni transactions ni apply mine mem dbi find frequent patterns dbi minimum support threshold min min sup ni partitioned database keeps relative minimum support global database 
fi set locally frequent patterns dbi 
property partition mining son globally frequent pattern db respect support threshold min sup exists fi :10.1.1.103.5437
mining frequent patterns dbi gather chapter 
mine scalable space preserving mining patterns fi collect global support db scanning transaction database db time 
observation extend mine mem mine follows 
algorithm mine hyper structure mining frequent patterns large databases 
input output algorithm 
method 
scan transaction database db find complete set frequent items 

partition db parts db 
dbi frequent item projections dbi held main memory 

mine mem mine frequent patterns dbi respect minimum support threshold min min sup ni ni numbers transactions db dbi respectively 
fi set frequent patterns dbi 

fi 
scan db time collect support patterns output patterns pass minimum support threshold min sup 
important issue algorithm partition database 
analyzed section space cost mine mem incurred header tables 
maxi mal number header tables space requirement predictable usually small comparison size frequent item projections 
reserving space header tables remaining main memory build struct covers transactions possible 
practice estimate size available main memory mining size frequent item projected database scale sum support counts frequent items partition database relatively avoid generation skewed partitions 
note partition mining method shares similarities parti tioned apriori method proposed savasere son :10.1.1.103.5437
transaction database partitioned 
partition mined apriori 
locally frequent patterns gathered form set globally frequent candidate patterns 
global supports counted scan transaction database 
essential differences method 
chapter 
mine scalable space preserving mining 
indicated son easy get partition scheme partitioned apriori son hard predict space requirement apriori :10.1.1.103.5437
contrast straightforward mine partition transaction database space overhead small predictable mining 

mine finds globally frequent items 
mining partitions database mine examines items globally frequent 
skewed partitions globally infrequent items locally frequent partitions mine spend effort check partitioned apriori son :10.1.1.103.5437
furthermore better consolidating globally frequent patterns local ones 
mining large transaction database database partitioned relatively expected short globally frequent patterns frequent parti tion 
case pattern frequent partition globally frequent pattern global support count sum counts partitions 
mine need test patterns third scan 
third scan mine checks locally frequent patterns infrequent partitions 
furthermore pattern checked partitions infrequent 
illustrate idea example 
example large transaction database db partitioned parts 
support threshold 
parts mined respectively mine mem 
locally frequent patterns partition ids frequent shown table 
accumulated support count pattern sum support counts partitions pattern locally frequent 
local frequent pattern partitions accumulated support count ab ac ad abc abcd table local frequent patterns partitions 
chapter 
mine scalable space preserving mining 
pattern ab frequent partitions 
globally frequent 
global support count accumulated support count 
patterns ac ad 

pattern abc frequent partitions 
accumulated support count abc covers occurrences pattern partitions 
pattern checked 
global support count abc accumulated count plus support count 
similarly pattern abcd need checked partitions 

third scan mine scanning partition suppose support count pattern abcd partition 
abcd frequent partition support count local support threshold 
local support threshold need check pattern abcd partition abcd hope globally frequent 
seen example optimization methods con globally frequent patterns 

accumulate global support count local ones patterns frequent partition 

check patterns partitions infrequent 

local support thresholds derive upper bounds global support counts locally frequent patterns 
check patterns upper bound pass global support threshold 
optimization number patterns consolidated re duced dramatically 
shown experiments data set relatively evenly distributed locally frequent patterns checked third scan mine 
general factors contribute scalability efficiency mine 
analyzed section mine mem small space overhead efficient mining partitions held main memory 
current memory technology medium sized databases mined efficiently memory frequent pattern mining mechanism 
chapter 
mine scalable space preserving mining matter large database mined scans database scan finds globally frequent items second mines parti tioned database mine mem third verifies globally frequent patterns 
partition mined efficiently mine mem mining database highly scalable 
may wonder partitioned apriori son takes scans db mine takes scans mine outperform proposed son :10.1.1.103.5437
notice major cost process mining partitioned database 
scan db collecting supports generating globally fre quent patterns fast set locally frequent patterns inserted compact structure hashing tree 
mine generates partitions mines partition fast better performance apriori partition mining algorithm 
demonstrated performance study 
handling dense data sets dynamic integration struct fp tree mining indicated studies bag finding frequent patterns dense databases challenging task may generate dense long patterns may lead generation large exponential number candidate sets apriori algorithm 
fp growth method proposed study works dense databases large number long patterns due effective compression shared prefix paths mining 
comparison fp growth mine generate physical projected databases conditional fp trees saves space time cases 
fp tree mining advantages mining struct fp tree shares common prefix paths different transactions may lead space time savings 
may expect situation method outperforms depends characteristics data sets data sharing rare sparse databases compression factor small fp tree may outperform mining struct 
hand dense data sets practice 
data sets dense originally mining progresses projected databases smaller data denser relative support goes number transactions chapter 
mine scalable space preserving mining projected database reduces substantially 
cases beneficial swap data structure struct fp tree fp tree compression common prefix path sharing mining compressed structures benefits brought struct 
question appropriate situations structure preferable determine structure algorithm swapping happen 
dynamic pattern density analysis technique suggested follows 
context frequent pattern mining projected database dense frequent items high relative support 
relative support computed follows relative support absolute support tran freq item projections projected database relative support high projected database dense number locally frequent items large resulting fp tree bushy fp tree constructed explore sharing common prefix paths database compression 
hand relative support frequent items low far sparse struct constructed efficient mine 
relative support values clear method efficient 
discussion see algorithm mine modified follows 
step algorithm mines frequent patterns partition dbi mine mem called 
simply constructing struct mining struct iteratively till mine mem analyze basic characteristics data determine struct constructed utilized subsequent mining fp trees constructed frequent pattern growth 
performance study experimental results evaluate efficiency scalability mine performed extensive formance study 
section report experimental results performance mine comparison apriori fp growth 
shows mine outperforms chapter 
mine scalable space preserving mining apriori fp growth efficient highly scalable mining large databases 
experiments performed mhz pentium pc machine megabytes main memory hard disk running microsoft windows nt 
mine fp growth implemented visual version apriori known version gnu lesser general public license available fuzzy cs uni magdeburg de borgelt 
reports runtime mine include time constructing struct mining frequent patterns 
include cpu time time 
tested various data sets consistent results 
limited space results typical data sets reported 
mining transaction databases main memory sub section report results mining transaction databases held main memory 
mine implemented stated section 
fp growth fp trees held main memory tests reported sub section 
modified source code apriori transactions loaded main memory multiple scans database pursued main memory 
data set gazelle sparse data set 
web store visit click stream data set gazelle com 
contains transactions item transaction 
shows run time mine apriori fp growth data set 
clearly mine wins algorithms gaps term seconds larger support threshold goes lower 
apriori works sparse data sets candidates apriori generates turn frequent patterns 
construct hashing tree candidates match tree update counts time scanning transaction contains candidates 
major cost apriori 
fp growth similar performance apriori slightly worse 
database sparse fp tree compress data effectively dense data sets 
constructing fp trees sparse data sets recursively overhead 
prototype mine tested third party commercial business data 
results consistent 
observed mine times faster apriori participating methods test support threshold low 
chapter 
mine scalable space preserving mining runtime seconds apriori fp growth mine support threshold runtime data set gazelle 
plots high water mark space usage mine apriori fp growth mining procedure 
comparison clear space usage axis logarithmic scale 
see mine fp growth similar space scalable term space usage respect support threshold 
support threshold reduces low memory usage stable moderate 
memory usage apriori scale support threshold goes 
apriori store level wise frequent patterns generate level candidates 
support threshold low number frequent patterns candidates non trivial 
contrast pattern growth methods including mine fp growth need store frequent patterns candidates 
pattern output immediately read back 
performance algorithms dense data sets 
synthetic data set generator described generate data set 
data set generator studies frequent pattern mining 
refer readers details data set generation 
data set contains transactions transaction items 
items data set average longest potentially frequent chapter 
mine scalable space preserving mining space kb apriori fp growth mine support threshold space usage data set gazelle 
itemset items 
relatively dense data set 
shows runtime algorithms data set 
support threshold high patterns short lengths apriori fp growth similar performance 
support threshold low items frequent 
fp growth faster apriori 
cases mine fastest 
times faster apriori times faster fp growth 
shows high water mark space usage algorithms mining data set 
space usage drawn logarithmic scale 
number pat terns goes dramatically support threshold goes apriori requires exponential amount space 
mine fp growth stable amount space 
dense data set fp tree smaller set frequent item projections data set 
long patterns means recursions recursive fp trees 
fp growth require space mine case 
hand number fre quent items large data set fp tree compressing database branches various levels bushy 
introduces non trivial tree browsing cost 
explore runtime frequent pattern data sets gazelle chapter 
mine scalable space preserving mining runtime seconds apriori fp growth mine support threshold runtime data set 
respectively 
support threshold goes number frequent patterns goes 
seen figures runtime pattern algorithms keeps going 
explains scalability algorithms 
algorithms mine runtime pattern best performance especially support threshold low 
figures illustrate mine scalable respect number frequent patterns 
dense data set connect uc irvine pumsb ibm almaden research center mine builds fp trees numbers frequent items small 
performance fp growth 
previous studies bay show apriori incapable mining data sets 
mining large databases test efficiency scalability algorithms mining large databases generate data set synthetic data generator 
www ics uci edu mlearn mlrepository html www almaden ibm com cs quest demos html chapter 
mine scalable space preserving mining space kb apriori fp growth mine support threshold space usage data set 
transactions similar statistic features data set 
enforce memory constraints mine total memory available limited megabytes respectively 
memory covers space struct header tables related mechanisms 
fp tree built data set big fit main memory report performance fp growth data set 
explicitly compose memory constraint apriori 
shows scalability mine main memory size constraint megabytes apriori respect number transactions database 
various support threshold settings tested 
algorithms linear scalability mine clear winner 
see mine efficient scalable mining large databases 
study effect memory size constraint mining efficiency scalability mine large databases plot 
shows scalability mine respect support threshold various memory constraints megabytes respectively 
shown runtime sensitive memory limitation support threshold high 
support threshold goes available space increases performance gets better 
chapter 
mine scalable space preserving mining runtime pattern seconds pattern apriori fp growth mine support threshold runtime pattern data set gazelle 
shows effect available memory size mining large data sets 
high support level performance sensitive available memory size number partitions 
support threshold low memory size plays important role performance 
high support threshold number frequent patterns small frequent patterns short 
dominant cost cost insensitive size available memory 
support threshold low larger available memory mine partitions generates fewer locally frequent patterns locally frequent pat terns contain globally frequent ones noise 
mine run faster memory 
results show mine fully utilize available memory scale mining process 
mine check locally frequent patterns database third scan database 
fortunately answer 
experimental results show mine light workload third scan 
consider ratio number patterns checked third scan distinct locally frequent patterns locally frequent pattern checked third scan frequent partition 
shows ratio numbers 
general chapter 
mine scalable space preserving mining runtime pattern seconds pattern apriori fp growth mine support threshold runtime pattern data set 
support threshold goes ratio goes 
means mining low support threshold may lead patterns frequent partitions 
hand memory small partition leads partitions increase ratio 
shown limited portion locally frequent patterns test case needs tested third scan 
leads low cost third scan partition mining 
implemented partition apriori method 
partitioned apriori cuts database partitions exactly mine 
uses main memory apriori mine partition 
apply main memory constraint candidate generation available memory store candidates level wise frequent patterns wants 
partitioned apriori better performance apriori support threshold low lose mine wide margin 
limited space omit detailed performance report partitioned apriori 
summary experimental results performance study verify analysis support claim mine efficient algorithm mining frequent patterns 
highly scalable mining large databases 
chapter 
mine scalable space preserving mining runtime seconds summary apriori apriori apriori apriori mine mine mine mine number transactions thousands scalability respect number transactions 
chapter proposed simple novel hyper linked data structure struct new frequent pattern mining algorithm mine takes advantage struct data structure dynamically adjusts links mining process 
shown perfor mance study mine high performance scalable kinds data limited predictable space overhead outperforms previously developed algorithms various settings 
section discuss mine high performance impact new method 
major distinction mine previously proposed methods mine re adjusts links mining different projected databases small space overhead counting temporary working space candidate generation test generate test large number candidate itemsets fp growth generate number conditional projected databases fp trees 
structure space preserving philosophy mine promotes sharing existing structures mining reduces cost copying large amount data building new data structures chapter 
mine scalable space preserving mining runtime seconds apriori mine mb mem mine mb mem mine mb mem mine mb mem support threshold scalability mine large data set 
data reduces cost updating checking data structures 
second mine absorbs nice features fp growth 
essentially frequent pattern growth approach partitions search space patterns data divide conquer methodology generating testing candi date patterns 
fp growth mine create physical projected databases constructing conditional local fp trees 
builds adjusts links dynamically frequent items mining achieve effect construc tion physical projected databases 
avoids paying cost space time projected database re construction better performance fp growth 
third mine confined struct 
watches carefully changes data characteristics mining dynamically switches data structure struct fp tree mining algorithm mining struct fp growth data set dense number frequent items small 
absorbs benefits fp growth explores data compression prefix path shared mining 
mining struct mining fp tree built frequent pattern growth methodology dynamic algorithm swapping performed naturally easily 
chapter 
mine scalable space preserving mining runtime seconds min sup min sup min sup min sup memory size mb effect memory size mining large data set 
fourth mine scaled large databases due small precisely predictable run time memory overhead database partition mining technique 
mine partitions large database set relatively uniform sized partitions mines partition mine mem 
mining partition main memory highly efficient mined patterns shared uniformly partitioned databases reduce effort pattern matching additional database scan cost far proposed methods demonstrated performance study 
analysis see mine represents new highly efficient scalable mining method 
structure space preserving mining methodology may strong impact development new efficient scalable data mining methods mining kinds patterns closed itemsets max patterns bay sequential patterns sa constraint mining interesting direction study :10.1.1.27.6266
chapter 
mine scalable space preserving mining patterns checked rd scan mb mem mb mem mb mem mb mem support threshold ratio patterns checked mine third scan 
chapter constraint pattern growth mining chapters developed efficient pattern growth methods mine frequent patterns large databases 
applications need efficient effective frequent pattern mining techniques 
cases frequent pattern mining may return patterns users understand process 
integrating users interests frequent pattern mining important issue 
highlighted importance constraint mining paradigm user allowed express focus mining means rich class constraints capture application semantics 
allowing user exploration control paradigm allows constraints pushed deep mining confining search patterns users interest improving performance 
metarules various kinds templates proposed filters define forms rules mined kmr sva 
itemset constraints incorporated association mining sva 
systematic method incorporation large classes constraints anti monotone succinct frequent itemset mining 
method mining association rules large dense databases incorporating user specified constraints ensure mined rule offers predictive advantage cations developed bag 
constraints specified regular expressions sequential pattern mining grs 
constraint mining correlations exploration anti monotonicity succinctness monotonicity studied chapter 
constraint pattern growth mining glw 
previous studies cover large class useful constraints useful natural constraints considered 
example consider constraints avg median sum anti monotone monotone succinct 
anti monotone items non negative values 
contains items arbitrary values sum constraints 
intuitively implies constraints hard optimize 
chapter investigate class constraints subsumes examples 
main idea certain constraints exhibit nice properties general may presence certain item ordering 
contributions 
introduce section concept convertible constraints classify classes convertible anti monotone convertible monotone strongly convert ible 
covers number useful constraints previously regarded tough including examples 
characterize section class convertible constraints notion prefix monotone functions study arithmetical closure properties functions 
byproduct show class constraints involving arithmetic convertible 
example show max avg convertible anti monotone median min convertible monotone 
show convertible constraints pushed deep basic apriori framework 
pushed deep frequent pattern growth mining 
develop section algorithms fast mining frequent itemsets satis fying various constraints 
discuss section multiple convertible constraints incorporated fast frequent pattern mining 
report results detailed set experiments show effectiveness algorithms developed section 
study distinguishes previous works constraint frequent pattern mining aspects 
chapter 
constraint pattern growth mining argued previous works constraint frequent pattern mining relied properties anti monotonicity succinctness monotonicity glw handle constraints studied chapter 
studies constraint search algorithms artificial web 
study distinguished theirs aspects find complete set frequent itemsets satisfying constraints algorithms find feasible solutions satisfying constraints ii goal find methods scalable large databases algorithms main memory 
section motivates problem frequent itemset mining constraints 
sec tion concludes chapter 
problem definition frequent itemset mining con straints constraint predicate powerset set items true false 
itemset satisfies constraint true 
set itemsets satisfying constraint true 
call itemset valid 
problem definition 
transaction database support threshold set constraints problem mining frequent itemsets constraints find complete set frequent itemsets satisfying find fc sup 
kinds constraints associated frequent itemset mining 
cat egories constraints succinctness anti monotonicity proposed third category monotonicity studied bms glw ph contexts mining correlated sets frequent itemsets 
briefly recall tions 
definition anti monotone monotone succinct constraints constraint ca anti monotone itemset violates ca superset constraint cm monotone itemset satisfies cm superset succinctness defined steps follows 
chapter 
constraint pattern growth mining itemset succinct set expressed selection predicate selection operator 
sp succinct powerset fixed number succinct sets 
ik sp expressed terms strict powersets 
ik union minus 
constraint cs succinct provided succinct powerset 
show result 
theorem succinct constraint involving aggregate functions expressed conjunction disjunction monotone anti monotone constraints 
proof 
proof theorem induction structure succinct constraint definition succinctness 
essential cases follows 
ic ic set anti monotone constraint pattern satisfying constraint subset ic 
ic ic expressed terms corresponding anti monotone constraints 
constraint expressed conjunction constraints ca cm ca anti monotone constraint corresponding cm monotone constraint 
especially im monotone constraint im 
categories constraints cover large class popularly encountered con straints 
representative subset commonly sql constraints listed table useful constraints avg sum shown table belong classes 
example table running transaction database set items 
support threshold 
itemset acd frequent brevity show small subset representative constraints involving aggregates 
see details 
chapter 
constraint pattern growth mining constraint anti monotone monotone succinct min min max max count weakly count weakly sum sum sum range range avg sup sup table characterization commonly sql constraints 
transaction id items transaction table transaction database example 
transactions respectively 
complete set frequent itemsets listed table 
length frequent itemsets ac ad af bc bd bf cd ce cf cg df ef fg acd acf adf bcd bcf bdf cdf cef cfg table frequent itemsets support threshold transaction database table 
item attribute value profit concrete value shown table 
constraints sum implicitly refer value 
constraint range requires itemset value range items greater 
anti monotone constraint sense itemset say ab violates constraint supersets violate ab removed safely candidate set apriori frequent itemset mining chapter 
constraint pattern growth mining item value table values profit items example 
process 
constraint avg anti monotone monotone succinct verified readers 
example avg df violates constraint 
adding item avg adf adf satisfies 
example scratches surface large class useful constraints involving avg median arithmetic 
exploiting mining calls new techniques subject chapter 
convertible constraints classification introducing concept convertible constraint motivate example 
example suppose wish mine frequent itemsets transaction database table support threshold constraint avg complete set frequent itemsets satisfying obtained mining frequent itemsets constraint table filtering satisfying constraint 
constraint anti monotone monotone succinct directly incorporated apriori style algorithm 
itemset fg satisfies constraint subset superset dfg 
arrange items value descending order observe interesting property follows 
writing itemsets order leads notion prefix 
afd af prefixes 
interestingly average itemset prefix order 
chapter 
constraint pattern growth mining convertible constraints observation example motivates definition 
frequently order set items assume itemsets written order 
definition prefix itemset order set items itemset il called prefix itemset im items itemsets listed order 
called proper prefix 
formalize convertible constraints follows 
definition convertible constraints constraint convertible anti monotone provided order items itemset satisfies prefix convertible monotone provided order items itemset violates prefix constraint convertible convertible anti monotone monotone 
note anti monotone resp monotone constraint trivially convertible anti monotone resp convertible monotone just pick order items 
example show avg convertible constraint 
value descending order 
itemset satisfying constraint avg items listed order pre fix ak ak ak avg avg ak avg implies satisfies con straint 
constraint avg convertible anti monotone 
similarly shown constraint avg convertible monotone 
interestingly order reversed order constraint avg shown convertible monotone 
leave exercise reader 
summary constraint avg convertible constraint 
furthermore exists order constraint convertible anti monotone convertible monotone stated order chapter assumed total set items 
chapter 
constraint pattern growth mining example examine constraints function sum 
example shown table constraint sum anti monotone items non negative values 
items negative zero positive values constraint anti monotone monotone succinct 
interestingly constraint exhibits piecewise convertible monotone anti monotone behavior 
constraint constraint convertible anti monotone item value ascending order 
itemset sum items listed value ascending order 
prefix aj aj means aj aj 
sum hand aj aj aj sum sum sum aj sum cases means satisfies constraint 
constraint convertible monotone item value descending order 
leave reader verify 
similarly show items negative zero positive values constraint sum convertible monotone value ascending order convertible anti monotone value descending order 
lemma proved straightforward induction 
lemma constraint set items 
convertible anti monotone exists order itemset item implies 

convertible monotone exists order itemset item implies 
proof 
show part lemma 
second part shown similarly 
part suppose constraint property itemset item item implies 
itemset am prefix sk itemset ak 
sm am true implies sm true 
induction show sl true 
convertible anti monotone 
part convertible anti monotone constraint definition convertible anti monotonicity property holds itemset item item implies 
chapter 
constraint pattern growth mining notion prefix monotone functions introduced helpful determining class constraint 
denote set real numbers definition prefix monotone functions order set items function prefix monotonically increasing function itemset prefix 
function called prefix monotonically decreasing function itemset prefix 
lemma determination prefix monotone functions 
proof similar lemma 
lemma order set items 
function prefix decreasing function itemset item 

function prefix increasing function itemset item 
proof 
show part lemma 
second part proved similarly 
prefix decreasing function 
itemset prefix ra 
definition prefix decreasing function 
suppose function property itemset item 
itemset am prefix am 
prefix decreasing function 
turns prefix monotone functions satisfy interesting closure properties arithmetic 
understanding shed light characterizing class convertible functions involving arithmetic 
theorem establishes cal closure properties prefix monotone functions 
say function positive provided 
theorem prefix decreasing functions prefix increasing functions order respectively 
positive real number 
chapter 
constraint pattern growth mining 
functions prefix increasing functions 
functions prefix decreasing functions 

positive functions prefix decreasing prefix increasing 

constraint resp convertible anti monotone resp mono tone prefix decreasing 
similarly resp convertible monotone resp anti monotone prefix increasing 
proof 
theorem follows related definitions immediately 
example illustration notice avg prefix decreasing function value descending order avg convertible anti monotone order 
max prefix increasing function order 
theorem follows avg prefix increasing max avg prefix increasing 
con immediately deduce max avg convertible anti monotone order 
know theorem succinct constraint expressed terms conjunction disjunction anti monotone monotone constraints 
definition monotone anti monotone 
natural question rela succinct constraints convertible constraints 
theorem settles question 
theorem succinct constraint anti monotone monotone convert ible 
proof 
proof theorem induction structure succinct constraint definition succinctness 
suppose succinct constraint set items 
fc ic ic shown theorem constraint anti monotone 
interestingly convertible monotone order ic ic prefix decreasing order 
assuming items non negative values 
chapter 
constraint pattern growth mining fc constraint anti monotone theorem 
convertible monotone case 
fc constraint convertible anti monotone order please note convertible monotone especially fc im 
im constraint monotone theorem 
example consider succinct constraint solution space de scribed ii pi pi selection predicate 
consider order items come item items ordered arbitrarily 
easy see convertible anti monotone convertible monotone 
strongly convertible constraint convertible constraints additional desirable property order convertible anti monotone inverse convertible mono tone 
avg convertible monotone value ascending order convertible anti monotone value descending order see example 
property provides great flexibility data mining query optimization 
definition strongly convertible constraint constraint csc called strongly convertible constraint provided exists order set items csc convertible anti monotone convertible monotone notice median strongly convertible 
clearly convertible constraint strongly convertible 
max avg convertible anti monotone value descending order items non negative value 
convertible monotone value ascending order 
lemma links strongly convertible constraints prefix monotone functions 
says proportion max price item itemset average price items set go certain limit 
chapter 
constraint pattern growth mining lemma constraint strongly convertible exists order set items prefix decreasing function prefix increasing function proof 
lemma follows theorem immediately 
example avg median prefix decreasing value descending order prefix increasing value ascending order 
exist constraints pushed item ordering 
example constraint avg median admit natural ordering items convertible 
call constraints 
summary classification constraints general picture constraints involving aggregate functions classified categories interactions frequent itemset mining process anti monotone monotone succinct convertible turn vided convertible anti monotone convertible monotone 
intersection categories precisely class strongly convertible constraints treated convertible anti monotone monotone ordering items properly 
shows relationship various classes constraints 
convertible anti monotone anti monotone strongly convertible succinct monotone convertible monotone classification constraints relationships commonly convertible constraints listed table 
constraint requires median item itemset equal average value 
chapter 
constraint pattern growth mining constraint convertible convertible strongly anti monotone monotone convertible avg median sum sum sum sum prefix decreasing function prefix increasing function prefix decreasing function prefix increasing function table characterization commonly sql convertible constraints 
means depends specific constraint 
mining algorithms section explore mine frequent itemsets convertible constraints ef 
general idea push constraint mining process deep possible pruning search space 
section argue apriori algorithm extended mining convertible constraints efficiently 
new method proposed examining example 
section presents algorithm fic mining frequent itemsets convertible anti monotone constraints 
algorithm fic computes complete set frequent itemsets convertible monotone constraint section 
section discusses mining frequent itemsets strongly convertible constraints 
mining frequent itemsets convertible constraints example show convertible constraints pushed deep apriori mining 
convertible constraint monotone anti monotone succinct pushed deep apriori mining algorithm 
rationale 
observed earlier constraint avg subsets supersets valid itemset invalid vice versa 
level wise framework direct pruning constraint 
particular invalid chapter 
constraint pattern growth mining subset eliminated support counting supersets suffixes pruned frequency 
example itemset df running example violates constraint avg 
apriori algorithm prune itemsets 
superset adf satisfies constraint generated 
giving algorithms mining convertible constraints give overview example 
example mine frequent itemsets constraint avg trans action database table support threshold 
items itemset listed value descending order shown constraint convertible anti monotone mining process shown 
scanning find support counts item 
appears transaction infrequent items dropped consideration 
set frequent itemsets listed order satisfy constraint convertible anti monotone constraint itemsets having prefix satisfy constraint 
set frequent itemsets satisfying constraint partitioned subsets 
ones having itemset prefix containing item 
ones having itemset prefix containing item subsets form projected databases mined respectively 

find frequent itemsets satisfying constraint having prefix 
frequent itemset satisfying constraint 
frequent itemsets having proper prefix subset transactions containing called projected database 
appears transaction projected database omitted 
projected database contains transactions cdef 
items infrequent projected database ab ae frequent 
pruned 
frequent items projected fact itemset satisfy constraint implies itemsets order satisfy constraint avg 
chapter 
constraint pattern growth mining af proj 
db dc dc proj 
db freq 
items afd true afc false tran 
db freq 
items true true true freq 
items af true ad true ac false ad proj 
db freq 
items adc false proj 
db dbc dce gce freq 
items fg true fd false fg proj 
db dbc ce freq 
items false mining frequent itemsets satisfying constraint avg 
database listed order ac satisfy constraint need create ac projected database 
check mined projected database af ad prefix respectively need construct projected databases mine 
process similar mining projected databases 
af projected database contains frequent items afd satisfies constraint 
satisfy constraint process branch complete 
afc violates constraint need construct afc projected database 
ad projected database contains frequent item adc satisfy constraint 
set frequent itemsets satisfying constraint having prefix contains af afd ad 
chapter 
constraint pattern growth mining 
find frequent itemsets satisfying constraint having prefix 
similarly projected database subset transactions containing removed 
transactions bcd cde 
frequent items projected database listed order itemsets fg fd satisfy constraint need explore frequent itemset fg fd proper prefix satisfies constraint 
projected fg database contains frequent itemset fg proper prefix satisfies constraint 
item immediately order fdb violates constraint itemset fd proper prefix satisfy constraint 
fg frequent itemsets having prefix satisfying constraint 
summary complete set frequent itemsets satisfying constraint contains itemsets af ad afd fg 
new method generates tests small set itemsets 
fic mining frequent itemsets convertible anti monotone constraint justify correctness completeness mining process example 
show complete set frequent itemsets satisfying convertible anti monotone constraint partitioned non overlapping subsets 
leads soundness algorithmic framework 
lemma consider transaction database support threshold convertible anti monotone constraint order set items 
am items satisfying complete set frequent itemsets satisfying partitioned disjoint subsets th subset contains frequent itemsets satisfying having aj prefix 
proof 
lemma follows showing frequent itemset satisfying th subset ii subsets overlap 
mine subsets frequent itemsets satisfying constraint constructing corresponding projected database 
definition projected database transaction database itemset order chapter 
constraint pattern growth mining 
itemset called max prefix projection transaction tid prefix exists proper superset prefix 
projected database collection max prefix projections transactions containing transaction database support threshold convertible anti monotone constraint frequent itemset satisfying complete set frequent itemsets satisfying having prefix mined projected database 
rationale 
mine frequent itemsets having prefix transactions containing needed 
furthermore definition convertible anti monotonicity information itemsets having prefix sufficient serve mining constraint 
information completely retained max prefix projections 
lemma 
mining process improved lemma 
definition ascending descending orders order set items called ascending order function items implies itemsets prefix 
called descending order function example verified value ascending order ascending order function avg descending order function max avg 
lemma convertible anti monotone constraint ascending descending order set items prefix function 
frequent itemset satisfying 
am set frequent items projected database listed order 
itemset ai violates itemset aj violates chapter 
constraint pattern growth mining 
itemset aj satisfies aj aj violates frequent itemset having aj proper prefix satisfies proof 
constraint forms prefix ascending function descending order prefix descending function ascending order show lemma holds case 
second case shown similarly 
suppose ai vs descending order ai aj implies aj ai 
means itemset aj violates alternatively suppose aj aj aj item aj aj order aj aj aj aj 
itemset aj aj violate constraint 
reasoning algorithm fic follows mining frequent itemsets convertible anti monotone constraints 
algorithm fic input transaction database support threshold convertible anti monotone constraint order set items output complete set frequent itemsets satisfying constraint method call function parameters itemset prefix projected database 
method 
scan find frequent items 
set frequent items true 

return output frequent itemset satisfying constraint 
chapter 
constraint pattern growth mining 
form prefix function lemma optimize mining removing items exists frequent itemset satisfying having proper prefix 

scan generate projected database 

item call 
rationale 
correctness completeness algorithm reasoned step step section 
efficiency algorithm pushes constraint deep mining process need generate complete set frequent itemsets cases 
related frequent itemsets identified tested 
shown example experimental results search space decreased dramatically constraint sharp 
reasoning theorem 
theorem transaction database support threshold convertible con straint fic algorithm computes complete set frequent itemsets satisfying constraint duplication 
fic mining frequent itemsets monotone constraints subsections efficient algorithm mining frequent itemsets convert ible anti monotone constraints developed 
similar spirit algorithm mining frequent itemsets convertible monotone constraints developed 
giving details formal reasoning illustrate ideas example algorithm 
example mine frequent itemsets transaction database table constraint avg 
suppose support threshold 
example value descending order exactly example 
constraint convertible monotone order scan transaction database set frequent itemsets 
frequent itemsets satisfy constraint defini tion convertible monotone constraints frequent itemset having itemsets chapter 
constraint pattern growth mining prefix satisfy constraint 
projected databases mined testing constraint adding smaller items decrease value avg 
projected databases mined constraint test ing 
soon frequent itemsets satisfy constraint constraint checking needed mining projected databases 
algorithm fic mining frequent itemsets convertible monotone constraint follows 
algorithm fic input transaction database support threshold convertible monotone con straint order set items output complete set frequent itemsets satisfying constraint method call function check flag parameters itemset prefix projected database check flag method flag constraint checking 

scan find frequent items 
check flag set frequent items true set frequent items false 
check flag set frequent items 

output frequent itemset satisfying constraint 

scan generate projected database 

item call item call chapter 
constraint pattern growth mining rationale 
correctness completeness algorithm shown similar reasoning section 
analyze difference fic apriori algorithm constraint checking post processing 
fic apriori algorithms generate complete set frequent itemsets matter frequent itemsets satisfy convertible monotone con straint 
frequent itemsets satisfying constraint pruned 
inherent difficulty convertible monotone constraint 
advantage fic apriori algorithms lies fact fic tests frequent itemsets constraint 
frequent itemset satisfies constraint guarantees frequent itemsets having prefix satisfy constraint 
testing saved 
apriori algorithm check frequent itemset constraint 
situation constraint testing costly spatial constraints saving constraint testing non trivial 
exploration spatial constraints scope chapter 
mining frequent itemsets strongly convertible constraints main value strong convertibility constraint treated convertible anti monotone monotone choosing appropriate order 
main point note practice constraint high selectivity fewer itemsets satisfy converting anti monotone constraint yield maximum benefits search space pruning 
constraint selectivity low checking reasonably expensive converting monotone constraint save considerable effort constraint checking 
constraint avg classic example 
experimental results evaluate effectiveness efficiency algorithms performed extensive experimental evaluation 
section report results synthetic transaction database transactions items dataset generated standard procedure described 
dataset average transaction size average maximal potentially dataset downloadable www cs sfu ca personal publications dat gz 
chapter 
constraint pattern growth mining frequent itemset size set respectively 
dataset contains lot frequent itemsets various lengths 
dataset chosen typical data mining performance study 
algorithms implemented experiments performed mhz pentium pc mb main memory running microsoft windows nt 
evaluate effect constraint mining frequent itemsets constraint selectivity selectivity constraint mining frequent itemsets transaction database support threshold defined frequent itemsets satisfying frequent itemsets constraint selectivity means frequent itemset satisfies con straint constraint selectivity means constraint satisfied frequent itemset 
selectivity measure defined consistent 
facilitate mining projected databases employ data structure called fp tree implementations fic fic fp tree proposed adopted ph 
prefix tree structure record complete compact information frequent itemset mining 
transaction database projected database compressed fp tree consequent projected databases derived efficiently 
refer readers details fp tree methods fp tree frequent itemset mining 
fp growth fp tree algorithm mining frequent itemsets faster apriori include experiment 
interesting compare performance fic fic fp growth apriori method 
evaluation fic test efficiency fic constraint selectivity mining frequent itemsets convertible anti monotone constraints test performed dataset support threshold 
result shown 
various settings constraint various selectivity 
shown fic achieves linear scalability constraint selectivity 
selectivity goes fewer itemsets satisfying constraint chapter 
constraint pattern growth mining runtime seconds apriori fp growth fic selectivity scalability constraint selectivity 
fic cuts search space frequent itemset satisfy constraint means frequent itemsets prefix pruned 
compare runtime apriori fp growth 
methods compute complete set frequent itemsets constraint filter 
runtime constant constraint selectivity 
constraint selectivity frequent itemset satisfies constraint fic need runtime fp growth 
situations fic requires time 
tested scalability fic support threshold number transac tions respectively 
corresponding results shown 
figures see fic scalable cases 
furthermore higher constraint selectivity scalable fic explained fact fic cuts search spaces constraints higher selectivity 
evaluation fic analyzed convertible monotone constraint save cost con straint checking cut search space frequent itemsets 
experiments relatively simple constraints involving avg sum cost chapter 
constraint pattern growth mining runtime seconds fp growth fic fic support threshold scalability support threshold 
constraint checking cpu bounded 
cost frequent itemset mining process bounded 
effect pushing convertible monotone constraint mining process hard observed runtime reduction 
experiments fic achieves runtime benefit cases 
look number constraint tests performed advantage fic evaluated objectively 
fic save lot effort constraint testing 
experiments fic number constraint tests performance measure 
test scalability fic constraint selectivity mining frequent itemsets convertible monotone constraint 
result shown indicates fic linear scalability 
constraint selectivity low frequent itemsets pass constraint checking constraint tests saved 
frequent itemset satisfies convertible monotone constraint subsequent frequent itemset derived corresponding projected database frequent itemset prefix satisfies constraint 
tested scalability fic support threshold 
result shown 
shows fic scalable 
furthermore lower constraint chapter 
constraint pattern growth mining runtime seconds fp growth fic fic number thousands scalability number transactions 
selectivity better scalability fic summary experimental results show method proposed chapter scalable mining frequent itemsets convertible constraints large transaction databases 
experimental results strongly support theoretical analysis 
mining frequent itemsets multiple convertible con straints studied push single convertible constraints frequent itemset mining 
push multiple constraints deep frequent pattern mining process multiple constraints mining query may belong category anti monotone different categories 
different constraints may different properties items item price sales profits number items 
shown previous analysis anti monotone monotone succinct con straints convertible constraints mined ordering items properly 
different constraints may require different conflicting item ordering 
question chapter 
constraint pattern growth mining number constraint tests apriori fp growth fic selectivity scalability constraint selectivity 
deal nicely 
refer constraint high low selectivity sharp blunt constraint 
sequel consider mining frequent itemsets constraint convertible constraints 
case 
exists order convertible case conflict convertible constraints 
push constraints mining process order suggest heuristics shown table 
case 
exists conflict order items 
suppose requires requires incompatible 
situations try satisfy constraint order constraint mine frequent itemsets corresponding projected database 
strategies shown table 
interested readers may verify strategies tables similar rea provided section 
need ways estimate selectivity constraints 
practice methods sampling business background knowledge provide useful chapter 
constraint pattern growth mining number constraint tests fp growth fic fic support threshold scalability support threshold 
estimation 
notice queries may contain anti monotone monotone constraint gether convertible constraint 
anti monotone monotone constraint impose requirements item ordering constraint treated similarly case table 
discussion extended cases constraints 
summary interesting studies glw mining frequent patterns constraints constraints involving holistic functions median algebraic functions avg involving distributive functions sum sets positive negative item values difficult incorporate optimization process frequent itemset mining 
reason constraints exhibit nice properties monotonicity main contribution chapter showing imposing appropriate order items tough constraints converted ones possess monotone behavior 
detailed analysis classification called convertible constraints 
characterized prefix chapter 
constraint pattern growth mining categories constraints convertible monotone convertible anti monotone test blunt constraint 
itemsets violating corresponding projected database pruned 
test blunt constraint 
itemset satisfies constraint follow testing 
test convertible monotone 
satisfied testing 
test sharp constraint 
itemsets violating constraint projected database pruned 
test sharp constraint 
itemset satisfies constraints testing 
test convertible anti monotone constraint 
violated corresponding projected database pruned 
convertible antimonotone constraint checking done time convertible monotone satisfied 
table strategies mining multiple convertible constraints conflict item ordering 
monotone functions established arithmetical closure properties 
byproduct shed light picture various classes constraints optimized frequent set mining 
convertible constraints literally incorporated apriori style algorithm readily incorporated fp growth algorithm 
experiments show effectiveness algorithms developed 
working systematic implementation constraint frequent pattern mining data mining system 
experiments needed understand best handle multiple constraints 
open issue arbitrary constraint quickly check strongly convertible 
exploring constraints clustering 
chapter 
constraint pattern growth mining categories constraints convertible monotone convertible anti monotone test blunt constraint say order 
frequent itemset violates mine frequent itemsets projected database satisfies 
test blunt constraint say order 
frequent itemset violates mine frequent itemsets projected database satisfies 
test convertible monotone say 
satisfied follow testing 
projected database violates mine frequent itemsets satisfies 
test sharp constraint say order time 
post filter 
test sharp constraint say order 
frequent itemset satisfies mine frequent itemsets projected database satisfies 
test convertible anti monotone constraint 
violated corresponding projected database pruned 
post filter 
table strategies mining multiple convertible constraints conflict item ordering 
chapter pattern growth sequential pattern mining previous chapters developed efficient effective pattern growth methods frequent pattern mining 
extend pattern growth methods mine kinds patterns 
examine power pattern growth methods chapter solve sequential pattern mining problem pattern growth methods 
sequential pattern mining discovers frequent subsequences patterns se quence database important data mining problem broad applications including analysis customer purchase patterns web access patterns analysis pro cesses scientific experiments natural disasters disease treatments dna analysis 
sequential pattern mining problem introduced agrawal srikant set sequences sequence consists list elements element consists set items user specified min support threshold sequential pattern mining find frequent subsequences subsequences occurrence frequency set sequences min support 
studies contributed efficient mining sequential patterns frequent patterns time related data sa mtv wcm zak mcp ors rms 
srikant agrawal sa generalize definition sequential patterns include time constraints sliding time window user defined taxonomy :10.1.1.40.6428
mannila mtv problem mining frequent chapter 
pattern growth sequential pattern mining episodes sequence events episodes essentially acyclic graphs events edges specify temporal relationship timing interval re 
bettini consider generalization inter transaction association rules 
essentially rules left hand right hand sides episodes time interval restrictions 
lu propose inter transaction association rules implication rules sides totally ordered episodes timing interval restrictions 
garofalakis grs propose regular expressions flexible constraint specification tool enables user controlled focus incorporated sequential pattern mining process 
works extended scope mining sequential patterns mining partial periodic patterns 
ors introduce cyclic association rules essentially partial periodic patterns perfect periodicity sense pattern cycle confidence 
han developed frequent pattern mining method mining partial periodicity patterns frequent maximal patterns pattern appears fixed period fixed set offsets sufficient support 
proposed methods mining sequential patterns time related frequent patterns apriori apriori heuristic states fact super pattern infrequent pattern frequent candidate generation test paradigm proposed association mining 
typical apriori sequential pattern mining method gsp sa adopts multiple pass candidate generation test approach outlined follows :10.1.1.40.6428
scan finds frequent items form set single item frequent sequences 
subsequent pass starts seed set sequential patterns set sequential patterns previous pass 
seed set generate new potential patterns called candidate sequences 
candidate sequence contains item seed sequential pattern element pattern may contain item multiple items 
number items sequence called length sequence 
candidate sequences pass length 
scan database pass finds support candidate sequence 
candidates support database min support form set newly sequential patterns 
set seed set pass 
algorithm terminates new sequential pattern pass candidate sequence generated 
chapter 
pattern growth sequential pattern mining apriori sequential pattern mining method reduces search space bears nontrivial inherent costs independent detailed implementation tech niques 
huge set candidate sequences generated large sequence database 
set candidate sequences includes possible permutations elements repetition items sequence apriori method may generate large set candidate sequences moderate seed set 
example frequent sequences length generate candidate sequences length aa ab ba bb ab ab represents events happen time slot 
frequent sequences length 
apriori algorithm generate candidate sequences term derived set 

second term derived set 
database scans mining 
length candidate sequence grows database scan find sequential pattern abc abc abc abc abc apriori method scan database times 
bears nontrivial cost 
apriori method encounters difficulty mining long sequential patterns 
long sequential pattern grow huge number short sequential patterns number candidate sequences exponential length sequential patterns mined 
example suppose single sequence length 
database min support threshold occurring pattern frequent re derive length sequential pattern apriori method generate length candidate sequences length candidate sequences length candidate sequences 
obviously total number candidate sequences generated notice apriori cut substantial amount search space 
number length candidate sequences 
chapter 
pattern growth sequential pattern mining applications unusual may encounter large number se patterns long sequences dna analysis stock sequence analysis 
important re examine sequential pattern mining problem explore efficient scalable methods 
analysis thrust bottleneck apriori sequential pattern mining method come step wise candidate sequence generation test 
success pattern growth methods frequent pattern mining develop pattern growth method sequential pattern mining absorbs spirit apriori avoid substantially reduce expensive candidate generation test 
chapter systematically develop pattern growth methods mining tial patterns efficiently 
new methods non apriori apply divide conquer pattern growth principle 
general idea sequence databases recursively pro set smaller projected databases sequential patterns grown projected databases exploring local frequent fragments 
pattern growth schemes freespan frequent pattern projected sequential pattern mining prefixspan prefix projected sequential pattern mining proposed 
mine complete set sequential patterns greatly reduce efforts candidate subsequence generation 
improve mining efficiency kinds database projections level level tion bi level projection pseudo projection explored 
comprehensive performance study shows freespan prefixspan outperform apriori gsp algorithm integrated prefixspan fastest mining large sequence databases 
remainder chapter organized follows 
section define se pattern mining problem illustrate ideas apriori sequential pattern mining method gsp 
section introduce projection sequential pattern mining general basic freespan prefixspan algorithms 
section methods scaling pattern growth bi level projection pseudo projection proposed 
experimental results performance study reported section 
summarize factors contributing success method discuss related issues section 
study concluded section 
chapter 
pattern growth sequential pattern mining problem definition related works section define problem sequential pattern mining illustrate essential mining method gsp sa example :10.1.1.40.6428:10.1.1.40.6428
problem definition 
set items 
itemset subset items 
sequence ordered list itemsets 
sequence denoted sl sj itemset sj sj called element sequence denoted xm xk item xk brevity brackets omitted element item 
element written item occur element sequence occur multiple times different elements sequence 
number instances items sequence called length sequence 
sequence length called sequence 
sequence called subsequence sequence bm super sequence denoted exist integers jn bj bj 

sequence database set tuples sid sid sequence id sequence 
tuple sid said contain sequence subsequence support sequence sequence database number tuples database containing supports sid sid 
denoted support sequence database clear context 
positive integer min support support threshold sequence called sequential pattern sequence database sequence contained min support tuples database supports min support 
sequential pattern length called pattern 
example running example running database sequence database columns table min support 
set items database 
sequence abc ac cf elements abc ac cf items appear respectively different elements 
sequence instances appearing sequence 
item happens times chapter 
pattern growth sequential pattern mining sequence id sequence item pattern abc ac cf ad bc ae ef ab df cb af cbc table sequence database sequence contributes length sequence 
sequence abc ac cf contributes support sequence bc df subsequence abc ac cf sequences contain subsequence ab sequential pattern length pattern 
problem statement 
sequence database min support threshold prob lem sequential pattern mining find complete set sequential patterns database 
algorithm gsp apriori heuristic typical sequential pattern mining method gsp sa proceeds shown example :10.1.1.40.6428
example gsp database min support example gsp scans collects support item finds set frequent items form item support filtering infrequent items obtain seed set representing element sequential pattern 
subsequent pass starts seed set previous pass uses generate new potential sequential patterns called candidate sequences 
set length sequential patterns generates set sequences aa ab 
af ba bb 
ff ab ac 
ef 
candidate multi scan mining process shown explanations 
chapter 
pattern growth sequential pattern mining th scan candidates length sequential patterns bc rd scan candidates length sequential patterns candidates appear database nd scan candidates length sequential patterns candidates appear database st scan candidates length sequential patterns ab dc aab ab aac 
aa ab 
af ba bb 
ff ab 
ef candidate pass support threshold candidate appear database candidates sequential patterns gsp set candidates generated self join sequential patterns previous pass 
th pass sequence candidate length subsequences sequential pattern st pass 
new scan database collects support candidate sequence finds new set sequential patterns 
set seed pass 
algorithm terminates sequential pattern pass candidate sequence generated 
number scans maximum length sequential patterns 
needs scan sequential patterns obtained scan generate new candidates 
gsp benefits apriori pruning generates large number candi dates 
example length sequential patterns generate length candidates length sequential patterns generate length candidates candidates generated gsp may appear database 
example length candidates appear database 
chapter 
pattern growth sequential pattern mining mining sequential patterns projections section introduce new approaches mining sequential patterns efficiently large databases 
general idea follows 
repeatedly scanning entire database generating testing large sets candidate sequences adopt divide conquer strategy recursively project sequence database set smaller databases mine projected database find frequent patterns 
propose methods freespan prefixspan projection sequential pattern mining 
methods create projected databases differ criteria database projection freespan creates projected databases current set frequent patterns prefixspan frequent prefixes 
study shows freespan prefixspan faster gsp prefixspan substantially faster freespan 
freespan frequent pattern projected sequential pattern mining sequence set items appearing called item pattern sequence denoted 
example abc ac cf 
sequence database sidi si obtain corresponding item pattern database denoted sidi si substituting sequences item patterns 
example item patterns sequences sequence database table listed third column table 
itemset set items support denoted support sidi si si number tuples containing support threshold min support itemset called frequent item pattern support min support 
lemma illustrate interesting relationship sequential pattern sequence database item pattern corresponding item pattern database 
lemma item pattern sequential pattern sequence database item pattern frequent corresponding item pattern database 
proof 
sequence database support threshold min support 
sequential pattern 
obviously sidi si si si 
support supports followed theorem 
please note reverse statement lemma true 
example chapter 
pattern growth sequential pattern mining frequent item pattern item pattern database table respect support threshold min support 
abcd frequent sequence database lemma provides heuristic prune search space mining sequential patterns item pattern infrequent need examine corresponding sequential patterns 
freespan adopts heuristic mine sequential patterns partitioning search space projecting sequence sub databases recursively 
show freespan uses heuristic mining sequential patterns example follows 
example freespan database min support example freespan scans collects support item finds set frequent items 
step similar gsp 
frequent items listed support descending order form item support list list complete set sequential patterns divided disjoint subsets ones containing item ones containing item item list ones containing item item list ones containing item subsets sequential patterns mined constructing projected databases 
infrequent items example removed construction projected databases 
mining process detailed follows 
finding sequential patterns containing item scanning sequence database sequential patterns containing item aa 
finding sequential patterns containing item item list 
achieved constructing projected database 
sequence containing item subsequence derived removing items list 
inserted projected database 
projected database contains sequences ab aba ab ab scanning projected database sequential patterns containing item item list 
ab ba ab 
chapter 
pattern growth sequential pattern mining finding subsets sequential patterns 
subsets sequential patterns similarly constructing corresponding projected databases mining recursively 
please note 
projected databases constructed ously scan original sequence database 
sequential patterns containing item pass 
database projection process performed recursively projected databases 
example sequences projections item patterns follows 
definition projection item pattern list list items set items 
item called leading item respect list exists item list 
sequence set items 
item pattern projection denoted formed removing items list 
sequence database sidi si set items item pattern projected database denoted defined sidi si sidi si 
freespan algorithm follows 
algorithm freespan frequent pattern projected sequential pattern mining 
input sequence database support threshold min support output complete set sequential patterns method call freespan 
procedure freespan proj db freq item pat 
scan projected database proj db find list list frequent items frequent item pattern freq item pat chapter 
pattern growth sequential pattern mining 
scan proj db find sequential patterns item pattern freq item pat list item list form projected database proj db freq item pat item pattern freq item pat 
item list call freespan proj db freq item pat freq item pat 
analysis 
correctness algorithm freespan lays aspects 
problem partitioning frequent item patterns 
list 
xn list frequent items sequence database complete set sequential patterns divided disjoint subsets set sequential patterns containing item second containing item item 
xn 
general th subset set sequential patterns containing item xi item xi 
xn 
partitioning frequent item patterns applied partitions re 
lemma provides theoretical support partitions frequent item patterns need considered 
long find sequential patterns partitions frequent item patterns global sequential pattern mining problem solved completely redundancy 
forming mining proper projected databases 
find complete set sequential patterns partition frequent item pattern freespan forms projected database 
projected database contains segments sequences potentially supporting sequential patterns partition 
irrelevant information discarded 
projected database contains minimal information finding sequential patterns partition 
recursively mining projected databases generates complete set sequential patterns partition duplication 
example analysis algorithm freespan obser efficiency freespan 
experimental results verify observa tions 
chapter 
pattern growth sequential pattern mining freespan searches smaller projected database gsp subse quent database projection 
freespan projects large se quence database recursively set small projected sequence databases currently mined frequent item patterns subsequent mining confined projected database relevant smaller set candidates 
major cost freespan deal projected databases 
pattern appears sequence database projected database shrink removal infrequent items 
example projected database example original sequence database removal infrequent item length subsequence may grow position search length candidate sequence need check possible combination costly 
prefixspan prefix projected sequential patterns mining items element sequence listed order loss generality assume listed alphabetical order 
example sequence sequence id running example listed abc ac cf stead bac ca fc convention expression sequence unique 
definition prefix projection suffix suppose items element listed alphabetically 
sequence en sequence called prefix ei em items em alphabetically sequences subsequence 
subsequence sequence called projection prefix prefix exists proper super sequence subsequence prefix 
en projection prefix em 
sequence mem en called suffix prefix denoted em 
denote 
empty suffix denoted items em en chapter 
pattern growth sequential pattern mining especially subsequence projection suffix empty respectively 
example aa ab abc prefixes sequence abc ac cf ab bc considered prefix 
abc ac cf suffix prefix bc ac cf suffix prefix aa ac cf suffix prefix ab example prefixspan sequence database table min sup sequential patterns mined prefix projection method steps 

find length sequential patterns 
scan find frequent items se quences 
frequent items length sequential pattern 
notation pattern count represents pattern associated support count 

divide search space 
complete set sequential patterns partitioned subsets prefixes ones prefix ones prefix 
ones prefix prefix projected suffix database sequential patterns abc ac cf bc ae cbc df cb ac cf df cb ae ac cf bc bc ae aa ab bc bc aba abc ab ab ab ab ab dc ac aca acb acc ad adc af ba bc bc bc bd bf ca cb cc cf bc ae cb db dc ab df cb af cbc ea eac eb ec ef efc ab df cb cbc fb fc fcb table projected databases sequential patterns 
find subsets sequential patterns 
subsets sequential patterns mined constructing corresponding set projected databases mining recursively 
projected databases sequential patterns listed table mining process explained follows 
chapter 
pattern growth sequential pattern mining find sequential patterns prefix sequences containing collected 
sequence containing subsequence pre fixed occurrence considered 
example sequence ef ab df cb subsequence df cb consid ered mining sequential patterns prefixed notice means element prefix form element 
sequences containing projected form projected database consists suffix sequences abc ac cf bc ae df cb cbc scanning projected database length sequential patterns prefixed 
aa ab ab ac ad af 
recursively sequential patterns prefix partitioned subsets prefixed aa ab 
af subsets mined constructing respective projected databases mining recursively follows 
aa projected database consists non empty suffix sub sequences prefixed aa bc ac cf hope generate frequent subsequence single sequence processing aa projected database terminates 
ii 
ab projected database consists suffix sequences ac cf recursively mining ab projected database returns sequential patterns bc bc aba abc form complete set sequential patterns prefixed ab iii 
ab projected database contains sequences ac cf df cb leads finding sequential patterns prefixed ab dc iv 
ac ad af projected databases constructed re mined similarly 
sequential patterns shown table 
find sequential patterns prefix respectively 
done constructing projected databases chapter 
pattern growth sequential pattern mining mining respectively 
projected databases sequential patterns shown table 
set sequential patterns collection patterns recursive mining process 
verify returns exactly set sequential patterns gsp freespan 
justify correctness completeness mining process example 
concept prefix lemma completeness partitioning sequential pattern mining problem 
lemma problem partitioning 

xn complete set length sequential patterns sequence database complete set sequential patterns divided disjoint subsets 
th subset set sequential patterns prefix xi 
length sequential pattern 
set length sequential patterns prefix 
complete set sequential patterns prefix divided disjoint subsets 
th subset set sequential patterns prefixed proof 
show correctness second half lemma 
half special case sequential pattern prefix length length prefix sequential pattern apriori heuristic 
furthermore length prefix prefix definition prefix 
exists length prefix 
th subset 
hand length prefix sequence unique belongs determined subset 
subsets non overlapping 
lemma 
lemma prefixspan partitions problem recursively 
subset sequential patterns divided necessary 
forms divide conquer framework 
mine subsets sequential patterns prefixspan constructs corresponding projected databases 
chapter 
pattern growth sequential pattern mining definition projected database sequential pattern sequence database projected database denoted collection suffixes sequences prefix 
collect counts projected databases definition 
definition support count projected database sequential pattern sequence database sequence prefix 
support count projected database denoted supports number sequences 
please note general holds running example 
support support example supports ad holds running example 
ad support 
lemma projected databases 
lemma projected database sequential patterns sequence database prefix 


sequence prefix supports support 
size projected database exceed proof 
part lemma follows fact sequence suffix equals sequence resulted projection projection 

second part lemma states collect support count sequence sequences database sharing prefix considered 
furthermore suffixes prefix super sequence counted 
related definitions claim correct 
third part lemma size projected database 
obviously projected database number sequences appears chapter 
pattern growth sequential pattern mining sequence sequences super sequences appear projected database 
number sequences 
sequence super sequence appears projected database prefix 
subsequence appears projected database 
size projected database exceed reasoning algorithm prefixspan follows 
algorithm prefixspan prefix projected sequential pattern mining 
input sequence database minimum support threshold min sup output complete set sequential patterns method call prefixspan 
subroutine prefixspan parameters sequential pattern length projected database sequence database method 
scan find set frequent items assembled element form sequential pattern appended form sequential pattern 

frequent item append form sequential pattern output 
construct projected database call prefixspan 
chapter 
pattern growth sequential pattern mining analysis 
correctness completeness algorithm justified lemma lemma shown theorem 
analyze efficiency algorithm follows 
candidate sequence needs generated prefixspan 
apriori gorithms prefixspan grows longer sequential patterns shorter frequent ones 
generates tests candidate sequence non existent projected database 
comparing gsp generates tests substantial number candidate sequences prefixspan searches smaller space 
projected databases keep shrinking 
indicated lemma projected database smaller original suffix subsequences frequent prefix projected projected database 
practice shrinking factors significant usually small set sequential patterns grow quite long sequence database number sequences projected database quite small prefix grows projection takes suffix portion respect prefix 
notice freespan employs idea projected databases 
projection takes string just suffix shrinking factor prefixspan 
major cost prefixspan construction projected databases 
worst case prefixspan constructs projected database sequential pattern 
number sequential patterns cost non trivial 
section develop strategies reduce number projected databases dramatically 
theorem prefixspan sequence sequential pattern prefixspan says 
proof 
direction length sequence identified sequential pattern prefixspan sequential pattern projected database length prefix length prefix projected database 
sequential pattern lemma exactly projected database supports supports 
sequential pattern means sequential pattern show sequence sequential pattern prefixspan says 
chapter 
pattern growth sequential pattern mining direction lemma guarantees prefixspan identifies complete set sequential patterns theorem 
scaling pattern growth bi level projection pseudo projection analyzed major cost prefixspan construct projected databases 
number size projected databases reduced performance sequential pattern mining improved substantially 
section develop techniques reduce cost constructing projected databases bi level projection scheme proposed reduce number size projected databases pseudo projection proposed explore virtual projection database projected fits main memory 
bi level projection introducing method formally examine example 
example re examine mining sequential patterns sequence database table 
step scan find length sequential patterns second step constructing projected databases length se pattern construct lower triangular matrix shown table 
table matrix matrix registers supports length sequences assembled length sequential patterns 
cell diagonal line counter 
example chapter 
pattern growth sequential pattern mining indicates sequence cc appears sequences 
cells counters respectively 
example means supports ac supports ca supports ac 
information cell symmetric triangle matrix sufficient 
matrix called matrix 
scanning sequence database matrix filled shown table 
length sequential patterns identified matrix immediately 
length sequential pattern construct projected database 
example ab identified length sequential pattern matrix 
ab projected database contains sequences ac cf scanning frequent items matrix ab projected database constructed shown table 
table matrix ab projected database 
cell support length pattern gen erated projection needed 
notice means possibility generate pattern 
need look database 
mine complete set sequential patterns projected databases length sequential patterns constructed 
verify bi level projection method produces exactly set sequential patterns prefixspan algorithm introduced section 
section find complete set tial patterns projected databases constructed 
example projected databases length sequential patterns needed 
total projected databases constructed bi level projection 
justify mining process bi level projection 
definition matrix sequence match matrix length sequential pattern 
length sequential patterns prefix chapter 
pattern growth sequential pattern mining projected database 
matrix projected database denoted defined follows 

contains counter 
element item counter registers support sequence ix xx projected database 
counter set 
form counters 
element item counter registers support sequence ix projected database 
counter set element item counter registers support sequence jy projected database 
counter set elements number items counter registers support sequence projected database sequence inserting element item element counter set 
lemma length sequential pattern 

matrix filled scans projected database 
length sequence prefix sequential pattern matrix projected database says 
proof 
half lemma intuitive 
show second half lemma 
suppose length sequential pattern prefix 
formed ways adding items element alphabetically items element adding item element alphabetically items element adding element containing item element adding elements xy adding element element 
cases case length subsequences chapter 
pattern growth sequential pattern mining sequential patterns prefix 
lemma identified length sequential patterns projected database 
exists cell matrix 
loss generality suppose 
sequential pattern assembled corresponding counter pass minimum support threshold 
matrix identify sequential pattern 
case length subsequence sequential pattern prefix 
definition matrix matrix registers support projected database 
lemma says counter passes minimum support threshold sequential pattern 
hand definition matrix counter registers support count unique length sequence prefix 
lemma tells counter passes minimum support threshold sequential pattern 
lemma 
lemma provides theoretical guarantee correctness bi level projection 
need include item suffix projected databases 
example consider ac projected database example 
matrix table tells ad sequential pattern cd 
apriori heuristic acd super sequence sequential pattern 
matrix tells cd frequent 
exclude item ac projected database 
way apriori checking prune items constructing projected databases 
state principle optimization 
optimization pruning items projected database way apriori check ing prune items constructing projected databases rules 
projected database length sequential pattern length subsequence 
frequent item excluded suffixes element suffixes elements supersets element 
projected database formed substitute item element frequent item excluded elements chapter 
pattern growth sequential pattern mining suffixes 
optimization applies way apriori checking reduce projected databases 
fragments sequences necessary grow longer patterns projected 
pseudo projection major cost prefixspan projection forming projected databases recursively 
propose pseudo projection technique reduces cost projection sub projected database held main memory 
examining set projected databases observe suffixes se quence appear repeatedly recursive projected databases 
example sequence abc ac cf suffixes abc ac cf ac cf projections ab projected databases respectively 
redundant subsequences 
se quence database projected database held main memory redundancy avoided pseudo projection 
method follows 
database held main memory constructing physical projection collecting suffixes pointers referring sequences database pseudo projection 
projection consists pieces information pointer sequence database offset indicates position suffix sequence 
example suppose sequence database table held main memory 
constructing projected database projection sequence abc ac cf consists pieces pointer offset set 
offset indicates pro starts position sequence abc ac similarly projection ab projected database contains pointer offset set indicating suffix starts item ac cf 
pseudo projection avoids physically copying suffixes 
efficient terms running time space 
efficient pseudo projection disk accessing random access disk space costly 
observation prefixspan pursues pseudo projection projected databases held main memory 
experimental results show integrated solution combining disk bi level projection pseudo projection data fit main memory clear winner performance 
chapter 
pattern growth sequential pattern mining experimental results performance study section report experimental results performance prefixspan comparison gsp freespan 
shows prefixspan outperforms previ ously proposed methods efficient scalable mining sequential patterns large databases 
runtime seconds gsp freespan prefixspan prefixspan support threshold runtime comparison prefixspan freespan gsp data set 
experiments performed mhz pentium pc machine megabytes main memory running microsoft windows nt 
methods implemented mi visual 
compare performance methods follows 
gsp 
gsp algorithm implemented described sa :10.1.1.40.6428
freespan 
reported freespan alternative level projection efficient freespan level level projection 
chapter freespan alternative level projection 
chapter 
pattern growth sequential pattern mining prefixspan 
prefixspan prefixspan level level projection described section 
prefixspan 
prefixspan prefixspan bi level projection described sec tion 
synthetic datasets experiments generated standard pro cedure described 
data generator studies sequential pattern mining sa 
agrawal srikant give details generation data sets 
tested methods various datasets 
results consistent 
thesis report results representative dataset 
data set number items set sequences data set 
average number items elements set denoted 
average number elements sequence set denoted 
number long sequential patterns low support thresholds 
experimental results scalability different support thresholds shown 
support threshold high limited number short sequential patterns appear 
methods close terms runtime 
support threshold decreases gaps clear 
freespan prefixspan faster gsp 
prefixspan methods efficient scalable freespan 
focus performance various prefixspan techniques remainder section 
shown performance curves prefixspan prefixspan close support threshold low 
support threshold low sequential patterns prefixspan requires major effort generate projected databases 
bi level projection leverage problem efficiently 
seen increase runtime prefixspan moderate support threshold pretty low 
shows pseudo projections projected databases held main memory improves efficiency prefixspan 
seen performance level level bi level pseudo projections close 
runtime methods close support threshold low 
bi level projection method efficient savings due fewer projected databases overcomes cost mining filling matrix 
verifies analysis chapter 
pattern growth sequential pattern mining runtime seconds prefixspan prefixspan prefixspan pseudo prefixspan pseudo support threshold runtime comparison prefixspan variations data set 
level level bi level projection 
pseudo projection improves performance projected database held main memory interest consider method extended disk processing 
doing physical projection saving projected databases hard disk projected database form disk address offset 
explore alternative pursue simulation test follows 
sequential read reading bytes data file cost unit random read reading data offset file cost units suppose write operation costs shows costs prefixspan prefixspan pseudo projection variations data set kt means sequences data set 
prefixspan prefixspan beat pseudo projection variations clearly 
observed bi level projection outperforms level level projection support threshold low 
huge number random reads disk pseudo projections major cost database big fit main memory 
chapter 
pattern growth sequential pattern mining cost prefixspan prefixspan prefixspan pseudo prefixspan pseudo support threshold cost comparison prefixspan variations data set kt 
shows scalability prefixspan prefixspan respect number sequences 
methods linearly scalable 
support threshold set prefixspan performs better 
summary performance study shows prefixspan efficient scalable freespan gsp freespan faster gsp support threshold low long patterns 
prefixspan uses bi level projection dramatically reduce number projections efficient prefixspan large databases low support threshold 
projected databases fit main memory pseudo projection leads efficient solution 
experimental results consistent theoretical analysis 
discussion supported analysis performance study prefixspan freespan faster gsp prefixspan faster freespan 
summarize chapter 
pattern growth sequential pattern mining runtime seconds prefixspan prefixspan number sequences thousands scalability prefixspan variations 
factors contributing efficiency prefixspan freespan gsp follows 
prefixspan freespan pattern growth methods searches focused efficient gsp 
pattern growth method try grow longer patterns shorter ones 
accordingly divide search space focus subspace potentially supporting pattern growth time 
search spaces focused 
technically search spaces confined projected databases 
projected database sequential pattern contains necessary information mining sequential patterns grown 
mining proceeds longer sequential patterns projected databases smaller 
contrast gsp searches original database iteration 
irrelevant sequences scanned checked fruitful 
argument supported performance study 
indicates average number candidates sequential pattern gsp increases exponentially support threshold goes average processing time projected database prefixspan goes dramatically 
prefix projected pattern growth elegant frequent pattern guided projection 
chapter 
pattern growth sequential pattern mining comparing frequent pattern guided projection employed freespan prefix projected pattern growth progressive 
worst case prefixspan guarantees projected databases keep shrinking takes care suffixes 
mining dense databases freespan gain projections prefixspan reduce length sequences number sequences projected databases dramatically 
example suppose database contains sequence support threshold set 
consider projected databases optimization predominant prefix 
projected database contains sequence projected database contains sequential pattern longer sequences corresponding projected databases shorter 
prefixspan needs find patterns suffixes 
freespan order frequent items 


projected databases contain original sequence cases sequence projected databases shrink 
furthermore freespan take care pattern growth possible pattern growth point pattern template 
sequential pattern elements total points enable inserting item existing element single item element inserted possible points 
quite costly 
apriori principle integrated bi level projection prefixspan 
apriori heuristic essence apriori methods 
apriori methods generate test candidates 
fully utilize apriori heuristic avoid costly candidate generation test 
notice mining frequent pattern projected database utilizes apriori heuristic subsequences related frequent patterns current databases projected examined subsequently 
analysis experimental results support claim bi level projection efficient level level projection prefixspan 
bi level projection inte apriori heuristic pruning projected databases 
heuristic bi level projection achieves way checking determine sequential pattern lead longer pattern items assemble longer patterns chapter 
pattern growth sequential pattern mining potentially 
fruitful projected databases constructed 
furthermore way checking efficient corresponding cells matrix checked assembling needed 
summary studied methods mining sequential patterns large databases developed pattern growth approach efficient scalable mining sequential patterns 
approach direct extension candidate generation test approach gsp sa 
exploration divide conquer pattern growth approach viewed spirit extension fp growth algorithm developed mining non sequential frequent patterns databases 
new approach explores database projection method grows sequential patterns locally frequent fragments projected databases 
pattern growth methods freespan prefixspan proposed 
methods mine complete set sequential patterns substantially reduce efforts candi date subsequence generation 
prefixspan explores prefix projection leads search spaces better efficiency freespan 
improve efficiency kinds database projections level level projection bi level projection pseudo projection explored 
comprehensive performance study shows freespan prefixspan outperform apriori gsp algorithm prefixspan database pro techniques especially pseudo projection data fits main memory bi level projection fastest mining large sequence databases 
interesting issues need studied 
example users may pose constraints sequential patterns 
interesting research problem see full constraints sequential pattern mining 
sequential pattern mining problems applications dna mining may admit faults allowing insertions deletions mutations dna sequences 
interesting issue develop efficient fault tolerant sequential pattern mining algorithms applications 
chapter discussion developed pattern growth methods efficient effective frequent pattern min ing 
chapter summarize major characteristics pattern growth methods discuss interesting extensions applications pattern growth methods 
characteristics pattern growth methods developed new class pattern growth methods effective efficient data mining 
summarize major characteristics pattern growth methods 
pattern growth methods adopt divide conquer methodology partition data sets patterns subsets recursively 
general data mining search huge space 
divide conquer methodology enables search algorithms focus reduced subsets goals smaller sub spaces 
sharper pruning feasible 
pattern growth methods avoid candidate generation test 
pattern growth methods take patterns seeds explore extensions current patterns 
benefits aspects 
hand pattern growth methods search candidate generation test methods number candidates huge 
hand pattern growth methods avoid sive pattern matching operations 
search local frequent items cheaper 
chapter 
discussion pattern growth methods employ effective data structures fully utilize available space 
example fp tree block try fully available memory reduce irrelevant information 
highly condensed indexed data structures search space organized way pattern growth search efficient 
extensions applications pattern growth methods shown pattern growth methods effective efficient frequent pattern mining 
interestingly surprisingly pattern growth methods applicable mining kinds knowledge solving interesting data processing problems 
section discuss examples 
mining closed association rules association mining may derive undesirably large set frequent itemsets rules 
interesting alternative proposed pasquier mining complete set frequent itemsets associations association mining needs find frequent closed itemsets corresponding rules 
important implication mining frequent closed itemsets power mining complete set frequent itemsets substantially reduces redundant rules generated increases efficiency effectiveness mining 
examine simple example 
suppose database contains trans actions 

minimum support threshold occurrence frequent minimum confidence threshold 
tradi tional association mining method generate frequent itemsets 



tremendous num ber association rules frequent closed itemset mining generate frequent closed itemsets 

association rule 

derived easily 
studied efficient mining frequent closed itemsets large databases pattern growth methods :10.1.1.27.6266
mine frequent closed itemsets pasquier proposed apriori mining algorithm called close 
zaki hsiao zh pro posed mining algorithm charm improves mining efficiency exploring chapter 
discussion item data structure 
analysis close charm costly mining long patterns low minimum support thresholds large databases 
continued study frequent pattern mining candidate generation proposed efficient method mining closed itemsets :10.1.1.27.6266
techniques developed purpose framework developed efficient frequent pat tern mining method fp growth extended strategies devised reduce search space dramatically identify frequent closed itemsets quickly partition projection mechanism established mining efficient scal able large databases 
performance study showed closet efficient scalable large databases faster previously proposed methods 
associative classification pattern growth methods associative classification attracted increasing attention data mining community due improved classification accuracy flexibility handling unstructured data 
associative classification suffers huge set mined rules fitting classification rules highest confidence 
proposed new associative classification method classification multiple association rules performs associative classification multiple strong association rules 
method extends efficient frequent pattern min ing method fp growth constructs class distribution associated fp tree mines large databases efficiently 
applies cr tree structure store retrieve mined association rules efficiently prunes rules effectively confidence correlation database coverage 
classification performed weighted analysis multiple association rules 
experiments performed databases popularly referenced uc irvine machine learning database repository 
experimental results showed con sistent highly effective classification various kinds databases better average classification accuracy comparison cba 
performance study showed method highly efficient scalable comparison reported associative classification methods 
chapter 
discussion mining multi dimensional sequential patterns sequential pattern mining finds set frequent subsequences sequence databases important data mining task broad applications 
usually sequence patterns associated different circumstances circumstances form multiple dimensional space 
example customer purchase sequences associated region time customer group 
interesting useful mine sequential patterns associated multi dimensional information 
php proposed theme multi dimensional sequential pattern mining integrates multi dimensional analysis sequential data mining 
thoroughly explored efficient methods multi dimensional sequential pattern mining 
examined feasible combinations efficient sequential pattern mining multi dimensional analysis methods developed uniform methods high performance mining 
extensive experiments showed advantages limitations methods 
recom selecting proper method respect data set properties drawn 
computing iceberg cubes complex measures data cube essential facility online analytical processing 
expensive compute materialize complete high dimensional data cube 
computing iceberg cube effective way derive nontrivial multi dimensional aggregations olap data mining data compression applications 
iceberg cube set cells data cube satisfy certain constraints minimum support threshold 
previous studies developed efficient methods computing iceberg cubes simple measures count sum nonnegative values 
challenging problem efficiently compute iceberg cubes complex measures average sum mixture nonnegative negative values studied efficient methods computing iceberg cubes popularly complex measures developed methodology uses weaker anti monotonic condition testing pruning search space 
particular investigated efficient methods computing iceberg cubes average measure proposed top average pruning method 
extended previously studied methods apriori buc top apriori top buc efficient computation chapter 
discussion iceberg cubes 
improve performance fast algorithms cubing cubing developed 
employ hyper structures tree block respectively 
performance study showed buc cubing cubing promising candidates scalable computation cubing best performance cases 
summary summary pattern growth methods adopt divide conquer methodology parti tion data sets patterns subsets recursively 
avoid candidate generation test 
addition employ effective data structures fully utilize available space 
studies show pattern growth methods efficient effective 
strong implication mining kinds knowledge broad applications closed association rule mining associative classification multi dimensional tial pattern mining iceberg cube computation complex measures 
chapter world information era huge amount data accumulated everyday 
real universal challenge find actionable knowledge large amount data 
data mining emerging research direction meet challenge 
kinds knowledge patterns mined various data 
thesis focus problem mining frequent patterns efficiently effectively develop new class pattern growth methods 
chapter summarize thesis discuss interesting directions 
summary thesis mining frequent patterns transaction databases time series databases kinds databases studied extensively data mining research 
previous studies adopt apriori candidate set generation test approach 
didate set generation costly especially exists abundance patterns long patterns 
thesis propose class pattern growth methods frequent pattern mining contributions 
propose novel frequent pattern tree fp tree structure extended prefix tree structure storing compressed crucial information frequent pat terns develop efficient fp tree mining method fp growth mining complete set frequent patterns pattern fragment growth 
efficiency mining chapter 
achieved techniques large database compressed highly condensed smaller data structure avoids costly repeated database scans fp tree mining adopts pattern growth method avoid costly generation large number candidate sets partitioning divide conquer method decompose mining task set smaller tasks mining confined patterns conditional databases dramatically reduces search space 
performance study shows fp growth method efficient scalable mining long short frequent patterns order magnitude faster apriori algorithm faster reported new frequent pattern mining methods 
major cost fp growth build conditional fp trees recursively 
overcome disadvantage propose simple novel hyper linked data structure struct new mining algorithm mine takes advantage data structure dynamically adjusts links mining process 
distinct feature method limited precisely predictable space overhead runs really fast memory setting 
scales large databases database partitioning 
data set dense conditional fp trees constructed dynamically part mining process 
study shows mine high performance various kinds data 
outperforms previously developed algorithms highly scalable mining large databases 
study proposes new data mining methodology space preserving mining may strong impact development efficient scalable data mining methods 
cases frequent pattern mining may result patterns 
highlighted importance constraint mining paradigm context mining frequent itemsets associations correlations sequential patterns interesting patterns large databases 
constraint pushing techniques developed mining frequent patterns associations anti monotonic mono tonic succinct constraints 
study constraints handled existing theory techniques frequent pattern mining 
example avg median sum may contain items arbitrary values customarily regarded tough constraints pushed inside algorithm chapter 
apriori 
develop notion convertible constraints systematically ana classify characterize class constraints 
develop techniques enable readily pushed deep inside developed fp growth algorithm frequent itemset mining 
results detailed experiments show effectiveness techniques developed 
sequential pattern mining important data mining problem time related sequence databases broad applications 
difficult problem may need examine combinatorially explosive number possible subsequence pat terns 
previously developed sequential pattern mining methods follow apriori methodology apriori method may substantially reduce number combinations examined 
apriori encounters perfor mance challenges sequence database large sequential patterns numerous long 
systematically develop pattern growth approach efficient mining sequential patterns large databases 
gsp generalized sequential pat tern algorithm sa candidate generation test approach extended apriori algorithm 
new approach adopts divide conquer pattern growth principle extending fp growth algorithm mine order dependent sequential patterns 
general idea sequence database recursively projected set smaller projected databases 
sequential patterns grown projected database exploring local frequent fragments 
pattern growth methods freespan prefixspan proposed 
methods mine complete set sequential patterns substantially reduce effort candidate subsequence generation 
improve mining efficiency kinds database projections level level projection bi level projection pseudo projection explored 
comprehensive performance study shows freespan prefixspan outperform apriori gsp algorithm integrated prefixspan fastest algorithm mining large sequence databases 
chapter 
research directions success pattern growth methods interesting re examine explore related problems extensions applications 
listed 
fault tolerant frequent pattern mining 
real world data tends dirty 
discovering knowledge large real world data calls fault tolerant data mining fruitful direction data mining research 
fault tolerant extensions data mining techniques gain useful insights data 
pth introduced problem fault tolerant frequent pattern mining 
fault tolerant frequent pattern mining novel interesting practical knowledge discovered 
example discover fault tolerant association rules students doing courses data structure algorithm artificial intelligence database receive high grades data mining 
apriori extended ft apriori fault tolerant frequent pattern mining 
experimental results showed ft apriori solid step fault tolerant frequent pattern mining 
challenging develop efficient fault tolerant mining methods 
extensions implications related fault tolerant data mining tasks interesting research 
frequent pattern clustering 
clustering algorithms new challenges exist 
hand real datasets web documents high dimensionality missing dimensional values 
hand novel applications organizing web documents categories distance functions hard define properly clusters overlaps 
frequent pattern mining promising candidate technique problems 
set frequent patterns organize objects clusters patterns share 
technique avoid problem defining distance functions dealing high dimensionality explicitly 
mining long sequences 
emerging applications requires effective ef ficient mining long sequences bio sequences 
candidate generation test framework feasible solve problems number candidates chapter 
prohibitively large 
interesting approach apply pattern growth method bypass trivial patterns mining long target patterns 
final thoughts discovery consists seeing everybody seen thinking thought data mining effective efficient tool discovery 
min ing see patterns hidden data accurately systematically efficiently 
data miner responsibility distinguish gold dust 
science begins philosophy ends art data mining 
albert von gy hungarian born american 
story philosophy 
bibliography aap agarwal aggarwal prasad 
tree projection algorithm generation frequent itemsets 
journal parallel distributed computing special issue high performance data mining 
ais agrawal imielinski swami 
mining association rules sets items large databases 
proc 
acm sigmod int 
conf 
management data sigmod pages washington dc may 
agrawal srikant 
fast algorithms mining association rules 
proc 
int 
conf 
large data bases vldb pages santiago chile sept 
agrawal srikant 
mining sequential patterns 
proc 
int 
conf 
data engineering icde pages taipei taiwan mar 
bag bayardo agrawal gunopulos 
constraint rule mining large dense data sets 
proc 
int 
conf 
data engineering icde sydney australia april 
bay bayardo 
efficiently mining long patterns databases 
proc 
acm sigmod int 
conf 
management data sigmod pages seattle wa june 
bms brin motwani silverstein 
market basket generalizing association rules correlations 
proc 
acm sigmod int 
conf 
management data sigmod pages tucson arizona may 
brin motwani ullman tsur 
dynamic itemset counting implication rules market basket analysis 
proc 
acm sigmod int 
conf 
management data sigmod pages tucson arizona may 
br beyer ramakrishnan 
bottom computation sparse iceberg cubes 
proc 
acm sigmod int 
conf 
management data sigmod pages philadelphia pa june 
bibliography bettini sean wang jajodia 
mining temporal relationships multiple granularities time sequences 
data engineering bulletin 
dl dong li 
efficient mining emerging patterns discovering trends differences 
proc 
int 
conf 
knowledge discovery data mining kdd pages san diego ca aug 
fayyad piatetsky shapiro smyth uthurusamy eds 
advances knowledge discovery data mining 
aaai mit press 
glw grahne lakshmanan wang 
efficient mining constrained correlated sets 
proc 
int 
conf 
data engineering icde pages san diego ca feb 
grs garofalakis rastogi shim 
spirit sequential pattern mining regular expression constraints 
proc 
int 
conf 
large data bases vldb pages edinburgh uk sept 
han dong yin 
efficient mining partial periodic patterns time series database 
proc 
int 
conf 
data engineering icde pages sydney australia april 
han pei dong wang 
efficient computation iceberg cubes complex measures 
proc 
acm sigmod int 
conf 
management data sigmod santa barbara ca may 
han pei asl chen dayal 
hsu 
freespan frequent pattern projected sequential pattern mining 
proc 
int 
conf 
knowledge discovery data mining kdd pages boston ma aug 
han pei yin 
mining frequent patterns candidate generation 
proc 
acm sigmod int 
conf 
management data sig mod pages dallas tx may 
kamber han chiang 
metarule guided mining multidimensional association rules data cubes 
proc 
int 
conf 
knowledge discovery data mining kdd pages newport beach ca aug 
kmr klemettinen mannila ronkainen toivonen verkamo 
finding interesting rules large sets discovered association rules 
proc 
rd int 
conf 
information knowledge management pages gaithersburg maryland nov 
bibliography lu han feng 
stock movement dimensional association rules 
proc 
sigmod workshop research issues data mining knowledge discovery dmkd pages seattle wa june 
lhm liu hsu ma 
integrating classification association rule mining 
proc 
int 
conf 
knowledge discovery data mining kdd pages new york ny aug 
li han pei 
accurate efficient classification multiple class association rules 
proc 
ieee int 
conf 
data mining icdm san jose ca 
lakshmanan ng han pang 
optimization constrained frequent set queries variable constraints 
proc 
acm sigmod int 
conf 
management data sigmod pages philadelphia pa june 
lsw lent swami widom 
clustering association rules 
proc 
int 
conf 
data engineering icde pages birmingham england april 
mcp 
psp approach mining sequential patterns 
proc 
european symp 
principle data mining knowledge discovery pkdd pages nantes france sept 
mtv mannila toivonen verkamo 
discovery frequent episodes event sequences 
data mining knowledge discovery 
ng lakshmanan han pang 
exploratory mining pruning optimizations constrained associations rules 
proc 
acm sigmod int 
conf 
management data sigmod pages seattle wa june 
ors ramaswamy silberschatz 
cyclic association rules 
proc 
int 
conf 
data engineering icde pages orlando fl feb 
pasquier bastide taouil lakhal 
discovering frequent closed itemsets association rules 
proc 
th int 
conf 
database theory icdt pages jerusalem israel jan 
park chen yu 
effective hash algorithm mining association rules 
proc 
acm sigmod int 
conf 
management data sigmod pages san jose ca may 
bibliography ph pei han 
push constraints frequent pattern mining 
proc 
int 
conf 
knowledge discovery data mining kdd pages boston ma aug 
pei han lakshmanan 
mining frequent itemsets convertible constraints 
proc 
int 
conf 
data engineering icde pages heidelberg germany april 
pei han mao :10.1.1.27.6266
closet efficient algorithm mining frequent closed itemsets 
proc 
acm sigmod int 
workshop data mining knowledge discovery dmkd pages dallas tx may 
pei han asl pinto chen dayal 
hsu 
prefixspan mining sequential patterns efficiently prefix projected pattern growth 
proc 
int 
conf 
data engineering icde pages heidelberg germany april 
php pinto han pei wang chen dayal 
multi dimensional sequential pattern mining 
proc 
acm int 
conf 
information knowledge management cikm atlanta georgia november 
pth pei tung han 
fault tolerant frequent pattern mining problems challenges 
proc 
acm sigmod int 
workshop data mining knowledge discovery dmkd santa barbara ca may 
rms ramaswamy mahajan silberschatz 
discovery interesting patterns association rules 
proc 
int 
conf 
large data bases vldb pages new york ny aug 

search systematic set enumeration 
proc 
int 
conf 
principle knowledge representation reasoning kr pages cambridge ma 
sa srikant agrawal 
mining quantitative association rules large relational tables 
proc 
acm sigmod int 
conf 
management data sigmod pages montreal canada june 
sa srikant agrawal :10.1.1.40.6428
mining sequential patterns generalizations performance improvements 
proc 
th int 
conf 
extending database technology edbt pages avignon france mar 
silverstein brin motwani ullman 
scalable techniques mining causal structures 
proc 
int 
conf 
large data bases vldb pages new york ny aug 
bibliography son savasere omiecinski navathe :10.1.1.103.5437
efficient algorithm mining association rules large databases 
proc 
int 
conf 
large data bases vldb pages zurich switzerland sept 
sta sarawagi thomas agrawal 
integrating association rule mining relational database systems alternatives implications 
proc 
acm sigmod int 
conf 
management data sigmod pages seattle wa june 
sva srikant vu agrawal 
mining association rules item constraints 
proc 
int 
conf 
knowledge discovery data mining kdd pages newport beach ca aug 
toi toivonen 
sampling large databases association rules 
proc 
int 
conf 
large data bases vldb pages bombay india sept 
wcm wang chirn marr shapiro shasha zhang 
pattern discovery scientific data preliminary results 
proc 
acm sigmod int 
conf 
management data sigmod pages minneapolis mn may 
web webb 
opus efficient admissible algorithm unordered search 
journal artificial intelligence research 
zak zaki 
efficient enumeration frequent sequences 
proc 
th int 
conf 
information knowledge management cikm pages washington dc nov 
zh zaki hsiao 
charm efficient algorithm closed association rule mining 
technical report computer science rensselaer polytechnic institute 
