making reliable distributed systems presence sodware errors final version corrections update november joe armstrong dissertation submitted royal institute technology partial fulfilment requirements degree doctor technology royal institute technology stockholm sweden december department microelectronics information technology ii issn isrn kth se sics dissertation series issn isrn sics se joe armstrong printed ab iii helen thomas claire iv described thesis result research program started find better ways programming telecom applications 
applications large programs despite careful testing probably contain errors program put service 
assume programs contain errors investigate methods building reliable systems despite errors 
research resulted development new programming language called erlang design methodology set libraries building robust systems called otp 
time writing technology described number major ericsson nortel products 
number small companies formed exploit technology 
central problem addressed thesis problem constructing reliable systems programs may contain errors 
constructing systems imposes number requirements programming language construction 
discuss language requirements show satisfied erlang 
problems solved programming language standard libraries accompany language 
argue certain requirements necessary build fault tolerant system solved language solved standard libraries 
form basis building fault tolerant sodware systems 
theory complete proof ideas practice 
demonstrate ideas practice number case studies large commercially successful products technology 
time writing largest projects major ericsson vi product having lines erlang code 
product axd thought reliable products ericsson 
ask goal finding better ways program telecom applications fulfilled point areas think system improved 
contents background 
ericsson background 
chronology 
thesis outline 
chapter chapter summary 
architectural model definition architecture 
problem domain 
philosophy 
concurrency oriented programming 
programming observing real world 
characteristics 
process isolation 
names processes 
message passing 
protocols 
cop programmer teams 
system requirements 
language requirements 
library requirements 
application libraries 
construction guidelines 
related 
vii viii erlang overview 
example 
sequential erlang 
data structures 
variables 
terms patterns 
guards 
extended pattern matching 
functions 
function bodies 
tail recursion 
special forms 
case 

higher order functions 
list comprehensions 
binaries 
bit syntax 
records 
epp 
macros 
include files 
concurrent programming 
register 
error handling 
exceptions 
catch 
exit 
throw 
corrected uncorrected errors 
process links monitors 
distributed programming 
ports 
dynamic code change 
type notation 
discussion 
programming techniques abstracting concurrency 
fault tolerant client server 
maintaining erlang view world 
error handling philosophy 
process fix error 
workers supervisors 
crash 
intentional programming 
discussion 
programming fault tolerant systems programming fault tolerance 
supervision hierarchies 
diagrammatic representation 
linear supervision 
supervision hierarchies 
error 
behaved functions 
building application behaviours 
behaviours written 
generic server principles 
generic server api 
generic server example 
event manager principles 
event manager api 
event manager example 
finite state machine principles 
finite state machine api 
finite state machine example 
ix supervisor principles 
supervisor api 
supervisor example 
application principles 
applications api 
application example 
systems releases 
discussion 
otp libraries 
case studies methodology 
axd 
quantitative properties sodware 
system structure 
evidence fault recovery 
trouble report hd 
trouble report hd 
deficiencies otp structure 
smaller products 
mail 
alteon ssl accelerator 
quantitative properties code 
discussion 
apis protocols protocols 
apis protocols 
communicating components 
discussion 
achieved far 
ideas 
conceptual integrity 
files bang bang 
distribution bang bang 
spawning bang bang 
naming processes 
programming bang bang 
exposing interface discussion 
programming communicating components 
acknowledgments programming rules conventions ubf xi xii program systems behave reasonable manner presence sodware errors 
central question hope answer thesis 
large systems probably delivered containing number errors sodware systems expected behave reasonable manner 
reliable system faulty components places certain requirements system 
requirements satisfied programming language solve problem standard libraries called application programs solve problem 
thesis identify essential characteristics believe necessary build fault tolerant sodware systems 
show characteristics satisfied system 
essential characteristics satisfied programming language erlang satisfied library modules written erlang 
language libraries form basis building reliable sodware systems function adequate manner presence programming errors 
having said thesis say 
thesis cover detail algorithms building blocks construction fault tolerant systems algorithms concern thesis programming language algorithms expressed 
am chapter 
concerned hardware aspects building fault tolerant systems sodware engineering aspects fault tolerance 
concern language libraries operating system requirements sodware fault tolerance 
erlang belongs family pure message passing languages concurrent process language having strong isolation concurrent processes 
programming model extensive fail fast processes 
techniques common hardware platforms building fault tolerant systems commonly sodware solutions 
mainly conventional languages permit dicerent sodware modules exist way interference modules 
commonly threads model programming resources shared extremely diecult isolate components errors component propagate component damage internal consistency system 
background reported thesis started ericsson computer science cslab 
personal involvement started joined cslab 
reported performed period 
time erlang programming language otp developed author colleagues number large applications written erlang 
system know today result collective large number people 
feedback users erlang today 
parts system diecult say precision exactly exactly original ideas particular innovation 
tried credit everybody accurately possible 
chronology follows ericsson cslab formed 
goal laboratory suggest new architectures concepts structures 
background processing systems developments 
start language erlang time language name 
language started experiment add concurrent processes prolog described 
stage intend design new programming language interested program pots plain old telephony service time best method programming pots appeared variant prolog augmented parallel processes 
mention erlang 
term erlang coined probably head cslab bjarne cker 
year prolog implementation erlang available 
version erlang embedded prolog prolog infix operators syntax 
major experiment erlang started group ericsson engineers led kerstin started prototyping project 
chose erlang prototype called acs acs architecture designed implementing ericsson md private automatic branch exchange 
project implement number typical features erlang acs architecture compare programming time estimated job taken plex 
ideas current erlang otp system traced back project 
time clear erlang suitable programming telecoms systems group wrote applications erlang cslab group augmented plex programming language program md 
chapter 
robert virding mike williams worked improving erlang system 
attempt improve erlang cross compilation parallel logic programming language strand 
compilation erlang strand described chapter 
cross compilation strand improved performance erlang factor project viewed failure 
acs project began produce results 
group showed acs erlang lead improvement design factor times corresponding plex 
result experience prototyping functionality ericsson md figures debated depending believed erlang 
group estimated need factor performance improvement promised order turn acs prototype commercial product 
improve performance erlang designed jam machine joe machine 
design jam machine loosely warren machine 
erlang started extension prolog reasonable techniques implement prolog applicable erlang 
intuition proved correct 
jam machine similar wam addition parallel processes message passing failure detection omission backtracking 
compilation pattern matching essentially wam 
original jam instruction set details compilation process published 
design jam completed 
implementation instruction set emulator written prolog emulated jam machine 
fact recorded strand book 

background evaluate approximately reductions second evaluate test virtual machine allow erlang compiler written erlang 
design jam complete started implementation virtual machine soon abandoned ader mike williams read code ader worked compiler 
mike williams wrote virtual machine emulator robert virding worked erlang libraries 
jam machine working surpassed original goal times faster original prolog interpreter 
erlang syntax regarded dialect prolog regarded language right dialect prolog 
added distribution erlang 
jam machine stable replaced prolog implementation erlang 
decision ericsson business systems develop product acs 
product called mobility server ericsson erlang developments xiv international switching symposium yokohama japan 
ericsson starts wholly owned subsidiary called erlang systems ab 
purpose market sell erlang external customers provide training consulting services internal external customers 
support erlang performed ericsson computer science laboratory 
commercial version erlang released 
ericsson axe project collapsed 
axe project project build generation switch replace ericsson axe 
extremely large project ran 
chapter 
ader axe project collapsed decision restart project erlang 
project eventually resulted development axd switch 
project larger scale previous erlang project 
reason new group started provide support axd project 
erlang libraries renamed otp open telecom platform new group created 
order provide erlang users stable sodware base project called otp open telecom platform started 
otp primarily newly started axd project existing projects migrate otp 
otp project consolidated number ideas derived experience erlang particular earlier set libraries developed mobility server 
otp project turned otp product unit started order take formal responsibility erlang 
prior cslab formally responsible erlang 
moved cslab otp group worked chief technical ordinator 
period person group magnus fr berg martin bj redesigned implemented otp core libraries 
ericsson delivered axd 
axd subject case studies chapter 
time writing axd lines erlang code probably largest system written functional style programming 
february erlang banned new product development ericsson main reason ban ericsson wanted consumer sodware technologies producer 
december erlang otp libraries released subject open source license 
date freely 
thesis outline available download www erlang org led ericsson number original erlang group new ab people led ericsson 
idea erlang technology program products internet services reliable 
produced products written erlang 
mail web 
ericsson produced number erlang products including axd gprs systems 
acquired alteon web systems subsequently alteon acquired nortel networks 
erlang otp technology established 
projects knows exact number 
erlang products developed nortel selling hundreds millions year ericsson axd ericsson successful new products dozen small companies erlang product development 
thesis outline thesis organized chapters chapter introduces main problem area thesis addresses gives background thesis chronology performed thesis detailed chapter plan 
chapter introduces architectural model basis chapters thesis 
define meant architecture specify components architecture 
talk problem domain architecture designed 
talk underlying philosophy architecture introduce idea concurrency oriented programming cop 
chapter 
develop idea cop state desirable properties programming language system order support concurrency oriented style programming 
review previous related showing similarities prior material thesis 
chapter describes programming language erlang 
describe reasonably large sub set erlang programming language motivate design decisions erlang 
chapter gives examples erlang programming techniques 
show factor design functional non functional components 
show factor notions concurrency fault tolerance program generic client server model 
describe technique maintaining illusion erlang process give examples write code handles errors 
chapter gets central question thesis 
concerned program systems behave reasonable manner presence errors 
central idea fault tolerance notion error describe meant error mean talk fault tolerant system 
describe strategy idea supervision trees writing fault tolerant sodware 
chapter links general principles programming fault tolerant system developed previous chapter number specific programming patterns developed programming fault tolerant systems 
programming patterns central understanding otp system build fault tolerant sodware erlang 
give complete example involving client server model event handler finite state machine 

thesis outline components added supervision tree monitor progress restart event error 
entire program packaged single otp application chapter describes otp system 
otp stands open telecoms platform application operating system programming fault tolerant applications delivery platform erlang programming language 
includes large set libraries implementing fault tolerant systems documentation guides understanding system 
chapter briefly describe otp architecture give details main components system 
chapter acid test technology 
ideas practice 
chapter analyse number large commercially successful products otp 
intention chapter see achieved goals programming system functions reliably presence sodware errors 
projects studied chapter ericsson axd high performance highly reliable atm switch 
project interesting right largest programs written functional style 
chapter concerned apis protocols 
ask specify interfaces modules interfaces communicating components 
chapter ask broader questions 
ideas 
badly 
things improved 
look going get 
chapter 
architectural model standard universally accepted definition term software architecture field infancy 
standard definition shortage 
carnegie mellon institute software engineers chapter presents architecture building fault tolerant systems 
everybody vague idea word architecture means widely accepted definitions leads misunderstandings 
definition captures general idea meant sodware architecture architecture set significant decisions organization sodware system selection structural elements interfaces system composed behaviour specified collaborations elements composition structural behavioural elements progressively larger subsystems architectural style guides organization elements interfaces collaborations composition 
booch rumbaugh jacobson chapter 
architectural model definition architecture highest level abstraction architecture way thinking world useful turn way thinking world practical set procedures tells construct particular system particular way looking world 
sodware architecture characterised descriptions things 
problem domain type problem architecture designed solve 
sodware architectures general purpose designed solving specific problems 
description architecture complete describing type problem supposed solved architecture 

philosophy reasoning method sodware construction 
central ideas architecture 

set construction guidelines program system 
need explicit set construction guidelines 
systems written maintained teams programmers important programmers system designers understand system architecture underlying philosophy 
practical reasons knowledge conveniently maintained form construction guidelines 
full set guidelines includes sets programming rules examples course material 
set pre defined components design choosing set pre defined components far easier design scratch erlang otp libraries contain complete set pre defined components called behaviours commonly system components built 
examples gen server behaviour build client server systems gen event behaviour build event pro 
problem domain grams 
pre defined components discussed fully section 
section gives simple example program server gen sever behaviour 

way describing things describe interfaces component 
describe communication protocol components system 
describe static dynamic structure system 
answer questions introduce number dicerent specialised notations 
describing program apis notations describing protocols system structure 

way configuring things start configure system 
re configure system operation 
problem domain system originally designed building telecoms switching systems 
telecoms switching systems demanding requirements terms reliability fault tolerance telecoms systems expected operate forever exhibit sod real time behaviour behave reasonably presence sodware hardware errors 
cker gave requirements properties telecoms system 
system able handle large numbers concurrent activities 

actions performed certain point time certain time 

systems may distributed computers 

system control hardware 
chapter 
architectural model 
sodware systems large 

system exhibits complex functionality feature interaction 

systems continuous operation years 

sodware maintenance reconfiguration performed stopping system 

stringent quality reliability requirements 

fault tolerance hardware failures sodware errors provided 
motivate requirements follows concurrency switching systems inherently concurrent typical switch tens thousands people may simultaneously interact switch 
implies system able handle tens thousands concurrent activities 
sod real time telecommunications system operations performed specific time 
timed operations strictly enforced sense operation succeed time interval entire operation aborted 
operations merely monitored form timer operation repeated timer event triggers operation completed 
programming systems requires manipulating tens thousands timers manner 
distributed switching systems inherently distributed system structured way easy go single node system multi node distributed system 

problem domain hardware interaction switching systems large amounts peripheral hardware controlled monitored 
implies possible write device drivers context switching dicerent device drivers 
large sodware systems switching systems large example ericsson axe ess switch lines program code 
means sodware systems millions lines source code 
complex functionality switching systems complex functionality 
market pressure encourages development deployment systems large numbers complex features 
oden systems deployed interaction features understood 
lifetime system feature set probably changed extended ways 
feature sodware upgrade performed place stopping system 
continuous operation telecommunications systems designed years continuous operation 
implies operations sodware hardware maintenance performed stopping system 
quality requirements switching systems run acceptable level service presence errors 
telephone exchanges expected extremely reliable 
fault tolerance switching systems fault tolerant means outset know faults occur design sodware hardware infrastructure deal faults provide acceptable level service presence faults 
typically having hours time years 
chapter 
architectural model requirements came originally telecoms world means exclusive particular problem domain 
modern internet services example web servers strikingly similar list requirements 
philosophy fault tolerant sodware system behaves reasonable manner presence sodware errors 
answering take rest thesis 
start giving short answer refined remainder thesis 
fault tolerant sodware system behaves reasonably presence sodware errors proceed follows 
organise sodware hierarchy tasks system perform 
task corresponds achievement number goals 
sodware task try achieve goals associated task 
tasks ordered complexity 
top level task complex goals top level task achieved system function perfectly 
lower level tasks allow system function acceptable manner may reduced level service 
goals lower level task easier achieve goals higher level task system 

try perform top level task 

error detected trying achieve goal attempt correct error 
correct error immediately abort current task start performing simpler task 
programming hierarchy tasks needs strong encapsulation method 
need strong encapsulation error isolation 
want pro 
philosophy gramming errors part system adversely sodware parts system 
need isolate code runs order achieve goal way detect errors occurred trying achieve goal 
trying simultaneously achieve multiple goals want sodware error occurring part system propagate part system 
essential problem solved making fault tolerant sodware system fault isolation 
dicerent programmers write dicerent modules modules correct errors 
want errors module adversely behaviour module errors 
provide fault isolation traditional operating system notion process 
processes provide protection domains error process operation processes 
dicerent programmers write dicerent applications run dicerent processes errors application negative influence applications running system 
course true approximation 
processes cpu memory processes try hog cpu try excessive memory negatively processes system 
extent processes interfere depends design characteristics operating system 
system processes concurrency part programming language provided host operating system 
number advantages operating system processes concurrent programs run identically dicerent oss limited processes implemented particular operating system 
observable moving os processors due dicerent cpu speeds memory sizes issues synchronization inter process interaction irrespective properties host operating system 
chapter 
architectural model language processes lighter weight conventional os processes 
creating new process language highly operation orders magnitude faster process creation operating systems orders magnitude faster thread creation programming languages 
system little need operating system 
operating system services relatively easy port system specialised environments embedded systems 
applications structured large numbers communicating parallel processes 
take approach 
provides architectural infrastructure organize system set communicating processes 
enumerating processes system defining message passing channels processes conveniently partition system number defined sub components independently implemented tested 
methodology implied top level sdl system design methodology 

potential system designed implemented number independent concurrent processes implemented multi processor run distributed network processors 
note potential works best application partitioned number truly independent tasks 
strong data dependencies tasks possible 

fault isolation concurrent processes data sharing provide strong measure fault isolation 
sodware error concurrent process influence processing processes system 

concurrency oriented programming uses concurrency non essential characteristics provided kind built scheduler provides various forms pseudo parallel time sharing processes 
third characteristic essential programming fault tolerant systems 
independent activity performed completely isolated process 
processes share data communicate message passing 
limit consequences sodware error 
soon processes share common resource example memory pointer memory mutex possibility exists sodware error processes corrupt shared resource 
eliminating sodware errors large sodware systems unsolved problem think realistic way build large reliable systems partitioning system independent parallel processes providing mechanisms monitoring restarting processes 
concurrency oriented programming system concurrency plays central role coined term concurrency oriented programming distinguish style programming programming styles 
concurrency oriented programming concurrent structure program follow concurrent structure application 
particularly suited programming applications model interact real world 
concurrency oriented programming provides major advantages commonly associated object oriented programming 
polymorphism defined protocols having message passing interface instances dicerent process types 
partition problem number concurrent processes arrange processes respond messages object oriented programming models world terms objects functional programming uses functions logic programming uses relations 
chapter 
architectural model polymorphic follow message passing interface 
word concurrency refers sets events happen simultaneously 
real world concurrent consists large number events happen simultaneously 
atomic level bodies atoms molecules simultaneous motion 
macroscopic level universe populated galaxies stars simultaneous motion 
perform simple action driving car freeway aware fact may hundreds cars immediate environment able perform complex task driving car avoiding potential hazards thinking 
real world sequential activities rarity 
walk street surprised find thing happening expect encounter simultaneous events 
ability analyze predict outcome simultaneous events live great danger tasks driving car impossible 
fact things require processing massive amounts parallel information suggests equipped perceptual mechanisms allow intuitively understand concurrency consciously thinking 
comes computer programming things suddenly inverted 
programming sequential chain activities viewed norm sense thought easy programming collections concurrent activities avoided possible generally perceived diecult 
believe due poor support provided concurrency virtually conventional programming languages 
vast majority programming languages essentially sequential concurrency language provided underlying operating system programming language 
thesis view world concurrency provided programming language underlying operating system 
languages support concurrency call concur 
concurrency oriented programming oriented languages short 
programming observing real world oden want write programs model world interact world 
writing program easy 
firstly perform analysis step process 
identify truly concurrent activities real world activity 

identify message channels concurrent activities 

write messages flow dicerent message channels 
write program 
structure program exactly follow structure problem 
real world concurrent activity mapped exactly concurrent process programming language 
mapping problem program say program isomorphic problem 
extremely important mapping exactly 
reason minimizes conceptual gap problem solution 
mapping program quickly degenerate diecult understand 
degeneration oden observed non languages solve concurrent problems 
oden way get program force independent activities controlled language thread process 
leads inevitable loss clarity programs subject complex interference errors 
performing analysis problem choose appropriate granularity model 
example writing instant messaging system choose process user process atom user body 
chapter 
architectural model characteristics characterised properties 
support processes 
process thought self contained virtual machine 

processes operating machine strongly isolated 
fault adversely process interaction explicitly programmed 

process identified unique unforgeable identifier 
call pid process 

shared state processes 
processes interact sending messages 
know pid process send message process 

message passing assumed unreliable guarantee delivery 

possible process detect failure process 
know reason failure 
note provide true concurrency objects represented processes truly concurrent messages processes true asynchronous messages disguised remote procedure calls object oriented languages 
note reason failure may correct 
example distributed system receive message informing process died fact network error occurred 
process isolation notion isolation central understanding cop construction fault tolerant sodware 
processes operating 
concurrency oriented programming machine independent ran physically separated machines 
ideal architecture run program machine assigned new physical processor sodware process 
ideal reached live fact multiple processes run machine 
think ran physically separated machine 
isolation consequences 
processes share semantics 
obvious imagined run physically separated machines 

message passing way pass data processes 
shared means possible exchange data 

isolation implies message passing asynchronous 
process communication synchronous sodware error receiver message indefinitely block sender message destroying property isolation 

shared necessary perform distributed computation copied 
shared way communicate processes message passing know messages arrive remember said message passing inherently unreliable 
way know message correctly sent send confirmation message back 
programming system processes subject rules may appear sight diecult ader concurrency extensions sequential programming languages provide facilities exactly opposite providing things locks semaphores provision shared data reliable message passing 
fortunately opposite turns true programming system turns surprisingly chapter 
architectural model easy programs write scalable fault tolerant little 
processes required complete isolated adding processes original system 
sodware written handle collections isolated processes adding processors usually accomplished major changes application sodware 
assumptions reliable message passing write application works presence unreliable message passing presence message passing errors 
initial involved reward try scale systems 
names processes require names processes unforgeable 
means impossible guess name process interact process 
assume processes know names processes create processes know names processes created 
words parent process knows names children 
order write need mechanisms finding names processes involved 
remember know name process send message process 
system security intimately connected idea knowing name process 
know name process interact way system secure 
names processes widely know system secure 
call process revealing names processes controlled manner name distribution problem key security lies name distribution problem 
reveal pid process say published name process 
name published security problems 
knowing name process key element security 
names unforgeable system secure limit 
concurrency oriented programming knowledge names processes trusted processes 
primitive believed humans powers command real names 
knowing real name spirit gave power spirit name command spirit various things 
idea 
message passing message passing obeys rules 
message passing assumed atomic means message delivered entirety 

message passing pair processes assumed ordered meaning sequence messages sent received pair processes messages received order sent 

messages contain pointers data structures contained processes contain constants pids 
note point design decision reflect underlying semantics network transmit messages 
underlying network reorder messages pair processes messages re assembled correct order delivery 
assumption programming message passing applications easier allow order messages 
say message passing send semantics 
send message arrives 
confirmation message arrived achieved returning confirmation message called round trip confirmation 
interestingly programmers believe round trip confirmation underlying transport layers supposed provide reliable data transport checks supposedly irrelevant 
chapter 
architectural model message passing synchronisation 
suppose wish synchronise processes sends message receive message point time ader sent message 
known casual ordering distributed systems theory 
interprocess synchronisation simple idea 
protocols isolation components message passing components architecturally protecting system consequences sodware error specify behaviour system event kind failure determine component failed 
assumed failure property single component single component supposed fail soon possible 
happen components observed fail system expected 
complete programming model add thing 
need completely isolated components communicate message passing need specify communication protocols pair components communicate 
specifying communication protocol obeyed components easily find components involved violated protocol 
guaranteeing protocol enforced done static analysis possible failing compiling run time checks code 
cop programmer teams building large system involves programmers hundreds programmers involved 
organise programmers organised smaller groups teams 
group responsible logical component system 
day day basis groups communicate message passing mail 
system requirements phone regularly meet 
cases groups dicerent countries meet 
amusing note organisation sodware system isolated components communicate pure message passing desirable number reasons way large programming groups organised 
system requirements support style programming system satisfy requirements telecoms system arrive set requirements essential characteristics system 
requirements system am interested requirements satisfied programming language libraries construction methods accompany language 
essential requirements underlying operating system programming languages 

concurrency system support concurrency 
computational needed create destroy concurrent process small penalty creating large numbers concurrent processes 

error encapsulation errors occurring process able damage processes system 

fault detection possible detect exceptions locally processes exception occurred remotely able detect exception occurred non local process 

fault identification able identify exception occurred 

code upgrade exist mechanisms change code executing stopping system 
chapter 
architectural model 
stable storage need store data manner survives system crash 
important systems satisfying requirements implemented concurrency reliably create tens thousands processes 
fault identification contain information allow correct error date 
satisfying requirements done number different ways 
concurrency example provided language primitive example erlang operating system example unix 
languages java concurrent operating system primitives gives user illusion concurrent concurrent programs written languages concurrent 
language requirements programming language program system encapsulation primitives number mechanisms limiting consequences error 
possible isolate processes damage 
concurrency language support lightweight mechanism create parallel process send messages processes 
context switching process message passing 
concurrent processes time share cpu reasonable manner cpu bound processes cpu prevent progress processes ready run fault detection primitives allow process observe process detect observed process terminated reason 

library requirements location transparency know pid process able send message process 
dynamic code upgrade possible dynamically change code running system 
note processes running code need mechanism allow existing processes run old code new processes run modified code time 
language satisfy requirements satisfy reasonably manner 
program want limit freedom expression counting processes want worry happen process inadvertently tries cpu 
maximum number processes system large programming purposes consider maximum number limiting factor 
need example create order processes order switching system maintains simultaneous user sessions 
mix features needed simplify applications programming 
mapping semantics distributed set communicating components erlang program greatly simplified map concurrent structure problem manner process structure application program solves problem 
library requirements language number things provided accompanying system libraries 
essential set libraries routines provide stable storage storage survives crash 
assuming processes session 
chapter 
architectural model device drivers provide mechanism communication outside world 
code upgrade allows upgrade code running system 
infrastructure starting stopping system logging errors observe library routines written erlang provide services conventionally provided operating system 
erlang process isolated communicate message passing behave operating system processes communicate pipes sockets 
features conventionally provided operating system moved operating system programming language 
remaining operating system provides primitive set device drivers 
application libraries stable storage provided language primitive erlang provided basic erlang libraries 
having libraries precondition writing complex application sodware 
complex applications need higher level abstractions storage build applications need pre packaged sodware entities help program things client server solutions otp libraries provide complete set design patterns called behaviours building fault tolerant applications 
thesis talk minimal set behaviours building fault tolerant applications 
supervisor supervision model 
gen server behaviour implementing client server applications 

construction guidelines gen event behaviour implementing event handling sodware 
gen fsm behaviour implementing finite state machines 
central component programming faulttolerant applications supervision model 
construction guidelines addition explaining general philosophy programming faulttolerant applications need specific guidelines apply programming languages wish program applications 
need example programs examples library routines 
open source erlang release contains guidelines basis systems millions lines erlang code 
appendix reproduces programming guidelines erlang open source release 
thesis contains additional guidelines organized follows philosophy architecture described chapter 
notion error discussed places 
sections describe meant error section gives advice correct programing style programming errors erlang 
examples program simple components chapter examples otp behaviours chapter 
chapter 
architectural model related inability isolate sodware components main reason popular programming languages making robust system sodware 
essential security able isolate programs protect host platform programs 
isolation diecult object oriented systems objects easily aliased 
bryce bryce goes say object aliasing diecult impossible detect practice recommends protection domains akin os processes solve problem 
java czajkowski sun microsystems write safe way execute multiple applications written java programming language computer separate jvm execute jvm separate os process 
introduces various resource utilization performance scalability application startup time 
benefits language reduced mainly portability improved programmer productivity 
granted important full potential language provided safety realized 
exists curious distinction language safety real safety 
introduce mvm extension jvm goal turn jvm execution environment akin os 
particular abstraction process aliased object objects hold 

related modern oses role model terms features isolation computations resources accountability control ease termination resource reclamation 
achieve conclude tasks directly share objects way tasks communicate standard copying communication mechanisms 
new 
similar arrived decades earlier jim gray described architecture tandem computer highly readable computers done 
says hardware key sodware fault tolerance hierarchically decompose large systems modules module unit service unit failure 
failure module propagate module 
process achieves fault containment sharing state processes contact processes messages carried kernel message system 
language support style programming parallel processes shared data pure message passing andrews schneider refer message oriented languages language name probably example programming language fundamental design decision implementation rig allow strict message discipline shared programming language sky 
rig small system written 
chapter 
architectural model data structures 
communication user server messages messages routed aleph kernel 
message discipline proved flexible reliable 
turning away language ask properties individual process 
schneider answered question giving properties thought hardware system order suitable programming fault tolerant system 
properties schneider called 
halt failure event error processor halt performing possibly erroneous operation 

failure status property processor fails processors system informed 
reason failure communicated 

stable storage property storage processor partitioned stable storage survives processor crash volatile storage lost processor crashes 
processor having properties schneider called fail processor 
idea failure occurs pointless continue 
process halt continuing possibly causing damage 
fault processor state stored volatile stable memory 
processor crashes data volatile memory lost state stored stable storage available ader crash 
remarkably similar idea gray talks fail fast processes :10.1.1.59.6561
process approach fault isolation advocates process sodware fail fast function correctly detect fault signal failure operating 
schneider considers failure error corrected 

related processes fail fast defensive programming 
check inputs intermediate results data structures matter course 
error detected signal failure 
terminology cristian fail fast sodware small fault detection latency 
schneider gray essential idea talking hardware sodware underlying principles 
argued important processes fail soon possible ader error occurred fault sodware system cause errors 
latency time interval existence fault occurrence error high complicates backwards analysis error 
error handling detect errors failures early possible bearing mind arguments original requirements advocate system properties 
processes units error encapsulation errors occurring process processes system 
call property strong isolation 

processes supposed fail soon possible 

failure reason failure detected remote processes 

processes share state communicate message passing 
language system properties necessary preconditions writing fault tolerant sodware 
thesis see properties satisfied erlang erlang libraries 
chapter 
architectural model ideas thesis new fundamental principles making fault tolerant system described gray 
features tandem computer bear striking similarity design principles otp system fundamental principles concurrency oriented programming discussed earlier 
quotes firstly design principles page 
keys sodware fault tolerance sodware modularity processes messages 
fault containment fail fast sodware modules 
process pairs tolerant hardware transient sodware faults 
transaction mechanisms provide data message integrity 
transaction mechanisms combined process pairs ease exception handling tolerate sodware faults 
sodware modularity processes messages 
hardware key sodware fault tolerance hierarchically decompose large systems modules module unit service unit failure 
failure module propagate module 
considerable controversy modularize sodware 
starting burroughs continuing languages mesa ada compiler writers assumed perfect hardware contended provide isolation static compile time type checking 
contrast operating systems designers advocated run time checking combined process unit protection failure 

related compiler checking exception handling provided programming languages real assets history favored run time checks plus process approach fault containment 
virtue simplicity process processor misbehaves 
process provides clean unit modularity service fault containment failure 
fault containment fail fast sodware modules 
process achieves fault containment sharing state processes contact processes messages carried kernel message system 
compare current erlang system see striking similarities 
certain erlang defensive programming recommended compiler adds necessary checks style programming unnecessary 
gray transaction mechanism provides mnesia data base 
containment processing errors managed supervision tree behaviours otp libraries 
idea fail fast modules mirrored guidelines programming say processes supposed specification crash 
supervision hierarchies system correspond hierarchies modules gray refers 
idea candea fox talked crash sodware argue allowing components crash restart leads simpler fault model reliable code 
modern object oriented systems recognised importance isolating sodware components 
bryce argue essential isolate programs programs run host operating system 
consider essential characteristic object system 
point diecult problem object oriented context 
written erlang 
chapter 
architectural model erlang chapter introduces erlang 
treatment language intended complete 
fuller treatment reader referred 
developments erlang otp documentation 
formal treatment erlang erlang specification core erlang specification 
erlang belongs class message oriented languages message oriented languages provide concurrency form parallel processes 
shared objects message oriented language 
interaction processes achieved sending receiving messages 
chapter subset language provides detail understand erlang examples thesis 
overview erlang view world summarized statements process 
processes strongly isolated 
process creation destruction lightweight operation 
chapter 
erlang message passing way processes interact 
processes unique names 
know name process send message 
processes share resources 
error handling non local 
processes supposed fail 
processes basic unit abstraction motivated desire language suitable writing large fault tolerant sodware systems 
fundamental problem solved writing sodware limiting consequences error process abstraction provides abstraction boundary stops propagation errors 
example precisely inability limit consequences errors java unsuitable programming safe sic applications see page discussion point 
processes truly isolated limit consequences error properties process example way processes interact message passing follow natural consequence isolation 
statement error handling obvious 
fault tolerant system need physically separated computers 
single computer crashes lost 
simplest fault tolerant system imagine exactly computers computer crashes computer take computer doing 
simple situation sodware fault recovery non local error occurs machine corrected sodware running second machine 
erlang view world process model physical machines processes retain idea error handling non local 
modified truth remote 
example error handling occurs local attempt fix error fails 
event exception local process may able detect correct fault caused exception case far process system concerned error occurred 
viewed concurrent language erlang simple 
shared data structures monitors synchronised methods little learn 
bulk language possible interesting part language sequential subset language 
sequential subset characterised dynamically typed strict functional programming language largely free side 
sequential subset operations side virtually needed 
remainder chapter deals firstly sequential subset language 
followed sections concurrent distributed programming error handling 
describe type notation specifying erlang data function types 
jump start description start example sequential erlang code 
example simple erlang program 
program structure 
program starts module definition line followed export input declarations number functions 

export declaration line says function areas exported module 
notation areas means function called areas argument 
functions called outside module contained export list 

import declaration line says function map module lists 
chapter 
erlang module math 
export areas 
import lists map 
areas lists sum map fun area 
area square area rectangle erlang module 
example 
lines function definitions 

line call function sum module lists 

lines call function map module lists 
note call sum call map functions module call uses fully qualified name lists sum call uses abbreviated call sequence map 
lists map 
accounted import declaration line says function map module lists 

line creates fun argument map 

lines contain function area 
function clauses 
clause lines second lines clauses separated semi colon 

clause head body 
head body separated symbol 

function head consists pattern argument position possible guard see section 
line pattern rectangle 
pattern curly bracket denote tuple 
argument tuple atom rectangle second third arguments variables 
variables start capital letters atoms start small letters 
run program start erlang shell compile program enter requests evaluate functions shown 
user input underlined 
erlang shell prompt character meaning system waiting input 
line starts erlang shell 
line compiles module math 
chapter 
erlang erl erlang beam emulator version source abort math 
ok math math areas rectangle square 
math area square 
exited undef math area square erl eval expr erl eval exprs shell eval loop compiling running program shell line requests function evaluation shell accepts request evaluates function prints result line 
line try evaluate function exported module math 
exception generated printed lines 
sequential erlang data structures erlang primitive data types integers integers written sequences decimal digits example integers 
integer arithmetic called constants 

sequential erlang exact unlimited precision 
atoms atoms program denote distinguished values 
written strings consecutive alphanumeric characters character small letter 
atoms obtain character enclosed single quotes escape convention exists allows character atom 
floats floating point numbers represented ieee bit floating point numbers 
real numbers range represented erlang float 
globally unique symbols property compared equality 
created evaluating erlang primitive ref 
binaries binary sequence bytes 
binaries provide space way storing binary data 
erlang primitives exist composing decomposing binaries input output binaries 
full treatment binaries see 
pids pid short process identifier pid created erlang primitive spawn 
pids erlang processes 
ports ports communicate external world 
ports created bif open port 
messages sent received ports message obey called port protocol funs funs function closures 
funs created expressions form fun 

compound data types precision integers limited available memory 
bif short built function 
called lambda expressions languages 
chapter 
erlang tuples tuples containers fixed number erlang data types 
syntax dn denotes tuple arguments 
dn 
arguments primitive data types compound data types 
elements tuple accessed constant time 
lists lists containers variable number erlang data types 
syntax dh dt denotes list element dh remaining elements list dt 
syntax denotes empty list 
syntax dn short dn 
element list accessed constant time 
element list called head list 
remainder list head removed called tail list 
forms syntactic sugar provided strings strings written doubly quoted lists characters syntactic sugar list integer ascii codes characters string example string cat shorthand 
records records provide convenient way associating tag elements tuple 
allows refer element tuple name position 
pre compiler takes record definition replaces appropriate tuple 
variables variables erlang sequences characters starting upper case letter followed sequence letters characters character 
variables erlang unbound meaning value bound meaning value 
variable bound 
sequential erlang value changed 
variables called single assignment variables 
variable values changed programmer create new variable time want simulate destructive assignment 
example erlang equivalent expression written invent new variable change value terms patterns ground term defined recursively primitive data type tuple ground terms list ground terms 
pattern defined recursively primitive data type variable tuple patterns list patterns 
primitive pattern pattern variables dicerent 
pattern matching act comparing pattern ground term 
pattern primitive pattern ground terms shape constants occurring pattern occur ground term places pattern match succeed fail 
variables occurring pattern bound corresponding data items positions term 
process called unification 
formally primitive pattern term say matches ic list head ph tail pt list th tail tt ph match th pt match tt 
chapter 
erlang tuple elements pn tuple elements tn match match 
constant constant 
free variable bound examples pattern abcd matches term abcd creating binding 
pattern matches term cat creating bindings 
pattern abc match term abc 
guards guards expressions involving predicates 
written immediately ader primitive patterns introduced keyword 
example call program fragment abc guarded pattern 
guards written comma separated sequences guard tests guard test form binop ground terms 
available binary operators 
sequential erlang operator meaning greater equal greater equal equal equal equal equal guard expression evaluate atoms true false 
guard evaluates true say evaluation succeeded failed 
extended pattern matching primitive pattern variables dicerent 
extended pattern syntax primitive pattern variables required dicerent 
perform pattern matching extended patterns convert extended pattern primitive pattern guard match primitive pattern 
variable repeated pattern times rename second subsequent occurrences fresh variables 
fresh variable add predicate fi guard 
rules transformed pattern variable taken mean anonymous variable anonymous variable matches term variable binding created 
fresh variable occur current lexical context 
chapter 
erlang functions functions obey rules 
function composed clauses separated semi colons 

clause head followed separator followed body 

function head composed atom followed parenthesized set patterns followed optional guard 
guard introduced keyword 

function body consists sequence comma separated expressions 
body body 
pk pk 
extended patterns described previous section 
examples factorial factorial factorial 
member true member member member false 

sequential erlang function execution follows evaluate fun arg arg argn search definition function 
corresponding definition taken function patterns head clause match arguments arg argn function call 
pattern match succeeds associated guard test succeeds body clause evaluated 
free variables occurring patterns head clause values obtained result matching pattern clause head actual arguments provided call 
example evaluate expression member dog cat man dog ape showing steps taken 
assume definition member member true member member member false 

evaluate member dog cat man dog ape 
clause matches bindings dog cat 
guard test fails 

second clause matches dog man dog ape guard test system evaluates member current bindings 
evaluate member dog man dog ape 

time second clause matches bindings dog dog ape 
evaluate member dog dog ape 
clause matches bindings dog dog 
guard test clause succeeds 

evaluate true just true 
chapter 
erlang note time function clause entered fresh set variable bindings values variable step distinct step 
function bodies function bodies sequences expressions 
value sequence expressions obtained sequentially evaluating element sequence 
value body result evaluating expression sequence 
example suppose define function manipulate bank account deposit money old lookup new old money insert new new 
body function consists sequence statements 
evaluate expression deposit joe function entered bindings joe money 
lookup called 
assume returns return value matched free variable old match succeeds 
ader match continue set bindings joe money old 
tail recursion function call tail recursive calls function body calls functions system 
example consider functions 
sequential erlang 
point execution function called 
final function call call returns returns value value just returns value unmodified call function called tail call traditional stack machine tail calls compiled merely jumping code return address pushed stack return address stack point execution correct function return correct place called body function tail recursive possible execution paths function finish tail calls 
important thing note tail recursive functions run loops consuming stack space 
function oden called iterative functions functions written iterative non iterative recursive style 
illustrate factorial function written dicerent styles 
firstly non tail recursive way factorial factorial factorial 
write tail recursive manner requires additional function factorial factorial 
factorial factorial factorial 
chapter 
erlang non tail recursive functions tail recursive introducing auxiliary function additional argument 
functions erlang designed run infinite loops particular client server model assumes server run infinite loop 
loops written tail recursive manner 
typical infinite loop server written loop dict receive store key value loop dict store key value dict get key dict fetch key dict loop dict 
tail recursive 
special forms special forms conditional evaluation erlang expression sequences 
case statements 
case case syntax case expression pattern expr seq pattern expr seq called accumulator 

sequential erlang case evaluated follows firstly expression evaluated assume evaluates value 
value matched turn pattern pattern match 
soon match pattern pattern corresponding expression sequence expr seq evaluated result evaluating expression sequence expr seq value case statement 
second conditional primitive provided 
syntax guard expr seq guard expr seq evaluated follows firstly guard evaluated evaluates true value value obtained evaluating expression sequence expr seq 
guard succeed guard evaluated match 
guards statement evaluate true exception raised 
oden final guard statement atom true guarantees form statement evaluated guards failed 
higher order functions higher order functions functions take functions input arguments produce functions return values 
example function map lists module defined follows map fun fun map fun map fun 
chapter 
erlang map produces new list applying function element list example lists map fun 
higher order functions create control abstractions syntactic constructions exist language 
example programming language provides looping construct follows sum max sum erlang loop easily max sum max max sum max sum sum 
follows sum sum max sum 
functions return new functions defined 
example erlang shell illustrates adder fun fun 
fun erl eval adder adder 
fun erl eval adder 

sequential erlang variable adder contains function evaluating adder binds returns function fun 
ingenuity recursive functions defined example factorial fact fun fun 
fun erl eval fact 
functions referred syntax fun name arity 
example expression fun foo shorthand writing fun foo free variables occur place function defined 
list comprehensions list comprehensions expression generate lists values 
written syntax qualifier qualifier 
arbitrary expression qualifier generator filter 
chapter 
erlang generators written pattern expression evaluates list terms 
filters predicates boolean expressions 
example known quicksort algorithm expressed terms list comprehensions qsort qsort pivot qsort pivot pivot qsort pivot 
infix append operator 
interested crossword puzzles need compute permutations string function perms perms perms perms 
infix operator copy list element occurs removed 
example perms 
binaries binaries memory designed storing untyped data 
binaries primarily store large quantities unstructured data operations 
binaries store data space manner lists tuples 
example string stored list needs bytes storage character string stored binary needs byte character plus small constant overhead 

sequential erlang bif list binary converts io list binary inverse computed binary list term binary converts arbitrary term binary inverse binary term 
note io list list elements small integers small integer integer range binaries io lists 
bif list binary flattens io list produces binary constructed list 
binary list returns flat list small integers 
binary list strict inverse list binary case flat list small integers 
lists binaries concatenated concatenate binaries single binary split binary split binary 
illustrate number operations binaries shell list binary 
list binary 
concat binary 
split binary 
expression converts list binary 
notation represents binary bytes 
expression converts io list binary 
expression combines binaries single binary expression splits binaries 
term binary hello joe 
binary term 
hello joe chapter 
erlang bif term binary converts argument binary 
inverse function binary term reconstructs term binary 
binary produced term binary stored called external term format terms converted binaries term binary stored files sent messages network original term reconstructed 
extremely useful storing complex data structures files sending complex data structures remote machines 
bit syntax bit syntax provides notation constructing binaries pattern matching contents binaries 
understand binaries constructed give number examples shell 





line variables defined 
line constructs binary result just 
line value copied unchanged second byte binary 
try create binary value truncated fit single byte 
quantifier added line corrects problem 
quantify size integer assumed take bits 
line shows bit quantifier 

sequential erlang specify size integer byte order example 
big 
little 
line says create binary integer pack integer bits 
line tells system create bit integer big endian byte order line says little endian byte order 
bit fields packed 
creates single byte binary bit field followed bit field 
unpacking binaries opposite packing 
inverse line 
pattern machine operation binaries originally designed processing packet data 
pattern matching performed sequence zero segments 
segment written syntax value size hyphen separated list items form sign type unit chapter 
erlang specifies machine big little native 
sign signed unsigned 
type integer float binary 
unit form unit int int literal integer range 
total size segment size int bits long size multiple bits 
items may omitted items occur order 
nice example binaries erlang open source distribution section entitled erlang extensions shows parse ip version datagram single pattern matching operation 
define ip version 
define ip min hdr len 

size case ip version hlen id ttl proto binary hlen hlen hlen ip min hdr len opts binary data binary 
lines match ip datagram single pattern matching expression 
pattern complex spreading lines illustrating data fall byte boundaries easily extracted example fields bits long respectively 
having pattern matched ip datagram header data part datagram isolated lines 

sequential erlang records records provide method associating name particular element tuple 
problem tuples number elements tuple large diecult remember element tuple means 
small tuple rarely problem oden see programs manipulated tuples small number elements tuple 
number elements tuples greater diecult keep track meanings individual elements tuple 
number elements tuple large wish name elements tuple purposes records tuples 
record declarations written syntax record name key default key default 
name name record 
key key names fields record 
field record default value value particular field specified record created 
example define person record follows record person firstname lastname age 
record defined instance record created 
example example documentation 
chapter 
erlang person person firstname rip lastname van age creates rip van person 
write functions pattern match fields record create new records van birthday call birthday person age person age 
clause head matches record bound entire record bound age field record 
person age copy replacing old value field named age value epp erlang module compiled processed erlang preprocessor epp 
erlang pre processor performs macro expansion inserts necessary include files 
output pre processes saved file giving command compile file 
compiles code file erl produces listing file macros expanded necessary include files included 
macros erlang macros written define constant replacement 
define func var var var replacement 
google know old van pure guesswork 

sequential erlang macros expanded erlang pre processor epp expression form encountered 
variables occurring macro definition match complete forms corresponding site macro call 
define macro 
foo macro expands foo 
argument call macro return value macro complete balanced expression 
possible macros define start 
define 
foo start 
addition number predefined macros provide information current module 
follows file expands current file name 
module expands current module name 
line expands current line number 
chapter 
erlang include files files included syntax include filename 
conventional include files extension hrl 
filename contain absolute relative path preprocessor locate appropriate file 
library header files included syntax include lib name 
example include lib kernel include file hrl 
case erlang compiler find appropriate include files 
concurrent programming erlang creation parallel process achieved evaluating spawn primitive 
expression pid spawn fun arity zero creates parallel process evaluates spawn returns process identifier pid access newly created process 
syntax pid msg sends message msg pid 
message received receive primitive syntax 
concurrent programming receive msg guard expr seq msg guard expr seq 
expr 
timeout expr seq msg patterns 
patterns may followed optional guards 
message arrives process put mailbox belonging process 
time process evaluates receive statement system look mailbox try match item mailbox set patterns contained current receive statement 
message matches received message moved temporary save queue process suspends waits message 
message matches guard test matching pattern matches sequence statements match evaluated 
time saved messages put back input mailbox process 
receive statement optional timeout 
matching message received timeout period commands associated timeout evaluated 
register send message process need know name process 
secure somewhat inconvenient processes want send message process obtain name process 
expression chapter 
erlang register name pid creates global process associates atom name process identifier pid 
messages sent evaluating name msg sent process pid 
error handling evaluating function erlang result exactly possible outcomes function return value generate exception 
generating exceptions implicit generated erlang run time system explicitly generated evaluating primitive exit 
implicit exceptions described section 
example implicit exception generation 
suppose write factorial factorial factorial 
evaluating factorial returns value evaluating factorial abc raises exception exit 
exceptions cause program doing called exceptions 
write factorial expect value value factorial integer 
factorial called non integer argument statement sense 
program fragment monday factorial nonsense compute factorial monday 
value pointless proceed 
programming languages ignore distinction values exceptions continue program nonsense 

error handling exceptions exceptions abnormal conditions detected erlang runtime system 
erlang programs compiled virtual machine instructions executed virtual machine emulator part erlang run time system 
emulator detects condition decide generates exception 
types exception 
value errors things divide zero 
argument function correct type incorrect value 

type errors generated erlang bif called argument incorrect type 
example bif atom list converts atom list ascii integer codes represent atom 
atom run time system generates exception 

pattern matching errors generated attempt match data structure number patterns matching pattern 
occur function head matching matching alternatives case receive statement 

explicit exits generated explicitly evaluating expression exit generates exception 

error propagation process receives exit signal may decide die propagate exit signal processes link set see section 

system exceptions run time system terminate process runs memory detects inconsistency internal table 
exceptions outside programmer control 
chapter 
erlang catch exceptions converted values catch primitive 
illustrate erlang shell trying evaluate illegal expression evaluation leads generation exception 
try bind value free variable happens 
error report apr error process exit value erl eval eval op erl eval expr erl eval exprs shell eval loop exited erl eval eval op erl eval expr erl eval exprs shell eval loop entering expression erlang shell caused exception generated error message printed standard output 
try print value variable see exited unbound erl eval expr course value exception generated error message printed 
convert exception value evaluate catch statement follows catch 
exit erl eval eval op erl eval expr erl eval exprs shell eval loop 
error handling value element tuple element atom exit second value term 
normal erlang term freely examined manipulated erlang data structure 
expression val catch expr evaluates expr context 
function evaluation terminates normally catch returns value expression 
exception occurs evaluation evaluation function stops immediately exception generated 
exception erlang object describes problem case value catch value exception generated 
evaluating catch expr returns term form exit say expression terminated reason exception generated inside catch value catch just value exception 
exception generated outside scope catch process exception generated die exception broadcast processes currently linked dying process 
links created evaluating bif link pid 
exit explicit exceptions generated calling exit primitive 
example sqrt exit sqrt sqrt generates exception sqrt called negative argument chapter 
erlang throw primitive throw change syntactic form exception 
exception generated calling exit scope function result evaluating catch term form exit 
exception generated calling throw scope function result evaluating catch term throw distinguishing user generated exceptions exceptions produced run time system 
corrected uncorrected errors suppose write case catch exit val val 
cat exit dog evaluating cat generates exception returns value 
evaluating cat dog returns value returns value 
evaluate cat sequence events occurs 
cat evaluated 

error handling 
generates exception 

exception caught 
returns value 
evaluating dog causes occur 
dog evaluated 

bound dog body 
evaluated dog 

exception generated 

exception propagated 
exception caught 
returns value 
look carefully observe evaluating dog exception raised caught corrected say error occur corrected 
evaluated dog directly error occurred caught corrected 
process links monitors process system dies processes system informed recall page need order able program fault tolerant systems 
ways doing 
process link process monitor 
process links group sets processes way error occurs processes processes group get killed 
process monitors allow individual processes monitor processes system 
chapter 
erlang process links primitive catch contain errors occur process 
ask happens top level catch program manage correct error detected 
answer processes terminates 
reason failure just argument exception 
process fails reason failure broadcast processes belong called link set failing process 
process add process link set evaluating bif link 
links symmetric sense linked linked links created process created 
process creates process evaluating spawn link fun process linked semantically equivalent evaluating spawn immediately followed link expression evaluated atomically sequentially 
spawn link primitive introduced correct rare programming error occur process dies immediately spawning process reach link statement 
process dies uncaught exception exit exit signal exit sent processes link set process far mentioned signals 
signals things sent processes process terminates 
signal tuple form exit pid process terminated term describing reason termination 
process receives exit signal die atom normal 
exception rule receiving process system process die signal converted happen example process tries spawn processes uses code module exist 

error handling normal inter process message added input mailbox process 
evaluating bif process flag trap exit true normal process system process 
typical code fragment system process handle failures processes start spawn fun go 
go process flag trap exit true loop 
loop receive exit handle error additional primitive completes picture 
exit pid sends exit signal process pid reason 
process evaluating exit terminate message fake death process 
exception rule system process convert signals messages evaluating exit kill sends exit process terminated extreme prejudice 
exit needed kill processes refuse honour requests voluntarily terminate 
process links useful setting groups processes die goes wrong processes 
usually just link processes belong application processes assume supervisor role 
supervisor process set trap exits 
goes wrong entire group die supervisor process receive messages inform failures processes group 
feature bug 
chapter 
erlang process monitors process links useful entire groups processes monitoring pairs processes asymmetric sense 
typical client server model relationship client servers asymmetric regards error handling 
suppose server involved number long lived sessions number dicerent clients server crashes want kill clients individual client crashes wish kill server 
primitive erlang monitor set monitor 
process evaluates ref erlang monitor process dies exit reason sent message form ref process system processes order set receive monitor messages 
distributed programming erlang programs easily ported uni processor collection processors 
complete self contained erlang system called node 
erlang nodes run host operating system 
testing distributed application simplified fact erlang nodes run operating system 
distributed application developed tested running nodes application single processor 
application works dicerent nodes assigned processor moved dicerent nodes network distributed processors 
exception timing operations distributed system exactly way worked single node test system 
primitives needed distributed processing 
ports spawn fun node spawns function fun remote node node 
monitor node monitoring behaviour entire node 
monitor analogous link controlled object entire node process 
ports ports provide mechanism erlang programs communicate outside world 
ports created evaluating bif open port 
associated port called controlling process 
controlling processes said port 
messages port sent controlling process controlling process allowed send messages port 
controlling process initially process created port process changed 
port con pid port controlling process port commanded evaluating expression con command command possible values command data sends data external object 
data io list see page definition io lists 
io list flattened data elements list sent external application 
close closes port 
port respond sending closed message controlling process 
connect pid changes controlling process pid 
port send port connected original controlling process new messages sent new controlling process 
chapter 
erlang data external application results port data messages sent controlling process port 
exact format messages messages framed depends details port opened 
see details 
dynamic code change erlang supports simple mechanism dynamic code changes 
running erlang node processes share code 
consider happens change code running system 
sequential programming language thread control wish dynamically change code worry happening single thread control 
usually sequential system wish change code system change code re start program 
real time control system oden wish system order change code 
certain real time control systems able turn oc system order change code systems designed code changed stopping system 
example system satellite control system developed nasa 
erlang system allows versions code module 
code particular module loaded new processes call code dynamically linked latest version module 
code particular module subsequently changed processes execute code module choose continue executing old code module new code 
choice determined code called 
code called fully qualified name module name followed function name latest version module called current version called 
example suppose write server loop follows module 

dynamic code change loop data receive reply data data loop data 
time module called code module loaded 
loop loop called 
version module code current module called 
suppose change code module recompile re load code loop called clause receive statement code new version called 
note programmer responsibility ensure new code called compatible old code 
highly advisable code replacement calls tail calls see section tail call old code return ader tail call old code module safely deleted 
want carry executing code current module change code new module write loop fully qualified call module 
loop data receive reply data data loop data 
case code new version module called 
judicious mechanism allows processes execute old new versions code dicerent modules time 
chapter 
erlang note limit versions code 
third attempt re load module processes executing code module killed 
addition calling conventions number code replacement 
fully described 
type notation build sodware module describe 
conventional answer involves called programming api application programming interface 
api usually list functions module externally callable types inputs function types output 
example types number functions specified erlang type notation type file open filename read write ok error string 
type file read line ok string eof 
type file close true 
filename int string int 
pid 
erlang primitive data types type 
primitive types int integer type 

type notation atom atom type 
pid pid type 
ref type 
float erlang float type 
port port type 
bin binary type 
list tuple alternation types defined recursively tn tuple type 
tn types 
say xn type tn type type xn type tn 
list type type 
say xn type type note empty list type values alternation type types 
say type type type 
new types introduced notation name name 
type 
names name name follow syntax erlang atoms 
type variables written syntax erlang variables 
example define bool true false 
weekday monday tuesday wednesday thursday friday 
weekend saturday sunday 
day weekday weekend 
chapter 
erlang function types written type tn types 
type variable occurs type definition instances type position implied variable type 
examples string int 
day number int 
town street string 
type factorial int int 
type day int day int 
type address person town street number 
function types written type fun tn example type map written type map fun 
type notation simplified version notation developed wadler marlow 
discussion chapter introduced significant subset erlang understand examples thesis addressed question erlang suitable language programming fault tolerant systems believe answer argued earlier 
discussion order program fault tolerant system programming language job satisfy certain properties page 
claim erlang satisfy properties reasons process fundamental erlang satisfied 
satisfied processes erlang designed units error encapsulation 
process terminates sodware error process executing erlang node course linked terminating process case interaction intentional 
processes fail immediately functions processes called incorrect arguments system called incorrect arguments 
immediate failure corresponds gray notion fail fast processes page schneider notion fail processor page statement detect errors fail early possible page 
processes fail reason failure broadcast current link set process satisfying 
satisfied code upgrade mechanism described section 
satisfied erlang satisfied erlang libraries 
stable storage mnesia 
single system disk storage system 
process node crashes data stored survive crash 
stronger data protection data stored physically separated nodes mnesia data base otp applications 
note passing schneider halt failure failure status property stable storage property page satisfied directly erlang erlang libraries 
chapter 
erlang programming techniques previous chapter erlang program erlang 
chapter erlang programming techniques 
programming techniques concerned abstracting concurrency concurrent programs sense diecult write sequential programs 
writing module concurrent sequential code show structure code modules concurrent code having purely sequential code 
maintaining erlang view world erlang terms process 
help maintain view introduce idea protocol converter helps programmer maintain illusion erlang process 
erlang view errors treatment errors handled erlang radically dicerent programming languages show error situations programmed erlang 
intentional programming programming style programmer easily see code exactly programmer intended guessing meaning superficial analysis code 
chapter 
programming techniques generic component plugins 
concurrency fault handling handled generic component 
plugins written purely sequential code 
abstracting concurrency program want structure code diecult easy modules 
diecult modules written expert programmers 
easy modules written experienced programmers 
shows generic component diecult part number plugins easy parts parameterise generic component 
generic component hide details concurrency mechanisms fault tolerance plugins 
plugins written sequential code defined types 
show structure client server generic component number plugins 
structuring system generic component plugins common programming technique unusual approach generic component provide rich environment execute plugin 
plugin code errors code plug dynamically modified entire component moved network occurs explicit programming plugin code 

abstracting concurrency abstracting concurrency powerful means available structuring large sodware systems 
despite ease concurrent programs written erlang desirable restrict code explicitly handles concurrency modules possible 
reason concurrent code written free manner diecult understand analyse purely sequential side free code 
system involving large numbers processes issues message passing ordering potential dead live lock problems concurrent systems diecult understand program 
common abstraction applications written erlang client server abstraction 
virtually systems programmed erlang client server abstraction far outweighs abstraction 
example page see behaviours axd system instances gen server behaviour provides client server abstraction 
start simple universal client server server show parameterised form simple name service 
extend simple server ways 
firstly modify basic server form fault tolerant server server extend version providing dynamic code upgrade server 
step wise refinement server code server server server leads eventually gen server standard behaviours otp libraries 
code gen server performs operations performed simple server examples shown 
principles gen server simple server examples client server separated generic part takes care concurrency sequent plug modules merely generic server particular manner create specific instance server 
treatment extensions deliberately simplistic 
ignored implementation issues favour simple explanation demonstrates principles involved 
client server model illustrated 
client server model characterized central server arbitrary number chapter 
programming techniques clients client server query reply server clients 
client server model generally resource management operations 
assume dicerent clients want share common resource server responsible managing resource 
ignore server started stopped ignore error cases possible describe server means single function suppose server state state receives message query client 
server respond query returning message reply client changing state state 
values completely determined server function computed erlang expression state reply query state evaluated server 
universal server server erl shown 
client stub routine rpc lines sends messages server line waits reply lines 
server receives message sent client stub line computes reply new state line sends reply back server line recursively calls line 
note recursive call loop line see section tail call variable state 
abstracting concurrency module server 
export start rpc 
start name state register name spawn fun loop name state 
name name 
rpc name query name self query receive name reply reply 
loop name state receive void pid query reply state query state pid name reply loop name state 
simple server 
chapter 
programming techniques longer accessible code storage accessed state reached state eventually reclaimed garbage collector 
loop said run constant space apart local storage stored variable state needed store state server 
server erl exports routines start name fun state starts server name name 
initial state server state fun function completely characterises behaviour server 
name stops server name 
rpc name perform remote procedure call server called name 
server implement simple home location register call vshlr simple hlr 
vshlr interface start starts hlr 
stops hlr 
am person loc tells hlr person location loc 
find person ok loc error tries find position person hlr 
hlr responds ok loc loc reported location error doesn know person vshlr implemented parameterising server shown 
simple session server home location registers widely telecoms industry keep track current location mobile user 

abstracting concurrency module vshlr 
export start handle event am find 
import server start rpc 
import dict new store find 
start start vshlr fun handle event new 
vshlr 
am rpc vshlr am 
find rpc vshlr find 
handle event am dict ok store dict handle event find dict find dict dict 
simple home location register 
chapter 
programming techniques vshlr start 
true vshlr find joe 
error vshlr am joe sics 
ack vshlr find joe 
ok sics vshlr program extremely simple illustrates provides simple solutions number design problems 
reader note total separation functionality dicerent modules 
code spawning processes sending receiving messages contained server erl 
code implementation vshlr contained vshlr erl 
code vshlr erl erlang concurrency primitives 
programmer writes module needs know concurrency fault handling 
second point important 
example factoring concurrency writing concurrent programs generally perceived diecult programmers experienced writing sequential code able factor concurrency distinct advantage 
factor concurrency mask possible errors code parameterise server function 
shown section 
fault tolerant client server extend server adding code error recovery shown 
original server crash error function 
abstracting concurrency 
term fault tolerance usually applies hardware mean sever tolerate faults function parameterise server 
function evaluated catch client killed rpc request killed server 
comparing new server old note small changes rpc code changed rpc name query name self query receive name crash exit rpc name ok reply reply 
code inner section receive statement loop case catch query state exit log error name query name crash loop name state reply state name ok reply loop name state looking changes detail observe evaluating function server loop raises exception things happen 
exception logged case just print exception sophisticated system log non volatile storage 
chapter 
programming techniques module server 
export start rpc 
start name state register name spawn fun loop name state 
name name 
rpc name query name self query receive name crash exit rpc name ok reply reply 
loop name state receive void query case catch query state exit log error name query name crash loop name state reply state name ok reply loop name state 
log error name query io format server query caused exception name query 
simple server error recovery 

abstracting concurrency 
crash message sent client 
crash message received client raise exception client code 
desirable probably pointless client continue 

server continues operate old value state variable 
rpc obeys transaction semantics say succeeds entirety state server updated fails case state server unchanged 
note code server erl written protect error characteristic function server 
server dies example deliberately killed process system client rpc stub hang indefinitely waiting reply message sent 
wish guard possibility write rpc routine follows rpc name query name self query receive name crash exit rpc name ok reply reply exit timeout 
solution solves problem introduces problem value choose timeout 
better solution elaborate applications supervision trees 
server failures detected client sodware special supervisor processes responsible correcting errors introduced failure server 
run server parameterised version vshlr vshlr contains deliberate error session modified server shown chapter 
programming techniques module vshlr 
export start am find 
import server start rpc 
import dict new store find 
start start vshlr fun handle event new 
vshlr 
am rpc vshlr am 
find rpc vshlr find 
handle event am dict ok store dict handle event find robert dict handle event find dict find dict dict 
home location register deliberate error 

abstracting concurrency vshlr start 
true vshlr find joe 
error vshlr am joe sics 
ok vshlr find joe 
ok sics vshlr find robert 
server vshlr query find robert caused exception vshlr handle event exited rpc vshlr find joe 
ok sics hopefully information exception debug program satisfying requirement page 
final improvement modify server allow change code server fly shown 
parameterise vshlr 
vshlr shown identical vshlr exception server line module replaced server 
vshlr start 
true vshlr am joe sics 
ok vshlr am robert 
ok vshlr find robert 
server vshlr query find robert caused exception vshlr handle event exited rpc vshlr find joe 
ok sics chapter 
programming techniques module server 
export start rpc swap code 
start name state register name spawn fun loop name state 
name name 
swap code name rpc name swap code 
rpc name query name self query receive name crash exit rpc name ok reply reply 
loop name state receive void swap code name ok ack loop name state query case catch query state exit log error name query name crash loop name state reply state name ok reply loop name state 
log error name query io format server query caused exception name query 
simple server error recovery dynamic code replacement 

abstracting concurrency server swap code vshlr fun vshlr handle event 
ok vshlr find robert 
ok trace illustrates change code server fly lines show server working properly 
line trigger deliberate error programmed vshlr 
server handles error crashing example response line correct 
line send command change code server back correct version vshlr 
ader command completed server works correctly shown line 
programmer wrote code vshlr need know server implemented code server dynamically changed server service 
ability change sodware server stopping server partially fulfils requirement page upgrade sodware system stopping system 
return code server figures server vshlr application observe 
code server re build dicerent clientserver applications 

application code simpler server code 

write server code programmer understand details erlang concurrency model 
involves name registration process spawning exits process sending receiving messages 
trap exception programmer understand notion exception familiar erlang exception handling mechanisms 
chapter 
programming techniques 
write application programmer understand write simple sequential program need know concurrency error handling 

imagine application code succession progressively sophisticated servers 
shown servers imagine adding functions server keeping server application interface unchanged 

dicerent servers server server application dicerent non functional characteristics 
functional characteristics servers correctly typed arguments programs eventually produce identical results non functional characteristics dicerent 

code implements non functional parts system limited server non function mean things system behaves presence errors long time function evaluation takes hidden application programmer 

details remote procedure call implemented hidden inside server module 
means implementation changed stage changing client code necessary 
example change details rpc implemented having change client sodware calls functions server 
division total server functionality non functional part functional part programming practice gives system desirable properties 
concurrent programming oden perceived diecult 
large programming group programmers dicerent skill levels expert programmers write generic server 
maintaining erlang view world code experienced programmers write application code 

formal methods applied simpler application code 
formal verification erlang type systems designed infer types erlang code problems analysing concurrent programs 
code generic servers assumed correct priori problem proving properties system reduces problem proving properties sequential programs 

system large number client servers servers written generic server 
easier programmer understand maintain dicerent servers 
section investigate claim analyse large system servers 

generic servers applications tested separately independently 
interface remains constant long period time independently improved 

application code plugged number dicerent generic servers servers dicerent non functional characteristics 
special servers interface provide enhanced debugging environment servers provide clustering hot standby done number projects example eddie provided clustering mail provided server hot standby facilities 
maintaining erlang view world erlang view world process processes interact exchanging messages 
chapter 
programming techniques interface erlang programs external sodware oden convenient write interface program maintains illusion process example consider implement web server 
web servers communicate clients protocol defined rfc 
point view erlang programmer inner loop web server spawn new process connection accept request client respond appropriately 
code serve client receive client request response generate response request client self response 
request response erlang terms representing requests responses 
server simple expects single request replies single response terminates connection 
sophisticated server support persistent connections code remarkably simple serve client receive client close true client request response generate response request client self response server client client self close 

maintaining erlang view world web server driver erlang terms tcp packets web server tcp driver line function essentially needed primitive web server persistent connections 
web server talk directly clients making requests 
significantly clutter web server code irrelevant detail structure diecult understand 
middle man process see 
middle man process driver converts requests responses corresponding erlang terms represent requests responses 
structure driver follows relay socket server state receive tcp socket bin case parse request state data completed request state server self request req relay socket server state state relay socket server state tcp closed socket server self close server close gen tcp close socket server response data format response response chapter 
programming techniques gen tcp send socket data relay socket server state exit server gen tcp close socket 
packet comes client tcp socket parsed calling parse request 
response complete erlang term representing request sent server 
response comes server reformatted sent client 
side terminates connection error occurs server connection closed 
process terminates reason connections automatically closed 
variable state state variable representing state reentrant parser parse incoming requests 
entire code web server shown downloaded 
error handling philosophy error handling erlang radically dicerent error handing programming languages 
erlang philosophy handling errors expressed number process error recovery 
want die 
crash 
program 
process fix error handle errors distributed system 
handle hardware errors need replication 
guard failure entire computer need computers 

error handling philosophy computer computer computer fails computer notices failure corrects error 
computer crashes failure noticed second computer try correct error 
exactly method erlang computers pairs processes 
exit pid pid pid process fails process notices failure corrects error 
process pid fails processes pid pid linked process pid set trap errors message form exit pid delivered pid pid fails 
describes reason failure 
note computer pid executes dies exit message exit pid machine died delivered pid 
message appears come pid fact comes run time system node pid executing 
reason coercing hardware error look sodware error don want dicerent methods dealing errors sodware errors hardware errors 
reasons conceptual integrity want uniform mechanism 
combined extreme case hardware error failure entire processors leads idea handling errors occurred place system 
circumstances including hardware failure pid job correct error 
say process fix error chapter 
programming techniques philosophy completely dicerent sequential programming language alternative try handle errors thread control error occurs 
sequential language exceptions programmer encloses code fail exception handling construct tries contain errors occur construct 
remote handling error advantages 
error handling code code error execute dicerent threads control 

code solves problem cluttered code handles exception 

method works distributed system porting code single node system distributed system needs little change error handling code 

systems built tested single node system deployed multi node distributed system massive changes code 
workers supervisors distinction processes perform processes handle errors clearer oden talk worker supervisor processes process worker process job 
process supervisor process 
observes worker 
error occurs worker supervisor takes actions correct error 
nice thing approach 
clean separation issues 
processes supposed things workers worry error handling 

crash 
special processes concerned error handling 

run workers supervisors dicerent physical machines 

oden turns error correcting code generic generally applicable applications worker code oden application specific 
point crucial erlang satisfies requirements see page run worker supervisor processes dicerent physical machines system tolerates hardware errors entire processes fail 
crash philosophy handling errors fit coding practices 
kind code programmer write find error 
philosophy process fix error mean code 
answer crash 
mean event error program just crash 
error 
programming purpose say exceptions occur run time system know 
errors occur programmer doesn know 
exception generated run time system programmer foreseen knows correct condition caused exception error 
example opening file exist cause exception programmer decide error 
write code traps exception takes necessary corrective action 
chapter 
programming techniques errors occur programmer know 
programmers supposed follow specifications oden specification say programmer know 
example suppose writing program produce code microprocessor specification says load operation result opcode store operation result opcode 
programmer turns specification code asm load asm store 
suppose system tries evaluate asm jump happen 
suppose programmer writing defensive code write asm load asm store asm 

code write 
situation run time system faced encountered divide zero situation write sensible code 
terminate program 
write asm load asm store asm exit oops asm bother 
erlang compiler compiles asm load asm store 
written 
intentional programming asm load asm store asm exit bad arg asm 
defensive code detracts pure case confuses reader diagnostic oden better diagnostic compiler supplies automatically 
intentional programming intentional programming name give style programming reader program easily see programmer intended code 
intention code obvious names functions involved inferred analysing structure code 
best explained example early days erlang library module dict exported function lookup interface lookup key dict ok value notfound definition lookup dicerent contexts 
data retrieval programmer write ok value lookup key dict lookup extract item known key dictionary 
key dictionary programming error case exception generated key 

searching code fragment case lookup key dict ok val chapter 
programming techniques val 
searches dictionary know key programming error key dictionary 

testing presence key code fragment case lookup key dict ok 
tests see specific key key dictionary 
reading thousands lines code worry intentionality ask question programmer intend line code analysing usages code arrive answers data retrieval search test 
number dicerent contexts keys looked dictionary 
situation programmer knows specific key dictionary programming error key dictionary program terminate 
situation programmer know keyed item dictionary program allow cases key 
guessing programmer intentions analyzing code better set library routines dict fetch key dict val exit dict search key dict val 
dict key key dict boolean 
discussion precisely expresses intention programmer guesswork program analysis involved clearly read intended 
noted fetch implemented terms search vice versa 
fetch assumed primitive write search key dict case catch fetch key dict exit value value 
really code generate exception signal program error correct error 
better find key dict case search key dict ok value value exit find key 
precisely exception generated represents error 
discussion programming disciplined activity 
writing clear intentional code apparent structure diecult 
part choosing right abstractions 
master complex situation method divide conquer split complex problems simpler subproblems solve sub problems 
chapter 
programming techniques chapter shown split number complex problems simpler sub problems 
comes error handling shown errors argued program divided pure code code fixes errors writing server shown non functional properties server 
shown write version server crash error characteristic function defines behaviour server shown behaviour server changed stopping server 
recovering errors changing code running system typical non functional properties real systems required 
oden programming languages systems strongly support writing code defined functional behaviour poor support non functional parts program 
programming languages easy write pure function value depends deterministic manner inputs function diecult impossible things changing code system handling errors generic manner protecting programmer code failures part system 
reason programmer services operating system operating system provides protection zones concurrency usually guise processes 
sense operating system provides programming language designer forgot language erlang operating system hardly necessary os just provides erlang number device drivers os mechanisms processes message passing scheduling memory management needed 
trouble os fill deficiencies programming language underlying mechanisms operating system easily changed 
operating systems ideas process interprocess scheduling changed 
providing programmer lightweight processes primitive mechanisms detecting handling errors application programmer easy 

discussion easily design implement application operating system specifically designed characteristics specific problem 
otp system just application program written erlang example 
chapter 
programming techniques programming fault tolerant systems designers devote half software telephone switches error detection correction richard kuhn national institute standards technology fault tolerant system program 
question central thesis understanding build fault tolerant systems 
chapter define mean fault tolerance specific method programing fault tolerant systems 
start couple quotations say system fault tolerant programs properly executed despite occurrence logic faults 

design build fault tolerant system understand system fail kinds errors occur 
error detection essential component fault tolerance 
know error occurred able tolerate replacing component alternative means computation raising exception 
want avoid adding unnecessary complexity enable fault tolerance complexity result reliable system 
quoted voas 
chapter 
programming fault tolerant systems presentation follows advice explain exactly happens abnormal condition detected sodware structure detects corrects errors 
remainder chapter describes strategy programming fault tolerance strategy fail immediately correct error try simpler achieve 
supervision hierarchies hierarchical organisations tasks 
behaved functions functions supposed correctly 
generation exception behaved function interpreted failure 
programming fault tolerance system fault tolerant organise sodware hierarchy tasks performed 
highest level task run application specification 
task performed system try perform simpler task 
simpler task performed system try perform simpler task 
lowest level task system performed system fail 
method intuitively attractive 
says want try simpler 
try organise sodware simpler tasks performed simpler sodware likelihood success increases tasks simpler 
tasks simpler emphasis operation performed changes interested protecting system damage full service 
stages goal acceptable level service ambitious things start fail 
failures occur interested protecting system logging precise reason failure 
programming fault tolerance failure 
implies need kind stable error log survive crash 
exceptional circumstances system fail happen lose information tells system failed 
implement hierarchy tasks need precise notion meant world failure evaluating function erlang result exception 
exceptions errors errors necessarily lead failures 
need discuss distinction exceptions errors failures 
distinctions exceptions errors failures largely system abnormal event detected handled interpreted 
trace happens abnormal situation occurs system description bottom starts point time error detected 
lowest level system erlang virtual machine detects internal error detects divide zero condition pattern matching error 
important point detected conditions pointless continue evaluating code processes error occurred 
virtual machine emulator continue thing possible throws exception 
level exception may may caught 
program fragment traps exception may may able correct error caused exception 
error successfully corrected damage done process resume normal 
error caught corrected exception generated may may trapped process exception occurred 
catch handler exception process fail 
reason failure propagated processes currently linked process failed 
current function evaluating scope catch statement 
chapter 
programming fault tolerant systems linked processes receive failure signals may may intercept process signals normal interprocess messages 
see starts oc abnormal condition virtual machine emulator propagates upwards system 
point upwards propagation error attempt correct error 
attempt succeed fail fine grain control handle errors 
corrected error situation foreseen corrective code successfully executed considered fault 
far just seen abnormal conditions lead exceptions exceptions trapped exceptions lead process failures process failures detected processes system 
available mechanisms implement hierarchy tasks supervision hierarchies recall chapter talked idea hierarchy tasks 
basic idea 
try perform task 

perform task try perform simpler task 
task associate supervisor process supervisor assign worker try achieve goals implied task 
worker process fails non normal exit supervisor assume task failed initiate error recovery procedure 
error recovery procedure restart worker failing try simpler 
supervisors workers arranged hierarchical trees 
supervision hierarchies 
supervision trees trees supervisors 

supervisors monitor workers supervisors 

workers instances behaviours 

behaviours parameterised behaved functions 

behaved functions raise exceptions errors occur 
supervision trees hierarchical trees supervisors 
node tree responsible monitoring errors child nodes 
supervisors processes monitor processes system 
things monitored supervisors workers 
supervisors able detect exceptions generated things monitoring able start restart things monitoring 
workers processes perform tasks 
worker process terminates non normal exit see page supervisor assume error occurred take action recover error 
workers model arbitrary processes instances small number generic processes called behaviours 
behaviours generic processes operation entirely characterised small number callback functions 
functions instances behaved functions 
example behaviour gen server behaviour programming distributed fault tolerant client server 
behaviour parameterised number 
programmer understand order program faulttolerant distributed client server write 
clientserver behaviour provides fault tolerant framework concurrency chapter 
programming fault tolerant systems supervisor node worker node supervisor worker symbols distribution 
programmer need concerned writing parameterise behaviour 
convenience particular supervision hierarchies considered linear hierarchies hierarchy trees 
shown diagrammatically sections 
diagrammatic representation supervisors workers conveniently represented notation 
supervisors draw rectangles right angled corners 
top right hand corner symbol denoting type supervisor 
value meaning supervision meaning supervision 
supervision types described 
supervisors supervise arbitrary number workers supervisors 
entity supervised supervisor know start restart entity supervise 
information kept stands start restart specification page contains simple specifies dicerent behaviours supervised 
supervisor apart topmost supervisor hierarchy exactly supervisor directly hierarchy call parent supervisor 
conversely processes supervisor 
supervision hierarchies linear supervisor hierarchy hierarchy referred children supervisor 
shows supervisor node parent children 
workers drawn rectangles rounded corners see 
parameterised behaved functions diagrams 
linear supervision start linear hierarchy 
represents linear hierarchy supervisors 
supervisor children obeys rules parent stops children 
children dies try restart child 
system started starting topmost supervisor 
top level supervisor started specification 
top level supervisor children worker supervisor 
starts worker chapter 
programming fault tolerant systems hierarchy behaviour parameterising behaved function starts child supervisor 
lower level supervisors hierarchy started similar manner entire system running 
supervision hierarchies extend simple supervision hierarchy tree structure containing nodes 
shows tree 
denotation denotes supervisor denotes supervisor 
rules supervisor tree follows parent stops children 
child dies am supervisor children restart children 
child dies am supervisor restart child died 
supervision dependent ordinated processes 
tree successful operation system depends successful operation children child dies children stopped restarted 

error 
supervision ordinate activities independent processes 
tree activities performed assumed independent failure child consequence children event child failure child process restarted 
concrete terms hierarchy tasks expressed supervision hierarchy 
system equate tasks goals goals invariants say goal achieved invariant associated goal false 
programs assertion invariant corresponds statement evaluation particular designated function yield exception 
similar reported candea fox system recursively restartable java components notice distinguish errors categories correctable errors 
correctable errors errors component detected corrected component 
errors errors detected corrective procedure specified 
discussion vague said error said practice distinguish correctable error 
situation complicated fact vast majority specifications specify happen components system planned specifications rarely specify done particular error occurs 
specification say exactly particular error occurs argued error desired property system 
consequence vague way word error 
error 
run program run time system idea constitutes error just runs code 
indication invariant true 
chapter 
programming fault tolerant systems gone wrong exception generated 
exceptions generated automatically run time system run time system decide 
example performing division run time system detect divide zero condition case generates exception know 
complete list conditions cause exceptions section 
exceptions correspond errors 
example programmer written code correctly deal divide zero exception presence exception may necessarily indicate error 
programmer decides exception corresponds error system programmer explicitly say functions system expected generate exceptions 
schneider gives number definitions fault tolerance acm tutorial 
says component considered faulty behaviour longer consistent specification 
purposes define error deviation observed behaviour system desired behaviour system 
desired behaviour behaviour specification says system programmer ensure system behaves way deviates specification kind error recovery procedure initiated record fact recorded permanent error log corrected 
building real systems complicated fact oden don complete specification case programmer general notion constitutes error 
absence explicit specification need implicit mechanism corresponds intuitive idea error causes program crash otp system programmer expected write behaved functions behaved functions parameterise 
error 
otp behaviours 
functions evaluated code otp behaviours 
evaluation parameterisation function generates exception defined error error diagnostic added error log 
point important recall part inner loop generic server shown page loop name state receive 
query case catch query state exit log error name query name crash loop name state reply state name ok reply loop name state 
callback function called catch statement 
exception generated assumed error error message added error log 
simple example illustrate fundamental principle error handling otp behaviours 
example otp gen server behaviour programmer write callback module parameterise server 
module things export callback function handle call example shown line page callback function behaved function 
chapter 
programming fault tolerant systems behaved functions behaved function function normally generate exception 
exception generated exception interpreted error 
exception occurs trying evaluate try correct condition caused exception 
error occurs corrected programmer terminate function explicit exit statement 
behaved functions written rules rule program isomorphic specification 
program faithfully follow specification 
specification says silly program silly 
program faithfully reproduce errors specification 
rule specification doesn say raise exception 
important 
specifications oden say done happens omit say happens 
answer raise exception unfortunately programmers take opportunity creative guess try guess designer ought said 
systems written manner observation exception synonymous specification error 
rule generated exceptions contain information able isolate error add additional helpful information exception 
programmers write code ask information written error log error occurs 
information debugging purposes add information exception allow program debugged stage 

error 
rule turn non functional requirements assertions invariants checked run time 
assertion broken raise exception 
example concern termination loop programming error cause function enter infinite loop causing function return 
error detected requiring certain functions terminate specified time checking time generating exception function terminate specified time 
chapter 
programming fault tolerant systems building application previous chapter introduced general model programming fault tolerant systems introduced idea supervision tree monitor behaviour system 
chapter moves general theory specific implementation supervisors implemented otp system 
illustrate supervision principles build simple otp application 
application single supervisor process manages worker processes 
worker processes instances gen server gen event gen fsm behaviours 
behaviours applications otp sodware built number behaviours behaviours abstractions common programming patterns building blocks implementing systems erlang 
behaviours discussed remainder chapter follows gen server build servers clientserver models 
gen event building event handlers 
event handlers things error loggers event handler chapter 
building application responds stream events necessarily reply processes send events handler 
gen fsm implementing finite state machines 
supervisor implementing supervision trees 
application container packaging completed applications 
behaviour general principles involved specific details programming api give complete example instance behaviour 
otp systems built hierarchical manner releases releases top hierarchy 
release contains information necessary build run system 
release consists sodware archive packed form set procedures installing release 
process installing release highly complicated upgrade releases oden installed stopping target systems 
otp release packages complexity single unit 
internally release consists zero applications 
applications applications simpler releases contain code operating procedures necessary run single application entire system 
release composed multiple applications system structured way ensure dicerent applications largely independent dicerent applications strictly hierarchical dependencies 
supervisors otp applications commonly built number instances supervisors 
workers otp supervisors supervise worker nodes 
worker nodes usually instances gen server gen event gen fsm behaviours 

behaviours application 
application built bottom starting worker nodes 
create worker nodes instance gen server gen event gen fsm behaviours 
worker nodes managed simple supervision tree supervision tree packaged application 
start worker nodes 
behaviours written otp behaviours written programming style similar examples section 
major 
parameterising behaviour arbitrary function parameterise behaviour name module 
module export specific number pre defined functions 
exactly functions exported depends behaviour defined 
complete apis documented behaviour manual pages 
example assume xyz instance gen server behaviour xyz erl contain code module xyz 
behaviour gen server 
export init handle call handle cast handle info terminate change code 
xyz erl export routines init shown 
create instance gen server call gen server start mod args options names server 
mod atom xyz 
args argument passed xyz init options argument controls behaviour server 
options passed argument module xyz 
method parameterising behaviour examples shown pages somewhat general method chapter 
building application otp system 
reasons largely historical behaviours written funs added erlang 
generic server principles chapter introduced idea generic server 
generic server provides empty server framework instances servers built 
examples chapter deliberately short illustrated principles involved making generic server 
otp system erlang module gen server client server modules 
gen server parameterised number dicerent ways range dicerent types servers 
generic server api understand gen server api helpful see flow control server application 
describe subset gen server api examples chapter 
gen server start name mod arg options result name name server see note 
mod name callback module see note 
arg argument passed mod init see note 
options set options controls workings server 
result result obtained evaluating mod init see note 
gen server call name term result name name server see note 

generic server principles term argument passed mod handle call see note 
result result obtained evaluating mod handle call see note 
gen server cast name term ok notes name name server see note 
term argument passed mod handle cast see note 

name term local name global name 
starting local server creates server single node 
starting global server starts server transparently accessed node set distributed erlang nodes 

name atom 

mod export functions init handle call handle cast terminate 
routines called gen server 

arguments functions gen server appear unchanged argument functions mod 
similarly terms contained return values functions mod reappear return values functions gen server 
callback routines mod apis mod init arg ok state reason routine attempts start server arg third argument supplied gen server start 
chapter 
building application ok state means starting server succeeded 
internal state server state original call gen server start return ok pid pid identifies server 
reason means starting server failed case original call gen server start return error reason 
mod handle call term state reply gets called user calls gen server call name term 
term term 
identifies client 
state current state server 
reply causes return value gen server call new state server 
mod handle cast term state gets called user calls gen server cast name term 
term term 
state current state server 
causes state server change 
causes server 
stopped calling mod terminate mod terminate void routine gets called server stops 
return value ignored 
reason termination 
current state server 

generic server principles generic server example example simple key value server implemented gen server 
key value server implemented callback module called kv shown 
line kv tells compiler module call back module gen server behaviour 
compiler issue warnings module export correct set call back routines needed gen server 
kv erl exports number client functions line number callback functions lines 
client functions called system 
callback functions called gen server module 
kv start starts server calling gen server start link 
argument gen server start link location server 
example location local kv means server locally registered process name kv 
values permitted location 
include value global name register server global name local name 
global name allows server accessed distributed erlang system node system 
remaining arguments gen server start callback module name kv initial argument arg set options controlling debugging 
setting debug trace log turn debugging tracing log file 
gen server start link called initialise internal data structures calling kv init arg arg third argument supplied call gen server start link 
normal operation init return tuple form ok state 
client routines exported kv lines 
store lookup implemented gen server call 
internally remote procedure calls implemented calling callback routine handle call 
lines implement callback routines necessary implement server side remote procedure calls 
line kv erl deliberate error ignore 
chapter 
building application module kv 
behaviour gen server 
export start lookup store 
export init handle call handle cast terminate 
start gen server start link local kv kv arg 
gen server cast kv 
init arg io format key value server starting ok dict new 
store key val gen server call kv store key val 
lookup key gen server call kv lookup key 
handle call store key val dict dict dict store key val dict reply ack dict handle call lookup crash dict deliberate error handle call lookup key dict reply dict find key dict dict 
handle cast dict normal dict 
terminate reason dict io format server terminating 
simple server 
event manager principles argument handle call pattern match second argument calls gen server call 
second argument state server 
normal operation handle call return tuple form reply state return value remote procedure call returned client return value gen server call state new value state server 
gen server cast kv called line server 
second argument reappears argument handle cast line second argument state server 
handle cast returns reason state force generic server call kv terminate reason state 
give server chance perform final operations wishes perform exiting 
terminate returns generic server stopped name registrations removed 
example shown simple example generic server 
manual pages gen server give options values various arguments callback functions control functions gen server take 
generic server parameterised large number dicerent ways making easy run system local server global server network distributed erlang nodes 
generic server number built debugging aids automatically available programmer 
event error occurring server built gen server complete trace dump went wrong automatically added system error log 
information usually allow debugging server 
event manager principles event manager behaviour gen event provides general framework building application specific event handling routines 
event managers built tasks chapter 
building application error logging 
alarm handling 
debugging 
equipment management 
event managers provide named objects events sent 
zero event handlers installed event manager 
event arrives event manager processed event handlers installed event manager 
event managers manipulated run time 
particular install event handler remove event handler replace event handler dicerent handler 
start definitions event happens 
event manager program coordinates processing events category 
event manager provides named object events sent 
notification act sending event event manager 
event handler function process events 
event handler function type state event state event manager maintains list module state tuples form 
call list module state ms list 
suppose internal state event manager represented ms list 
event received event manager replaces list list 
event manager principles new new 
ok mi handle event si 
event manager thought generalisation conventional finite state machine single state maintain set states set state transition functions 
expected number interface functions gen event api allow manipulation module state pairs server 
gen event powerful imagined simple 
full details best appreciated reading tutorial event handling part otp documentation 
event manager api event manager gen event exports routines gen event start name ok pid error create new event manager 
name name event manager see note 
ok pid means event manager started successfully 
pid process pid event manager 
error returned event manager started 
gen event add handler name mod args ok error adds new handler event manager 
old state event manager operation succeeds new state event manager mod obtained evaluating mod init args 
name name event manager see note 
mod name callback module see note 
arg argument passed mod init 
chapter 
building application gen event notify name ok sends event event manager 
state event manager set mi si pairs event received state event manager changes set mi pairs ok mi handle event si gen event call name mod args reply perform operation handlers event manager 
state event manager contains tuple mod mod handle call args called 
reply derived return value call 
gen event name ok stops event manager 
notes 
event follow naming conventions generic servers 

event handler export functions init handle event handle call terminate 
event handler modules api mod init args ok state args comes gen event add handler 
state initial value state associated event handler 
mod handle event ok comes second argument gen event notify 
initial value state associated event handler 

finite state machine principles new value state associated event handler 
mod handle call args state ok reply state args comes second argument gen event call 
state initial value state associated event handler 
reply return value gen event call state new value state associated event handler 
mod terminate reason state void reason tells event manager stopped 
state current value state associated event handler 
event manager example shows gen event build simple event logger 
error logger keeps track error messages display error messages response notification report event 
notice code simple logger erl purely sequential 
point reader noticed similarity forms arguments gen server gen event 
general arguments routines start handle call dicerent behaviour modules chosen similar possible 
finite state machine principles applications example protocol stacks modeled finite state machines fsms 
fsms programmed finite state chapter 
building application module simple logger 
behaviour gen event 
export start log report 
export init terminate handle event handle call 
define name simple event logger 
start case gen event start link local name ret ok pid gen event add handler name module arg ret 
gen event name 
log gen event notify name log 
report gen event call name module report 
init arg io format logger starting ok 
handle event log ok trim 
handle call report ok 
terminate true 
trim trim simple error logger 
finite state machine principles machine behaviour gen fsm 
fsm described set rules form state event actions state 
interpret meaning state event occurs perform actions transition state 
choose program fsm gen fsm behaviour state transition rules written number erlang functions follow convention statename event 
code actions 
state statename finite state machine api finite state machine behaviour gen fsm exports routines gen fsm start name mod arg options result function works exactly gen server start discussed earlier 
gen fsm send event name event ok send event fsm identified name callback module mod export functions mod init arg ok statename fsm starts calls init expected return initial state statename data associated state 
gen fsm send event event called fsm evaluate mod statename event 
chapter 
building application mod statename event nextstate sname step fsm 
statename event represent current state fsm 
state fsm sname data associated state 
finite state machine example illustrate typical fsm application written simple packet assembler gen fsm 
packet assembler states waiting collecting 
waiting state expects sent information containing packet length case enters collecting state 
collecting state expects sent number small data packets assemble 
length small data packets equals total packet length prints assembled packet re enters waiting state 
simple packet assembler written gen fsm 
line call gen fsm start link start local instance fsm behaviour note similarity gen server start line line 
third argument gen server start reappears passed argument init line 
waiting state modeled function waiting line collecting state collecting lines 
data associated state stored second argument functions 
argument functions provided second argument calls gen fsm send event 
example send data calls gen fsm send event second argument len 
argument reappears argument waiting line 
state fsm represented tuple need len buff 
collecting data need total number bytes collected len number collected buff containing bytes collected 
tuple appears second argument collect line 
illustrate packet assembler session erlang shell 
finite state machine principles module packet assembler 
behaviour gen fsm 
export start send header send data 
export init terminate waiting collecting 
define name simple packet assembler 
start gen fsm start link local name module arg 
send header len gen fsm send event name len 
send data str gen fsm send event name str 
init arg io format packet assembler starting ok waiting nil 
waiting nil state collecting 
collecting buff need len buff length buff len need state collecting need len buff buff len need buff buff buff io format got data buff state waiting nil 
terminate reason state data io format packet assembler terminated reason true 
simple packet assembler chapter 
building application packet assembler start 
ok packet assembler send header 
ok packet assembler send data hello 
ok packet assembler send data 
ok packet assembler send data joe 
got data hello joe ok gen fsm functionality described 
supervisor principles concentrated primitive behaviours solve typical application problems large part application written primitive client server event handling fsm behaviours 
gen sup behaviour meta behaviour glue primitive behaviours supervision hierarchies 
supervisor api supervisor api extremely simple supervisor start link name mod arg result starts supervisor calling mod init arg mod export init mod init arg term describing supervision tree 

supervisor principles term describing workers supervision tree started stopped restarted 
describe detail 
example follows contains simple supervision tree explained 
complete detail supervisor manual pages 
supervisor example example monitors worker behaviours introduced earlier chapter 
recall kv erl included deliberate error line simple logger erl error didn mention 
see happens errors occur run time 
module simple sup erl defines behaviour supervisor 
starts line calling supervisor start link calling conventions start start link functions exported behaviours system 
module macro expands current module name simple sup 
final argument set nil 
supervisor method starts calling init specified callback module argument nil third argument start link 
init returns data structure defining shape supervision tree strategy 
term line tell supervisor construct supervision tree see page activities supervised considered unrelated 
numbers specify restart frequency supervisor restart processes monitoring times seconds fail 
objects supervision tree describe packet assembler added supervision tree 
behaviours follow principles packet assembler 
lines specify behaviour packet assembler 
item tuple describes packet assembler notice error hope 
chapter 
building application module simple sup 
behaviour supervisor 
export start init 
start supervisor start link local simple supervisor module nil 
init ok packet packet assembler start permanent worker packet assembler server kv start permanent worker kv logger simple logger start permanent worker simple logger 
simple supervisor 
supervisor principles supervised 
starts line 
atom packet arbitrary name unique instance supervisor refer node supervision tree 
objects supervised instances otp behaviours plugging supervision tree simple 
argument line tuple called supervisor start specified processes 
supervisor calls apply wants start supervised process 
argument permanent line says monitored process called permanent process 
permanent process automatically restarted supervisor fails 
addition specifying start supervised process supervised process written particular manner 
example possible supervisor request supervised process terminate orderly manner 
supervised processes obey called shutdown protocol terminate worker process supervisor calls shutdown pid worker determines worker stopped 
shutdown defined follows shutdown pid kill exit pid kill shutdown pid infinity exit pid shutdown receive exit pid shutdown true shutdown pid time exit pid shutdown receive exit pid shutdown true time exit pid kill 
chapter 
building application kill worker process killed see page 
infinity shutdown signal sent worker process respond exit pid shutdown message 
integer process milliseconds terminate 
exit pid shutdown received milliseconds process unconditionally killed 
line integer shutdown time needed shutdown protocol 
says supervisor wishes supervised allow process milliseconds doing 
worker argument means supervised process worker process recall page supervised process worker supervisor process packet assembler list modules behaviour argument needed synchronising code change operations 
defined compile run supervisor 
transcript start supervisor trigger number errors supervised processes 
supervised processes die automatically restarted supervisor 
example shows happens error occurs packet assembler 
start supervisor check pid packet assembler 
simple sup start 
packet assembler starting key value server starting logger starting ok simple packet assembler 
printout shows servers started 
send byte length count followed bytes data second deliberate error sure noticed 

supervisor principles packet assembler send header 
ok packet assembler send data oops 
packet assembler terminated clause packet assembler collecting gen fsm handle msg proc lib init ok packet assembler starting error report jun state machine simple packet assembler terminating event oops state collecting data reason termination clause packet assembler collecting gen fsm handle msg proc lib init results quite lot output 
firstly packet assembler crashes accounts error printout 
secondly supervisor detects packet assembler crashed restarts message packet assembler starting printed process restarts 
long hopefully informative error message 
error message contains information state fsm point crashed 
tells state fsm collecting data associated state tuple event caused fsm crash oops 
information debug fsm machine 
case output error logger directed standard output 
production system error logger configured direct output stable storage 
analysis error log post mortem debugging system 
confirm supervisor correctly restarted packet chapter 
building application assembler evaluating simple packet assembler returns pid newly started packet assembler 
simple packet assembler 
packet assembler send header 
ok packet assembler send header ok 
got data ok ok similar manner evoke deliberate error key value server kv store 
ack kv lookup 
ok spawn fun kv lookup crash 
server terminating key value server starting error report jun generic server kv terminating message lookup crash server state dict lines removed 
reason termination kv handle call proc lib init kv lookup 
error 
application principles note kv lookup crash evaluated temporary processes linked query shell 
supervisor started call supervisor start link linked query shell 
evaluating kv lookup crash directly shell crash supervisor probably intended 
note supervisor pre defined behaviours 
supervisor primitive behaviours designed isolation designed complement 
default behaviour provide helpful information possible error log put system safe state 
application principles constructed primitive servers built supervision tree remains build application 
application container needed deliver particular application 
way applications programmed earlier behaviours 
earlier behaviours callback modules export number pre defined functions 
applications callback functions assume specific organisation files directories sub directories file system 
important part application contained application descriptor file file extension app describes resources needed application 
applications api applications described application descriptor file 
application descriptor files extension app 
man manual page application defines structure app file structure original attempt failed erlang mailing list kind point behaviours behaving badly 
chapter 
building application application application description description vsn vsn id id modules module maxt maxt registered name applications appl included applications appl env par val valn mod module start phases phase 
keys application association list optional 
omitted reasonable default values 
application example package application consists primitive behaviours supervisor application file simple app shown 
example structure app file straight forward 
main purpose application files name describe application list modules registered process names application uses 
addition simple app need main program launch application simple erl 
simple erl couple calls start application 
ready run application 
assuming erlang files compiled directory app file start application test servers follows application start simple temporary 
packet assembler starting 
application principles application simple description simple application vsn modules simple kv packet assembler simple sup simple logger maxt infinity registered kv simple event logger simple packet assembler applications included applications env mod simple go 
module simple 
behaviour application 
export start 
simple app simple application start simple sup start 
simple erl simple application chapter 
building application key value server starting logger starting ok packet assembler send header 
ok packet assembler send data hi 
ok got data hi application application simple 
info report jun application simple exited stopped type temporary ok ader stopping application processes running application closed orderly manner 
systems releases development chapter bottom start simple things combining larger complicated units 
started number primitive servers gen server gen event gen fsm 
organised primitive behaviours supervision hierarchy built supervision hierarchy application 
final stage shown build application release 
release packages number dicerent applications single conceptual unit 
result small number files moved target environment 
building complete release complex procedure release describe current state system know previous versions system 

discussion releases contain information current version sodware information previous releases sodware 
particular contain procedures upgrading system earlier version sodware current version sodware 
upgrade oden performed stopping system 
release handle situation installation new sodware fails reason 
new release fails system revert back previous stable state 
handled release management part otp system 
look axd project chapter see instances gen server instances gen event instances gen fsm 
supervisors applications 
packaged release 
opinion simplest behaviours gen server happens single design pattern 
errors gen server callback module result informative error messages quality enable post hoc debugging system 
behaviours compromise design programming 
quicker design program system design patterns resultant code marginally hand written code solves exactly problem 
discussion otp system generic modules implemented behaviours written expert erlang programmers 
modules years experience represent best practice writing code particular problem 
systems built otp behaviours regular structure 
example client servers supervision trees identical structure 
behaviour forces common structure solution problem 
applications programmer provide part code defines semantics chapter 
building application particular problem 
infrastructure provided automatically behaviour 
relatively easy new programmer joining existing team understand behaviour solutions problems 
gained familiarity behaviours easily recognize situations particular behaviour 
tricky systems programming hidden implementation behaviours complicated described 
look back clientserver event handler behaviours see code concurrency message passing isolated generic part behaviour 
problem specific code pure sequential functions defined types 
highly desirable state concurrent programs diecult isolated small defined parts system 
vast majority code system written sequential programs having defined types 
system behaviours solve orthogonal problems example client server worker supervisor 
building real system pick mix behaviours combine dicerent ways solve problems 
small fixed set behaviours sodware designer benefits focuses attention small set proven techniques 
know advance individual techniques practice 
totally unconstrained choice complete freedom action design designer may tempted produce unnecessarily complex implemented 
allows designer structure talk design precise manner 
provides vocabulary discourse 

discussion completes feedback cycle design implementation 
behaviours practice 
example ericsson axd product 
chapter 
building application otp open telecom platform otp development system designed building running telecommunications systems 
block diagram system shown taken article 
seen otp system called middleware platform designed run top conventional operating system 
otp system developed internally ericsson 
sodware released public domain subject erlang public license 
included otp release components 
compilers development tools erlang 

erlang run time systems number dicerent target environments 

libraries wide range common applications 

set design patterns implementing common behavioural patterns 

educational material learning system 

extensive documentation 
similar open source license 
chapter 
otp applications written languages applications written erlang mnesia snmp agent erlang run time system web server commercial operating system computer hardware otp system architecture otp ported number dicerent operating systems include major unix systems linux freebsd solaris os windows operating systems windows nt 
number embedded operating systems vxworks 
erlang run time system virtual machine designed run intermediate code produced erlang beam compiler 
provides run time support services native code erlang compiler 
erlang beam compiler replaced original jam compiler 
beam compiler compiles erlang code sequences instructions bit word threaded interpreter 
original jam machine non threaded byte code interpreter 
additional erlang programs compiled native code hipe compiler developed university uppsala 
interpreted beam compiled code freely intermixed module level entire modules compiled beam hipe code code individual module intermixed 
beam hipe machines common code erlang run time system memory management input output process management garbage collection 
libraries erlang run time system services traditionally operating system comparison runtime support needed purely sequential language run time system fairly complex 
erlang processes managed erlang run time system tens thousands erlang processes running control erlang run time system host operating system think process running erlang run time system 
erlang compiler hand simple compared languages 
compilation oden simple translation erlang code appropriate primitive virtual machine 
example spawn primitive erlang compiles single opcode virtual machine spawn primitive great care taken implement possible 
libraries otp release contains large set libraries release purposes considered instances otp applications 
release contains applications graphical utility observe manipulate supervision trees 
asn compiler run time support decoding encoding packets defined asn 
compiler erlang compiler 
crypto set functions encrypting decrypting data computing message digests 
debugger erlang source code debugger 
erl interface set libraries communicating distributed erlang nodes 
chapter 
otp erlang run time system 
event tracer tools record give graphical presentation event data 
eva event alarm handling application 
gs graphics system 
set graphics routines building guis 
ic erlang idl compiler 
server ftp client 
tool create java erlang interfaces 
kernel basic libraries needed run system 
kernel contains code file servers code servers libraries protocols 
database query language mnesia 
mnesia distributed dbms sod real time properties erlang 
observer tools tracing observing behaviour distributed system 
odbc erlang interface odbc interface sql databases 
erlang implementation corba object request broker 
note separate applications provide access various corba services events notifications file transfers os mon tool monitor resource usage external operating system 
media gateway control 

libraries tools parsing erlang 
includes lalr parser generator 
graphic tool inspect state system 
observe local remote erlang nodes 
runtime tools miscellaneous small routines needed runtime system 
short system architecture support libraries application contains support alarm handling managing releases snmp erlang implementation simple network management protocol 
application includes mib compilers tools building mibs ssl erlang interface secure sockets layer 
pure erlang libraries needed run system 
obligatory application kernel 
toolbar graphical toolbar applications started 
tools package stand applications analysing monitoring erlang programs 
includes tools profiling coverage analysis cross analysis tv table viewer table viewer graphic application allow graphic browsing tables mnesia database 
system managing web tools 
otp libraries provide highly sophisticated tool set starting point commercial product fairly complex 
chapter 
otp recall chapter devoted simplified explanation behaviours gen server gen event gen fsm supervisor application complete explanation behaviours outside scope thesis 
principles behaviours gen server subject pages 
release modules described 
case studies section thesis presents studies systems written erlang otp system 
ericsson axd system axd high capacity atm switch 
version axd system studied lines erlang largest programs written functional style programming 
axd extensive otp libraries provides test functionality libraries 
study number small products ab alteon web systems nortel networks 
avoid confusion add ab founded erlang people led ericsson cslab included subsequently acquired alteon web systems nortel networks acquired alteon 
products developed core group people 
products include mail bmr ssl accelerator alteon web systems sold nortel networks 
ssl accelerator developed remarkably short time months rapidly market leader niche market embedded secure socket layer devices ssl accelerator extensive erlang otp system libraries 
projects represent extremes 
axd done asynchronous transfer mode 
secure socket layer 
chapter 
case studies large group programmers programmers involved code year period 
large sodware projects notoriously diecult manage resulting code oden diecult understand matters am concerned poorly otp design methodology supports construction large systems 
second set projects programmed smaller group programmers depending product completed shorter time frame months 
developers highly experienced erlang programmers 
developers magnus fr berg martin bj designed programmed original otp behaviours 
developers author second edition erlang book 
main implementor distributed erlang mnesia data base 
methodology case studies am interested problem domain problem domain 
kind problem erlang otp designed solve 
quantitative properties code lines code written 
modules 
code organised 
programmers follow design rules 
design rules helpful 

bad 
evidence fault tolerance system fault tolerant 
raison tre erlang build fault tolerant systems 
evidence errors occurred run time successfully corrected 
information produced programming error occurred subsequently correct program 
understanding system system understandable 
maintained 

methodology ask general questions properties system am looking specific evidence system behaves desirable manner 
particular 
evidence show system crashed due programming error error corrected system subsequently recovered error behaved satisfactory manner ader error correction occurred 

evidence show system run extended period time sodware errors occurred system stable 

evidence code system updated fly 
evidence garbage collection works run garbage collected system long time getting garbage collection errors 

evidence information error logs post crash localization error 

evidence code system structured way majority programmers need concerned details concurrency patterns system 

evidence supervision trees expected 

code structured clean dirty style 
items included wish test ideas programming fault tolerant systems practice 
item tests hypothesis long term garbage collection real time systems operate extended periods time 
chapter 
case studies item measure abstraction power otp behaviours 
desirable number reasons details concurrency commonly recurring situations 
set otp behaviours attempt 
extent programmers approximation ignore concurrency important measure suitable otp behaviours making system sodware 
assess extent concurrency ignored observing oden programmers forced explicit message passing process manipulation primitives code 
item tests supervisor strategies expected 
item tests possible program rules gave appendix particular guidelines stress importance structuring system clean dirty manner 
clean code purposes assumed side free code code easier understand dirty code code having side 
entire system concerned manipulation hardware 
manipulation hardware involves side 
concern side avoided extent code side restricted small number modules 
having code side scattered uniform manner system desirable small number dirty modules large number side combined larger number modules written side free manner 
analysis code reveal structuring possible 
interest counter evidence know cases paradigm breaks breakdown major problem 
axd axd high performance asynchronous transfer mode atm switch produced ericsson 
system built number scalable modules module provides gbit switching capacity modules connected form gbit 
quantitative properties software switch 
axd designed carrier class non operation 
system duplicated hardware provides hardware redundancy hardware added removed system interrupting services 
sodware able cope hardware sodware failures 
system designed non operation possible change sodware disturbing system 
quantitative properties sodware report result analysis snapshot axd sodware 
snapshot represents state system december 
analysis concerned quantitative properties erlang code system 
gross properties system follows number erlang modules clean modules dirty modules number lines code total number erlang functions total clean functions total number dirty functions percentage dirty functions code lines table code subject simple analysis superficially classifies module function clean dirty module considered dirty function module dirty clean 
simplify matters say function dirty sends receives message calls erlang chapter 
case studies apply cancel timer check process code delete module disconnect node erase group leader halt link load module monitor node open port port close port command port control process flag processes purge module put register registered resume process send spawn spawn link spawn opt suspend process system flag trace trace info trace pattern unlink unregister yield 
reason classification code fragment calls potentially dangerous 
notice chosen particularly simple definition dirty sight appear better recursively define module dirty function module calls dangerous bif dirty function module 
unfortunately definition virtually module system classified dirty 
reason compute transitive closure functions calls exported particular module transitive closure include virtually module system 
reason transitive closure large due leakage occurs modules erlang libraries 
take simplifying view modules written tested contain side module written way side leak module adversely code calls module 
definition modules clean 
module considered dirty contains single dirty function interesting look ratio clean dirty functions 
function considered dirty single call bif 
viewed function level functions appear written side free manner 
note total dirty functions contained lines code dirty functions lines code 
distribution dirty functions shown 
distri 
quantitative properties software mods dirty functions distribution dirty functions bution dirty functions encouraging discouraging 
news dirty functions slightly modules 
bad news large number modules small number impure functions 
example modules dirty function dirty functions interesting thing data systematic code pure emergent style programming favour style programming small number modules large number side larger number modules having side 
erlang programming rules favour style programming intention get experienced programmers write test code lots side 
axd code idea explicitly define modules allowed contain side enforce kind quality control 
look detail primitives called introduce side get ordering put apply send receive erase process flag spawn unlink register chapter 
case studies spawn link link unregister open port processes yield halt registered spawn opt port command trace cancel timer monitor node 
common primitive put times see erlang primitives black list 
common primitive introduces side put depending put may may dangerous 
common put assert global property process debugging purposes 
probably safe automatic analysis program infer fact 
dangerous side change concurrency structure applications modules call link unlink spawn spawn link primitives carefully checked 
dangerous code evaluate halt processes assume code carefully checked 
system structure axd code structured otp supervision trees structure axd code inferred primarily shape trees 
interior nodes supervision tree supervisor nodes terminal nodes tree otp behaviours specialised application specific processes 
axd system supervision tree nodes instances otp behaviours 
number instances behaviours gen server gen event supervisor gen fsm application 
gen server lesser extent gen event dominate instances generic server 
interesting point note behaviours required 
client server abstraction gen server useful generic objects system instances client servers 

quantitative properties software otp libraries supervisor starts application calling function called child spec processes supervisor controls 
things child specification contains mod func args tuple specify start supervised process 
method starting supervised process completely general arbitrary function started supervisor 
axd case full generality method dicerent startup methods supervision hierarchies 
methods method dominated supervision trees 
axd architects defined master supervisor parameterised number standardised ways 
axd supervisors packaged conventional otp applications behaviour described called app files 
analysing axd apps gives idea static structure axd sodware 
total app files axd sodware 
files represent disjoint supervision trees 
supervision trees flat complex structure 
simple way show structure plot trees simple ascii display 
example eleven top level trees responsible standby services standby top application standby parts ats subsystem sb protocol termination 
cc sb call control standby role sb protocol termination 
sb message dispatcher standby role pch sb permanent connection handling 
pnni sb protocol termination pnni 
sb standby application sb standby application 
sbm sb standby manager start standby role sb soft permanent connection 
uni sb protocol termination uni 
standby applications sws circuit emulation axd 
chapter 
case studies sb connection handling standby node tone echo axd sws 
seen tree simple structure flat deep 
main sub nodes tree supervisor structure underneath sub nodes flat 
note displaying data manner shows organisation supervisor nodes 
actual processes sub nodes leafs tree shown type supervision supervision 
reason trees flat deep reflects experience gained axd sodware 
put simply cascading restarts chief sodware architect axd restarting failed process arguments oden worked simple restart procedure failed cascading restarts restarting level generally help 
interestingly gray observed hardware faults transient corrected state hardware retrying operation 
conjectured true sodware conjecture similar phenomenon sodware production faults sod 
program state reinitialized failed operation retried operation usually fail second time 
full generality model thesis trying simpler strategy event failure partially exploited 
particular exploitation accidental design otp libraries provide interfaces file system system level services sockets written manner protect integrity system event failure 
example files sockets automatically closed controlling processes file socket terminates reason 

quantitative properties software level protection provided otp library services automatically provides simpler level service implied model fault tolerant computing 
evidence fault recovery sections evidence error recovery mechanism worked planned 
evidence analysis entries contained ericsson trouble report database 
quoted data trouble report database added entries removed irrelevant detail 
trouble report hd trouble report hd may information 
description heading crash report performance measurements issue priority minor fault opinion traffic disturbance status fi finish hot tr 

observation top page effect crash report performance measurements issue description node axd pp customer crash report may pid registered name error info function clause get hwm base ne cv ga create mep get counter values collect group proc lib init initial call collect generic observed object group undefined chapter 
case studies ancestors super messages links dictionary mi apply em type sublayer type sublayer int trap exit false status running heap size stack size reductions neighbours measures performance measurements turned crash report stopped occurring 

answer 
combination wildcard implementation ds measurement cause described crash 
effect measurement fails 
fault detected released important customer 
wildcard implementation greatly improved problem exist 
recommend specify pdh interfaces included ds measurement 
crash number fairly typical illustrates situation hardware errors occurred corrected system reverted normal 
crash report lines error log contains information function clause get hwm base ne cv ga create mep get counter values collect group proc lib init 
quantitative properties software get hw base ne cv ga called function call fails pattern matching error 
interestingly error occurred april snapshot system access december reasoned error snapshot code 
satisfy curiosity checked code 
code looked get hwm base cnt 
lines omitted get hwm base fe pdh tr ce fe tr 
pattern match calling arguments clearly error occur called arguments shown error log 
able clearly locate error understand program failed didn idea error means 
encouraging note programmer wrote code programmed defensive manner written code get hwm base cnt 
lines omitted get hwm base fe pdh tr ce fe tr get hw base exit 
written code exactly style recommended page 
recall motivation writing code manner defensive style programming unnecessary erlang compiler automatically adds additional information suitable debugging program 
chapter 
case studies trouble report hd crash number hd interesting 
reading log subsequent comments engineers studied problem see error occurred run time corrected 
error occurs deemed worthy correction 
section extracted trouble report nit test case takeover om process ch cp 
traffic continues run successfully get error reports cp blocked 
example see enclosure erlang log error report apr error info case clause plc handle info gen server handle msg proc lib init msg info tag plc msg info mfa plc old hc ncs undefined msg info true node axd cp proc info pid server message queue len dictionary ancestors lines omitted 
answer text 
quantitative properties software fault solved version block 
solution planned earlier versions mainly reasons fault obvious negative effects traffic handling 

lines show error occurred 
line lines show despite error system functions obvious negative handling error nice shows certain execution path error encountered 
system detects recovers error particular error system behaved reasonable manner presence sodware error 
deficiencies otp structure interesting area erlang model programming handling call setup call termination axd sodware 
section philosophy cop argued mapping problem structure sodware architecture 
important part axd sodware mapping possible 
part sodware setup termination calls 
order understand point go little detail important services axd switch 
axd switching system responsible maintenance large number connections 
time module system handling large number virtual channels 
channel represents single connection 
typically single node handle connections 
connections possible states 
setup state new connection established 
intensive signalling 
chapter 
case studies 
connected state connection established 
little signalling monitoring going connection 

terminating state connection terminating 
signalling points connection 
setup termination phases connection quick typically take milliseconds 
termination somewhat simpler setup 
connection phase monitoring involved connection phase typically orders magnitude longer setup termination phases 
connections range seconds hours years 
time connections node vast majority connected state 
system dimensioned maximum calls second number refers number simultaneous calls setup termination phase number calls connected phase 
modelling natural concurrency problem needs concurrent processes call setup termination 
having processes connection setup say couple processes connected call requires erlang processes 
processes suspended long time processes monitor connected calls implemented number reasons 
firstly processes take space doing 
secondly state involved connected phase replicated physical hardware boundary 
order provide continuous service presence hardware failure 
axd tries minimise number active processes connection handling uses strategy 

call setup processes created handle call 

call setup succeeds relevant information call reduced call record describes call 
processes call setup destroyed call record 
quantitative properties software describes call stored locally 
asynchronous message containing copy call record sent backup node current node 

call termination process structure required terminate call created initialized data call record 
call termination processing occurs processes involved destroyed 
call setup process understood memory requirements process setup phase understood 
maximum stack heap size needed setup processes known established number measurements 
data possible initialise processes needed call setup large initial stacks heaps garbage collection occurs call setup 
setup attempt replicate state calls physical boundary system crashes call lost 
event client detect failure merely try 
event hardware failure retry directed new hardware module succeed 
call setup quick hardly problem 
setup phase complete information reduced call record kb call processes call setup destroyed 
asynchronous message containing call record sent backup processor 
hardware units configured pairs 
pair machine considered backup machine machine machine backup machine signals particular client arbitrated hardware dispatcher unit sends signals particular call master unit call 
master unit fails call connected state arbitrator direct signals backup unit 
call termination modification call inverse call setup 
system detects operation performed call call record retrieved process structure necessary manipulate call created initialized data call record 
call processing proceeds call setup 
chapter 
case studies model minimizes number processes active set processes needed perform particular operation 
application reaches point time little active processing data processes destroyed relevant data needed re create process structure stored database asynchronously replicated backup machine 
approach advantages having flexible process structure needed complex phases call setup termination processes inactive storage reclaimed deleting processes storing state data stable storage 
fact state information asynchronously replicated increases throughput system compromising integrity system 
solution fits nicely erlang processes model 
processes light weight create destroy demand systems heavy weight processes similar solution destroying process finished process recycled pool processes maintained system 
time axd sodware developed upper limit total number erlang processes run time system 
number large large allow hundreds thousands processes system 
versions system allow hundreds thousands erlang processes millions processes 
designer system approximation worry total number processes system able crudely dimension system rough idea processes needed operation application 
long lived processes storing process state data base process active attractive alternative 
method added advantage replicating state stable storage sodware fault tolerant 

smaller products smaller products second case study concerns products developed ab 
products mail bmr described 
mail server server server server clients proxy servers mail product designed increase reliability existing mail services 
bmr designed proxy placed clients wished mail services number mail servers 
far clients concerned servers ip address address proxy internally proxy physical machines fault tolerance intercept relay messages back servers 
back servers machines running standardised mail servers 
bmr concentrated mail protocols smtp pop imap 
bmr shipped customers turn key system 
requirements bmr 
times minutes decade 

mail server fails server take minimum delay clients notice server failed 
chapter 
case studies 
possible remotely manage system 
add remove mail servers take service interrupting quality service 

possible upgrade bmr sodware stopping system 

event error bmr sodware possible revert previous version sodware stopping system 

system improve performance existing mail systems 

system existing hardware run existing operating systems 

system conventional imperative language implementation 

system conventional unix command line interface conventional unix manual pages 

system gui interface 
points typical requirements sod real time system particular point typical requirement kind system rarely requirements system short period time 
point related point far possible want operation sodware entirely autonomous require minimal operator intervention 
fact bmr remotely managed upgrades system handled automatically remotely important factor selling product 
main reasons buying bmr relieve burden manually monitoring maintaining mail system 
bmr written erlang modules lines erlang code 
written scratch delivered customer months project start 
bmr live 
smaller products operation swedish isp handles millions emails year 
bmr implemented release management system extension release behaviour otp system 
bmr system intrinsically distributed system 
desirable sodware upgrade distributed system transaction semantics sodware upgrade works entirety nodes system fails sodware changed node 
bmr versions entire system exist old version new version 
adding new version sodware current version sodware old version added version new version 
achieve bmr sodware upgrade packages written reversible manner possible perform dynamic upgrade old version sodware new version convert new version back old version 
upgrading sodware nodes done phases 

phase new sodware release distributed nodes succeeds 

phase sodware nodes changed old version new version 
conversion node fails nodes running new versions sodware backed run old version sodware 

phase nodes system run new sodware error occur nodes backed run old sodware 
system committed run new sodware 

ader new system run successfully time period operator commit sodware change 
committing system phase changes behaviour system 
error occurs ader commit system restart new sodware revert old sodware 
chapter 
case studies interestingly exactly mechanism system developed nasa deep space applications sodware applications upgraded stopping system 
addition bmr upgrade system allow possibility node distributed system service time sodware upgrade performed 
case node re introduced system learn changes system time unavailable necessary sodware upgrades performed 
alteon ssl accelerator alteon ssl accelerator product produced ader ab acquired alteon web systems 
ssl accelerator hardware appliance containing special purpose hardware speeding cryptographic computations 
ssl accelerator marketed sold nortel networks 
control system ssl accelerator written erlang 
research alteon ssl accelerator leading ssl accelerator appliance market 
ssl accelerators deployed vendor nortel networks leads market innovative new applications features back encryption integrated load balancing session persistence application address translation layer filtering secure global server load balancing 
ader winning evaluation categories network computing named nortel networks alteon ssl accelerator king hill latest ssl accelerator bake oc citing industry leading performance features manageability distinguishing attributes 
secure socket layer 

smaller products ssl accelerator produced hardware appliance 
interestingly produced short time year rapidly market leader having won best test awards categories awarded network computing sodware architecture ssl accelerator derived generic architecture mail 
quantitative properties code unfortunately nortel networks analyse source code detail report properties code 
data derived alteon erlang products 
distinguish individual products number erlang modules clean modules dirty modules number lines code total number erlang functions total number clean functions total number dirty functions percentage dirty functions code lines products extensive otp behaviours behaviours 
gen server dominated 
number times dicerent behaviours gen server supervisor application gen event rpc server gen fsm supervisor bridge 
say figures apart fact sight axd project relatively longer functions relatively fewer behaviours alteon projects 
interviewed people programmed ssl accelerator 
told practice architecture worked failures due sodware unrecoverable sodware errors occurred kept records confirm observation 
chapter 
case studies said product upgrade mechanism evolved developed otp system 
product release increment designed way totally reversible 
planning go version system version write code go version version write code go version version discipline strictly followed possible rollback system current incarnation release 
commercial reasons nortel wish release detailed information details process 
discussion started case studies fairly clear idea parameters possible measure 
ultimate test technology ask users technology question ask question people ericsson nortel shake heads say course works hoped able provide clearly documented evidence system manner described thesis 
liked evidence log files code upgrades worked system crashed recovered system run thousands hours interruption people interviewed happy tell case code upgrades expected 
produce collaborative evidence case records log files code upgrades occurred 
reason documentary evidence system instrumented way report log files things code upgrade occurred lasting evidence 
interestingly counter evidence suggest 
discussion procedures failed 
assume procedures failed lot trouble reports documented fact 
evidence long term operational stability system collected systematic way 
ericsson axd information long term stability system came power point presentation showing figures claiming major customer run node system reliability obtained documented 
case bmr ssl accelerator hard evidence system run reliably extended periods time 
reason information recorded log files 
bmr course fault tolerant distributed system having interconnected nodes 
system failure individual node noteworthy event system designed survive crash single node 
single nodes crash obviously anecdotal evidence case performance system slightly degraded point operational problem 
am unaware entire system failures nodes fail case suspect due massive hardware failure machines system 
failures appear extremely rare occur cause failure sodware entirely dicerent hardware issue 
distributed system perception failure language talking failure need modification 
hardly sense talk total system failure uncommon event need talk measure degradation service quality 
sodware systems case study reliable people operating system inclined think error free 
case sodware errors occur run time errors quickly corrected noticed errors occurred 
get accurate statistics long term stability record start stopping times system measure chapter 
case studies number parameters indicated health system 
system appears entirely healthy statistics collected systematic way 
regards analysis axd code base hoped find evidence programming rules correctly liked example seen clear separation clean dirty code 
accept certain parts system written suspect manner reasons reason liked code separated clear manner main body code stringent test procedures applied code case 
majority code clean distribution dirty code pure step function clear division say code bad stare carefully code spread distribution small number modules lot side doesn worry troublesome number modules calls dirty primitives 
deeper understanding code possible impossible say nature problem calls potential side introduce problems system harmless 
case message clear 
programming rules cause system written particular way 
wished enforce partitioning code clean dirty code tool support added policies enforced manner 
desirable debatable probably best approach allow rules broken hope programmers know doing break programming rule 
ultimate test technology course test case axd nortel ssl accelerator answer products small niche products market leaders niches 
apis protocols built sodware module need describe 
method define programming language api exported functions module 
erlang type system outlined page 
method defining api widespread 
details type notation vary language language 
degree type system enforced underlying language implementation varies system system 
type system strictly enforced language called strongly typed called untyped point oden causes confusion languages need type declarations type systems easily broken 
languages erlang need type declarations type safe meaning underlying system broken way damage system 
language strongly typed existence type declarations provides valuable documentation input dynamic type checker run time type checking 
unfortunately api written conventional manner understand operation program 
example consider code fragment silly ok file open foo dat read file close file read line 
chapter 
apis protocols type system api example page perfectly legal program obviously total nonsense expect read file closed 
remedy problem add additional state parameter 
fairly obvious notation api written type start file open filename read write ok ready error string 
type ready file read line ok string ready eof 
type ready file close true 
type ready file rewind true ready model api uses state variables start ready 
state start means file opened 
state ready means file ready read means file positioned file 
server starts state start stops state 
api says example state ready file read line function call legal 
return string case stay state ready return eof state 
state close rewind file operations illegal 
choose rewind file state change back ready case read line operation legal 
augmenting api state information provides method determining sequence allowed operation accordance design module 

protocols protocols having seen specify sequencing api equivalent idea applicable protocols 
consider components communicate pure message passing level abstraction need able specify protocol messages flow components 
protocol components described terms non deterministic finite state machine 
assume process file server client program file server assume sessions connection oriented 
protocol file server obeys specified follows state start open filename read write ok ready error string 
state ready read line ok string ready eof 
state ready close true 
state ready rewind true ready specification says file server state start receive message type open filename read write chapter 
apis protocols processes protocol checker respond sending message type ok move state ready respond replying message error string move state 
protocol specified manner similar possible write simple protocol checking program placed pair processes 
shows protocol checker placed processes sends message query responds response new state pair type checked rules protocol specification 
protocol checker sits checks messages protocol specification 
order check protocol rules checker needs access state server protocol specification contain productions state sn case observation reply message type distinguish output states 
recall simple generic server shown page main loop program loop state fun receive 
apis protocols 

reply state state reply reply loop state fun easily changed loop state fun receive reply state state reply reply loop state fun 
represent state variable specified protocol specification 
note state interface value state variable protocol specification state server state 
change generic server re cast form allows dynamic protocol checker inserted client server 
apis protocols 
shown essentially equivalent ways doing thing 
impose type system programming language impose contract checking mechanism components message passing system 
methods prefer contract checker 
reason structure systems 
model programming assume isolated components pure message passing 
components considered black boxes outside black box computation performed inside black chapter 
apis protocols box totally irrelevant 
thing important black box behaves protocol specification 
inside black box may desirable reasons program obscure programming methods break rules common sense programming practice 
matter slightest provided external behaviour system consistent protocol specification 
simple extension protocol specification extended specify non functional properties system 
example add protocol specification language notion time say things type si operation arg value sj value sk meaning operation return value type data structure time return type value ader time second reason things system 
placing contract checker outside component way interferes construction component allows flexible way adding removing introspective testing powers system checked run time configured number dicerent ways 
communicating components erlang talk outside world 
question interesting want build distributed applications erlang number communicating components 
read fundamental building blocks underlying system modules messages 
module self contained 
discussion entity simula smalltalk class sail process clu module 
important moment programming language encode body module wish explicitly account case various modules coded dicerent languages variety machines order system communication components agree number dicerent things 
need transport format way mapping language entities entities transport format 
system types built top entities transport format 
protocol description language terms system types 
method doing involving transport format called ubf short universal binary format designed rapid parsing 
slightly revised version appendix discussion want return central question thesis reliable system presence errors 
stepping outside system viewing system set communicating black boxes helpful 
formally describe protocol obeyed communication channel black boxes means detecting identifying errors say precisely component failed 
architecture satisfies requirements page reasoning programming error resilient systems 
chapter 
apis protocols try simpler idiom page applies 
blackbox implementation function fails revert simpler implementation implemented black box 
protocol checking mechanism making meta level decisions implementation choosing simpler implementation errors observed 
components reside physically separated machines property strong isolation automatically enforced 
theses completed point just give 
thesis number things new programming language method programming fault tolerant systems 
erlang appears useful tool programming reliable systems amazingly large number applications far removed problem domain erlang designed 
achieved far 
described thesis related performed demonstrated number dicerent things erlang associated technology works 
interesting result 
people argued languages erlang full scale industrial sodware development 
axd nortel range products shows erlang appropriate language types product development 
fact products successful market leaders respective niches significant 
programming light weight processes shared memory works practice produce complex largescale industrial sodware 
chapter 
possible construct systems behave reasonable manner presence sodware errors 
ideas shame erlang story chapters number directions see language develop 
conceptual integrity develop erlang reinforce process view world 
system erlang code regular easier understand 
kernel improvements statement page modified truth 
property strong isolation strictly adhered known implementation erlang 
process process system allocating vast amounts memory sending large numbers messages process 
malicious process destroy entire system creating large numbers atoms overflow atom table current implementations erlang designed protect system malevolent attacks 
kernel improvements possible guard attacks 
program components idea set communicating processes leads naturally idea writing components dicerent languages 

conceptual integrity system easier understand 
erlang programming model process emphasise view making minor changes languages 
changes unnecessary 
assume process 

ideas processes names 
message passing explicit 
introduce new infix remote procedure call operator called bang bang written 
pid short self receive reply reply fact pid atom string list pid atoms strings 
returns 
rpcs performed parallel 
files bang bang recall said earlier process processes names files processes 
file 
read reads file 
write bin writes file 
code fragment reads file copies new location ok bin home joe abc 
read home joe def 
write bin example reads files parallel chapter 
home joe foo www sics se joe file html ftp www pub joe file 
read fairly obvious syntactic sugar 
suppose am working home keep copy remote host 
code compares local copy file copy backup machine dicerent updates backup copy home joe foo remote ftp www sics se joe backup foo case 
read true ok bin remote 
write bin error distribution bang bang process name string form erl node name operation performed remote node local node erl node name 
means evaluate name 
node node return result user 
ok bin erl joe sics se home joe abc 
read home joe def 
write bin reads remote file stores local computer 

ideas spawning bang bang universe magic processes assumed exist 
names dev processes pre defined magic things 
particular dev spawn process spawning device 
send dev spawn erlang fun send back erlang pid pid dev spawn 
fun pid erl joe org dev spawn 
fun creates erlang processes org 
local node 
throw away erlang primitive spawn 
replaced spawn device 
naming processes talked dev spawn devices flavour dev spawn process dev stdout stdout dev log spool errors error logger dev code code server proc name processes path file files dev tables dev ets ets tables dev mnesia mnesia tables host file read files erl node hist 
remote processes need extend process registration primitive allow register string name process 
chapter 
module vshlr 
export start handle rpc handle cast 
import server start rpc 
import dict new store find 
start start vshlr fun handle event new 
vshlr 
handle cast am dict store dict 
handle rpc find dict find dict dict 
simple home location register revisited programming bang bang start simple example 
old friend home location register revisited 
time vshlr written pure erlang function attempt hide access functions inside stub function 
expose interface 
bang bang notation shell dialog shown page vshlr start 
true vshlr 
find joe 
error vshlr am joe sics 

exposing interface discussion ack vshlr 
find joe 
ok sics achieve results time encapsulated remote procedure call stub function 
exposed programmer 
exposing interface discussion expose interfaces 
imagine ways doing things 
suppose remote file server accessible variable suppose protocol file server client code hidden module file server erl 
inside file server erl find code module file server 
export get file 
get file fs filename fs self get file name receive fs reply reply access function get file client code fetch file file server 
statement file file server get file home joe foo fetch file 
code nicely hidden inside file server user idea need know underlying protocol 
concurrent programming erlang argued hiding details interface programming practice chapter 
purpose interface functions create abstractions hide specific details protocol clients server 
user service need know details protocols implement service internal data structures algorithms server 
implementor service free change internal details time maintaining user interface pages unfortunate consequence encapsulation easily simultaneous calls dicerent file servers stream requests single file server 
wish perform rpcs parallel better dispatch requests gather responses done situations interface exposed 
programming communicating components interestingly dominant way building internet applications involves isolated components 
pure message passing 
informal protocols 
internet case components really physically isolated example client sweden services server australia 
pure message passing shared data norm 
possibly just way system builder understand build distributed applications involves asynchronous 
programming communicating components protocols described informally rfcs 
problem rfcs virtually rfc defines ad hoc syntax data transit allowed sequences messages oden described formally guessed implementor 
standard syntax describing rfcs example xml lisp expressions ubf terms great step forward enabling single parser applications 
contract checker proposed appendix programming internet applications significantly easier hopefully applications reliable 
interestingly internet model works notification reasons failure 
pathological distrust component talking sensible normal applications notification failure reason implementing debugging applications lot easier 
contract checker accurately pinpoints exactly errors occurred increasingly important communicating components added system 
model communicating components widely distributed applications infrequently structuring single node applications 
interest designers reject idea processes protection domains sodware favour shared object models 
believe model programming single node applications exactly programming distributed applications 
dicerent components protected processes 
impossible components damage components communicate defined protocols specified contract enforced contract checker 
way build reliable applications 
requests comments set memos describing various aspects internet including major application protocols 
chapter 
acknowledgments erlang system otp libraries applications built erlang result massive amount done large number people 
diecult write acknowledgments section don want anybody contributed system don want errors shall try accurate possible omissions inaccuracies advance 
start management types possible place 
bjarne cker boss ericsson enthusiastic fought behalf bjarne 
rn jonsson bjarne boss fought bjarne behalf rn learnt lot 
jane jane woman open source erlang managing director taught know running small business 
get developers erlang longer list 
original erlang team robert virding mike williams 
originally wrote erlang compiler robert wrote libraries mike wrote jam emulator 
robert wrote dicerent erlang emulators prolog 
mike re wrote emulator ader couple years came added distribution erlang hausman invented improved erlang machine beam 
erlang machine 
appendix acknowledgments members cslab dropped project wrote programs erlang went things 
carl wilhelm wrote 
hans nilsson wrote mnesia tony added binaries language generally amazing things networks 
amazing patience answered stupid question unix sure systems worked beautifully 
re wrote tricky bits erlang emulator looking 
magnus fr berg wrote debugger rn wrote interface generator interface erlang erlang moved lab otp born group extended reshaped 
magnus fr berg martin bj designed otp library structure structure behaviours 
otp behaviours number ideas floating lab 
written generic server similar gen server peter written generic server early version supervision tree 
ideas process supervision came peter mobility server project 
ader led ericsson day day maintenance development system moved new generation programmers 
bj rn gustavsson maintains emulator otp libraries maintained lars kenneth kent patrik hans richard green dan 
users erlang otp system significantly improved interaction faithful band users 
set users built major product erlang mats persson kerstin peter ake karlsson larsson 
axd ulf blau pioneering erlang carrier class applications 
inside ericsson outside ericsson users amazing things 
sean uk man erlang factory inside mobile 
erlang mailing list source inspiration encouragement 
today anybody wants know er lang just ask erlang list usually get accurate informed reply hour 
people list especially met exchanged long interesting mails 
friends colleagues sics prof seif haridi supervising thesis 
brand encouraging write thesis members distributed systems laboratory stimulating discussions 
everybody 
appendix acknowledgments programming rules conventions program development erlang programming rules conventions 
eriksson williams armstrong march description programming rules advice write systems erlang 
note document preliminary document complete 
requirements base system documented followed early design phase base system 
requirements documented map start error recovery reformatted version ericsson internal document epk np document released public domain part open source erlang distribution appendix programming rules conventions contents 
purpose 

structure erlang terminology 

sw engineering principles 

error handling 

processes servers messages 

various erlang specific conventions 

specific lexical stylistic conventions 

documenting code 

common mistakes 

required documents 
purpose lists aspects taken consideration specifying programming sodware systems erlang 
attempt give complete description general specification design activities independent erlang 
structure erlang terminology erlang systems divided modules 
modules composed functions attributes 
functions visible inside module exported called functions modules 
attributes placed module 
system designed erlang done processes 
process job functions modules 
processes communicate sending messages 
processes receive messages sent process decide messages prepared receive 
messages queued receiving process prepared receive 
process supervise existence process setting link 
process terminates automatically sends exit signals process linked 
default behaviour process receiving exit signal terminate propagate signal linked processes 
process change default behaviour trapping exits causes exit signals sent process turned messages 
pure function function returns value arguments regardless context call function 
normally expect mathematical function 
function pure said side 
side typically occur function sends message receives message calls exit calls bif changes process environment mode operation get put erase process flag 
warning document contains examples bad code 
sw engineering principles export functions possible module modules basic code structuring entity erlang 
module contain large number functions functions included export list module called outside module 
seen outside complexity module depends number functions exported module 
module exports functions usually easier understand module exports dozens functions 
modules ratio exported non exported functions low appendix programming rules conventions desirable user module needs understand functionality functions exported module 
addition writer maintainer code module change internal structure module appropriate manner provided external interface remains unchanged 
try reduce intermodule dependencies module calls functions dicerent modules diecult maintain module calls functions dicerent modules 
time change module interface check places code module called 
reducing interdependencies modules simplifies problem maintaining modules 
simplify system structure reducing number dicerent modules called module 
note desirable inter module calling dependencies form tree cyclic graph 
example module function module function module function module function module module function function put commonly code libraries commonly code placed libraries 
libraries collections related functions 
great ensuring libraries contain functions type 
library lists containing functions manipulating lists choice library lists maths containing combination functions manipulating lists mathematics bad choice 
best library functions side 
libraries functions side limit re usability 
isolate tricky dirty code separate modules oden problem solved mixture clean dirty code 
separate clean dirty code separate modules 
dirty code code dirty things 
example uses process dictionary 
uses erlang process info strange purposes 
supposed 
concentrate trying maximize amount clean code minimize amount dirty code 
isolate dirty code clearly comment document side problems associated part code 
don assumptions caller results function don assumptions function called caller function wishes results 
example suppose call routine certain arguments may invalid 
implementer routine assumptions caller function wishes happen arguments invalid 
appendix programming rules conventions write code args case check args args ok ok args error string format error don io format error string error 
write args case check args args ok ok args error error 
error report error format error 
case error string printed standard output case error descriptor returned application 
application decide error descriptor 
calling error report application convert error descriptor printable string print required 
may desired behaviour case decision result led caller 
common patterns code behaviour pattern code places code try isolate common function call function having code dicerent places 
copied code requires maintain 
see similar patterns code identical places code worth time see change problem slightly dicerent cases write small amount additional code describe 
avoid copy paste programming functions 
top write program top fashion bottom starting details 
top nice way successively approaching details implementation defining primitive functions 
code independent representation representation known higher levels code designed 
don optimize code don optimize code stage 
right necessary fast keeping right 
principle system respond manner causes user user able predict happen result 
consistency consistent system dicerent modules things similar manner easier understand system module things dicerent manner 
get function function solves wrong problem wrong name 
appendix programming rules conventions try eliminate side erlang primitives side 
functions easily re cause permanent changes environment know exact state process calling routines 
write possible code side free code 
maximize number pure functions 
collect functions side clearly document side 
little care code written side free manner system lot easier maintain test understand 
don allow private data structure leak module best illustrated simple example 
define simple module called queue implement queues module queue 
export add fetch 
add item lists append item 
fetch ok fetch empty 
implements queue list unfortunately user know queue represented list 
typical program contain code fragment don queue queue add joe queue queue add mike queue 
bad user needs know queue represented list implementer change internal representation queue want provide better version module 
better module queue 
export new add fetch 
new 
add item lists append item 
fetch ok fetch empty 
write queue new queue queue add joe queue queue add mike queue 
better corrects problem 
suppose user needs know length queue tempted write len length queue don know queue represented list 
bad programming practice leads code diecult maintain understand 
need know length queue length function added module appendix programming rules conventions module queue 
export new add fetch len 
new 
add item lists append item 
fetch ok fetch empty 
len length 
user call queue len queue 
say abstracted details queue queue fact called data type 
go trouble 
practice abstracting internal details implementation allows change implementation changing code modules call functions module changed 
example better implementation queue follows module queue 
export new add fetch len 
new 
add item faster addition elements item 
fetch ok fetch empty fetch perform heavy computation 
fetch lists reverse 
len length length 
code deterministic possible deterministic program run manner matter times program run 
non deterministic program may deliver dicerent results time run 
debugging purposes idea things deterministic possible 
helps errors reproducible 
example suppose process start parallel processes check started correctly suppose order started matter 
choose start parallel check started correctly better start time check started correctly starting 
program defensive program programmer trust input data part system programming 
general test input data functions correctness 
code system written assumption input data function question correct 
small part code appendix programming rules conventions perform checking data 
usually done data enters system time data checked enters system assumed correct 
example args option normal get server usage info option pid list pid case option get info pid normal get normal info pid 
function crash option normal 
caller responsible supplying correct input 
isolate hardware interfaces device driver hardware isolated system device drivers 
device drivers implement hardware interfaces hardware appear erlang processes 
hardware look behave normal erlang processes 
hardware appear receive send normal erlang messages respond conventional manner errors occur 
undo things function suppose program opens file closes 
coded file case file open file read ok stream doit stream file close stream correct solution error error 
note open file file open close file close routine 
solution harder follow obvious file closed 
don program file case file open file read ok stream doit stream error error 
doit stream func stream 
func stream 
file close stream don error handling separate error handling normal case code don clutter code normal case code designed handle exceptions 
far possible program normal case 
code normal case fails process report error crash soon possible 
don try fix error continue 
error handled dicerent process 
see process role page 
clean separation error recovery code normal case code greatly simplify system design 
error logs generated sodware hardware error detected stage diagnose correct error 
permanent record kept information helpful process 
appendix programming rules conventions identify error kernel basic elements system design identifying part system correct part system correct 
conventional operating system design kernel system assumed correct user application programs necessarily correct 
user application program fails concern application failure occurred integrity system 
part system design identify part system correct call error kernel 
oden error kernel kind real time memory resident data base stores state hardware 
processes servers messages implement process module code implementing single process contained module 
process call functions library routines code top loop process contained single module 
code top loop process split modules flow control extremely diecult understand 
mean generic server libraries helping structuring control flow 
conversely code kind process implemented single module 
modules containing code dicerent processes extremely diecult understand 
code individual process broken separate module 
processes structuring system processes basic system structuring elements 
don processes message passing function call 
registered processes registered processes registered name module 
easy find code process 
register processes live long time 
assign exactly parallel process true concurrent activity system deciding implement things sequential parallel processes structure implied intrinsic structure problem 
main rule parallel process model truly concurrent activity real world mapping number parallel processes number truly parallel activities real world program easy understand 
process role processes dicerent roles system example clientserver model 
far possible process role client server combine roles 
roles processes supervisor watches processes restarts fail 
worker normal process errors 
trusted worker allowed errors 
generic functions servers protocol handlers possible circumstances idea generic server programs generic server implemented standard libraries 
con appendix programming rules conventions sistent small set generic servers greatly simplify total system structure 
possible protocol handling sodware system 
tag messages messages tagged 
order receive statement important implementation new messages easier 
don program loop state receive 
mod args don apply mod args loop state 
new message get status info option introduce conflict placed mod func args message 
messages synchronous return message tagged new atom describing returned message 
example incoming message tagged get status info returned message tagged status info 
reason choosing dicerent tags debugging easier 
solution loop state receive 
tagged message 
execute mod args apply mod args loop state get status info option status info get status info option state loop state 
flush unknown messages server alternative receive statement 
avoid filling message queues 
example main loop receive msg msg main loop msg msg main loop flushes message queue 
error logger error msg error process got unknown msg self main loop 
write tail recursive servers servers tail recursive server consume memory system runs 
don program loop receive appendix programming rules conventions msg msg loop true error logger log error process got self loop don 
tail recursive io format server going 
correct solution loop receive msg msg loop io format server going error logger log error process got self loop 
tail recursive kind server library example generic automatically avoid doing mistake 
interface functions functions interfaces possible avoid sending messages directly 
encapsulate message passing interface functions 
cases 
message protocol internal information hidden modules 
example interface function module fileserver 
export start open file 
open file filename fileserver open file request filename receive open file response result result 
code 
time outs careful receive statements 
sure handle case message arrives see flush unknown messages page 
trapping exits processes possible trap exit signals 
processes trap exits 
usually bad practice process toggle trapping exits 
various erlang specific conventions records principle data structure records principle data structure 
record tagged tuple introduced erlang version see epk np 
similar struct record pascal 
appendix programming rules conventions record modules definition placed header file hrl included modules 
record module definition record file module defined 
record features erlang ensure cross module consistency data structures interface functions passing data structures modules 
selectors constructors selectors constructors provided record feature managing instances records 
don matching explicitly assumes record tuple 
example demo person name joe age person name name matching 
name person name 

don program demo person name joe age don person name age phone misc tagged return values tagged return values 
don program key key value tail value don return untagged values 
key tail key tail key false 
key value contain false value 
correct solution key key value tail value value correct 
returns tagged value 
key tail key tail key false 
catch throw extreme care catch throw know exactly doing 
catch throw little possible 
catch throw useful program handles complicated unreliable input outside world reliable program may cause errors places deeply code 
example compiler 
process dictionary extreme care get put know exactly doing 
get put little possible 
function uses process dictionary rewritten introducing new argument 
example don program tokenize tokenize don get case get characters device get device eof value chars appendix programming rules conventions tokenize chars 
correct solution tokenize device tokenize device better case get characters device device eof value chars tokenize device chars 
get put cause function behave called input arguments 
code hard read non deterministic 
debugging complicated function get put function input arguments process dictionary 
run time errors erlang example bad match include arguments function process dictionary 
don import don import code harder read directly see module function defined 
cross tool find module dependencies 
exporting functions distinction function exported 
function exported reasons example user interface module 
interface function modules 
called apply spawn module 
dicerent export groupings comment accordingly 
example user interface export help start info 
intermodule exports export pid pid 
export process print info 
exports module export init info log impl 
specific lexical stylistic conventions don write deeply nested code nested code code containing case receive statements case receive statements 
bad programming style write deeply nested code code tendency page right soon unreadable 
try limit code maximum levels indentation 
achieved dividing code shorter functions 
don write large modules module contain lines source code 
better small modules large 
appendix programming rules conventions don write long functions don write functions lines code 
split large functions smaller ones 
don solve problem writing long lines 
don write long lines don write long lines 
line characters 
example fit page 
erlang string constants automatically concatenated 
example io format name age phone dictionary name age phone dict variable names choose meaningful variable names diecult 
variable name consists words capitalized letter separate 
example variable 
avoid don care variable variables 
example name 
stage need value variable just remove leading underscore 
problem finding underscore replace code easier read 
function names function name agree exactly function 
return kind arguments implied function name 
surprise reader 
conventional names conventional functions start init main loop 
functions dicerent modules solve problem name 
example module module info 
bad function names common programming errors choice names diecult 
kind naming convention useful writing lots dicerent functions 
example name prefix signify function question returns atom true false 
true false check ok 
error 
module names erlang flat module structure modules modules 
oden simulate hierarchical module structure 
done sets related modules having module prefix 
example isdn handler implemented dicerent related modules 
module names isdn init isdn isdn 
format programs consistent manner consistent programming style help people understand code 
dicerent people dicerent styles concerning indentation usage spaces example write tuples single comma elements people comma followed blank adopted style stick 
larger project style parts 
appendix programming rules conventions documenting code attribute code correctly attribute code module header 
say ideas contributing module came code derived code say got code wrote 
steal code stealing code code module editing forgetting say wrote original 
examples useful attributes revision revision 
created date 
created erlang 
modified date 
modified erlang 
provide code specifications provide cross code documents relevant understanding code 
example code implements communication protocol hardware interface give exact document page number documents write code 
document errors errors listed english description mean separate document see error messages page 
errors mean errors detected system 
point program detect logical error call error logger error logger error msg format descriptor arg sure line descriptor arg 
added error message documents 
document principle data structures messages tagged tuples principle data structure sending messages dicerent parts system 
record features erlang introduced erlang versions ensure cross module consistency data structures 
english description data structure documented see message descriptions page 
comments comments clear concise avoid unnecessary 
sure comments kept date code 
check comments add understanding code 
comments written english 
comments module indented start percent characters see file header description page 
comments function indented start percent characters see comment function page 
comments erlang code start percent character 
line contains comment indented erlang code 
kind comment placed statement refers 
comment placed line statement preferred 
comment function useful functions functions comment line comment complicated level indentation complicated 
appendix programming rules conventions comment function important things document purpose function 
domain valid inputs function 
data structures arguments functions meaning 
domain output function 
possible data structures return value meaning 
function implements complicated algorithm describe 
possible causes failure exit signals may generated exit throw non obvious run time errors 
note failure returning error 
side function 
example function get server statistics purpose get various information process 
args option normal 
returns list key value error reason process dead get server statistics option pid pid pid 
data structures record defined plain text description 
example file data structures data type person name string default undefined 
age integer default undefined 
phone list integers default 
dict dictionary containing various information person 
key value list default empty list 
record person name age phone dict 
file headers copyright file source code start copyright information example copyright ericsson telecom ab rights reserved 
part computer programs may reproduced stored retrieval system transmitted form means electronic mechanical photocopying recording prior written permission ericsson telecom ab 
file headers revision history file source code documented revision history shows working files done 
revision history rev pa date author fred initial pre release 
functions adding deleting incomplete rev date author johanna johansson added functions adding deleting changed data structures allow needs baz signalling system file header description file start short description module contained file brief description exported functions 
description module foobar data manipulation basic elements baz signalling system 
functions manipulating data exports create foobar parent type returns new foobar object appendix programming rules conventions know weakness bugs badly tested features note special comment don try hide 
part module incomplete add special comment 
add comments help maintainers module 
product module writing success may changed improved years time may meet 
comment old code remove add comment revision history 
remember source code control system help 
source code control system non trivial projects source code control system rcs cvs clearcase keep track modules 
common mistakes writing functions span pages see don write long functions page 
writing functions deeply nested ifs receives cases see don write deeply nested code page 
writing badly typed functions see tagged return values page 
function names reflect functions see function names page 
variable names meaningless see variable names page 
processes needed see assign exactly parallel process true concurrent activity system page 
badly chosen data structures bad representations 
bad comments comments document arguments return value 
code 
put get see process dictionary extreme care page 
control message queues see flush unknown messages page time outs page 
required documents section describes system level documents necessary designing maintaining system programmed erlang 
module descriptions chapter module 
contains description module exported functions follows meaning data structures arguments functions meaning data structure return value purpose function possible causes failure exit signals may generated explicit calls exit 
format document defined appendix programming rules conventions message descriptions format inter process messages defined inside module 
format document defined process description registered servers system interface purpose 
description dynamic processes interfaces 
format document defined error messages description error messages format document defined ubf getting erlang talk outside world 
joe armstrong may erlang talk outside world 
question interesting want build distributed applications erlang number communicating components 
assume components interact exchanging messages level abstraction details programming language operating system host architecture irrelevant 
important ease construct systems precision isolate faulty components system 
importance terms cpu bandwidth requirements send receive messages system 
widely adopted solution problem involves xml family standards xml xml schemas soap wsdl argue reformatted slightly revised version acm sigplan erlang workshop pittsburg pa usa 
appendix ubf black boxes contract checkers overly complex propose basing system simpler binary scheme called ubf universal binary format 
ubf scheme expressive power xml set standards considerably simpler 
ubf prototyped erlang entire scheme equivalent semantic power xml series standards implemented mere lines erlang 
ubf encoding terms shown space existing erlang term format 
example ubf encoded parse trees erlang programs average size equivalent ets format encoding open source erlang distribution 
categories subject descriptors computer communications network protocols sodware programming techniques sodware programming languages interested building reliable distributed systems asynchronously communicating components 
assume components written dicerent programming languages run dicerent operating systems operate network 
example components may written erlang java components run unix windows solaris 
ask questions systems interact create convenient language neutral transport layer allow applications easily constructed suppose dicerent components collaborate solve problem individual component tested assumed system 
component error 
number conventional methods solving parts problem example interface description language sun xdr asn complex framework corba 
methods associated problems methods supposedly language neutral practice heavily biased languages bit word length processor architectures 
complex frameworks corba diecult implement inappropriate simple applications 
proprietary solutions component interaction com dcom considered complex available platforms 
mess single universal panacea emerged xml 
xml series standards notably xml xml schemas soap wsdl emerged universal solution problem 
xml solution involves layers transport layer xml provides simple transport layer 
xml encoded terms encode complex structured objects 
type system xml schemas provides type schema describing type content particular xml tag 
protocol description language soap defines simple remote procedure calls encoded xml terms 
complex interactions components described web service description language wsdl 
architectural layering desirable separates transport data xml types data xml schemas appendix ubf semantics interactions dicerent components network soap 
unfortunately architecture essentially correct details leave desired 
individual components number significant problems 
argue section xml overly complex overly verbose 
section propose simpler equally expressive binary format complement xml 
proposed schema implemented fully erlang partially java preliminary results final section 
type system expressive power similar expressive power xml schemas believe scheme simpler 
contract language similarities wsdl believe simpler expressive 
architecture similarities net architecture believe architecture simpler powerful 
remainder describes system detail gives performance figures describes initial experience system 
problems xml complexity xml xml schemas soap complex set inter related standards 
full implementation standards requires tens thousands lines code implementation number minor standards xml name spaces xml path xml standard grammar productions requires pages explanatory text entire text books written just explain simple standard 
having implemented xml parsers erlang am position say xml decidedly simple implement amazingly complexity occurs implementation number features vast majority programmers hang backs sgml 
original design xml notion structure described regular grammar notion type 
structure described dtds data type descriptions dtd xml syntax 
viewed disadvantage came rescue xml schemas xml structures described xml rich set types added 
described xml dtd element root xml schemas element name root complextype content choice element ref sequence element ref element ref sequence choice complextype element notation saying content tag particular type equally verbose 
xml schemas built primitive types type constructors net result want express types xml schemas 
unfortunately verbosity specification schemas diecult read 
retrospect simpler alternative extend xml small number primitive data types 
example xml construct element xxx pcdata appendix ubf easy extend expressions element xxx integer meaning xxx bit integer 
extension provided succinct readable alternative xml schemas 
verbosity xml encodings incredibly verbose 
designers xml excuse words xml markup minimal importance unfortunately verbosity xml parsing impossible parser examine single input character 
property limits usefulness xml transport format mobile devices limited bandwidth 
interestingly common xml applications designed devices wap uses ad hoc method compress xml wap programs providing striking evidence raw xml inappropriate universal format low bandwidth devices 
strange property xml binary data encoded prior transmission 
example jpeg image base encoded 
base encoding processes data bit groups replacing byte sequence input byte sequence output lines limited characters printable characters transmitted 
strange highly especially considering soap uses tcp ip data transport tcp ip designed transport binary data bit characters probably cards restriction printable characters transmission systems may pass bits byte transparent manner 
unfortunately weird quoting rules sgml apply xml naively think binary data transmitted unfortunately just quote binary data xml binary data just happened contain valid xml tag chaos ensue 
client server client server contract checker programming languages quoting conventions allow arbitrary sequence characters quoted xml example data placed cdata block data containing string fact severely limits usefulness cdata section making impossible say quote arbitrary xml program contain cdata section 
wonders convention adopted 

architecture architecture shown figures 
shows number communicating components 
components assumed black boxes particular time component behave client server 
components place entity call contract checker shown diagram black blob contact checker checks legality flow messages components 
assume contract checker starts state see client sends message intended server contract checker checks correct type expected state sent server 
server responds message state tuple contract checker checks message expected response current state sent client appendix ubf state contract checker updated 
contract checker parameterised contract specifies ordering types allowed message sequences client server 
contract written simple non deterministic finite state machine simple type language 
contract modeled set tuples form sin tin tout sout means server state sin receives message type tin may possibly respond message type tout change state sout 
contract checker assumes start state server start assigned state variable client sends server message contract checker checks rules contract sin typeof tin rules client said follow contract message safely sent server 
rules match client said broken contract client server informed 
client sent valid message set expected output responses server pruned set tuples tout sout allowed set type state tuples server respond 
server respond msg state tuple contract manager checks tuple response set state sout typeof msg tout 
tuple response accepted msg sent back client global value state updated state 
note convention rpc mechanism server responds message response particular query state server implied protocol 
note contract checker operates transparently normal operation 
case client server follow contract changes messages passed client server possible client server interaction contract checker contract checker slight timing 

ubf universal binary format contracts written language call ubf components ubf data transport format roughly equivalent wellformed xml 
ubf programming language describing types ubf protocols clients servers 
ubf roughly equivalent verified xml xml schemas soap 
xml series languages goal having human readable format ubf languages take opposite view provide machine friendly format 
ubf designed easy implement 
proof concept ubf drivers erlang oz java tcl author web site 
implementors welcome add new languages 
ubf designed language neutral ubf defines language neutral binary format transporting data network 
ubf type system describing client server interactions ubf 

ubf binary transport format ubf transport format designed easy parse easy manipulate text editor 
ubf byte encoded virtual machine byte codes reserved 
allocating byte codes printable character codes format easy read edit 
appendix ubf simplicity goal define minimal set primitive types compared xml schemas types glue building complex types simple types 
primitive types ubf primitive types 
primitive tag recognized pushed recognition stack decoder 
primitive types integers integers written sequences bytes described regular expression 
optional minus denote negative integer followed sequence digits 
restrictions precision integer precision issues dealt ubf 
strings strings written enclosed double quotes 
string quoting conventions observed written written allowed write double quote string 
binary data binary data encoded int integer representing length binary data encoded followed tilde data exactly length integer closing tilde 
closing tilde significance retained readability 
white space added integer length data readability 
constants constants encoded strings single quote double quote 
constants commonly symbolic languages lisp prolog erlang 
represented hashed strings 
essential property constant constants compared equality constant time 
addition item followed semantic tag written 
tag meaning ubf meaning ubf 
example jpg represents bytes raw data semantic tag jpg ubf know jpg means passed ubf know means application expected know object type jpg example know represents image 
ubf just encode tag ubf type check tag application able understand tag 
compound types having defined simple types define type glue making compound objects 
structs structures written obj obj 
obj arbitrary ubf objects byte codes delimit structure 
decoder encoder map ubf objects appropriate representation application programming language example structs arrays java tuples erlang 
structs represent fixed numbers objects lists lists represent variable numbers objects 
written syntax appendix ubf 
obj obj represents list objects object list obj second obj note objects reverse order 
lisp programmers recognize operator pushes nil list recognition stack operator takes top items recognition stack replaces list cell 
need know object finished 
operator signifies object 
encountered item recognition stack 
white space convenience blank carriage return line feed tab comma treated white space 
comments included ubf syntax usual quoting convention applies 
caching optimizations far exactly control characters leaves unallocated byte codes 
follows byte code sequence reserved byte codes means store top recognition stack register reg pop recognition stack 
subsequent reuse single character means push reg recognition stack client java ubf driver contract checker ubf contract ubf driver server erlang java ubf ubf erlang terms objects objects objects client server dicerent languages contract checker 

programming contract central ubf idea contract 
contract regulates set legal conversations take place client server 
sodware component contract checker placed client server checks interactions client server legal 
contract written types contract says formal language am state send message type reply message type move state reply message type move state contract checker dynamically checks sides involved transaction obey contract 
contracts expressing language call ubf 
ubf type system describing types ubf objects 
protocol description language describing client server interaction terms non deterministic finite state machine 
lalr grammar ubf appendix appendix ubf type system type system describe type encoded objects simplified version type system describe erlang terms 
notation int means ubf integer 
string means ubf string 
constant means ubf constant 
bin means ubf binary data item 
means object type ubf literals written follows 
denotes ubf string 
za denotes ubf constant 
denotes ubf integer 
complex types defined recursively tn tuple type 
tn types 
say xn type tn type type xn type tn 
list type type 
say xn xn 
type xi type alternation type types 
say type type type 
new types new types introduced ubf notation types type type 
type type simple types literal types complex types 
examples types types person person firstname lastname sex age firstname string lastname string age int sex male female people person 
type schema defines number dicerent types 
example easily seen person jim smith male susan jones female type people 
note xml ubf encoded terms contain tag information 
clearer suppose xml data structure represent information people person appendix ubf firstname jim firstname lastname smith lastname sex male sex age age person person firstname susan firstname lastname jones lastname sex female sex age age person people xml data structure contains large number redundant tags representation omits tags sizes representation bytes second ignoring white space redundant expect parsing ubf expression times fast parsing xml expression 
note ubf type language independent type schema 
defines types messages ader encoding universally applicable programming language produces ubf encoded data 
language independent type schemas basis contracts clients servers 
contract language start simple example name file server 
vsn ubf 
types info info description description services services contract contract file string ls ls files files file getfile get file 
state start ls files start getfile binary start 
info string description string contract term 
program starts sequence type definitions follow types keyword define types message visible interface component 
example see type getfile defined get file file type string 
definition easily seen ubf sequence characters get image jpg belongs type 
reading state part program see rule state start ls files start getfile bin start 
english rule means system state start receives message type ls respond message type files appendix ubf move start state message type getfile received respond message type bin move state start respond message type move state 
continue example requested file named image jpg valid responses type bin corresponds ubf encoded sequences nnn 

note possible component distinguish dicerent state transitions basis response 
consider fragment contract types running string error string 
state running request ok running error stopping 
knew component state running sent message type request expect respond types ok error unfortunately types indistinguishable represented strings ubf 
reason require server responds state message pair just message 
server explicitly reveals state contract checker 

implementation details entire ubf system prototyped erlang 
entire system lines commented erlang code 
ubf encoding decoding lines 
contract parsing lines 
contract checker type checker lines 
run time infrastructure support libraries lines 
compares favourably complexity xml implementation 
example incomplete implementation xml wrote years ago lines erlang code 
compared lines code ubf implementation 

performance far system implemented entirely erlang thought embedding ubf encoding decoding sodware type checking sodware erlang run time system 
measure performance give concerns packing density ubf encoded erlang terms 
simple check compared size encoding parse tree number erlang modules size binary produced evaluating expression size term binary epp parse file algorithm serialize term representing parse tree simple pass optimizer cached frequently constants occurred program 
sample files observed average ubf encoded data size corresponding data encoded erlang external term format 
applications bandwidth expensive communication relatively slow example communication mobile devices gprs reduction data volume considerable benefit 

system contracts uses simple type system 
easy envisage extensions allow complex types extensions describe non functional properties system 
appendix ubf non functional properties system particular interest 
example add simple timing constraints allowing rules state time time meaning component state receives message type respond message type change state time respond message type change state state ader time time 
stricter contracts timing constraints useful designing real time systems interacting components 
extensions imagined allow define contracts subroutines contract sub contract perform specific task 

running system system essentially exchanges characters telnet observe session test behaviour system 
example commands issued telnet session client talking directly file server specified file server contract info am mini file server start recall system starts state start contract says info command sent state 
response string new state case start state changed rule 
application returns tuple containing descriptive string new state 
converted application driver ubf tuple am 
start 
ls files ubf erl client erl makefile 
start client sends message type ls server responds tuple files start message 
element tuple type files 
ask system describe contract contract name file server info am mini file server description commands ls list files get file length 
services states start input tuple prim file constant get output constant output prim binary start input constant ls output tuple appendix ubf list prim string constant files start types file prim string system responds message type info parse tree representing contract 
contract generic type term describe contract 
contract typed term ubf discussion abstracted form contract relevant 
example illustrate introspective power system 
run system ask system describe 
believe desirable property distributed component system communicating components 

larger contract previous examples showed basic syntax contract 
finish complex example 
contract describes irc protocol 
name irc 
vsn ubf 
types info info description description contract contract bool true false nick string string string group string logon logon proceed ok nick groups groups group join group leave group ok ok nick nick send message group msg msg group string msg nick group string joins nick group leaves nick group group 
am assigned initial random nick state start logon proceed active 
state active groups active ok active ok active bool active false group msg bool active event message group event nick joins group event nick leaves group event 
nick changes name appendix ubf info string description string contract term 
example introduces new keyword event 
syntax state 
event means server spontaneously send message type client 
normally messages sent client response requests event asynchronous single messages server client 
server sure client received message change state server allowed 

experience initial version ubf completed weeks intensive programming system design changed times re designed implemented re implemented times 
basic infrastructure running simple interface oz implemented interface java 
oz java implementation concerned ubf contract language checker 
non toy application irc implemented test system non trivial example 
started writing contract erlang client server followed contract 
interestingly contract checker proved extremely helpful developing irc system oden develop systems writing client server time frame attention client server necessary 
contract checker proved helpful rapidly identifying components error event error 
intermediate communication fairly readable ascii subset able test server typing simple text queries telnet session way able immediately test server interaction client server telnet erlang code stages partially complete 
interestingly contract checker oden complained contract violations believe erroneously assumed code checking contracts incorrect 
invariably contract checker right wrong 
think tendency believe expected see contract checker biases 
concentration contact caused interesting psychological perspective forced think system metalevel terms considering client server stupid black boxes told 
trying write contracts clear manner exercise resulted clearer understanding problem forcing think terms messages sent client server 
contract proved valuable easy understand specification problem 
having implemented erlang client server graphic erlang client decided add java client 
java client developed independently luke ubf specification irc contract 
came testing contract checker provide extremely precise error diagnostics form state expected send message type sent message wrong 
armed precise diagnostics easy debug java program 
needless say java client talked erlang server system worked time 
testing java client erlang server done independently modified form contract checker contract concerned 
appendix ubf having developed system high degree confidence correctness fail ll immediately know component broken 

acknowledgments seif haridi brand thomas arts luke helpful discussions particular go luke implementing java client 
appendix ubf grammar form name string dot 
form vsn string dot 
form types types dot 
form state atom transitions dot 
form dot 
types typedef types 
types typedef 
typedef atom type annotation 
annotation string 
annotation empty 
type type 
type 
int 
string 
constant 
bin 
atom 

type 
atom 
integer 
integer integer 
string 
type 
type 
typeref atom 
transitions transition transitions 
transitions transition 
transition typeref outputs 
transition event typeref 
outputs outputs 
outputs 
typeref atom 


typeref typeref 
strings string strings 
strings string 
strings empty 
appendix ubf intention write new typesetting system order typeset thesis started described 
having read knuth digital typography realised producing high quality type setting system delay thesis years estimate years decided latex 
turns little tweaking persuaded produce readable text 
thesis produced pt reduced fit 
drop capitals chapter numbers set old english computer programs shell dialogs code text set computer modern 
john english type designer printer 
started printing business delayed 
fournier benjamin franklin 
chose typeface heavily weighted suited documents produced low quality laser printer photocopying 
text delicate lightly weighted tends fade printed poor quality printer poor quality 
fading reduces legibility text 
lines 
appendix tried micro typographic extensions developed th th nh doctoral thesis reintroduced original practice gutenberg line bible allowing punctuation lines slightly right hand margin 
practice improves optical alignment led hand margin produces better line breaks 
unfortunately abandoned approach sodware margin correctly multiple line 
reason motivated 
small army people read commented thesis 
wife helen proof read entire thesis embarrassing number small mistakes text 
peter van roy ulf spelling mistakes helen missed richard keefe formatting errors everybody missed 
bibliography ahlberg john anders 
prototyping cordless declarative programming 
xiv international switching symposium october 
leon ann tai 
long life deep space applications 
ieee computer april 
marie 
ps 
ny august 
gregory andrews fred schneider 
concepts notations concurrent programming 
acm computing surveys 
armstrong williams virding 
concurrent programming erlang 
prentice hall englewood 
armstrong 
ubf universal binary format www sics se joe ubf 

armstrong 


www sics se joe html 
armstrong arts 
practical type system erlang 
erlang user conference 
armstrong cker virding williams 
implementing functional language highly parallel real time applications 
sodware engineering telecommunication switching systems april 
armstrong virding williams 
prolog developing new programming language 
moss appendix bowen editors proc 
st conf 
practical application prolog london england 
association logic programming 
joe armstrong 
increasing reliability email services 
proceedings acm symposium applied computing pages 
acm press 
joe armstrong 
concurrency oriented programming 
lightweight languages workshop ll november 
joe armstrong 
getting erlang talk outside world 
proceedings acm sigplan workshop erlang pages 
acm press 
joe armstrong 
concurrency oriented programming erlang 
march 
joe armstrong 
webserver daemon 

available www sics se joe tutorials web server web server html 

design fault tolerant computers 
proceedings fall joint computer conference 
afips conf 
proc vol 
thompson books washington pp 
pages 
jonas 
erlang specification 

available www com rv 
blau jan rooth 
axd new generation atm switching 
ericsson review 
grady booch james rumbaugh ivar jacobson 
unified modeling language user guide 
addison wesley longman publishing 
bray paoli sperberg mcqueen maler eds 
extensible markup language xml second edition 
october www org tr rec xml 

bryce 
approach safe object sharing 
proceedings conference object oriented programming systems languages applications pages 
acm press 
george candea armando fox 
crash sodware 
proceedings th workshop hot topics operating systems ix may 
richard carlsson thomas lindgren bj rn gustavsson sven nystr robert virding erik johansson mikael pettersson 
core erlang 
november 
case 
simple network management protocol snmp 
rfc internet engineering task force may 
christensen curbera meredith weerawarana 
web services description language wsdl march www org tr note wsdl 

dan connolly bert bos koike mary 
www org schema hack 

crispin 
internet message access protocol version 
rfc internet engineering task force december 
grzegorz czajkowski laurent multitasking virtual machine evolution 
proceedings oopsla conference object oriented programming systems languages applications pages 
acm press 
bjarne cker 
de aren 
march 
bjarne cker 
concurrent functional programming telecommunications case study technology 
november 
licentiate thesis 
appendix dahlin 
eddie robust scalable internet server 
may 
fallside ed 
xml schema part primer 
may 
www org tr rec xmlschema 

dick eriksson mats persson kerstin 
switching sodware architecture prototype real time declarative language 
xiv international switching symposium october 
open source erlang distribution 

feldman low 
programming distributed systems 
proceedings acm computer science conference pages 
fielding gettys mogul frystyk masinter leach berners lee 
hypertext transfer protocol 
rfc internet society june 
see www ietf org rfc rfc txt 
ian foster stephen taylor 
strand new concepts parallel programming 
prentice hall 
jim gray 
computers done 
technical report tandem computers 
hadley 
moreau nielsen 
soap version part messaging framework december www org tr wd soap part 

hadley 
moreau nielsen 
soap version part adjuncts december www org tr part 

hausman 
turbo erlang 
international logic programming symposium october 
hausman 
turbo erlang approaching speed evan tick giancarlo editors implementations logic programming systems pages 
kluwer academic publishers 
american national standards institute institute electrical electronic engineers 
ieee standard binary floating point arithmetic 
ansi ieee standard std new york 
iso iec 
osi networking system aspects syntax notation asn 
itu rec 
iso iec iso iec 
itu 
recommendation specification description language sdl 
itu international telecommunication union 
reed 
rfc internet relay chat protocol 
may 
erik johansson sven nystr mikael pettersson sagonas 
hipe high performance erlang 
richard kuhn 
sources failure public switched telephone network 
ieee computer 
simon marlow philip wadler 
practical subtyping system erlang 
international conference functional programming pages 
acm june 
martin eds 
wap binary xml content format june www org tr 


private communication 

myers rose 
post protocol version 
rfc internet engineering task force may 
nortel networks 
alteon ssl accelerator product brief 
september 
appendix ed mitra 
soap version part primer 
december www org tr wd soap part 

hans olsson 
ericsson ner 
december 
omg 
common object request broker architecture corba manual 
object management group needham 
postel 
simple mail transfer protocol 
rfc internet engineering task force august 

error handling business information systems 

richard schlichting fred schneider 
fail processors approach designing fault tolerant computing systems 
computer systems 
fred schneider 
byzantine generals action implementing fail processors 
acm transactions computer systems tocs 
fred schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys 
srinivasan 
rfc xdr external data representation standard 
august 
ann tai kam tso leon chau william sanders 
message driven confidence driven protocol guarded sodware upgrading 
performance evaluation 
th th nh 
micro typographic extensions tex typesetting system 
university brno 
thompson beech maloney mendelsohn eds 
xml schema part structures 
recommendation may 
www org tr rec xmlschema 


open telecom platform 
ericsson review 
voas 
fault tolerance 
ieee sodware pages july august 
david warren 
prolog instruction set 
note sri international menlo park california october 
ulf 
private communication 
ulf sta ask kent 
world class product certification erlang 
proceedings acm sigplan workshop erlang pages 
acm press 
yu 
sodware fault prevention approach coding root cause analysis 
bell labs technical journal 
