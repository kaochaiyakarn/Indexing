composable cryptographic library nested operations extended michael backes ibm research division switzerland mbc zurich ibm com idealized cryptographic library dolev yao model automated proofs cryptographic protocols nested cryptographic operations coming cryptographic implementation provably secure active attacks 
categories subject descriptors data data encryption theory computation computation devices modes computation general terms security theory verification keywords cryptography simulatability security analysis protocols cryptographically composable operators 
practically relevant cryptographic protocols ssl tls mime ipsec set cryptographic primitives signature schemes encryption black box way adding non cryptographic features 
vulnerabilities accompanied design protocols early authentication protocols needham schroeder carefully designed de facto standards ssl pkcs current widely deployed products microsoft passport 
proving security protocols unsatisfactory task long time 
possibility take cryptographic approach 
means reduction proofs security system security cryptographic primitives shows break system break underlying cryptographic primitives respect cryptographic definitions adaptive chosen message security permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
ccs october washington dc usa 
copyright acm 
birgit pfitzmann ibm research division switzerland bpf zurich ibm com michael waidner ibm research division switzerland wmi zurich ibm com signature schemes 
authentication protocols approach 
principle proofs approach rigorous typical proofs mathematics 
practice human beings extremely fallible type proofs 
due cryptography distributed systems aspects protocols 
known non cryptographic distributed systems wrong protocols published small problems 
hand proofs highly error prone different cases actions different machines interleave extremely tedious 
humans tend take wrong shortcuts want proof read details proofs 
protocol contains cryptography obstacle worse rigorous definition goals gets complicated trace properties integrity proven secrecy 
principle reduction carried cases trivial rigorously 
consequence real cryptographic proof larger protocol times supposedly proven relatively small systems broken 
possibility formal methods 
leaves tedious parts proofs machines model checkers automatic theorem provers 
means code cryptographic protocols language tools may need start depending tool supports distributed systems interaction models encoded 
tools currently able deal reduction proofs 
thought long time felt protocol proofs simpler idealized abstractions cryptographic primitives 
abstractions variants dolev yao model represents cryptographic primitives operators term algebra cancellation rules 
instance publickey encryption represented operators encryption decryption cancellation rule encrypting message twice model yield message basic message space term 
model assumes terms equality derived cancellation rules equal term derived completely secret 
originally foundation assumptions real cryptographic primitives guarantee protocols proved tools secure implemented real cryptography 
previously proved protocol broken implemented standard provably secure cryptosystems clearly unsatisfactory situation artificial counterexamples constructed 
years ago efforts started get best worlds 
essentially started define general cryptographic models support idealization secure arbitrary environments arbitrary active attacks started justify dolev yao model far model 
directions significantly extended subsequent papers particular :10.1.1.29.1076
offers provably secure variant dolev yao model proofs people typically dolev yao model time cover active attacks nested cryptographic operations 
new property combination essential cryptographic protocols broken active attacks man middle attacks attacks adversary reuses message protocol step different protocol step suddenly gets different semantics 
attacks covered :10.1.1.29.1076
secondly main dolev yao model represent nested protocol messages sign denotes arbitrary message nonces 
previous idealization proved reactive cryptographic models contains abstractions cryptographic primitives mainly encryption signatures nonces list operation nested terms 
existing abstractions high level secure channels combine encryption signatures fixed way 
need immediate interaction adversary adversary learns structure term honest party builds signed message 
abstraction usable term may want show secret outer encryption abstraction gives adversary 
similar immediate application model primitives avoid problem keep signatures ciphertexts system nesting possible 
exist semi abstractions depend cryptographic details 
suitable protocol representations proof tools semi abstraction public key encryption submodule 
decision design ideal library supports nesting general active attacks represent idealized cryptographic term corresponding real message way higher protocol 
necessary reactive cryptographic models composition theorems 
handles 
ideal system handles essentially point dolev yao terms real system point real cryptographic messages 
model storing terms belonging handles stateful ideal system comprises knowledge knows terms 
ideal cryptographic library corresponds csp dolev yao model strand space dolev yao model pure algebraic dolev yao model 
idea handles consider put exact dolev yao terms wants deviate order allow provably secure cryptographic realization general class underlying primitives 
overview deviations section section surveys cryptographic primitives augmented give secure implementation ideal library 
vast majority credible proof real cryptographic library securely implements ideal 
hand proof cryptographic primitives distributed systems aspects problems mentioned cryptographic proofs large protocols 
needed novel proof technique consisting probabilistic imperfect bisimulation embedded static information flow analysis followed cryptographic reductions proofs called error sets traces bisimulation 
proof needs intended justification basing protocol proofs ideal cryptographic library proving higher assurance automatic tools carefully worked tedious details encourage readers double check page full version 
experience making proof errors making strongly discourage reader accepting idealizations cryptographic primitives similar security property simulatability claimed step proof definition simulator 
related literature cryptographic approach proving cryptographic systems started early 
early examples cryptographic definitions reduction proofs 
applied protocols techniques best relatively small protocols certain interaction cryptographic primitives 
early methods automating proofs dolev yao model summarized 
concentrated existing general purpose model checkers theorem provers treating larger protocols 
intended bridge gap cryptographic approach automated tools started independently 
dolev yao terms nested operations considered specifically symmetric encryption 
adversary restricted passive eavesdropping 
consequently necessary define reactive model system honest users adversary security goals formulated indistinguishability terms 
extended terms general programs restriction passive adversaries remains realistic practical applications 
theorems composition property preservation real system 
papers extended specific models specific properties 
instance specifically considers strand spaces information theoretically secure authentication 
deduction system information flow operations passive attacks 
approach starts general reactive system model general definition cryptographically secure implementation simulatability composition theorem notion secure implementation 
definitions secure function evaluation computation set outputs set inputs earlier extensions reactive systems real abstraction quite special cases 
approach extended synchronous asynchronous systems 
reactive works come worked examples abstractions cryptographic systems proofs abstraction theorem prover pvs 
composition theorem automatically give cryptographic library dolev yao sense possibility nest operations explained 
cryptographic library overcomes problems 
supports nested operations intuitive sense operations performed locally visible adversary 
secure arbitrary active attacks works context arbitrary surrounding interactive protocols 
holds independently goals wants prove surrounding protocols particular property preservation theorems simulatability definition proved integrity liveness non interference 
exemplified usefulness cryptographic library conducting cryptographically sound security proof known needham schroeder lowe protocol 
proof relies idealizations cryptography advantages explained text particular proof suited formal proof tools 
simultaneously independently cryptographically sound security proof protocol invented 
proof done scratch cryptographic setting vulnerable problems mentioned 
fair mention proof establishes security property matching conversations proof currently strives weaker authentication requirement 
overview ideal cryptographic library ideal cryptographic library offers users cryptographic operations commands encrypt decrypt message test signature generate nonce 
commands simple deterministic semantics 
reactive scenario semantics state knows terms 
store state database 
entry type signature pointers arguments key message 
corresponds top level dolev yao term entire term pointers 
entry contains handles participants know 
database index handles serve infinite efficiently constructible supply global local names cryptographic objects 
libraries export operations leave message transport users 
actual implementation simulatable library internally structured higher protocols automatically secure export function special send operations 
ideal cryptographic library allow cheating 
instance receives command encrypt message certain key simply entry database ciphertext 
entry contains handles participants know 
user ask decryption ciphertext handles ciphertext secret key 
similarly user issues command sign message ideal system looks user secret key 
stores message signed key 
tests simply look ups database 
send operation entry known participants adds handles entry 
recall ideal library entire reactive system contains network model 
offer types send commands corresponding channel types meaning secure authentic private insecure 
types extended 
currently library contains public key encryption signatures nonces lists application data 
added symmetric authentication unpublished 
main differences ideal cryptographic library standard dolev yao model 
exist prior extensions dolev yao model 
signature schemes inverses encryption schemes 
secure encryption schemes necessarily probabilistic secure signature schemes 
message signed encrypted times distinguish versions making different database entries 
secure signature schemes memory 
standard definition exclude signature entire history messages signed 
restrict definition allow signature divulge number previously signed messages include efficient provably secure schemes classical assumptions hardness factoring 
easily allow participants send secret keys network simulation possible 
fortunately public key cryptosystems needed typical protocols 
encryption schemes keep length arbitrary entirely secret 
typically see length quite precisely message expansion minimized 
allow ideal system 
fixed length version easy addition library implemented top library padding fixed length 
adversaries may include incorrect messages encrypted parts message current recipient decrypt may possibly forward recipient notice incorrect format 
allow certain garbage terms ideal system 
overview real cryptographic library real cryptographic library offers users commands ideal honest users operate cryptographic objects handles 
quite close standard apis existing implementations cryptographic libraries include key storage 
database real system contains real cryptographic keys ciphertexts commands implemented real cryptographic algorithms 
sending term insecure channel releases actual bitstring adversary likes 
adversary insert arbitrary bitstrings non authentic channels 
simulatability proof show real adversary achieve achieved adversary ideal system underlying cryptography broken 
base implementation commands arbitrary secure encryption signature systems standard cryptographic definitions 
cryptographic objects operations measures similar robust protocol design 
objects tagged type field signatures acceptable ciphertexts keys 
objects tagged parameters signatures public key 
randomized operations randomized completely 
instance ideal system represents signatures message key different real memory schemes exist lower efficiency stronger assumptions 
add library additional primitive 
primitives committing 
known individual simulation proofs 
explains restricted passive attacks 
system guarantee different small error probabilities 
probabilistic encryptions randomized additionally sufficiently random keys chosen adversary 
reason tag signatures public key needed verify usual definition secure signature scheme exclude signature stealing denote key pair correct participant 
ordinary signatures adversary able compute valid key pair signatures pass test pass test 
correct participant receives encrypted signature accept signed adversary adversary saw easy see result protocols simulated 
modification prevents anomaly 
additional randomization signatures include random string message signed 
alternatively replace counter signature scheme strongly randomized omit ciphertexts randomized including random string message encrypted ciphertext 
outer prevents collisions ciphertexts honest participants inner ensures continued non malleability 

preliminary definitions briefly sketch definitions 
system consists possible structures 
structure consists set connected correct machines subset free ports called specified ports 
machine probabilistic io automaton extended finite state machine slightly refined model allow complexity considerations 
machines turing machine realizations defined complexity measured terms common security parameter initial tape content machine 
readers interested ideal cryptographic library larger protocols need normal deterministic io automata 
standard real cryptographic system structures derived intended structure trust model consisting access structure acc channel model 
acc contains possible sets indices uncorrupted machines intended ones designates channel secure authentic private insecure 
typical ideal system structure contains machine th called trusted host 
structure complemented configuration arbitrary user machine adversary machine connects ports rest may interact 
set configurations system sys called conf sys 
general scheduling model gives connection output port 
input port 
buffer machine corresponding clock port schedule message transition 
real asynchronous cryptographic systems network connections typically scheduled configuration runnable system gets defined probability space runs 
view machine run restriction outputs machine sees internal states 
formally view machine configuration conf family random variables element security parameter value simulatability simulatability cryptographic notion secure implementation 
reactive systems means happen simulatability views indistinguishable 
honest user real system sys real happen ideal system sys id structure sys real polynomial time user polynomial time adversary exists polynomial time adversary corresponding ideal structure sys id view computationally indistinguishable configurations 
illustrated 
indistinguishability known cryptographic notion 
definition 
computational indistinguishability families var random variables common domains dk computationally indistinguishable iff algorithm dis distinguisher probabilistic polynomial time input dis dis var denotes set negligible functions iff positive polynomials 
intuitively security parameter element chosen var dis tries guess distribution element came 
definition 
simulatability systems sys real sys id 
say sys real sys id secure iff polynomial time configuration conf sha conf sys real exists polynomial time configuration conf sha conf sys id 
cryptographic library show blackbox simulatability consists simulator sim depends uses blackbox 
essential feature definition simulatability composition theorem essentially says design prove larger system ideal system sys id securely replace sys id real system sys real 
notation write deterministic probabilistic assignment uniform random choice set 
integer variables mean length message denoted error element available addition domains ranges functions algorithms 
list operation denoted 
xj arguments unambiguously retrievable database set functions called entries finite domain called attributes 
entry value attribute att written att 
predicate pred involving attributes pred means subset entries attributes fulfill pred 
pred contains element notation element 
adding entry abbreviated 
ideal cryptographic library ideal cryptographic library consists trusted host th subset set 
users 
port 
inputs port 
outputs user denoting adversary 
mentioned section assume encryption systems hide length message 
furthermore higher protocols may need know length certain terms honest participants 
trusted host parameterized certain length functions denoting length corresponding value real system 
tuple functions contained system parameter simulatability polynomial time real system ideal cryptographic library polynomial time 
contains explicit bounds message lengths number signatures key number accepted inputs port 
contained system parameter underlying io automata model guarantees machine enforce bounds additional turing steps adversary tries send data 
details refer full version 
states main data structure th database entries representations data produced system run information knows data 
entry form ind type arg hndu 
len 
um ind called index write ind 
type typeset data list nonce ske pke enc sks pks sig garbage identifies type extensions library extend set 
arg 
aj possibly empty list arguments 
hndu identifies knows entry 
value represents adversary hndu indicates know entry 
value hndu called handle entry superscript hnd handles usually denote handle entry hnd len denotes length entry 
computed th length functions system parameter initially empty 
th keeps variable size denoting current number elements new entries receive index ind size ind changed 
th maintains counter current handle initialized new handle chosen hnd 
inputs evaluation input port 
list cmd 
xj 
usually write cmd 
xj variable designating result th returns 
value cmd command string contained command sets 
commands sets available user adversary sets model special adversary capabilities accepted command sets enlarged extensions library 
basic commands set basic cmds basic commands 
basic command represents cryptographic operation arbitrary terms similar dolev yao model built decomposed sequence commands 
instance command gen nonce create nonce encrypt encrypt message list combine messages list 
commands store retrieve store real world messages bitstrings library retrieve handle 
commands assume addressed handles 
allow lists signed transferred list operation convenient place concentrate verifications secret items put messages 
altogether basic cmds get type get len store retrieve list list proj gen nonce gen sig keypair sign verify pk sig msg sig gen enc keypair encrypt decrypt pk enc 
commands mentioned meaning get type get len retrieve type length message list proj retrieves handle th element list gen sig keypair gen enc keypair generate key pairs signatures encryption respectively initially handles user input command sign verify decrypt obvious purpose pk sig msg sig pk enc retrieve public key message respectively signature ciphertext 
retrieving public keys possible real cryptographic library tag signatures ciphertexts public keys explained 
details th evaluates basic commands state examples nonce generation encryption see full version complete definition 
assume command entered port 

basic commands local produce result port 
possibly update database produce outputs ports 
touch handles participants functions nonce len enc len max len length functions message length bound system parameter nonces th just creates new entry type nonce arguments handle user nonce length 
models real system nonces randomly chosen bitstrings certain length different initially 
outputs handle nonce generation hnd gen nonce 
set hnd ind size type nonce arg hndu hnd len nonce len 
inputs public key encryption handles public key plaintext list 
th verifies types recall notation pred verifies ciphertext exceed maximum length 
ok new entry type enc indices public key plaintext arguments handle user computed length 
fact entry new models probabilistic encryption arguments model highest layer corresponding dolev yao term 
public key encryption hnd encrypt pk hnd hnd 
pk hnd pk hnd type pke ind hnd hnd type list ind length enc len len 
length max len pk return 
set hnd ind size type enc arg pk hndu hnd len length 
honest send commands secondly set send cmds send send send honest send commands sending messages channels different degrees security 
example details important case insecure channels 
send hnd 

ind hnd hnd type list ind ind output ind ind outa 
algorithm ind hndu retrieves handle user entry index assigns new handle 
command means database stores message known adversary adversary learns output user wanted send message user protocols send commands secret authentic channels key distribution 
channel type part send command name syntactic checks ensure protocol designed ideal cryptographic library fulfills requirements 
local adversary commands thirdly set adv local cmds adv garbage adv invalid adv transform sig adv parse local adversary commands 
model tolerable imperfections real system actions may possible real systems required 
adversary may create invalid entries certain length obtain type garbage 
secondly invalid ciphertexts special case participants knowing secret key reasonably ask type query public key type garbage 
thirdly security definition signature schemes exclude adversary transforms signatures honest participants valid signatures message public key 
allow adversary retrieve information explicitly require hidden denoted command adv parse 
command returns type usually arguments value indices replaced handles parsing signature yields public key testing signature signed message value signature counter message 
ciphertexts adversary know secret key parsing returns length cleartext cleartext 
adversary send commands fourthly set adv send cmds adv send adv send adv send adversary send commands modeling different degrees security channels 
contrast honest send commands sender message additional input parameter 
insecure channels adversary pretend message sent arbitrary honest user 
small example assume cryptographic protocol perform step sign input message fresh nonces 
library represented sequence commands input port 
assume received handle pke hnd public encryption key created signature keys gave handle sks hnd 
hnd store 

hnd gen nonce 

hnd list hnd hnd 

sig hnd sign sks hnd hnd 

hnd gen nonce 

hnd list sig hnd hnd 

enc hnd encrypt pke hnd hnd 

hnd list enc hnd 

send hnd 
note entire term constructed local interaction user ideal library adversary learn interaction step 
step adversary gets output hnd handle hnd resulting entry 
real system described sequence inputs constructing sending term identical real cryptographic operations build bitstring step sent real insecure channel step 
real cryptographic library real system parameterized digital signature scheme public key encryption scheme ranges functions 
signature scheme secure existential forgery adaptive chosen message attacks 
accepted security definition general purpose signing 
encryption scheme fulfill equal length messages indistinguishable adaptive chosen ciphertext attacks 
chosen ciphertext security introduced formalized ind cca 
accepted definition general purpose encryption 
efficient encryption system secure sense 
just ideal system real system parameterized tuple length functions bounds 
structures intended structure real cryptographic library consists machines 
mn 
mu ports 
honest users connect ideal real library 
mu connections mv 
called network connections corresponding ports network ports 
network connections scheduled adversary 
actual system standard cryptographic system defined sketched section 
subset machines may corrupted set 
denote indices correct machines 
channel model means actual structure honest intended recipient gets messages output network ports type secret authentic adversary gets messages output ports type insecure 
furthermore adversary inputs network port type shown 
connections correct machine real system 
states machine main data structure mu database du contains implementation specific data ciphertexts signatures produced system run handles type ideal system possibly additional internal attributes 
entry du form hndu word type add arg 
hndu handle consecutively numbers entries du 
word called word real cryptographic representation type typeset null type null denotes entry parsed 
add arg list additional arguments 
typically signing keys contains signature counter 
similar ideal system mu maintains counter denoting current number elements du 
new entries receive hndu hndu changed 
inputs evaluation describe mu evaluates individual inputs 
inputs port 
basic commands honest send commands ideal system network inputs arbitrary bitstrings 
bitstrings parsed 
captured functional algorithm parse outputs pair type arg type typeset list real arguments bitstrings 
corresponds top level term similar arguments ideal database parse hnd abbreviate mu calls type arg parse du hnd word assigns du hnd type type null may arg 
basic commands basic commands local produce outputs network ports 
basic commands implemented underlying cryptographic operations modifications motivated section 
general cryptographic objects tagged data lists 
similar ideal system show examples evaluation basic commands additionally ciphertexts parsed 
commands full version 
nonce generation real nonce generated tagging random bitstring length type nonce 
new handle assigned handle word type stored additional arguments 
nonce generation hnd gen nonce 
nonce len nonce hnd du hnd nonce 
encryption command epk denote probabilistic encryption string public key pk underlying encryption system parameters parsed case received network types verified 
second component tagged public key word actual public key pk message fresh random value generated additional randomization explained section 
recall included inside encryption final tagged ciphertext encryption hnd encrypt pk hnd hnd 
parse pk hnd hnd du pk hnd type pke du hnd type list return 
set pk du pk hnd word du hnd word nonce len encrypt epk set enc pk 
max len return set hnd du hnd enc 
parsing ciphertext verifies components lengths outputs corresponding tagged public key message retrieved decryption command 
send commands network inputs send commands simply output real messages appropriate network ports 
show insecure channel 
send hnd 

parse hnd necessary 
du hnd type list output du hnd word port 
receiving bitstring network port netw machine mu parses verifies list 
new mu stores du new handle hnd retrieves existing handle hnd outputs hnd port 

security proof security claim real cryptographic library secure ideal cryptographic library protocols proved basis deterministic dolev yao ideal library safely implemented real cryptographic library 
late theorem need additional notation sys cry id denote ideal cryptographic library participants length functions bounds sys cry real real cryptographic library participants secure signature scheme secure encryption scheme length functions bounds set valid parameter tuples real system consisting number participants secure signature encryption schemes length functions bounds sys cry real resulting real cryptographic library 
corresponding length functions bounds ideal system formalized function sys cry id ideal cryptographic library parameters notation definition theorem 
security cryptographic library parameters 
sys cry real sys cry id proving theorem define simulator simh combination arbitrary polynomial time users arbitrary polynomial time adversary distinguish combination real machines mu combination th simh sets indicating correct machines 
sketch simulator proof correct simulation 
simulator basically simh translate real messages real adversary handles th expects adversary input port ina 
vice versa see 
directions simh parse incoming messages completely construct version real bottom 
done recursive algorithms 
cases simulator produce corresponding message 
collect cases called error sets show occur negligible probability 
ports output types simulator 
state simh mainly consists database da similar databases du storing knowledge adversary 
behavior simh sketched follows 
inputs th 
assume simh receives input hnd th 
bitstring hnd exists da message known adversary simulator immediately outputs port 
constructs bitstring recursive algorithm id real 
algorithm decomposes term basic commands adversary command adv parse 
time id real builds corresponding real bitstring real cryptographic operations enters new message parts da recognize reused th simulator construct subterms exactly correct machines real system 
encryptions public key correct machine adv parse yield plaintext simulator encrypts fixed message equal length 
simulation presupposes new message parts standard formats resulting local adversary commands proven correct bisimulation 
inputs assume simh receives bitstring port 
valid list simh aborts transition 
translates corresponding handle hnd algorithm real id outputs sending command adv send hnd port ina 
handle hnd exists da real id reuses 
recursively parses real bitstring functional parsing algorithm 
time builds corresponding term database th 
yields handle hnd furthermore real id enters new subterms da 
building term real id extensive special capabilities adversary modeled th 
real system bitstring may contain transformed signature new signature message correct user created signature 
transformation signature excluded definition secure signature schemes occur real system 
simulator able insert transformed signature database th explains need command adv transform signature 
similarly adversary send invalid ciphertexts simply bitstrings yield valid type parsed 
cases covered special capabilities 
case command exists forged signature new message 
leads simulator abort 
runs fall error set shown negligible 
commands id real real id local algorithms give uninterrupted dialogues simh th show views important properties shown simulator bisimulation 
simulator polynomialtime 
joint machine simh simh valid polynomial time adversary ideal system 
secondly shown interaction th simh recursive algorithms fail machines reaches runtime bound 
proof properties quite involved analysis possible recursion depths depending number existing handles see 
proof correct simulation simulator show arbitrary polynomial time users arbitrary polynomial time adversary distinguish combination real machine mu combination th simh 
standard technique distributed systems rigorously proving systems identical visible behaviors bisimulation defines mapping respective states shows identical inputs mapped states retain mapping produce identical outputs 
need probabilistic bisimulation real system simulator probabilistic identical inputs yield mapped states correct probabilities identically distributed outputs 
mappings arbitrary relations bisimulation 
presence cryptography active attacks normal probabilistic bisimulation insufficient crucial reasons 
adversary succeed attacking real system small probability impossible ideal system 
means cope error probabilities 
secondly encryption gives computational indistinguishability captured bisimulation actual values systems may quite different 
thirdly adversary guess random value nonce created machine adversary ideally seen 
formally ideally seen just means bisimulation fails adversary sends certain value exists databases command give adversary handle 
order perform rigorous reduction proof case show partial information value leaked adversary value contained nested term certain operations leak partial information 
instance proof fail allowed arbitrary signatures definition divulge previously signed messages additionally randomize probabilistic ciphertexts keys adversary 
meet challenges factoring computational aspects special treatment ciphertexts 
new bisimulation technique includes static information flow analysis followed remaining cryptographic reductions 
rigorous proof takes pages give brief overview see 
introducing encryption machines 
encryption machines handle encryption decryption needs system 
roughly machine calculates correct encryption message second encrypts fixed message answers decryption requests resulting ciphertexts table look 
secure rewrite machines mu step yields modified machines replace idealized counterpart step composition theorem show original system secure resulting system 
combined system 
want compare combination mh machines combination machines th simh 
direct invariant mapping states overview proof correct simulation 
joint machines 
defining intermediate system ch state space combined systems step 
bisimulations error sets information flow analysis 
show joint view equal interaction combined machine ch machines mh certain runs collect error sets 
show performing bisimulations simultaneously step 
transitivity symmetry indistinguishability yield desired result mh 
normal state invariants ch define prove information flow invariant variables ch 
reduction proofs 
show aggregated probability runs error sets negligible break underlying cryptography 
perform reduction proofs security definitions primitives 
signature forgeries collisions nonces ciphertexts relatively straightforward proofs 
fact adversary guess official nonces additional signatures ciphertext information flow invariant variables ch show adversary partial information values situations correct guessing put run error set 
proves mh computationally secure ideal system step 
simulatability transitive 
original real system secure ideal system step 

abadi 
formal eavesdropping computational interpretation 
proc 
th international symposium theoretical aspects computer software tacs pages 
abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
proc 
st ifip international conference theoretical computer science volume lecture notes computer science pages 
springer 
anderson needham 
robustness principles public key protocols 
advances cryptology crypto volume lecture notes computer science pages 
springer 
backes jacobi 
cryptographically sound machine assisted verification security protocols 
proc 
th annual symposium theoretical aspects computer science stacs volume lecture notes computer science pages 
springer 
backes jacobi pfitzmann 
deriving cryptographically sound implementations composition formally verified bisimulation 
proc 
th symposium formal methods europe fme volume lecture notes computer science pages 
springer 
backes pfitzmann 
computational probabilistic non interference 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 
backes pfitzmann 
cryptographically sound security proof needham schroeder lowe public key protocol 
appear proc 
rd conference foundations software technology theoretical computer science 
preliminary version available iacr cryptology eprint archive 
backes pfitzmann 
intransitive non interference cryptographic purposes 
proc 
th ieee symposium security privacy pages 
backes pfitzmann steiner waidner 
polynomial fairness liveness 
proc 
th ieee computer security foundations workshop csfw pages 
backes pfitzmann waidner 
universally composable cryptographic library 
iacr cryptology eprint archive jan 
eprint iacr org 
beaver 
secure multiparty protocols zero knowledge proof systems tolerating faulty minority 
journal cryptology 
bella massacci paulson 
verification industrial payment protocol set purchase phase 
proc 
th acm conference computer communications security pages 
bellare desai pointcheval rogaway 
relations notions security public key encryption schemes 
advances cryptology crypto volume lecture notes computer science pages 
springer 
bellare 
authenticated encryption ssh provably fixing ssh binary packet protocol 
proc 
th acm conference computer communications security pages 
bellare rogaway 
entity authentication key distribution 
advances cryptology crypto volume lecture notes computer science pages 
springer 
bleichenbacher 
chosen ciphertext attacks protocols rsa encryption standard pkcs 
advances cryptology crypto volume lecture notes computer science pages 
springer 
canetti 
security composition multiparty cryptographic protocols 
journal cryptology 
canetti 
unified framework analyzing security protocols 
iacr cryptology eprint archive dec eprint iacr org 
canetti 
universally composable security new paradigm cryptographic protocols 
proc 
nd ieee symposium foundations computer science focs pages 
cramer damg ard 
secure signature schemes bas ed interactive protocols 
advances cryptology crypto volume lecture notes computer science pages 
springer 
cramer damg ard 
new generation secure practical rsa signatures 
advances cryptology crypto volume lecture notes computer science pages 
springer 
cramer shoup 
practical public key cryptosystem provably secure adaptive chosen ciphertext attack 
advances cryptology crypto volume lecture notes computer science pages 
springer 
cramer shoup 
signature schemes strong rsa assumption 
proc 
th acm conference computer communications security pages 
dang kemmerer 
astral model checker cryptographic protocol analysis 
proc 
dimacs workshop design formal verification security protocols dimacs rutgers edu workshops security 
denning sacco 
timestamps key distribution protocols 
communications acm 
desmedt 
break practical mix design new 
advances cryptology eurocrypt volume lecture notes computer science pages 
springer 
dolev yao 
security public key protocols 
ieee transactions information theory 
schneider 
pvs embedding csp verify authentication protocols 
proc 
international conference theorem proving higher order logics volume lecture notes computer science pages 
springer 
fisher 
millions net passport accounts put risk 
may 
flaw detected 
gennaro halevi rubin 
secure hash sign signatures random oracle 
advances cryptology eurocrypt volume lecture notes computer science pages 
springer 
goldreich 
remarks concerning goldwasser micali rivest signature scheme 
advances cryptology crypto volume lecture notes computer science pages 
springer 
goldwasser levin 
fair computation general functions presence majority 
advances cryptology crypto volume lecture notes computer science pages 
springer 
goldwasser micali 
probabilistic encryption 
journal computer system sciences 
goldwasser micali rivest 
digital signature scheme secure adaptive chosen message attacks 
siam journal computing 
guttman thayer zuck 
faithfulness protocol analysis message authentication 
proc 
th acm conference computer communications security pages 
hirt maurer 
player simulation general adversary structures perfect multiparty computation 
journal cryptology 
kemmerer meadows millen 
systems cryptographic protocol analysis 
journal cryptology 
laud 
semantics program analysis computationally secure information flow 
proc 
th european symposium programming esop pages 
lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proc 
th acm conference computer communications security pages 
lowe 
breaking fixing needham schroeder public key protocol fdr 
proc 
nd international conference tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer 
micali rogaway 
secure computation 
advances cryptology crypto volume lecture notes computer science pages 
springer 
mitchell mitchell stern 
automated analysis cryptographic protocols mur 
proc 
th ieee symposium security privacy pages 
needham schroeder 
encryption authentication large networks computers 
communications acm 
owre shankar rushby 
pvs prototype verification system 
proc 
th international conference automated deduction cade volume lecture notes computer science pages 
springer 
paulson 
inductive approach verifying cryptographic protocols 
journal cryptology 
pfitzmann waidner 
cryptographic security reactive systems 
dera rhul workshop secure architectures information flow electronic notes theoretical computer science entcs march 
www elsevier nl cas tree store tcs free pc menu htm 
pfitzmann waidner 
break repair provably secure untraceable payment system 
advances cryptology crypto volume lecture notes computer science pages 
springer 
pfitzmann waidner 
composition integrity preservation secure reactive systems 
proc 
th acm conference computer communications security pages 
pfitzmann waidner 
model asynchronous reactive systems application secure message transmission 
proc 
nd ieee symposium security privacy pages 
rackoff simon 
non interactive zero knowledge proof knowledge chosen ciphertext attack 
advances cryptology crypto volume lecture notes computer science pages 
springer 
rogaway 
authenticated encryption associated data 
proc 
th acm conference computer communications security pages 
wagner schneier 
analysis ssl protocol 
proc 
nd usenix workshop electronic commerce pages 
warinschi 
computational analysis needham schroeder lowe protocol 
proc 
th ieee computer security foundations workshop csfw pages 
yao 
theory applications trapdoor functions 
proc 
rd ieee symposium foundations computer science focs pages 
