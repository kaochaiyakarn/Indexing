carnegie mellon university high performance robust computer systems dissertation submitted graduate school partial fulfilment requirements degree doctor philosophy electrical computer engineering john peter pittsburgh pennsylvania october copyright john 
rights reserved 
wife believed helped believe society increasingly relies computing systems smooth efficient operation computer errors interrupt lives commonplace 
better error exception handling correlated reliable software systems shelton koopman 
unfortunately robust handling exceptional conditions rarity modern software systems signs situation improving 
dissertation examines central issues surrounding reasons software systems general robust presents methods resolving issue 
commonly held building robust code impractical methods addressing common robustness failures simple generic fashion 
develop checking mechanisms detect handle exceptional conditions affect process system state preemptive detection 
gives software system information needs gracefully recover exceptional condition need task restarts 
perception computing systems robust fast myth dearth quantitative data abundance conventional wisdom truth rooted era modern superscalar processors 
advanced microarchitectural features processors key building understanding systems fast robust 
research provides objective quantitative analysis performance cost associated making software system highly robust 
develops methods systems studied robust performance overhead nearly case 
studies indicate programmers incomplete understanding build software systems robust exception handling importance design respect handling errors exceptional conditions maxion 
studies large scope thorough analysis contain data students little professional programming experience 
presents data collected professional programming teams measured expected exception handling performance achieved performance 
iv data provides indication despite industry experience specifications robustness teams predict robustness response software build robust systems 
acknowledgments foremost wish wife struggled school 
light earth believing face 
family helped shape person am 
taught self reliance trust importance personal integrity 
committee gave freely time mentor guide process 
especially phil koopman advisor taught think critically problems perform effective research importantly communicate results effectively 
want carnegie mellon possible helped fun place bryan black putting perspective making pizza tuesday 
way house 
cindy black getting mad bryan took kitchen tuesday pizza behavior 
green true friend setting best examples 
friend tan dark humor 
bill melanie renaissance shared lives 
elaine running office year old making pictures giving reason smile 
lou jim network engineers kept running smoothly despite dumb things system 
karen melissa lynn elaine elaine doing jobs dedication worry working projects 

acknowledgments vi table contents iv acknowledgments vi motivation terms definitions exception handling language approaches operating system trap support performance issues knowledge code outline prior describing exception handling performing exception handling high performance exception handling ballista robustness benchmarking service previous ballista testing methodology scalable testing functional specifications implementation test values testing results example testing generalizing approach support exception handling models support callbacks scaffolding phantom parameters generalization ballista testing method summary exception handling effectiveness posix operating systems ballista testing methodology posix categorizing test results results raw testing results normalized failure rate results failure rates weighted operational profile failure rates call function category library failure rates data analysis version software voting elimination non exceptional tests 
estimation silent failure rates frequent sources robustness failure table contents vii issues attaining improved robustness signals vs error codes building robust systems summary os results hardening analysis math libraries background performance testing methodology results analysis summary math library robustness results hardening analysis safe fast robustness testing sfio performance results analysis summary hardening analysis operating system internals robustness testing linux hardening select linux api calls failure previous techniques approach enhanced memory robustness checks performance analysis hardened code robustness check cache iterative benchmark lightweight synthetic application benchmark understanding robustness dod high level architecture run time infrastructure commercial java objects self report format self report data test results analysis acknowledgments contributions tractability generality speed developer understanding architectural improvements compiler support controlled study table contents viii tool integration detailed performance evaluation appendix appendix table contents ix list 
example signal exception handling 
ballista test parameter creation 
date string type inherits tests generic string generic pointer 
trapezoidal numerical integration algorithm sedgewick target function 
ballista test case generation write function 
arrows show single test case generated particular test values general combinations test values tried course testing 

normalized failure rates posix operating systems 
normalized failure rates call function category divided posix document chapters 
library functions contribute large proportion raw failure rates 
adjusted normalized robustness failure rates version software techniques 
results approximate due heuristics 

performance variants normalized unmodified source 

robustness failure rates sfio stdio compared functions direct functional equivalence measured linux test system 
failure rates digital unix lower sfio functions addressed section 
abort failure rate select sfio functions linux 
elapsed time benchmark running architecture 
elapsed time benchmark running axp alpha architecture 
total processing time benchmark architecture 
total processing time benchmark axp alpha architecture 
initial failure rates memory manipulation process synchronization methods 
failure rate memory process synchronization functions initial treatment 
altered malloc helps address fundamental robustness limitation 
failure rate memory process synchronization functions final treatment 
software implemented robustness check cache 
iterative performance slowdown robust process synchronization functions list figures 
iterative performance slowdown robust memory functions 
pseudo code lightweight synthetic benchmark 
slowdown synthetic benchmark robust process synchronization functions 
slowdown synthetic benchmark robust process synchronization functions large cache size 
absolute robustness overhead process synchronization functions nanoseconds 
absolute robustness overhead memory functions nanoseconds 
robustness failure rate rti sunos 
average failure rate 

robustness failure rate rti digital unix 
average failure rate 

sample report form 
robustness failure rates components 
component constructor abort failure rates parameter 
component abort failure rate 
component silent failure rates 
total failure rate component list figures xi table list table 
directly measured robustness failures fifteen posix operating systems 
table 
test function list table 
robustness failure rate math library variants 
table 
sfio benchmark descriptions table 
usr sys elapsed time data original hardened sfio intel architecture table 
expected robustness response component table 
expected robustness response component table 
expected robustness response component list tables xii society dependant complex interactions electronic systems ability systems tolerate defects errors exceptions critical achieving service goals 
aspect life dependant computers software runs 
banking traffic control weapons systems trip grocery store things take granted tied correct functionality computing systems 
course need fault tolerance entirely new thing 
military aerospace medical financial systems built tolerant faults practical 
robust designers may hoped jones leveson lions effort build robust systems 
designers fault tolerant systems continued efforts goal improving subsequent system generations 
fault tolerance issues addressed safety critical computing sectors medical aerospace sectors lack time money expertise build robust systems methods developed traditional safety critical sectors 
promise reusable modular computational components beans ole containers closer reality building systems tolerate faults reused purchased components critical 
motivation research thesis tells complex story motivation times subtle 
section attempt relate path experiences observations roughly chronological order led inception guided direction 
readers interested results technical details invited skip section immediately terms definitions 
historical basis deeply rooted fault injection community larger fault tolerance community 
fault tolerance goal engineers engineering invented discipline 
happy stiff wind come blows house 
philosophy applied today wide variety computing systems including banking aerospace military medical just name 
drawbacks fault injection kanawati usually required special purpose hardware specific hardware setup 
difficult trace root cause problems detected difficult reproduce due random element involved 
course height popularity approach worked target systems relatively simple designed specifically purpose requiring fault tolerance 
potential problem lack consistent meaningful numerical result relate measured existing tools 
unclear exactly fault injection tools measure relate measurement back system 
dissatisfaction limitations traditional fault injects led line research carnegie mellon university culminated ballista tool 
ballista fault injection system software provides portable repeatable fault injection api level meaningful numerical results compared related back system test 
initial version tool primitive test data types hard coded system little flexibility type api test 
armed new tool set change world little corner testing posix compliant operating systems 
tool applied posix compliant os get hands 
instincts told systems tests surprised bit results obtained 
publish complete results gave results os vendors publication allow fix problems discuss 
cases vendors elected send new versions operating system retest 
cases newer system different robustness necessarily better 
succeed goal interacting developers responses varied ranged fix ibm dumping core right thing freebsd understand interested addressing issues linux guys crazy name withheld protect guilty 
companies cisco military contractors agreed results important 
large prevailing sentiment fixing issues just couldn done 
just hard cost terms performance better 
confronted appeared cold hard reality situation stopped took stock position 
nearly talked disagreed felt way address issues reasonable fashion 
unfortunately didn evidence support position 
took time enhance tool completely rebuilt ballista making extensible api 
custom language compiler created allow easy creation custom data types testing 
gave ability test wide range software systems 
having completely rewritten tool began process deciding best step addressing problem improved system robustness 
simple expedient elected investigate freebsd math libraries 
wanted determine difficult address existing robustness problems cost fixing 
able fix robustness failures math library turned costly terms performance 
additionally discovered lot checks similar ones needed add improved robustness 
tested ranges boundary conditions part necessary calculations correct checked error conditions forced signal condition detected 
turned stock implementation paid cost making library robust just get calculation correct 
just percent able robust afford check return codes call 
course response result predictably negative 
math libraries represent simple computational code 
don complex data structures don affect machine state 
results generally seen providing little solid evidence supporting idea possible build robust software little performance cost 
example criticisms changed bit include new idea 
idea developers build robust code didn complexity speed issues 
indicating insights gained tool robustness testing 
issues uncovered believed understood simply ignored 
address new direction critics decided look package written software reliability fault tolerance mind safe fast library 
authors sfio able create library avoided stdio inefficiencies added variety safety features greatly improved robustness stdio 
suffer failures despite comments authors indicating contrary suspected 
took results sfio authors firmly believed failures remaining hard performance costly remove 
pointed improved robustness large extent removed failures felt sacrificing performance 
explanation plausible elected look see kinds performance vs robustness tradeoffs possible 
facilitate obtained copy sfio source code trying fix problems ballista 
couple weeks able build additional checks code robust 
robust fact functions exhibited failures fractional percentages failures 
thing remained benchmark new code performance tradeoffs possible 
recreated original benchmarks authors sfio scaled today architectures simple optimizations performance penalty large 
despite originally thought sfio didn fix failures didn address fixed significantly performance library 
looked speed critical os services linux including memory process synchronization primitives 
able completely low level service modules slight performance penalty pessimistic case 
began attempt quantify performance tradeoffs inherent building robust systems detailing simple generically applicable methods build high performance robust computing systems 
piece puzzle issue purpose tool ballista 
believe developers understand build robust software simply speed complexity issues tool redundant 
case tool critical offers feedback robustness goals met 
great deal thoughtful experimentation done area roy maxion piece fell place course joint research project ibm center software engineering research 
peter group interested coming methodology describe non functional qualities components way encourages reuse 
aspect robustness 
maxion springboard came system developers ibm classify robustness software system 
experiment devised developers classify software modules indicate robust expected 
modules tested actual versus expected robustness values compared 
experiment executed research team ibm center software engineering research data components turned testing comparison 
tested components related measured robustness actual robustness noticed number discrepancies expected measured robustness 
attribute phenomena discussed maxion maxion 
team build robust software tool ballista necessary perform tests determine robustness goals met feed back software process 
path research long execution retrospect fairly straight logical 
started metric 
addressed concern heard detailing reasons robust software systems developed 
people smart need method tool check sure think happening happening 
day software groups determine build robust systems technical 
terms definitions purposes thesis definition robustness ieee software engineering glossary dropping environmental conditions clause degree system component function correctly presence invalid inputs ieee quantify robustness terms failure rate 
failure rate function represents percentage test cases cause robustness failures occur 
define normalized failure rate particular operating system 
range values inclusive number functions tested equal number calls particular os supports suite wi weighting importance relative execution frequency function fi number tests produced robustness failure function ti number tests executed function define hardening act adding software perform tasks perform run time checks validation determine validity operand data detect handle exceptional conditions 
software package hardened definition robust 
exception handling anecdotal data collected robustness testing suggest systems incapable gracefully handling exceptional conditions including exceptions caused software defects application programs calling software packages tend somewhat reliable system level reliable task level 
evidence prove causality cases system failures tend modules poor exception handling characteristics christian shelton koopman 
despite general need better exception handling existence tools identify exception handling shortcomings projects pay passing attention aspect system 
developers simply lack exposure need methods exception handling maxion 
eschew perceived performance problems development difficulty 
need case 
maxion points small amount effort applied raising awareness importance solid exception handling result significant improvements maxion 
additionally research commercial tools help developers detect potential robustness weaknesses hastings carreira ghosh 
issue finding correcting robustness problems experience developers greatly overestimate performance penalty making software highly robust reason avoid robustness improvement 
language approaches idea building exception handling novel 
fundamental part languages defined constructs handling exceptional conditions 
popular languages today java 
java provides optional mechanisms enforce exception handling constructs modules 
allows developers specify exceptions method throw predefined user defined types 
compiler forces calling routine catch handle type exception module defined throw 
similarly ada ml languages provide various levels compiler enforceable exception handling 
problem approaches incomplete foresight part people writing software modules 
nearly impossible anticipate possible event condition large gaps improper exception handling exists 
conceivable programmers grow rely heavily language safe 
see java components robustness failures despite safe language 
great importance question recoverability language exception received 
languages built exception handling deliver language exceptions low level signals little ensure exceptional condition safely recovered task restart 
operating system trap support languages built routines exception handling rely specific support virtual machine case java operating system support signal handling 
signals caused exceptional conditions software generated conditions interpreted small runtime environment converted appropriate language constructs 
constructs handled built mechanisms 
include setjmp include signal include stdio jmp buf ec error int signum signal sigsegv void error longjmp ec int main int int exc code signal sigsegv void error exc code setjmp ec fileno void printf exception handled exc code printf complete return 
example signal exception handling languages specific built support exception handling may mechanisms trap handle signals machine software generated exceptions 
example programmer may set exception handling mechanisms signal handling defined posix 
example signal exception handling 
essence programmer set large number small localized exception handling routines called occurrence exception essence modeling try catch framework setup large global handlers 
performance issues exception handling generally perceived expensive terms performance software systems attempt robust sacrificing performance 
example software package developed safety robustness goal compromise performance safe fast library sfio developed david korn phong vo research korn 
functions included sfio implement functionality standard libraries stdio 
library adds large amount error checking ability functionality standard libraries manages adversely affecting performance 
authors sfio able demonstrate high performance library time developed method quantifying robustness 
case library safer due design decisions method available quantify improved stdio 
furthermore discussions developers sfio revealed concerned performance impact increasing amount exception checking done code 
existence sfio viewed opportunity gain understanding robust application programing interface api implementation design techniques metrics feedback actual performance penalty improving robustness point judged practical sfio developers 
performance cost adding solid exception handling error checking high conventional wisdom holds reduce cost 
conversely cost prohibitive error checking exception handling keeping cost reason 
knowledge code cost exception handling important understand ability developers estimate code performs respect graceful response exceptional conditions 
done aid determining reason software complete regard put path able develop software exception handling wider range projects just military aerospace applications 
available evidence suggests inexperienced developers able write code robust error exception handling maxion 
support hypothesis professional developers similar deficiency 
cursory data explore notion effort understand improve ability professional developers successfully write software systems robust exception handling just speculation 
outline dissertation begins overview previous general area exception handling chapter discusses broad nature existing dissertation fits spectrum exception handling research 
chapter presents ballista software robustness testing tool detail 
chapter presents experimental results robustness posix operating systems shaped core idea general robustness poorly understood priority professional software developers 
vendor response results led investigation tractability performance characteristics robust exception handling 
chapter presents experimental data analysis standard math libraries distributed freebsd 
represents earliest exploratory done investigation 
chapter presents results analysis hardening safe fast library sfio korn 
results applying techniques lessons developed hardening sfio math libraries operating system services chapter 
data collected professional development groups comparing expected robustness measured robustness chapter 
dissertation concludes chapter discussion contributions possible 
prior literature written exceptions exception handling vast 
exception handling studied computing important detecting dealing problems errors expected conditions 
research falls largely major categories respect exception handling describe perform fast describing exception handling exception handling code difficult represent terms design documentation largely generally falls outside normal program flow occur virtually point program 
accordingly large body created help develop better methods describe design document exception handling facilities software system 
early discover multiple ways handle exceptional conditions hill goodenough 
years methods come dominate current implementations 
methods termination model resumption model gehani 
current systems main exception handling models manifest error return codes signals 
argued termination model superior resumption model cristian 
implementation resumption model semantics posix operating systems signals provides large grain control signal handling typically task level resulting termination process sigsegv 
difficult diagnose recover problem concern real time systems afford large scale disruptions program execution 
implementations termination model typically require software module return error code set error flag variable errno posix event exceptional condition 
instance function includes division operation return divide zero prior error code divisor zero 
calling program determine exception occurred determine recover 
posix ways error codes provides portable support error return model building robust systems ieee 
higher level abstraction formal frameworks representing exception handling recovery developed hofstede 
methods attempt build exception handling framework easy understand transactional workflow system 
highly hierarchical object oriented approaches seek build flexible easy frameworks bridge gap representation implementation dony 
approach computational reflection maes separate exception handling code normal computational code garcia garcia 
performing exception handling see language example exception handling mechanisms code generation reading difficult 
problem development lifecycle 
easing burden developing testing maintaining software exception handling constructs better code representation important reducing costs improving product quality 
consequently large field related 
common way easing burden writing effective exception handling code code macro libraries 
type approach benefit easily assimilated existing projects allows developers traditional programming languages lee hull hagen buhr 
aggressive approaches go simple compiler constructs build entire frameworks language constructs 
focus research lines identifying exceptional conditions exception generated efficient manner developing exception handling mechanisms easier 
closely related vo 
method way error checking encapsulated wrapper reducing prior flow control disruption improving modularity 
uses tool set facilitate intercepting function calls third party libraries perform error checking 
somewhat automated version relatively common manual wrapper technique high availability military systems 
influenced research leading 
research uses idea avoiding exception generation order software interface robustness failures 
explores practical limits hardening terms detection capabilities performance cost 
cases tool mechanism implementing checks discussed 
unfortunately incur overhead additional function call addition tests performed protected code segment 
check functions inlined due structure call intercept methodology difficult imagine practical modifications technology allow inlining optimization 
high performance exception handling today high performance culture desire fast exception handling obvious 
discussed section largely focuses generating propagating handling exceptions fast possible 
complementary document 
generated exceptions difficult recover robust fashion 
mainly interested developing methods including enhanced error detection software systems detect exceptional conditions maximum extent possible generate exceptions sacrificing performance 
exception delivery cost substantial especially heavily layered operating systems exception needs propagate subsystems reach handling program 
thekkath authors hardware software solution reduce delivery cost order magnitude 
zilles multithreading explored handle hardware exceptions tlb misses squashing main instruction thread 
may benefit multithreading technologies emerge new commercial processor designs allowing error checking threads run parallel 
prior synchronizing checking threads main execution thread may prove costly terms execution overhead certainly machine resources 
performs checks main thread building enhanced multiply branch prediction hardware block caches black simply execute checks parallel speculatively bypass little performance cost 
authors propose hardware architecture allow rapid validation software hardware memory accesses 
proposed architecture imposed speed penalty 
unfortunately authors determined special hardware scheme costly implement software 
proposes code transformation technique detect memory exceptions resulting performance overheads austin 
expands ideas key areas 
creates simple generically applicable construct exception detection 
quantifies performance cost construct provide robust exception detection handling discusses ways emerging microprocessor technologies improve construct performance 
prior ballista robustness benchmarking service computing systems continue take increasingly important roles everyday life dependability systems respect software robustness may high 
disruption communications services business server cause substantial problems service provider consumer dependent service 
personal computer users crashes popular desktop computer software 
people notoriously faced computer problems disrupt services daily lives 
software robustness failures exceptional conditions new problem 
early highly visible software robustness failure critical system came apollo lunar landing program despite ample resources engineering development test 
apollo space flight experienced mission threatening computer crashes reboots powered descent lunar landing caused exceptional radar configuration settings resulted system running memory buffers jones 
software development methodologies critical systems rational engineers ability create robust systems 
cost cutting time pressure real world constraints critical systems lead perfectly robust software systems 
spectacular instances maiden flight ariane heavy lift rocket 
shortly rocket payload lost due failure originating unhandled exceptional condition conversion floating point value integer value lions 
stands reason everyday projects lower perceived criticality budget size susceptible robustness problems 
illustrated space flight examples people daily experience personal computer software response exceptional conditions graceful 
frequently focus software development processes input exceptional encountered lack specification input defect requirements 
user perspective failure handle ballista tool exceptional condition gracefully amounts software failure strictly speaking caused software defect irrelevant software development documents leave responses particular exceptional condition unspecified lost hour family member due software crash 
history common sense tell specifications address possible exceptional condition 
consequently implementations developed typical software development teams probably entirely robust 
world commercial software resource time constraints leave gaps exceptional conditions anticipated overlooked left unchecked 
simple example consider ascii integer conversion fed null string pointer expressed call atoi null 
expect systems call causes segmentation fault aborts process 
course expect programmers deliberately write atoi null possible pointer returned user input routine purchased part component library generate null pointer value 
pointer passed atoi exceptional condition documented just pick example say happens user presses backspace carriage return isn test set 
atoi abort program case 
application programmer check input atoi specified case input routine component generate null pointer 
atoi react gracefully generate error return code application program check see conversion integer performed properly take corrective action 
easy say problem handled bug patch lack robustness simple case cause problems ranging expense distributing patch embarrassment loss customers worse 
resource time constraints allow thorough testing functional aspects software system 
functional testing easiest testing expense justify 
easy visions unhappy customers poor sales budget conscious cost cutter product fails perform advertised functions 
ballista tool development methodologies test methodologies software metrics typically give short issue robustness 
particular previously comprehensive way quantify robustness difficult measure effects spending money improve 
furthermore exceptional conditions typically infrequent difficult justify spending resources dealing 
mistake think infrequent exceptional necessarily equates demonstrated year values rolling digit year data fields infrequent certain happen 
robustness may important issue software system systems require software robustness pose special difficulties testing 
robust software system typical code exist purpose dealing exceptions exceptional conditions gehani 
unsurprisingly light sources state mature test suites may contain times test cases designed test responses invalid conditions inputs dirty tests designed test functionality clean tests beizer 
short writing robust code testing robustness difficult time consuming expensive 
bulk development effort situations spent exceptions normal functionality useful tools support evaluate effectiveness exception handling code 
problems arise attempting shelf software components 
may difficult evaluate robustness software access complete development process documentation cases source code 
robustness matters application robustness evaluations useful selecting component library 
evaluations useful performed way permitted apples apples comparisons similar component libraries multiple vendors 
ballista approach robustness testing discussed chapter provides automated scaleable testing framework quantifies robustness software modules respect response exceptional input values 
generates specific test cases deterministically reproduce individual robustness failures testing order help developers pin ballista tool robustness problems 
additionally compare shelf software components measuring robustness fifteen different implementations posix operating system application programming interface api 
previous ballista robustness testing method described form software testing heritage traces back software testing community fault tolerance community form software fault injection 
ballista builds fifteen years fault injection carnegie mellon university including barton siewiorek mukherjee contribution attaining scalability cost effective application reasonably large api 
early method automatically testing operating systems robustness development program 
operates writing random data values memory spawning large numbers tasks attempt execute random bytes concurrent programs 
tasks terminate immediately due illegal instruction exceptions occasion single task confluence multiple tasks cause operating system fail 
effectiveness approach relies serendipity words run long may eventually get lucky find way crash system 
similarly fuzz project university wisconsin random noise fuzz injection discover robustness problems operating systems 
documented source problems miller discovered problems operating systems years miller 
fuzz approach tested specific os elements interfaces opposed completely random approach relied random data injection 
fault injection area tested limited aspects robustness 
fiat system barton probes placed programmer alter binary process image memory execution 
ferrari system kanawati similar intent fiat uses software traps manner similar debugger break points permit emulation ballista tool specific system level hardware faults data address lines condition codes 
system tsai injected faults system exercised random workload generator platform specific device driver inject faults 
systems produced interesting results intended quantify robustness scale entire os api 
earlier cmu attempted attain scalable testing large api 
attempted generically map method functionality testing groups 
approach worked fulfil goal scalable large effort required function basis specify generic functionality software function 
hardware fault tolerance community investigating robustness mechanisms software engineering community working ways implement robust interfaces 
efforts discussed detail chapter 
moment simply reiterate posix supported mechanism creating portable robust systems error return code model ieee lines 
typical software testing approaches suitable evaluating robustness robustness included explicit detailed requirement reflected specifications 
comprehensive exceptional condition tests appear code traceable back requirements regular software engineering practices suffice ensure robust operation 
software engineering techniques tend yield way measure robustness specifications 
example test coverage metrics tend measure code exists tested may provide insight code test handle non specified exceptions may missing entirely 
tools test robustness problems instrumenting software monitoring execution purify rational insure para 
tools test robustness problems necessarily part application software specification course executing tests user scripts 
useful finding exceptional conditions encountered testing missed rely traditional software testing presumably traceable back specifications acceptance ballista tool criteria currently employ additional fault injection approaches 
additionally require access source code necessarily available 
contrast ballista works sending selected exceptional inputs directly software modules module testing level instrumenting existing tests integrated system 
complementary substitute current instrumentation approaches 
ballista testing methodology ballista robustness testing methodology combinational tests valid invalid parameter values system calls functions 
test case single software module test mut called determine provides robust exception handling called particular set parameter values 
parameter values test values drawn pool normal exceptional values data type argument passed mut 
test case consists name mut tuple test values passed parameters test case procedure call form mut name test value test value test 
general ballista approach test robustness single call mut single tuple test values iterate process multiple test cases different combinations valid invalid test values 
general approach ballista testing test robustness single call mut single tuple test values repeat process multiple test cases different combinations valid invalid test values 
style testing excludes timing sequence issues system extended cover areas 
phantom parameters test scaffolding discussed chapter provide opportunity investigate sequence timing issues 
course significant drawback doing potential loss scalability 
scalable testing functional specifications ballista testing framework achieves scalability techniques away functional specification mut 
reasoning functional specification irrelevant purposes testing effort needs ballista tool create specifications especially important testing legacy code code third party software component vendors code specifications machine usable form 
technique attain scalability test specification ballista simply doesn crash doesn hang simple specification describes broad category robust behavior applies modules checked looking appropriate timeout watchdog timer monitoring status task signs abnormal termination 
separate functional specification required module tested modules intentionally terminate abnormally hang appropriate testing ballista 
second technique attain scalability test cases functionality mut values tend exceptional data types mut 
words types arguments module completely determine test cases executed regard module 
approach eliminates need construct test cases functionality 
additionally surprisingly full scale testing proven possible bury test scaffolding code test values associated data types 
means large degree need write test api testing objects orthogonal properties test values test case sfio int pos file state buffer type flags read write rw closed deleted 
ballista test parameter creation sfio int mapped buffered non buffered string read write append line share public malloc static malloc static intvalue maxint zero sfio composite value int pos ballista tool scaffolding code test cases testing new module data types module previously test modules 
net result effort test large set modules api tends grow sublinearly number modules tested 
function tested interface description created function name type information argument 
type information simply name type ballista capable testing 
cases specific information argument exploited result better testing example file descriptor type int implemented ballista specific file descriptor data type 
ballista bases test values data types parameters function interface 
example interface function specifies passed integer ballista builds test cases taught exceptional integer values 
case integer ballista currently potentially exceptional test values 
include values zero powers maximum integer value 
complex data types orthogonal properties abstracted properly greatly reduce complexity effectiveness test objects 
ballista easily accommodate orthogonal deconstruction test data types 
provides greater ability distinguish aspect parameter causing specific robustness failure addition decreasing code complexity 
consider type sfio function seeks specific location file 
orthogonal categories possible values 
possible generated values sfio total values 
ballista uses interface description information create possible combinations parameters form exhaustive list test cases 
instance suppose mut took parameter type sfio integer input parameters 
integer test values sfio values ballista generate test cases 
implementation test values data types testing thought modules fit hierarchical object oriented class structure 
simplifies creation new data types refinement existing types 
data type derived parent type inherits parent test ballista tool cases root ballista type object 
instance data type created specifically represent date string specific test cases associated include invalid dates valid dates dates far past dates 
assuming direct parent date string data module string inherit test cases associated generic string empty string large garbage strings small garbage strings 
generic string inherit generic pointer data type base type include test null pointer 
test value sfio closed buffered malloc int zero refers set code fragments kept simple database comprised specially formatted text file 
fragment test value constructor called test case executed literally constructor code fragment identified test harness constructing instance test value 
constructor may simply return value null may complicated initializes system state 
example constructor sfio closed buffered malloc creates safe fast file call malloc puts predetermined set bytes file opens file read returns pointer file structure 
second code fragments test value commit code changes values necessary prior calling test 
example commit code sfio closed buffered malloc closes file 
date string generic string generic pointer null deleted pagesize maxsize size invalid 
date string type inherits tests generic string generic pointer ballista tool fragment deletes data structures files created corresponding constructor 
example destructor sfio closed buffered malloc deletes file created matching constructor frees buffer 
tests executed test harness having parent task fork fresh child process test case 
child process calls constructors test values selected test case executes call mut test values calls destructors test values 
special care taken ensure robustness failure result mut attributable constructors destructors 
functions implemented macros tested technique require special treatment 
test values experiments combination values suggested testing literature values selected personal experience 
example consider file descriptor test values 
file descriptor test values include descriptors existing files negative maximum integer number maxint zero 
situations exceptional contexts tested including file open read file open write 
file descriptors tested inherently exceptional situations file created opened read deleted file system program knowledge 
guideline test value selection data types include appropriate zero negative maximum minimum representable values pointers non existent memory lengths near virtual memory page size pointers heap allocated memory files open combinations read write exceptional permission settings files data structures released test executed 
creating generically applicable rules thorough test value selection remains subject experience driven approach sufficient produce useful results 
important note testing methodology generate tests description mut functionality data types mut arguments 
approach means mut scaffolding code need written 
result ballista testing method highly scalable respect amount effort required mut needing data types test posix 
ballista tool data types created stand data type compiler 
compiler completed part allows data types written higher level language easy define orthogonal characteristics data type associate appropriate code fragments creation 
compiler takes high level specification generates object linked ballista testing system 
appendix contains sample template file data type description code generated compiler 
important benefit derived ballista testing implementation ability automatically generate source code single test case suite capable running 
cases score lines fewer short programs contain constructors parameter actual function call destructors 
single test case programs reproduce robustness failures isolation os developers verify test result data 
testing results ballista categorizes test results crash severity scale catastrophic failures occur os corrupted machine crashes reboots 
restart failures occur call mut returns control caller meaning application pro gram single task hung requiring intervention terminate restart task 
failures identified watchdog timer times seconds waiting test case complete 
calls wait legitimate hangs tested 
abort failures tend prevalent result abnormal termination core dump posix sig signal single task 
silent failures occur mut returns indication error asked perform operation exceptional value 
example floating point libraries distributed operating systems fail return error code return result accurate computing logarithm zero 
silent failures ballista tool currently identified inferences version result voting identified ballista testing service 
hindering failures occur incorrect error code returned mut difficult execute appropriate error recovery 
hindering failures observed fairly common forming substantial fraction cases returned error codes previous koopman discussed due lack way perform automated identification large experimental data sets 
additional possible outcomes executing test case 
possible test case returns error code appropriate invalid parameters forming test case 
case test case passes words generating error code correct response 
additionally tests mut legitimately returns error code successfully completes requested operation 
happens parameters test case happen valid unreasonable expect os detect exceptional situation pointing address past buffer far past go virtual memory page protection boundary 
ballista methodology unsophisticated uncovers surprising number robustness failures mature software systems 
example test function calls different posix compliant operating systems ballista normalized robustness failure rates mean 
testing software systems indicate comparable failure rates 
example testing order illustrate usage ballista consider code segment performing trapezoidal approximation numerical integration 
typical textbook algorithms efficient easy understand 
testing done digital unix alpha station running digital unix 
required simply add line configuration file describes function module tested 
allows ballista locate interface file library binary source code module data types test 
ballista processes ballista tool information supplied user performs tests builds html page describing results including links generate source code required replicate robustness failures 
example ballista ran total tests function 
ballista tests caused abort failures tests caused restart failures robustness failure rate 
course important realize failure rate going directly dependant test cases 
case mut passed floats integer 
values float int exceptional pi 
means failure rates relative comparisons multiple modules data type implementations 
surface astonishing simple published algorithm robustness failures 
fairness textbook algorithm intended convey perform particular operation presumably intended bullet proof software 
additionally ballista methodology tends mut test cases containing exceptional conditions generate failures having root cause 
examine details test results obtain insight robustness mut 
looking results closely apparent restart failures due integer value maxint value number subdivisions 
case algorithm attempted sum areas roughly trapezoids 
waiting second value user configurable ballista decided process hung terminated classified restart failure 
may applications restart failure cases reasonable flag situation double double return double double double int int double double return 
trapezoidal numerical integration algorithm sedgewick target function ballista tool potential problem spot 
importance restart failures ballista varies depending timing constraints application detect true infinite loops 
abort failures detected ballista example directly caused divide zero floating point exception 
probably easiest type exceptional condition anticipate test 
programmers expected recognize potential problem put zero test function 
unfortunately large amount software developed relatively unskilled programmers may formal training software engineering trained programmers little knowledge write robust software 
remaining aborts due overflow underflow floating point exceptions 
insidious robustness failure nearly mathematical function potential overflow underflow 
exception commonly overlooked programmers difficult handle 
problems potential cause software system fail handled appropriately robust operation desired 
floating point class exceptions especially problematic especially systems microarchitecture default masks 
may fact exception masked may lead problems hardening algorithms robustness failures 
exception cause abort software check certain overflow underflow occur silent failures undetectable current ballista service may result 
resultant calculations may best indeterminate worst wrong depending application strongly recommended full ieee floating point features ieee propagation nan number values ballista testing applied computational software module 
generalizing approach generation standalone ballista test harness developed having mind posix operating system calls full size example system 
results achieved goals portability scalability 
significant limitations 
posix testing harness assumed signal thrown exception robustness failure posix ballista tool standard considers error return codes robust responses 
second result posix testing required absolutely scaffolding code creating tests bit true general software involving distributed computing environment initialization call backs 
issues addressed web testing system 
support exception handling models ballista framework supports termination model resumption model implemented standard 
termination model ballista assumes exceptions thrown amount detail try throw catch mechanism corrective action taken 
case error code returns assumed error variable checked determine error occured currently errno variable posix supported 
unknown exception condition results unhandled generic exception sigsegv segmentation violation posix operating system considered robustness failure 
additionally ballista ability add user defined exception handlers support modules exception handling techniques 
ballista embeds test call standard try catch pair 
thrown exception caught user defined catch statements handled catch 
test harness treated abort robustness failure 
support callbacks scaffolding ballista tool test high level architecture run time infrastructure hla rti simulation backplane system distributed military simulations 
example system brought need dealing exceptions errors handled set thrown exceptions specified api 
additionally hla rti problems piece client software go sequence events create register data structures central application server modules called testing 
function scaffolding required hla rti turned equivalence classes modules equivalence class ballista tool able share scaffolding code 
ballista web testing service ability specify scaffolding code preamble set modules tested 
preamble provides place putting application specific include files 
doubt applications clustering functions sets share scaffolding code possible plausible technique cases achieving scalability terms effort test large set modules 
software systems require calling object able support series callbacks independent functions methods associated calling object 
examples function analyzes incoming events dispatches registered event handlers registration function uses member functions calling object obtain information requires 
situations require testing framework enhanced functions appropriate object structure handle cases 
facilitate ballista ability test types systems provide user ability build main testing function call arbitrary sub class add independent functions needed 
customizable features ballista additions changed modules 
feature adds back function scaffolding previous version ballista added allow testing code requires desired may completely ignored users 
phantom parameters generalization ballista testing method glance parameter testing method ballista limited applicability 
bit creativity allows generalize software modules parameters modules take input files parameters tests system state affects modules parameters directly related state 
order test module parameters need done create dummy module sets appropriate system state parameter calls module tested 
example testing pseudo random number generator require setting starting seed value calling parameterless function returns random number predefined range 
accomplished creating preamble test scaffolding set starting seed ballista tool ballista tool supports elegant approach 
specifying parameters module phantom parameters added list 
parameters exercised ballista constructor destructor pairs called passed mut 
example testing random number generator best done creating data type random number seed sets various values interest data type phantom parameter testing parameterless random number generator 
similar approach taken file module inputs parameter inputs 
phantom parameter defined creates particular file data object set objects particular format 
object accessed parameter example referencing global variable looking object central registry phantom parameter appropriately register object 
version ballista phantom parameters able take parameters instance file name passed generic file creation data type support scheme recursive iterative creation test sets performed 
concept phantom parameters clear test modules system states reflected explicit parameters 
phantom parameters added set system state desired 
example phantom parameter data type created fill disk space disk accessing function called 
ballista testing reasonable certainly complete ability test single module calls single sets parameters effects calls wide variety system states 
extension phantom parameters provide highly deterministic testing amounts wide variety sequences function calls reflected system state set sequence calls 
summary ballista test large variety software modules robustness exceptional input conditions 
highly scalable provide rich state test modules 
early versions testing approach robustness failure rates ranging ballista tool full scale test fifteen posix operating system implementations 
module capable linked gnu binaries tested ballista system 
ballista ability testing data type api level part responsible scalability 
functions methods operate similar data types ballista test type input creation 
minimizes amount code needs written run tests 
due abstraction test effort terms test development time tends scale sub linearly number functions tested 
ballista data type compiler allows easy creation new testing data types 
allows developer write test objects simple language powerful express orthogonal properties associate code needed create test values run time 
ballista tool exception handling effectiveness posix operating systems genesis thesis involved testing analysis posix operating systems 
provided rich set available test targets built professional teams operating stability explicit goal 
suspected tested systems robust authors believe surprised poor robustness systems 
results investigation chapter afforded opportunity interact os developers interested results 
discussions clear prevailing wisdom building robust system complex hard resultant system slow 
operating systems form foundation robust application software making important understand effective handling exceptional conditions 
ballista testing system characterize handling exceptional input parameter values posix functions system calls widely operating system os implementations 
identified ways crash systems single call ways cause task hangs os code ways cause abnormal task termination os library code failures implement defined posix functionality failures report unsuccessful operations 
exceptional tests performed generated error codes depending operating system tested 
approximately tests failed generate indication error despite exceptional inputs 
approximately tests revealed failures implement defined posix functionality unusual specified situations 
exceptional tests caused abnormal termination os system call library function systems completely crashed individual system calls exceptional parameter values 
prevalent sources robustness failures illegal pointer values numeric overflows file overruns 
significant opportunity improving exception handling os calls especially library functions 
role signals vs error return codes controversial source divergent implementation philosophies forming potential barrier writing portable robust applications 
os robustness robustness system depend large part quality exception handling operating system os 
difficult produce robust software application task difficult underlying os application built provide extensive exception handling support 
true desktop computing systems embedded systems telecommunications transportation applications built atop commercial operating systems 
trend new application programming interfaces apis require comprehensive exception handling corba omg hla dod 
unfortunately posix api ieee provides mechanism exception reporting form error return codes implementation mechanism largely optional 
results uncertainty adopting posix operating system critical system leads important questions 
lack firm requirement robustness posix standard robust actual commercial shelf cots posix implementations 
application programmers minimize effects non robust os behavior 
questions answered creating direct repeatable quantitative assessment os exception handling abilities 
evaluation technique give developers feedback new os version released opportunity measure effectiveness attempts improve robustness 
additionally quantitative assessment enable system designers informed comparison shopping decisions selecting os support educated buy decision cots os fact robust existing proprietary os 
alternately knowledge exception handling weak spots os enable application designers take extra precautions known problem spots 
posix exception handling tests conducted ballista fifteen posix operating system versions different vendors variety hardware platforms 
tests executed covering distinct functions system calls os robustness os 
tests identified instances exceptional conditions handled non robust manner ranging severity complete system crashes false indication success system calls 
tests managed uncover exception related software defects apparently caught posix certification process 
robustness failure rates measured analysis test data discussion os vendors reveals divergence approaches dealing exceptional parameter values 
operating systems attempt posix documented error codes provide portable support exception reporting run time 
alternately operating systems emphasize generation signal typically resulting abnormal process termination exceptional parameter values encountered order facilitate debugging 
way generalize oss handle situations particular manner oss studied failed provide indication exceptions substantial portion tests conducted 
true posix standard require comprehensive exception reporting growing number applications need 
evaluating current operating systems respect exception handling important step understanding change needed directions take 
sections describe testing methodology briefly robustness testing results results reveal current operating systems potential directions research 
ballista testing methodology posix ballista approach robustness testing implemented set posix functions calls defined ieee standard ieee posix posix real time extensions language binding 
standard calls functions tested calls take arguments getpid calls return exit calls intentionally send signals kill 
posix function tested interface description created function name type information argument 
cases specific information argument os robustness exploited result better testing example file descriptor type int described ballista specific file descriptor data type 
example shows actual test values test write int const void buffer size nbytes takes parameters specifying file descriptor memory buffer number bytes written 
example older version ballista collection os data previously illustrated testing example showed sophisticated example dials approach 
write takes parameters different data types ballista draws test values separate test objects established data types 
arrows indicate particular test case constructed test file descriptor file opened read access null pointer buffer size api testing objects test values test case write int const void buffer size nbytes file descriptor test object fd closed fd open read fd open write fd deleted fd fd empty file fd past fd beg fd pipe fd pipe fd pipe block fd pipe block fd term fd shm read fd shm rw fd maxint fd neg memory buffer test object buf small buf med pagesize buf large mb buf gb buf huge gb buf size buf buf med buf far past buf odd addr buf freed buf code buf buf null buf neg size test object size size size page size size plus size maxint size size zero size neg write fd open rd buff null size 
ballista test case generation write function 
arrows show single test case generated particular test values general combinations test values tried course testing 
os robustness bytes 
combinations test values assembled create test cases 
usual case combinations test values generated create combinatorial number test cases 
half dozen posix calls number parameters large yield test cases exhaustive coverage reasonable execution time 
cases pseudo random sampling test cases 
comparison run exhaustive searching os sampling gives results accurate percentage point function 
categorizing test results test case executed ballista test harness categorizes test results letters severity scale 
silent failures normally detectable ballista system able infer silent failures experiment 
details explained section 
results total test cases executed data collection 
operating systems supported selected posix functions system calls total test cases supporting subset functionality tested fewer test cases 
raw testing results compilers libraries generate test suite provided os vendor 
case freebsd netbsd linux gnu compiler version associated libraries build test suite 
table reports robustness failure rates measured ballista 
tested systems resulted catastrophic failures 
restart failures relatively scarce operating systems 
abort failures common indicating operating systems relatively straightforward elicit abnormal task termination instruction function system call abort failures subsequent exceptional value returned system call happen response instruction vendor provided software 
os robustness mut suffered catastrophic failures completely tested due lack time multiple reboots borrowed equipment excluded failure rate calculations simply reporting number failures 
representative test case causing catastrophic failure irix malloc maxint similarly call crashes entire os digital unix osf version mprotect malloc calls causing catastrophic failures qnx mprotect qnx mmap mq receive digital unix osf 
note tables report digital unix version catastrophic failure quite similar behavior 
normalized failure rate results comparing os implementations simply basis number tests fail problematic identical tests attempted os different os implementations supported differing subsets posix functionality 
furthermore having parameters execute large number test cases potentially skewing results 
raw test results comparisons normalized failure rates 
rightmost column table show normalized failure rates computed process 
ratio robustness failures total tests computed mut os ratio means tests failed 
mean ratio os computed simple arithmetic average 
definition produces exposure metric gives probability exceptional parameter values types tested cause robustness failure particular os 
metric advantage removing effects differing number tests function permits comparing os implementations differing numbers functions implemented single normalized metric 
failure rates considering abort restart failures range low aix high qnx 
shown bulk failures os robustness system posix fns 
tested fns 
catastrophic failures fns 
restart failures abort failures 
os implementations having catastrophic failures annotated number capable causing system crash 
fns abort failures fns 
failures number tests set experimental data gathered included relatively old os versions representing machines service conservative campus wide software upgrade policy 
insistence vendors newer versions dramatically better tests run borrowed machines configured newest available os releases 
results showed major version upgrades necessarily improve exception handling capabilities 
failure rates reduced irix irix osf osf sunos sunos cases improvement overwhelming 
failure rates increased including addition os robustness abort failures restart failures normalized abort restart rate aix freebsd irix irix linux lynx netbsd osf osf qnx qnx sunos sunos table 
directly measured robustness failures fifteen posix operating systems 
aix free bsd hp ux ballista robustness tests posix function calls hp ux catastrophic irix irix linux netbsd osf osf qnx qnx sunos sunos normalized failure rate catastrophic failure mode increased qnx qnx elimination catastrophic failure modes stayed essentially identical osf osf introduced new catastrophic failure mode 
failure rates weighted operational profile catastrophic catastrophic 
normalized failure rates posix operating systems catastrophic abort failures restart failure uniformly weighted average gives convenient single number metric comparison purposes 
important dig little deeper data determine functions driving failure rates functions frequently obscure functions don matter time 
situations may desirable weight vulnerability exception handling failures relative frequency invocation possible function 
words equal weighting averaging failure rates mut os average weighted relative execution frequency typical program set programs 
os robustness approach corresponds simple version operational profiles traditional software testing musa 
collecting profiling information os system call function level turned surprisingly difficult posix api tools optimized instrumenting user written calls os calls 
instrumentation benchmark suite uhlig floating point portions spec benchmark suite possible atom tool set srivastava running digital unix record number calls run time 
due problems compiler option incompatibility atom benchmark programs compress ftp programs measured 
results weighted failure rates vary dramatically magnitude distribution operating systems depending workload executed 
example weighted failure rates varied depending operating system 
spec floating point programs weighted failure rate operating systems freebsd 
freebsd intentionally uses floating point exception signal error return codes cases happens high percentage abort results functions heavily spec 
specific weighted failure rates described results attempting operational profiling point single operational profile sense interface versatile os api 
definite point clearly profiles robustness failure rates significant 
publishing weighted average best overly simplistic 
interested readers invited obtain raw os failure rate data apply operational profiles appropriate particular application area 
failure rates call function category somewhat different way view failure rate data breaking aggregate failure rates separate failure rates grouped type call function ostrand 
gives general insight portions implementations tend robust handling exceptions bogged details individual call function failure rates 
os robustness 
normalized failure rates call function category divided posix document chapters shows failure rate different categories calls functions grouped chapters posix specification ieee 
general name category example function category convenience 
failure rates category calculated normalized average failure rates function category 
instance category member function failure rate category failure rate 
categories pronounced failure rates 
clocks timers category section standard bimodal distribution failure rates os implementations visible bars low values remaining oss hidden bars irix sunos rest 
set memory management set section standard deals memory locking mapping sharing os robustness malloc type library operations representative areas noticeable variation os implementations respect exception handling 
cases failure rates comparable os implementations different call categories bars show significantly higher failure rates 
failure rate memory management functions 
worse memory management calls produced catastrophic system failure indicating area robustness vulnerability compared problems 
learned new implementation functions accounting potentially higher failure rate 
similar observations indicate may specific areas reduced exception handling effectiveness particular os 
library failure rates general failure rate library calls uniformly high os implementations tested 
shows data shows portions failure rate attributable library functions 
part large contribution library functions failure rates account approximately half aix freebsd hp ux hp ux irix irix linux netbsd osf osf qnx qnx sunos sunos abort restart failure rates system calls library functions 
library functions contribute large proportion raw failure rates os robustness os total library functions tested total os 
library functions failure rate system calls qnx failure rates times higher system calls os versions tested 
library string functions time functions stream tended highest robustness failure rates 
data analysis version software voting scalability ballista testing approach hinges needing know functional specification mut 
general case results having way deal tests indication error non exceptional test cases silent failures depending actual functionality mut 
availability number operating systems conform standardized api permits estimating refining failure rates idea inspired multi version software voting avizienis 
ballista testing results multiple implementations single api compared identify test cases non exceptional silent failures 
course really multi version software voting similar sort idea identifies problems finding areas various versions disagree results identical tests 
elimination non exceptional tests 
ballista test cases carefully include test values exceptional way 
done intentionally prevent masking robustness failures 
correctly handled exceptional condition value tuple passed function may cause system look values 
concept similar obtaining high branch coverage nested branches traditional testing 
instance test case write null operating systems test third parameter length field zero legitimately return success zero length regardless parameter values 
alternately file descriptor checked error code returned 
having second parameter value null pointer generate robustness failure caused pointer dereference file descriptor parameter length fields tested os robustness non exceptional values 
words exceptional values correctly handled argument mask non robust handling exceptional values argument 
hand test case write fd open write null executed lead abort failure null pointer dereferenced 
additionally test cases exceptional calls may non exceptional read permissions testing read vs write 
including non exceptional test cases force module test attempt handle value exceptional 
uses non exceptional test values important necessarily lead test cases fact tests exceptional conditions reading read file exceptional 
multi version software comparisons prune non exceptional test cases results data set 
done assuming test case operating systems return indication error fact non exceptional tests exceptional tests detected reason current computer systems 
non exceptional tests removed operating systems 
shows adjusted abort restart failure aix freebsd hp ux hp ux irix irix linux netbsd osf osf qnx qnx sunos sunos normalized failure rate operating system catastrophic catastrophic catastrophic catastrophic normalized failure rate 
adjusted normalized robustness failure rates version software techniques 
results approximate due heuristics 
abort restart silent error os robustness rates removing non exceptional tests 
manual verification randomly selected test cases removed indicated non exceptional impractical examine larger sample labor intensive process 
possible test cases incorrectly removed sample intuition gained sampling process number false removals involved materially affect results 
estimation silent failure rates potential problems leaving silent failures reporting results os conceivably designed avoid generating abort failures cost 
example aix intentionally permits reads writes memory page mapped address zero support legacy code meaning dereferences null pointer generate abort failures 
fact aix moderately high silent failure rate implementation decision 
non exceptional tests removed multi version software comparison technique detect silent failures 
heuristic os returns error code operating systems return error code suffer form robustness failure typically abort failure 
example attempting compute logarithm zero aix versions qnx completed requested operation error code os implementations return error code 
indicated aix qnx suffered silent robustness failures test case 
course heuristic detection single os reporting error code perfect 
manual verification randomly sampled test cases test case compared os implementations indicates approximately cases predicted silent failures technique silent failures 
approximately test cases mis classified os robustness due posix permitting discretion handle exceptional situation 
example permitted required return error address memory space fall page boundary 
due bugs library floating point routines returning false error codes 
example irix returns error tan correct result 
instances due overflow intermediate results returns error code fmod dbl max pi qnx returns error code due lack support required posix features qnx incorrectly returned errors filenames having embedded spaces 
remaining instances obvious error code reasonably required 
mainly concern passing pointer structure containing meaningless data operating systems sunos returned error code test case abort apparently checked data validity returned error code 
examining potential silent failures manually revealed software defects bugs generated unusual specified situations 
instance posix requires int int return error valid file open write ieee 
tested operating system irix implemented specified behavior os implementations failing indicate error occurred 
posix standard specifically permits writes files past eof requiring file length updated allow write ieee freebsd linux sunos returned successfully attempt write data file past eof implementation returned 
estimated failure rates problems quite low depending os definitely apparently caught process validating posix compliance 
second approach attempted detecting silent failures comparing test cases having error indication instances test case suffering abort failures os robustness os 
surprise turned revealing software defects identifying silent failures 
relatively small number total test cases generated abort failure operating systems completed error indication operating systems 
manual verification randomly sampled test cases indicated detection mechanism approximately false alarm rate 
part high false alarm rate second approach due differing orders checking arguments various operating systems related discussion fault masking earlier 
example reading bytes empty file null pointer memory location abort file checked attempting move byte return successfully zero bytes having read file checked moving byte 
part false alarm rate apparently due limitations floating point libraries 
instance freebsd suffered abort failure fabs dbl max fabs dbl max returned error 
estimated accuracy rates results reported reflect silent errors measured silent aborts measured compensating estimated false alarm rates 
manual examination techniques impractical gather larger sample percentages considered gross approximations believed reasonably accurate intuition gained sampling process 
frequent sources robustness failure robustness failures prevalent common sources 
source code operating systems tested available manual examination available source code search root causes robustness failures impractical large set experimental data 
best data available correlation input values robustness failures analysis causality 
test values frequently associated robustness failures invalid file pointers excluding null associated robustness failure null file pointers associated robustness failure os robustness invalid buffer pointers excluding null associated robustness failure null buffer pointers associated robustness failure integer values associated robustness failure maxint integer values associated robustness failure surprisingly system state changes induced particular test prove source robustness failures tests 
apparently separate process test case provided sufficient inter test isolation contain effects damage system state tests catastrophic failures 
verified vendors reproducing tests isolation single test programs verifying test results remained tests run different order test harness 
say problems don exist difficult elicit operating systems think 
issues attaining improved robustness preliminary testing results shown os vendors apparent developers took dim view sigsegv signal considered robustness failure 
fact cases developers stated specifically purposefully generated signals error reporting mechanism order difficult developers bugs 
hand developers provide extensive support wide variety error return codes attempts minimize abnormal task terminations system calls library functions 
importance comprehensive exception handling conversations application developers develop critical systems 
parts story relative strengths weaknesses philosophy goal robust return codes signaling exceptions attained practice 
signals vs error codes discussions os developers proven exception handling robustness controversial religious subject fact remains significant applications os robustness industries developers stated clearly fine grain error reporting extremely desirable signals accompanied task restarts unacceptable 
applications include telecommunication switches railroad train controllers real time simulations power supplies factory automation control ultra high availability mainframe computers submarine navigation name real examples encountered course project 
may intended application areas os authors fact cots os implementations pressed service critical systems meet cost time market constraints 
evaluating robustness os useful robustness required posix standard 
having said results reported suggest issues hand go preference signals vs error return codes 
issue simply divergence implementations hinders writing portable robust applications 
second issue operating systems examined succeeded attaining high degree robustness signals considered desirable exception reporting mechanism 
building robust systems traditionally software robustness achieved variety techniques checking error codes performing range checks values testing flush problems 
ballista robustness testing results eliminated hopes approaches entirely sufficient critical systems 
checking error codes os porting os minor version change os generates sigsegv error code generates error code response exceptional situation 
similarly clear posix functions perform cursory check null pointer values accomplished minimal speed impact 
vendor testing os implementations demonstrated simple ways cause system crashes major minor version changes 
useful additional step building robust systems api level fault injection performed ballista testing system 
minimum identify certain classes catastrophic failures manual intervention performed software os robustness wrappers screen exceptional parameters specific system calls permit application developers pay specific attention eliminating possibility situations 
library functions may possible alternate libraries specifically designed increased robustness 
example safe fast library sfio korn replace portions library 
system calls select existing os tends low failure rates shown abort failures primary concern 
find necessary add extra parameter checking wrappers system calls reduce silent failure rates 
application important realize abnormal task terminations expected matter course provide automatic recovery events 
applications sufficient attain reasonable level robustness 
applications merely way reduce damage caused system failure viable substitute robust error identification recovery 
potential long term approach increasing robustness os implementations modify posix standard include requirement comprehensive exception handling exception left undefined 
impose modest performance penalty viable optional specified extended feature set 
research performed quantify reduce associated performance penalties associated increased exception handling abilities 
summary os results ballista testing approach provides repeatable scalable measurements robustness respect exceptional parameter values 
total tests automatically generated posix function system calls spanning fifteen operating systems 
significant result operating system displayed high level robustness 
normalized rate robust handling exceptional inputs ranged low freebsd version high sunos version irix version 
majority robustness failures abort failures ranging signal sent system call library function causing abnormal task termination 
os robustness prevalent failures silent failures ranging exceptional inputs module test resulted erroneous indication successful completion 
additionally operating systems situation caused system crash response executing single system call 
largest vulnerabilities robustness failures occurred processing illegal memory pointer values illegal file pointer values extremely large integer floating point numbers 
retrospect really surprise null pointers cause problems passed system calls 
regardless single effective way improve robustness operating systems examined add tests null pointer values relevant calls 
application ballista testing approach measuring os robustness led insights 
documents divergence exception handling strategies error return codes throwing signals current operating systems may difficult write portable robust applications 
operating systems examined large number instances exceptional input parameter values resulted erroneous indication success system call library function complicate creating robust applications 
observations insights gained application ballista operating systems provided impetus remainder investigation described thesis 
clear developers interacted held strong beliefs tractability robust exception detection handling terms complexity performance 
response experimental results os vendors stated code robust possible complexity performance constraints 
real evidence contrary refute opinions determined investigate 
observations led directly questions addressed remainder research contained dissertation code robust fundamental limit claimed 
possible build robust systems losing significant performance 
os robustness fundamental problem education words developers understand robustness 
understand takes system robust 
os robustness hardening analysis math libraries user pressure provide fastest possible executable may lead developers leave run time data checks may prevent software robustness failures expense execution speed 
show hand waving argument checks sacrifice performance clear impact significant 
chapter presents attempt quantify penalty 
math library freebsd modified perform robust error detection handling separate version error checking handling removed created 
function level robust library performed average slower unmodified library average slower library error handling code removed 
application code written explicitly check return codes library function calls ran slower average application code neglected checks 
background result testing operating systems reporting robustness failures spurred great deal discussion tractability performance cost detecting gracefully handling exceptional conditions 
general consensus hard costly generated interest determining case 
simple expedient standard bsd source code chosen modification testing 
simple exercise remove existing error detection handling code add robust error handling code 
functions rigorously mathematically defined library enjoys having degenerate cases input ranges defined century 
table lists functions selected test 
functions selected function takes single double precision floating point number returns single double precision floating point number 
atan cos cosh erf exp floor gamma log sin sinh sqrt tanh table 
test function list math libraries simplified creation performance testing harness robustness testing ballista testing service 
distinct versions math library analyzed 
version original unmodified source code distributed freebsd 
second original code existing error checking exception handling removed 
third version original source modified robust 
robust version math library extensive acceptance testing added function form inline input filters 
filters determined operation completed return meaningful result complete causing floating point exception 
condition existed precluded successful completion function errno set con meaningful error message identifying exact condition preventing completion 
performance testing methodology performance libraries measured pentium mb main memory running freebsd 
source code compiled gcc version optimization switch 
single program written exercise functions listed table 
program code linked appropriate library robust stock non robust executed 
input values functions carefully chosen cause function complete successfully fall special cases 
resulted execution test checked exceptional conditions ensure measured cost enhancing robustness determined non exceptional case 
function tested time took execute function times loop measured 
test run times average reported 
method provided repeatable time measurement reasonable assurance time measured representative code speed 
complete procedure performed library robust non robust unmodified 
math libraries results cost associated making library robust compared non robust case 
standard math library faster robust version 
complete results relative performance library function call tested shown 
robustness library measured ballista tool determine relative performance respect software robustness 
results detailed table 
robust library average failure rate stock non robust failure rates respectively 
restart catastrophic failures detected 
analysis performance data taken libraries provide surprise robust library close unmodified library terms speed performance 
fact performance difference average 
slowdown relative stock iterations function 
performance variants normalized unmodified source 
math libraries stock robust non robust important realize unmodified library code perform fair amount error checking perform functions ensuring input parameter proper range function 
source performance penalty stock library versus non robust library 
lack checks cases result incorrect answer returned non robust library 
stock library performs checks cases forces floating point exception occur hardware error condition detected 
course causes os send application 
hand robust library implementation sets errno returns zero nan supported 
stock math library tested performed error checking required implement truly robust system 
checking performed order ensure correct answer 
added cost setting error code checking value completion extremely small math functions 
especially true considering penalty amortized total running time user application spends majority time processing code library 
non robust library error checking removed 
non robust version lower measured failure rate surface counter intuitive result 
effect caused fact stock library fair amount error checking purposefully generates signals response errors 
non robust library error checking 
means signals generated generated directly due hardware exception 
input yields undefined indeterminate results simply return answer wrong best 
robust stock library library library atan cos cosh erf exp floor gamma log sin sinh sqrt tanh table 
robustness failure rate math library variants 
math libraries summary math library robustness results represents attempt quantify performance cost building software system robust error detection handling 
argued results performance impact small compared large gains software robustness provided characteristics similar math library 
cost percent actual function call robust system implemented error return codes easy diagnose recover leave process defined state 
important reach results case math library error checking performed existing code base ensure correct functionality sufficient ensure robust operation 
paid price building robust system benefits 
addition instructions library completely robust average cost terms performance percent roughly ns average function call 
important step quantifying performance cost robustness 
hints result math libraries relatively specialized general performance cost building robust software systems drawn 
results suggestive logical step look software system complex 
higher complexity system tends complex data types memory structures 
complexity difficult fix robustness problems possibly sensitive performance issues 
searched software system complex stressed different aspect system architecture math libraries preferable thought hardened 
finding system met criteria allow see result little performance cost added robustness 
equally important pre hardened library give data point determine types robustness problems perceived difficult costly providing significant challenge assumptions methodologies 
math libraries hardening analysis safe fast safe fast io library developed research improves robustness factor stdio sacrificing performance 
largely accomplished optimizing stdio adding features operation safe robust 
robustness testing results able improve robustness critical sfio functions factor 
robustness measurement tool enabled quantifying reducing robustness failure rates factor standard functions average performance penalty measured original sfio benchmark scheme 
processor architecture improvements improve checking speed essentially eliminating performance obstacle improving software robustness 
sfio written decade ago attempt address issues speed safety robustness authors sfio able demonstrate high performance library time developed method quantifying robustness 
case library safer due design decisions method available quantify improved stdio 
furthermore discussions developers sfio revealed concerned performance impact increasing amount exception checking done code 
saw existence sfio opportunity gain initial understanding robust application programing interface api implementation design techniques metrics feedback actual performance penalty improving robustness point judged practical sfio developers 
ballista tool measure robustness sfio exceptional parameter values api level 
allowed quantify sfio robustness find significantly robust stdio room improvement 
common types robustness vulnerabilities sfio hardened improving robustness 
improved sfio fact performance problems sfio largely remedied optimizing common case result proved significantly robust original sfio slight performance penalty 
remainder chapter describes efforts identify fix general robustness failures sfio system quantify performance impact additional code added system failures 
additionally discuss types robustness failures expensive check near term processor architecture enhancements general purpose computing reduce cost improving robustness 
results initial robustness testing sfio discussed 
robustness test results hardened sfio 
benchmark results discussed initial hardened version unoptimized 
discuss results benchmarking sfio version hardening code optimized 
robustness testing sfio ballista testing suite measure robustness functions sfio api 
allowed objectively evaluate sfio library terms exception handling robustness 
test sfio existing data types posix tests created custom ballista test types capable generating tests cases sfio types sfio void 
types fit directly robustness stdio comparable sfio function sprintf fwrite fscanf fread fopen fileno fgetc fclose failure rate sfio stdio 
robustness failure rates sfio stdio compared functions direct functional equivalence measured linux test system 
failure rates digital unix lower sfio functions addressed section sfio ballista data type framework inherited functionality generic pointer type 
implementation simple exercise requiring hours implement types test types ballista framework ensure robust 
testing showed robustness sfio far better stdio sfio suffers fair number robustness failures critical io function write read 
analysis testing data showed broad causes sfio robustness failures 
specifically failure ensure file valid failure ensure file modes permissions appropriate intended operation failure check buffers data structures size accessibility problems case defective checking code software lack attempting check types exceptions 
identified potential causes failures addressed generic fashion important io functions occurred prefix indicates safe version corresponding stdio library call 
function able reuse parameter validation code specific failure mode reducing cost developing checks linear number parameter types number functions hardened techniques 
version call robust sfio functions ordinary attention paid performance emphasis placed reducing robustness failure rates 
shows percent abort failures percent test cases resulting abnormal task termination error code significantly reduced robust sfio software version 
file validity permissions relatively easily checked 
call fstat sufficient ensure file existed currently valid 
determined valid call sufficient obtain flags sfio permissions associated file 
checked intended operation errors flagged returned accordingly 
abort failure rate select functions open write read close fileno seek stdio original sfio robust sfio function 
abort failure rate select sfio functions linux checking valid buffers data structures difficult 
sfio provides information ensure buffers data structures valid possibility de referencing invalid memory pointer performing checks checks simply failing detect potential problem 
posix standard gives assurance task state valid memory access fault validated memory prior function execution read write memory structure stride size memory page size architecture code executed 
allowed catch exceptions validation stage modifying system state eliminating issues performing rollbacks dealing partial completion functions event exception resulted error code successful completion function 
sfio mechanisms described lee set perform signal handling call basis 
time consuming setting global handlers ensure exact state program time signal known 
reduces complexity signal handlers recovery exceptions easier design code 
shows abort failure rates modified functions treatment 
failures remain modified functions represent cases data values passed functions corrupted manner difficult check data structure bounds checking pointer checking similar techniques 
unmodified sfio library average normalized abort failure rate uniformly weighting function failure rates test cases functions tested 
underlying operating system affect robustness testing showed normalized failure rates sfio running digital unix functions interest 
robust sfio library average failure rate digital unix linux modified functions 
robust sfio library achieve perfect robustness failure prevention significantly better stdio original sfio 
additionally possible robust sfio improved employing techniques detecting invalid memory structures techniques austin 
techniques performance penalty proposed architectural benchmark name description file size linux alpha copies file succession reads writes mb mb getc reads file byte time mb mb putc byte time mb mb read reads file mb mb reads file reverse block order seeks random file position reads block writes block position file number bytes equal mb mb read written mb mb write writes mb mb table 
sfio benchmark descriptions sfio support identify bad data situations 
robustness improvements practical supported generations microprocessor hardware 
performance results evaluation sfio completed key functions hardened measured performance original hardened versions compared stdio 
measure performance robust sfio functions benchmarks table described authors original sfio korn 
results averages benchmark runs figures execution time variance runs negligible 
run consisted single complete execution benchmark 
benchmarks run diverse architectures different development goals 
test system mhz dual pentium ii processors mb ram executed redhat linux version kernel smp gnu stdio library version 
second system alphaserver mhz processors gb physical ram running digital unix libc version 
elapsed time 
elapsed time benchmark running architecture stdio original sfio robust sfio unoptimized robust sfio sfio table describes operations performed benchmark block size 
benchmarks suffix appended name block size bytes 
reason different transfer sizes due difference machines configured 
chose sizes large ensure data cached main memory re read disk run 
linux platform run smaller benchmarks alphaserver keep execution times reasonable 
goal different testing platforms directly compare performance hardware questions platforms os developers divergent philosophies goals 
digital unix proprietary operating system developed provide maximum throughput optimized small number architecturally similar advanced processors fast io hardware 
linux open source os runs wide range hardware platforms intel workstations ibm system mainframes 
side effect targeting wide range architectures linux performance enhancements included code base due problems cross platform compatibility 
argued linux widely small scale server applications occasionally larger scale ones commonly workstation elapsed time axp alpha stdio original sfio robust sfio 
elapsed time benchmark running axp alpha architecture sfio os optimized latency raw throughput 
commodity pc hardware extremely cost sensitive high system sacrifices significant bandwidth potential keep costs 
hope satisfactorily showing cost achieving high degree robustness low diverse systems similar techniques systems design points fall extremes 
block io benchmarks perform io large files mb linux platform mb alphaserver 
byte io benchmarks mb file mb linux alpha systems respectively 
seek benchmarks performed linux alpha seek read write operations totaling mb mb respectively 
cases orders magnitude greater original sfio benchmarks published original sizes tended result files entirely cached memory buffers completed quickly accurate measurement 
expected performance penalty original implementation robust sfio cases substantial 
execution times getc putc benchmarks especially long 
result tends support contention past certain point robust exception handling simply costs terms performance worthwhile 
sfio find optimal point performance improved close stdio large gains robustness exception handling ability 
reflection determined address performance concerns try obtain additional exception handling low cost possible 
obvious place look performance optimization getc putc 
obviously overhead checks significant negative impact performance 
part due structure code put handle exceptional conditions 
time byte read written signal handling context set sfio data structure validated terms memory accessibility file existence setup 
demonstrates robustness checks adversely affect performance applied thought actual usage 
able largely eliminated speed penalty performing checks byte wise getc putc 
sfio speed robust versions getc putc applied variation optimistic incremental specialization pu 
idea technique generated code optimized guaranteed system state 
similar common programming adage optimize common case specialized robust sfio implementation case file buffer io times moving perform io different file 
case performing byte time io 
simplifying design choice easily designed implemented different common case complicated caching scheme 
speed getc putc added caching validated results sfio data type pointer sfio buffer pointer data types 
function successfully validates types values cached comparison 
functions close destroy types reset cached values null value 
execution values parameters passed execution compared cached values 
functions types match cached values pass comparison 
similarly functions types match corresponding cached value 
event parameter interest match cached values checks bypassed 
includes skipping construction exception handling context function call 
elapsed usr sys benchmark relative relative relative name original robust speed original robust speed original robust speed write write read read putc getc table 
usr sys elapsed time data original hardened sfio intel architecture sfio way overhead reduced single branch case structure succession initial penalty checks paid 
table gives complete user system level performance information original sfio final robust sfio incremental specialization described 
previous performance data values average complete runs 
total process time broken user system components measured libc function call time 
analysis surprise performance data clearly show common operations selected additional hardening io bound 
typical modern super scalar machine cpu io bound simple memory requests 
done improve griffin io speed catch speed processing unit near mid term 
hardening io functions accomplished basically free latency computational tasks 
processing time usr sys intel 
total processing time benchmark architecture stdio original sfio robust sfio sfio particular file operations state rich require error checking handling latency added increasing ability functions handle exceptions behave robust manner hidden latency operations 
block file operations suffer execution time penalty percent compared robust implementations 
elapsed time benchmarks run completion tell part story isn simply look data 
elapsed time hides intricacies going inside os hardware critical performance system especially throughput limited operating environments 
time spent io wait perform useful multi tasking system 
figures show total time spent performing computation usr sys time io wait time hardened sfio cases stdio block size copy benchmarks stdio linux 
sfio implementations actual processing time stdio alphaserver processing time usr sys compaq axp 
total processing time benchmark axp alpha architecture stdio original sfio robust sfio sfio platform read elapsed time tended close slower stdio 
indicate digital unix stdio libraries perform fair amount processing optimize disk transfers born fact benchmarks spend time io wait stdio libraries 
infer disk transfer scheduling optimizations consume far cpu cycles increased robustness checks 
benchmark significant performance shortfall sfio implementations 
stdio libraries able avoid memory copy sfio libraries performing 
supported data nearly extra time manifests system time typically large block memory copies measured 
processing time penalty paid robust sfio compared original sfio consists largely occasional exception handling context setup parameter checks 
addition penalty constructing exception handling contexts occurs parameters require validation mandatory penalty represents check determine validation done 
expect processing cost checks diminish significantly near 
penalties incurred penalty determining validation occur completely negated improved hardware branch prediction available new processors soon fragmenting block size branch affect performance rotenberg 
achieving requires creating compiler structure exception checking code sequences way help cpu predict exceptions occur technical reason difficult accomplish 
processors trace cache rotenberg intel pentium processor lessen cost additional checks allowing unit fetch past branches may throttle fetch bandwidth 
advanced checking caching techniques degrade performance ways trace cache help multi branch direction traces anticipate techniques solve problems incorporated processors near 
include techniques completion time multiple branch prediction sfio block caches black 
general reasonable expect exception checking branches easily predictable non exceptional code path increasingly efficient processor hardware incorporates predictive execution capabilities 
robust sfio libraries achieve dramatically reduced robustness vulnerabilities compared stdio original sfio implementations 
latency bound applications performance impact providing extra robustness minimal 
throughput bound applications moderate increase cpu time perform extra checking routines minimized caching check results 
furthermore cpus increase concurrency branch prediction speed penalties performing exception checking decrease dramatically time 
summary ballista robustness testing tool find address robustness problems safe fast library sfio able improve robustness code average factor treated functions despite fact sfio improves robustness stdio robustness order magnitude 
achieved robustness level approximately robustness failure rates compared failure rates stdio 
remaining failures generally involve incorrect corrupt data valid data structures speculate failures dealt better interface design 
contrary commonly held opinion robust software need come price reduced performance 
data show performance penalty providing thorough exception handling error handling tends low terms elapsed time similarly small terms processing overhead 
robust sfio avg 
slower ordinary sfio providing better robustness 
furthermore near term architectural improvements processors tend reduce costs providing robust exception handling exploiting fact exception checks readily predicted executed concurrently mainstream computations 
sfio hardening analysis operating system internals theory techniques developed building high performance robust systems successfully applied io bound sfio cpu bound software systems 
establish generality approach third domain identified treated chapter examines application techniques developed implementing high performance robust systems operating system services 
robustness software system argued dependant robustness underlying system 
system despite best effort attention detail creators may doomed low robustness due non robust underlying operating system 
speed terms latency throughput critical deciding factor evaluating operating systems 
operating system robust sacrificing performance spending time money application level code may questionable virtue 
commonly elements linux api memory process synchronization modules selected study 
method hardened robustness failure rate measured ballista 
resulting modules suffered performance loss lightweight synthetic application benchmark compared non robust libraries 
robustness testing linux order determine best system areas target robustness hardening ballista robustness benchmarking tool run linux api 
results complete tests appendix system calls linux kernel improved robustness releases areas traditionally thought hard address left state critical including process synchronization memory buffer manipulation 
example illustrated semaphore module linux implemented outside kernel thread library relatively poor response exceptional conditions os internals failure rates memory process synchronization methods average failure rate normalized function call 
memory manipulation functions average failure rate normalized function call 
hard areas interesting execution speed critical commonly modern software systems support multiple threads control 
additionally problems areas dire consequences making addressing problems potentially high impact activity 
testing benchmark results chapter executed dual intel pentium iii mhz processor machine mb ram running linux glibc 
hardening select linux api calls earlier efforts ability address problematic areas robustness structure memory validation limited 
partially due fact software systems looked previously suffer failures type 
math libraries failures areas due lack complex structures buffers 
sfio solved fair number os internals mem 
manipulation module process synch 
module function name 
initial failure rates memory manipulation process synchronization methods problems internally maintaining speed removing inefficiencies standard io systems 
number failures encountered small 
contrast process synchronization functions obviously memory manipulation functions memcpy suffer large numbers failures troublesome areas 
failure previous techniques techniques developed earlier fell short ability address class robustness failures prevalent modules 
checks satisfied requirements largely systems partially hardened sfio sufficient 
contains results initial hardening select linux api calls techniques developed hardening math sfio libraries 
earlier methods adequate simpler functions memory functions exhibited failures 
instances memory locations manipulated valid areas process read write permissions overwriting simply cause process fail result data process corruption 
failure rates memory process methods initial treatment function name os internals 
failure rate memory process synchronization functions initial treatment unfortunately failures exceptionally difficult deal due limitations way systems tend organize allocate memory 
systems widely windows os operating modes developers force allocation routines put memory separate isolated memory pages 
aids detecting faults testing improve robustness run time issue deployed service systems running normal mode 
easy fast way process tell write memory area safely system deployed running normal operational mode 
prior proposes methods building special purpose hardware micro architectures compiler tools aid determination structure memory location allocated properly correctly initialized 
unfortunately approach results substantial speed penalty special purpose hardware available 
recognizing micro architecture community seriously address issues fault tolerance reliability hardware enhance robustness included short term 
believe represents fundamental limitation ability design fast robust system imposed design api 
possible design elements allow safe testing structures buffers determine safe result substantial speed penalty certainly occur somewhat ad hoc manner 
approach enhanced memory robustness checks approach overcome situation create version malloc added application transparent byte tag dynamic structure created 
tag allowed store information regarding size validity 
building structure facilitates fast lookups tag structure malloc returns pointer memory offset tag size 
altered malloc helps address fundamental robustness limitation os internals verification static offset eliminates need complex indexing calculations 
essence adding internal state malloc keeps allocated memory 
malloc keep size information information lists memory blocks hidden process 
provide mechanism state memory block exposed robustness checking code 
process requests memory location validated added data determine memory properly allocated sized 
possibility context aware checks possible embedding information tag 
shows results hardening advanced memory checking validation techniques 
functions completely hardened robustness failures detectable current suite robustness tests 
performance analysis hardened code system robust 
system fast meet performance goals robust 
course performance goals failure rates memory process methods final treatment function name 
failure rate memory process synchronization functions final treatment os internals non embedded applications fast possible overhead kept absolute minimum 
developed variation technique known optimistic incremental specialization described pu enhance performance sfio 
simple approach worked io routinely done large blocks caching single validation cheap effective 
performance impact hardening sfio average 
process synchronization memory manipulation functions tend different profile 
approach sfio adapted function environment resources conjunction varied sequences complicating matters significantly 
robustness check cache address issues traditional cache style approach 
allows construction arbitrarily sized structures track number resources validated robustness checks invalidated various operations free sem destroy 
robustness check cache implemented entirely software required special hardware support 
operation check cache close parallel traditional verification module result lookup store clear module 
software implemented robustness check cache invalidate che structure memory os internals data instruction caches illustrated 
robustness check successfully performed structure validation module address placed cache indexed low bits 
complete set robustness checks performed cache checked 
successful hit bypasses checks 
function destroys critically modifies structure object calls clear module causes appropriate cache entry invalidated 
iterative benchmark order worst case application slowdown performance robust system functions measured simple iterative benchmarks 
mean performance methods measured repetitive calls method benchmarked useful calculations performed calls 
words asked slowdown function call times row simple slowdown robust semaphore functions respect number semaphores check cache size sem init sem destroy sem getvalue sem post sem wait sem semaphore objects sem init sem destroy sem getvalue sem post sem wait sem 
iterative performance slowdown robust process synchronization functions os internals iterative benchmarks small cache demonstrate smaller optimized cache improve performance 
performance results show treated function performing poorly compared non robust function 
functions include sem init slowdown sem destroy slowdown sem getvalue slowdown 
functions represent hardware instructions get value just address calculation read needed add read integer operation compare branch 
overhead high show represents cycles actual cpu time 
additionally original code small relation code added robust think measured overhead smaller 
effect indicative checks hidden existing microarchitecture reduced chip generations intel pentium 
complete treatment expectation section 
shows performance robust memory functions 
small buffer sizes overhead exception memset 
memset slowdown robust memory functions enhanced malloc buffer size bytes 
iterative performance slowdown robust memory functions memcpy memset os internals heavily optimizable especially small buffer sizes 
obviously buffer lengths increase overhead reduced 
lightweight synthetic application benchmark iterative benchmarks useful illustrating worst case performance bound individual process synchronization functions 
memory functions perform complete task semaphore functions tools facilitate coordination 
functions specific sequences 
obtain clear picture performance impacted manner consistent lightweight synthetic benchmark created 
benchmark performs significant computation purpose call sequences process synchronization functions consistent normal 
contains code benchmark 
brief simply creates semaphores obtains releases locks small intermediate computation dequeuing integer value 
purpose benchmark avoid overhead making functions robust cost complex computation 
illustrates overhead process synchronization isolated function call presents pessimistic operational scenario 
create semaphores create empty queue foreach semaphore obtain lock enqueue integer value dequeue integer value foreach semaphore release lock 
pseudo code lightweight synthetic benchmark shows results synthetic application benchmark small cache size 
average slowdown 
approaches performance impact sem wait sem post tested isolation 
expected functions worst performance penalty typically called course applications sem init sem destroy 
sem wait sem post primary os internals slowdown synthetic application benchmark sem verses number semaphore objects cache size functions test set semaphores process control purposes dominate performance synthetic application 
semaphores 
slowdown synthetic benchmark robust process synchronization functions second experiment run look scalability approach system requires checks done large numbers objects larger cache 
increase cache size increases slightly cost managing cache wider range performance cache fills increasing number conflict misses occur 
performance code cache robustness checks quite slowdown average addresses involved 
performance tapers penalty typical cache manner number addresses increases causing conflict misses 
expected number addresses involved exceeds cache capacity performance drops rapidly capacity misses force increasing numbers checks performed 
indexing accomplished doing address calculation explicitly allowing compiler generate array index operation 
os internals slowdown vs number semaphore objects cache size entries semaphores 
slowdown synthetic benchmark robust process synchronization functions large cache size data shows range speed critical os services functions enhanced extremely robust conservatively attainable speed penalty light weight synthetic application benchmark 
iterative benchmarks show worst case slowdowns 
clear average case synthetic benchmarks show lightest weight application penalties approach lower worst case bound 
software system performs non trivial computation see near zero overhead 
actual overhead nanoseconds determined figures 
average absolute overhead nanoseconds process synchronization functions nanoseconds memory functions small cache size 
small cache synthetic application overhead average ns full cache 
large cache os internals sem sem wait sem post sem getvalue sem destroy sem init average robustness overhead process synchronization functions ns nanoseconds 
absolute robustness overhead process synchronization functions nanoseconds overhead increases average ns full cache increasing ns cache capacity 
note measured overhead synthetic benchmark includes overhead pair calls sem wait sem post 
overhead order cycles protected call representative index calculation branch resolution wasted fetch bandwidth 
microprocessor test platform incapable fetching past branches correctly predicting branch induces penalty 
advances architecture block cache black multiple branch prediction branch predication effectively reduce overhead near zero 
robustness checks performed completely parallel useful computation predicated 
fetch bandwidth preserved block cache multiple branch predictors 
code highest degree parallelism utilizes hardware resources drop performance 
level parallelism seldom seen usually occurs tightly optimized loops computational algorithms 
os internals memset memcpy average robustness overhead call nanoseconds overhead ns 
absolute robustness overhead memory functions nanoseconds course code sections need robustness checks method entry method guaranteed receive known valid data 
os internals understanding robustness chapter examines experienced developers understand exception handling characteristics code 
look results testing dod simulation framework known hla rti developed explicit goal having undefined generic exceptions possible 
look series java components ibm component library 
data collected developers thought code respond exceptional conditions contrasted robustness measured ballista 
results indicate industrial developers predict exception handling characteristics software systems may ability write robust software systems better training area exception handling exceptional conditions 
robustness concept addressed programming software engineering classes maxion 
idea testing software linked idea system successfully tested reasonably sure provides correct output normal input 
unfortunately philosophy overlooks entire class failures resultant exception inputs conditions exception detection handling code tends tested understood parts entire software system christian 
thirds system crashes traced improperly handled exceptional conditions christian reason failures occur certain 
possibilities exist including classics hard check slow robust happen third party application number 
simple human error possibility 
system developer designer may intended handle exceptions simply mistake 
errors fall categories errors commission errors omission swain 
exception checking handling code designed implemented incorrectly commission simply omitted omission 
thorough treatment topic maxion posits exception handling failures test groups errors omission due simple lack knowledge exposure developer understanding exceptions exceptional conditions exception handling maxion 
maxion provided material groups information exceptions exception conditions mnemonic jump start thinking topic help remember exception checking 
maxion able show significant improvement exception handling characteristics treatment group software compared control group 
process known priming 
clearly demonstrates ordinary students understand robustness exception handling obvious question regard maxion professional developers understand robustness exception handling characteristics code 
important issue address succeed helping developers create robust software systems need better insight robust systems built today 
chapter examines experienced developers understand exception handling characteristics code 
look results testing dod simulation framework known hla rti developed explicit goal having undefined generic exceptions possible 
look series java components written various corporate development groups ibm research 
data collected developers thought code respond exceptional conditions contrasted robustness measured ballista 
dod high level architecture run time infrastructure dod high level architecture run time infrastructure hla rti standard architecture distributed simulation systems 
developed department defense facilitate model simulation reuse interoperability 
simulations run disparate network may include disparate components variety vendors 
reason framework desired completely robust dod 
hla adopted facility distributed simulation systems object management group omg november approved open standard institute electrical electronic engineers ieee ieee standard september 
developer understanding robustness explicit design goal argued developers reason identify handle possible exceptional conditions 
remaining exception handling failures result human error design decision 
access source code extensive review determination errors commission omission 
assuming standard practice code reviews adequate testing accomplished majority failures occurred due errors omission 
rti extensively tested range versions operating systems 
give resultant failure rates rti version solaris digital unix respectively 
rti functions tested roughly half failures 
failure rates low compared operating systems functions large failure rates 
robustness failures rti sun os rti restart segmentation fault unknown exception rti internal error exception rti functions alphabetical rti 
robustness failure rate rti sunos 
average failure rate 
developer understanding failures diverse ranging problems mutex locking algorithms infinite loops unwind crashes exception handling code 
broad failures assumption due errors omission classes exceptional conditions designers developers rti think anticipate 
commercial java objects rti results show specification mandated robustness developers didn quite deliver fails help address question developers understood characteristics code 
spec required robust operation assume developers thought system robust 
necessarily case speculation 
robustness failures rti digital unix rti rti rti functions alphabetical better address issue production java components selected developers reported expected robustness component 
components restart segmentation fault unknown exception rti internal error exception 
robustness failure rate rti digital unix 
average failure rate 
developer understanding unknown robust semi robust robust computational concurrency div domain overflow underflow mt unsafe response hardware file disk resource unreachable corrupt memory resource exhaustion file file permissions wrong file corrupt file moved deleted invalid filename file exists file locked library function shared object library incorrect version incorrect parameters data input empty data file incorrect delimiter data invalid return values args data values invalid wrong arguments wrong type arguments external wrong command line wrong response prompt response prompt workflow overload null ptr memory null ptr ptr points invalid data insufficient memory allocation error buffer overflow 
sample report form tested java version ballista written specifically purpose 
results compared expected robustness 
developer understanding self report format order allow development group report component expected response exceptional conditions taxonomy failures developed 
taxonomy borrows heavily developed maxion maxion 
minor changes required order better fit object safety models inherent java 
major categories retained order maintained preserve original mnemonic structure children 
essential specific study done continuity respect original 
example form report expected robustness method component 
specific example represents true response measured earlier ballista 
categories listed rows expected response exceptional conditions reported columns checking appropriate box 
row check column default assumed mean inapplicable 
self report data form finalized built lotus notes database placed service ibm center software engineering research yorktown heights ny 
data collected ibm research period weeks 
tables contain expected response components rated development teams 
condition response div nr domain overflow underflow data invalid data values invalid wrong num args wrong type args null pointer pointer invalid data insufficient memory table 
expected robustness response component method condition overflow underflow data invalid sr data values invalid sr overflow underflow data invalid sr data values invalid sr overflow underflow data invalid overflow underflow data invalid table 
expected robustness response component method condition response overflow underflow data invalid overflow underflow data input overflow underflow data input overflow underflow data input table 
expected robustness response component developer understanding component consists methods expected robustness 
response column stands robust response sr semi robust nr robust silent failure sub category robust 
semi robust means response error code language supported exception leaves program indeterminate state 
test results components comprising discrete methods rated development teams tested ballista 
components labeled written teams respectively 
component robustness function 
robustness failure rates components results testing components 
average failure rates respectively 
method suffers abort failure due invalid data memory conditions marked semi robust occur due language constraints placed testing system impossible create corrupt data certain base level data types teams anticipated divide zero failures 
contains test results object constructors component measured expected contains test results component methods 
average failure rate developer understanding 
methods separated classifications calculation merely return object data specific form data type 
analysis component constructor robustness constructor parameters 
component constructor abort failure rates parameter rti development team delivered fairly solid code failure rate approximately versions examined 
solaris version suffered high rate abort failures apparently due underlying problem language exception system solaris 
digital unix version suffered similar failure profile converting nearly abort failures unknown exception failures 
rti team thought handled possible exceptions correctly 
drawn anecdotal evidence developed reading specification conversations project engineers 
testing results failures fixed suitable tests added rti regression test suite 
measured expected teams closely estimated system respond exceptional conditions 
exception single failed pointer check instance expected robustness matched measured robustness systems 
excludes conditions generated due language constraints check presence failures result invalid base data types 
developer understanding evident test data component suffered abort failures roughly methods 
team indicated failures resultant divide zero exceptional conditions handled correctly 
fact suffered failures common software including memory data corruption issues failing handle legal degenerate data conditions 
prevalent exceptional conditions handled correctly caused values extreme legal ranges 
normally detectable ballista tool number silent errors detected component detected resultant values method calls returned error caused subsequent robustness failure test cleanup 
consider example attempt allocate memory failed returned non null value error condition indicated 
system attempts free memory 
abort failure result 
component robustness designation indicates type conversion method vs calculation method 
component abort failure rate developer understanding obvious observation robustness memory release method conclude allocation method suffered silent failure 
essence flag error allowed propagate system cause damage program execution 
example manifested abort failure 
potentially worse simply caused system wrong thing say deploy crash occurred vehicle traveling speed highway 
contains silent failure rate component input conditions induce silent failures examined case 
failures caused conditions caused abort failures methods 
silent failures usually indicative incomplete range testing algorithmic bounds 
case fact silent failures occurring abort failures suggests development team cohesive strategy addressing exceptional conditions approach uneven ad hoc best 
component silent failures 
component silent failure rates method designation developer understanding contains total expected failure rates component non constructor methods 
average measured failure rate 
methods computationally susceptible expected failure divide zero 
expected failure rates calculated determining percentage tests result divide zero 
functions listed expected failure rate susceptible expected failure 
component suffer expected divide zero failures 
group anticipated failures ones occurred 
component total failure rate method designation 
total failure rate component measured expected results testing systems written distinct programming groups ranging complexity small utility module full blown distributed simulation frameworks 
case know development teams thought systems respond exceptional conditions inference case rti team survey case developer understanding corporate development groups 
groups able classify code respond exceptional conditions reasonable extent 
overestimated robustness systems significant degree 
data provide evidence support maxion maxion applicable professional development teams 
contrary popular wisdom hard won industry experience guarantee team possesses knowledge required build robust system capable handling exception conditions graceful manner 
anecdotal results considered conclusive provide useful evidence may help shape direction experimentation area 
outstanding questions include individual responsible reporting expected robustness position feel code base 
junior management far removed really know 
java ides build exception handling wrappers applications mask exceptions 
possible teams environments visual age java fact testing conditions caught ignored application level exception handler 
acknowledgments special ibm implementing idea developer self reporting collecting data teams allowing dissertation 
particularly melissa writing lotus notes database data reporting collection peter going development teams getting cooperation matter 
developer understanding focused gaining better understanding exception detection handling 
specifically established quantitative relationship performance cost robust exception handling wide range software systems arguably general scope determined performance penalty associated robust code low 
measured ability set professional developers accurately classify exception handling abilities software systems determined particular case study maxion hypothesis developers specific training topic fully grasp exceptional conditions hold 
developed generic models common exception failures developed generically applicable methods fix 
contributions contributions tractability proves common robustness problems fixed contrary popular wisdom generality presents new methodology address robustness problems sacrificing performance speed establishes performance cost making software system robust negligible developer understanding provides case study data collected corporate development groups supporting assertion maxion hypothesis hold true professional developers tractability generality course developing preceded included dissertation clear robustness failures stem memory issues instance improperly referenced memory 
smaller number failures manifest structure state instance file status permissions 
fewer result algorithmic boundary conditions instance attempting calculate inverse sine 
dominant form failures memory addressed generically application function developed part 
function associated structures greatly reduce number robustness failures significant performance loss 
easily included system provides robust recoverable exception detection handling 
structure easily extensible provide context aware exception checking arbitrary structures 
speed distinct software system domains protected hardening techniques developed benchmarked performance 
cost average hardened math functions hardened io functions os service primitives 
exception io benchmarks benchmarks stressed actual calls tested building realistic application 
reason believe costs reported conservative suspect true cost system implementation lower real application code 
additionally newer micro architectures hide latency checks better processors block caches predication multiple branch prediction prevalent 
developer understanding analyzed data collected distinct development groups reporting expected software systems respond exceptional conditions 
systems tested measured robustness related expected values 
additionally group design mandate robustness included testing portion analysis self report data 
sel reporting groups able classify robustness software systems reasonable degree 
rti group mandate build robust code left abort failure system 
group anticipated nearly robust system reality average failure rate 
conclude particular experiment scientifically rigorous experimental method provides useful data point validating extension maxion hypothesis professional development teams 
addresses critical outstanding issues regarding robustness building robust software systems needs done 
look outstanding issues directly related 
architectural improvements assert advanced microarchitectural features result faster determination data exceptional normal 
unfortunately bulk completed just prior new systems available 
assertion performance cost decreases architectural enhancements available needs validated 
additionally depth look robustness checking code done microarchitectural level 
investigation simulator tools simplescalar provide better insight better structure software take maximum advantage hardware features 
natural extension help identify potential enhancements architecture speed robustness checks 
compiler support shown techniques generally applicable software 
logical step build specific support robustness checks compiler 
allow maximum protection minimum effort hiding complexity checking structure 
controlled study case study professional developer understand robustness response software systems 
maxion performed careful scientific study university programming teams scientific study involving professional teams 
study huge undertaking establish certainty need better education respect exception conditions exception handling 
validate hypothesis developers learn exception handling current educational processes reliably design develop robust software systems 
tool integration tools techniques joined scripts manual manipulation 
wide scale adoption techniques occur built consolidated coherent cross platform toolset 
undertaking large scope enable broader base practitioners methods 
detailed performance evaluation benchmarks evaluate performance impact pessimistic upper bound actual overhead unknown 
implications changing memory footprint system adding tags allocated memory software cache clear 
research area give insight performance robust code enhanced 
austin austin breach sohi efficient detection pointer array access errors conference programming language design implementation pldi acm sigplan avizienis avizienis version approach fault tolerant software ieee transactions software engineering vol se barton barton segall siewiorek fault injection experiments fiat ieee transactions computers beizer beizer black box testing new york wiley black black bryan john paul shen block trace cache proceedings th annual international symposium computer architecture isca buhr buhr peter mok russell advanced exception handling mechanisms ieee transactions software engineering vol 
number carreira carreira madeira silva xception technique experimental evaluation dependability modern computers ieee transactions software engineering vol random input testing formal publication available ple delphi com html accessed july cristian cristian exception handling tolerance software faults software fault tolerance michael lyu ed 
chichester wiley 
pp 
ch 
feather segall siewiorek fault free performance validation multiprocessors proceedings ieee aiaa th digital avionics systems conference fort worth tx usa oct pp 
fujimoto department defense high level architecture proceedings winter simulation conference winter conference board directors san diego ca koopman ballista software robustness testing service th international conference testing computer software 
pp 
measuring robustness fault tolerant aerospace system th international sym fault tolerant computing june 
pp 
portable robustness benchmarks ph thesis dept electrical computer engineering carnegie mellon university pittsburgh pa may dod department defense high level architecture run time infrastructure programmer guide rti version dec saic virtual technology dony dony improving exception handling object oriented programming th international conference computer software applications workflow modeling exception failure handling representation th international conference society computer science koopman robustness testing distributed simulation backplane th international symposium software reliability engineering november garcia garcia exception handling mechanism developing dependable object oriented software meta level approach th international symposium software reliability engineering garcia garcia exception handling software architecture developing fault tolerant software th international symposium high assurance system engineering gehani gehani exceptional exceptions software practice experience ghosh ghosh schmid approach testing cots software robustness operating system exceptions errors proceedings th international symposium software reliability engineering goodenough goodenough exception handling issues proposed notation communications acm december software fault tolerance functional programming th international conference computer software applications griffin griffin schlosser ganger nagle modeling performance mems storage devices international conference measurement modeling computer systems acm sigmetrics hagen hagen alonso flexible exception handling opera process support system th international conference computing systems hastings hastings joyce purify fast detection memory leaks access errors proceedings winter usenix conference hill hill faults functions algol fortran computer journal august hof hof zero overhead exception handling metaprogramming proceedings th seminar current trends theory practice informatics hofstede hofstede barros specifying complex process control aspects workflows exception handling th international conference advanced systems advanced applications hull hull cohen exception handling scientific computing acm transactions mathematical software vol 
september ieee ieee standard binary floating point arithmetic ieee std institute electrical electronics engineers ieee ieee standard glossary software engineering terminology ieee std ieee computer soc dec ieee ieee standard information technology portable operating system interface posix part system application program interface api amendment realtime extension language ieee std ieee computer society jones jones ed 
apollo lunar surface journal apollo lunar landing entries national aeronautics space administration washington dc kanawati kanawati kanawati abraham ferrari tool validation system depend ability properties ieee workshop fault tolerant parallel distributed systems 
amherst ma usa july pp 
koopman koopman sung siewiorek comparing operating systems robustness benchmarks proceedings symposium reliable distributed systems durham nc oct pp 
koopman koopman comparing robustness posix operating systems th fault tolerant computing symposium june pp 
koopman koopman exception handling effectiveness posix operating systems ieee transactions software engineering vol korn korn vo sfio safe fast string file io proceedings summer usenix conference june pp 
koopman siewiorek automated robustness testing shelf soft ware components th fault tolerant computing symposium june pp 
lee lee exception handling programs software practice experience 
vol leveson leveson turner investigation accidents ieee computer vol lions lions 
chairman ariane flight failure report inquiry board european space agency paris july martin lopes cristina study exception detection handling aspect oriented programming proceedings international conference software engineering maes maes concepts experiments computational reflection conference object orientated programming systems languages applications oopsla maxion maxion improving software robustness dependability cases eighth annual international symposium fault tolerant computing ftcs craft software testing prentice hall miller miller empirical study reliability operating system utilities communication acm december miller miller koski lee murthy natarajan fuzz revisited re examination reliability unix utilities services computer science technical report univ wisconsin madison may mukherjee mukherjee siewiorek measuring software dependability robustness benchmarking ieee transactions software engineering june musa musa irving operational profile lyu 
ed handbook software reliability engineering mcgraw hill ieee computer society press los alamitos ca pp 


www com products bounds accessed omg object management group common object request broker architecture specification revision july ostrand ostrand category partition method specifying generating functional tests communications acm para 
insure 
www com products insure index htm accessed pu pu black consel cowan inouye walpole ke zhang optimistic incremental specialization streamlining commercial operating system proceedings fifteenth acm symposium operating systems principles sigops ryan black bryan shen john completion time multiple branch prediction enhancing trace cache performance th annual international symposium computer architecture isca rational rational 
purify 
www rational com products index jsp accessed exception handling framework version programming object oriented systems proceedings third ieee international symposium object oriented real time distributed computing rotenberg rotenberg eric bennett steve smith james trace cache low latency approach high bandwidth instruction fetching proceedings th annual ieee acm international symposium computer architecture isca shen siewiorek zhu experimental evaluation concurrent error detection schemes digest papers 
th annual international symposium fault tolerant computing systems vienna austria july pp 
sedgewick sedgewick robert 
algorithms 
addison wesley shelton shelton koopman robustness testing microsoft win api proceedings international conference dependable systems networks 
dsn siewiorek siewiorek hudak suh segal development benchmark measure system robustness rd international symposium fault tolerant computing june 
pp 
srivastava srivastava eustace atom system building customized program analysis tools research report wrl digital western research laboratory palo alto ca swain swain handbook human reliability analysis emphasis power plant applications technical report cr nuclear regulatory commission thekkath thekkath hardware software support efficient exception handling sixth international conference architectural support programming languages october tsai tsai iyer measuring fault tolerance fault injection tool proceedings eighth international conference 
modeling techniques tools computer performance evaluation heidelberg germany sept springer verlag pp 
uhlig uhlig nagle mudge emer instruction fetching coping code bloat proceedings nd annual international symposium computer architecture june acm new york pp 
vo vo wang chung huang software instrumentation method exception handling eighth international symposium software reliability engineering albuquerque nm usa nov pp 
kong efficient memory access checking third international symposium fault tolerant computing ftcs kong concurrent detection software hardware data access faults ieee transactions computers vol beizer black box testing new york wiley zilles zilles emer sohi multithreading exception handling proceedings nd annual acm ieee international symposium microarchitecture appendix complete robustness failure rates linux kernel 
call rate call rate call rate call rate call rate abs rmdir access labs sched get priority max sched get priority min alarm fgetc sched link sched asin sched atan fileno log sched strstr atan floor log sem close fmod longjmp sem destroy strtok atoi fopen sem getvalue malloc sem init calloc fprintf sem open ceil sem post fread sem tan free sem unlink tanh sem wait memcpy chdir fscanf chmod memset setjmp chown mkdir fstat close fsync setuid time times cos sigaction cosh fwrite mmap creat getc toupper mprotect ctime getenv uname div dup open unlink dup utime wait sin pow sinh printf sprintf execve putc sqrt write putchar exp puts strcmp fabs readdir stat strcat strcpy fclose remove rename isspace rewind strlen list tables appendix ptr tpl ballista datatype template signal action pointer copyright carnegie mellon university program free software redistribute modify terms gnu general public license published free software foundation version license option version 
program distributed hope useful warranty implied warranty fitness particular purpose 
see gnu general public license details 
received copy gnu general public license program write free software foundation temple place suite boston ma usa 
name ptr sigaction parent ptr buf includes define struct sigaction include signal include ptr buf global defines struct sigaction sigaction temp void foo handler int void foo action int sig void dials enum dial sa handler null sig dfl sig ign usr func sig err enum dial sa mask empty full sigsegv zero maxint appendix enum dial sa flags sa set sa set sa sa restart sa extra sa zero sa maxint enum dial sa sigaction action null action usr func access sigaction temp sa flags sigaction temp sa mask val null sigaction temp sa handler null sig dfl sigaction temp sa handler sig dfl sig ign sigaction temp sa handler sig ign usr func sigaction temp sa handler foo handler sig err sigaction temp sa handler sig err empty signals blocked sigaction temp sa mask file logfile null logfile fopen tmp txt null exit fprintf logfile ptr sigaction empty failed 
function tested fclose logfile exit full signals blocked 
sigaction temp sa mask file logfile null appendix logfile fopen tmp txt null exit fprintf logfile ptr sigaction full failed 
function tested fclose logfile exit sigaction temp sa mask val sigsegv sigaction temp sa mask val sigsegv sigaction temp sa mask val sigaction temp sa mask val zero sigaction temp sa mask val maxint sigaction temp sa mask val maxint sa set sa sigaction temp sa flags sa sa set sa sigaction temp sa flags sa sa sa sigaction temp sa flags sa sa restart sa sigaction temp sa flags sa restart sa zero appendix sigaction temp sa flags sa maxint sigaction temp sa flags maxint sa sigaction temp sa flags sa restart sa sa sa action null sigaction temp sa sigaction null action usr func sigaction temp sa sigaction foo action sigaction temp commit cleanup appendix ptr sigaction cpp generated ballista tm project data object compiler copyright carnegie mellon university program free software redistribute modify terms gnu general public license published free software foundation version license option version 
program distributed hope useful warranty implied warranty fitness particular purpose 
see gnu general public license details 
received copy gnu general public license program write free software foundation temple place suite boston ma usa 
file generated tuesday october pm edt title ptr sigaction cpp include errno include include stdio include include stream include string include sys types include sys stat include include ptr sigaction struct sigaction sigaction temp void foo handler int void foo action int sig void classname classname dial declarations appendix generated strcpy ptr class string strcpy ptr ptr sigaction null strcpy ptr dfl ptr sigaction sig dfl strcpy ptr ign ptr sigaction sig ign strcpy ptr func ptr sigaction usr func strcpy ptr err ptr sigaction sig err strcpy ptr ptr sigaction empty strcpy ptr ptr sigaction full strcpy ptr ptr sigaction strcpy ptr ptr sigaction sigsegv strcpy ptr ptr sigaction strcpy ptr ptr sigaction strcpy ptr ptr sigaction zero strcpy ptr ptr sigaction maxint strcpy ptr sigactionsa set ptr sigaction sa strcpy ptr sigactionsa set ptr sigaction sa set strcpy ptr sigactionsa ptr sigaction sa strcpy ptr sigactionsa restart ptr sigaction sa restart strcpy ptr sigactionsa ptr sigaction sa strcpy ptr extra ptr sigaction extra strcpy ptr sigactionsa zero ptr sigaction sa zero strcpy ptr sigactionsa maxint ptr sigaction sa maxint strcpy ptr null ptr sigaction action null strcpy ptr usr func ptr sigaction action usr func param ptr sigaction ptr return ptr param ptr sigaction ptr dfl return ptr dfl param ptr sigaction ptr ign return ptr ign param ptr sigaction ptr func return ptr func param ptr sigaction ptr err appendix return ptr err param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr return ptr param ptr sigaction ptr sigactionsa set return ptr sigactionsa set param ptr sigaction ptr sigactionsa set return ptr sigactionsa set param ptr sigaction ptr sigactionsa appendix return ptr sigactionsa param ptr sigaction ptr sigactionsa restart return ptr sigactionsa restart param ptr sigaction ptr sigactionsa return ptr sigactionsa param ptr sigaction ptr extra return ptr extra param ptr sigaction ptr sigactionsa zero return ptr sigactionsa zero param ptr sigaction ptr sigactionsa maxint return ptr sigactionsa maxint param ptr sigaction ptr null return ptr null param ptr sigaction ptr usr func return ptr usr func type name return method param classname typename return ptr int classname appendix return void classname typelist param list int num strcpy list num char typename typelist list num void classname access param data strcmp data char typename return access data access code ptr sigaction null ptr sigaction sig dfl ptr sigaction sig ign ptr sigaction usr func ptr sigaction sig err ptr sigaction empty ptr sigaction full ptr sigaction ptr sigaction sigsegv ptr sigaction ptr sigaction ptr sigaction zero ptr sigaction maxint ptr sigaction sa set ptr sigaction sa set ptr sigaction sa ptr sigaction sa restart ptr sigaction sa ptr sigaction extra ptr sigaction sa zero ptr sigaction sa maxint ptr sigaction action null ptr sigaction action usr func int dataptr dataptr strcmp data dataptr ptr ptr sigaction null strcmp data dataptr ptr dfl ptr sigaction sig dfl strcmp data dataptr ptr ign ptr sigaction sig ign strcmp data dataptr ptr func ptr sigaction usr func appendix strcmp data dataptr ptr err ptr sigaction sig err error unknown setting sa handler dial data object class string 
endl offending string data dataptr endl exit dataptr strcmp data dataptr ptr ptr sigaction empty strcmp data dataptr ptr ptr sigaction full strcmp data dataptr ptr ptr sigaction strcmp data dataptr ptr ptr sigaction sigsegv strcmp data dataptr ptr ptr sigaction strcmp data dataptr ptr ptr sigaction strcmp data dataptr ptr ptr sigaction zero strcmp data dataptr ptr ptr sigaction maxint error unknown setting sa mask dial data object class string 
endl offending string data dataptr endl exit dataptr strcmp data dataptr ptr sigactionsa set ptr sigaction sa set strcmp data dataptr ptr sigactionsa set ptr sigaction sa set strcmp data dataptr ptr sigactionsa ptr sigaction sa strcmp data dataptr ptr sigactionsa restart ptr sigaction sa restart appendix strcmp data dataptr ptr sigactionsa ptr sigaction sa strcmp data dataptr ptr extra ptr sigaction extra strcmp data dataptr ptr sigactionsa zero ptr sigaction sa zero strcmp data dataptr ptr sigactionsa maxint ptr sigaction sa maxint error unknown setting sa flags dial data object class string 
endl offending string data dataptr endl exit dataptr strcmp data dataptr ptr null ptr sigaction action null strcmp data dataptr ptr usr func ptr sigaction action usr func error unknown setting sa sigaction dial data object class string 
endl offending string data dataptr endl exit sigaction temp sa flags sigaction temp sa mask val ptr sigaction null sigaction temp sa handler null ptr sigaction sig dfl sigaction temp sa handler sig dfl appendix ptr sigaction sig ign sigaction temp sa handler sig ign ptr sigaction usr func sigaction temp sa handler foo handler ptr sigaction sig err sigaction temp sa handler sig err ptr sigaction empty sigaction temp sa mask file logfile null logfile fopen tmp txt null exit fprintf logfile ptr sigaction empty failed 
function tested fclose logfile exit ptr sigaction full sigaction temp sa mask file logfile null logfile fopen tmp txt null exit appendix fprintf logfile ptr sigaction full failed 
function tested fclose logfile exit ptr sigaction sigaction temp sa mask val ptr sigaction sigsegv sigaction temp sa mask val sigsegv ptr sigaction sigaction temp sa mask val ptr sigaction sigaction temp sa mask val ptr sigaction zero sigaction temp sa mask val ptr sigaction maxint sigaction temp sa mask val maxint ptr sigaction sa set ptr sigaction sa sigaction temp sa flags sa appendix ptr sigaction sa set ptr sigaction sa sigaction temp sa flags sa ptr sigaction sa ptr sigaction sa sigaction temp sa flags sa ptr sigaction sa restart ptr sigaction sa sigaction temp sa flags sa restart ptr sigaction sa zero sigaction temp sa flags ptr sigaction sa maxint sigaction temp sa flags maxint ptr sigaction sa sigaction temp sa flags sa restart sa sa sa ptr sigaction action null sigaction temp sa sigaction null ptr sigaction action usr func appendix sigaction temp sa sigaction foo action sigaction temp return int classname commit param tname strcmp tname char typename return commit tname commit code generated return int classname cleanup param tname strcmp tname char typename return cleanup tname cleanup code generated return int classname param tname strcmp tname char typename return number dials return tname int classname param tname int strcmp tname char typename return tname switch switch cases generated case return appendix break case return break case return break case return break generated default error invalid dial number passed class string please check declaration files 
dial number passed endl exit return param classname param tname int int position strcmp tname char typename return tname position switch switch cases generated case switch position case return ptr break case return ptr dfl break case return ptr ign break appendix case return ptr func break case return ptr err break default error invalid position number passed class string please check declaration files 
dial number passed break position position exit case switch position case return ptr break case return ptr break case return ptr break case return ptr break case return ptr break case return ptr break case return ptr break case return ptr break default error invalid position number passed class string please check declaration files 
dial number passed break position position exit appendix case switch position case return ptr sigactionsa set break case return ptr sigactionsa set break case return ptr sigactionsa break case return ptr sigactionsa restart break case return ptr sigactionsa break case return ptr extra break case return ptr sigactionsa zero break case return ptr sigactionsa maxint break default error invalid position number passed class string please check declaration files 
dial number passed break position position exit case switch position case return ptr null break case return ptr usr func break default error invalid position number passed class string please check declaration files 
dial number passed appendix position position exit break default error invalid dial number passed class string please check declaration files 
dial number passed endl exit return null ptr sigaction generated ballista tm project data object compiler copyright carnegie mellon university program free software redistribute modify terms gnu general public license published free software foundation version license option version 
program distributed hope useful warranty implied warranty fitness particular purpose 
see gnu general public license details 
received copy gnu general public license program write free software foundation temple place suite boston ma usa 
file generated tuesday october pm edt title ptr sigaction include control ifndef ptr sigaction define ptr sigaction include errno include include stdio include include stream include string include sys types include sys stat include include appendix define struct sigaction include signal include ptr buf define define classname ptr sigaction define class string ptr sigaction define ptr buf define number dials class classname public private class dial setting string variables param ptr param ptr int ptr sigaction null param ptr dfl int ptr sigaction sig dfl param ptr ign int ptr sigaction sig ign param ptr func int ptr sigaction usr func param ptr err int ptr sigaction sig err param ptr int ptr sigaction empty param ptr int ptr sigaction full param ptr int ptr sigaction param ptr int ptr sigaction sigsegv param ptr int ptr sigaction param ptr int ptr sigaction param ptr int ptr sigaction zero param ptr int ptr sigaction maxint param ptr sigactionsa set int ptr sigaction sa set param ptr sigactionsa set int ptr sigaction sa set param ptr sigactionsa int ptr sigaction sa param ptr sigactionsa restart int ptr sigaction sa restart param ptr sigactionsa int ptr sigaction sa param ptr extra int ptr sigaction extra appendix param ptr sigactionsa zero int ptr sigaction sa zero param ptr sigactionsa maxint int ptr sigaction sa maxint param ptr null int ptr sigaction action null param ptr usr func int ptr sigaction action usr func type variable save value destruction public class dial setting string access methods param ptr param ptr dfl param ptr ign param ptr func param ptr err param ptr param ptr param ptr param ptr param ptr param ptr param ptr param ptr param ptr sigactionsa set param ptr sigactionsa set param ptr sigactionsa param ptr sigactionsa restart param ptr sigactionsa param ptr extra param ptr sigactionsa zero param ptr sigactionsa maxint param ptr null param ptr usr func class constructor classname public mandatory methods param typename returns type parameter virtual void access param data virtual int commit param tname virtual int cleanup param tname virtual int param tname virtual int param tname int virtual param param tname int int position virtual int virtual void typelist param list int num appendix endif classname appendix 
