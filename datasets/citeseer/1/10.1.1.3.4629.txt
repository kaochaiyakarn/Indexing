symmetric encryption simulatable dolev yao style cryptographic library michael backes birgit pfitzmann ibm zurich research lab solved long standing open problem justifying dolev yao type model cryptography virtually automated protocol provers active attacks 
justification done defining ideal system handling dolev yao style terms cryptographic realization user interface showing realization secure ideal system sense reactive simulatability 
definition encompasses arbitrary active attacks enjoys general composition property preservation properties 
security holds standard model cryptography standard assumptions adaptively secure primitives 
major primitive missing library far symmetric encryption 
show symmetric encryption harder way allows general composition existing primitives library 
discuss approaches overcome problems 
favorite approach provide detailed provably secure idealization symmetric encryption framework constructing nested terms 
automated proofs security protocols model checkers theorem provers typically cryptography deterministic operations terms simple cancellation rules 
example term pke sign denotes application message nonces 
typical cancellation rule ske pke corresponding keys 
proof tools handle terms symbolically evaluate bitstrings 
words perform algebraic manipulations trees consisting operators base messages cancellation rules transition rules particular protocol models networks adversaries 
abstractions di erent details called dolev yao model authors 
years cryptographic justification abstractions 
problem lies assumption implicit adversary model actions expressed operations impossible relations hold terms derivable cancellation rules 
hard artificial counterexamples assumptions 
counterexamples method protocols proved literature far 
approach abstracting cryptographic primitives rigorous hand proofs tools proving protocols primitives highly attractive cryptographic aspects protocol proofs distributed systems aspects proofs tedious error prone weren interlinked cryptographic aspects 
existing cient automated proof tools security protocols cryptography abstracted simple deterministic ideal systems 
closer stay dolev yao model easier adaptation proof tools 
cryptographic underpinnings dolev yao model addressed abadi rogaway 
handled passive adversaries symmetric encryption 
protocol language security properties handled extended passive adversaries :10.1.1.29.1076
excludes orts way formulate syntactic calculi dealing polynomial time considerations particular second step encode proof tools 
approach handle protocols degree automation 
generally complementary competing approach proving simple deterministic abstractions cryptography working cryptography blackbox way 
typical ways attacking protocols man middle attacks attacks reusing message part di erent place concurrent protocol run 
full cryptographic justification dolev yao model arbitrary active attacks arbitrary surrounding interactive protocols :10.1.1.4.5735
specific dolev yao model soundness proven known needham schroeder lowe protocol proved :10.1.1.4.5735
shows spite adding certain operators rules compared simpler dolev yao models order able arbitrary cryptographically secure primitives changes cryptographic realization proof possible style automated tools sound cryptographic basis 
shown library words term algebra rules modularly extended additional cryptographic primitives example symmetric authentication 
symmetric encryption missing framework common cryptographic primitive typical proofs dolev yao models 
goal add symmetric encryption framework 
concurrently laud cryptographic underpinning dolev yao model symmetric encryption active attacks 
enjoys direct connection formal proof tool specific certain confidentiality properties restricts surrounding protocols straight line programs specific language address connection remaining primitives dolev yao model 
intrinsic di culties providing sound abstraction symmetric encryption strong sense security :10.1.1.4.5735
strong notion concept simulatability 
essentially cryptographic notion secure implementation 
roughly real system called secure ideal system sense happen honest users real system happen honest users ideal system 
typically proved providing simulator interacting ideal system honest users adversary real system blackbox subsystem simulates visible actions real system online time occur 
symmetric encryption called commitment problem wants achieve simulatability 
ideal encryption system allow secret keys sent participant protocols proven ideal system key exchange protocols 
main di erence public key systems ideal system assume public keys sent su cient standard protocols 
ideal system simply allows keys sent time typical dolev yao models allow valid terms sent time problem occur honest participant sends ciphertext adversary see sends contained cleartext key 
behavior may reasonably designed protocols ciphertext encrypted bet opened 
simulator learn way ciphertext sent simulate bitstring adversary sees 
simulator sees abstractly key known ciphertext contains specific application message 
change application message simulate key decrypts old ciphertext bitstring produced knowledge application message specific message 
discuss ways dealing problem 
preferred ideal real symmetric encryption system leave surrounding protocol guarantee commitment problem occur 
essentially means surrounding protocol guarantee keys longer sent form known adversary honest participant started 
alternatives build guarantee ideal real system restrict oneself encryption systems problem occur models cryptography ideal unrealizable aspect particular model 
discuss possibilities choice detail section 
important argument choice depending timing assumptions possible environment protocol goals range di erent measures conceivable guaranteeing necessary order sending keys ciphertexts 
existing formal methods automated tools suited arguing properties 
proposed measures underlying idealization need measure need prove hand 
show wants achieve simulatability problem independent surrounding framework nested terms specific goal making ideal encryption system subsystem library :10.1.1.4.5735
applicability choice modeling protocols typically analyzed dolev yao models investigated protocols clark jacob library respect commitment problem raises problem 
design decisions taken symmetric encryption ciphertext adversary may obtain information key ideal system prescribes decryption ciphertext message di erent type wrong key produces error may produce message 
questions similar passive case treatment symmetric authentication combined consistent way ideal encryption system 
underlying definitions discussing commitment problem detail exact definition simulatability strong security notion causes problem 
briefly sketch underlying definitions 
model cryptographic library embed ideal encryption system :10.1.1.4.5735
system consists possible structures 
structure consists set connected correct machines subset free ports called specified ports 
machine probabilistic io automaton extended finite state machine slightly refined model allow complexity considerations 
machines turing machine realizations defined complexity measured terms common security parameter initial tape content machine 
readers interested ideal cryptographic library ideal encryption system larger protocols need normal deterministic io automata 
standard real cryptographic system structures derived intended structure trust model consisting access structure acc channel model 
acc contains possible sets indices uncorrupted machines intended ones designates channel secure authentic private insecure 
typical ideal system structure contains machine th called trusted host 
structure complemented configuration arbitrary user machine adversary machine connects ports rest may interact 
set configurations system sys called conf sys 
general scheduling model gives connection output port 
input port 
bu er machine corresponding clock port schedule message transition 
real asynchronous cryptographic systems network connections typically scheduled configuration runnable system gets defined probability space runs 
view machine run restriction outputs machine sees internal states 
formally view view conf machine configuration conf family random variables element security parameter value simulatability simulatability cryptographic notion secure implementation 
reactive systems means happen honest user real system sys real happen ideal system sys id structure sys real polynomial time user polynomial time adversary exists polynomial time adversary corresponding ideal structure sys id view computationally indistinguishable configurations 
illustrated 
indistinguishability known cryptographic notion 
definition computational indistinguishability families var var random variables common domains computationally indistinguishable algorithm dis distinguisher probabilistic polynomial time input dis var dis var simulatability views indistinguishable 
denotes set negligible functions positive polynomials 
intuitively security parameter element chosen var var dis tries guess distribution element came 
definition simulatability systems sys real sys id says sys real sys id secure polynomial time configuration conf conf sys real exists polynomial time configuration conf conf sys id view conf view conf 
cryptographic library shown blackbox simulatability consists simulator sim depends uses blackbox 
essential feature definition simulatability composition theorem roughly says design prove larger system ideal system sys id securely replace sys id real system sys real notation write deterministic probabilistic assignment uniform random choice set 
integer variables mean length message denoted len error element available addition domains ranges functions algorithms 
list operation denoted 
arguments unambiguously retrievable database set functions called entries finite domain called attributes 
entry value attribute att written att predicate pred involving attributes pred means subset entries attributes fulfill pred pred contains element notation element 
adding entry abbreviated overview ideal cryptographic library ideal cryptographic library defined ers users cryptographic operations commands encrypt decrypt message test signature generate nonce :10.1.1.4.5735
commands simple deterministic behavior ideal system 
reactive scenario semantics state knows terms 
state stored database 
entry database type signature pointers arguments key message 
corresponds top level dolev yao term entire term pointers 
entry contains handles participants know 
reason handles entry accessible higher protocols idealized cryptographic term corresponding real message way higher protocols allow provably secure implementation sense simulatability 
ideal library handles essentially point dolev yao terms real library point cryptographic messages 
ideal cryptographic library allow cheating construction 
instance receives command encrypt message certain key simply database entry ciphertext 
user ask decryption ciphertext handles ciphertext secret key 
similarly user issues command sign message ideal system looks user secret key 
stores message signed key 
tests simply look ups database 
send operation entry known participants adds handles entry 
underlying model cover crypto operations entire reactive system contains network model 
design decisions symmetric encryption simulatability proofs section discuss approaches solve commitment problem sketched 
elaborate main design decisions provide suitable deterministic abstractions symmetric encryption 
commitment problem solution approaches name suggests commitment problem simulatability proofs captures situation simulator commits certain message change commitment allow correct simulation 
case symmetric encryption commitment problem occurs simulator construct indistinguishable ciphertext knowing secret key plaintext corresponding ciphertext real world 
simulate missing key simulator create new secret key rely arbitrary fixed key encryption systems guarantees indistinguishable keys see 
unknown plaintext simulator encrypt arbitrary message correct length relying indistinguishability ciphertexts di erent messages 
far simulation fine 
stays fine message known secure encryption guarantees indistinguishable simulator ciphertext contains wrong message 
secret key known simulator runs trouble learning abstractly fact produce suitable key decrypts ciphertext correct message 
cheat message produce correct behavior honest users 
typically possible 
perfect exception commitment problem time pad 
specific encryption system simulator open arbitrary ciphertext string arbitrary message selecting key want restrict ideal encryption system modeling time pads standard encryption systems standard modes operation certainly similar process known 
show encryption system fixed length keys deterministic decryption algorithm property 
assume possible keys 
protocol send fresh random messages length allows possibilities 
simulator produce key able provide di erent cases messages just keys 
keys produces fit message tuple ciphertext tuple 
fit means particular assumed deterministic decryption algorithm honest participants fact decrypt ciphertext tuple messages 
impossible 
reason commitment problem occur cryptographic library public key encryption enforced secret keys sent symmetric authentication enforced authenticator known message authenticates 
related problems known encryption adaptively secure multi party function evaluation 
solutions provided fits case encryption stronger requirements need physical assumption fulfilled 
adaptively secure multi party computation deletion old keys concentrates public key schemes simply assuming time pad symmetric case 
introduce possible approaches solve commitment problem 
assumptions sending keys aim abstraction simple possible works cases typically analyzed models 
turns typical cases commitment problem occur protocol ensures keys sent having 
protocols keys assumed authentication protocols clearly fulfill assumption 
formally seen synchronization assumption stating predistribution phase key participants sharing key starts 
synchronous protocols similar assumptions key exchange part protocols indicating time bounds exchange phase usage phase key key exchange messages 
party protocols exchanging session key symmetric asymmetric master key clearly fulfill assumption party generates key sends 
typically true 
party protocols key distribution center helps parties exchange secret key sk come flavors sends sk step depends detailed model asynchrony assumption automatically fulfilled sends sk sends starts 
sends sk di erent steps recipient messages second message look equal wait confirmation partner key 
protocols confirmation anyway 
group key distribution protocols confirmation phases fulfill assumption 
get representative assessment restrictiveness commitment problem investigated protocols clark jacob library 
protocols library flawed wide frog protocol raises commitment problem 
avoiding commitment problem integrity property scope current automated protocol proof tools verified application properties protocol 
clearer formal definition definition approach define simple abstraction symmetric encryption show securely implemented provided commitment problem occur 
alternative approaches discussed exclude protocols require complex abstraction rely unrealistic assumptions random oracle model special non committing encryption schemes 
additional benefit solution expect ideal encryption system works random oracle model non committing encryption schemes protocols commitment problem 
internal restrictions sending keys solution guarantee ideal real system commitment problem occur 
means systems permit operations cause commitment problem key encrypting may longer sent 
problem distributed property trivial enforce real system 
implement imposing restrictions patterns keys passed need byzantine agreement participant uses key 
highly unnatural underlying implementation authentication key exchange protocols typically proved dolev yao models 
natural enforce restrictions patterns keys passed 
certainly means ideal system real system keep track current status key participant may sent 
furthermore provide general rules confirmation messages compare section enforce patterns confirmation messages needed 
saw excludes important cases pulls distributed systems aspects cryptographic primitives 
decided follow approach 
random oracle approach special encryption schemes commitment problem circumvented conducting proof random oracle model 
nutshell including random oracle encrypted message prevents simulator committing fixed value oracle suitably instantiated commitment opened respectively secret key sent 
idealizations random oracles capture cryptographic realities protocols known provably secure idealizations insecure instantiation oracle benefit simply dolev yao model great desire 
commitment problem occur non committing encryption schemes showed currently leaves time pad 
need authenticated encryption assume user encrypts message symmetric encryption key sk decrypts resulting ciphertext key sk ideal system result error symbol equation case defined 
real world encryption schemes yield message particular time pad yields result 
similar problems known normal dolev yao models see 
solve problem considering encryption schemes answer decryption requests wrong keys encryption schemes provide certain kind authenticity 
formally authenticated symmetric encryption schemes defined 
intuitively guarantee know specific key infeasible compute ciphertext validly decrypted key see definition section 
definition implies decryption wrong key output negligible probability 
restricting encryption schemes try define ideal system allows non error outputs decryptions wrong keys 
deterministic abstraction achieve real system decryption di erent wrong keys yield di erent messages ideal system wrong keys common abstraction 
non deterministic choice achieved letting adversary choice resulting message somewhat undesirable ideal system authenticated encryption ciently implementable normal cryptographic assumptions 
modeling special adversary capabilities idealization reflect special capabilities adversary may respect symmetric encryption schemes real world 
allow checking encryptions created secret key definition authenticated encryption schemes exclude happen real system 
public key encryption achieved tagging ciphertexts corresponding public key :10.1.1.4.5735
symmetric encryption possible public key exists 
solve problem tagging ciphertexts meaningless public key solely identifier secret key 
alternative approach taken considering encryption schemes guarantee indistinguishable keys schemes problem occur 
wanted restrict case need extend authenticated encryption 
secondly encryption keys come adversary happen encryption validly decrypted keys incorrectly chosen keys 
security definition considers correct keys 
possible tag encryptions additional key identifiers execution ideal system 
encryptions key identifiers model encryptions adversary suitable key known 
ideal system ideal encryption system 
addition ideal cryptographic library reviewed section capturing symmetric encryption primitives 
stress modeling proving cryptographic protocols abstraction su cient understand ideal system described section 
sections justify cryptographic faithfulness ideal library 
structures parameters ideal system consists trusted host thh subset set 
users denoting possible honest users 
port inputs port outputs user denoting adversary 
ideal system keeps track length messages tuple length functions 
add functions skse len symenc len length symmetric encryption keys ciphertexts depending security parameter length message 
function polynomially bounded ciently computable 
states state thh consists database variables size 
database contains abstractions real cryptographic objects correspond top levels dolev yao terms 
entry attributes ind inds called index consecutively numbers entries index primary key attribute database write selection ind 
type typeset identifies type add types skse pkse symenc typeset denoting secret symmetric encryption keys corresponding public keys symmetric encryptions :10.1.1.4.5735
type pkse called secret type put lists transferred 
arg 
possibly empty list arguments 
values indices entries inds distinguish superscript ind 
hnd handles user adversary knows entry 
hnd means know entry 
superscript hnd handles 
len denotes length entry computed applying functions initially empty 
thh counter size inds current number elements new entries receive ind size ind changed 
handle attributes counters current handle initialized new handle chosen hnd 
thh maintains explicit bounds length messages number activations achieve polynomial runtime independent environment 
bounds modification number permitted inputs adversary enlarged :10.1.1.4.5735
just technical detail allow correct proof simulatability 
omit details 
new inputs evaluation ideal system types inputs basic commands accepted ports correspond cryptographic operations local ects output port user occurs handles involved 
local adversary commands type accepted model tolerated imperfections possibilities adversary may honest users 
send commands output values users 
notation algo command algo thh means thh receives input algo outputs input output port clear context 
allow lists encrypted transferred general convention :10.1.1.4.5735
symmetric encryption add new basic commands local adversary commands send commands unchanged 
define precise new inputs thh evaluates state 
handle arguments tacitly required existing time execution 
underlying model bounds length input ensure polynomial runtime bounds written explicitly easily derived domain expectations individual inputs 
algorithm hnd ind hnd side ect denotes thh determines handle hnd user entry hnd hnd returns sets returns hnd hnd 
non handles identity function 
ind hnd applies ind hnd element list 
basic commands consider basic commands 
comprises operations key generation encryption decryption 
assume current input port result goes 
key generation skse hnd gen symenc key 
set skse hnd ind size type pkse arg len ind size type skse arg ind hnd skse hnd len skse len 
entry empty public key handle serves mentioned key identifier secret key 
argument secret key points empty public key 
encryption hnd sym encrypt skse hnd hnd 
skse hnd skse hnd type skse ind hnd hnd type list ind return length symenc len len max len 
set hnd pkse skse ind size type symenc arg pkse hnd hnd len length 
general argument format entries type symenc pkse 
pkse 
arguments pkse 
pkse pairwise disjoint key identifiers secret keys encryption validly decrypts messages 
respectively 
see section additional key identifiers encryption added execution adversary created suitable key 
arguments appended existing list 
empty sequence arguments models encryptions adversary suitable secret key received 
decryption hnd sym decrypt skse hnd hnd 
hnd hnd type symenc ind skse hnd skse hnd type skse ind return 
pkse 
pkse arg may 
skse pkse set hnd ind hnd hnd 
local adversary commands local commands accepted port 
model special capabilities adversary see section 
dealing symmetric encryptions adversary suitable key received provide command generating unknown symmetric encryption 
suitable secret keys may received 
command fixing symmetric encryptions takes care 
allow adversary retrieve information explicitly require hidden arguments type handle 
extend general command parameter retrieval symmetric encryption system 
entries type symenc length encrypted message output message adversary corresponding secret key handle 
unknown symmetric encryption hnd adv unknown symenc length length return length max len 
set hnd ind size type symenc arg hnd hnd len length 
fixing symmetric encryption adv fix symenc content skse hnd hnd hnd 
return hnd hnd type symenc ind skse hnd skse hnd type skse ind hnd hnd type list ind symenc len len len 
pkse skse pkse 
pkse arg may 
pkse pkse 
pkse set arg pkse 
pkse pkse true set false 
parameter retrieval type arg adv parse hnd 
existing command sets type hnd hnd type types arg ind hnd hnd hnd arg 
applies new types skse pkse 
type symenc pkse 
pkse hnd hnd arg 
pkse hnd ind hnd pkse skse pkse 
skse hnd ind hnd len arg pkse hnd 
pkse hnd 
unknown encryptions key identifier message exists 
note parsing symmetric encryption yields handles empty public keys 
encryption generated honest user public key corresponds secret key encryption generated 
adversary wants know encryptions created secret key parses compares resulting public keys 
send commands ideal cryptographic library ers commands virtually sending messages users 
sending modeled adding new handle intended recipient possibly adversary database entry modeling message 
handles point list entry contain arbitrary application data ciphertexts public keys symmetric encryptions corresponding secret keys 
commands unchanged example modeling insecure channels commonly ones omit secure channels authentic channels :10.1.1.4.5735
send hnd 

intuitively list shall sent user ind hnd hnd type list ind ind output ind hnd ind 
adv send hnd 
port 
intuitively adversary wants send list pretending ind hnd hnd type list ind ind output ind hnd ind 
real system real cryptographic library ers users commands ideal honest users operate cryptographic objects handles 
separate machine database honest user real system containing real cryptographic keys real encryptions 
real bitstrings sent machines 
commands implemented real cryptographic algorithms simulatability proof show real adversary achieve achieved adversary ideal system underlying cryptography broken 
additions modifications real system starting description underlying cryptographic definitions :10.1.1.4.5735
underlying cryptographic operations denote symmetric encryption scheme tuple se gen se sym encrypt sym decrypt skse len symenc len polynomial time algorithms 
key generation security parameter written sk gen se 
length sk skse len 
denote encryption message sym encrypt sk decryption sym decrypt sk 
result may call ciphertext invalid key 
correctly generated ciphertext key correct length valid key 
length symenc len len 
true sym decrypt sk value sk skse len functions skse len symenc len bounded multivariate polynomials 
requirement functions exist loss generality due standard padding techniques 
security definition standard definition authenticated symmetric encryption schemes 
consists parts scheme ensure confidentiality messages attacks guarantee integrity ciphertexts 
formulate notions notation interacting machines 
definition security chosen ciphertext attacks symmetric encryption scheme symmetric machine defined follows input output port variable sk initialized initially empty set transition rules generate key sk gen se set 
input symenc intuitively pair messages adversary hopes able distinguish len len set sym encrypt sk output input return sym decrypt sk 
encryption scheme called indistinguishable chosen ciphertext attack probabilistic polynomial time machine sd interacts outputs bit meant guess probability event bounded negligible function machine defining integrity ciphertexts defined similarly 
definition integrity ciphertexts symmetric encryption scheme define symmetric integrity machine follows input output port variable sk initialized transition rules generate key sk gen se 
input symenc return sym encrypt sk 
input return sym decrypt sk 
encryption scheme said integrity ciphertexts probabilistic polynomial time machine si interacts probability negligible outputs input output command symenc time 
symmetric encryptions schemes provably secure respect definitions exist reasonable assumptions 
bellare showed encryption schemes derived symmetric encryption scheme provably secure adaptive chosen plaintext attacks strongly unforgeable message authentication code encrypting plaintext appending mac obtained ciphertext 
structures intended structure real cryptographic library consists machines 
mn 
ports honest users connect ideal real system 
connections exactly particular insecure connection called net normal :10.1.1.4.5735
called network connections corresponding ports network ports 
subset 
denote indices correct machines 
resulting actual structure consists correct machines modified channels channel model 
particular insecure channel split actual structure machines interact adversary 
details channel model needed 
structure interacts honest users adversary states machine state machine consists database variable entry attributes hnd consecutively numbers entries primary key attribute write hnd selection hnd hnd 
word real representation type typeset null identifies type value null denotes unparsed entry 
add arg list additional arguments 
entries new types 
initially empty 
counter current size subroutine hnd type add arg determines handle certain parameters entry word exists hnd word type sks ske hnd returns hnd assigning input values type add arg corresponding attributes hnd hnd type null 
len max len returns hnd 
sets returns hnd hnd type add arg 
similar machine thh maintains explicit bounds length messages number activations achieve polynomial runtime 
omit details 
inputs evaluation describe evaluates individual new inputs 
constructors level parsing stateful commands defined functional constructors parsing algorithms type 
general functional algorithm type arg parse parses arbitrary entries follows tests form type 
type typeset pkse sks ske garbage 
returns garbage 
calls parsing algorithm arg parse type 
result parse outputs garbage 
parse hnd abbreviate calls type arg parse hnd word assigns hnd type type null may arg parse hnd necessary mean hnd type null 
restriction type sks ske abbreviating secret keys signature public key encryption schemes included compatibility original library 
similar statements occur times knowledge types needed understanding new 
basic commands parse type consider basic commands 
local 
means produce outputs network ports 
term tagged list means valid list real system 
assume tagged lists ciently encoded key constructor sk symenc key 
sk gen se sr nonce len return sk skse sk sr 
key generation skse hnd gen symenc key 
sk symenc key skse hnd skse hnd sk skse 
key parsing arg parse skse sk 
sk form skse sk sr sk skse len sr nonce len return 
symmetric encryption constructor symenc sk sk set nonce len sk sk sr sk 
encrypt sym encrypt sk return symenc sr 
symmetric encryption hnd sym encrypt skse hnd hnd 
parse skse hnd hnd necessary 
skse hnd type skse hnd type list return 
set sk skse hnd word hnd word symenc sk 
len max len return set hnd symenc hnd symenc 
encryption parsing arg parse symenc 
form symenc sr sr nonce len return set arg 
symmetric decryption hnd sym decrypt hnd skse hnd 
parse hnd skse hnd hnd type symenc skse hnd type skse return 
symenc sr hnd word sk skse hnd word 
sym decrypt sk 
sr skse hnd word tagged list return hnd :10.1.1.29.1076
hnd list 
send commands network inputs similar ideal system command send hnd sending list port net real insecure network input send hnd 
parses hnd necessary 
hnd type list outputs hnd word port net 
inputs network ports simply tested tagged lists stored :10.1.1.4.5735
security proof security claim real cryptographic library extended symmetric encryption secure ideal cryptographic library symmetric encryption sense definition provided commitment problem avoided surrounding protocol 
define means commitment problem occur 
formalize event exists input specified port causes symmetric encryption generated corresponding key known adversary inputs may cause key sent encryption decrypted adversary 
note property marginally weakened restricting cases symmetric encryption sent adversary variant easier verify actual protocols additionally parse sent term look contained encryption 
technical reasons exclude encryption cycles encrypting key definition exists inds skse hnd hnd sym encrypt skse hnd hnd term encrypted time type skse secret key hnd known adversary hold 
send hnd term sent time tree hnd hnd secret key contained term wrapped hnd hnd ind 
secret key su ciently wrapped property 
required acquiring properties weaker simulatability 
refer discussions 
capture event formally define tree contained terms database entry written tree defining root tree child arg recall symmetric encryptions maintain secret keys generating encryptions arguments corresponding public key identifiers 
capture absence encryption cycles define function order honestly generated secret encryption keys known adversary 
function order assigns key number corresponding order keys encryption 
define honestly generated secret keys public key encryption schemes order 
require key order may encrypted keys order event formally defined 
statement form send hnd means send command input port 
thh time sent term received adversary 
formally means arbitrary sending insecure authentic channels dishonest sending secure channels 
write describe contents database time statement form wrapped true occurrence node tree type skse exists node tree type symenc enc descendant arg encrypted message hnd order sk order sk denotes secret key encrypting message sk arg type symenc respectively sk arg type enc :10.1.1.29.1076
easy see define event terms inputs thh obtains honest users independent state thh solely depending interaction surrounding protocol 
description lengthy omitted reasons readability 
define configurations commitment free event holds independent considered adversary honest user guarantees validity event 
event restated terms inputs obtained user commitment free configuration naturally defined real library ers ports commands honest users ideal library 
definition commitment free configurations simulatability user respect symmetric encryption machine thh configurations conf thh sh property defined holds 
configurations commitment free user called commitment free configurations 
restriction simulatability set commitment free configurations denoted comm commitment free configurations real system exists commitment free configuration ideal system honest user achieves indistinguishable views honest user 
set valid parameter tuples real system consisting number participants secure signature encryption symmetric encryption schemes se length functions bounds se sys cry sym real se resulting real cryptographic library 
corresponding length functions bounds ideal system formalized function se sys cry sym id ideal cryptographic library parameters extension newly added length functions symmetric encryption skse len symenc len appendix notation definition theorem security cryptographic library parameters se sys cry sym real se comm sys cry sym id se 
proving theorem original library symmetric encryption simulator simh defined combination arbitrary polynomial time users arbitrary polynomial time adversary distinguish combination real machines combination thh simh sets indicating correct machines :10.1.1.4.5735
sketch extend simulator proof correct simulation deal symmetric encryption 
fully rigorous definition simh postponed appendix simulator basically simh translate real messages real adversary handles thh expects adversary input port vice versa 
directions simh parse incoming message completely construct version real bottom 
done recursive algorithms 
state simh mainly consists database similar databases storing knowledge adversary 
behavior simh sketched follows 
inputs thh assume simh receives input hnd thh bitstring hnd exists message known adversary simulator immediately outputs port net 
constructs bitstring recursive algorithm id real 
algorithm decomposes term basic commands adversary command adv parse 
time id real builds corresponding real bitstring real cryptographic operations enters new message parts recognize reused thh sketch simulator extended deal symmetric encryption keys respectively symmetric encryptions 
entry corresponding hnd symmetric encryption key id real creates new secret key applying function symenc key uses key encryption simulated key entry hnd entry corresponding hnd symmetric encryption simh determines corresponding secret key means public key identifier encryption 
checks designated recipient handle dishonest honest party 
case adv parse reveals plaintext encrypted message id real encrypt plaintext determined secret key output encryption 
designated recipient honest adv parse outputs length encrypted message 
case id real encrypts fixed message equal length 
inputs assume simh receives bitstring port net 
valid list simh aborts transition 
translates corresponding handle hnd algorithm real id outputs sending command adv send hnd port 
handle hnd exists real id reuses 
recursively parses real bitstring functional parsing algorithm 
time builds corresponding term database thh yields handle hnd furthermore real id enters new subterms building term real id extensive special capabilities adversary modeled thh real system bitstring may contain encryption encryption key known valid decrypt encryption 
simulator able insert encryption unknown key unknown plaintext database thh explains need command adv unknown symenc 
similarly adversary send new encryption key added existing symmetric encryption entries key valid 
similar cases symmetric encryption covered special adversary capabilities ered section 
proof correct simulation proof extended cryptographic library including symmetric encryption retain original proof structure far possible 
basic structure proof combined system ch defined essentially contains aspects real ideal system bisimulations proved ch combination mh real machines ch combination trusted host simulator 
bisimulation deal computational indistinguishability 
proof real asymmetric encryptions replaced simulated ones simulator 
done replacement step lowlevel idealization asymmetric encryption composition theorem 
proof illustrated steps depict treatment public key encryption step system original proof 
symmetric encryption complicated allow symmetric keys sent 
typical low level idealization assume original cryptographic definitions encryption security keys correct en decryption 
intuitively ok case simulator treats keys adversary learns perfectly correctly adversary learn key key sent encrypted apart en decryption 
argue security encryption trying show security encryption ensure argument circular 
fortunately assumptions guarantee argue security encryption key treating key keys arranged non circular order treatment 
perform successive exchange real encryptions simulated encryptions called hybrid argument 
combined system information easily available particular keys ideally known adversary 
proof depicted step fact multiple indexed combined systems new aspects symmetric encryption 
initial final combined systems initial combined system ch defined indirectly real ideal system exactly :10.1.1.4.5735
particular contains database extends database th attribute word containing real word entries mh simh real words computed mh entries generated basic commands honest users computed simh entries resulting network inputs values coming adversary 
implies symmetric encryptions produced honest users contain real plaintext message 
final combined system equal ch symmetric encryptions encryptions honest users keys honest users simulated message len defined simh encrypted real plaintext message 
distinguish keys generated honest users keys generated adversary ch give entries type skse additional attribute owner ranging honest adv captures key generated honest user adversary 
means command gen symenc key input new entry systems additionally set owner honest owner adv 
proof hybrid systems 
hybrid combined systems successive hybrid combined system di er behavior symmetric encryption key sk encrypts real messages key encrypts simulated messages 
selection sk guarantee sk encrypted keys sk encryptions replaced encryptions fixed messages len guarantee numbering keys order encryption 
combined system global knowledge 
corresponds function order introduced definition property 
define hybrid combined system see number di erent hybrid systems grows polynomially security parameter 
hybrid combined system keeps additional state compared ch global variable keys initially set 
counts honestly generated symmetric encryption keys encryption 
entry type skse additional attributes boolean attribute initially set false indicates key encryption 
attribute pos initialized indicates position key order keys encryption 
combined system processes commands initial combined system real words may di erent ciphertext generated decrypted honest user 
constructor symenc decryption command sym decrypt ected input sym encrypt sym decrypt port local variable sim encryption constructor set true key encrypt simulated messages 
symmetric encryption constructor symenc sk sk set nonce len sk sk sr sk 
skse ind word sk ind skse ind hnd sim false skse ind false skse ind true keys keys skse ind pos keys sim skse ind pos sim false encrypt sym encrypt sk sym encrypt sk len len list len nonce len len 
return symenc sr 
symmetric decryption hnd sym decrypt hnd skse hnd 
parse hnd skse hnd ind hnd hnd ind sk ind hnd skse hnd ind ind type symenc sk ind type skse return 
sk ind hnd sk ind false output 
symenc sr ind word sk sk ind word 
sk ind hnd sk ind pos key encrypt normally sym decrypt sk 
sr sk ind word tagged list set hnd :10.1.1.29.1076
resulting word compute return hnd ch sk ind pos pkse 
pkse ind arg claim exists unique 
skse ind pkse 
output hnd ind hnd 
lemma behavior equal initial combined system ch function bounding number keys generated honest users particular max behavior security parameter equals proof 
clear treat keys ch treat keys low level combined symmetric encryption machine hybrid argument want argue individually secrecy integrity ciphertext 
define machine symcomb corresponds precisely entire action hybrid system key 
show successful attack symcomb implies successful attack machines 
definition machine symcomb symmetric encryption scheme machine symcomb defined follows input output port variable sk initialized initially empty database sym ciphers attributes msg transition rules input generate sk output 
generate key sk gen se set 
input symenc sk output 
set len sym encrypt sk sym ciphers output input sk output 
return sym decrypt sk return sym ciphers msg 
encryption scheme called key reactively secure probabilistic polynomial time machine sc interacts symcomb outputs bit meant guess probability event bounded negligible function lemma secure symmetric encryption scheme sense definitions key reactively secure 
standard cryptographic reduction proof postpone appendix hybrid argument show combined systems ch indistinguishable 
structure hybrid argument standard case polynomially growing number hybrids 
special aspects usage symmetric encryption come treat cases secret key occur larger terms possible occurrences harm 
core hybrid argument show encryption machine symcomb simulate depending bit symcomb 
call rest simulation combination symcomb yield depending bit symcomb 
clearly symcomb encryption decryption th key 
problem hybrid systems key operations 
spite assumptions impossible may put list send secure channel 
choose key operations independently key chosen symcomb 
main task show simulation distinguishable 
definition rewritten hybrid system defined exactly exceptions inputs symmetric encryption constructor command hnd sym encrypt skse hnd hnd th key hnd skse hnd pos algorithm sym encrypt sk replaced calls symcomb 
key gets attribute pos generate input symcomb 
symmetric decryption hnd sym decrypt skse hnd hnd hnd skse hnd pos algorithm sym decrypt sk replaced calls symcomb 
note replaced key generation definition key sk symcomb key sk hnd skse hnd word lemma combination symcomb bit reactively indistinguishable bit indistinguishable proof postponed appendix put lemmas show theorem main new proof parts symmetric encryption 
theorem secure encryption scheme definitions initial final hybrid combined systems ch defined section reactively indistinguishable 
proof 
assume contradiction reactive distinguisher dis distinguishes ch negligible advantage 
dis combines honest users adversary final distinguisher 
similar definition advantage defined denote probabilities dis outputs run ch respectively security parameter construct successful adversary sc underlying symmetric encryption scheme precisely machine symcomb definition 
adversary sc defined follows security parameter randomly chooses 
polynomial bound number di erent hybrids lemma 
simulates rewritten hybrid system definition interaction reactive distinguisher dis lets interact directly machine symcomb sc attacks 
dis outputs bit sc outputs lemma constructed adversary sc symcomb choice perfectly simulates depending bit symcomb 
denote probability dis outputs run omit security parameter readability 
probability sc guesses correctly specific want dis output 
lemma success probability sc random choice 

polynomial absolute value di erence guessing probability negligible 
negative invert output sc obtain attacker positive negligible guessing advantage 
desired contradiction lemma 
bisimulations show bisimulations original cryptographic library extended symmetric encryption 
corresponds steps 
bisimulations mappings ch mh called derivations essentially extract part combined system :10.1.1.4.5735
initial final combined systems equal original combined system entries belonging symmetric encryption extensions derivations :10.1.1.4.5735
tedious part proof novelty symmetric encryption sketch 
bisimulation proof relies certain properties individual systems ideal real simulator joint invariants combined systems 
lemmas sections invariants section 
properties retained change adapted obvious ways 
examples retained properties indices handles unique length bounds retained equality real ideal lengths 
example property adapted obvious way real lengths equal types correspond real words 
new type pkse added exceptions 
order show ideal look procedure decryption works add invariant essentially covers case simulator action receipt new adversary key enters possible encryptions procedure real id skse 
formally invariant similar symmetric authentication states real parsing entry type symenc succeeds corresponding attributes ideally 
purpose derivations properties invariants described definition 
definition bisimulation property input retains invariants mean resulting transitions ch retain invariants true input 
input mh state derived ch probability distribution state equals states derived state ch similarly input state derived probability distribution state equals states derived state called correct derivation 
properties invariants obviously true initially databases empty counters 
show inputs retain invariants 
unfortunately true runs combined systems nonces collide generation di erent secret keys 
exceptional runs collected error sets 
remaining part fully detailed proof consists relatively long tedious part shows new inputs retain invariants certain defined error sets final reduction proofs show probability error sets negligible 
part aided certain lemmas type inputs basic commands send commands network inputs majority invariants automatically fulfilled general aspects cryptographic library 
lemmas continue hold symmetric encryption added verified text inspection 
error sets arise due symmetric encryption known types main cryptographic properties secrecy ciphertext integrity taken care hybrid argument 
particular shown entries nonces keys honest participants collide adversary guess random values keys ideally able know 
proofs 
provably secure idealization symmetric encryption dolev yao style cryptographic library allows cryptographically sound security proofs entirely way accessible current automated proof tools :10.1.1.4.5735
security holds arbitrary attacks arbitrary contexts standard definition authenticated encryption 
benefit adding symmetric encryption cryptographic library impressive protocols clark jacob library expressed operations constraints cryptographic library protocols expressed 
remaining protocols excluded commitment problem require hash functions model message authentication codes require number theoretic operations exponentiation exclusive 
abadi :10.1.1.29.1076
formal eavesdropping computational interpretation 
proc 
th international symposium theoretical aspects computer software tacs pages 
abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
proc 
st ifip international conference theoretical computer science volume lecture notes computer science pages 
springer 
backes pfitzmann 
cryptographically sound security proof needham schroeder lowe public key protocol 
proc 
rd conference foundations software technology theoretical computer science 
backes pfitzmann waidner :10.1.1.4.5735
composable cryptographic library nested operations extended 
proc 
th acm conference computer communications security pages 
full version iacr cryptology eprint archive jan eprint 
iacr org 
backes pfitzmann waidner 
symmetric authentication simulatable cryptographic library 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 
extended version iacr cryptology eprint archive eprint iacr org 
backes pfitzmann waidner 
universally composable cryptographic library 
iacr cryptology eprint archive jan 
eprint iacr org 
beaver 
plug play encryption 
advances cryptology crypto volume lecture notes computer science pages 
springer 
beaver haber 
cryptographic protocols provably secure dynamic adversaries 
advances cryptology eurocrypt volume lecture notes computer science pages 
springer 
bellare 
authenticated encryption relations notions analysis generic composition paradigm 
advances cryptology asiacrypt volume lecture notes computer science pages 
springer 
bellare rogaway 
random oracles practical paradigm designing cient protocols 
proc 
st acm conference computer communications security pages 
bellare rogaway 
encode encryption exploit nonces redundancy plaintexts cient constructions 
advances cryptology asiacrypt volume lecture notes computer science pages 
springer 
benaloh 
communication 
computer science technical report clarkson university 
canetti feige goldreich naor 
adaptively secure multi party computation 
proc 
th annual acm symposium theory computing stoc pages 
canetti goldreich halevi 
random oracle methodology revisited 
proc 
th annual acm symposium theory computing stoc pages 
clark jacob 
survey authentication protocol literature version nov 
www cs york ac uk jac papers ps gz 
damgard nielsen 
improved non committing encryption schemes general complexity assumption 
advances cryptology crypto volume lecture notes computer science pages 
springer 
dolev yao 
security public key protocols 
ieee transactions information theory 
impagliazzo 
logics reasoning cryptographic constructions 
proc 
th ieee symposium foundations computer science focs pages 
laud 
symmetric encryption automatic analyses confidentiality active adversaries 
manuscript 
laud 
semantics program analysis computationally secure information flow 
proc 
th european symposium programming esop pages 
lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proc 
th acm conference computer communications security pages 
millen 
freedom decryption 
information processing letters june 
mitchell mitchell scedrov 
linguistic characterization bounded oracle computation probabilistic polynomial time 
proc 
th ieee symposium foundations computer science focs pages 
mitchell mitchell scedrov 
probabilistic time process calculus analysis cryptographic protocols preliminary report 
electronic notes theoretical computer science 
pfitzmann waidner 
model asynchronous reactive systems application secure message transmission 
proc 
nd ieee symposium security privacy pages 
extended version cryptology eprint archive report eprint iacr org 
rogaway bellare black krovetz 
block cipher mode operation cient authenticated encryption 
proc 
th acm conference computer communications security pages 
yao 
theory applications trapdoor functions 
proc 
rd ieee symposium foundations computer science focs pages 
set simulator 
simulator give formal description simulator simh sketched section 
states simulator state simh consists database variables steps 
input port 
entry attributes hnd primary key attribute straightforward ideal real system entries created completely parsing incoming message recursively 
word real representation add arg list additional arguments 
typically 
key identifiers adv corresponding secret key received adversary keys honest users simulator generated encryption key form honest sk 
variable denotes current size temporarily algorithm id real 
variables steps 
count inputs port 
corresponding bounds bound 
max network ports max 
bounds included ensure polynomial runtime order obtain correct functionality second bound reached destroy interaction thh simh allow distinguishing ideal real system 
new primitive enlarge second bound alter proof remains polynomially bounded 
length functions inputs tacitly defined domains 
evaluation send commands simh receives unsolicited input thh contrast immediate result local command result hnd send command honest user insecure channel 
simh looks corresponding real message hnd word constructs algorithm id real hnd side ects 
outputs port net 
algorithm id real recursive layer builds real word real words certain components 
need add new type dependent constructions new types briefly repeat structure set context 

call type hnd 
hnd adv parse hnd 
ignore parentheses case type symenc expecting type typeset sks ske garbage max len hnd max hnd hnd len hnd max len certain domain expectations arguments hnd automatically fulfilled interaction thh extended command adv parse new types 


hnd hnd set 


hnd set hnd hnd hnd word recursive call id real hnd 
arg real 


construct enter real message depending type list new types type pkse call sk symenc key set hnd honest sk 
type skse pkse hnd hnd claim pkse hnd add arg form honest sk 
set sk hnd 
type symenc claim hnd hnd pkse hnd hnd distinguish cases pkse hnd add arg honest sk pkse hnd add arg sk pkse hnd word hnd cleartext handle length output symenc sk hnd :10.1.1.29.1076
claim len hnd simh encrypts fixed message correct length list 
len list len nonce len len sk sk sr sk 
encrypt sym encrypt sk len set nonce len symenc sr hnd 
evaluation network inputs simh receives input port net len max len verifies tagged list 
translates corresponding handle hnd recursive algorithm hnd real id side ects outputs adv send hnd port 
algorithm real id recursively parses real message builds corresponding term thh enters messages arbitrary message hnd real id works follows 
handle hnd hnd word returns 
sets type arg parse calls type specific algorithm add arg real id type arg 
real id sets hnd hnd add arg 
provide type specific algorithms new types 
add arg real id skse 
call skse hnd gen symenc key set adv key identifier add arg secret key 
skse sk sr format ensured preceding parsing 
handle hnd hnd type symenc hnd word symenc sr nonce len symenc len len sym decrypt sk recursive call hnd real id call adv fix symenc content skse hnd hnd hnd 
return add arg add arg real id symenc 
symenc sr parsing ensures format 
skse skse hnd skse hnd type skse skse hnd word sr sym decrypt sk sk skse hnd word set keys known adversary decrypts message skse denote union sets skse skse skse hnd skse arbitrary recursive call hnd real id 
secondly call hnd sym encrypt skse hnd hnd 
thirdly skse hnd skse skse hnd order call adv fix symenc content skse hnd hnd hnd 
return 
skse call hnd adv unknown symenc len return 
properties simulator simulator polynomial time 
handle output thh rejected simh counters steps simh steps thh reach bounds 
shown new bound max steps steps cf :10.1.1.4.5735
section 
interaction thh simh real id steps increased linearly number existing encryption existing keys new secret key update arguments existing encryption entry new encryption get existing key argument 
means enlarge bounds maintain correct functionality simulator 
polynomial number encryptions keys created coarse bound max entries honest users plus polynomial runtime remaining ones 
omit details 
corresponding ideal length functions bounds real length functions list len nonce len skse len symenc len corresponding ideal length functions computed follows skse len list len len skse skse len nonce len bounded max len symenc len symenc len list len nonce len symenc len list len len symenc nonce len nonce len symenc len 
postponed proofs proof lemma sc adversary succeeds attacking symcomb probability negligible function construct adversary sd follows 
sd adversary sc blackbox maintains initially empty database sym ciphers sd attributes msg ranging bit initially 
defined sd reacts outputs sc usually symcomb 
generate 
sd sets 
symenc 
sd returns 
outputs symenc len answers ciphertext sd sets sym ciphers sd returns sc 

sd returns 
sets sym ciphers sd msg outputs sc outputs forwards obtained message sc bit guess sd outputs show adversary sd machine perfectly simulates machine symcomb bit ciphertext integrity encryption scheme violated 
establish invariants runs sd runs symcomb choose key sk get inputs 
database sym ciphers sd sd equal database sym ciphers symcomb 

sym ciphers sd sym decrypt sk 

sym ciphers sd set ciphertexts 
show invariants retained outputs simulation correct certain runs violate ciphertext integrity 
output generate sc encryption decryption commands symcomb yield sk symcomb exactly sd 
assume output generate occurred sk symcomb 
simulation encryption commands key generation commands clearly perfect invariants remain correct 
consider decryption command 
set sym ciphers sd msg distinguish cases 
sd outputs symcomb outputs sym decrypt sk 
equals invariant 
sd outputs symcomb outputs sym ciphers msg equals invariant 
sd outputs 
invariant implies symcomb output sym decrypt sk 
sd outputs 
outputs sym decrypt sk 
symcomb returns sym ciphers msg invariant implies 
obtain exception perfect simulation 
probability runs exception perfect simulation fourth case occurs 
success probability adversary sd cases sd successful sc successful symcomb 
negligible obtained desired contradiction chosen ciphertext security 
negligible 
derive successful attack ciphertext integrity 
intuitively possible ciphertext exceptional case validly decrypted sk output si adversary acts sd sd outputs symenc len si outputs symenc len 
clearly simulates encryption commands perfectly case 
decryption case sd si output sd si output respectively 
outputs sym decrypt sk know outputs decryption simulated perfectly 
exception means exactly condition new ciphertexts definition 
exceptional run si successful attack ciphertext integrity 
si success probability uses 
desired contradiction ciphertext integrity 
proof lemma lemma clearly hold perfect indistinguishability keys sk sk equal encryption machine symcomb encrypting decrypting oneself simple rewriting 
su cient show sk sk operations en decryption perfectly indistinguishable users adversary 
show information shannon sense flows word sk skse ind word honest users adversary length sk sk sk length skse len leaking length sk destroy perfect simulation 
overview cases proof 
show information sk output ports honest users 
outputs occur result basic commands network inputs 
resulting outputs database handles types clearly reveal word attribute skse ind exceptions commands get len outputs length entry retrieve outputs word attribute entry type data 
explained leaking length sk problem 
entries type data created command store depend word attribute entry particular sk absence information flow simulated key sk show information flows network ports adversary 
need consider authentic insecure channels distinguish outputs time skse ind encryption time 
time definition symenc hybrid systems guarantees adversary handle key skse ind hnd keys adversary handles counted 
time property implies term sent channel skse ind contained term term wrapped encryption key skse ind adversary handle 
definition commands adv parse sym decrypt implies adversary get handle skse ind time skse ind hnd implies skse ind hnd time show information key flows database entries ideally key component 
application data nonces types keys clear definition 
word attribute list fully determined word attributes contained terms list 
word attribute public key encryption digital signature authenticator determined word attributes contained terms fresh random value parts word attribute secret key 
secret key showed depend word attributes symmetric keys 
word attribute symmetric encryptions depends word attributes contained terms fresh random value parts word attribute secret key precisely skse ind word skse ind index key encryption 
part independent sk skse ind word 
case output term skse ind ideal component interesting part proof know adversary get handle skse ind hnd hybrid system prepared real output 
treat term ind word skse ind tree ind 
initial combined system constructs network outputs simh translates ideal output ind thh recursive procedure id real 
interaction thh procedure unchanged hybrid systems term parsed far possible adv parse 
gives adversary handle skse ind certain cases particular skse ind encrypted term 
cases show absence information flow prior replacements real encryptions encryptions fixed messages hybrid system 
case skse ind ideally occurs public key encryption secret key unknown adversary cleartext argument component 
hybrid systems real public key encryptions replaced encryptions fixed messages len see step 
information flow real cleartext word length cleartext matter shown 
second case skse ind ideally occurs symmetric encryption key skse ind adversary handle time term sent 
case know skse ind encryption time adversary handle 
got position attribute skse ind pos case property ensures order skse ind ind order skse ind ind implies skse ind encryption time adversary handle got position attribute skse ind pos actual words encrypted corresponding real key sk simulated messages len particular independent real key sk possibly length matter shown 

