scalable certi cation typed assembly language dan grossman greg morrisett department computer science cornell university 
type certifying compiler maps source code machine code target level type annotations 
target level annotations possible prove easily machine code type safe independent source code compiler 
useful range source languages compilers target language type system provide powerful type constructors encoding higher level invariants 
unfortunately dicult engineer type systems annotation sizes small veri cation times fast 
describe experience writing certifying compiler targets typed assembly language talx discuss general techniques keep annotation sizes small veri cation times fast 
quantify ectiveness techniques measuring ects sizeable application certifying compiler 
techniques include common subexpression elimination types higher order type abbreviations selective cation dramatically change certi cate size veri cation time 
background certifying compiler takes high level source code produces target code certi cate ensures target code respects desired safety security policy 
date certifying compilers primarily concentrated producing certi cates type safety 
example sun javac compiler maps java source code statically typed java virtual machine language jvml code 
jvml code includes type annotations veri er data ow analysis ensure code type safe 
instructions type system jvml relatively high level speci cally tailored java 
consequently jvml ill suited compiling variety source level programming languages highperformance code 
example jvml provides high level method call material supported part afosr arpa radc national science foundation graduate fellowship 
opinions ndings recommendations expressed publication authors re ect views agencies 
method return operations 
provides provision performing general tail calls methods 
jvml dicult target compilers functional languages scheme require tail call elimination 
addition current platforms jvml interpret programs compile native code 
achieving acceptable performance demand compilation deal optimization 
avoid security safety holes translation jvml native code done certifying compiler 
way verify safety resulting code trusting just time compiler 
example certifying compiler necula lee touchstone compiler 
touchstone compiles small type safe subset optimized dec alpha assembly language 
key novelty touchstone certi cate produces formal proof code type correct 
checking proof type correctness relatively easy especially compared ad hoc veri cation process jvml 
touchstone certi cates provide higher degree trustworthiness 
proofs touchstone system represented generalpurpose logical framework lf 
advantage lf encode proofs implementation perspective easy change type system target language 
particular proof checker parameterized set primitive axioms inference rules ectively de ne type system 
checker need change rules changed 
consequently lf easy change type systems adapt di erent source languages di erent compilation strategies 
uses di erent type system certifying output special compiler java 
changing type system easy implementor doing enormous proof burden change requires proof soundness type system respect underlying machine semantics 
constructing proofs extremely dicult task 
absence proof clear assurances veri er providing 
alternative approach goal easy certifying compilers produce provably code having change type system target language 
way suces write trust veri er type system 
studying design implementation generalpurpose type systems suitable assembly language :10.1.1.12.4086
ultimately hope discover typing constructs support certifying compilation orthogonal programming language features 
current focuses design extremely expressive type system intel ia assembly language veri er call talx :10.1.1.33.3468
possible avoided including high level language abstractions procedures exception handlers objects 
fact high level operation talx primitive memory allocation 
baked compiler speci abstractions activation records calling conventions 
type system talx provides number primitive type constructors parametric polymorphism label types existential types products recursive types encode language features compiler invariants 
type constructors studied contexts modeled proven sound group 
addition shown encode number important language compiler features type constructors 
example encoding procedures easily supports tail call optimizations control ow transfers achieved simple machine level jumps 
words change type system talx support optimizations 
type soundness talx ensures compilers targeting talx produce code safe run time behavior 
speci assurances program counter point executable code unallocated memory dereferenced system routines input output called inappropriate arguments 
respects talx provides attractive target certifying compilers 
problem unfortunately particularly dicult engineering tradeo arises certifying compiler targets general purpose type system talx encoding high level language features compiler invariants optimizations primitive type constructors results extremely large types type annotations larger code 
real danger goal general purpose type system defeated practical considerations space time 
case study writing certifying compiler targets general purpose typed assembly language talx 
source language compiler called popcorn shares syntax number advanced language features including rst class parametric polymorphism non regular algebraic datatypes limited pattern matching function pointers exceptions rst class data types modules language suitably high level ported various ml libraries popcorn needing change structure substantially 
certifying compiler popcorn written popcorn 
talx type system expressive far able accept safe assembly programs 
expressive allow reasonable translation popcorn linguistic features 
compiler invariants encoded primitive typing constructs talx dicult aspect ecient scalable veri cation handling potentially enormous size target level types 
experience suggest general techniques controlling overhead believe transcend speci cs system 
ecacy techniques demonstrated quantitatively libraries compiler 
particular size type annotations time needed verify code essentially linear size object code 
constant factors small permit veri cation entire compiler minute 
section give taxonomy general approaches reducing type annotation overhead discuss projects related certifying compilation 
informal description existing techniques classi cation useful know attempt classify approaches 
section summarize relevant aspects talx type system annotations veri cation process 
show features encode provably safe compilation control ow aspects popcorn including procedures exceptions 
extended example demonstrates expressive type system permit reasonable compilation language speci cally designed 
shows qualitatively handled naively type annotation size unwieldy 
section example analyze approaches examined reducing type annotation overhead 
section presents quantitative results investigation conclude talx approach scales verify popcorn compiler largest popcorn application written 
techniques contribute signi cantly reducing overhead certifying compilation 
summarize collection guidelines designers low level safety policies 
approaches ecient certi cation keeping annotation size small veri cation time fast presence optimizations advanced source languages important requirement practical system relies certi ed code 
section classify approaches managing overhead certifying compilation discuss relative merits 
approaches mutually exclusive system probably elements 
bake approach type system supports way compiling compilers need write way 
example type system calling convention require compilers group code blocks procedures 
jvml touchstone special approach 
assumptions procedures eliminates need annotations describing interactions procedures 
inhibits inter procedural optimizations inter procedural register allocation dicult compile languages control features exception handlers 
general bake approach re ects particular source features target language providing low level constructors suitable encoding variety source constructs 
example certi er special rst processes class descriptor form close jvm class descriptors programs conforming jvml class hierarchy type system certi able checker 
general frameworks inevitably bake underlying machine requires 
talx example labels formed code examine actual address implement label 
abstraction prevents clever implementation techniques 
veri able safety policy impose conservative restrictions choosing restrictions crucial design decision fundamental part policy 
don optimize approach complicated analysis necessary prove optimization safe reasoning involved encoded annotations 
example compiling dynamically typed languages scheme dynamic type tests general necessary ensure type safety 
simple strategy perform appropriate type test operation 
approach veri er easily ensure safety minimum annotations 
strategy essence veri cation approach suggested kozen 
results relatively small annotations fast veri cation price performance exibility 
contrast optimizing compiler may attempt eliminate dynamic checks performing soft typing analysis 
optimized code requires sophisticated type system convince veri er type tests unnecessary 
veri cation tractable type systems require additional annotations 
example touchstone type system supports static elimination array bounds checks requires additional invariants proof terms support optimization 
example record initialization easy way prove memory properly initialized write memory basic block memory allocated 
proving instruction schedules safe may require data ow annotations describe location uninitialized memory 
unoptimized code tends uniform turn annotations uniform 
example callee save register pushed stack callee register annotations describe stack program common 
techniques improve results compression approach discussed expense eciency 
reconstruction approach easy veri er infer correct annotation annotations elided 
example necula shows simple techniques may automatically reconstructing large portions proofs produced touchstone compiler 
important veri cation time unduly su er 
reason code producers know ects annotation elision 
unfortunately expressive systems talx forms type reconstruction intractable undecidable 
veri er provide simple heuristics default guesses maneuvers weaker forms bake approach 
extreme approach reconstruction include generalpurpose theorem prover veri cation system 
prover generates proofs independently checked trusted computing base larger complex 
generated proofs need concise 
talx project maintained design goal type checking essentially syntax directed search backtracking realm ecient veri cation 
necula rahul suggests annotations provide proof guide prover nondeterminism 
essence insight compiler knows veri er decision procedure guide reconstruction avoid overhead search 
certi cation systems invariably reconstruction type construct straightforward compute types parts 
example explicitly typed source languages require explicit types term types reconstructed explicit types variables 
similarly lowlevel systems explicitly describe single instruction changes state program 
instructions just ecient examine instruction recompute information 
compression approach collection annotations create concise representation contains information 
technique producing compact wire format run standard program gzip serialized version 
repetition annotations manifests repetition byte stream technique amazingly ective see section 
help improve time space required veri cation byte stream uncompressed prior processing 
slightly domain speci technique create binary encoding shares common subterms annotations 
approach ectively common subexpression elimination types 
veri er aware sharing exploit consume space 
interesting tradeo respect place modi cation 
simpli cation converting annotation canonical form internal sound contexts performed shared term 
transformation context dependent veri er copy presence sharing 
reducing size jvml annotations largely followed compression approach 
example projects ways exploit similarities entire archive class les 
carefully design wire format downloading veri cation may pipelined 
talx encoding currently property essential language prevents 
shao associates investigated engineering tradeo sharing context typed intermediate languages 
suggest consistent hash consing essentially line common subexpression elimination suspension lambda encoding solution 
hash consing scheme results type reductions identical reductions require retrieving answer table 
problem managing low level types compilation quite similar problem managing veri cation case type directed compilation appropriate specialize task compiler 
note comparing size compressed low level types size uncompressed object code somewhat misleading object code compresses quite :10.1.1.147.3931
domain speci techniques include instruction format account generic compression technique processing entire bytes detecting common sequences instructions detecting similarity modulo rarely repeated eld branch target address 
analogous techniques may prove useful annotations know tried 
abbreviation approach step simple sharing higher order annotations factor common portions 
annotations essentially functions level types 
tarditi approach til compiler 
show section approach exploit similarities sharing 
furthermore higher order annotations relatively easy compiler writer express high level abstractions type system target language 
experience abbreviations places additional burden compiler writer reasoning terms abstractions 
veri er expand abbreviations order verify code veri cation time may su er 
higher order abbreviations important component certi framework appel felty propose 
suggest formalizing machine semantics safety policy higher order logical framework 
code producer supply formal proof program obeys policy 
proof expressed directly terms machine semantics presumably enormous appel felty suggest compiler rst prove collection lemmas sound respect semantics apply lemmas program 
sense lemmas parameterized abbreviations de ne suitably concise type system 
system approaches reduce annotation size veri cation time 
attempted minimize bake don optimize approaches favor techniques 
javac touchstone special talx commitment calling convention data representation 
fact built notion functions control ow just blocks code 
design challenge talx provide generally useful constructors compilers novel ways encode safety compilation strategies 
type system talx bake primitive logical description machine 
example builds distinction integers pointers 
result programs low bits pointers store information mask bits reading memory 
memory locations statically divided code data extensions support run time code generation 
order investigate practicality expressive low level safety policies relied rigorous hand written proof type soundness procedural implementation veri er 
formal approach encode proof logical framework veri er produced mechanically proof 
approach able examine feasibility safety policies far larger scale previously possible 
date certi ers proof carrying code technology safety policies compiler targeted compiler independent safety policies appel felty 
talx designed written separate compilers target talx 
discuss optimizing popcorn compiler 
compiler certi ed talx program kilobyte executable compiled eighteen lines source code 
compiling talx extended example section brie review structure talx type system annotations process veri cation 
follows relevant talx constructs necessary purposes sucient treat types low level syntax describing pre conditions 
purpose dwell artifacts talx relative expressiveness 
want give intuition claims believe transcend talx safety policy bake data control abstractions annotations compiler uses encode large 
fact annotations describing compiler conventions consume space annotations speci particular source program 
annotations compiler conventions large uniform presence optimizations 
focus purposely explain aspects annotations mention general things encoding 
reader interested details consult literature :10.1.1.33.3468:10.1.1.12.4086
talx object le consists ia assembly language instructions data 
conventional assembly language instructions data organized labeled sequences 
conventional assembly language labels equipped type annotation 
type annotations labels instruction sequences called code types specify pre condition satis ed control may transferred label 
pre condition speci es things types registers stack slots 
example code type annotating label int ebx ecx compilers simple stack compiler popcorn compiler core subset scheme 
int int control may transferred address register eax contains byte integer register ebx contains integer value register ecx contains pointer record byte integers 
veri cation code proceeds labeled instruction sequence building typing context assumes registers values types speci ed pre condition 
instruction type checked sequence current set context assumptions possibly producing new context 
instructions veri er automatically infers suitable typing postcondition style similar data ow analysis strongest post conditions 
instructions require additional annotations help veri er 
example necessary explicitly coerce values supertype explicitly instantiate polymorphic type variables 
labels require type annotations 
code blocks annotations may checked multiple times di erent contexts depending control ow paths program 
ensure termination veri cation type checker requires annotations labels moved register stack data structure closure labels targets backwards branches loop headers labels exported object le function entry points 
restrictions sucient veri cation terminate 
discuss labels explicit types detail section 
conventional compiler certifying compiler translates highlevel control ow constructs popcorn suitable collections labeled instruction sequences control transfers 
purposes control ow popcorn takes forms intra procedural jump function call return invocation current exception handler currently compiler performs intra procedural optimizations code types function entry labels quite uniform derived systematically source level function type 
simplicity discuss code types rst 
discuss code types labels internal functions focusing complicated function entries 
emphasize distinction di erent avors code labels function entries internal labels exception handlers popcorn convention encoded preconditions way speci talx 
constructed toy compilers radically di erent conventions 
function entry labels running example consider popcorn function foo takes parameter int returns int 
popcorn type int compiled return addresses important exception need explicit types 
talx type int 
arithmetic operations allowed values type treating pointers 
compiler uses standard calling convention ia architecture 
convention parameters passed stack return address stack return value passed register eax caller pops parameters return 
speci cs encoded talx giving foo pre condition foo ts 
fesp eax int esp int sg int sg pre condition foo concerns esp stack pointer requires register point stack contains return address pre condition int parameter stack return address expects int register eax stack shape int 
int caller pops parameters 
pre condition polymorphic rest stack indicated universal quanti cation stack type variable technique allows caller current type stack entry ensures type preserved return 
types talx classi ed kinds types types confuse standard types int non standard types stack types 
maintain distinction label bound type variable kind ts 
notice annotation includes information need safety policy dictated calling convention 
case presumably just give parameter types return type function 
systems including certi er special go encode types string label appears annotation necessary 
course safety policy attaches speci meaning characters label annotations encoded assembly listing 
annotation quite describe standard calling convention 
particular standard requires registers ebx esi edi 
requires ebp traditionally frame pointer callee save 
compiler uses ebp exception handler 
encode callee save registers polymorphism foo ts fesp int esp int ebx esi edi int ebx esi edi pre condition indicates standard types appropriate registers types foo called underlining emphasis 
kind includes types values register 
return address invoked 
annotation restricts behavior foo preserve registers know values types 
formally fact follows parametricity 
notice wish di erent conventions registers callee save need change pre condition foo 
particular need change underlying type system talx 
detail required encode compiler translation exception handling just sketch main ideas :10.1.1.12.4086
reserve register ebp point middle stack pointer current exception handler resides 
handler expects exception packet register eax 
foo need raise exception pre condition encode strategy 
encode foo returns normally exception handler ebp 
express details operator appending stack types 
foo ts ts fesp int esp int fesp eax ebp fesp eax ebx esi edi int fesp eax ebp fesp eax ebx esi edi urge reader focus details notice additions particular foo appropriate safety policy bake speci treatment exception handlers 
assumed type exn exception packets 
talx provide type directly compiler encode representation extensible sum 
occurrences exn fact replaced type tm rw int rw rw interest type setting spare reader result 
sake completeness er nal amendment precondition correct 
compiler schedules function calls heap records may partially initialized 
strategy arguably better don optimize approach initializing records basic block requires convince veri er aliases partially initialized records escape 
particular pre condition foo uses capability variables shown indicate create aliases partially initialized records reachable caller exception handler 
constructor 
joins capabilities produce harder satisfy capability omit de nition 
foo ts ts fesp int esp int fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap int fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap short compiler complicated inter procedural invariants naive encoding talx concise 
reader invited encode function takes function pointer parameter 
parts particular example function foo return type written parameter types written twice 
parts functions take return integers 
internal labels section pre conditions labels targets intraprocedural jumps 
simplicity consider functions declare local exception handlers 
special case far common worth considering explicitly 
compiler perform intra procedural optimizations register allocation pre conditions internal labels uniform function entry labels 
speci cally encode properties program point label designates local variable may reside register stack 
stack slots may hold live values di erent control ow paths label stack slot may values di erent types 
callee save values may reside stack remain registers 
heap records may partially initialized 
describe relevant aspects term translation callee save values remain registers stored stack function prologue restored registers function epilogue 
space storage just shallower return address 
local variables registers stored spill slots stack 
number spill slots remains constant body function 
strategy fairly normal far speci dictated talx 
original popcorn compiler perform register allocation simply pushed popped variables stack needed 
pre condition internal labels gives type location register spill slot live local variable 
stack slot live give place holder type stack type describes stack correct size 
di erent control ow paths may stack slot temporary variables di erent types 
cases previously seen type serve place holder 
talx provides primitive type top supertype types ranging word sized values 
give type dead stack slots control ow join appropriate subtyping control transfers handled implicitly veri er 
addition live variables invariants involving stack exception handler preserved control ows labels information looks function entry labels 
example suppose function foo uses callee save registers needs spill slots 
furthermore suppose internal label live variables type int register esi middle spill slot 
correct pre condition ts ts 
fesp top int top int esp int fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap int fesp eax exn cap ebp fesp eax exn cap cap esi int register allocator tries callee save registers functions save restore 
example suppose registers esi edi function 
internal labels encode value type stack appropriate place esi contains value type edi contains value type 
records partially initialized entry precondition complicated capability omit details 
clear point type annotations internal labels considerably uniform function entry annotations 
recovering conciseness eciency continuing examples previous section describe techniques reducing size annotations 
discuss techniques notably hash consing reduce space time required veri cation 
section quanti es ectiveness techniques 
theoretically possible polymorphism supertype practice doing unwieldy 
sharing common subterms annotations repeat information greatly reduce total size replacing identical terms pointer shared term 
example consider pre condition function foo takes returns int type exn tm rw int rw rw foo ts ts fesp int esp int fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap int fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap removing common subterms hand represent information pseudo annotation tm rw int rw rw fesp eax cap int int esp ebp ebx esi edi cap foo ts ts fesp ebp ebx esi edi cap pre conditions share subterms 
example pre condition previous section rewritten ts ts 
fesp top int top ebp cap esi int despite exploiting signi cant sharing example illustrates limitations sharing common subterms 
share occurrences ts ts depends syntax language 
second pre conditions functions di erent parameter types return types exploit subterms 
possible shortcoming demonstrated alpha equivalent terms may appear 
practice compilers re variable names compiler introduced variables detecting alpha equivalence purpose sharing important 
parameterized abbreviations talx provides user de ned compiler de ned higher order type constructors 
functions types types uses 
example necessary encode source level type constructors array list object types 
show higher order type constructors de ne parameterized abbreviations 
abbreviations exploit sharing di erent types sharing common subterms 
veri er unable exploit abbreviations veri cation reasons explain 
function entry pre condition compiler creates parameter types return type create parameterized abbreviation describes generic situation 
label apply abbreviation appropriate types 
type fn params ts ret 
ts ts 
fesp ret esp params fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap params fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap foo int se int new feature abbreviation type se describes empty stacks 
terminate list parameter types 
abbreviations greatly simpli es structure compiler invariants calling conventions 
clear compiler independent veri er exploit abbreviation veri cation 
suppose rst instruction block foo increments input parameter 
veri er check pre condition int se int safe perform increment value top stack 
veri cation requires inspecting result abbreviation application veri er know argument int se describes top stack 
show section abbreviations slows veri cation phenomenon 
abbreviation widely useful function entry pre conditions similar 
abbreviations internal labels capture additional properties distinguish pre conditions 
addition parameters need parameters spill slots live registers partial initialization issues 
primitive type constructor combining pre conditions 
way pass live regis ters pre condition merge pre condition describes reserved registers 
type fn params ts ret spills ts part regs 
ts ts 
fesp spills ret esp params fesp eax exn cap ebp fesp eax exn cap ebx esi edi cap params fesp eax exn cap ebp fesp eax exn cap cap part regs int se int top int top se ce int correct useful labels functions values stored stack 
don optimize approach functions meet description lose advantages callee save registers result 
better approach provide di erent abbreviations combination callee save values stored stack 
fact need abbreviations register allocator uses callee save registers xed order 
compiler provides abbreviations specialization possible appropriate 
require compiler writer write higher order abbreviations hope write tool took collection talx types re wrote terms automatically generated abbreviations 
creating optimal result appears dicult nding shortest simply typed lambda calculus term equivalent 
investigated heuristics discover useful abbreviations 
eliding pre conditions recall veri er checks code block assuming pre condition true processing instruction turn checking safety computing pre condition remainder block 
control transfer block suces ensure current pre condition implies pre condition destination label 
talx uses reconstruction approach allowing label pre conditions elided 
clearly result eliding pre condition direct decrease annotation size 
check control transfer block elided precondition veri er simply uses current pre condition source transfer check target block 
block elided pre condition multiple control ow predecessors veri ed multiple times possibly di erent pre conditions 
ensure veri er terminates prohibit annotation free loops control ow graph 
reason talx allows pre condition elided block target forward jumps 
restriction number times block checked number paths control ow graph block block path explicit pre condition 
number exponential number code blocks unwise elide explicit pre conditions 
section demonstrates exponential number paths rare occur disastrous ect veri cation time 
approach compiler takes set elision threshold insist code block veri ed times 
notice means merge points explicit pre conditions 
interpret mean code labels single predecessor explicit pre conditions 
higher values expect space requirements decrease veri cation time increase 
value minimize number labels explicit pre conditions 
unfortunately proven problem np complete 
know tractability 
currently compiler greedy depth rst traversal control ow graph leaving pre conditions threshold demands 
pathological cases heuristic arbitrarily poorly practice 
elision threshold constraining problem important minimize total number times verify blocks 
prefer verify block times order verify blocks fewer times 
structured programs intraprocedural jumps loops conditionals appears relaxed problem solved polynomial time number blocks algorithm impractical 
hash consing fast type operations far discussed techniques reducing size annotations code producer writes 
veri er explicit types provide guidance check assembly instruction safe 
checking veri er determines type context registers stack instruction types operands type context instruction 
operands subtypes types instruction requires 
short veri er creates type expressions checks subtype 
important operations consume little time space possible 
primary technique reducing space hash consing essentially just line form sharing 
types created rst check table see created 
return pointer table entry put type table 
result types consume space incur overhead managing table 
correct return type table interest fast lookup operations nd syntactically identical type 
general case decide subtype convert types normal form structural subtyping comparison 
common case easy optimize object pointer equal 
hash consing syntactically equal types pointer equal 
types object example strict subtype parts types may pointer equal usually avoid full structural comparison 
complications pointer equality consider alpha equivalent types equal 
maintain separate map performing costly type substitutions 
presence non empty map necessarily correct pointer equal types equal substitution applied 
fortunately compiler uses type variables consistently variable substitution map empty 
hash consing positive ect veri cation time reduce example applying abbreviation place update pointers shared result single reduction 
original longer appear hash cons table 
add level indirection alleviate shortcoming keep table purpose sharing point reduced form implementation currently 
common operation types substitution substituting variable operations need substitution include applying abbreviations instantiating polymorphic types 
need recursively substitute constituent types expect contain optimize common case avoid crawling free variables type store set type 
discussed section expect bene ts de bruijn indices performing type substitutions lazily 
unfortunately change pervasive chose investigate experiments discuss section 
experimental results section quantitative study certifying real program talx 
conclude targeting compiler independent safety policies practical scalable appropriate techniques 
example popcorn compiler 
compiler consists popcorn source les compiled separately 
interesting optimizations performed chaitin style intra procedural register allocation optimistic spilling conservative coalescing elimination fully redundant null checks object dereferences 
entire compiler roughly lines source code compiles kilobytes object code kilobytes running strip 
sizes report include sum les annotations just code labels 
include separate module interface les talx link checker uses ensure type safe linking 
execution times measured mhz pentium ii mb ram running windows nt 
veri er assembler written objective caml compiled native code 
rst show naive choices annotation language compiler produce system unacceptable space time overhead 
show actual implementation avoids pitfalls 
adjust various parameters disable various techniques discover usefulness individual approaches interact 
discuss extend techniques lower talx overhead 
bad approaches simple encoding talx annotations insucient 
consider system abbreviations developed section type annotations repeat types share put types code labels 
total annotation size program megabytes times size object code 
veri cation time attempt share common subterms created veri cation takes seconds verify les 
second possibility remove pre conditions possible 
put explicit pre condition code label label call destination backwards branch destination rst class value 
total size annotations drops megabytes 
veri er checks code blocks large number times 
total veri cation time rises minutes seconds 
coarse experiments yield immediate 
actual amount safety information describing compiled program large 
second number loop free paths application code places larger size code 
unwise veri cation time proportional number loop free paths second approach 
important certi ed code frameworks construct veri cation conditions veri cation time form weakest precondition computation 
essentially systems construct pre conditions loop free code segments backward ow analysis 
expressive system pre condition backward merge point logical disjunction conditions 
done naively constructed condition exponential size having di erent clause loop free path 
number loop free paths large clear constructing enormous pre condition wasteful 
compiler exploit weakness pre condition need optimized exponential amount path sensitive information 
conclude constructing weakest pre conditions way impractical 
annotations guide construction veri cation condition optional code pre conditions talx ll role 
usable system having shown bad matters get actual overhead system achieves 
identify main techniques overhead results 
show veri cation time roughly proportional le size fact suggests approach scale larger applications 
partition source code styles show overhead reasonable discuss salient di erences 
straw man systems constructed real encoding talx annotations uses tables share common occurrences 
specifically uses identi ers types kinds coercions indices tables contain annotations 
code producer avoid duplicates constructing tables 
bene approach proportional amount repetition small penalty annotations occur 
call technique sharing speci cally full elimination types le level 
sharing just line term refer sharing veri er types created veri cation 
sharing create parameterized abbreviations abbreviations developed section 
compiler provides abbreviations uses text version talx 
independent tool converts text version binary version sharing 
sense abbreviations sharing 
set elision threshold 
value forward control ow points need explicit pre conditions block veri ed times 
veri er uses hash consing share types created veri cation 
creating new type veri er consults table see encountered type previously 
uses type table 
entire sharing table parsed prior veri cation types table repeated 
reductions higher order type constructors performed lazy manner 
particular weak head normalization strategy memoization avoid unnecessary reductions duplicated reductions 
uses type recompute reduction 
shao associates similar strategy 
complications scope abbreviations hash consing table emptied verifying le 
memory scarce empty table point measure necessary practice 
note hash consing ect size explicit annotations hash consing attempts share types created veri cation 
total file size bytes verification time sec fig 

veri cation time vs file size system total annotation size drops megabytes kilobytes veri cation time drops seconds 
compilation time compiler takes seconds compile popcorn source les ascii talx les essentially microsoft assembler les augmented annotations 
separate tool takes seconds assemble les time includes creation binary encoding annotations sharing 
add optimizations compiler expect compilation time increase veri cation time 
may decrease object code size decreases 
performing gzip compression kilobytes annotations reduces size kilobytes 
ratio compression similar object les les compress kilobytes stripped les compress kilobytes 
desirable property veri cation time generally proportional le size 
eliding pre conditions time verify talx code proportional size code plus size normalized types annotations plus time look types context 
higher order abbreviations normalizing types theory take non elementary time 
pleased see ineciency occurred practice plots veri cation time total size object code plus annotations les compiler 
time stays roughly proportional le size grows order magnitude 
small les take proportionally longer verify start costs overhead hash consing 
les take just fraction second verify consider costs insigni cant 
far results entire compiler 
analyzing results di erent styles code gain additional insight 
course code source language compiled style object annotations veri cation size time code kb kb time sec ratio ratio polymorphic libraries monomorphic libraries type de nitions machine generated compilation fig 

ect di erent code styles compiler written authors 
partition les broad categories polymorphic libraries les provide generally useful utilities iterators generic container types 
examples include les lists dictionaries sets resizing arrays 
monomorphic libraries examples include les bit vectors arguments 
type de nitions les primarily de ne types compiler provide simple code create destruct instances type 
examples include les syntax popcorn compiler intermediate language syntax talx environment maintained translating intermediate language talx 
machine generated les include scanner parser 
compared styles code characterized small number large functions contain switch statements cases 
large constant arrays 
compilation les compilation 
examples include les type checking register allocation printing output 
summarizes annotation size veri cation time relative categorization 
size ratio annotation size divided object code size smaller better 
time ratio sum sizes divided veri cation time larger better 
importantly size ratios factor time ratios closer 
conclude particular style code written dominates overhead producing provably safe object code 
results di er interesting distinctions 
les type de nitions largest worst size ratio largest best time ratio 
type de nitions compiled annotations describe corresponding talx types associated object code 
size ratio arbitrarily high sum veri cation times slightly time verify les due secondary ects 
annotation size kb veri cation time sec sharing abbreviations uncompressed compressed hash consing hash consing fig 

ect abbreviations sharing subterms hash consing amount code source le goes zero 
time ratio surprising time consuming part veri cation checking instruction safe context 
relatively high size ratio machine generated code artifact parsers generated 
essentially di erent token types put large union 
code processes tokens lled annotations coerce values union 
size ratio polymorphic libraries slightly larger expected 
source level function polymorphic types needs explicitly name types 
talx notion function labels function enumerate type variables 
furthermore control transfers labels explicitly instantiate additional type variables 
time ratio noticeably worse compilation code 
style code contains higher proportion function calls libraries contain leaf procedures 
complicated type instantiations occur call site call instructions take time verify 
ectiveness individual techniques shown system achieves reasonable performance uses number techniques controlling annotation overhead discussed techniques ective 
section examine happens selectively disable techniques 
summarizes total annotation size elision threshold techniques selectively 
sharing tables sharing types coercions 
repeat types directly annotations 
share identi ers lengths strings insigni cant 
abbreviations abbreviations fully expanded annotations written 
uncompressed total size annotations 
compressed sum result running gzip le annotations separately 
nal columns give total veri cation time hash consing enabled 
pre conditions elided fortunately 
rst discuss ect sharing abbreviations explicit annotation size 
techniques appear ective ignore ect gzip 
abbreviations reduce size factor sharing reduces size factor 
abbreviations sharing reduces size seventeen percent compared system just sharing 
technique subsumes recover repetition 
really care size annotations sent code consumer consider running gzip 
clear gzip extremely ective worst result compressed annotations factor better best result uncompressed annotations 
subtle fact gzip achieves smaller result sharing binary encoding 
result surprised product tables implemented gzip performs compression 
short gzip constructs tables uses compact format encoding 
worse tables hide repetition gzip looks common strings 
conclude annotation size primary concern binary encoding remain gzip friendly 
abbreviations ective data gure suggests 
compiler abbreviations code pre conditions optimizing aspect annotation size eventually demonstrate amdahl law 
considered total annotation size removed explicit code pre conditions 
course result drastic measure able provides rough lower bound ectiveness abbreviations 
total size kilobytes abbreviations reduced size code pre conditions factor 
discuss ect techniques veri cation time 
gzip useless veri er works uncompressed annotations 
sharing signi cantly reduces veri cation time 
veri er conditions share types creates veri cation share types originally occur annotations 
result suggests types cover veri cation 
sharing abbreviations great help recover common occurrences 
sharing abbreviations hurt veri cation time 
time expand abbreviations veri cation outweighs time additional sharing gains 
hash consing di erent veri cation times closer 
hash consing table sharing sharing initially pay cost achieve rediscovery 
interestingly penalty abbreviations disappears 
believe result due fact hash consing abbreviation applied argument expanded result multiple places 
places abbreviations polymorphic function instantiated function type situations rare code 
parsing time small noticeable fraction di erence 
hash consing reduces veri cation time signi cantly careful implementation hashing 
example give hash cons table size near power number theory warns veri cation time takes longer hash consing 
news optimizing veri er reduced fundamental properties data structures 
bad news di erence veri cation times di erent parameters brittle 
reason hash consing improves veri cation time types occupy space expect better cache performance fewer garbage collections 
reason veri er function determining type subtype returns immediately types pointer equal 
function called times verifying compiler 
hash consing sharing abbreviations calls pointer equal arguments 
hash consing gure rises 
entire types pointer equal avoid structural comparison parts pointer equal 
hash consing recursive calls 
hash consing number recursive calls drops 
explained previous section talx code blocks targets forward branches need annotations ed unannotated control ow path 
elision threshold compiler ensures block veri ed times 
subject constraint uses simple greedy algorithm leave annotations labels 
shows ect changing value sharing abbreviations 
top chart shows total annotation size drops fteen percent 
conclude low level systems require pre conditions blocks 
additional space savings takes values larger quite small 
fact justi es experiments 
bottom charts show veri cation time di erent values veri cation time initially drops gets value 
phenomenon indicates takes lot time process explicit annotation compare pre condition 
takes values veri cation time rises noticeably seconds 
conclude range values allows reasonable time space tradeo takes larger values veri cation time rises sharply 
additional blocks pre conditions elided blocks checked large number times 
fact large time spent verifying di erent les varies drastically les blocks 
value nity means put explicit annotations veri er requires 
useful extensions system uncompressed safety annotations consume roughly half space object code describe infinity elision threshold uncompressed compressed elision threshold verification time sec infinity elision threshold fig 

ect elision threshold techniques sharing abbreviations elision help regard 
investigate current system best hope achieve techniques contribute reducing talx overhead 
moving current system supports demonstrate 
notice sharing common subterms ective share annotations entire le 
le level currently best compile les separately 
scenario object les packaged share annotations single table entire package 
current tools process package able generate measure size 
total size drops kilobytes kilobytes 
conclude di erent les project similar annotations able exploit property reduce overhead 
improvement rely understanding compiler conventions generic talx tool put separately compiled object les package 
second annotations describe coercions apply instruction currently shared 
common occurrences take byte represent sharing annotations carefully avoid increasing space requirements 
third veri cation time su ers signi cantly memory allocation garbage collection 
implemented hash consing address bottleneck shao associates experience building type directed compilers suggest suspension lambda encoding essentially de bruijn indices lazy substitution improve performance 
relegate modifying veri er experiment techniques 
fourth chosen uses type reconstruction eliminate explicit annotations 
example veri er performed uni cation rst order type variables compiler eliminate type applications control transfer points 
elision improve annotation size kilobytes 
compute gure elided instantiations veri er process result 
reconstruction approaches improve size presence gzip compressed annotations drop kilobytes kilobytes case 
summary talx system shows techniques sharing elision certi ed code scalable practical talx techniques aggressively achieve lower overhead 
popcorn compiler encodes safety output talx 
popcorn application serves largest application know compiled safe machine language 
believe safety policies tailored particular compiler encode aspects popcorn compilation relevant safety primitive constructs talx 
important factor scalability certifying compilation size code pre conditions 
experience certi cation systems 
common subexpression elimination explicit annotations practical necessity 
sharing terms created veri cation helpful important carefully manage overhead inherent doing 
compilers ectively exploit parameterized abbreviations encode invariants 
abbreviations improve size explicit annotations dicult exploit abbreviations veri cation 
serial compression utilities gzip helpful complete substitute techniques 
compression system requirement understand compression algorithm designing uncompressed format 
overhead proportional number loop free control ow paths program 
believe suggestions help projects avoid common pitfalls focus important factors achieving expressiveness scalability 
acknowledgments talx infrastructure product tal research group 
fred smith contributed greatly prototype popcorn compiler bootstrapping 
proved optimal annotation elision np complete elision threshold greater david kempe proved complexity results 
anonymous reviewers provided helpful comments 
david walker generously encouraged write report 

andrew appel amy felty 
semantic model types machine instructions proof carrying code 
seventh acm symposium principles programming languages pages boston ma january 

bradley nigel horspool jan vitek 
jazz ecient compressed format java archive les 
cascon november 

preston briggs keith cooper linda torczon 
improvements graph coloring register allocation 
acm transactions progamming languages systems may 

chaitin auslander chandra cocke hopkins markstein 
register allocation coloring 
computer languages 

christopher colby peter lee george necula fred blau 
certifying compiler java 
acm conference programming language design implementation pages vancouver canada 

karl crary 
simple proof technique certain parametricity results 
fourth acm international conference functional programming pages paris france september 

jens ernst william evans christopher fraser todd proebsting steven lucco 
code compression 
acm conference programming language design implementation pages las vegas nv june 

lal george andrew appel 
iterated register coalescing 
acm transactions progamming languages systems may 

neal glew 
type dispatch named hierarchical types 
fourth acm international conference functional programming pages paris france september 

neal glew greg morrisett 
type safe linking modular assembly language 
sixth acm symposium principles programming languages pages san antonio tx january 

harper honsell plotkin 
framework de ning logics 
journal acm 

luke hornof trevor jim 
certifying compilation run time code generation 
acm workshop partial evaluation semantics program manipulation pages san antonio tx january 

david kempe 
personal communication 

dexter kozen 
ecient code certi cation 
technical report department computer science cornell university ithaca ny january 

xavier leroy 
objective caml system documentation user guide 

steven lucco 
split stream dictionary program compression 
acm conference programming language design implementation pages vancouver canada june 

harry mairson 
simple proof theorem statman 
theoretical computer science september 

greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
talx realistic typed assembly language 
second acm sigplan workshop compiler support system software pages atlanta ga 
published inria technical report march 

greg morrisett karl crary neal glew david walker 
stack typed assembly language 
workshop types compilation volume lecture notes computer science pages kyoto japan march 
springerverlag 

greg morrisett david walker karl crary neal glew 
system typed assembly language 
acm transactions progamming languages systems may 

nadathur 
notation lambda terms ii re nements applications 
technical report cs duke university durham nc january 

george necula peter lee 
design implementation certifying compiler 
acm conference programming language design implementation pages montreal canada june 

george necula peter lee 
ecient representation validation proofs 
thirteenth symposium logic computer science pages indianapolis june 

george necula rahul 
oracle checking untrusted software 
eigth acm symposium principles programming languages pages london united kingdom january 

william pugh 
compressing java class les 
acm conference programming language design implementation pages atlanta ga may 

zhong shao christopher league stefan 
implementing typed intermediate languages 
third acm international conference functional programming pages baltimore md september 

fred smith david walker greg morrisett 
alias types 
ninth european symposium programming volume lecture notes computer science pages berlin germany march 
springer verlag 

tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm conference programming language design implementation pages philadelphia pa may 

philip wadler 
theorems free 
fourth international conference functional programming languages computer architecture pages london united kingdom september 

andrew wright robert cartwright 
practical soft type system scheme 
acm transactions progamming languages systems january 
