implementation performance compressed databases till donald kossmann sven guido moerkotte universit mannheim universit passau informatik iii fmi mannheim germany passau germany show compression integrated relational database system 
specifically describe storage manager query execution engine query optimizer database system extended deal compressed data 
main result compression significantly improve response time queries light weight compression techniques 
light weight compression techniques give results running tpc benchmark compressed database non compressed database database system experimental database system developed universities mannheim passau 
benchmark results demonstrate compression offers high performance gains queries moderate gains cpu intensive queries 
compression increase running time certain update operations 
recommend extend today database systems lightweight compression techniques extensive feature 
compression heavily technique today computer systems 
name just applications compression audio image video data multi media systems carry backups compress inverted indexes information retrieval know unix gzip dos zip commands ship files internet store large files software packages need 
compression advantages reduces costs storage media main memory disk tape saves io bandwidth disk tape network communication results improved performance applications 
negative side compression cause significant cpu overhead compress mail pi informatik uni mannheim de phone fax data place uncompress data time data compression result reduced performance cpu bound applications 
standard relational database applications execute fair amount cpu intensive operations joins aggregation compression wide acceptance relational database arena database vendors slowly adopting compression techniques products 
just give example compression query io costs minute cpu costs seconds resulting response time minute cpu io processing overlapped 
compression io costs query easily reduced seconds expensive compression technique cpu costs just easily increased minute resulting higher response time due compression 
show done right compression fact reduce response time queries 
show carefully designed system cpu overhead compression tolerable getting high benefits compression due reduced disk io time 
specifically set simple light weight compression techniques show database system extended exploit compression techniques 
address storage management issues efficient implementation small variable sized fields query engine issues efficient evaluation expressions compressed data predicates aggregate functions query optimization issues necessary refinements optimizer cost model order find query plans compressed databases 
optimizer cost model implemented proposed techniques database system universities mannheim passau 
give results performance experiments carried tpc benchmark tpc 
experiments demonstrate reductions size database achieved light weight compression techniques confirm compression improves performance queries factor extreme case 
shows weaker performance certain update operations 
remainder organized follows section lists related database compression 
section presents light weight compression techniques 
section explains queries executed presence compressed data 
section discusses tpc results 
section contains 
related related database compression focussed development new compression algorithms evaluation existing compression techniques database systems sev cor rh iw alm nr grs 
differs important ways interested showing compression integrated database system inventing new compression algorithms 
second interested performance aspects compression running times queries results performance experiments 
experimental studies hand investigated disk savings achieved database compression 
disk savings important advantage compression believe importance factor decrease continuing trend dropping disk prices 
note couple papers address performance issues database compression gs sng rhs grs took observations papers account designed implemented system see section 
papers results comprehensive performance experiments 
areas compression studied context database systems 
design special implementation techniques say joins compression go 
second significant body compressed indexes vsam wag prefix compression trees com compression rectangle descriptions trees grs compression bit mapped indexes mz :10.1.1.44.4359
areas orthogonal concentrated studying performance compression perceived query techniques hash joins techniques propose just specialized query evaluation algorithms concentrated compression base data relations sure kind index compressed remains applicable environment 
light weight database compression section describe compression techniques considered 
describe characteristics compression technique suited general purpose database systems list concrete techniques chosen implement experimental system 
inventing new compression techniques main contribution show explicitly compression techniques integrated storage manager database system address subject third part section 
stated related section cover compression techniques base data relations special purpose compression techniques indexes understood independently techniques propose 
premises fundamental premises compression fast compression finegrained 
importance premises discovered discussed previous database compression gs sng rhs grs briefly summarize arguments 
compression technique fast low cpu overhead benefits compression terms disk io savings eaten additional cpu cost 
saw example phenomenon grs show gzip appropriate database compression takes longer gunzip page read page disk :10.1.1.44.4359
pick compression technique willing sacrifice couple percent disk savings order achieve fast possible decompression performance 
database compression theoretically carried different granularities file level block level tuple level field level 
propose compression means compress decompress field tuple individually reading updating fields tuples 
strong arguments favor compression see gs sng rhs grs 
important field level compression techniques fast coarser grained compression techniques gzip techniques slow stated 
furthermore fine grained compression possible lazily decompress fields executing query save fair amount costs decompression way gs sng query example asks name older need decompress age fields need decompress name fields age need decompress say address fields 
arguments demonstrate difficulties implement integrate block level compression techniques database system described grs :10.1.1.44.4359
propagate fine grained field level compression require compression technique applied column table 
example require age field tuples compressed way cumbersome user specify compression technique field tuple individually costly system determine compression mode field accessing field 
different columns table compressed different compression techniques possible compress certain columns table columns compressed 
concrete techniques discuss number compression techniques useful order improve performance database systems 
specifically describe compression techniques numeric compression string compression dictionary compression 
furthermore describe compression works presence values 
compression techniques applicable variety cases combined compress different columns table differently general different options compress table choosing wrong technique impact performance database 
think adding heavy burden job database system administrator usually obvious right compression techniques application 
example hesitate dictionary compression flag fields numeric compression fields type decimal implementation tpc benchmark 
dictionary numeric compression described 
numeric compression technique compress integers null suppression encoding resulting length compressed integer rh 
technique built commercial relational database system software ag ag 
idea cross leading representation integer 
systems integers represented bytes integer represented bits set bits set 
kind compression integer represented bits 
course crux numeric compression keep information bits represent specific integer information needed decompress integer 
discuss technique encode decode information section having compression techniques encoding decoding techniques specific particular compression technique 
moment keep mind coding scheme works compressed fields aligned bytes 
integer represented byte bits 
alignment bytes example trade disk savings high speed decompression 
compression technique integers applied dates 
date represented number days date certain base date 
base date november date november represented integer date october represented integer dates compressed just integer 
apply special compression technique floating point numbers represented bytes uncompressed state doubles 
cases byte floating point number represented bytes loosing information 
take advantage fact represent floating point numbers bytes possible 
forms numeric compression consider helpful situations nr grs 
string compression sql allows define strings different ways char 
database systems char fields represented allocating fixed chunk bytes length varchar fields typically implemented recording length string storing string variable chunk shrink grow depending current state string 
simple way compress varchar fields simply compress part records length string numeric compression technique integers defined 
char fields compressed converting step achieving compression compressing length resulting variable string second step 
strings long beneficial compress string fields 
order preservation important additional compression done classic compression techniques huffman coding arithmetic coding lzw algorithm wel 
order preserving technique needed additional compression done techniques proposed bce alm 
compression techniques cases need encode sign integer order achieve effective compression integer 
carried independently addition compression part records length compressed string 
dictionary compression dictionary compression popular compression technique data type 
dictionary compression particularly effective field take small number different values storing different values field take separate data structure dictionary 
instance field take values mannheim passau value field represented single bit bit look decompressed value field dictionary 
different variants dictionary compression conceivable 
chosen implement simple somewhat limited variant maximum size dictionary known advance number bits required represent field known advance 
interesting general variant dictionary compression alm 
dealing values sql values data type 
realistic applications integrity constraints disallow null values fields absence constraints system take account fields may null values compression technique uniquely represent values 
dictionary compression null values easily represented possible values recording dictionary 
numeric compression field represented field length 
distinguish null integer double represent integer byte bits turned double bytes 
string compression represent empty string string length null string string 
encoding decoding compression information turn question compression techniques integrated storage manager database system 
seen previous subsection effectiveness variablelength compression techniques depend efficiently encoding decoding length information compressed data items 
issue finding right offset field tuple contains variable length compressed fields 
example time needed access field increases position field tuple length preceding field determined order calculate offset 
approach take encodes length information field fixed number bits packs length codes compressed fields special part tuple 
describe resulting layout compressed tuples encoding decoding algorithms 
layout compressed tuples shows layout compressed tuple 
shows tuple composed parts part tuple keeps compressed values fields compressed dictionary compression compression technique 
second part keeps encoded length information fields compressed variable length compression technique numerical compression techniques described 
third part contains values uncompressed fields fixed length integers doubles chars chars turned result compression 
fourth part contains compressed values fields compressed variable length compression technique example compressed integers doubles dates 
fourth part contain compressed value size varchar field value chosen compressed 
size information field compressed stored third part tuple fixed length uncompressed integer value 
fifth part tuple contains string values compressed compressed var char fields 
sounds quite complicated separation different parts natural 
sense separate fixed sized variable sized parts tuples separation standard database systems today gr 
parts tuple fixed sized means size tuple table 
result compression information value field directly retrieved parts address calculations 
particular uncompressed integer double date 
fields directly accessed regardless fields compressed 
furthermore sense pack length codes compressed fields exploit bundling fast decoding algorithm see soon 
codes data length offset encoding encoding dictionary compression length null null allowed table length encoding integers fixed length variable length separate small variable length compressed fields potentially large variable length string fields length information small fields encoded byte length information large fields encoded step process described section 
obviously tuple database consists parts 
example tuples compressed fields consist third fifth part 
furthermore keep mind tuples table layout consist number parts tuples table compressed techniques 
length encoding discussion layout compressed tuples fairly obvious uncompressed fields compressed fields accessed 
open question variable length compressed fields accessed 
describe length fields encoded packed second part tuple subsection describe information decoded 
recall interested encoding length compressed integer double values 
dates compressed represented integers strings keep length information separately compress just integer 
recall due byte alignment compressed integer bytes long 
consequence encode length compressed integer bits shown null column table 
integer take null values need bits encode length compressed integer compressed integer bytes long case allowed column table 
layout compressed tuple strings length null null allowed table length encoding doubles analogously table shows codes lengths compressed double 
recall compressed double bytes long ifnull values allowed bytes long ifnull values allowed length coded bit case bits second case 
tuple variable length compressed fields try pack length codes fields possible single byte sure time code single field retrieved probing single byte 
illustrate example 
example compresses tuples consist integer fields null allowed integer field null constraint double field null constraint int int double null int int int null fields compressed described section length codes fields packed bytes way byte bit bit bit bit bit bit bit byte bit bit bit bit bit bit bit bit refers ith bit length encoding attribute bit byte 
length decoding encoding scheme previous section easy determine length compressed field specific tuple simply need access right bits field length encoding part tuple look length encoding table table 
access field attr 
attr 
attr 
total length attr 
attr 
attr 
decoding byte need solve problem determine offset field depends length compressed fields stored tuple field 
naive algorithm determine offset say ith compressed field loop decode length jth field compute offset sum lengths 
algorithm high cpu overhead involve decoding length information fields 
fortunately better materializing possible offsets field called decoding tables 
see works continue example look concrete tuple relation compressed value tuple bytes value bytes value bytes value bytes value bytes value bytes bytes encode length tuple look follows codes tables setting unused bit byte byte byte determine offset attribute tuple 
probe decoding table byte find length encoding attributes combined consume bytes 
probe decoding table byte attr 
attr 
attr 
attr 
attr 
attr 
offset length encoding decoding byte find need add bytes determine full offset attribute tuple get length attribute general maintain decoding tables relation tuples bytes length encoding part 
decoding table entries number bits corresponding length encoding byte byte byte example 
entry decoding table total length field bytes offset bytes length bytes field attribute encoded corresponding byte see figures 
design offset length compressed field tuple determined algorithm shown 
go back example note decoding tables really small 
relation example require decoding table size kb entries bytes decoding table size kb entries bytes 
expect decoding tables kept main memory time just meta data 
willing invest memory materialize possible offsets single table table byte achieve decoding constant time 
relation universal decoding table require mb main memory entries bytes 
course ways compromise conceivable 
input attribute identifier attr encoding information tuple array decoding tables table number byte records attr length code output offset attr tuple length value attr tuple offset offset offset table total return offset table offset attr table length attr executing queries compressed data previous section showed compression techniques integrated implemented efficiently storage manager database system 
section describe necessary adjustments carry queries efficiently presence compression 
obviously compression integrated database system adjustments query execution engine query optimizer database system simply encapsulating compression storage manager 
recall compression easily turn io bound query cpu bound query textbook query execution engines designed minimize io costs need extended minimize cpu costs order take full advantage database compression 
furthermore compression impact choices optimizer example best join orders compressed uncompressed database may differ 
design query execution engine discuss query optimization issues 
section give brief report status system experiences building system 
section presents results experiments evaluate performance engine 
query execution engine achieve lowest possible cpu overhead query execution propose techniques extended query iterator model evaluation expressions virtual machine interprets assembler programs 
extension necessary order avoid unnecessary copying tuples query execution avoid decompressing fields twice query 
second extension necessary order minimize cost evaluate expressions predicates aggregate functions 
extended iterator model classic iterator model query operator table scan index scan sort 
called iterator pro algorithm decode compression information vides methods gra open close 
open allocates resources main memory disk temporary results computations need carried iterator produce results 
delivers result tuples iterator time 
close releases allocated resources cleaning 
concerned interface method iterator 
classic iterator model delivers result tuple returning main memory pointer tuple 
generalize interface allow method return array pointers just single pointer 
extension necessary implement technique called implicit joins known seventies avoids copying tuples pipelined join methods pal 
see implicit joins save cpu costs copy tuples consider index nested loop join relations classic iterator model iterator copy matching tuples result tuple order return pointer result tuple 
implicit joins iterator simply returns pointers pair matching tuples copying tuples relation 
second step take generalize interface method iterator model allow iterators return values fields tuples addition just returning pointers tuples 
extension necessary avoid decompressing field twice course evaluating query 
consider example employee database table scan iterator emp evaluates salary pipes result iterator evaluates predicate emp salary dept budget 
assume emp salary field compressed consider method iterator return pointers tuples 
case table scan iterator decompress emp salary fields emp tuples time evaluate emp salary predicate 
table scan iterator pass pointers resulting compressed emp tuples iterator iterator decompress emp salary field resulting tuples second time order evaluate join predicate 
generalize interface leq dat zc avm avm prg shipdate method table scan iterator return decompressed values emp salary fields addition pointers tuple iterator uncompressed values generated table scan iterator 
conclude interface method extended iterator model bool method iterator iterator done find new result tuples returns true 
results pointers tuples values fields passed array 
union type take uncompressed value pendant common sql data type integer double date internal types query engine rid void 
reasons clear subsection call entry array register 
virtual machine date little published efficient evaluation expressions database systems 
intuitive approach generate operator tree expression compile time query interpret operator tree query execution far know approach oracle 
operator tree approach approach initially implemented system 
going operator tree involves high cpu costs experiments carried version cpu costs high ate benefits achieved saving io costs compression 
developed efficient method generating assembler statements compile time interpreting statements special virtual machine call avm similar idea literature old ibm technical report lw describes rule system generate statements query fg 
told ibm db uses assembler statements evaluate expressions details db published 
example figures show avm programs implement query tpc benchmark tpc 
program implements shipdate predicate query second avm program implements sum extended price avm stands virtual machine 
sub sf cz add sf cz mul sf zz mul sf zz avm avm prg aggregate function discount tax aggregate function query 
instructions avm programs operate registers passed iterators instructions take parameters registers write results registers 
example leq statement compares th attribute tuple pointed register constant writes result register 
going details instruction set supported avm scope 
clear avm allows efficient expression evaluation operator trees just register programming languages efficient stack programming languages java 
note statements avm machine independent avm statements compression specific 
iterator side iterators get avm programs operator trees iterators call avm execute programs evaluate expressions load registers side effect scan iterators get avm program predicates apply join iterators get separate avm programs primary secondary join predicates group iterators get avm programs order compute aggregate values separate programs initialize compute aggregate store aggregate values 
iterators pipeline temp get avm program applied result tuples iterators usually avm programs involve copying pointer result tuple register consumed iterator parameter avm program iterator 
note implementation iterators compression specific just avm set query iterators applied compressed uncompressed databases 
query optimization get best possible query plans presence compression small adjustments physical query optimizer required 
adjustments necessary best query plan uncompressed database best query plan compressed database 
compression impacts size base relations intermediate results compression ideally impacts join ordering choice join methods 
index nested loop join example favorable query compressed database inner relation fits memory due com pression merge join favorable query uncompressed database relation fits memory due absence compression 
important point notice query plan shows performance uncompressed database show performance compressed database optimizer lacks adjustments produce acceptable plans compressed databases 
purpose adjustments list find query plans compressed databases 
important adjustment cost model optimizer compression aware 
optimizer cost model compression aware optimizer automatically choose index nested loop join plan example paragraph plan lower cost merge join plan optimizer automatically generate plan right join order presence compression 
optimizer cost model compression aware need carry steps 
cost model ought account cpu costs decompress fields tuples 
techniques section optimizer estimates cardinality base relations temporary results cpu costs easy predict easily considered optimizer cost model 

memory requirements disk io estimates iterator need adjusted significantly smaller presence compression 
exact savings due compression difficult predict depend characteristics data set light weight compression techniques savings compressed attribute rule thumb 
second adjustment optimizer decide temporary results compressed 
large temporary results written disk sorting compress fields compressed results aggregate functions order save disk io 
sort carried memory completely temporary results small cpu cycles left spent sense compress fields advantage expected compression 
implementation status implemented extensions storage manager described section extensions query engine described section part project programming language 
point component working query optimizer 
deficiency due compression 
due fact system growing dramatically couple months able keep optimizer date order consider different join group methods implemented 
important observation changes query execution engine extended iterator model avm helped improve performance queries compressed uncompressed databases cases observed savings cpu costs factor due changes 
integrating compression storage manager affect performance queries uncompressed data see section 
affecting performance queries uncompressed data important allowed explicitly study performance tradeoffs database compression subject section 
tpc benchmark results section results running tpc benchmark tpc compressed database techniques described previous sections 
study performance tradeoffs database compression compare results results tpc benchmark uncompressed database 
describe details implementation tpc benchmark 
address benchmark results including database sizes bulk loading times running times seventeen queries update functions 
implementation tpc queries update functions mentioned database system experimental platform 
pretty textbook relational database system special features described sections extended iterator model avm 
optimizer currently craft query plans tpc queries update functions manually 
doing guided query plans produced commercial database systems tpc queries 
plans left deep group operators sitting top plans consider early aggregation yl cs 
grace hash blockwise hashed nested loop preferred join methods hr hashing group operations 
secondary tree indexes date fields clustered indexes keys tables 
turned trees useful improve performance tree implementation berkeley database toolkit athttp www com 
heavy weight tpc queries trees regular implementation tpc benchmark 
show impact indexes compression tpc style queries show running time tpc query index plan 
memory allocated way operators read wrote large blocks data usually pages disk order avoid disk seeks 
plans memory allocation compressed uncompressed databases identical plan memory allocation query uncompressed database ran plan compressed uncompressed databases 
described section approach conservative possible achieve better response times compressed database compression specific query plans results sense seen lower bound performance improvements achieved compression tpc benchmark 
compress tpc database compression techniques numeric compression described section integers dictionary compression flag fields described section 
turned char strings compressed length information described section 
huffman coding compress strings 
felt sophisticated compression techniques long string fields comments tpc tables unfair favor compression compression techniques resulted high compression rates high io savings paying price compression fields rarely tpc queries 
compress date fields compress tables fit single page disk 
ran tpc queries update functions compressed uncompressed databases scaling factor sf 
machine sun ultra ii workstation mhz processor mb main memory 
execute queries limited size database buffer pool mb 
databases stored gb seagate disk drive gb seagate disk drive store temporary results queries 
operating system sun solaris version 
configured kb page size 
size compressed uncompressed databases table shows size compressed uncompressed databases 
depending tpc table achieved compression rates 
highest compression rate achieved lineitem table lineitem table table compressed uncompressed lineitem order partsupp part customer supplier nation region total table size kb compressed uncompressed tables sf table compressed uncompressed lineitem order partsupp part customer supplier total table time min secs tpc database sf numerical values integers compress 
hand fraction long string values compressed length information quite high tables achieve high compression rates tables 
rule thumb light weight compression techniques achieved compression rate fields compress 
stated compress region nation tables fit single kb page 
loading compressed uncompressed databases table shows times compressed uncompressed databases 
observe times tend higher compression 
compression reduce cost write new pages disk cpu bound operation involves parsing input file character time 
typically cpu utilization compressed uncompressed database compressing tuples part high cpu overhead higher fact decompressing tuples 
show bulk loading times nation tables table small measured 
running times tpc queries update functions regular tpc results table lists running times cpu costs cpu utilization seventeen queries update functions tpc benchmark 
described section results obtained best possible plans uncompressed database plans exploit indexes 
just looking results seventeen queries observe compression looses queries benefits due reduced io costs outweigh cpu overhead compression 
performance improvements due compression course depend kind query selectivity predicates number joins tables involved joins presence clauses columns expressions result query 
cases compression improve running time case savings running time 
looking closer cpu costs cpu utilizations queries see important implement compression way cpu overhead compression small possible 
queries cpu utilization cpu utilizations pretty common compression 
naive decoding algorithm take advantage decoding tables see section triple cpu costs decompression queries 
increasing cpu costs factor eat benefits reduced disk io result higher running times compressed database uncompressed database 
turning results update functions observe compression increase running time update function uf factor 
uf inserts tuples specified text file database see basically performance degradation due compression experiments see table 
tuples appended tables fairly little disk io cost cpu costs parsing text file dominate running time uf compression looses due high cost compress tuples 
update function uf hand compression wins significant margin 
update function uf deletes order tuples involves fair amount disk io order find right tuples delete 
compression saves costs carry disk ios additional advantage particular case compression additional cpu overhead case tuples deleted need decompressed 
primary keys need decompressed order find right tuples delete 
compressed uncompressed table running time secs query index plan impact indexes table shows running time plan query uses orderdate index evaluate range predicate query 
queries showed deterioration performance compressed uncompressed databases indexes 
see running time plan significantly better compression compression reasons experiments reduced disk io due compression 
fact index slightly improved running time query compressed database running time query worse uncompressed database 
general indexes significantly affect performance tradeoffs database compression 
cases significant amounts base data read index tpc style queries compression reduces amount disk io cause higher buffer hit rates normal index scans simply data scanned index scans rid sorts ck 
cases small amounts data read index compressed databases show performance uncompressed database cases compression result significant disk io benefits compression result significant cpu overheads 
showed compression integrated database system 
large body related describing specific database compression algorithms really describes full detail low level algorithms built database system 
experience shows low level considerations important compression perform execution queries involves decompression millions tuples 
defined layout compressed tuples variable length fields separated fixed length fields compressed fields separated uncompressed fields 
layout allows direct access fixed length fields allows compress individual fields affecting uncompressed fields 
furthermore developed fast encoding decoding algorithms compressed fields accessed fast uncompressed fields 
addition low level storage manager issues integration compression described novel design query execution engine extended iterator model avm fast expression evaluation query execution 
development query compressed uncompressed update time cpu cpu time cpu cpu uf uf total geometric mean table tpc power test running time secs cpu cost secs cpu utilization highly tuned query engine triggered high performance compression easy integrate compression specific adjustments avoiding repeated decompression fields extended iterator model 
really compression specific query engine enhancements kind database system including systems provide support compression 
result efforts able show compression significantly improve performance database systems addition providing disk space savings 
implemented tpc benchmark compressed uncompressed database saw compression improves running times queries factor slightly cases 
read queries find single case compression result worse performance 
observations indicate compression definitely integrated decision support systems data warehouses process great deal tpc style queries 
experiments showed cpu costs continue important factor query performance considering today hardware trends 
important implement techniques proposed order achieve performance compression 
compression read queries see significant performance penalties insert modify operations 
particular insert operations tend cpu bound techniques compressing tuple significantly higher cpu cost decompressing tuple foresee compression going improve performance oltp style applications time soon 
ag software ag 
im 
technical report ada ib software ag munich germany january 
alm lomet murray 
order preserving compression 
proc 
ieee conf 
data engineering pages new orleans la usa 
bce casey eswaran 
encoding method sorting indexing 
technical report rj ibm research san jose ca 
ck carey kossmann 
reducing braking distance sql query engine 
proc 
conf 
large data bases vldb pages new york city ny usa august 
com comer 
ubiquitous tree 
acm computing surveys 
cor cormack 
data compression database system 
communications acm december 
cs chaudhuri shim 
including group query optimization 
vldb pages 
fg freytag goodman 
translation relational queries iterative programs 
acm trans 
database systems march 
go graefe neil 
multi table joins bitmapped join indices 
acm sigmod record october 
gr gray reuter 
transaction processing concepts techniques 
morgan kaufmann publishers san mateo ca usa 
gra graefe 
query evaluation techniques large databases 
acm computing surveys june 
grs goldstein ramakrishnan shaft :10.1.1.44.4359
compressing relations indexes 
proc 
ieee conf 
data engineering orlando fl usa 
gs graefe shapiro 
data compression database performance 
proc 
acm ieee cs symp 
applied computing kansas city mo april 
haas carey livny 
seeking truth ad hoc join costs 
vldb journal july 
hr harris ramamohanarao 
join algorithm costs revisited 
vldb journal january 
huffman 
method construction minimum redundancy codes 
proc 
ire september 
iw iyer 
data compression support databases 
vldb pages 
lw lorie wade 
compilation high level data language 
technical report rj ibm research san jose ca 
mz moffat zobel 
parameterised compression sparse bitmaps 
sigir pages 
nr ng ravishankar 
relational database compression augmented vector quantization 
proc 
ieee conf 
data engineering pages taiwan 
pal palermo 
database search problem 
information systems pages 
plenum publ new york ny 
rh roth van horn 
database compression 
acm sigmod record september 
rhs ray seshadri 
database compression performance enhancement tool 
proc 
india december 
sev 
practitioner guide data base compression 
information systems 
sng shapiro ni graefe 
full time data compression adt database performance 
portland state university usa 
tpc transaction processing performance council tpc 
tpc benchmark decision support 
standard specification transaction processing performance council tpc may 
www tpc org 
proc 
conf 
large data bases vldb santiago chile september 
wag wagner 
indexing design considerations 
ibm systems journal 
wel welch 
technique high performance data compression 
ieee computer june 
witten neal cleary 
arithmetic coding data compression 
communications acm june 
yl yan larson 
performing group join 
proc 
ieee conf 
data engineering pages houston tx 
