functional bulk synchronous parallel programming fr ric fr ric laboratory algorithms complexity logic university paris xii val de avenue du ral de cr teil cedex france tel fax univ paris fr research report tr presents library functional bulk synchronous parallel programming 
extension calculus parallel operations parallel data structure named parallel vector intention 
guarantees determinism absence deadlock 
broadcast algorithms implemented core library 
keywords parallel programming functional programming algorithmic skeletons declarative parallel languages needed ease programming massively parallel architectures 
languages enforce syntax order evaluation appear suitable automatic parallelization 
logic programming languages backtracking difficult parallelize 
functional languages considered 
problems encountered parallelization sequential imperative languages avoided remains example different denotationally equivalent programs may lead different parallel programs added example fact languages data structures dynamic ones 
amount grain parallelism low 
opposite direction research give programmer entire control parallelism 
message passing facilities added functional languages 
case obtained parallel languages non deterministic non functional referential transparency lost 
intermediate approach offer set algorithmic skeletons case functional languages set higher order functions implemented parallel 
algorithmic skeletons sequential counterparts 
example map function takes function list xn returns list fx fxn classical algorithmic skeleton 
usual parallel implementation scatters list different processors evaluates fxi parallel gathers results processor 
denotational semantics map skeletons function 
parallel semantics remains implicit algorithmic skeletons approaches 
parallel programming easier algorithmic skeletons drawbacks 
firstly set algorithmic skeletons finite depends domain application 
parallel languages algorithmic skeletons rely specific compiler 
impossible programmer extend set algorithmic skeletons 
approaches set algorithmic skeletons library 
libraries implemented mpi 
program new skeletons programmer may deal deadlocks 
secondly portable performance prediction considered cost models complex useful programmer compilers 
bulk synchronous parallel bsp computing parallel programming model introduced valiant offer high degree abstraction pram models allow portable predictable performance wide variety architectures 
works studied bsp implementation algorithmic skeletons 
cases model extended bsp model adding network subset synchronization desirable 
seen algorithmic skeletons language finite set operations parallel different main points operations universal bsp programming allow implementation classical algorithmic skeletons 
possible programmer implement additional skeletons 
performance prediction possible associated cost model bsp cost model 
operations implemented library functional programming language objective caml 
parallel semantics formal ones 
confluent calculus distributed semantics parallel machine semantics proved correct respect previous 
project standardization algorithmic skeletons library began 
library library widely programming language implemented widely low level parallel programming library mpi performance prediction possible portable 
libraries proposed library mpi prototypes algorithmic skeletons written style prototypes mpi collective functions higher level library mpi fact 
library functional programming 
contribution aims design standard algorithmic skeletons library bsp model 
step design implementation bs calculus primitives library mpi 
library called fc library functional programming 
presents bsp model section gives overview fc library section 
describe library section 
section examples library 
section 
bulk synchronous parallel model bulk synchronous parallel bsp computing parallel programming model introduced valiant offer high degree abstraction pram models allow portable predictable performance wide variety architectures 
bsp computer contains set pairs communication network allowing inter processor delivery messages global synchronization unit executes collective requests synchronization barrier 
performance characterized parameters expressed multiples local processing speed number processor memory pairs time required global synchronization time collectively delivering relation communication phase processor receives sends word 
network deliver relation time gh arity 
synchronization barrier synchronization barrier 
bsp superstep bsp program executed sequence super steps divided successive logically disjoint phases fig 

phase processor uses local data perform sequential computations request data transfers nodes 
second phase network delivers requested data transfers third phase global synchronization barrier occurs making transferred data available super step 
execution time super step sum maximal local processing time data delivery time global synchronization time time max processor max processor time local processing time processor super step max hi resp 
number words transmitted resp 
received processor super step execution time time bsp program composed super steps sum terms time hg sl maxi maxi general functions size data application complex parameters data skew histogram sizes 
minimize execution time bsp algorithm design jointly minimize number super steps total volume resp 
imbalance resp 
communication resp 
local computation 
functional programming int square int return direct polymorphic struct square template class struct sig public template class operator return int main conversion usual function direct monomorphic indirect fun int int ptr fun sqrt implicit conversion direct indirect fun int int ptr fun sqrt operations introduce fc programming 
allows polymorphism template mechanism polymorphic function passed argument 
fc problem means new function type called 
instance structure defined function 
member sig gives real signature function 
type structure reflect function type 
example type function square doesn match functional signature int int struct square int operator int return second example member class represents real functional type function struct square public cfun type int int int operator int return twice fc introduces kinds 
direct monomorphic 
indirect dynamically bound value changed 
indirect permit define variables range functions type signature 
monomorphic 

direct polymorphic templates mechanism allow polymorphism 
usual functions converted direct monomorphic fun 
direct converted indirect polymorphic done implicitly 
notations 
signature function noted type th argument result type 

fc get result type function type applied argument type 
functional bulk synchronous parallel programming access architecture bsp parameters gives access underlying bsp architecture parameters 
bsp function returns static number processes 
bsp gives respectively parameter parameter bsp machine 
bsp int direct broadcast struct bcast direct template class par operator int par value const return get value template class struct sig public int par par bcast direct total exchange broadcast struct bcast template class par list operator int par list value const return concat scatter value template class struct sig public int bcast broadcast algorithms creation parallel vectors programs uses type represents parallel vector 
parallel vector contains values process 
class contains member functions know type elements 
nesting allowed responsibility programmer 
creates parallel vector function template class fun int par process hold value point point parallel application parallel vector functions applied parallel vector values template class class par par par rt operation executed asynchronous computations phase bsp super step 
cost maxi process wi wi sequential time required execute called operation process communications messages exchanged put template class par fun int option par fun int option argument parallel functions process indexes values sent 
type encapsulates values exchanged 
type constructors 
parameter specify value send 
second takes parameter value sent 
function held parallel process 
option send process value process 
option send value process process returned value function put parallel vector functions process indexes received values 
function gi held process parallel vector gi value received process process put function called process function held vf applied process indexes determine values sent processes 
values copied buffer array integers containing sizes values sent exchanged processes mpi function 
phase global synchronization barrier total exchange process knows sizes supposed receive values effectively sent call values exchanged new functions processes indexes values created process 
process function returns values received process 
call put function full super step 
asynchronous computation phase synchronization barrier phase said section phases superstep logically distinct successive communication phase asynchronous computations phase second super step 
cost general formula section 
points may need serialization mechanism 
reason comes standard library proposes rudimentary mechanism serialization order permit communications complex data types classes functions 
class serialized inherits class 
member special constructor char buffer implemented 
method serialize permits put function take back value object 
called serialize function members class serialized 
constructor permits build new object buffer passed argument call unpack serialized value put matching variables 
global conditional global parallel conditional par bool int bool structure vb evaluates process toe process process executes matching code 
function realize simple bsp broadcast value corresponding process index passed argument 
cost examples library comes standard library implemented core library previous section 
broadcast algorithms functions standard library transforms sequential function parameter parallel function process 
parameters 
transforms sequential value parallel vector value process get values pids take parallel vector values vp parallel vector process identifiers np returns parallel vector values xn xn 
implemented operations 
concat transforms list lists list 
concat function fc library 
struct scatter template class par list operator int par list const scatters list held process processes template class struct sig public int scatter struct template class struct sig public par list typename struct template class class option operator val pid const return option val template class class struct sig public option template class par list operator par const return map map put take bsp bsp scatter total exchange line expression take bsp bsp creates list 
take functions fc library 
programs versions broadcast 
direct 
value process broadcast directly processes get 
implemented super steps put 
super step process requests value process 
second super step requested values sent 
cost program size value held process parallel 
second specialized large values algorithm data structure list 
proceeds super steps 
value held process scattered cut pieces size piece sent process 
second pieces totally exchanged process pieces recombined 
cost size element list 
gives access bsp parameters machine 
possible write broadcast program chooses calculating costs efficient broadcast direct broadcast total exchange broadcast 
library allows declarative parallel programming 
implemented mpi portable wide range architectures 
basic parallel operations bulk synchronous parallel operations allow accurate portable performance prediction 
library easily programmers requires mpi library standard compiler 
algorithmic skeletons languages offer higher level skeletons require dedicated compilers case set skeletons may extend price update compiler offer associated cost model extended programmer price mpi risk non determinism deadlocks 
main goal provide new library called library french acronym parallel skeleton library offer classical set skeletons 
library development implemented library 
advocated subset synchronization usual bsp global synchronization 
design skeletons harder simpler cost model allow design skeletons able dynamic load balancing complex situations 
acknowledgments supported aci grid program french ministry research project 
parallel skeleton component standardisation project 
web pages ww dcs ed ac uk home mic html 
arvind nikhil 
structures data structures parallel computing 
acm transactions programming languages systems 

high level bsp programming bs 
michaelson ph 
trinder editors trends functional programming pages 
intellect books 

self balancing join algorithm sn machines 
pan akl li editors proceedings international conference parallel distributed computing systems pages las vegas usa 
iasted acta press 


efficient high level parallel programming 
theoretical computer science 
cole 
algorithmic skeletons structured management parallel computation 
mit press 
cole 
bringing skeletons closet 
submitted parallel computing 
di cosmo leroy 
functional parallel programming system 
liens ens 
darlington field harrison kelly sharp wu 
parallel programming skeleton functions 
bode reeve wolf editors parle parallel architectures languages europe number lecture notes computer science munich june 
springer 

caml flight portable spmd extension ml distributed memory multiprocessors 
hm feo editors workshop high performance computing denver colorado april 
lawrence livermore national laboratory usa 

subset synchronization bsp computing 
editor pdpta international conference parallel distributed processing techniques applications volume pages las vegas july 
csrea press 
hayashi 
shaped cost analysis skeletal parallel programs 
phd thesis university edinburgh 

skeleton library 
europar lncs 
springer verlag 

bs functional bsp programs enumerated vectors 
editor international symposium high performance computing number lecture notes computer science pages 
springer october 

distributed evaluation functional bsp programs 
parallel processing letters 

implementation functional bulk synchronous parallel programming library 
th iasted international conference parallel distributed computing systems pages 
acta press 

calculus functional bsp programs 
science computer programming 
smaragdakis 
programming 
icfp montreal canada 
acm press 
brian yannis smaragdakis 
fc library 
web pages www cc gatech edu yannis fc 
mallet 
symbolic cost analysis automatic data distribution skeleton language 
springer editor europar number lncs pages 
mccoll 
scalability portability predictability bsp approach parallel programming 
generation computer systems 
merlin 
spmd environment machine functional bsp programs 
proceedings third scottish functional programming workshop august 
panangaden reppy 
essence concurrent ml 
nielson editor ml concurrency monographs computer science 
springer 

structured development parallel programs 
taylor francis 
schwarz 
skeleton implementation iterative transformation algorithms functional languages 
kara editor machine models parallel distributed computing pages 
ios press april 

embodying parallel functional skeletons experimental implementation top mpi 
lengauer editors euro par parallel processing number lecture notes computer science pages passau germany august 
springer 
skillicorn 
optimising data parallel programs bsp cost model 
europar volume lncs pages 
springer verlag 
snir gropp 
mpi complete 
mit press 

fact 
functional side 
www fz de zam fact 
leslie valiant 
bridging model parallel computation 
communications acm august 

skeletons bsp performance portability parallel programming 
phd thesis universita degli studi di pisa 

