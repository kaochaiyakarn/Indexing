presheaf models process calculi lecture notes draft june nygaard disi may june process calculi ccs motivated studied operationally outset lacking mathematical treatment provided domain theory 
consequently concurrency separate study particular higher order functional features known sequential programming treated ad hoc fashion 
study presheaf models processes seen attempt bring concurrency back realm traditional denotational semantics providing domain theory concurrent computation :10.1.1.120.180
far concentrated developing domain theory showing handle existing models notions process calculi 
full operational understanding presheaf models obtained 
sensible way proceed exploit domain theory define mathematically natural process calculi approach operational understanding presheaf models investigating operational semantics calculi 
notes report joint glynn winskel lines 
section contains brief ccs intended readers unfamiliar milner 
give idea approach offer terms process calculi give section operational account higher order process language viewed extension lambda calculus ccs prefix operation 
hoped reader motivated presentation sections material concerning presheaves different categories organise 
ccs preface robin milner writes 
tried apply semantic ideas known sequential programming concurrent programming language insufficient 
particular milner viewing program function memory states identifying programs sense program full control memory 
interference program say change behavior program program behave nondeterministically changing 
led milner search fundamental new calculus interaction communication central idea 
tony hoare independently came primitive notion indivisible interaction 
milner calculus called calculus communicating systems ccs attempt providing paradigm concurrent computation sense lambda calculus paradigm sequential computation 
intuition terms ccs stand computing agents processes built small set operations 
processes may perform sequences atomic actions may actions communication 
start giving intuition series vending machine examples 
prefixing time vending machine may accept coin give coffee inactive process unable perform actions 
relabelling time tea vending machine description coffee version sum time vending machines selling coffee tea 



recursion vending machine may repeatedly accept coin give coffee rec communication suppose coffee vending machine consists subsystems accepting coins giving coffee 
may communicate notification action describe systems terms rec rec complement action processes may synchronise complementary actions producing anonymous internal communication action rec xj rec restriction clearly away internal workings machine 
obtained restriction rec xj rec fng theory formally define ccs assume set names write set fa ag set labels 
range extend complementation write act set actions ranged terms ccs grammar rec write empty sum 
restriction term subset relabelling function extend act defining operational semantics ccs system rules deriving transitions form closed ccs terms see 
example consider process 
clockwise order starting initial state states transition system written rec rec calculus operational semantics complemented notions process equivalence 
roughly processes considered equivalent indistinguishable point view sequential observer requesting sequences actions 
notice abstracts away syntactic representation agents transition system states 
depending observer ignores actions induced equivalence called weak strong 
ll concentrate actions treated actions 
milner adopted david park notion bisimulation rec rec ju ju ccs operational semantics definition relation closed ccs terms bisimulation implies 
ii write largest bisimulation called bisimilarity 
bisimilarity equivalence relation definition milner showed fact congruence preserved operators ccs 
example consider processes 
bisimilar bisimulation relation relates processes 

relate pair 


violates ii transition match 
example process bisimilar process rec 
notice example parallel composition reduced nondeterminism bisimilarity 
known result milner called expansion law shows happens general 
suppose ju ju returning semantics ccs classic theory inspired school researchers world milner received turing award partly recognition foundational concurrency theory 
side shift away traditional semantics led milner ccs concurrency separate study 
research indicates need remain 
handbook chapter glynn winskel mogens nielsen show categorical notions particular adjunctions relate models concurrency allow transfer definitions results 
example adjunction category tree trees category tran transition systems tree tran inclusion familiar operation unfolding transition system tree 
transition systems unfolds trees unfoldings andre joyal nielsen winskel extend defining categorical notion bisimulation open maps topos presheaves 
point presheaves may fruitful model concurrency generalising familiar models 
winskel phd student gian luca cattani go develop idea collaboration number researchers see cattani thesis 
new notes takes development full circle back considering process calculi denotational model presheaves 
offers universal constructions guide definition process operations away ad hoc higher order functional features type system 
particular section ll describe extension lambda calculus ccs prefix operation 
new language called hopla denotational semantics cartesian closed category cts presheaf categories 
hopla going categorical details straight away start giving operational account hopla 
language typed 
type process describes possible computation paths process perform 
computation paths may consist simply sequences atomic actions ccs may represent input output behaviour process 
typing judgement means process yields computation paths processes computation paths assigned variables respectively 
types built prefixed sum products function spaces recursive definition 
notable express kinds concurrent processes language language features typical process calculi built nondeterministic sum prefix operations 
operations associated prefix sum type constructor central expressiveness language 
prefix sum type form describes computation paths action performed resuming computation path prefix sum associated prefix operations process type type prefix match prefix sum type type generally involves variable term matches pattern passes results successful matches detail isomorphisms denotational semantics types language interpreted objects cts grammar drawn set type variables defining recursive types interpreted component solution defining equations expressions may contain 
shall write abbreviation tuple component raw syntax grammar rec fst snd variable match term binding occurrence binds occurrences variable body shall take granted understanding free bound variables substitution raw terms 
closed type expressions assume variables distinct 
syntactic judgement interpreted map 
cts 
range environment lists may treat finite maps variables closed type expressions 
term formation rules 
expected syntactic substitution lemma lemma suppose semantic counterpart essentially says denotation functorial composition denotations rec fst snd typing rules terms 
typing rules actions rec rec 

fst snd hopla operational semantics rec rec fst snd hopla evaluation operational semantics actions grammar 
operational rules define transition semantics language 
rule example suppose derivation 

shows rules abstraction application cooperate 
show rules type correct assign types actions judgement form intuitively performing action remains computation path computation path typing rules actions rule omitted 
notice judgement type unique proposition suppose rules sound complete respect denotational semantics derivations correspondence rooted components jak jtk jt corresponding rooted component 
means clear 
side operational rules incorporate evaluation sense values grammar define nondeterministic evaluation relation see proposition derivation value subderivation evaluation relation respects types beware rule sum preserves meaning bisimilarity 
rec rec ii iii iv vi vii viii ix fst xi snd xii fst snd xiii xiv fst fst xv snd snd bisimilar terms bisimulation extend definition operational semantics hopla demanding bisimulation respects types quantifying general actions theorem bisimilarity congruence 
proof howe method 
shows number closed formed terms shown bisimilar 
items ii vi xi rules vii xii rules 
case prove identity relation extended pair bisimulation correspondence tight expected denotational semantics jt jt results characterises bisimilarity arrow type proposition closed terms function type equivalent bisimilar ii bisimilar closed terms type iii bisimilar pairs bisimilar closed terms type encoding ccs specify type ccs computation paths terms ccs expressed hopla terms type jxk tk rec jtk tk jtk jt jtk jt sk rs jtk jt jtk rs abbreviations recursively defined processes rec rs rec rec proposition derivable ccs jtk jt hopla 
conversely jtk derivable hopla jt ccs 
follows translations ccs terms bisimilar hopla iff strongly bisimilar ccs 
recover expansion law general reasons 
write application terms type suppose item vi items ii iv get ju jy ju ju note hopla encode ccs simple way language distinguished invisible action issue support operational equivalences weak bisimulation starting 
processes presheaves mathematical study processes starting idea representing process kind collection possible computation paths 
path models processes consider processes ccs perform simple atomic actions time may actions synchronisation 
old idea represent nondeterministic behaviour process collection computation paths perform 
trace model tree model processes different ideas means 
trace set process simply expresses finite sequence actions trace possible process 
tree expresses paths paths subpaths restrictions keeping track nondeterministic branching 
example consider processes 
unfoldings trees see clearly different trace sets described ac atg result trace sets explain possible deadlock encountered coffee process 
interacting version left 
presheaves data tree representation paths restrict smaller paths precisely caught presheaf category objects path shapes maps express path shape extend 
category presheaves view tree colimit paths kind collection 
illustrate idea suppose actions drawn alphabet fa tg consider processes computation paths shape strings actions members substring ordering poset category arrow precisely see 
presheaf functor opposite category op arrows reversed category sets functions set 
thinking aaa aa aac ac aat ca cc ct ta tc tt part poset category presheaf representing process string set set computation paths shape process perform function tells paths shape restrict subpaths shape example tree branches consists strings easily viewed presheaf set consists branches shape function restricts branch shape shape example write empty set 
vending machines left represented presheaf ac atg ac maps ac maps 
morphisms action uniquely determined 
similarly presheaf ac atg represents vending machine right 
note presheaves suppose replace category sets definition presheaves subcategory inclusion 
non identity arrow 
functor op monotonic function reverse order op order 
thinking representing process means process perform path shape means 

words functor characteristic function trace set 
trees trace sets arise variants common idea representing process generalised characteristic function form functor path shapes measures extent path shapes realised process 
follows want broaden computation paths general shapes sequences atomic actions allow individual actions complicated structure hopla 
consider presheaves arbitrary small category functors op set 
category thought consisting computation path shapes map expresses path extended path ll investigate elementary category theory say data explaining variety process concepts terms nonsense 
category elements definition consider presheaf category elements written objects pairs morphisms form 
arrow xe example categories elements presheaves example look follows identity arrows omitted ac ac notice arrows categories may seen reflexive transitive closure transition relations trees 
category elements understood intuitively tree transition system process represented presheaf 
beware system may initial state example rooted definition presheaf rooted initial element 
singleton 
rooted presheaf corresponds directly tree branches general presheaf determines set trees set roots 
example may consider diagram presheaf disjoint union corresponding transition system starting states contrary standard definition transition systems may reasonable restrict attention rooted presheaves 
terms category theory mean working sheaves presheaves 
alternatively simply view presheaves presheaves easily seen bijective correspondence rooted presheaves natural transformations presheaves small category objects functor category op set arrows natural transformations 
spelled natural transformation presheaves family functions satisfying arrow naturality square commutes 
entirely obvious process concept amounts replay terms categories elements 
function induces map objects sending 
naturality simply functoriality sends morphisms 
morphisms 

natural transformation shows may simulate example define natural transformation presheaves example ac ac ac diagram means equivalently maps 
preserves transitions categories elements think simulation relation transition systems defined analogously item definition 
graph function relations called functional simulations 
obtain categorical definition bisimulation need way reflecting preserving behaviour 
open maps process viewpoint reasonable extra requirement natural transformation situation left may complete square right formulated requirement naturality square see opposite column exists xe case call open map presheaves joyal moerdijk 
notion open map topos defined axiomatically class morphisms satisfying things iso belongs closed composition stable pullbacks open maps rooted presheaves trees functional bisimulations 
bisimilarity equivalence relation trees bisimilar iff exists span open maps rooted presheaves generally axioms open maps sure related span open maps equivalence relation reflexivity obtained trivial span symmetry implicit notion span 
transitivity consider spans limits adjoin pullback open 
open related span open maps wanted 
cheating little bit general intuition open maps functional bisimulations incorrect 
trivial span relating pair presheaves initial object empty presheaf empty contribution 
take indication rooted presheaves look requirement spans 
demanding legs span epi reasonable open maps rooted presheaves automatically epi viewing trees presheaves extra requirement exactly needed show bisimilarity defined open maps coincide bisimilarity defined park milner 
avoid restricting class presheaves take definition presheaves open map bisimilar related span epi open maps 
yoneda presheaf category associated canonical functor saying view paths processes definition small category 
yoneda functor yp maps presheaf maps natural transformation obtained example presheaf single branch shape shows included longer branch shape intuitively yp maps computation path shape process may single computation shape path extension simulation computation longer 
intuition natural transformation yp shows process may simulate process capable performing just path set computation paths shape set natural transformations 
content lemma yoneda bijection yp 
example presheaf example natural transformations corresponding elements 
justified yoneda lemma write corresponding natural transformation yp gives alternative characterisation open maps proposition map open iff arrow commuting square left split commuting triangles right yp yp yp yp yp yp completeness presheaf category limits colimits pointwise limits colimits set 
particular presheaf category sums coproducts presheaves sum presheaves contribution disjoint union sets empty sum presheaves presheaf empty contribution process terms sum presheaves represents nondeterministic sum processes 
example consider processes 
view presheaves nondeterministic sum corresponds sum ccs terms 
hand form sum rooted presheaves get presheaf described section rooted expressed ccs 
similarly presheaf corresponds inactive ccs process written intuitively empty computation path 
promised section exhibit process colimit paths proposition density formula yp role colimit glue paths dictated category elements start section said yoneda functor canonical 
precise functor yp satisfies universal property functor category colimits colimit preserving functor determined isomorphism yp see page yp proof uses density formula 
take colimit fp presheaf category tells colimit preserving functors presheaf categories may useful 
ll consider candidates interpreting operations processes 
linearity distributed computation hard impossible process copy process generally easy process ignore process 
reason operation processes associated distributed computation property computation path process arising application operation input process resulted single possible empty computation path input process 
see property expresses operation kind linear map determined action single possibly empty computation paths 
example basic operations ccs linear sense 
example ccs process consider operations prefixing action composing process restricting label set non empty computation path process shape involving empty computation path shape shape single computation path likewise computation path parallel composition may obtained solely letting perform empty computation path non empty computation paths involve single non empty computation path consider diagram preceding section 
universal property colimit preserving functors determined isomorphism functors actions paths 
indicate colimit preserving functors fit intuition 
see precise 
model linear logic define category lin consist small categories maps colimit preserving functors universal property functors correspond isomorphism functors functors bijective correspondence profunctors 
recall category profunctors written prof functor category op set clearly equals category presheaves op isomorphic functor category 
chain equivalences lin prof op symmetric relational presentation profunctors exposes involution central understanding lin categorical model classical linear logic 
involution linear logic object op clearly presheaves op correspond presheaves op op op showing maps correspond maps op op lin 
model somewhat degenerate par tensor product product small categories function space op 
likewise objects products coproducts disjoint juxtaposition neutral elements terminal category object arrow initial category objects respectively 
exponential linear logic room choice 
linear process language 
consider interpreting process language category lin 
rich type discipline promising furthermore congruence result free proposition functor presheaf categories 
preserves open maps open map bisimulation 
process operation interpreted map lin automatically respect open map bisimulation 
unfortunately colimit empty diagram maps lin process operations send inactive process inactive process 
particular interpret prefixing parallel composition la ccs lin 
colimit preserving maps quite fit intuition ignore arguments 
extend maps objects lin properties exponential allow arbitrary copying argument process 
ccs need maps ignore arguments got cheaply moving model affine linear logic 
lifting obtain model affine linear logic ll consider operation lifting intuitively extends path categories empty path presheaves single computation shape 
rooted presheaves ll write 
new initial object freely adjoined 
spelled 
objects arrows unique arrow 
example easy see presheaf ll write bxc presheaf 
defined bxc copy bxc 

arrows bxc acts bxc 
forced constantly map terms categories elements objects addition unique transition object 
freely adjoined initial object 
example presheaf presheaf bxc tree obtained adding root fact lifting extends functor bc 
natural transformation sent obvious extension bxc 
component natural transformation lifted presheaves uniquely determined image lifting full subcategory 
rooted presheaves 
result important proposition presheaf 
decomposition sum rooted presheaves 
bx presheaf isomorphism fx ig example presheaf rooted component decomposition exhibits forest sum trees 
strict yoneda turns 
relates way relates definition strict yoneda functor 
sends acts yp formally maps 

inclusion 
intuitively maps possibly empty computation path shape process may single computation shape understood empty computation path gives rise inactive process 
example maps string 
presheaf represented ccs term 
natural transformations represent ways may simulate just way simulate inactive process expect lemma strict yoneda 
bijection bxc 
justified write corresponding natural transformation proposition map open epi iff arrow 
commuting square left split commuting triangles right may formulate result saying presheaves open map bisimilar iff related span open maps proposition shows open maps may seen open maps 
may notions paths inclusions paths give sensible definitions open map bisimulation 
example open maps exactly functional bisimulations sense park milner 
connected colimits density formula proposition shows yoneda presheaf regarded colimit nonempty paths 
strict yoneda may view connected colimit paths including empty 
connected colimit colimit nonempty connected diagram 
proposition strict density formula nonempty connected category initial element 
presheaf category free connected colimit completion 
satisfy universal property functor 
category connected colimits connected colimit preserving functor determined isomorphism 
ll write universal property suggests importance connected colimit preserving functors 
says functors match intuition section determined action single possibly empty computation paths 
model affine linear logic define category consisting small categories maps preserving functors lin maps preserve arbitrary colimits subcategory shares objects 
easily characterise maps lin proposition suppose preserves connected colimits 
properties equivalent preserves colimits ii preserves coproducts sums iii strict 
free connected colimit completion 
obtain equivalence consequently equivalence lin equivalence part adjunction inclusion lin 
defined left adjoint unit components bc lin regarded categories cells natural transformations 
easily extend lifting functor lin functor 

lin takes 
decomposition 
bx 

bg lifting restricts comonad lin category 
comonad turned model linear logic lin model affine linear logic model intuitionistic linear logic structural rule weakening satisfied unit tensor terminal object see 
affine linear process language constructions form basis denotational semantics affine linear process language 
types open terms language interpreted respectively objects arrows full subcategory path orders small partial order categories needed ll simplify discussion accordingly treating denotations types just partial orders 
preservation connected colimits functor presheaf categories sufficient ensure preserves open maps bisimulation 
proposition connected colimit preserving functor presheaf categories 
preserves open maps open map bisimulation 
open map bisimulation congruence language 
constructions prefixed sum category coproducts constant functors maps initial object empty coproduct 
build useful sum help coproduct lin lifting 
family path orders 
prefixed sum take disjoint union path orders underlying set path order forms coproduct lin obvious injections 
injections defined compositions bc 
finite prefixed sums written 
construction coproduct satisfy weaker property analogous universal property coproduct 
suppose maps mediating map lin determined isomorphism suppose family maps property constantly different write choice mediating map lin 
term type free variable type denotes type shall write 
hopla construction tests matches pattern passes results successful matches possibly multiple results successful matches summed cf 
lemma 
product product path orders disjoint union object identified pair provides projections general just binary products projections defined similarly 
universal property products collection maps tupled form unique map hf property hf empty product terminal object associated unique maps constantly path order rec variables recursion sum prefixing prefix match pairing product match tensor tensor match abstraction application raw syntax tensor tensor product path orders set 
ordered coordinatewise 
intuitively computation path pair computation paths respectively may empty 
define extension functor 
notice 

define 
bf bg jq 

unit tensor empty path order objects correspond maps sending define element pointed function space function space path orders product partial orders op chain isomorphisms 
op op op 
correspondence curry maps maps 
inverse called uncurry obtain linear application app uncurry 
shall write application type type ability curry justifies formation terms type lambda abstraction type term free variable type allan type system affine linear language called allan brevity extends hopla tensor constructor interpretation closed type expressions objects clear section operations form basis syntax terms see 
raw syntax subject typing linearity constraints 
closed expressions path orders variables distinct 
syntactic judgement stands map jx qk 
shall typically write 
environment list abbreviate denotation 
environment list empty corresponding tensor product empty path order substitution consider expected isomorphism qk qk suppose 

computation shape gives mismatch intuition computation path output result single computation path input 
counterpart model absence suitable diagonal map object 



fy xg crossed rec 











allan term formation rules interpret hand raw terms fine intuitively may interpreted validate isomorphism 
appropriate syntactic restriction disallow variable occur freely sides accordingly term formation rules tensor 
similar restrictions apply application match terms 
consider expected isomorphism rec pk rec pk unfolding immediately yields term occurring freely sides tensor 
definition ranges patterns definition raw term 
say set variables crossed iff subterms form tensor application match free occurrences variables appearing rule recursion restricted requiring fy xg crossed linearity constraints strong show syntactic results proposition suppose set fxg crossed lemma formed substitution suppose set variables fx crossed suppose 
variables 
disjoint 

section discussing semantic counterpart variables crossed 
consider term crossed intuitively means computation arguments may 
terms interpretation satisfies may seen essentially map ht dist ht ui curry 
app denote equal path orders premise interpreted map 
allan interpretations specified 
composition map diagonal map product viz 
diag takes gives weak form diagonal map 
analogously define general weak diagonal maps pk lin copies 
weak diagonal maps allow argument different incompatible ways 
denotational semantics term formation rules constructors morphisms morphisms denoted premises denoted cf 

rules shown read par 
comments order recursion rule recursion map composition operation preserves connected colimits fixpoint map category equivalent 
op colimits particular colimits 
sum indicated section path order associated nondeterministic sum operations map tuple hx sum coproduct prefix match prefixed sum coproduct tensor distributes prefixed sum 
map dist expressing form distributivity extension functor 
defined exploiting naturality various operations semantic definitions prove general substitution lemma 
lemma substitution suppose set variables fx crossed suppose 
variables 
disjoint 

suppressing types brevity jt jtk pk note case lemma specialises jt jtk 
particular consequence linear application amounts substitution lemma qk qk 
similarly expected result recursion lemma rec rec rec pk rec pk 
lemma follows directly universal properties prefixed sum property mediating map lin lemma properties prefix match qk qk ii qk iii qk qk expressive power linearity constraints imply allan encode ccs full generality 
particular translation section ccs term rec xj formed crossed ja xk xk minor restriction variable occurs freely sides parallel composition translation allan provides presheaf semantics ccs translation hopla 
hand tensor type allan allows define processes kind encountered treatments nondeterministic dataflow 
define recursively consisting streams sequences 
example process type selects outputs ignoring rec ja ja example process type produces identical parallel streams output rec category elements jbk objects strings fa bg substring 
notice entanglement sides tensor capabilities process side restricted process side done 
effect obtained hopla products nondeterministic sum distributes pairing item xiii 
words choices side effect 
example process type separates stream streams consisting solely second solely rec jc ja 
course stage define operational semantics allows execute examples prove sound complete respect denotational semantics sense 
unfortunately shall see section turned difficult 
operational semantics consider closed term allan type write presheaf interpreting 
sections suggest look operational understanding terms transition system 
hope morphism 
presheaf rooted denotation term corresponding transition operational semantics 
turns case ground type hold general higher order 
hope able extend higher order shall restrict ground types 
ground type expect correspondence labels transitions patterns pattern match terms making possible give operational semantics pattern matching 
start investigating patterns 
general patterns obvious extension allan allow general patterns formed variables distinct 
match understood inductively abbreviation term allan 
get useful insight giving denotational semantics patterns directly 
judgements form distinct interpreted functors 


rules weakening exchange lemma environment uniquely pattern matches allan replaced single typing rule 

confusing syntax semantics ll write map 
lin obtained composition 


empty interpretation rule obtained bu buc rooted component decomposition buc 
intuitively set ways may perform computations matching processes may 
key operational semantics order fragment allan 
tensor fragment consider tensor fragment language order fragment obtained leaving products brevity 
ll need sub language patterns obtain actions images pk 

ll write 
conversely may recover pattern unique variable names replacing distinct variables 
actions stand patterns write 
lemma 
uniquely fact isomorphic path order 
inclusion 
write map btc 
closed presheaf lifted path order decomposition sum rooted presheaves proposition 
turns rooted component form bt denotation term type 
judgements operational semantics express bt rooted component fact derivations transitions correspondence components decomposition fresh variable fresh variable fresh variable fresh variables general patterns abbreviations typing interpretation 

bin pc 












denote equal path orders premise interpreted map 
semantics patterns 
rec rec pm 
tm allan operational semantics operational semantics informed isomorphisms saying find rooted components example isomorphisms left suggesting rules right btc rules closed terms 
semantics suggests open term take transition environment syntactically environments lists matches 
environment exports set variables empty environment exports empty set exports exports free variables plus may formalise judgement distinct denotes presheaf 

term environment written 
give judgement denotation term 
variables exported free operational rules shown 
left rules obvious right counterparts 
tm implicitly renamed avoid exported variables environment rules typed lemma assume 

jxj rec tj rec tj jt rec sup jt tj jtj jt uj jtj juj jtj juj je pj jej jtj je tj jej jtj size measure terms environments terms environments replace rule rec rec tagged recursion expect transition sequences finite 
proved defining size measure 
terms environments see 
sizes measured ordinals possibly infinite sums natural addition ordinals associative strictly monotone argument 
lemma assume 
tagged recursion 
je tj je building fact prove main result says rooted components correspond derivations 
proved founded induction order size measure 
induction hypothesis says 

subset variables 

ranges derivations form theorem assume bt sum derivations 



example derivation example consider process example 
operational semantics derive 
see 
notice term right remembers choice doing action 
extending operational semantics theorem higher order proving difficult 
hopla rules 

contaminate actions exported variables sense 
example consider derivation 





correspondence lost 
difficulty fact led hopla appropriate point give denotational semantics 
recall section inadequacy lin denotational model process calculi 
section discussed reasonable employ lifting allow maps ignore arguments 
radical response employ suitable exponential order allow arbitrary copying arguments 
copying exponential linear logic possible choices see 
intuitively object represent computation path assembly processes computation paths assembly processes collection copies process possibly different states 
take finite colimit completion object finite colimit express paths coincide initially branch 
way understand object computation path assembly processes assembly fixed 
assembly grows copies invoked copies processes run 
copies run resulting processes copied 
way keeping track origins copies account identifications subpaths 
choice exponential obvious inclusion functor playing role yoneda section strict yoneda section 
particular shown free filtered colimit completion spelled functor filtered colimits filtered colimit preserving functor determined isomorphism gip see follows maps lin correspond isomorphism continuous filtered colimit preserving functors cartesian closed category define cts category consisting small categories objects morphisms continuous functors compose functors 
clearly lin subcategory cts shares objects 
cts lin small categories category cts category comonad completions 
unit corresponding adjunction maps copy cts play role bc easily characterise maps cts lin proposition suppose functor preserves filtered colimits 
preserves colimits iff preserves finite coproducts 
continuous map linear iff preserves sums 
isomorphism making cts cartesian closed immediately allows interpret simply typed lambda calculus pairing cts 
products cts lin viewing projections continuous functors 
function space op category cts coproducts resort coproduct lin construct prefixed sum 
definition section just need replace bc copy equivalence category initial element empty colimit decompose presheaf sum rooted presheaves 
key correspondence operational semantics hopla 
may interpret map lin letting judgement denote restriction inductively interpreting 
denotation map application second projections respectively 
rules sound sense identifying term denotation copy rooted component fact correspondence derivations rooted components rules complete 
bisimulation interestingly operational bisimulation park milner congruence hopla maps cts general preserve open maps 
suggests look notions open map cf 
section 
inclusion corresponding notion bisimulation 
unfortunately choice exponential bisimulation degenerates isomorphism choices exponential corresponding bisimulation coincide open map bisimulation may hope recover operational bisimulation bisimulation choice exponential expose union bisimulations 
fact appears correspondence denotational operational semantics proved abstractly depending properties prefixed sum holds choices exponential 
independence returning operational semantics allan consider term example 
operational semantics may derive transitions 
general result saying diagram completed diamond corresponding 

category elements 
words stands operational semantics gives interleaving model tensor fragment presheaf semantics independence model 
distinction fundamental concurrency theory 
interleaving model explains concurrency terms nondeterminism concurrency taken basic independence models 
process means transitions considered independent happen order having done resulting state silent occurred 
diamond property holds process unable prove disprove holds general operational semantics tensor fragment 
considerations independence presheaf semantics tensor fragment led realise definable presheaves represented event structures standard independence model concurrency 
detail categories elements definable presheaves seen posets configurations event structures 
event structures originally concrete representations domains 
interestingly application event structures may play roles interpreting types terms tensor fragment 
material describes progress 
types event structures definition prime event structure binary conflict just event structure triple set events partial order causality binary symmetric irreflexive relation conflict defined 
data satisfy dee def fe finite notation girard notation complement reflexive closure written complement specifying relation clearly determines 
definition configuration finite subset closed dee consistent poset configurations ordered inclusion written note contains dee ll consistently write empty configuration 
configurations compatible written upper bound list basic constructions event structures lifting event structure lifting written 
event structure events causality iff conflict iff poset 
isomorphic new element added 
sum event structures sum written event structure events fi causality iff conflict iff poset isomorphic coalesced sum pointed posets non 
elements written lifted sum event structures lifted sum written event structure ap 
corresponding poset isomorphic lifting separated sum non 
elements written tensor event structures tensor product written event structure events fi causality iff conflict iff poset usual cartesian product posets 
non 
elements written 
event structure event structure events fe events may extend configuration causality conflict simply restrictions events 
poset configurations isomorphic poset constructions allow interpret types tensor fragment event structure 
beware empty configuration types interpreted pointed posets correspond 
section 
recursive types obtained lubs large cpo event structures ordered substructure ordering see respect constructions continuous 
actions section recovered sublanguage language configurations type interpretations called paths syntax restricted rule synonyms 
formed path interpreted obvious element derived rules notice restriction correspondence elements path orders derivations ll confuse syntax denotations path orders paths 
lemma suppose poset isomorphism path order 
accordingly ll treat expression syntactic synonym path order language patterns section obtained language paths replacing distinct variables removing restriction tensor rule 
pattern pattern paths ll write path obtained applying syntactic restriction paths just substitution 
example 
having represented types paths patterns tensor fragment event structures turn terms 
ll need morphisms event structures 
terms spans definition consider event structures 
morphism function satisfies dee ee lemma morphism event structures 
sends configurations configurations injective configurations 
definition notation definition morphism synchronous dee ee 
lemma synchronous morphism 
smaller output configuration obtained unique smaller input configuration 
ll write xj unique synchronous morphism induces presheaf follows fx pg maps xj note rooted 
singleton consisting empty configuration category elements isomorphic poset synchronous morphisms constructions event structures able interpret tensor fragment 
pattern match need able interpret open terms need event structure representation maps isomorphism rooted profunctors 
recall pointed 
shall distinction functor bifunctor op set 
path orders 
ll consider spans form event structure synchronous morphism strict monotone map posets 
equivalent requiring maps events configurations write spn class spans 
induce profunctors 
follows fx qg maps element maps xj note rooted sense singleton containing empty configuration crucial observation stable functor preserves pullbacks 
pullbacks intersection configurations intuitively means output obtained unique minimal input 
detail unique minimal input needed computation 
show poset configurations isomorphic category elements fp 
fact interpreted saying viewed process computation paths needed input assigned computation state 
morphism event structures induces strict monotone map posets seen maps kind suggesting compose spans 
span spn span spn 
form pullback category pointed posets strict monotone maps poset isomorphism componentwise order obvious projections 
non 
elements written fact isomorphic poset configurations event structure events causality iff conflict iff event structure map synchronous 
strict morphisms compose spn expected defining composition pullbacks associativity holds isomorphism suggesting bicategory objects spans arrows 
fact expect spans arise sub bicategory prof bicategory profunctors 
exact relationship determined 
case spans provide alternative denotational semantics tensor fragment 
ll write pj sj interpretations rooted profunctors spans respectively 
proposition term tensor fragment 
isomorphic induced 
proof structural induction typing derivation stable operational semantics event structure semantics may exploited obtain new simpler operational semantics 
working closed terms may derive output corresponding minimal input open terms judgements form paths type respectively path type operational rules shown 
show rules type correct sense derived transition intuitively says type process obtained letting input produce output 
semantically correspondence derivations form configurations jtk 
recursion proved structural induction avoid size measure 
show diamond property semantics 
rec rec allan stable operational semantics event structure semantics suggests stable function space able provide operational counterpart refining rules 
side higher order profunctors induced spans probably don coincide obtained function space presheaf semantics 
difference analogous domain theory dana scott stable domain theory gerard berry 
abramsky 
computational interpretation linear logic 
tech 
report dept computing imperial college 

axiomatic approach adequacy 
brics dissertation series ds 
cattani 
presheaf models concurrency 
brics dissertation series ds 
cattani fiore winskel 
theory recursive domains applications concurrency 
proc 
lics 
cattani power winskel 
categorical axiomatics bisimulation 
proc 
concur lncs 
cattani stark winskel 
presheaf models calculus 
proc 
ctcs lncs 
fiore cattani winskel 
weak bisimulation open maps 
proc 
lics 
hildebrandt 
fully presheaf semantics sccs finite delay 
proc 
ctcs entcs 
hildebrandt 
categorical models concurrency independence fairness dataflow 
brics dissertation series ds 
hildebrandt panangaden winskel 
relational semantics non deterministic dataflow 
proc 
concur lncs 
hoare 
communicating sequential processes 
communications acm 
howe 
proving congruence bisimulation functional programming languages 
information computation 
jacobs 
semantics weakening contraction 
annals pure applied logic 
joyal nielsen winskel 
bisimulation open maps 
information computation 
joyal moerdijk 
completeness theorem open maps 
annals pure applied logic 
kahn 
semantics simple language parallel programming 
information processing 
kelly 
basic concepts enriched category theory 
london math 
soc 
lecture note series cup 
levy 
basic set theory 
springer verlag 
mac lane moerdijk 
sheaves geometry logic 
springer verlag 
nygaard 
operational understanding presheaf models 
progress report university aarhus 
nygaard winskel 
linearity process languages 
proc 
lics 
nygaard winskel 
higher order process language 
proc 
concur 
park 
concurrency automata infinite sequences 
proc 
th gi conference lncs 
milner 
calculus communicating systems 
lncs 
milner 
communication concurrency 
prentice hall 
winskel 
event structures 
lncs 
winskel 
presheaf semantics value passing processes 
proc 
concur lncs 
winskel nielsen 
models concurrency 
handbook logic computer science vol oup 

