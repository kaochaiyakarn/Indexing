temporal logics express search control knowledge planning fahiem bacchus dept computer science university waterloo waterloo ontario canada logos uwaterloo ca june kabanza dept de math informatique universite de quebec canada kabanza dmi ca years increasingly sophisticated planning algorithms developed 
efficient planners unfortunately planners suffer combinatorial complexity simple domains 
theoretical results demonstrate planning worst case intractable 
planning particular domains tractable utilizing additional domain structure 
fact long acknowledged domain independent planners need domain dependent information help plan effectively 
approach representing utilizing domain specific control knowledge 
particular show domain dependent search control knowledge represented temporal logic utilized effectively control forward chaining planner 
number advantages approach including declarative semantics search control knowledge high degree modularity new search control knowledge added affecting previous control knowledge independence knowledge details planning algorithm 
implemented ideas tlplan system able demonstrate remarkable effectiveness wide range planning domains 
classical planning problem finding finite sequence actions transform initial state state satisfies goal computationally difficult 
traditional research supported canadian government iris project nserc programs 
preliminary version results european workshop ai planning appears 
context actions represented strips representation initial goal states specified lists literals restricted versions planning problem known pspace complete 
informative worst case hardness results mean computing plans impossible 
demonstrate domains offer additional structure ease difficult planning 
variety mechanisms exploit structure planning easier 
abstraction related hierarchical task network htn planners studied literature utilized planning systems mechanisms search control received attention 
truly effective planners probably utilize number mechanisms 
important mechanisms developed understood 
contribution development mechanisms search control 
search control useful planning algorithms employ search find plans 
planning researchers identified variety spaces search performed 
spaces exponential size blind search ineffective 
key problem facing planning systems guiding controlling search 
idea search control new notion search heuristics fundamental ideas ai 
planning implementations heuristically guided search various sophisticated heuristics developed guiding planning search 
knowledge systems search control developed 
particular knowledge bases forward chaining rules guide search essence expert systems guiding search 
soar system utilize approach refined version prominent part prodigy system 
similar rule approach search control incorporated ucpop implementation procedural search control language developed 
key difference knowledge search control systems various search heuristics knowledge systems generally rely domain dependent knowledge search heuristics generally domain independent 
reported new approach knowledge search control 
particular utilize domain dependent search control knowledge utilize different knowledge representation different reasoning mechanism previous approaches 
previous search control utilized current state planning algorithm provide advice 
advice computed evaluating domain independent heuristics current state planner current state trigger set forward chaining rules ultimately generate advice 
approach differs 
control provides general depend entire sequence predecessors current state current state 
demonstrate facilitates effective search control 
second search control information state planning algorithm properties planning domain 
planning algorithm take advantage information mapping information properties internal state 
means control information utilize domain dependent provider information need know planning algorithm 
obtaining domain dependent search control information course impose significant overhead modeling planning domain 
overhead justified increased planning efficiency 
give empirical evidence information tremendous difference planning efficiency 
fact show convert intractable planning problem tractable way automatic planning possible 
advance previous mechanisms search control crucial areas 
provides far greater improvements planning efficiency previous approaches 
obtain polynomial time planners relatively simply control knowledge 
empirical tests approaches yielded speedups magnitude 
second approach course difficult domain independent search heuristics easier previous rule mechanisms 
sum approach offers lower overhead mechanism yields superior results 
approach uses order temporal logic represent search control knowledge 
utilizing logic gain advantage providing formal semantics search control knowledge open door sophisticated line reasoning generating manipulating knowledge 
words declarative representation search control knowledge facilitates variety uses 
examples demonstrate logic allows express effective search control information furthermore information quite natural intuitive 
logics previously planning 
fact earliest planning green approach situation calculus 
subsequent planning logic included rosenschein dynamic logic temporal logic :10.1.1.34.9153
viewed planning theorem proving problem 
approach initial state action effects goal encoded logical formulas 
green plans generated attempting prove constructively plan exists 
planning theorem proving date suffered severe computational problems approach yielded effective planner 
approach uses logic completely different manner 
particular viewing planning theorem proving 
utilize traditional planning representations actions states generate plans search 
theorem provers employ search generate plans 
performance hampered fact search space proofs space clear relation structure plans 
shall argue section overhead manageable 
developed procedural search control mechanisms just hard 
fact argued information different knowledge actions simply part store domain knowledge 
reason utilized planning systems 
promising approaches planning theorem proving utilized insights non theorem proving approaches provide specialized guidance theorem proving search 
example stephan utilized ideas refinement planning guide theorem proving process 
approach logic solely express search control knowledge 
show knowledge control search simple forward chaining planner 
explain planner particularly effective utilizing information expressed chosen temporal logic 
implemented combination simple forward chaining planner temporal logic search control system call tlplan system 
resulting system surprisingly effective powerful planner 
planner flexible example plan conditional actions expressed full adl language handle certain types resource constraints 
demonstrate effectiveness empirically number test domains 
forward chaining planners fallen favor ai planning community 
due fact alternate spaces searching plans generally effective 
partial order planners search space partially ordered plans shown possess number advantages 
planners search graph plan graphs models propositional theories representing space plans shown quite effective 
demonstrate combination domain specific search control information expressed formalism suggest forward chaining planner significantly outperforms competing planners range test domains 
appears forward chaining planners despite disadvantages significantly easier control ultimate choice planning technology may open question 
point forward chaining planners easier control argued mcdermott bonet 
planning systems heuristically controlled forward chaining search 
methods automatically generating heuristics considerable done truly effective control information automatically extracted particular planning problem 
result performance systems competitive fastest domain independent planning systems blackbox ipp check performance hsp planning system aips planning competition 
utilize domain specific search control knowledge results demonstrate kind knowledge approach reach new level performance ai planning 
rest describe temporal logic express domain dependent search control knowledge 
example showing control information expressed logic 
section show planning algorithm designed utilizes information section describe tlplan system planner constructed ideas 
show effectiveness approach results number empirical studies section 
domain specific control planning systems htn planners employ extensive domain specific information 
compare approach works section 
close discussion feel important research issues suggested 
order linear temporal logic language expressing search control knowledge order version linear temporal logic ltl 
language starts standard order language containing collection constant function predicate symbols collection variables 
include language propositional constants true false treated atomic formulas 
ltl adds temporal modalities eventually 
standard formula formation rules order logic augmented rules formulas note order temporal formula formation rules applied order quantifiers scope temporal modalities allowing quantifying modal contexts 
call extension include temporal modalities interpreted sequences worlds temporal modalities assert properties sequences 
particular temporal modalities intuitive interpretations means holds world means holds current world worlds means holds world means world holds world holds 
intuitive semantics approximations true semantics modalities 
particular formulas contain temporal modalities say holds world really mean true sequence worlds starts world 
precise semantics 
formulas interpreted models form sequence worlds 
refer sequence worlds timeline 
world model base order language furthermore require share domain discourse constant domain discourse worlds allows avoid difficulties arise quantifying modal contexts 
specify semantics formulas language set interpretation rules 
th world timeline variable assignment function maps variables domain formulas atomic formula iff atomic formulas interpreted world variable assignment standard interpretation rules order logic 
logical connectives handled standard manner 
iff variable assignment function identical maps iff exists true achieved 
iff true state 
iff exists eventually true 
iff true states current state 
say model satisfies formula iff formula true initial world 
difficult show free variables specific variable assignment function irrelevant 
discussion keys understanding semantics temporal formulas realize temporal modalities move timeline 
formulas inside temporal modality generally interpreted current world world sequence seen semantic rules 
expressiveness arises ability nest temporal modalities express complex properties timeline 
point worth making eventually modalities fact equivalent assertions 
particular true true true states see formula simply reduces requirement eventually hold 
dual eventually state falsify noted quantifiers require subformulas scope interpreted modified variable assignment function standard manner quantifiers interpreted 
quantify temporal contexts means variable bound current world passed constrain worlds 
example examples expressed third world timeline holding world timeline true holding enter world remains timeline preserved achieve state 
equivalent saying note example scope quantifier extend modal context 
formula true timeline different object world 
ontable ontable objects table initial state remain table states 
example quantifying modal context binding various objects table initial world passing bindings worlds 
need additions language extension introduces additional modality goal second extension syntactic 
goal modality 
going formulas express domain dependent strategies search control 
trying control search find solution goal strategies generally need take account properties goal 
empirical tests making current goal essential writing effective control strategies 
facilitate augment language additional modality goal modality 
intention modality able assert certain formulas true goal world 
syntactically add formula formation rule rules pure order formula containing temporal goal modalities goal formula goal subsequently appear subformula complex formula 
give semantics formulas augment models language pairs form timeline described set worlds domain intuitively set worlds satisfy agent goal agent wants modify current world reach world add semantic interpretation rule ones goal iff formula full language language goal modality added containing free variables say model satisfies iff refer full language generated formation rules including formation rule allows goal modality 
clear goal clear example syntactically legal formula augmented language 
formula satisfied model iff pair objects clear true clear true clear true world timeline 
goal hand formed formula apply goal formula containing temporal modality 
note syntax allows goal formulas nested inside temporal modalities vice versa 
ontable goal example syntactically legal remember order model variable assignment 
decided standard interpretation rules order formulas 
formula 
says world timeline exist pair blocks table true goal world note particular instantiation goal true world timeline false world timeline semantics goal goal formulas independent timeline 
set instantiations require goal true change world timeline due outermost modality 
particular formula true completely different pair blocks satisfies ontable goal world timeline 
noted assert goal goal goal logically entailed 
clearly true world true true 
bounded quantification 
section demonstrate method information expressed temporal logic computationally 
facilitate usage eschew standard quantification bounded quantification 
convenient point introduce addition syntax 
take bounded quantification purely syntactic extension 
see additional restrictions required achieve computational effectiveness 
definition formula 
atomic formula atomic formula inside goal modality 
bounded quantifiers defined follows 


convenience define easiest think bounded quantifiers semantically holds iff true holds holds iff true holds 
quantifier bound simply serves limit range quantified variable ranges 
restrictions bounded quantification just expressive standard quantification simply take propositional constant true 
atomic goal formulas quantifier bounds 
goal definition abbreviation goal seen simple semantic meaning asserting holds true goal world 
uses language 
defined formal language possess declarative semantics 
possible language logic perform inference collections sentences defining standard notion entailment 
formulas full language define explore logic words possibilities section 
explore means declaratively specifying search control information utilize formal semantics verify correctness algorithms utilize control knowledge 
iff models extended example section demonstrate express domain specific information 
information viewed simply additional knowledge dynamics domain 
traditionally planning task undertaken simple knowledge domain dynamics 
particular usually specified planning problem information primitive actions applied effects 
knowledge planner expected able construct plans 
experience ai planners indicates problem difficult point view theoretical worst case behaviour point view practical empirical experience 
part motivation opinion successful planning systems access addition useful knowledge dynamics domain knowledge goes simple specification primitive actions 
knowledge come designer planning system long term expect knowledge learned computed system 
example human agents experimentation exploration gather additional knowledge dynamical domains expect eventually autonomous planning system 
automatically generating knowledge preliminary explore utilize knowledge provided designer planning system 
section give extended example familiar blocks world serves demonstrate considerable additional knowledge available designer 
advance argument temporal logic serves useful flexible means representing knowledge 
section discuss knowledge put computational reduce search planning 
noted ai planning systems practical impact htn style planners 
htn hierarchical task network planners utilize domain knowledge form task decomposition schema goes simple knowledge action effects utilized classical planners 
discuss point section 
operator preconditions deletes adds ontable clear pickup holding ontable clear putdown holding holding clear clear clear holding clear 

stack 
unstack 
table blocks world operators 
blocks world 
consider standard blocks world describe strips operators table 
despite age blocks world hard domain sophisticated domain independent ai planners 
experiments indicate see section generating plans reconfigure blocks limit current planners blocks world special structure planning domain easy 
easy write additional information dynamics domain information potentially put planning 
basic idea blocks world towers built bottom 
built prefix tower need prefix order finish task 
example consider planning problem shown 
solve problem clear need unstack tower blocks called tower tower need order achieve goal 
generally write straightforward order formula single world describes clear block sits top tower tower blocks need 
clear goal holding ontable goal goal ontable goal holding goal clear goal goal block satisfies predicate top tower clear required robot holding tower violate goal conditions 
various tests violation goal condition tower definition 
table goal require block hand block required table robot required hold required clear block required block required tower violate goal conditions 
represent insight towers preserved formula 
plan reconfiguring collection blocks sequence actions manipulating blocks 
initial state blocks world example goal state actions executed world passes sequence states states brought actions 
plan reconfigure blocks destroy tower generate sequence states tower destroyed 
tower destroyed eventually reassembled better plan preserved tower 
formulas specify properties sequences states write formula characterizes state sequences destroy towers 
plan generates state sequence destroys towers state sequence fail satisfy formula 
example state transitions caused stacking block violate formula 
note definition tower tower blocks mentioned goal tower irrelevant blocks violate goal conditions 
formula rules state sequences towers irrelevant blocks 
singleton tower example satisfies definition tower 
towers towers 
clearly violate goal condition 
point stacking blocks top eventually disassemble towers 
define clear clear clear augment characterization state sequences ruling grow bad towers formula clear formula rules sequences place additional blocks bad tower 
furthermore conjoining new control previous formula continues rule sequences towers 
formula sequence pickup blocks top bad towers 
want bad towers disassembled 
example tower blocks bad tower 
action stacks block cause state transition violates second conjunction formula 
formula rule useless actions 
particular definitions single block table intended table bad tower 
example block singleton bad tower 
intended block currently table 
formula permits pick blocks top bad towers point picking stacked general point picking singleton bad tower blocks final position ready 
adding insight arrive final characterization state sequences blocks world clear ontable goal holding provided intuitions formula formula rule bad state sequences number details remain fleshed 
sections 
finding plans previous sections provided formal logic assert various properties timeline examples showing timelines violating asserted properties worth exploring 
put logical ideas computational need concrete data structures represent timeline models manner models constructed determine formulas satisfied falsified models 
sections provide details 
utilize extended version standard strips database representation individual worlds timeline 
representation individual world represented complete list ground atomic formulas hold world 
closed world assumption employed ground atomic formula world database falsified world 
planning problem provides complete strips database specification initial world actions generate new worlds specifying complete set database updates applied current world 
sequence actions applied initial world generates sequence complete strips databases 
strips databases essentially identical traditional relational databases viewed finite order models 
order formulas evaluated models section provide details evaluation algorithm 
algorithm allows determine individual world satisfies falsifies order formula 
general need deal formulas go standard order formulas inclusion temporal goal modalities 
treat goal modality formulas section 
section show deal temporal modalities 
method builds ability evaluate atemporal formulas individual worlds 
approach formulas guide planning search involves testing candidate plan falsifies formula 
formalize notion plan satisfying formula describe mechanism checking plan prefix see extensions necessarily falsify formula describe planning algorithm constructed mechanism 
checking plans actions map worlds new worlds 
plan take finite sequence actions generates finite sequence worlds worlds arise plan executed 
worlds standard strips database plan fact produces finite sequence order models suitable model difficulty models infinite sequences order models 
intuitively plan intended control agent finite time time agent completes execution plan 
classical assumed agent executing plan source change 
addresses issue search control context classical planning adopt assumption 
means execution plan completed world remains unchanged phrase common verification literature world 
model formally manner definition plan finite sequence actions sequence worlds initial world sequence worlds visited plan 
model corresponding defined extended infinite sequence infinitely replicating final world 
verification literature know idling final world 
finite sequence actions generate corresponds unique model final state idling 
formula plan falsify satisfy 
fact evaluating database queries relational databases essentially evaluating logical formulas finite models central theme database theory 
reactive plans policies concerned going interactions agent environment 
applications want agent accomplish task finite horizon case plans finite sequences actions generally suffice 
definition plan initial world 
say satisfies falsifies formula just case model corresponding satisfies falsifies formula blocks world control formula formula designed char sequences blocks world transformations check plan see plan 
control formula say plan plan satisfies unfortunately tractable check satisfies arbitrary formula knowing directly help searching plan 
searching plan need able test partially constructed plans objects searching 
furthermore need able determine plan possible arise expansion partial plan 
test able mark partial plans dead ends pruning search space avoiding having search successors 
contributions method doing space partial plans searched forward chaining planner 
checking plan prefixes forward chaining planner searches space world states 
particular examines executable sequences actions emanate initial world keeping track worlds arise actions executed 
sequences plans right prefixes plans result expansion 
developed incremental mechanism checking plan prefix gen erated forward chaining lead plan satisfies arbitrary formula 
method subject restriction quantifiers formula range finite sets quantifier bounds formula specify finite sets 
clearly restriction satisfied application worlds specified finite strips databases quantifier bounds atomic formulas involving described predicates 
key method progression algo rithm table 
algorithm takes input formula produces new formula output 
seen clauses algorithm handles quantification expanding instances 
assumption bounded quantification comes play algorithm iterate instances quantifier bounds 
noted algorithm particular tractable check plan satisfies various formulas bound size sets quantification range bound depth quantifier nesting formulas tractable test world visited plan satisfies ground atomic formula 
defined section described predicates predicates positive instances appear explicitly strips database 
technique expanding universal base ucpop planner similar manner ucpop assume universal base finite :10.1.1.143.5194
inputs formula world output new formula representing progression world progress algorithm case 
contains temporal modalities 
progress progress progress 
progress progress true false 



progress 
progress progress progress 

table progression algorithm 
relies ability evaluate atemporal formulas individuals worlds case section provide algorithm test 
progression algorithm boolean simplification intermediate results various stages 
applies transformation rules 
false false false 
true true 
true false 
false true 
transformations allow algorithm occasionally short circuit recursive calls 
example conjunct connective progresses false need progress remaining conjuncts 
key property algorithm characterized theorem theorem model 
formula quantification bounded progress proof prove theorem induction complexity atemporal formula iff line algorithm applies progress true false dependent world satisfies true satisfy false 
progress iff required 
progress progress form iff iff induction iff progress progress iff line algorithm progress form case similar previous 
form iff semantics iff line progress algorithm form iff semantics exists iff satisfied immediately current state sat state satisfies entire formula iff induction progress iff line progress progress form cases similar previous ones 
iff iff induction progress iff assumption satisfied finite number objects satisfies conjunction progress formulas finite number resulting conjunction infinite valid formula iff line progress case similar previous 
say wish check plan prefixes determine satisfy formula starting initial world theorem plan starting satisfy subsequent sequence worlds visits satisfies progress formula false know plan starting world possibly satisfy model satisfy false 
similarly formula true plan starting world satisfy model satisfies true 
check subsequent sequences progressed formula progression serves check null plan prefix plan 
suppose apply action generating successor world compute progress know plan starting sequence worlds plan starting action satisfy sequence worlds visits satisfies false plan satisfy true plan satisfies continue check extensions action sequence formula difficult see process iterated yield mechanism plan prefix sequence actions continually updates original formula new formula characterizes property satisfied subsequent actions order entire action sequence satisfy stage progressed formula true false definite answer possible extension current plan prefix 
reasoning yields observation finite sequence worlds generated finite sequence actions applied initial world 
formula labeling output progress result iteratively progressing sequence worlds 
formula false sequence worlds starting satisfy shows progression algorithm sound 
rules plan prefix guaranteed extension satisfy original formula progression model checking algorithm operates progressing formula particular finite sequence worlds finite prefix timeline reason timelines general 
progression ability give early answer question give definite answer 
progression complete 
verification literature class safety formulas defined 
formulas subset set linear temporal logic ltl formulas property violation safety formula occurs finite period time 
precisely safety formula timeline falsifies finite prefix extensions prefix falsify generally formula conjunction safety formula liveness non safety formula 
case prefixes falsify safety component infinite timelines falsify liveness component progression algorithm certain extent ability model check safety component initial formula particular progression algorithms ability detect finite prefixes falsify safety component algorithm complete may plan prefixes extensions falsify ruled progression progress false prefixes 
components incompleteness 
progression check liveness component formulas 
example check liveness requirements achievement order version ltl added goal modality syntactic characterizations safety formulas exists general testing propositional ltl formula safety formula pspace complete problem 
eventualities formula 
just current world sufficient information determine eventualities achieved 
extensions particular plan prefix fail satisfy liveness requirements detected progression algorithm 
example actions prefix resource needed satisfy liveness requirements progression able detect 
second source incompleteness arises fact progression employ theorem proving 
example formula unsatisfiable progressing formula discover 
apply progression progress obtain algorithm may able reduce progress false left original formula reduce formula 
know world satisfy unsatisfiable formula semantics see fact plan satisfy formula 
general detecting unsatisfiable requires complete theorem prover 
advantage giving component completeness computational efficiency 
ignoring quantification progression algorithm complexity linear size formula assuming tests line performed time linear length propositional formula 
complexity validity checking quantifier free linear temporal logic known pspace complete 
noted progression ability detect unsatisfiable formulas buried inside eventuality 
example formula atemporal unsatisfiable progression formula world false 
progression due case algorithm return false simplified false 
case progression model checking atemporal formula model determining falsified proving falsified world process requires validity checker 
model checking formula particular world tractable computation checking validity see discussion issue 
example say progress formula world true 
result formula true reduced hand says falsifies progressed formula false clear clear reduced false 
example shows formulas generate test current world propagate test world 
example say progress formula world true 
result formula test propagated world addition clear world required clear satisfy currently true 
hand user specify safety formula prohibiting conditions liveness requirements impossible achieve 
return issue quantification tests line 
inputs world formula goal set domain actions current plan prefix start planning tlplan call initial world initial control formula current plan prefix empty 
output plan sequence actions transform world satisfies algorithm tlplan 
satisfies return 
progress 
false return failure 

choose action set actions preconditions satisfied 
action exists return failure 

world arises applying 
return tlplan 
table planning algorithm 
falsified progressed formula simply clear simply propagate constraint additional requirements world 
possible add progression algorithm idling checking algorithm receive definite answer question plan prefix satisfies formula sense definition see details 
purposes search control necessary 
particular plan prefixes checking final plan want know possibility lead final plan 
purpose partial information returned progression sufficient 
planning algorithm progression algorithm admits planning algorithm shown table 
algorithm tlplan system described section 
algorithm described non deterministically search performed explore correct choice action apply world algorithm essentially simple forward chaining planner progressive world state planner terminology 
difference world labeled formula initial world labeled user supplied formula expressing control strategy domain 
expand world progress formula progression algorithm generating new formula new formula label successor worlds worlds generated applying applicable actions 
progresses false false theorem shows sequences worlds emanating satisfy formula 
immediately mark dead search space avoid exploring successors 
evaluating atemporal formulas individual worlds previous section showed checks plan prefixes determine extensions falsify initial control formula 
process proved sound incomplete 
progression algorithm assumptions plan prefixes generated search consist sequences order models formula containing temporal modalities models sequence determine satisfies case algorithm 
section show assumptions satisfied planning system construct 
mentioned previous section represent state plan strips database extensions described closed world assumption employed databases formally order models 
furthermore actions modeled performing database updates follows strips model 
action maps database new database order model new order model 
assumption trivially satisfied plan prefix consists sequence order models 
satisfy assumption simply need specify algorithm evaluating atemporal formulas models strips databases 
formula evaluator algorithm specified 
assumptions satisfied progression algorithm sound sense observation 
planning algorithm specified table searches plans transforms initial world world satisfying goal 
searches plan space action sequences emanating initial world eliminating search space set plan prefixes 
guarantee plan prefix eliminated search space extension satisfying initial formula 
planning algorithm trivially sound 
plan plan fact correctly transform initial state state satisfying goal 
planning algorithm complete return plan exists underlying search algorithm note incompleteness pose fundamental difficulty approach 
incompleteness means fail prune away invalid plan prefixes 
real issue prune away sufficient number prefixes search computationally feasible 
section provide extensive evidence 
pure strips database finite order model 
evaluator describe facilities range variables finite set integers evaluate numeric predicates functions 
implies system implicitly dealing infinite models 
particular checking formulas order model determined strips database conjoined integers 
actions precise representation precise operational semantics discussed 
plan returned correct specific interpretation action effects 
complete plan exists plan falsify initial formula exists 
formula evaluator checks truth formulas individual worlds 
world represented extended version strips database 
particular distinguished set predicates called described predicates 
world database containing positive ground instances described predicates hold world 
closed world assumption employed derive negations ground atomic facts 
addition described predicates world include set described functions 
specified database database storing value described function various arguments 
actions map worlds worlds effects ultimately specified updates described predicates functions 
standard operational semantics strips actions fact semantics applicable adl actions 
building database described predicates add defined predicates functions 
predicates functions value defined order formula 
add computed predicates functions generators 
mainly numeric predicates functions rely computations performed underlying hardware 
evaluator evaluate complex atemporal formulas involve symbols appearing underlying database described predicates 
formula evaluator tables 
lowest level recursive algorithm table convert complex order terms containing functions variables constants 
variables easy simply look value current set variable bindings 
hard see long top level formula passed eval contains free variables sentence set bindings value variable time variable evaluated 
allows types functions computed described defined functions 
computed functions invoke arbitrary computations collection constant arguments arguments function evaluated prior passed arguments 
value function depend current world function may independent world 
example possible declare standard arithmetic functions computed functions 
evaluator encounters term recursively evaluates invokes standard addition function compute sum 
world contains database values described function functions evaluated simple database lookup 
user ensure function values specified initial state action descriptions properly update values 
example blocks world specify function equal object block current world convention table condition standard algorithm employs search 
second condition means user specify sensible control knowledge control knowledge eliminates redundant plans 
adl actions complex order preconditions conditional add deletes 
set add deletes action generates set ground atomic facts 
quantifier clauses eval set variable values prior 
inputs atemporal formula world set variable bindings output true false dependent algorithm eval case 
atomic formula return 
eval return false return eval 
return eval similar processing boolean connectives 

generator generator true generator eval generator 
return generator generator false true 
return return eval table formula evaluator 

initial state specify initial values actions stack putdown update function values 
updating function values action accomplished utilizing adl representation actions allows specification updates function values 
defined functions functions value defined formula 
evaluating functions requires recursive call top level formula evaluator 
describe rest evaluator prior describing defined functions 
level terms evaluation atomic formulas ground atomic formulas terms evaluated prior evaluating formula 
evaluator allows described computed defined predicates 
described predicates standard type 
world maintains database positive instances predicates truth ground instance determined database lookup 
standard initial state specify positive instances described predicates actions specify correct adds deletes keep inputs ground atomic formula world output true false dependent algorithm case 
described predicate return lookup 
defined computed predicate return 
defined formula arguments return eval table evaluating atomic formulas 
inputs term world set variable bindings output constant value world algorithm case 
variable return return binding 
constant return 
described function return lookup 
computed function return 
defined formula arguments eval return table evaluating terms 
database date 
computed predicates computed functions invoke arbitrary computation case return true false 
way include arithmetic predicates formulas 
weight weight example legitimate formula weight declared function 
formula evaluator evaluate terms weight prior invoking standard numeric comparison function compare weight values 
interesting type predicate defined predicates 
defined functions predicates defined order formulas 
predicate defined section example defined predicate 
defined predicates evaluated simply recursively invoking formula evaluator formula defines predicate appropriate modifications set bindings 
key feature mechanism allows write evaluate recursively defined predicates 
example define transitive closure top level evaluator simply decomposes formula appropriate set atomic predicate queries 
decomposition determined semantics formula connectives 
quantifiers treated special manner 
previously mentioned implementation utilizes bounded quantification 
formula specifying quantifier bound restricted atomic formula involving described predicate goal atomic formula involving described predicate special computed function 
inside evaluator implemented quantifier bound construct generator instances bound 
function time send returned generator message returns value variable 
described predicate quantifier bound generator instances easy construct world database generator simply returns positive instances predicate contained database 
implementation allows computed generators invoke arbitrary computations return sequence variable bindings 
considerable generality implementation 
ary predicates generators 
generators bind tuples variables evaluating formula generator pairs holds current world constructed 
generators automatically take account previously bound variables 
example clear evaluating outer generator successively bind clear block inner generator bind single block block currently bound clause formula evaluator algorithm deal defined functions 
discuss defined functions section 
course user write recursively defined predicates manner recursion terminates 
short circuiting booleans quantifiers evaluating remaining disjunctions disjunctions evaluates true essential process 
useful want quantified variable range finite set integers 
evaluating goal formulas mentioned section language utilized express control formulas action preconditions adl formulas includes goal modality 
practice user specifies goal order formula generally means transform initial state world satisfying solution problem 
formally set goal worlds interpret goal formulas see section taken set order models satisfying semantics goal section interpretation set goal worlds goal true iff temporal control formula includes goal modality control formulas world progress control formula world may invoke evaluator determine truth goal formulas truth various speeding search able efficiently evaluate goal formulas 
general checking entailment checking efficient 
goal formulas control formulas preconditions adl actions enforce restrictions implementation ensure evaluated efficiently 
particular goal formulas require goal specified list ground atomic facts involving described predicates restrict goal formulas appear domain specification form goal atomic formula involving described predicate 
restrictions evaluate goal formulas efficiently simple lookup operation 
set ground atomic formulas model falsifies atomic formula set 
restrictions goal true efficiently utilize goal formulas bounded quantification instances quantifier range instances explicitly appear example goal set ground atomic facts ontable clear goal ontable evaluate true 
goal ontable evaluate false 
ontable goal ontable evaluate true iff blocks table current world equal quantifier evaluated current world successively bound instance satisfying ontable bound true goal ontable evaluate true 
evaluate false ontable binding 
formula true blocks table block table ontable ontable goal case quantifier evaluated goal world binding satisfying bound formula evaluate true world table iff table may number blocks correctness evaluator evaluator breaks formulas standard order semantics difficult see evaluates atomic formulas quantifier bounds correctly immediately follow evaluates formulas correctly 
deal quantifier bounds 
quantifier bound goal previous restrictions described predicate 
furthermore binding sequence variables satisfies quantifier bound list ground atomic facts specifies goal 
iterating list facts correctly evaluate quantifier bound 

quantifier bound described predicate binding variables satisfies quantifier bound world database positive instances 
iterating world database correctly evaluates quantifier bound 

quantifier bound computed generator function user supplies generate sequence bindings current world current set bindings 
take sequence definition set satisfying instances quantifier bound 
definition computed generators correctly evaluated 
atomic formulas require evaluate terms contain 
term variable value current binding set generator quantifier bound 
shown generators operate set bindings correctly 

constants value correctly evaluates terms 

term described function strips database contains values function simple lookup correctly evaluate terms 

term computed defined function take value returned define function 
operational semantics defined functions described section 
terms evaluated correctly definition 
atomic formulas 
system ensure user supplied generator function implements user intended 
provide specific semantics output function ensure correctly implements semantics 
approach taken programming languages compilers 
language specifies specific semantics language construct compiler correct correctly maps programs specified semantics 
program implements user intended separate matter 
search engine goal tester state expander tlplan system formula evaluator formula 
atomic formula involves described predicate strips database contains positive instances predicate 
predicates evaluated simple database lookup procedure 

atomic formula involves defined predicate evaluation shown correct induction base case atomic predicates defined predicates 

atomic formula computed predicate take value returned computation define predicate 
tlplan system constructed planning system called tlplan system utilizes planning algorithm shown table 
section describe system supply final details design system 
tlplan simple system diagram components shown demonstrates 
distinct components system subtlety defined predicate recursive 
case need fixpoints give precise semantics predicate 
goes scope supply semantics approaches problem developed concerned providing semantics database queries recursive see 
search engine implements range search algorithms 
goal tester called search engine determine reached goal world 
goal tester turn calls formula evaluator implement test 
state expander called search engine find successors world 
state expander turn calls formula evaluator determine actions applicable world 
calls formula determine formula label new worlds 
formula implements progression algorithm shown table 
progression algorithm uses formula evaluator realize line algorithm 
formula evaluator implements algorithm shown tables 
forward chaining planners tlplan inherently simple 
worth pointing functionality needed planner implemented evaluator 
shows design tlplan 
properly designed formula evaluator provides considerable additional flexibility expressiveness system understanding operation provides insights worst case complexity planner basic operations 
utilizing evaluator operational semantics shown previous section formula evaluator correctly determines truth atemporal formula 
way view evaluator evaluator viewed interpreter language language syntactic structure atemporal component viewed interpreter evaluator operational semantics precisely specified algorithm tables 
particular evaluator formula evaluate perform precise sequence computations determined syntactic structure formula properties world formula evaluated 
example say evaluate formula world holds 
evaluator perform computations 
evaluate evaluate true 

evaluate evaluate false 

return false 
hand evaluate formula evaluator perform computation evaluating behaviour stems fact evaluator utilizes early termination boolean connectives quantifiers 
point view correctness early termination difference evaluator returns value matter formula written 
early termination useful control flow mechanism add additional computed predicates 
computed predicates functions invoke user defined computation order return value evaluator 
great economy implementation achieved advantage fact 
particular implementation realized simply supplying additional set computed predicates functions 
predicates functions return specific values mainly designed invoke useful computation evaluated 
printing example 
system defines computed print predicate arbitrary number arguments 
predicate returns true truth value formula containing print rewritten replacing instances print true 
evaluator evaluates print predicate computation invokes generates side effect 
predicates trivial declarative semantics usually equivalent propositional constant true 
effects determined computation invoke evaluated evaluator operational semantics determines conditions invoked 
example world example formula print holds print holds evaluate false just evaluation print string holds side effect formula print holds print holds return false generate evaluation terminate prior print statement evaluated 
example shows viewing evaluator interpreter formula evaluation syntax dependent way affects correctness final value returns 
despite drawback utilizing evaluator interpreter implement remaining components planner quite easily 
discuss components 
defined functions operational semantics evaluator provides mechanism allows user specify defined functions 
functions handled clause formula evaluator algorithm table 
noted thinking evaluator interpreter surprising order conjunctions formula difference 
order statements difference programming languages 
consider function depth returns depth block clear blocks depth zero 
function computed evaluating formula depth depth clear depth depth depth zero clear exist block top depth depth formulas defining functions utilize computed assignment predicate 
predicate handled clause evaluator algorithm 
assignment returns true side effect sets binding variable equal value term left hand side 
defined functions convention assigning values function name shorthand setting return value 
value function value assigned name 
internally defined functions handled adding function name new unassigned variable set variable bindings see clause algorithm table 
evaluate formula defining function augmented set variable bindings 
evaluator encounters assignment predicate depth modifies binding variable 
evaluator processed defining formula function name variable set value value returned function value 
simple mechanism adds considerable flexibility defining planning domain 
noted formula defining depth written interpretation evaluator yield correct value depth 
particular consequent implications assignments evaluated antecedent evaluates true 
progression algorithm shown table case progression algorithm needs evaluate various subformulas holds current world 
accomplished calling formula evaluator 
useful illustration working progression algorithm formula evaluator provided example 
example consider control formula blocks world ontable goal holding formula asserts plan pickup block table block required block say wish progress formula world ontable ontable clear clear set ontable clear facts implementation extends mechanism allow defined functions predicates local variables assigned 
local variables essential speedup certain computations 
hold say goal specified set encountering modality compute progression ontable goal holding return conjunction result original formula case table 
progress subformula evaluator called generator instances clear hold instances progress subformula ontable goal holding call generator return binding subsequent calls evaluator return true ontable true goal instantiations satisfy goal world 
terminates progression antecedent implication 
antecedent true forced progress consequent implication holding result instantiation progressed formula holding call top level generator returns binding new binding evaluates true goal evaluates false binding ontable satisfies existential 
conjunction evaluates false entire implication progresses true 
final result formula holding ontable goal holding says subsequent state holding remember progressed formula label successor worlds 
implementing operators actions specified strips adl operators 
instantiate parameters operators obtain action instance instantiated precondition add delete clauses 
action applied current world instantiated precondition satisfied world 
easy formula evaluator determine action precondition satisfied current world 
go 
utilizing evaluator interpreter adding appropriate computed predicates formula evaluator fully implement operators 
process best illustrated example 
consider strips operator unstack specified table 
precondition list clear add list holding clear delete list clear represent operator formula 
formula evaluated current world side effect computed predicates correctly construct successor worlds generated various executable instances operator 
formula unstack clear del del del add holding add clear formula evaluated current world thing done evaluator test true 
instance unstack applicable computation necessary 
quantified subformulas evaluated 
variables instantiated objects satisfy preconditions operator representing operator parameters quantified variables standard processing quantifiers find executable actions 
new computed predicates need add del 
generates new copy current world add del modify databases describe instances various predicates hold copy 
predicates evaluate true world 
evaluating predicates world generated applying current action current bindings computed 
difficult see strips operator translated formula form 
mechanism easy handle adl operators full generality 
adl operators take arbitrary order formulas preconditions conditional add delete lists 
furthermore operators update function values 
adl operator converted formula form add formula precondition operator 
contains vector free variables instantiation true current world specifies single executable action 
action conditional updates activated 
conditional updates potentially add delete instances predicate fixed instantiation may instantiations satisfy conditional update formula del add del syntactically unusual take atomic formulas arguments 
wanted say computed modalities computed predicates 
interesting point convert operator formulas universally quantified operator parameters need unification 
particular unification algorithm plays role tlplan system 
action instance add delete instance predicate distinct instantiation satisfies current world 
function updates handled uniform manner equality predicate 
term add update function value equal current binding 
functions unique values add function value automatically deletes old value 
actual adl strips operators specified standard syntax translated form 
form direct formula evaluator apply operators current world 
testing goal achievement discussed goal usually specified list ground atomic facts test world satisfies goal evaluate conjunction evaluator directly test goal achievement 
point checking arbitrary formulas world efficient 
principle give planner goals expressed complex order formulas 
planner perform search world evaluate formula current world see goal achieved 
produce planner capable generating plans achieving disjunctive quantified goals fact tlplan configured accept arbitrary firstorder formula goal 
problem general goals form arbitrary formula checking goal holds various checking hard requires theorem proving 
reason tlplan accept formulas goals domain utilizes goal formulas 
complexity planner components domain specifications accepted tlplan sufficiently general quite possible write specifications cause planner basic operations intractable 
practice planner efficient basic operations 
formula evaluator heart system start examining complexity 
evaluating formulas evaluating formula usually efficient 
particular quantifier free formula computed defined functions predicates appear evaluating complexity linear length basic set described functions predicates evaluated near constant time boolean connectives 
indexing hashing techniques perform database lookups near constant time 
actual implementation simpler albeit log time binary tree representation world databases contains computed predicates functions said general performance evaluator predicates functions invoke arbitrary computations 
test domains computed predicates functions useful need define ones particularly expensive compute 
allow contain quantifiers formula evaluation pspace complete 
easily shown reduction quantified boolean formula problem known pspace complete 
quantified boolean formula formula form universal existential quantifier boolean variable boolean expression involving problem determine formula true 
example true formula matter value takes exists value true formula true true false false values false false true 
hand false 
consider world predicates type predicate truth predicate positive instances predicates true convert quantified boolean formula order formula replacing universal existential quantifier bounded quantification 
similarly boolean expression replace variable atomic formula example quantified boolean formula difficult see converted formula evaluates true world original quantified boolean formula true 
shows evaluating quantified formulas pspace hard 
algorithm pspace easy observation may need test different sets bindings quantified variables stage algorithm need store set bindings 
observation indicates easily write quantified formulas intractable formula evaluator 
practice things bad 
total number objects domain deepest level quantifier nesting formula worst evaluating take time pspace result holds write formulas nested quantifiers length increase quantifier nesting adds size exponent 
practice rarely need nest quantifier deep case evaluating formulas remains polynomial complexity fact 
formula evaluator performance bottleneck test domains 
area careful evaluating quantified formulas 
mentioned determine set actions executed current world evaluating formula operator parameters converted quantified variables 
way convert operator description quantified formula significant difference planner performance 
best illustrated example 
gives excellent performance 
consider formula encodes unstack operator previously section clear del del clear del add holding add clear alternate encoding operator formula clear del del clear del add holding add clear formula logically equivalent far efficient 
worlds false evaluator immediately recognize instance unstack applicable formula 
second formula evaluator iterate pair object clear iteration evaluation fail produce applicable instance unstack 
formula evaluates constant time second takes number blocks domain 
action formulas evaluated world forward chaining search differences significant impact planner efficiency 
issues involved choosing logically equivalent formulas generate converting action formula choose ordering adjacent universal quantifiers essentially issues arise area query optimization databases 
needless say considerable body area applied problem 
implementation employs simple heuristics lines converts operators formulas 
final issue arises examining complexity formula evaluator defined predicates 
mentioned defined predicates invoke evaluator formula defines predicate 
formula recursive 
means single predicate instance formula may invoking considerable additional computation evaluator recurses definition 
easy see priori bound complexity process 
previous cases particular problem test domains 
state expansion goal testing described state expansion finding applying set actions applied current world testing goal achievement involve utilizing formula evaluator 
complexity components determined complexity formula evaluator 
progressing formulas process progressing formulas area expensive computations invoked 
seen table progression algorithm generally quite efficient 
particular quantification process essentially linear size input formula 
quantification possible specify short formula takes long time progress 
difficulty progression lies progressing formula repeated progression formula sequence worlds 
planning explore sequence states progress original temporal control formula times world formula grow length progression careful lead excessive space time requirements 
example consider progression temporal formula world hold algorithm yields new formula 
progression formulas form progress formulas grown quadratically size 
furthermore formula grows longer progress multiple worlds 
key efficient implementation progression algorithm realize progressed formula subformulas common original formula 
considerable efficiency gained sharing subformulas 
fact example share substructures progressed formula requires store new top level connectives 
structure sharing known technique automated theorem provers employed similar techniques implementation 
addition space efficiency structure sharing yields computational efficiency 
progression distributes logical connectives progress progress 
computed progression progress subformula progression spliced subformula appears need compute progression subformula 
example progress new formula time need progress subformula appears times formula 
structure sharing techniques quantification main impact efficiency progression practice 
consider formula object progression invokes evaluator atemporal subformulas noted potential intractable 
progress formula world object satisfies object object object hold get new formula object progression algorithm deals quantifiers expanding particular instances see progression formula grows length factor determined number objects satisfying object currently fail satisfy nested quantifiers progressed formula length number objects domain 
behaviour analogous behaviour formula evaluator face nested quantification 
case rarely need nest quantifiers deep temporal control formulas 
furthermore natural control formulas continue grow continually length 
consider example control formula specified blocks world formula 
formula progressed world generate collection conditions hold world 
particular collection towers preserved collection bad towers placed top collection blocks held state 
conditions checked discharged world 
length control formula grows shrinks grows monotonically progress sequence worlds 
summary tlplan allows expressive domain specifications 
sufficiently expressive quite possible express domains basic operations planner intractable 
practice planner expressiveness boon bane 
allows easy specification domains potential intractability basic operations major issue far 
note tractability planning domain separate issue tractability planner basic operations 
tractability basic operations necessary condition tractable planning means sufficient 
empirical results section show right control knowledge tlplan plan effectively test domains 
empirical results implemented range test domains determine easy specify control information formalism effective information controlling planning search 
empirical tests ran tlplan pentium pro mhz machine mb ram 
amount memory sufficient tlplan tests 
ran various tests blackbox ipp satplan prodigy ucpop systems 
blackbox satplan similar systems encode planning problems satisfiability problems 
satplan uses different encoding efficient black box employs various simplification steps interleaved generation encodings 
ipp graphplan algorithm optimized various ways extended handle subset adl language 
blackbox ipp state art planning systems 
best performers aips planning competition coded tlplan 
systems tremendous memory ran sun ultra mhz machine mb ram 
sufficient memory systems careful recording cpu time count time taken swapping 
furthermore fairly clear trends established time problems large start excessive thrashing 
noted blackbox ipp high memory consumption ignored 
space limiting resources time cases 
older systems ucpop prodigy coded lisp ran mhz sun ultra support lisp 
performance difference systems great recoding running faster machine helped 
blocks world tlplan performance different control formulas formulas section depth search shown 
data point represents average time taken solve randomly generated blocks world problems involving blocks 
particular value generated random initial configuration blocks asked planner transform configuration randomly generated goal configuration 
graph shows time taken planner employed breadth search final control strategy time taken blind breadth search 
blind breath outperforms blind depth search domain 
data shows control information acts incrementally add clauses control formula planner able search efficiently pruning paths search space 
shows just effective search control tlplan able solve blocks problems minutes depth search control strategy compare performance state art planners shown fig 

data generated breadth search represent time find optimal plans 
data shows control strategies considerable aid solving optimization problem 
control tlplan able generate optimal plans block problems reasonable time seconds average control optimal block problems limit blocks take seconds 
generating optimal plans blocks world known np hard control strategies insufficient generating optimal solutions blocks problems 
control strategy eliminate optimal plans search space optimal plan satisfies control strategy strategy planner finding optimal plans 
easy show optimal plan eliminated blocks world control strategies 
blocks world depth search find solution solution may long 
shows length plan planner different control strategies 
control generates identical plans control takes longer 
data shows plans generated control quite high quality plans measuring quality plan length 
slightly longer optimal length plans 
fact show plans generated control control longer times length optimal plan 
furthermore tlplan able generate plans strategies backtracking 
control strategies yield polynomial time blocks world planner reasonable plan quality guarantee 
blocks world remains difficult domain current domain independent planners 
shows range planning systems perform blocks world 
briefcase world briefcase world simple domain invented pednault illustrate adl action representation 
domain briefcase moved different locations 
objects put taken briefcase briefcase moved 
simple intuitive search control formula written domain 
interesting ideas search control appear unchanged popular test domain logistics domain see 
meta level strategies applicable different domains slightly different concrete realizations 
operators domain table 
def adl operator move briefcase def adl operator put pre pre briefcase loc briefcase loc location loc briefcase add briefcase briefcase del briefcase add briefcase forall briefcase def strips operator take add pre briefcase del del briefcase table briefcase world operators 
operators tlplan input language basically order logic written lisp syntax 
types operators accepted standard strips operators adl blocks world state reachable state cycle free depth path eventually reach goal 
control encodes strategy similar reactive strategy selman proves reactive strategy exceeds optimal factor 
seconds cpu time control fails problem size control breadth control control control control breadth number blocks performance tlplan search control blocks world plan length control generates long plans note log scale control generates near optimal plans control breadth blackbox ipp generate optimal plans domain control control control breadth number blocks length plans generated tlplan blocks world seconds cpu time satplan fails problems size ucpop fails problems size blackbox fails problem size ipp ucpop satplan blackbox ipp fails problems size exceeds gb ram problems size number blocks performance planners blocks world operators 
consists sequence clauses 
clause name operator may contain variables take operator 
briefcase specified simple strips style operator precondition add delete list 
list atomic predicates 
operators move briefcase put specified adl style operators 
adl operators specified precondition clause acts exactly quantifier clause 
particular variables clause specified quantifiers 
quantification bounded quantification specify quantifier bound variables 
example put operator loc ranges locations briefcase fact location ranges objects location 
note scoped loc 
binding loc compute distinct range bindings variable bindings precondition include additional formula test variable bindings required features current world 
note formula arbitrary order formula may include disjunction quantifiers example operator put includes formula briefcase briefcase 
binding precondition variables satisfies precondition formula generates unique instance operator operator instance called action 
bindings variables appearing operator name give action unique name 
subsequent precondition formula come sequence clauses 
clauses scoped precondition variables may access bindings individually evaluated formula evaluator see section 
evaluation add del clause evaluates true side effect modifying new world 
current state world manner evaluator works rules early termination formula evaluation precisely specifies set adds deletes generated instance operator 
move briefcase action add briefcase new location delete old location 
universal quantifier successively bind objects currently briefcase 
binding body universal evaluated 
body universal conjunction evaluate add 
terms add clause evaluated case variables evaluate objects currently bound see table 
results ground atomic fact added world database 
add clause evaluates true evaluator moves evaluate second conjunct delete 
variables tlplan prefixed 
planning systems accept adl specified actions ucpop ipp accept restricted subset adl specification 
example disjunctive preconditions usually allowed 
operator instance need unique name 
useful treat different instances action 
tlplan internally reorders adds deletes deletes executed prior adds 
predicates functions appear inside add delete described symbols directly updated 
result update locations briefcase objects briefcase 
search control formulas domain easy write 
embody obvious ideas 
don move briefcase current location object needs taken put briefcase 

don take object briefcase briefcase object goal location 

don put objects don need moved briefcase 

don move briefcase irrelevant location 
domain location irrelevant object picked object briefcase needs dropped goal move briefcase location 
control formula table realizes rules 
give formula exactly input planner 
planner take control input formula differences prefix lisp syntax logical symbols modalities text names universal quantifier specified 
performance tlplan control rule demonstrated table 
table shows planning time seconds required tlplan ipp solve suite problems taken ipp distribution 
briefcase world requires adl actions solved current version blackbox ucpop handle adl actions performance far worse ipp 
suite problems includes standard problem briefcase dictionary home briefcase want take dictionary office briefcase leave home ti problems involve picking objects different locations home exi problems involve permuting locations objects 
tlplan faster problems 
fact difficult tlplan 
ipp unable solve number larger problems 
entries values indicate ipp aborted seconds cpu time having plan 
logistics world popular test domain logistics world 
domain types vehicles trucks airplanes 
trucks transport goods city airplanes transport goods airports 
problems domain typically start collection objects various locations various cities goal redistribute objects new locations 
object new location city transported solely truck 
new location different city transported truck city airport plane new city truck final location new city 
forall briefcase forall implies briefcase 
implies goal briefcase briefcase 
implies goal briefcase briefcase 
implies briefcase goal briefcase 
implies goal briefcase briefcase forall location 
implies location briefcase don need deliver briefcase exists briefcase goal don need pickup location exists exists gl goal gl gl goal briefcase don need move briefcase goal briefcase don go briefcase table briefcase world control strategy 
problem name tlplan time ipp time cpu seconds cpu seconds ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex max ex ex ex ex ex ex ex table performance tlplan ipp briefcase world operators domain table 
encoded domain simply find easier write strips operators 
operators written standard strips operators simple preconditions modify function values conditional effects 
compressed load unload operators single case defined predicate tells object vehicle truck airplane 
standard strips encoding truck unload truck load plan plane 
apparent search space identical instance operators executable vehicle bound truck equivalent instance aload truck operator executable 
planners ran supplied standard strips encoding 
control strategy similar briefcase world applicable logistics world fact domains involve transporting goods meta level principles appear 
particular write control strategy embodies ideas 
don move vehicle object current location needs loaded 
similarly don move vehicle object needs unloaded current location 

don move vehicle location location want vehicle goal object location needs picked kind vehicle object vehicle needs unloaded location 

don load object vehicle needs moved type vehicle 

don unload object vehicle needs unloaded location 
types vehicles distinct purpose 
helpful define collection auxiliary predicates 
def defined predicate wrong city obj curr loc goal loc true iff object curr loc goal location goal loc right city 
loc loc city true loc located city city 
exists city loc curr loc city loc goal loc city def defined predicate need move truck obj curr loc need move object located curr loc truck iff object wrong city airport object right city right location 
note goal location don need move truck 
logical connective simply short hand implies implies 
def defined predicate vehicle vehicle truck vehicle airplane vehicle def adl operator load obj vehicle loc pre obj loc obj loc vehicle vehicle loc vehicle vehicle object obj add obj vehicle del obj loc def adl operator unload obj vehicle loc pre obj vehicle obj vehicle loc vehicle loc add obj loc del obj vehicle def adl operator drive truck truck allow trucks move city 
pre truck truck truck truck city loc city loc city add truck del truck def adl operator fly airplane plane airplanes may fly airport airport 
pre plane airplane plane plane airport add plane del plane table logistics world operators exists goal loc goal obj goal loc wrong city obj curr loc goal loc airport curr loc right city curr loc goal loc def defined predicate need unload truck obj curr loc need unload object truck current location iff curr loc goal location object object wrong city current location airport 
exists goal loc goal obj goal loc curr loc goal loc wrong city obj curr loc goal loc airport curr loc def defined predicate need move airplane obj curr loc need move object curr loc airplane iff object wrong city 
exists goal loc goal obj goal loc wrong city obj curr loc goal loc def defined predicate need unload airplane obj curr loc need unload object airplane current location iff curr loc right city 
exists goal loc goal obj goal loc wrong city obj curr loc goal loc predicates define control strategy realizes rules 
forall loc loc implies vehicle don move vehicle object needs moved object needs unloaded current location 
implies exists obj object obj obj loc implies truck need move truck obj loc implies airplane need move airplane obj loc obj implies truck need unload truck obj loc implies airplane need unload airplane obj loc loc similarly move vehicle conditions meet 
exists newloc newloc location vehicle didn move 
newloc loc location goal location vehicle goal newloc object exists obj object obj object new location needs pickup 
obj newloc implies truck need move truck obj newloc implies airplane need move airplane obj newloc object vehicle needs unloaded obj implies truck need unload truck obj newloc implies airplane need unload airplane obj newloc implies object don load vehicle need move type vehicle 
forall truck truck truck implies need move truck loc truck forall plane airplane plane implies need move airplane loc plane don unload objects need 
forall obj vehicle obj vehicle exists loc vehicle loc implies truck vehicle need unload truck obj loc airplane vehicle need unload airplane obj loc obj vehicle control rule obtain performance shown 
data shows planner solving problems objects moved plotted axis 
initial state place objects city different cities truck city locations city post office airport airplanes 
final locations objects chosen random different locations 
data point shows average time require solve random problems size 
shows planners perform domain 
seen control strategy gives tlplan multiple order magnitude improvement performance planners 
blackbox performance hindered fact machine ram significantly slower tlplan smaller problems prior onset thrashing 
timing routines fairly job accounting just cpu time taken time taken program waiting page swapped counted check significant bias ran suite problems come blackbox distribution 
blackbox solutions problems come distribution generated machine slightly faster machines experiments judging solution times smaller problems blackbox thrashing significantly gb ram 
table shows tlplan performance test suite run mb machine 
tlplan difficulty completing larger problems mb ram 
results show memory bottleneck significant factor experiments tlplan control strategy remains significantly faster blackbox 
compares total number actions plans generated planners 
see tlplan generating plans planners 
planners search plan incrementally looking shorter plans 
expect generating relatively short plans 
tlplan employs strategy 
simply depth search 
control strategy stops stupid moves included plan 
similar results seen table tlplan generating shorter plans blackbox 
tire world tire world standard test domain due originally russell 
domain general task change flat tire sequence actions involving wheel loosening tightening nuts branching factor domain large forward direction different operators 
wrote control strategy domain included ideas 
fetch object container need 
rule involved defining predicates determine needs wrench jack pump 
number rules deal wheels nuts don inflate wheel needs inflated 
blackbox employs stochastic search plan constructed graphplan graph time steps 
plan time steps exist fail find stochastic search runs time 
seconds cpu time ipp fails problems size satplan fails problems size blackbox fails problems size tlplan blackbox satplan ipp number packages performance various planners logistics world problem tlplan blackbox tlplan blackbox time time length length log log log log log log log log log log log log log log log log log log log log log log log log log log log log log log table performance tlplan blackbox logistics problems plan length blackbox generates longer plans ipp generates shorter plans tlplan blackbox ipp number packages length plans generated logistics world don jack wheel needs 
keep correctly placed wheels current hubs don place wheel incorrect hub 
wheel needs removed hub don undo removal steps 
keep hub wheel nuts tight 
execute actions putting wheels hubs removing hubs particular order 

open containers contain need 

don put away objects don need anymore 

keep containers open removed need needs stored returned 
rules fairly intuitive encoding formulas straightforward albeit lengthy 
control strategy obtain performance shown 
designed suite test problems involved changing increasing number tires set tools 
data shows planner solving problems goal literals plotted axis 
increases need increase number tires order generate different goal literals 
data point shows time required solve problem size 
final problem involved changing tires 
data shows performance ipp blackbox planners problems 
generating plans depth search compare length generated plans 
data shows tlplan able achieve exceptional performance appropriate control strategy 
schedule world schedule world involves scheduling set objects various machines order achieve various effects shaping object painting polishing operations undo effects operations operations impossible 
domain operators number objects climbs branching factor forward direction 
worth noting domain actions inherently concurrent 
machine run parallel 
problem tlplan explores linear sequences actions 
particular sequence worlds explore structure choose linear sequence worlds need correspond linear sequence times domain modeled 
domain added time stamp world time stamp denotes current time partial schedule 
actions generate new worlds scheduling currently unscheduled objects currently unscheduled machines object machine marked scheduled current time step 
scheduling actions possible desirable action increment time stamp 
effect making objects machines available scheduling new current time step 
words tlplan explores sequence worlds sequence scheduling actions schedule concurrent set operations followed time step followed sequence scheduling actions schedule set concurrent operations 
types concurrent actions modeled manner implemented jobshop scheduling domain solves standard job shop scheduling problems tlplan 
common versions domain simplified appeared ucpop distribution 
ucpop version discarded notion time simply computes operations need run objects 
original version appeared prodigy distribution involves non trivial time 
coded prodigy version tests tlplan ipp ran version experiments 
seconds cpu time ipp takes seconds problem size tlplan ipp blackbox blackbox runs memory problems larger size number goal literals performance tlplan planners tire world plan length blackbox generates considerably longer plans tlplan ipp blackbox number object features length plans generated tire world performance tlplan shown 
data shows planner solving problems objects randomly chosen properties involving objects achieved single object randomly selected require property 
forms axis 
data point represents average time required solve random problems size 
graph shows performance ipp domain 
domain requires adl actions unable run blackbox test 
control strategy tlplan included ideas 
schedule operation twice 
particularly simple scheduling domain need perform operation twice better plan operations sequenced manner needed effects undone 

scheduled operations achieve goal 

goal condition achieved allow destroyed 
domain need undo achieved goals 

ordering constraints goal achievements rolling object cylindrical destroys number things rolling object temperature goes 
prohibit rolling conditions goal 
shaping operations prior surface conditioning operations destroy surface condition 
grinding prior painting destroy paint 
shows average number actions plans generated different planners 
see search control allows tlplan construct plans depth search 
case tlplan able generate slightly shorter plans ipp 
ipp employs deterministic search plan step graphplan graph find plan shortest graphplan parallel length 
plan finds include redundant actions long redundant actions executed parallel 
similar manner plans tlplan need shortest parallel length 
plan length best rough estimate plan quality 
bounded blocks world interesting problem bounded blocks world table limited amount space 
easy specify plan bounded blocks world tlplan 
graphplan graphs handle limited kind action concurrency shortest graphplan parallel length need shortest parallel length 
seconds cpu time tlplan ipp ipp takes average sec 
problems size number object features performance tlplan ipp schedule world plan length tlplan generates slightly shorter plans tlplan ipp number object features length plans generated schedule world standard domain independent planners deal effectively resource constraints simple ones 
domain easier single operator simply moves blocks location avoiding intermediate holding block state blocks world specification section 
table gives domain operator 
case operator def adl operator pre clear clear don put back came put block table move table implies table move table table space table space 
add del implies table add table space table space implies table add table space table space implies table del clear implies table add clear table bounded blocks world operators precondition quite simple move object new location move table move table space table 
domain table space ary described function specified initial state properly updated operator 
term table space evaluates quantity space table current world table space means space blocks table precondition simply tests ensure space table intend moving gives example tlplan ability handle functions 
particular adding equality predicate add table space table space specifying function table space new value current value minus 
terms inside add deletes evaluated current world prior committed 
evaluator computes value term table space looking current value table space subtracting standard computed function 
htn style planners facilities dealing resource constraints 
conditional updates specified implies 
particular evaluator evaluation formulas consequent implication case adds deletes executed antecedent evaluates false 
illustrates performance tlplan domain 
data point represents average time taken solve randomly generated bounded blocks problems spaces table 
data shows domain standard blocks world hard domain specific search control 
different control strategies easily specified domain 
meta level notion continues useful modified version blocks world 
slightly different realization 
particular may need tower blocks free space table 
define appropriately modified version follows def defined predicate note takes account table space 
particular occupy needed 
clear table table space table space 
def defined predicate table goal table table exists goal forall goal table table exists goal table goal clear forall goal forall goal version classify table stacked space 
main difference lies block table needs table need blocks table 
cases goal achieved moving block table 
recursive case just standard section 
define predicate def defined predicate move final move final location final location location final location 
cpu time sec 
control control control number blocks search control bounded blocks world clear exists goal predicate true block moved final location 
move final define simple control strategy define control simple trigger control 
destroy 
forall clear implies table block exists moved immediately move 
implies exists clear move final exists clear move final control strategy simple trigger control 
state block moved final location 
note multiple blocks moved final location trigger existential condition remain active moved 
choice block move non deterministic 
strategy involves obvious towers don need 
shows trigger control quite effective small problems serves illustrate fact considerable gain achieved minor effort 
trigger control knows finds certain fortuitous situations idea achieve fortuitous situations 
increase size problems useful 
complete strategy written 
strategy complex able solve problems quite effectively requiring backtracking 
idea quite simple 
strategy components 
taken previous strategy 



blocks moved final positions pick block move final position 
course implementation picks blocks particular order 

locations exists stacked waiting block pick location clear block intended go keeping location clear 
block clear back situation previous rule applies block moved final location 

clear locations stacked pick location clear 
achieved situation rule applies 
facilitate implementation strategy definitions def defined predicate stack block ready stacked 
exists goal def defined function depth return depth location clear depth exists depth depth function find location stack location clear 
def defined function find stack clear pick table possible table space exists goal table table return table find stack clear table return top prefix exists table exists top tower incomplete 
exists goal find stack clear clause fails stackable location exists 
find stack clear def defined function top pass function block block examine tower block looking top longest tower 
clear clear top prefix 
top block exists goal table goal clear forall goal forall goal block top violate goal relations recurse upwards 
top top 
top predicate stack true location location ready stacked implement rule strategy 
function depth explained 
stack clear function returns location cleared stacked implement rule strategy 
function checks see table location tower blocks started build returns possible 
employs recursive function top find top block partly completed 
clear top block location stacked 
thing notice stack clear functional binding existential variable line exists top line specifies variable range set objects equal top course object computed evaluating function bound point 
definitions second strategy specified follows define control complex control 
destroy 
forall clear implies table exists 
immediate moves implies immediate move 
exists clear move final pick 
exists clear move final 
clear block 
stackable location including table exists clear stack progress uncovering block location 
asserting block relation achieve decrease depth uncover keeping clear 
exists clear stack need pick block clear table block exists goal stack keep clear exists depth decrease depth depth constraint active achieve 
completed pick location clear stack location clear 
include table 
exists loc loc find stack clear loc exists loc implies loc table exists depth stack loc depth stack loc specification fairly straightforward translation components mentioned 
similar clauses strategy second exists depth stack loc depth stack loc loc 
clause asserts condition true state reach state stack loc 
intent force planner uncover reach state clear loc move 
formula bit cumbersome fact loc table simply force decrease depth loc depth apply table 
uncovering accomplished asserting state prior state stack loc depth decreases 
thing careful reach state clear depth decrease state 
state remove loc 
disjunction condition 
example shows approach represent wide range control strategies 
previous examples control strategies expressed obvious myopic information bad various situations 
control strategy migrating domain specific program specifying loose manner entire sequence activities 
couple points complex strategies 
data shows simple strategies trigger strategy offer tremendous improvement 
simple strategies sufficient solve size problems faced 
second pragmatic point view reason planner able take advantage detailed domain specific strategy available 
writing control knowledge key issue raised approach obtaining appropriate control knowledge 
examples previous section demonstrate appropriate knowledge obtain tremendous performance gains 
example domains require quite lengthy control formulas 
question arises just easy practical write required control knowledge 
provide definitive answers question wider base users domains examined 
number reasons believing approach practical 
ultimately course develop mechanisms automatically generating appropriate control knowledge 
research various learning mechanisms techniques static domain analysis ongoing 
research currently preliminary system requires user write control knowledge question easy remains 
compelling evidence anecdotal evidence student projects 
university waterloo tlplan system undergraduate ai course number years 
course taught th year undergraduates generally course ai 
part course evaluation involves project students implement planning system domain tlplan system 
quite impressive array different domains implemented students successful writing effective search control knowledge formalism 
example implementation car pool planner developed 
domain allows specify number locations providing coordinates people cars car capacities 
operators driving car loading unloading passengers deadlines people arrival times possibility dropping passengers near locations walk 
control formulas written student included failure detection rules terminate plan prefix deadline missed rules car driven useless locations performing pickup dropoff location driven 
control knowledge planner able generate plans involving steps seconds 
importantly control knowledge effective pruning away worlds generated search 
second piece evidence comes fact domains implemented reflected student projects considerable reuse control knowledge 
example transportation style domain car pooling domain example transportation style domain control ideas developed logistics domain moving vehicles irrelevant location doing necessary actions location prior moving reused 
similarly idea preserving condition wasteful destroy quite common domains blocksworld towers preserved tire domain want preserve having various tools longer required 
words various widely applicable meta control principles exist 
categorizing formalizing principles interesting topic research 
piece evidence supply fact approach supports powerful incremental style development 
particular easy modify control formula run planner determine difference performance 
control formula compositional semantics changes quite modular 
example add new conjunct new conjunct alter pruning achieved previous components formula 
manner examine state sequences searched planner determine sequences doing avoided modify control formula eliminate behavior 
incremental improvement stopped time planner works problem sizes contemplated 
shown previous section simple control formulas yield dramatic improvements 
approaches utilizing domain information means suggest domain specific information planning 
longest traditions ai planning htn planning done formalizing ideas htn planning 
htn planning requires specifying information planning domain classical planning 
particular addition primitive operators planner collection tasks task decompositions 
tasks identify common sub plans domain decompositions describe various ways sub plans solved 
working top level task primitive actions htn planners avoid large parts search space 
particular explore primitive action sequences arise sequence task decompositions 
hierarchical arrangement yield exponential speed search time 
specified task decompositions provide planner search control knowledge 
particular decompositions eliminate large number physically feasible primitive action sequences search control formulas 
view htn planners clear barrett weld showed specified task decompositions prune partially ordered plans composed primitive actions 
pruning accomplished parsing algorithm 
language representation htn planners control knowledge quite distinct suggested useful 
pieces control knowledge naturally represented hierarchical decomposition tasks pieces knowledge naturally expressed information bad state sequences formalism 
scope types information interesting topic research examine mechanisms combining types information 
early planning system take issue control information seriously prodigy system 
prodigy employs search control rules act expert system guiding search 
prodigy approach specifying control information main disadvantages 
approach hard 
particular control rules required understand planning algorithm rules algorithmic choices algorithm 
approach simple knowledge domain sufficient write control rules 
second control rules give speed ups speed ups great search control prodigy remains relatively slow planner 
blocksworld illustrates difficulties 
prodigy employed rules blocks world 
example rules control rule select bindings unstack clear current goal clear current ops unstack true state select bindings ob rule says planner currently working goal clearing block current state currently considering regressing goal unstack operator select specific binding unstack operator 
binding rules require user understand planner utilizes bindings planning search 
notion binding domain planning algorithm 
example rule control rule arm empty candidate goal arm empty true state holding select goal arm empty rule says planner considering goal having robot hand empty true current state holding block commit working goal hand empty 
rule requires user know difference candidate goal current goal difference affect planner operation 
rules prodigy unable solve random blocksworld problems involved blocks failed solve problems involving blocks 
hand prodigy rules designed learned automatically transparency critical issue 
current learning algorithms reached stage generate truly effective control rules 
leaves user system choice attempt construct control rules hand indicated difficult task 
lot innovative learning reasoning planning domains come prodigy project performance scale demonstrated approach achieved 
utilizing domain dependent control knowledge srivastava kambhampati kautz selman 
srivastava kambhampati scheme domain specific information similar tlplan information input complex program synthesis system 
result semiautomatically constructed planning system customized domain 
example logistics domain domain specific information utilize includes 
planes consecutive flights loading unloading package 

package reaches goal location moved 
reader recognize rules part domain information encoded tlplan 
fact tlplan representation general allowed srivastava kambhampati domain specific information mentioned easily encoded logic tlplan utilizes 
tlplan approach requires complex program synthesis step information customized planner synthesized 
tlplan control information simply part planner input 
furthermore empirical results show performance orders magnitude inferior tlplan 
example customized planners took minute solve standard tire problem package logistics problem block problem 
tlplan takes seconds solve tire problem seconds average solve package logistics problems seconds average solve block problems 
methods developed synthesizing customized planners demonstrate interesting alternative approach utilizing domain specific information 
kautz selman investigated domain specific information satplan paradigm 
adopted approach domain information logically represented independent planner operation 
specifically represent extra domain knowledge additional propositional clauses noticed state representation promising exploiting knowledge 
results preliminary show promise 
particular show speedups possible attain speed competitive tlplan performance 
major hurdle approach faces scaled size problems tlplan handle size propositional theories generates 
effective ways need dealing theories size incrementally simplifying theories smaller theories generated 
example experiments logistics problems packages generated theories containing clauses variables 
theories size polynomial time processing takes considerable amount time 
rich representation domain specific control knowledge shown knowledge utilized ai planning system planning efficient 
empirical evidence indicates information available domains information reach new level planning performance 
believe size problems tlplan solve approached 
success approach natural pressing question control information come 
taken pragmatic approach assumed come user just forms knowledge user needs specify developing planning domain 
empirical studies show unreasonable approach form control knowledge usually available 
equally clear knowledge form domains similar meta level strategies 
furthermore clear knowledge automatically derived operator descriptions conjunction initial state 
important area research employ learning reasoning techniques automatically generate domain specific knowledge 
considerable body built area 
mcdermott bonet viewed light 
works search heuristics computed dynamically search 
heuristics try estimate search making progress goal 
potentially similar ideas line construction search control formulas provide effect obtain goal modality 
area done develop ways temporal logic developed utilized control kinds planning algorithms 
relatively easy convert temporal logic expressions propositional logic fixed initial goal state find ways representation satplan approaches 
actively working methods extending approach classical planning 
basic system handles resources empirical test effective domains heavy resource reasoning 
extended approach generate plans satisfy temporally extended goals 
goals generalize safety maintenance goals mentioned 
developed strips database approach planning sensing incomplete knowledge 
plan combine search control construct planner capable planning sensing incomplete knowledge 
line material tlplan planning system test suites raw data collected experiments available web site www uwaterloo ca 
aips 
artificial intelligence planning systems planning competition 
ftp cs yale edu pub mcdermott results html 
fahiem bacchus kabanza 
planning temporally extended goals 
proceedings aaai national conference pages 
fahiem bacchus kabanza 
temporal logic control search forward chaining planner 
ghallab editors new directions ai planning pages 
iso press amsterdam 
fahiem bacchus kabanza 
planning temporally extended goals 
mathematics artificial intelligence 
fahiem bacchus ron 
modeling agent incomplete knowledge planning execution 
proceedings international conference principles knowledge representation reasoning pages 
kabanza st denis 
synthesizing plant controllers real time goals 
international joint conference artifical intelligence ijcai pages 
barrett golden penberthy weld 
ucpop user manual version 
technical report tr university washington department computer science engineering ftp cs washington edu pub ai 
barrett weld 
task decomposition plan parsing 
proceedings aaai national conference pages 
barrett weld 
partial order planning evaluating possible efficiency gains 
artificial intelligence 
bauer koehler integrated plan generation recognition logic approach 
technical report rr dfki 
stephan 
modeling planning domains systematically 
proceedings european conference artificial intelligence pages 
wiley sons 
stephan 
system assistance structured domain model development 
international joint conference artifical intelligence ijcai pages 
morgan kaufmann 
avrim blum furst 
fast planning planning graph analysis 
artificial intelligence 
bonet geffner 
robust fast action selection mechanism planning 
proceedings aaai national conference pages 
craig boutilier richard dearden 
abstractions decision theoretic planning time constraints 
proceedings aaai national conference pages 
carbonell blythe etzioni gill joseph khan knoblock minton rez reilly veloso wang 
prodigy manual 
technical report cmu cs school computer science carnegie mellon university 
ken currie austin tate 
plan open planning architecture 
artificial intelligence 
dean kaelbling nicholson 
planning deadlines stochastic domains 
proceedings aaai national conference pages 
emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume chapter pages 
mit 
erol nau subrahmanian 
complexity domain independent planning 
proceedings aaai national conference pages 
erol 
hierarchical task network planning formalization analysis implementation 
phd thesis university maryland 
oren etzioni 
acquiring search control knowledge static analysis 
artificial intelligence 

quantification modal logic 
gabbay guenthner editors handbook philosophical logic vol 
ii pages 
reidel dordrecht netherlands 
gerevini schubert 
accelerating partial order planners techniques effective search control pruning 
journal artificial intelligence research 
green 
application theorem proving problem solving 
international joint conference artifical intelligence ijcai pages 
gupta nau 
complexity blocks world planning 
artificial intelligence 
halpern vardi 
model checking vs theorem proving manifesto 
allen fikes sandewall editors proceedings international conference principles knowledge representation reasoning pages 
morgan kaufmann san mateo california san mateo ca 
matthew hennessy 
semantics programming languages elementary structural operational semantics 
wiley 
johnson 
catalog complexity classes 
van leeuwen editor handbook theoretical computer science volume chapter pages 
mit 
joslin pollack 
cost flaw repair plan refinement strategy planning 
proceedings aaai national conference pages 
morgan kaufmann san mateo california 
paris kanellakis 
elements relational database theory 
van leeuwen editor handbook theoretical computer science volume ii pages 
elsevier science publishers 
henry kautz bart selman 
pushing envelope planning propositional logic stochastic search 
proceedings aaai national conference pages 
henry kautz bart selman 
blackbox new approach application theorem proving problem solving 
system available www research att com kautz 
henry kautz bart selman 
role domain specific knowledge planning satisfiability framework 
proceedings international conference artificial intelligence planning pages 
kibler morris 
don stupid 
international joint conference artifical intelligence ijcai pages 
craig knoblock 
automatically generating abstractions planning 
artificial intelligence 
koehler nebel hoffmann dimopoulos 
extending planning graphs adl subset 
european conference planning pages 
system available www informatik uni freiburg de koehler ipp html 
laird newell rosenbloom 
soar architecture general intelligence 
artificial intelligence 
zohar manna amir pnueli 
temporal logic reactive concurrent systems specication 
springer verlag new york 
mcdermott 
heuristic estimator means analysis planning 
proceedings third international conference planning systems 
minton bresina drummond 
total order partial order planning comparative analysis 
journal artificial intelligence research 
steve minton 
learning search control knowledge 
kluwer academic publishers 
parekh 
study procedural search control simon 
www cs washington edu homes quals ps 
pednault 
adl exploring middle ground strips situation calculus 
proceedings international conference principles knowledge representation reasoning pages 
poet smith 
threat removal strategies partial order planning 
proceedings aaai national conference pages 
stanley 
plan synthesis logical perspective 
international joint conference artifical intelligence ijcai pages 
russell norvig 
artificial intelligence modern approach 
prentice hall 
earl sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
selman 
near optimal plans tractability reactivity 
proceedings international conference principles knowledge representation reasoning pages 
sistla 
safety liveness fairness temporal logic 
formal aspects computing 
sistla clarke 
complexity propositional linear temporal logic 
journal acm 
srivastava kambhampati 
synthesizing customized planners specifications 
journal artificial intelligence research 
stephan 
deduction refinement planning 
proceedings international conference artificial intelligence planning pages 
aaai press 
jonathan stuart russell 
control strategies stochastic planner 
proceedings aaai national conference pages seattle 
austin tate 
generating project networks 
international joint conference artifical intelligence ijcai pages 
chris thompson 

undergraduate project cs university waterloo 
vardi 
complexity relational query 
proc 
th ann 
acm symp 
theory computing pages 
vardi 
computational model theory overview 
logic journal igpl 
veloso carbonell rez borrajo fink blythe 
integrating planning learning prodigy architecture 
journal experimental theoretical artificial intelligence 
daniel weld oren etzioni 
law robotics call arms 
proceedings aaai national conference pages 
daniel weld 
commitment planning 
ai magazine 
david wilkins 
practical planning extending classical ai planning paradigm 
morgan kaufmann san mateo california 

