polymetric views lightweight visual approach reverse engineering michele lanza st phane ducasse preprint transactions software engineering journal reverse engineering software systems major concern software industry sheer size complexity 
problem needs tackled systems question considerable worth owners maintainers 
article concept polymetric view lightweight software visualization technique enriched software metrics information 
polymetric views help understand structure detect problems software system initial phases reverse engineering process 
discuss benefits limits predefined polymetric views implemented tool codecrawler 
clusters different polymetric views developed methodology supports guides software engineer phases reverse engineering large software system 
refined methodology repeatedly applying industrial systems illustrate applying selection polymetric views case study 
keywords reverse engineering object oriented programming software visualization software metrics reverse engineering large software systems difficult due sheer size complexity 
prerequisite maintenance reengineering evolution 
chikofsky defines reverse engineering process analyzing subject system identify system components relationships create representations system form higher level abstraction 
maintaining evolving existing software systems difficult reasons accelerating turnover developers increasing size complexity software systems constantly changing requirements software systems 
legacy systems large mature complex software systems result long term investment effort maintained evolved new requirements fulfilled investment pay back 
parnas assessed legacy systems suffer typical problems including original developers may longer available outdated development methods programming languages outdated incomplete missing documentation 
maintenance evolution systems apart technically difficult prohibitively expensive sommerville davis estimate cost software maintenance accounts cost software system 
rewriting systems scratch problematic take vast amounts time money human resources 
legacy systems tend large hundreds thousands lines poorly documented code exception definite need effective approaches help program understanding problem detection 
focus object oriented legacy systems mainly current systems written paradigm age turns piece software legacy system rate developed adapted 
object oriented paradigm support sequential reading order domain model distributed classes hierarchies subsystems reverse engineer needs know look system understand structure 
michele lanza st phane ducasse members software composition group university bern switzerland 
michele lanza corresponding author 
contact information michele lanza michele lanza institut informatik und angewandte mathematik bern switzerland 
mail lanza iam unibe ch 
tel 
fax 
contact information st phane ducasse st phane ducasse institut informatik und angewandte mathematik bern switzerland 
mail ducasse iam unibe ch 
tel 
fax 
targeting phase week reverse engineering process phase reverse engineer form initial mental picture system 
approach helps reverse engineer get mental picture viewing system means polymetric views lightweight software visualizations enriched software metrics 
software visualization context visual displays allow human brain study multiple aspects complex problems reverse engineering parallel 
ware states visualization provides ability comprehend huge amounts data 
software visualizations simplistic lack visual cues viewer correctly interpret 
cases obtained visualizations complex real value viewer 
software metrics assess quality complexity system known scale 
furthermore metrics means control quality state software system development process 
metrics come huge tables hard interpret difficult metrics combined generate metrics 
propose lightweight approach combination software visualization software metrics enriching simple visualizations metrics information 
refer lightweight combinations polymetric views 
depending applied polymetric view viewer visually looking interacting visualization extract different kinds information visualized system information structure hierarchies size classes methods attributes viewer verify findings inspecting corresponding source code fragments program cognition model vocabulary proposed littman support approach understanding opportunistic sense systematic line line understanding needed 
note opportunistic code reading useful forward engineering context context approach helps code browsing goes scope part current research 
article describe polymetric views detail point idea strengths weaknesses view 
guide reverse engineer phases weeks depending size system reverse engineering process developed methodology polymetric views extended refined applying repeatedly industrial case studies 
ii 
object oriented reverse engineering chikofsky states primary purpose reverse engineering software system increase comprehensibility system maintenance new development 
starting reverse engineering process essential decide primary goals pursuit ones secondary importance 
context object oriented legacy systems settled goals getting impression mental model system assess quality system gain overview system terms size complexity structure 
locate understand important classes inheritance hierarchies find classes hierarchies represent core part system domain understand structure terms implementation purpose terms functionality 
identify exceptional classes terms size complexity compared classes subject system 
may candidates inspection application refactorings 
identify possible presence design patterns occasions design patterns introduced ameliorate system structure 
result reverse engineering process list problematic classes subsystems identification possible design defects valuable piece information 
looking bad object oriented design obtaining information system implemented important independently quality implementation 
reengineering context fact class may design problem necessarily imply class modified completely redesigned cost time money 
badly designed class methods inconsistent accessors dead code subsystem accomplishes assigned having negative impact working system point changing 
aware information valuable getting better mental model system 
developed approach context european esprit project main results summarized reengineering handbook basis book object oriented reengineering patterns 
goal project reengineer large industrial object oriented software systems 
industrial setting project introduced constraints simplicity 
software industry face problems short time constraints little tool support limited manpower 
reason wanted results software engineers workplace having rely complex expensive tools 
choosing lightweight approach able get results quickly order evaluate certain ideas viable 
scalability 
wanted sure approach handle size industrial systems millions lines code 
scalability hand guaranteed software metrics metrics computed independently size system 
hand approach allowed generate test accept reject new ideas short iteration cycles 
starting development tools constantly tested industrial settings see viable scale 
language independence 
order handle software systems written different languages developed famix language independent metamodel 
implementation smalltalk famix metamodel called moose reengineering environment detail section vi 
principle iii 
approach visualization tool codecrawler uses dimensional displays visualize object oriented software 
nodes represent software entities abstractions edges represent relationships entities 
widely practice information visualization software visualization tools 
ware claims possible graphical notations showing connectivity far effective 
enrich basic visualization method rendering metric measurements single node simultaneously see 
list metrics enrich visualizations table node size 
width height node render metric measurement 
bigger measurements bigger node dimensions 
node color 
color interval white black render metric measurement 
convention higher metric value darker node light gray represents smaller metric measurement dark gray 
node position 
coordinates position node reflect metrics measurements 
requires presence absolute origin fixed coordinate system 
layouts exploit position metrics implicitly dictate position nodes tree layout 
measurement theory procedure rendering metrics dimensional nodes called measurement mapping fulfills representation condition asserts measurement mapping map entities numbers empirical relations numerical relations way empirical relations preserve preserved numerical relations 
words number bigger number graphical representation preserve fact 
fig 

metrics visualized node 
list possible metrics table system complexity view 
visualization classes uses tree layout 
edges represent inheritance relationships 
metrics enrich view noa number attributes class width nom number methods class height 
color shade represents number lines code class 
software metrics extensive object oriented software metrics 
wide array possible metrics selected design metrics metrics extracted source code entities 
metrics usually assess size cases quality complexity software 
metrics termed direct measurement metrics computation involves attributes entities 
don indirect measurement metrics combined generate new ones measurement mapping previous section works best direct measurements 
examples indirect metrics include programmer productivity defect detection density module defect density code oriented ones cbo rfc 
chose metrics extracted source code entities simple clear definition 
don composite metrics raise issue dimensional consistency 
table see appendix list metrics mentioned article 
actual visualization polymetric view actual visualization software codecrawler depends ingredients layout set metrics set entities 

layout 
layout takes account choice displayed entities relationships issues complete display fit screen space minimized nodes sorted layouts sense purposes better suited special cases tree layout better suited display inheritance hierarchy circle layout 
part lightweight approach chose implement simple layouts advanced powerful techniques interesting context 
layouts described detail appendix article tree scatterplot checker 

metrics 
incorporate metrics selected table view seen section iii 
choice metrics heavily influences resulting visualization interpretation 

entities 
certain views better suited small parts system handle complete large system 
reverse engineer choose parts entities subject system wants visualize 
choices part methodology discussed depth section iv 
example 
shows tree layout nodes enriched metrics information 
nodes represent classes edges represent inheritance relationships 
size nodes reflects number attributes width number methods height classes color tone represents number lines code classes 
position nodes reflect metric measurements case nodes position implicitly tree layout 
see visualized system composed large inheritance hierarchies quite deep standalone classes 
combination tree layout metrics mentioned selection classes nodes inheritance relationships edges yields polymetric view call system complexity view properties described detail section 
interpretation view 
polymetric views symptoms reside purely visual level small dark nodes large nodes nodes certain position 
symptoms provide information subject system support decision process view applied part system reverse engineer 
views lead views may result specific reengineering actions represent logical step detection defects 
example detecting god class defined class grown years responsibilities may lead necessary splitting class 
example long methods analyzed see contain duplicated code split smaller reusable methods interpretation views heuristics mainly come experience authors documented fowler beck 
useful views 
note approach allows combine subset metrics table layout algorithm kind software artifacts great number possible views 
similar exchanging width height metrics help reverse engineering process 
identified number useful views polymetric views useful reverse engineering process subset article 
iv 
lightweight visual reverse engineering methodology version methodology extended elaborated version 
ideally methodology defines views apply paths different views parts system view applied 
challenges elaboration methodology unique ideal path views different views applied stage depending current context 
decision certain view time depends interactions currently displayed view 
furthermore views applied different entities implying navigation facilities different views 
view displays system certain perspective emphasizes particular aspect system 
view analyzed code understood determine details revealed view interesting investigation 
views heavily customizable 
instance exchanging metrics easy may yield completely different views 
reverse engineer steer process order apply customize useful views 
loosely grouping polymetric views clusters indicating alternative views navigation possibilities views think challenges overcome 
furthermore views customizable tool offers set predefined views applied directly requiring user define wishes 
identified clusters contact 
thing subject system gain overview 
know big complex system way structured 
views cluster provide answers questions big system composed standalone classes large deep inheritance hierarchies 
system composed small classes really big ones 
system large classes reside 
cluster contains views system hotspots system complexity 
inheritance assessment 
inheritance key aspect object oriented programming languages represents important perspective understand applications 
inheritance different ways example pure addition functionality subclasses extension functionality provided superclasses 
views cluster help analysis inheritance provide answers questions inheritance hierarchies structured inheritance 
subclasses merely adding new functionality redefining functionality defined superclasses 
cluster contains views inheritance classification inheritance carrier 
candidate detection 
primary goals reverse engineer detect candidates may cases investigation necessary code refactorings needed 
views cluster help problem detection process provide answers questions large small classes methods 
methods contain dead code attributes 
cluster contains views data storage class detection method structure correlation direct attribute access 
class internal 
understanding classes key activity object oriented programming classes represent primary abstractions applications built 
main problem task quickly grasp purpose class inner structure 
performed extensive research subject keep certain scope views contained cluster especially class blueprint view 
note views belonging clusters easily applied single classes candidate detection cluster 
reverse engineering scenario reporting case study quite difficult sacrificing exploratory nature approach 
idea different views provide different complementary perspectives software 
consequently concrete reverse engineering strategy apply views specific order exact order vary depending kind system hand kind questions driving reverse engineering effort 
readers read case study report possible case keeping mind reverse engineers customize approach particular reverse engineering project 
facts case study 
system report called duploc version tool detection duplicated code 
done preliminary case study older version duploc curious see duploc evolved 
duploc mature application consisting classes 
duploc detects code duplication means visualization line dot dimensional matrix 
reverse engineering system reverse engineering system non linear procedure difficult sequential text 
reasons simplicity discuss views clusters show application case study put relation methodology section iv depending situations encountered reverse engineering duploc 
system hotspots view description layout checker 
target classes 
scope full system 
metrics width noa 
height nom 
color 
sort width 
example 
simple view helps identify large small classes scales large systems 
relates number methods number attributes class 
nodes sorted identification outliers easy 
symptoms large nodes represent voluminous classes may investigated 
tall nar fig 

system hotspots view variation duploc 
nodes represent classes size nodes represent number methods define 
grey nodes represent metaclasses 
system complexity view duploc 
nodes represent classes edges represent inheritance relationships 
metrics number attributes noa width number methods nom height number lines code color 
inheritance classification view model hierarchy duploc 
width height class nodes represents number added methods number overridden methods color represents number extended methods 
inheritance carrier view hierarchy duploc 
width color class nodes represents number descendants height represents number methods 
row nodes represent classes define methods attributes 
wide nodes classes attributes 
nodes show width height ratio may represent class main purpose data structure implementing accessor methods 
evidence gained color reflects number lines code class 
tall class light color means class contains short methods 
variations lines code number methods nom see rendering width height nodes obtain slightly different view helps assess system terms raw measure big classes big 
case smalltalk classes color metaclasses differently check distribute display 
large colored nodes bottom display may sign metaclasses responsibilities function facades bridges classes 
scenario see duploc classes 
classes bottom row contain methods investigated 
methods methods 
colored nodes representing metaclasses grey 
note bottom grey node metaclass methods 
class suggested name holder global values 
metaclass suggestion developer apply singleton design pattern 
system complexity view description layout tree 
target classes 
scope full system 
metrics width noa 
height nom 
color 
sort 
example 
view inheritance hierarchies subject system gives clues complexity structure 
large systems advisable apply view subsystems takes quite lot screen space 
goal view classify inheritance hierarchies terms functionality represent subject system 
want understand inner working technical level inheritance hierarchies apply views inheritance assessment cluster 
symptoms tall narrow nodes represent classes attributes methods 
nodes appear hierarchy applying inheritance classification view inheritance carrier view helps qualify semantics inheritance relationships classes involved 
deep large hierarchies definitively subsystems views inheritance assessment cluster help refine understanding 
large standalone nodes represent classes attributes methods subclasses 
may worth look internal structure class learn class structured decomposed reorganized 
flat light nodes width height ration represent data storage classes define attributes attribute implement accessor methods 
light color denotes class short methods case accessors 
scenario showing view perform manual preprocessing consists removing class object root class smalltalk language class inherits 
order focus inheritance duploc classes inherit directly object view distorted included view 
see resulting system complexity view 
see duploc fact mainly composed classes organized inheritance hierarchies 
large classes subclasses 
largest inheritance hierarchies levels deep 
noteworthy hierarchies ones root classes 
root class descendants application state design pattern controller part mvc pattern 
complex hierarchy duploc necessary duploc advanced graphical frameworks uses basic standard visualworks gui framework 
track investigation look signs mvc pattern find hierarchy root class descendants constitute view part mvc pattern 
inheritance classification view description layout tree 
target classes 
scope subsystem 
metrics width nma 
height 
color 
sort 
example 
view qualifies inheritance relationships displaying amount added methods relative number overridden extended methods 
extended methods mean methods contain super call method signature defined superclasses 
symptoms flat light nodes represent classes lot methods added methods overridden extended 
case semantic inheritance relationship addition functionality subclasses 
tall possibly darker nodes represent classes lot methods overridden extended 
may represent classes specialized hook methods 
nodes dark means methods extended hints higher degree reuse functionality 
scenario selected hierarchy indicated model hierarchy demonstrate application view 
see model hierarchy mainly composed flat lightly colored nodes classes mainly add functionality denoted width really overriding extending functionality defined superclasses 
see exceptions subclasses widest class nodes added methods define methods overridden extended subclasses 
example subclasses heavily override functionality indicated tall narrow shape override methods add respectively methods 
inheritance carrier view description layout tree 
target classes 
scope subsystem 
metrics width 
height nom 
color 
sort 
example 
view helps detect classes certain impact subclasses terms functionality helps see classes transmit functionality subclasses 
symptoms tall dark nodes represent classes define lot behavior descendants 
classes certain importance sub system question 
flat light nodes represent classes little behavior descendants 
flat dark nodes represent classes little behavior descendants 
ideal place factor code subclasses 
scenario shows view model hierarchy 
shows classes carrying weight implementation hierarchy classes sole subclass 
classes emphasized view darker color 
fig 

data storage class detection view largest classes terms number methods duploc 
color height metrics represents number lines code class width represents number methods 
nodes sorted width 
method structure correlation view duploc 
horizontal position metric lines code vertical metrics number statements 
direct attribute access view variation duploc 
width attribute node represents number direct local accesses defining class 
height node represents number accesses outside class nga color represents number total direct accesses 
nodes sorted color metrics 
data storage class detection view description layout 
target classes 
scope subsystem 
metrics width nom 
height 
color nom 
sort 
example 
view relates number methods nom lines code classes interprets information context subsystem small system 
ideally view return staircase pattern left right nodes sorted metric metrics related 
note view works setting puts values relation doesn matter big actual measurements 
symptoms staircase effect broken nodes tall 
represent classes long methods compared classes comply staircase pattern 
staircase pattern broken nodes short 
classes certain number methods expected length terms lines code 
classes data storage classes classes short simple methods possibly accessor methods 
data storage classes may point sets coupled classes brittle changes 
variations enhance detection data storage classes number attributes noa color metric data storage classes attributes 
scenario see fourth class right short line code compared great number methods indicated position right 
closer inspection see class contains dozens line methods return constant values 
see inverse case tall class left named contains methods total length lines 
class contains methods refactored splitting smaller reusable pieces 
method structure correlation view description layout scatterplot 
target methods 
scope full system 
metrics position loc 
position nos 
sort 
example 
scalable view shows methods scatterplot layout lines code loc number statements nos position metrics 
metrics related line may contain statements display methods align certain correlation axis 
symptoms nodes right display represent long methods investigated candidates split method refactorings 
nodes left top display represent empty methods 
nodes top display necessarily left represent methods containing commented lines possibly dead code 
nodes left bottom display represent methods probably hard read contain statements line 
case check formatting rules application violated 
variations view enriched size metrics 
useful variation number parameters nop size nodes reveals long methods methods input parameters 
scenario see view scales shows nearly duploc methods 
method nodes candidates investigations 
methods longer certain number lines example depending average length methods subject system inspected 
note regard average length smalltalk methods lines 
see methods top display contain statements 
closer inspection see partly due code commented cases dead code partly due long comments written developer explain methods doing 
insight come view general assessment system 
seen methods tend align certain correlation axis 
depending age system axis changes angle methods written corrected time slowly get messy statements lines 
regard duploc considered young system 
direct attribute access view description layout checker 
target attributes 
scope full system 
metrics width 
height 
color 
sort 
example 
view uses number direct accesses width height color attribute node sorts nodes metric 
symptoms small nodes top display represent attributes accessed may point dead code 
large dark nodes bottom point attributes heavily directly accessed may lead problems case internal implementation changes 
nodes check accessor methods defined 
variations size color metric number direct global accesses number accesses accessor methods reveal heavily accessor methods 
size color metric number direct accesses subclasses order reveal coupling aspects classes inheritance hierarchies 
number local accesses class attribute resides width number global accesses nga outside class height 
normally attributes rendered flat possible cases apply deeper inspection useful tall narrow nodes represent attributes heavily accessed outside defining class means direct accesses 
scenario slight variation regular view definition render width height number local respectively number non local accesses color renders total number direct accesses 
see duploc uses considerable number attributes 
top row contains attributes accessed removed 
bottom row contains heavily accessed attributes 
example attribute belonging class directly accessed times 
closer inspection see fact class defines accessor methods consistently may risky 
note tall narrow attribute node bottom view 
attribute heavily accessed directly outside containing class 
case suggest define accessor methods invoke directly accessing attribute 
evaluation case study 
approach provided initial understanding case study helps identify key classes having focus details 
developer duploc confirmed findings surprised obtained results days 
major problems large systems get overview initial understanding getting lost intrinsic complexity 
methodology clusters views helps stay focused different levels understanding want gain 
results obtained case study go scope 
limit draw specific major findings obtained case study general case studies performed 
contact views 
views cluster help get feeling size structure system detail see system major hierarchies composed larger classes located 
case seen duploc composed standalone classes major part duploc dedicated management graphical user interface 
list prominent classes hierarchies system useful get orientation 
especially large case studies cluster views help obtain results quickly 
inheritance assessment views 
views cluster useful easy understanding complex mechanisms related inheritance 
classify inheritance relationships detect important classes large hierarchies 
especially larger hierarchies case study contain cluster views reduce time understand complete inheritance hierarchies 
special case reverse engineered system contained large inheritance hierarchies hundreds classes case root class direct subclasses 
views obtained visualizing hierarchy led coin term flying hierarchy flat shape 
candidate detection views 
views cluster help identify candidates closer examination 
problem candidates number large 
reverse engineer easily produce long lists suspicious code fragments classes methods usefulness approach doubtful software decides parts system want spend time money reengineering 
case duploc developer inspected candidates confirmed findings difficult results detail go scope article 
industrial experiences 
applied approach large industrial applications ranging system approximately lines smalltalk framework approximately classes kloc 
experiments able quickly gain understanding analyzed applications identify problems point classes subsystems investigation 
learned approach preferably applied contact software system provides maximum benefit weeks reverse engineering process 
due agreements industrial partners deliver detailed report experiences 
applied refined reverse engineering methodology tool industrial applications explorative way 
common point experiences subject systems considerable size narrow time constraints maximum days 
led mainly get understanding system structure subsystems important hierarchies purpose produce overviews 
able point potential design problems overly large classes unused classes dead code methods unused attributes medium sized case studies time propose possible system example case suggested inverse order classes hierarchy increase stability introducing template method design pattern resulted considerable reduction complexity hierarchy 
time constraints account case studies lasted days obtained satisfying results 
initially sceptical developers surprised gained overview large systems uncovered design flaws short time 
aware half problems developers saw complete software system working time 
typical result case study report containing presentation polymetric views system list possible problems errors example suspicious classes methods unused attributes developers liked overviews example system complexity view documentation purposes 
list problems design flaws delivered accepted final discussion developers saw keen examining know extent done software companies question protective regarding information 
consider harmful allow improve approach 
goal provide expressive views system easily complemented code browsing 
time takes reverse engineer go visualization source code level kept short possible 
context speak opportunistic code reading polymetric views replace code reading support point reverse engineer spots code reading needed 
combining polymetric views manual code browsing proved way get results 
obvious tools necessary sufficient 
vi 
implementation moose language independent reengineering environment moose language independent reengineering environment written smalltalk 
famix metamodel provides language independent representation object oriented source code contains required information reengineering reverse engineering tasks performed tools 
language independent need legacy systems written different implementation languages 
extensible know advance information needed tools 
reengineering problems refactorings tools need language specific information allow language plug ins extend model language specific features 
allow tool plug ins extend model tool specific information 
core famix metamodel comprises main object oriented concepts class method attribute inheritance plus necessary associations invocation access 
note complete famix metamodel includes aspects object oriented paradigm contains source code entities formal parameters local variables functions opted uml sufficient modeling source code purpose reengineering specifically targeted representing source code 
codecrawler codecrawler uses moose representing software uses hotdraw framework visualization part 
remainder section discuss implementation issues design decisions 
extensibility 
lesson learned case studies typical normal 
case study posed certain problems size atypical language constructs domain specific aspects list just 
reverse engineering tool prepared situation may arise easily extended adapted current context 
codecrawler provides easy way integrate new kinds entities relationships 
occasion research project dealing legacy system written cobol changes needed enable visualizations cobol code performed hours 
doesn necessarily need moose entities handle visualize kind entity 
examples include visualizations domain concept analysis visualizations prolog statements 
codecrawler exploits properties entities moose model 
properties implemented dictionary freely easily extensible heavily example add new metric measurements add new annotations example package affiliation comments context treat moose models read facility enrich reverse engineering process additional information turn codecrawler 
interactivity 
software visualization needs offer interactive facilities user 
visualizations heavily parameterized offer easy way means direct manipulation idioms give user freedom directly manipulate resulting visualization means zooming scaling deletion elision 
case systems reverse engineered direct manipulation necessary reduce complexity providing basic navigation support cut latency times visualizations 
context claim visualizations merely represent source code case static visualizations static pictures manipulated source code 
emphasized aspect call code proximity discussed 
size color nodes render metric measurements possible display name information nodes codecrawler supports course case size render metric measurements anymore dictated displayed contents 
user wants know interacting codecrawler provides requested information ways means tool tip displaying status field top displaying separate window 
issue context interactivity definition measurement mapping function principles section iii order user click desired node node certain size 
hand size node render underlying metric measurement truthfully possible 
idea comes mind direct mapping 
idea rejected measurement zero node dimension 
considered possible solutions problem settled defining minimal node size mns value metric measurements directly added 
mns experience value easily changed user 
obtain mapping function width height mns metric measurement maps metric measurement code proximity 
providing easy fast access original source code greatly reduce latency times 
goal provide alternative expressive views system necessary quickly verify correctness visualization class really big important get visualization source code level 
codecrawler provides access source code represented nodes ways 
smalltalk code directly access open browser corresponding classes methods 
case non smalltalk code gain access right location right file means source anchor defined entity 
scalability 
major issues software visualization tools confronted scalability 
code crawler visualize time ca 
entities 
note keep entities memory 
tool usability 
tool downloaded times haven performed user survey personal mail discussions users learned short learning time know get view 
views easily editable learned users apply predefined views seldom create new views 
vii 
related approach mixture approaches discuss performed areas focusing methodological aspects related approaches 
software visualization 
graphical representations software field software visualization subarea information visualization long accepted comprehension aids support reverse engineering 
software visualization major approaches reverse engineering 
price extensive taxonomy software visualization examples tools 
tools static information visualize software rigi hy seesoft tango field environment name prominent examples 
substantial research conducted runtime information visualization called program visualization 
various tools approaches dynamic trace information program explorer ancestors 
various approaches discussed interactions program executions visualized 
current approach exploit dynamic information 
conducted research combination static dynamic information static information provided moose reengineering environment 
systems third dimension rendering software 
brown najork explore distinct uses expressing fundamental information structures inherently dimensional uniting multiple views object capturing history twodimensional view 
exemplify uses showing screen dumps views developed zeus algorithm animation system 
state potential graphics program visualization significant unexplored 
systems cited visualizations 
refrained visualizations mainly contradict lightweight constraint 
consider exploration possible 
metrics 
metrics long studied way assess quality complexity software applied object oriented software 
metrics profit scalability case simple ones reliable definition 
simple measurements hardly sufficiently reliably assess software quality 
metric tools visualize information diagrams statistical analysis histograms diagrams 
tac tools exhibit visualization features 
tools visualizations mere side effects having analyze large quantities numbers 
case visualization inherent part approach visualize numbers constructs occur source code 
methodology 
best knowledge approaches presents reverse engineering methodology help reverse engineer apply certain tool technique 
storey basic ideas build mental model software exploration provide needed difficult obtain empirical evidence 
suppose ad hoc nature reverse engineering tools including software industry adopted tools concrete aids development process 
viii 
article polymetric views lightweight visualizations enriched software metrics 
furthermore reverse engineering methodology clusters polymetric views 
methodology enables quickly gain insights inner structure large software legacy systems helps detect problems 
furthermore shown codecrawler reverse engineering tool built principles simple ideas applying constantly industrial case studies 
codecrawler successfully reverse engineering large industrial software systems 
methodology applying different views reverse engineered case study 
able understand different aspects case study overview application discussion inheritance mechanisms detection design patterns detection places depth examinations needed propositions possible refactorings applied 
seen reverse engineering systematic process understanding system non linear complemented opportunistic code reading 
corroborates mayrhauser vans show understanding resides level 
lightweight approach especially useful phase weeks reverse engineering process 
believe combined complex traditional approaches code reading simplest approach point complementary approaches 
believe approach iteratively complete reverse engineering process generate snap shots system different stages 
tried systematically part 
language specific views 
famix language independent focused developing views context 
believe views exploit language specific information example modifier information languages java metaclasses smalltalk 
new entities relationships 
new entities relationships may need equivalent software help generate new views new artifacts 
way interactively generate artifacts supported grouping mechanisms similar ones implemented rigi group entities relationships certain rules naming conventions types 
usability navigation 
extensive direct manipulation idioms especially relevant reverse engineering process increase malleability flexibility tools 
navigation mechanisms increase efficiency reverse engineering process 

third dimension see example help exploit visualize semantic information believe techniques generates results classified lightweight anymore 
forward engineering 
convinced approach benefits forward engineering code browsing programming environments 
currently integrating codecrawler visualworks smalltalk development environment 
appendix software metrics context article software metrics described table metrics divided groups class method attribute metrics entities metric measurements assigned 
note metrics engine able compute metrics omitted table mentioned article 
main constraints reengineer systems written different object oriented languages chosen include metrics engine metrics computation depend language specific features directly language independent metamodel section vi 
table list software metrics 
name description class metrics number classes superclass chain class number methods extended redefined subclass invoking method superclass nmi number methods inherited defined superclass inherited unmodified subclass number methods overridden redefined compared superclass noa number attributes noa niv ncv noc number immediate subclasses class nom number methods sum loc methods number descendant classes method metrics loc method lines code msg number method message sends nop number input parameters ni number invocations methods method body number accesses attributes nos number statements method body attribute metrics number times directly accessed 
note nga nga number direct accesses outside class number direct accesses class ii 
layouts context article layouts tree 
positions entities hierarchical relationship 
see example 
layout essential visualize hierarchical structures 
case object oriented programming languages applies especially classes inheritance relationships 
scatterplot 
positions nodes orthogonal grid origin upper left corner measurements 
entities identical measurements overlap 
algorithm useful comparing metrics large populations 
see example 
layout scalable space consumes due measurements nodes actual number nodes 
checker 
sorts nodes metric places rows checkerboard pattern 
useful getting impression especially relative proportions measurements visualized nodes 
see example 
layout advantage uses little space layout large numbers nodes 
nodes sorted certain metric easily detect outliers 

sorts nodes width metric renders second metric height node positions nodes long row 
layout detect exceptional cases metrics usually correlate normally results steady declining staircase exceptions break steady declination 
see example 
acknowledgments oscar nierstrasz tse review commission giving valuable advice writing 
chikofsky cross ii reverse engineering design recovery taxonomy ieee software pp 
january 
re engineering object oriented legacy systems journal object oriented programming vol 
pp 
january 
rugaber white restoring legacy lessons learned ieee software vol 
pp 
july 
parnas software aging proceedings international conference software engineering 
sommerville software engineering addison wesley sixth edition 
davis principles software development mcgraw hill 
demeyer ducasse nierstrasz object oriented reengineering patterns morgan kaufmann 

storey fracchia ller cognitive design elements support construction mental model software exploration journal software systems vol 
pp 

stasko domingue brown price eds software visualization programming multimedia experience mit press 
ware information visualization morgan kaufmann 
petre looking isn seeing readership skills graphical programming communications acm vol 
pp 
june 
fenton pfleeger software metrics rigorous practical approach international thomson computer press london uk second edition 
littman pinto letovsky soloway mental models software maintenance empirical studies programmers workshop pp 

ducasse demeyer eds object oriented reengineering handbook university bern october see www iam unibe ch handbook 
demeyer tichelaar ducasse famix information exchange model tech 
rep university bern 
ducasse lanza tichelaar moose extensible language independent environment reengineering object oriented systems proceedings second international symposium constructing software engineering tools coset june 
demeyer ducasse lanza hybrid reverse engineering platform combining metrics program visualization proceedings wcre th working conference reverse engineering 
october ieee 
lorenz kidd object oriented software metrics practical guide prentice hall 
henderson sellers object oriented metrics measures complexity prentice hall 
chidamber kemerer metrics suite object oriented design ieee transactions software engineering vol 
pp 
june 
battista eades tamassia tolls graph drawing algorithms visualization graphs prentice hall 
object oriented design heuristics addison wesley 
roberts brant johnson refactoring tool smalltalk theory practice object systems vol 
pp 

fowler beck brant opdyke roberts refactoring improving design existing code addison wesley 
beck smalltalk best practice patterns prentice hall 
ducasse lanza methodology understanding object oriented systems technique science vol 
pp 

lanza ducasse categorization classes visualization internal structure class blueprint proceedings oopsla pp 

ducasse rieger demeyer language independent approach detecting duplicated code proceedings icsm international conference software maintenance 
september pp 
ieee 
lanza combining metrics graphs object oriented reverse engineering diploma thesis university bern october 
gamma helm johnson vlissides design patterns addison wesley reading mass 
thomas smalltalk style prentice hall 
von mayrhauser vans identification dynamic comprehension processes large scale maintenance ieee transactions software engineering vol 
pp 
june 
tichelaar modeling object oriented software reverse engineering refactoring ph thesis university berne december 
demeyer ducasse tichelaar unified universal 
uml shortcomings coping round trip engineering proceedings uml second international conference unified modeling language kaiserslautern germany october vol 
lncs springer verlag 
johnson documenting frameworks patterns proceedings oopsla october pp 
published proceedings oopsla acm sigplan notices volume number 
ducasse lanza nierstrasz rieger tichelaar analysis report tech 
rep university bern 
cooper face essentials user interface design hungry minds 
card mackinlay shneiderman eds readings information visualization vision think morgan kaufmann 
price baecker small principled taxonomy software visualization journal visual languages computing vol 
pp 

tilley ller whitney wong domain retargetable reverse engineering proceedings csm conference software maintenance 
september pp 
ieee computer society 
consens mendelzon hy query visualisation system proceeding acm sigmod international conference management data sigmod record volume pp 

eick steffen eric jr seesoft tool visualizing line oriented software statistics ieee transactions software engineering vol 
pp 
november 

storey ller manipulating documenting software structures shrimp views proceedings international conference software maintenance 
stasko tango framework system algorithm animation ieee computer vol 
pp 
september 
reiss interacting field environment software practice experience vol 
pp 

lange nakamura interactive visualization design patterns help framework understanding proceedings oopsla 
pp 
acm press 
pauw helm vlissides visualizing behavior object oriented systems proceedings oopsla october pp 

understanding object oriented systems concurrently animated views proceedings oopsla november pp 
published proceedings oopsla acm sigplan notices volume number 
jerding ball visualizing interactions program executions proceedings icse pp 

ducasse recovering high level views object oriented applications static dynamic information proceedings icsm international conference software maintenance 
september pp 
ieee 
brown zeus system algorithm animation multi view editing proceedings ieee workshop visual languages october pp 

demeyer ducasse metrics really help proceedings lmo languages mod les objets 
pp 
hermes science publications paris 
assessment system evolution characterization icse proceedings international conference software engineering 
ieee computer society 
lewerentz simon product metrics tool integrated software development environment object oriented technology ecoop workshop reader vol 
lncs pp 

visually map source code structures analysis results space wcre proceedings 
ieee pp 
ieee computer society 

