university licentiate thesis intuitive resource efficient event detection algebra jan carlson june department computer science engineering university sweden copyright jan carlson issn isbn printed sweden distribution university press reactive systems execution driven external events system respond appropriate actions 
events simple systems supposed react sophisticated situations involving number events occurring accordance pattern 
systematic approach handle type systems separate mechanism detecting composite events rest application logic 
detection mechanism listens simple event occurrences notifies application complex event patterns interest occur 
event detection mechanism example event algebra expressions correspond event patterns interest built simple events operators algebra 
thesis presents novel event algebra important characteristics complies algebraic laws intuitively ought hold operators algebra large class expressions detection correctly performed limited resources terms memory time 
addition declarative algebra semantics imperative detection algorithm show correctly implements algebra 
algorithm analysed respect memory requirements execution time complexity 
increase ciency algebra semantic preserving transformation scheme expressions transformed meet criteria limited resource requirements guaranteed 
prototype implementation combines algebra event system java 
iii just forget algebra talk logic formula help anymore camp algebra preface thesis tradition bids start naming author feels indebted goes bjorn advisor supervising just works idt lengthy ee breaks talks subjects quite diverse order syllables fit verse andreas markus markus re johan xavier lars name important ones mention list constant strong support thesis exist marina course daughter parents siblings mentioned list far finished add mentioned shouldn feel sad take comfort fact lack time forget failed find proper rhyme 
jan carlson may contents problem formulation 
approach 
related publications 
contributions 
organisation 
event detection single point interval semantics 
event contexts 
event algebra declarative semantics 
primitive events 
composite events 
semantics 
properties 
algebraic laws 
impact restriction policy laws properties restriction policy 
event detection algorithm algorithm 
disjunction 
conjunction 
negation 
sequence 
temporal restriction 
vii viii contents putting 
resource requirements 
memory complexity 
time complexity 
expression transformation transformation algorithm 
experiments 
experiment 
experiment 
prototype implementation design decisions 
system description 
prototype 
related active databases 
event monitoring real time systems 
event notification services 
knowledge representation 

evaluating algebra 
delay operator 
dealing values 
implementing algebra 
bibliography experimental results experiment 
experiment 
list figures integrated separated detection composite events 
comparison single point semantics interval semantics 
comparison event contexts sequence operator 
graphical representation example 
event stream valid restrictions 
graphical representation example 
graphical representation example 
event detection algorithm 
statically simplified algorithm detecting 
detecting bounded memory 
algorithm 
example instances stored detection 
improved algorithm 
recursive transformation function 
transformation 
transformation 
class diagram event algebra package 
object diagram depicting expression represented 
sequence diagram depicting communication expression 
code creating expression 
ix list figures results experiment 
results experiment 
results experiment 
results experiment 
results experiment 
results experiment 
list tables informal description algebra operators 
summary experiment 
summary experiment 
summary experiment 
summary experiment 
xi chapter reactive system execution driven stream external events system react appropriate responses 
wide range applications fall category including active databases systems monitoring network tra electronic stock brokers real time embedded systems 
reactive systems desired behaviour seen reactions complex patterns events single event occurrences 
systematic way handle separate detection event patterns implementation appropriate reactions 
separation concerns facilitates design analysis reactive systems detection complex events formal semantics independent application remaining part system free auxiliary rules information partially completed patterns 
event detection part reacts simple events system referred primitive events detects occurrences composite events representing complex event patterns interest 
rest system composite events trigger specific actions way primitive events 
example 
consider system primitive events including button pressure alarm temperature alarm desired reaction system perform action button pressed twice seconds alarms occurs 
achieved set rules specify reactions chapter 
primitive events combined behaviour implements desired reaction 
alternatively separate detection mechanism define composite event corresponds described situation single rule stating occurrence trigger action approaches illustrated 


application logic 


event detection application logic integrated separated detection composite events 
reactive systems classified real time system temporal logical constraints expected system behaviour 
type systems correctness defined ability produce correct result correct time 
hard real time system violated temporal constraint considered serious error systems classified soft consider performance degradation 
establish correctness hard real time system able show temporal constraints violated worst case scenario 
especially important safety critical applications single constraint violation cause serious damage 
ensuring timeliness requires resource requirements parts system safe approximations thereof known 
separate detection mechanism possible derive bound memory required correctly detect complex event pattern worst case execution time detection mechanism pattern 
mechanism detect complex event patterns event algebra expressions correspond event patterns interest built simple events operators algebra 
event algebras variety reactive system domains problem formulation particular active databases areas real time systems middleware platforms 
desirable event algebra reactive systems meets criteria su cient expressiveness algebra rich express di erent types composite events interest targeted type systems 
formal semantics formal definition reduces ambiguity facilitates reasoning algebra system utilises 
particular formal reasoning system behaviour requires formal semantics 
intuitive operators usability algebra improved operators simple intuitive meaning 
aspect algebraic properties associativity comply intuition operators 
cient implementation detection mechanism low overhead terms memory execution time 
embedded real time systems vital safe estimates worst case memory usage execution time derived statically 
problem formulation desired properties event algebra described relatively straightforward achieve isolation 
existing approaches particular temporal logic similar formalisms highly expressive provide operators intuitive properties general means cient implementation event detection achieved 
similarly event algebras defined terms finite state machines trivially ensures limited resource requirements typically cost complicated non intuitive semantics operator combinations 
thesis addresses task developing formally defined event algebra reactive systems complies algebraic laws intuitively ought hold algebra operators ii permits cient implementation limited resource requirements 
problem statement motivated resource conscious applications real time embedded systems 
type systems chapter 
require bounds memory usage execution time statically determined 
furthermore appear safety critical applications formal verification required 
providing laws algebra conforms allows reasoning high level abstraction facilitates verification 
approach operators proposed algebra variants basic operators existing event algebras di erent application domains 
believe choice operators provides starting point 
plan perform thorough investigation expressiveness demands intended application domain determine algebra benefit additional operators 
discussed section 
algebra defined set declarative semantics terms state automata petri nets similar constructs 
simplifies tasks proving algebraic properties cost providing direct model algebra implemented 
provide separate imperative detection algorithm investigate time memory issues detail establish simple relation algorithm declarative algebra semantics 
techniques interval semantics preserve intuitive operator properties operator composition carefully designed restriction policy deal memory complexity caused properties 
techniques described chapter 
objectives intuitive algebraic properties bounded memory implementation contradictory extent 
situations trade unavoidable choice prioritise algebraic properties bounded memory 
consequently ensuring limited resource requirements general settled identifying class expressions correctly detected limited resources 
aim designing algebra class large possible 
related publications related publications event algebra thesis evolved current form number versions published 
carlson interval algebra restricted event detection 
proceedings international workshop formal modeling analysis timed systems formats marseille france september 
version algebra 
temporal restriction construct di erent restriction policies sequences remaining operators 
general resource bounds algebraic properties weak compared current version especially relation unrestricted semantics result restriction policy applied 
carlson improved algebra restricted event detection 
technical report se february 
improves algebra introducing temporal restriction sequences 
expressions sequence finite temporal restriction limited memory requirement ensured 
carlson event detection algebra reactive systems 
submitted april 
presents algebra version thesis results information minimum separation time primitive events achieve tighter resource bounds 
carlson event detection algebra reactive systems 
technical report se april 
technical report extends previous formal proofs 
chapter 
contributions main contributions thesis novel event detection algebra conforms algebraic laws intuitively ought hold algebra operators 
laws facilitate formal informal reasoning algebra behaviour reactive system uses 
formal restriction policy establish relation intuitive ine cient algebra semantics valid implementation thereof 
restriction policy carefully designed allow cient implementation retaining algebraic properties algebra semantics 
event detection algorithm conforms algebra semantics restriction applied large class events detected limited resources 
time triggered setting algorithm provides straightforward implementation algebra 
semantic preserving transformation algorithm algebraic laws temporal restriction allows expressions transformed meet criteria detection performed limited resources 
prototype implementation java provides opportunity test algebra practice illustrates concerns related implementing algebra event triggered setting 
organisation thesis organised way 
chapter gives brief concepts techniques common event detection frameworks 
algebra chapter 
declarative semantics algebra including restriction policy defined 
number important properties proved particular ect applying restriction policy nested fashion 
followed description imperative detection algorithm chapter correctness result establishes relation organisation algorithm declarative semantics algebra 
chapter contains analysis memory time complexity detection algorithm suggestions improved 
chapter presents event expression transformation algorithm decreasing memory needed detect event correctly possibly infinite limited memory 
show meaning event expression preserved transformation algorithm applied 
chapter prototype implementation algebra incorporated java event system 
chapter surveys related discussion followed description chapter concludes thesis 
chapter event detection conceptually task event detection mechanism compute occurrences composite event occurrences primitive events 
way composite event specified meant occurrence di er methods type event patterns specified 
applications event detection performed finite collection primitive event occurrences gathered earlier phase example result monitoring system environment 
allows detection mechanism process data arbitrary order possibly passes typically impose hard resource constraints 
contrasting line methods reactive applications require events detected continually entire system lifetime infinite theory 
implies detection mechanism knowledge occurrences primitive events typically limited information past events stored due resource restrictions 
naturally term event means di erent thing di erent contexts 
particular denote single occurrence source type occurrences 
thesis distinguish referring occurrence instance 
called event type just event 
proposed algebra event type algebra event instance algebra operators algebra combine simple event types complex event types 
chapter 
event detection event detection done means event algebra composite events defined expressions built recursively primitive events operators algebra 
choice operators di er algebras influenced type systems algebra intended 
table lists operators thesis informal description meaning 
formal definitions see section 
operator notation informal meaning disjunction occurs occurs 
conjunction occurs occurred order possibly simultaneously negation occurs occurrence occur 
sequence occurs occurrence followed occurrence temp 
restr 
occurs occurrence shorter time units 
table informal description algebra operators 
basic operators disjunction conjunction sequence negation algebras meaning slightly di erent 
example sequence operator allow partly overlapping events identified sequence conjunction restricted simultaneous occurrences 
addition common operators proposed algebra contains temporal restriction construct limits length event occurrence 
algebras type events specified typically provided variants ordinary operators temporally restricted sequence 
interval semantics described algebra allows general temporal restriction construct applied event expression 
negation operator general provided algebras result interval semantics 
example 
meaning negation operator temporal restriction construct best understood examples 
expression single point interval semantics denotes composite event occurs occurrence followed occurrence occurrence 
event defined expression occurs occurrence followed occurrence time units 
example 
composite event example corresponds expression 
single point interval semantics event algebras event occurrence including events require occurrence simpler events associated single time point time detection time occurrence required 
galton showed results unintended semantics operator combinations example nested sequence operators described example 
inspired methods knowledge representation suggest problem solved associating occurrence complex event occurrence interval time detection 
comparison single point semantics left interval semantics right 
example 
illustrate di erence single point interval semantics 
figures time flows left right chapter 
event detection row shows occurrences primitive event type detected occurrences expression 
single point detection instance event detected occurs followed reason occurrences cause detection associated occurrence time occurs time point occurrence detected 
shows situation left column intuitively correct detection 
interval semantics sequence defined occur intervals non overlapping 
example occurrence detected occurrence prior interval associated occurrence result interval version depicted right column 
base event algebra interval semantics facilitates design operators intuitive composition 
defining occurrence interval operator explicitly included operator semantics define interval occurrence smallest interval containing primitive occurrences caused occur 
event contexts operator semantics described informally specify handle situations occurrence participate occurrences composite event 
example occurrences followed occurrences result occurrences may acceptable desirable applications memory requirements occurrence remembered forever increasing number simultaneous events means unsuitable cases 
common way modify operator semantics take account means event contexts 
operator simple meaning defines constraints participating occurrences characterise operator similar table 
number event contexts defined act modifiers simple operator semantics 
contexts specify constraints occurrences may selected looking occurrence patterns event contexts match operator semantics 
result combination operator context seen separate operator specific meaning 
example 
illustrate concept event contexts typically define informally contexts snoop called unrestricted chronicle 
avoid details describe ect sequence operator general form applied operator 
detecting event contexts meanings 
unrestricted instances valid 
instance combined instances form instances instance valid 
chronicle instance combined instances form instances oldest instance valid 
instance valid 
shows ect contexts sequence operator 
existing event algebras event contexts defined informally 
defined contexts intended operators introduce unintended ects 
event contexts provide variants algebra operators developer reactive system achieve specific behaviour specified operator semantics 
contexts affect resource requirements operator applied 
example context instance constituent type stored basic operators implemented limited resources context 
unfortunately event contexts typically ruin algebraic properties hold simple operator semantics 
restriction policy proposed thesis originally influenced type event contexts conceptual role restriction policy di erent 
consider intuitive simple operator semantics intended behaviour event detection due chapter 
event detection unrestricted chronicle comparison event contexts unrestricted chronicle sequence operator 
ciency considerations subset occurrences detected 
restriction policy formalise subset may selected 
restriction policy conceptually applied event expression individual operators 
chapter event algebra described algebra defined declarative semantics sets 
introduce formal restriction policy defines considered valid implementation algebra 
algebra defined investigate algebraic properties operators restriction policy 
simplicity assume discrete time model thesis 
declarative semantics algebra dense time model restrictions prevent primitive events occur infinitely times finite time interval 
assume occurrences primitive events instantaneous primitive event occurs time instant 
declarative semantics defining syntax semantics algebra define concepts needed represent primitive events occurrences 
concepts extended encompass composite events 
primitive events assume system pre defined set primitive event types able react 
events external sampled environment originating system internal violation condition system state chapter 
event algebra timeout detection mechanism distinguish categories 
primitive events useful associate additional information occurrence 
example occurrences temperature alarm carry measured temperature value responding action 
values manipulated algebra grouped forwarded part system reacts detected events 
definition 
finite set identifiers represent primitive event types available system 
identifier dom denote value domain values associated instances definition 
temporal domain set natural numbers 
occurrences primitive events assumed instantaneous atomic 
algebra represented event instances contain event type value occurrence time 
formally represent primitive instance singleton set allow primitive complex instances treated uniformly 
definition 
dom singleton set primitive event instance 
occurrences certain event type form event stream 
definition 
primitive event stream set primitive event instances identifier di erent times 
set identifiers value domains capture static aspects system 
instances event streams dynamic concepts describe happens particular scenario 
interpretation formal representation single scenario describes possible ways primitive event occur 
definition 
interpretation function maps identifier primitive event stream containing instances identifier example 
system previous examples assume instances temperature alarm carry temperature measurements declarative semantics represented natural numbers 
pressure alarm sensitive instances contain information pressure low high 
button instances carry additional information represented dummy element 
static aspects system captured formally dom dom high low dom 
example particular scenario consider interpretation primitive event streams low composite events composite events represented expressions built recursively identifiers operators algebra 
definition 
event expression 
event expressions event expressions 
extend concepts instances streams composite events 
instance composite event triggered instances simpler events information associated simpler instances included representation composite event instance 
design decision structure expression visible representation instances 
simplicity flat instance representation independent structure expression 
informally instance composite event consist primitive event occurrences caused occur directly indirectly causing simpler composite events occur 
explicit information instance event type instance 
implicitly provided events stream instance belongs 
example consider instance caused instance instance instance represented chapter 
event algebra set alternative expression structure visible instances represent instance 
way instances constructed defined algebra semantics 
define structure 
definition 
event instance non empty union primitive event instances 
semantics interval associate instance interval definition 
definition 
event instance define start min max interval start thought smallest interval contains occurrences primitive events caused occur 
note primitive event instance event instance primitive event instance start 
example 
low 
event instance start 
graphical notation examples composite event instances visualised start time 
cases details required times primitive instances composite event instance marked 
need definition general event streams 
represent instances composite event 
definition primitive event stream event stream just names suggest 
definition 
event stream set event instances 
variable naming convention thesis event streams event expressions 
lower case letters event instances general belongs event stream declarative semantics semantics interpretation provides occurrences primitive event mapping identifier event stream 
role algebra semantics extend mapping composite events defined event expressions 
functions event streams form core algebra semantics defining characteristics operators 
definition 
event streams define dis con neg start start seq tim start semantics algebra defined recursively applying corresponding function operator expression 
definition 
meaning event expression interpretation defined follows dis con neg seq tim simplify presentation notation choice obvious arbitrary 
example 
consider expression algebra semantics meaning expression seq seq scenario captured interpretation example concrete meaning expressions low low illustrates graphically 
chapter 
event algebra time 
graphical representation example 
algebra semantics reasonably intuitive simple aid formal informal reasoning meaning expressions 
operators behave properly complex nested expressions captured algebraic laws section 
algebra ciently implemented form bounds number simultaneous instances memory required store instances 
deal expect implementation detect subset instances specified algebra semantics 
naturally allowing implementations detect subset constructive 
introduce formal restriction policy defines considered valid subset implementation detect 
conceptually restriction policy applied expression designed ensure semantically consistent applying recursively subexpressions required allow cient implementation 
ideally restriction policy interfere little possible properties unrestricted semantics 
removed instances crucial impact detection enclosing expressions 
time operators conjunction sequence able identify non valid instances early time instance reached order waste memory 
restriction policy defined predicate function 
alternatively seen non deterministic restriction function family valid restriction functions 
reasons repeatability desirable implementation algebra deterministic 
theoretical point view prefer leave open detailed design decisions possible ensure implementation consistent restriction policy predicate declarative semantics guaranteed properties described thesis 
design decision motivated increased flexibility provides implementing algebra 
choices non deterministic formal definition basis implementation details increase ciency 
basis restriction policy restricted event stream subset contain multiple instances time 
informally instances time restriction policy keeps exactly maximal start time 
formally restriction policy defined follows 
definition 
event streams rem holds conditions hold 

start start 
section show restriction policy applied recursively subexpressions event expression defined impact resulting event stream 
section argues restricted version algebra ciently implemented 
example 
illustrates result applying restriction policy event stream instances time start time removed start time 
instances time earliest start time removed 
long instance instance time included restricted stream 
choice short instances time remove results valid restrictions event stream named 
straightforward see rem rem holds event stream rem holds 
event contexts example section typically defined terms conditions constituent event instances 
restriction policy defined thesis di ers chapter 
event algebra time 
event stream valid restrictions rem rem holds 
explicitly applied event stream produced unrestricted algebra semantics 
results simpler restriction policy semantics cost reduced expressiveness designing policy restriction decisions solely information event stream 
example able modify policy give priority left argument disjunction instance representation changed include additional information 
sake completeness show restriction policy constructive event stream exists valid restriction 
theorem 
event stream exists event stream rem 
proof 
discrete time model ensures instance maximal start time subset way select instances time include restricted stream 
dense time setting contain infinite sequence increasingly shorter instances time 
instance maximal start time include restricted stream 
definition primitive event stream limited additional properties condition finite time interval finite number instances times interval theorem holds dense time model 
properties argued algebra semantics defined previous section corresponds intuitive meaning operators intuition personal cases inconsistent considerations conflict intuitively valid 
aid user algebra section presents number useful laws algebra complies 
laws facilitate formal informal reasoning algebra system embedded show extent operators behave intuition 
investigate laws ected restriction policy result applying restriction recursively subexpressions expression 
crucial implementing algebra limited resources 
notion expression equivalence defined 
definition 
event expressions equivalent denoted interpretation trivially equivalence relation 
theorem shows satisfies substitutive condition defines structural congruence event expressions 
theorem 
proof 
follows straightforward way definitions 
algebraic laws laws describe properties disjunction conjunction sequence operators distribute 
theorem 
event expressions laws chapter 
event algebra hold 









corollary 

proof 
laws follow straightforward way definitions 

dis 
dis dis 
con con 

con con 

con dis con con con 
properties 

follows laws 
set laws negation 
simplify proofs introduce predicate 
definition 
event stream time instants define empty hold start 
proposition 
empty start 
ii 
empty empty empty iii 
empty implies empty proof 
properties follow trivially definition 
theorem 
event expressions laws hold 





corollary 





proof 
denotes equivalence follows law number similarly ii denotes equivalence corresponding property proposition 
chapter 
event algebra 
empty start empty start empty start ii empty start 
empty start empty start empty start 
empty start empty start empty start empty start iii empty start empty start 
empty start empty start empty start empty start iii empty start empty start 
empty start empty start empty start empty start iii properties empty start empty start 
follows laws 

follows laws 


follows laws 

follows laws 

laws describing temporal restrictions propagated expression 
laws chapter construct algorithm transforming event expressions equivalent expressions detected ciently 
theorem 
event expressions laws hold 


min 





corollary 




max 

chapter 
event algebra proof 

implies start means 

start start start min min 
start start start 
start start start start start start start start start start formula equivalent start start 

start start start start start start 
start start start start start start start start start start implies start constraint removed ecting set 
set equivalent start start start 

properties start start start implies start constraint dropped changing set 
set equivalent 
start start start implies start constraint dropped changing set 
set equivalent start 
min min 

follows laws 

max max max min max min max 
follows laws 

introduce empty event occurs laws related 
definition 
denote empty event semantically defined interpretation chapter 
event algebra theorem 
event expression laws hold 








proof 
laws follow straightforward way definition operator semantics 
impact restriction policy laws laws consider equivalence expressions respect algebra semantics 
implementation restriction policy applied equivalent expressions produce di erent results non deterministic choices restriction policy depend structure expression implementation 
example 
consider event stream example imagine equivalent event expressions valid restrictions implementation algebra results detecting detecting consequently clarified extent laws applicable restriction applied 
theorem 
rem holds rem holds 
proof 
implies follows trivially 
ensures result implementation detecting valid result long reasoning algebra semantics restriction policy details particular detection algorithm section equally valid equivalent expressions 
properties example 
previous example algebra semantic restriction policy perfectly valid result reasoning system fact implementation happened result detecting investigate relation equivalent expressions restriction applied notice restriction policy implies detected event streams equivalent expressions contain instances corresponding start times 
means part system responds detected event occurrences notified time equivalent expressions possibly di erent values attached detected occurrences 
formally express follows 
definition 
event streams define hold start start trivially equivalence relation 
theorem 
rem rem holds proof 
take second condition definition rem exists start start 
start start 
third condition definition rem implies means start start start start start 
start time 
trivially opposite holds 
corollary 
rem rem holds proof 
follows theorem definition implies 
ensures implementation consistent restriction policy instances detecting start times 
means part system responds detected event occurrences notified time equivalent expressions possibly di erent values attached detected occurrences 
chapter 
event algebra properties restriction policy order achieve desired ciency subexpressions expression detected cient way 
requires restriction policy applied expression recursively subexpression resulting far complicated semantics far 
general require user algebra understand restrictions di erent subexpressions interfere ect di erent operator combinations 
avoid operators restriction policy carefully designed support theorem 
informally states introducing restriction subexpressions gives result valid case restriction applied top level 
opposite hold 
set valid restricted streams restriction applied recursively subset streams valid single top level restriction 
illustrated example 
theorem section prove correctness detection algorithm 
theorem 
rem rem holds event stream implications hold rem dis rem dis ii 
rem con rem con iii 
rem neg rem neg iv 
rem seq rem seq rem tim rem tim proof 
assume rem dis 
dis implying dis 
dis satisfies constraint definition rem 
take arbitrary dis 
definition rem exist start start 
dis rem dis implies exists start start 
means start start second constraint definition rem satisfied 
properties rem dis ensures instances di erent times 
gives rem dis 
ii 
assume rem con 
con subset requirement definition rem con con 
take arbitrary con 
definition rem exists start start start start 
con start start 
means exists start start satisfies second constraint definition rem 
rem con ensures instances di erent times 
gives rem con 
iii 
assume rem neg 
neg subset requirement definition rem exists start start exist start start contradicts fact neg 
exist neg neg 
take arbitrary neg 
exists start start 
exists start start fact contradicts neg 
exist neg 
means exists start start start start satisfies second constraint definition rem 
rem neg ensures instances di erent times 
gives rem neg 
iv 
assume rem seq 
seq start 
subset requirement definition rem seq seq 
chapter 
event algebra take arbitrary seq 
start 
definition rem exists start start start start 
start start seq start start 
means exists start start satisfies second constraint definition rem 
rem seq ensures instances di erent times 
gives rem seq 
assume rem tim 
tim start subset requirement definition rem means tim tim 
take arbitrary tim 
exists start start 
start start tim 
def rem means exists start start 
means start start second constraint definition rem satisfied 
rem tim ensures instances di erent times 
gives rem tim 
example 
example illustrate implications theorem hold opposite direction 
consider event stream interpretation consisting nonoverlapping event instances occurring order named identifier belong 
depicts scenario 
clearly valid restriction rem 
case multiple restrictions 
rem holds contain result seq contain instance streams valid restriction policy applied valid recursive application restriction 
properties graphical representation example 
example illustrates fact restriction start times crucial achieve properties restriction applied recursively 
example 
consider event streams depicted stream corresponding negation 
single valid restriction important property policy replacing negation restricted stream introduce additional instances 
consider imaginary restriction policy valid restriction resulting event stream contains instances unrestricted variant 
chapter 
event algebra neg neg neg graphical representation example 
chapter event detection algorithm simplicity declarative semantics helpful investigating properties algebra shown previous chapter 
provide insight algebra ectively implemented implementation constructed 
chapter imperative algorithm detecting event defined event expression 
algorithm proven correct respect declarative algebra semantics restriction policy analysed time memory complexity 
definition 
chapter denotes event expression detected 
numbers 
assigned subexpressions bottom order denote subexpression number consequently algorithm presents algorithm detecting event defined event expression algorithm executed time instant computes current instance current instances primitive events stored information past 
variables indexed operator expression requires state variables 
variable store chapter 
event detection algorithm current instance am contains output algorithm execution 
auxiliary variables store information past needed detect properly 
single event instance stored stores time instant contains set event instances 
symbol represent non occurrence define start simplify algorithm 
algorithm designed detection arbitrary expressions main loop selects dynamically part algorithm execute subexpression 
systems event expressions static known time development main loop unrolled top level conditionals variable indices statically determined 
concrete example 
rest section prove output algorithm corresponds valid restriction 
purpose need auxiliary concepts 
formalise algorithm output constructing corresponding event streams 
definition 
define denotes value variable executing algorithm times introduce thought pointwise restriction predicate lemma captures relates ordinary restriction policy 
definition 
event instance event stream define valid hold start lemma 
event instances 
event stream valid holds 
rem holds 
proof 
definition valid follows take arbitrary 
valid definition valid know algorithm current instance 
start start start start start start start foreach start start start event expression algorithm computes event stream rem holds 
initially chapter 
event detection algorithm current instance 
current instance 
start start current instance 
start start start statically simplified algorithm detecting 
initially 
start start 
means second requirement definition rem satisfied 
elements di erent times 
implies rem holds 
correctness proof organised follows 
operators prove lemma showing operator correctly detected respect instances detected arguments 
lemmas combined theorem previous chapter prove algorithm correct 
turning operators general observations regarding algorithm 
straightforward see ith iteration loop variables index changed variables indices equal subexpressions numbered bottom order 
proving correctness subexpression su cient consider ith iteration 
auxiliary predicates defined section refer variables index higher hold ith iteration hold iterations 
disjunction disjunction operator fairly simple requires auxiliary variables 
occur time restriction policy requires latest start time selected 
start times implementation gives precedence right subexpression 
algorithm lemma 
holds valid dis holds executing algorithm time ii 
rem dis 
proof 
valid dis trivially holds executing disjunction part algorithm 
belong dis maximum start time satisfies condition valid 
start times equal algorithm selects satisfies condition 
ii 
follows lemma 
conjunction conjunctions necessary store subexpressions instance maximum start time far 
formalised definition holds start time instant correct values 
definition 
define hold holds element maximum start time set empty 
element maximum start time set empty 
lemma 
holds holds start time ii 
valid con holds executing algorithm time chapter 
event detection algorithm iii 
rem con 
proof 
holds initial state 
assume holds start time conditional conjunction part algorithm ensures contains instance consistent executing conjunction part 
similarly second conditional ensures correctness induction lemma holds ii 
proof know holds executing conditionals conjunction part 
guard third conditional satisfied trivially follows instance con time lemma holds assigning guard false identify separate cases 
case know con 
assume existence con start start start start contradicts exists means valid 
inner conditional evaluates false assigned meaning lemma holds case 
similarly case lemma holds assigning third case belong con 
reasoning previous cases exist con start start start start inner conditional holds start start start start 
start start lemma holds assigning similarly inner conditional hold lemma holds assigning iii 
follows ii lemma 
algorithm negation semantics negation operator instance instance invalidated instance occurring interval 
current instance invalidated invalidated instance maximum start time occurred far 
su cient store single start time time trivially known time current instance definition 
define hold maximum element set start set empty 
lemma 
holds holds start time ii 
valid neg holds executing algorithm time iii 
rem neg 
proof 
holds initial state 
assume holds start time conditional negation part algorithm ensures contains value specified executing negation part 
induction lemma holds ii 
proof know holds executing conditional negation part 
guard second conditional holds 
start start neg 
trivially instance time valid neg 
lemma holds assigning iii 
follows ii lemma 
chapter 
event detection algorithm sequence sequence operator requires complex algorithm 
reason order detect sequence correctly store instances occurs start time instance determines stored instances combined form instance definition 
define hold holds maximum element start set empty 
start start lemma 
holds holds start time ii 
valid seq holds executing algorithm time iii 
rem seq 
proof 
holds initial state 
assume holds start time conditional sequence part algorithm change values second conditional holds updated value specified 
know start implies holds adding second conditional hold changes required hold 
induction lemma holds 
ii 
know holds start time consider case 
instance seq time lemma holds algorithm assigning second case 
executing foreach statement instance start 
implies seq lemma holds assigning foreach statement start seq 
know start start start valid seq lemma holds assigning iii 
follows ii lemma 
temporal restriction temporal restriction fairly straightforward implement requires auxiliary state variables 
lemma 
holds valid tim holds executing algorithm time ii 
rem tim 
proof 
lemma holds assigning done branches conditional 
conditional holds tim 
instance time follows lemma holds assigning conditional false instance tim time lemma holds assigning ii 
follows lemma 
chapter 
event detection algorithm putting theorem establishes correctness algorithm 
subexpression including detected instances correspond valid restriction 
theorem 
rem holds 
proof 
base case consider assumption interpretation correctly represents real world scenario rem holds trivially 
inductive case assume rem holds lemma rem dis 
subexpressions numbered bottom rem rem holds 
theorem implies rem dis rem holds lemmas section similar proof constructed operators 
induction theorem holds resource requirements instances fixed size instance subexpression contains primitive instances identifier occurrence assuming elements value domains constant size size single event instance bounded 
quick analysis algorithm previous section reveals disjunction conjunction negation temporal restriction event expression requires limited amount storage contributes limited factor computation time detection algorithm 
storage required sequence operator depend maximum size bound exists general case 
important class sequence expressions detection algorithm redefined ensure bounded memory time 
memory complexity sequence know length instances exceeds expressed equivalence resource requirements limits number instances need store order detect sequence correctly 
informally start instance time units back time need store instance ends earlier store maximum start time 
instances point time need store original algorithm version 
example illustrates idea 
example 
possible scenario detection event expression depicted 
current time instant occurrences instance occurs current time instance start time instance combined form instance start time combined combined instance time start earlier follows combined need store detection expression instances ended time units ago latest start time discarded 
time detecting bounded memory 
improved algorithm detecting limited memory 
denotes current time instant algorithm executed 
new algorithm prove lemma similar previous section 
state similar state sequences original algorithm contains su chapter 
event detection algorithm foreach start start start foreach algorithm original version 
remaining elements single element maximum start time stored definition 
define newstate hold holds maximum element start set empty 
start start element maximum start time set empty 
lemma 
holds newstate holds start time ii 
valid seq holds executing algorithm time iii 
rem seq 
proof 
newstate holds initial state 
assume newstate holds start time resource requirements conditional changes ect newstate 
second conditional updates way original sequence algorithm 
conditional foreach statement holds means conditional holds element definition newstate requires removed order newstate hold 
newstate fulfills requirement specified newstate 
induction lemma holds 
ii 
know newstate holds start time case follows proof original sequence 
case executing foreach statement valid seq proof original sequence 
executing foreach statement instance start 
case assign know start value specified newstate valid seq holds 
arriving conditional know instance valid seq holds 
lemma holds second foreach statement reached assigned value remaining statements lemma holds 
iii 
follows ii lemma 
definition newstate follows sequence size exceeds start time instant 
instance added single execution algorithm means storage requirement limited sequences 
large values example systems fine granularity timebase resource bound su cient practice 
bound large occurs frequently 
information minimum separation time chapter 
event detection algorithm primitive events minimum time consecutive occurrences event derive maximum number occurrences time interval length definition 
minimum separation time primitive events represented function interpretation consistent holds 
minimum separation time compute minimum separation times composite events disjunction conjunction minimum separation regardless constituent events 
derive maximum number times event occur interval size 
definition 
function occ defined follows occ occ min occ occ occ min occ occ occ occ occ occ occ occ function represents maximum number instances di erent times occur interval length theorem states 
theorem 
event expression time instants interpretation consistent holds occ proof 
proof induction 
base case note maximum number instances interval achieved instances occur distance 
exactly occ instances fit interval 
inductive case assume property holds event expressions time points interval number times larger justifies minimum construct disjunction conjunction 
instance time equal time instance number distinct times limited resource requirements sum distinct times interval 
assumption larger occ occ 
instances time instance reasoning disjunction applies conjunctions 
instance time instance assumption occ distinct instances interval 
similarly instances instances time instance induction theorem holds expression 
corollary 
improved sequence algorithm size exceeds occ 
proof 
elements belong constraint defined newstate times interval length corollary follows directly theorem 
applications beneficial provide maximum occurrence values primitive events addition minimum separation time 
especially useful bursty events occur times high frequency occur long time 
extending definition take kind information account relatively straightforward 
formally identify class expressions detected bounded memory formulate theorem 
theorem 
event expression subexpression form correctly detected limited memory 
proof 
trivially memory needed store information past limited operators sequence 
algorithm detecting specific type sequences size limited 
total storage requirement limited 
theorem provide means syntactically determining expression detected limited memory 
chapter describes laws temporal restriction transform expressions meet criteria limited resource requirements guaranteed 
addition su cient criteria syntactically identify expressions require limited memory transformation applied 
chapter 
event detection algorithm time complexity result instances having fixed size assigning instance variable constant operation proportional instance size 
operator contributes factor time complexity algorithm 
sequences straightforward representation variables gives linear time complexity finding best matching instance respect size limit variable 
gives total complexity mn number subexpressions max maximum size limit variables 
maximum size known elaborate implementation possible 
keep sorted respect times newstate ensures contain instances fully overlapping means sorted respect start times 
instance added start time instances elements removed old behave queue 
consequently keeping updated done constant time 
instance occurs need find best matching instance ciently instance latest start time start time instance 
sorted respect start times implemented straightforward binary search implementation allows constant access arbitrary elements 
allow base implementation static array variables mark part array currently contain elements added removed variables increased accordingly array reached simply continue 
size limit known size array ensures room array start marker overtake marker 
example illustrates implementation variables example 
describes instances stored variable detection assuming information minimum separation available 
shows updated element removed improved sequence algorithm 
resource requirements time example instances stored detection algorithm uses indexed integer variables qs qe qm temporary variables shared sequence operators expression 
variable marks start active part new instances added marks active part 
initial state representing empty 
temporary variables mark start middle subsection active part binary search 
accessing xth element array denoted 
implementation total complexity detecting mn number subexpressions max log maximum size limit variables 
chapter 
event detection algorithm start qe qs mod qe qs qm qe qs qe mod mod qm start qe qm qs qm mod qe start mod start mod improved algorithm initially 
brevity denotes occ 
chapter expression transformation chapter describes event expression automatically transformed expression detected ciently meaning 
transformation algorithm algebraic laws describing temporal restrictions propagated expression section 
simplify presentation extend algebra syntax constructs 
symbol added temporal domain allow temporally restricted unrestricted expressions treated uniformly 
formally define improved sequence algorithm defined sequences introduce notation label sequences information 
transformation algorithm transformation algorithm recursive function takes expression time instant input returns transformed expression time instant 
function defined 
informally input time instant represents temporal restriction applied current subexpression changing meaning expression 
example expression form changing changes meaning subexpression meaning expression remains unchanged 
returned time instant represents temporal restriction applied transformed expression changing chapter 
expression transformation transform transform transform transform max transform transform transform transform transform min transform transform transform transform transform transform min recursive transformation function 
transformation algorithm meaning 
informal description formalised lemma states transformation function preserves semantics original expression called properly 
defines meaning returned time 
lemma 
event expression time instant transform proof 
prove lemma structural induction 
proof denotes equivalence follows law theorem indicates equivalence follows assumptions 
base case note lemma holds transform inductive case assume lemma holds subexpressions consider operator separately disjunction assumption 
max 
means lemma holds transform 
conjunction assumption 
definition lemma holds transform 
negation assume min 
lemma holds transform 
sequence assumption 
consider cases separately 
chapter 
expression transformation trivially lemma holds transform case 
trivially 
lemma holds transform case 
labelling impact semantics expression 
fact sequences correctly labelled addressed theorem 
temporal assumption 
min consider cases min assumption lemma holds transform case 
min lemma holds transform case 
induction lemma holds event expression 
lemma prove transformation preserves semantic meaning expression 
identify class expressions correctly detected limited memory transformation applied 
theorem 
event expression transform 
holds ii subexpression form holds 
iii sequence correctly detected limited memory 
proof 
follows trivially lemma 
ii subexpression form created sequence part transformation algorithm cases 
transformation algorithm case result call transform lemma implies second case trivially means iii trivially sequences extended form ii satisfy condition specialised sequence algorithm section 
example 
example consider expression 
calls transformation function returned tuples depicted 
see temporal restriction removed instances guaranteed instantaneous 
sequence labelled information specifying size corresponding variable exceed detection 
transform transform transform transform transform transform transformation 
example 
consider somewhat complex expression 
transformation shown illustrates important aspects algorithm 
analysed separately second argument negation detectable limited resources chapter 
expression transformation transformation algorithm applied 
negation allows algorithm propagate time restriction information argument second limit sequence 
sequence second argument negation exemplifies necessary add explicit time restrictions 
information passed earlier analysis need detect instances longer transforming expression yields information instances detected arbitrary length 
order limit sequence explicit temporal restriction added 
transform transform transform transform transform min transform transform transform transform transform transformation 
su cient criteria event expression guaranteed detectable limited resources applying transformation algorithm 
experiments theorem 
criteria holds subexpression form detected limited memory applying transformation algorithm 
occurs inside temporal restriction contain sequence conjunction operators 
proof 
transformation algorithm follows finite recursive call transform holds subexpression temporal restriction 
cases sequence part transformation algorithm resulting sequence label finite 
case transform return pair finite infinite return time values introduced sequences conjunctions 
cases sequence part transformation algorithm produce sequence finite label 
theorem ensures detected limited memory 
note su cient necessary criteria limited resource requirements 
expressions detectable limited memory meeting conditions example expression example 
experiments conducted experiments evaluate transformation algorithm 
expressions containing operators created randomly equal probability operators occur 
temporal restrictions random time values generated uniformly limit configuration represented expressions 
experiment chapter 
expression transformation experiment investigates class expressions detected limited resources transformation algorithm applied 
randomly generated expression apply transformation algorithm determine resulting expression belongs class maximum storage requirement number instances 
experiment performed primitive events value representing information minimum separation available 
experiment repeated half primitive events having values uniformly generated 
limited average memory memory table summary experiment 
primitive events value 
results appendix summary table table 
configuration percentage expressions resource requirements limited 
columns indicate th th th percentiles 
example value columns means expressions require fewer instances stored 
column contains average storage size expressions limited resources 
experiment indicates class expressions detected limited resources fairly large 
anticipated percentage depend range time variables information 
furthermore average storage requirements reasonably low configurations increase dramatically experiments limited average memory memory table summary experiment 
half primitive events values uniformly generated 
time value range increased 
introducing information minimum separation primitive events improved storage size roughly higher time value limit 
experiment earlier versions algebra limited resource requirements ensured providing temporally restricted sequence operator corresponding sequence form algebra thesis 
expression equivalent specialised sequence algorithm applied 
experiment restricted expressions sequences form ensures detection performed limited resources 
type expressions investigate ciency gained introducing transformation algorithm 
summaries results table table 
configuration tables percentiles previous experiment average storage requirement transformation algorithm applied 
additional results see appendix experiment shows class expressions syntactically constrained ensure expressions detectable limited resources average storage size significantly reduced transformation algorithm applied 
transformation transformation average average table summary experiment 
primitive events value 
transformation transformation average average table summary experiment 
half primitive events values uniformly generated 
chapter prototype implementation chapter describes event triggered prototype implemented java algebra integrated existing event framework window toolkit awt graphical user interface programming 
detection algorithm section directly implementation algebra time triggered reactive systems 
time instant current primitive events processed detected instances composite events handed reactive part system 
designing real time systems time triggered approach considered overly costly example applications expected rate primitive event occurrences low systems soft real time demands 
alternative event triggered approach execution fully driven arrival events 
results lower overhead cost periods low activity cost making di cult guarantee timely behaviour worst case scenario 
chapter intended describe best design implementation algebra resource conscious event triggered system 
prototype provides possibility test algebra practice highlight issues related event triggered setting 
chapter 
prototype implementation design decisions integrating algebra existing awt event handling provides straightforward way algebra application 
primitive events tied events graphical interface button pressed 
event expression treated way graphical component produces events meaning objects register want informed event defined expression occurs just register example button 
awt event mechanisms dynamic event producers consumers created deleted redefined runtime 
achieve seamless integration algebra want event expressions exhibit high level dynamicity 
application construct new composite event expressions existing expressions subexpressions runtime 
example defined expression defined ects transformation algorithm applied transformation subexpression depends expression occurs 
currently transformation algorithm part prototype implementation assumed application performs transformations constructing expressions necessary 
sharp implementation possibility dynamically construct composite expressions existing ones restricted allow transformation algorithm automatically applied 
expression represented objects corresponding individual operators central object governing expression 
result way handling occurrence propagates expression global information expression 
requires intricate communication scheme described section 
implementation limited java subset defined personal profile set java apis supports resource constrained devices 
system description class diagram describing main classes depicted 
time measured milliseconds java standard 
keep resource requirements low primitive events val system description disjunction conjunction sequence negation temporal primitive parent child file hll impl uml mdl den maj class diagram logical view main page class diagram event algebra package 
dark classes denote existing java classes interfaces 
chapter 
prototype implementation ues constructed 
occurrences violate ignored primitive event object 
default value information minimum separation available 
sequences created additional time value indicating maximum length instances second subexpression corresponding notation chapter 
value provided limited sequence algorithm maximum size storage structure computed minimum separation primitive events 
expression built instances classes corresponding respective operators associated parent child 
concrete example object structure 
temporal sequence disjunction listener button button primitive primitive file hll impl uml mdl den maj collaboration diagram logical view page object diagram describing representation expression connected buttons 
dark objects denote entities outside event algebra part system 
parent child navigable directions messages sent directions event processing 
causes problems expression longer interest application connected expression variable referring 
case fact system description objects reachable chain active object event sources java garbage collection unable destroy objects reclaim resources allocated expression 
solution problem provided weak 
object reachable active object weak object said weakly reachable may finalized garbage collector 
weak child parent ordinary opposite direction expression reclaimed share example primitive event currently active expression 
application subexpression part object structure weakly reachable reclaimed 
application responsibility identifying active expressions keeping explicit 
mentioned earlier due lack central object governing expression order event occurrence processed message passing parent child 
causes problems expressions form trees directed acyclic graphs 
vital correctness operator implementation arguments occur time information operator evaluated 
bottom evaluation original detection algorithm ensure require additional siblings separate object controlling order expression evaluated 
alternatives require changes expression runtime detected ensure sibling control structure respectively updated accordingly 
double traversal expression illustrated example 
example 
sequence diagram describes communication controlling evaluation expression occurrence causes chain messages sent child parent indicating expression evaluated 
message reaches node parents second traversal expression initiated 
operator recursively requests children compute current instance doing 
result post order traversal tree equivalent bottom traversal original detection algorithm respect correctness result 
traversal new occurrences passed chapter 
prototype implementation registered 
storing time message sent parent request received duplicated computation due common subexpressions avoided 
example message sent second parent ignored reaches sequence 
primitive disjunction sequence temporal listener primitive button file hll impl uml mdl den maj sequence diagram logical view page sequence diagram depicting communication expression occurs 
prototype algebra package available url www se projects hll index html site contains example java applet user enter event expressions generate primitive event occurrences investigate event expressions detected 
prototype code snippet exemplifies expression constructed prototype implementation 
declare variables primitive create primitive events new primitive sec new primitive sec create expression new disjunction new sequence tau new temporal alternatively new temporal new sequence new disjunction register object listener expression connect primitive events gui start detection button button code creating expression chapter related lot especially formal approaches composite event detection done context active databases 
addition event detection addressed way design large scale distributed applications additional middleware functionality technique monitor complex systems 
area artificial intelligence related issues represent reason time dependent knowledge investigated 
general systems described cover aspects considered thesis specification value constraints actions deal timing issues distributed systems 
summary focus primarily event specification detection functionality 
active databases area event algebras active databases passive databases react automatically situations arise outside database 
reactions specified called action rules eca rules stating certain event occurs condition satisfied action performed 
event part eca rule expressed event algebra allow database react complex events 
event expression language object database ode expressive power regular expressions allows de chapter 
related tection mechanism implemented finite state automata 
definition global totally ordered set primitive event occurrences implying primitive events occur simultaneously 
allow event occurrences carry values composite events occur restrictions values constituent events automata mechanism extended data structures store values events occurred 
active database event detection implemented petri nets 
event occurrences associated number parameter value pairs specified complex event occur constituent event occurrences value parameter 
allow simultaneous primitive event occurrences 
snoop event specification language active databases 
addition unrestricted operator semantics defines different event contexts called parameter contexts 
operators defined formally event contexts described informally 
detection mechanism trees corresponding event expressions primitive event occurrences inserted leaves propagate upwards tree cause complex events occur 
zimmer formal event context framework event algebras snoop ode systems compared 
highlight number ambiguities inconsistencies various approaches 
framework contexts defined orthogonal concepts 
instance selection policy defines instances considered unrestricted operator semantics 
instance consumption policy defines ects detection occurrences example instances allowed 
selection consumption policies explicitly applied individual constituent events making framework flexible event contexts defined terms occurrences initiate terminate composite instance 
event algebra follows framework 
defined formally temporal logic includes event contexts 
identify class composite events testing event equivalence decidable show testing implication undecidable 
general possible check events occurrence event implies event monitoring real time systems event occurs 
event detection mechanisms described provide assistance developer terms algebraic laws general little said memory time complexity associated detection complex events 
algebra thesis originally influenced snoop visible choice operators restriction policy 
ambition provide intuitive algebraic laws operator semantics di er extent main di erence lies way restriction applied 
approach restriction policy designed applied expression individual operators resulting complex semantics nested operators 
event monitoring real time systems formalised schema composite event detection including definition operations event contexts snoop schema defined mellin 
operators definitions parameterised event contexts facilitates formal reasoning operators di erent contexts applied requiring explicit definitions combination operator context 
mellin includes full event specification language snoop designed proposed schema 
language targets real time systems particular achieves predictable resource requirements ensuring resource bounds derived events expiration time combination operator context 
corresponds observation event form correctly detected bounded resources algebra 
transformation algorithm expressions form detected bounded resources 
similar algebra proposed thesis respects 
interval semantics galton temporal restriction ensure bounded resources 
addition full event specification language important distinction algebra designed provide intuitive documented algebraic laws 
liu real time logic define system composite events expressed timing constraints handled general tech chapter 
related niques monitoring timing constraints 
mechanism early detection timing constraint violation show possible derive upper bound length structures needed correctly detect event 
general time complexity detection certain subset expressions algorithm linear complexity possible 
show technique applied area active databases 
constraints defined event instances example allows definition event occurs ith instance occurs ith instance result technique highly expressive compared algebras event types thesis 
language tccs similar style process algebra ccs targeting eca paradigm 
triggering events defined processes possibly composed communicating subprocesses executing concurrently synchronise primitive events detect certain pattern 
event notification services large distributed systems designed architecture event subscribers publishers 
system having subscribers register interest number primitive event types perform filtering composite event detection functionality provided publisher 
subscribers register event patterns specified example event algebra 
publisher performs event detection notifies individual subscribers pattern detected 
reduces communication system potentially gives higher ciency publisher perform event detection multiple subscribers concurrently registered event patterns overlap 
systems type proposed 
target resource conscious applications particular generally provide resource bounds 
studied systems provide algebraic laws operators 
ready event notification service gruber contains simple event algebra registering composite events 

hayton describes object oriented system event algebra implemented nested pushdown automata 
event algebra developed hinze de knowledge representation signed suit general event notification service systems 
algebra provides time restricted sequence conjunction construct detect ith occurrence event 
framework zimmer algebra parameterised respect policies event instance selection consumption 
middleware software located client server application program network contain event detection functionality deal high volumes event occurrences 
applications single exceptional event example network failure causes burst low level failure event occurrences system 
ideally occurrences correlated reported single composite event occurrence 
sanchez event correlation language middleware platforms 
approach event expressions translated correlation machines type nested state machines represent state concurrent detection activities similar petri nets 
knowledge representation interval semantics suggested galton inspired area knowledge representation concepts similar event detection represent reason event occurrences 
general methods focus defining relating complex events allow logical inference facts event occurrences detecting composite events occur 
typically highly expressive algebraic properties address ciency detection bounded resource requirements 
allen interval algebra defines thirteen possible relations temporal intervals 
algorithm network interval relations updated extent checked inconsistencies new information added 
interval algebra temporal interval logic defined truth value predicates may vary time 
event calculus similar style temporal interval logic avoids non classical logic 
events expressed means horn clauses augmented negation failure executed prolog programs 
chronicle recognition addresses detection certain type event patterns 
chronicle disjunction event sequences chapter 
related possibly limits time events sequence 
deal complexity solution similar event contexts suggested non overlapping occurrences chronicle reported 
chapter algebra proposed thesis straightforward declarative semantics 
number algebraic laws facilitate formal reasoning support claim algebra operators behave intuition composition 
formal restriction policy designed define constraints implementation algebra satisfy 
restriction policy algebra semantics carefully designed ensure algebra ciently implemented 
show imperative detection algorithm analysed respect memory requirements execution time complexity 
identified class expressions detected limited memory 
algorithm algebraic laws described expressions transformed meet criteria limited memory requirements retaining semantic meaning 
prototype implementation combines algebra event system java 
primitive events associated event sources graphical user interface buttons text fields objects register interest events defined expressions way register ordinary event sources 
algebraic laws identify expressions equivalent respect algebra semantics restriction implementation correspond algebra semantics restriction applied 
essential establish extent algebraic laws reasoning behaviour implementation 
chapter 
designer straightforward semantics algebra algebraic laws reason meaning expression restriction policy ensures point time occurs algebra semantics detection algorithm detects exactly occurrences 
holds transformed equivalent expression holds result detecting guaranteed valid restriction 
time occurs exactly occurrences detected implementation detecting number research directions discussed 
concern extensions algebra terms new operators constructs consider larger perspective algebra concert rest reactive system 
evaluating algebra design event algebra limited resource requirements originally motivated demands real time embedded systems 
natural step evaluate proposed algebra respect type systems particular identify extensions basic set operations required allow typical events domain expressed 
interesting evaluate algebra respect applications domains example active databases middleware platforms 
delay operator temporal restriction construct define events timeouts define timeout event 
example define complement event occurrence followed time units 
allow type timeout events algebra extended delay operation denoted symbol similar mellin 
informally occurrence occurrence start time time units 
timeout event example defined 
extending algebra way requires formal semantics operator defined way general algebraic properties holds 
new properties operator proved ensure behaves intuition 
dealing values values play significant role current algebra 
values primitive event occurrences simply merged instances composite events constructed 
top level assume values handed event detection mechanism part system reacts detected event 
existing event algebras allow event expressions describe value dependent events 
example occurrence value lower occurrence followed occurrence value 
value dependent constructs include filtering event stream respect predicate values instances possibility assign values instances created 
supported algebra thesis 
course filters applied outside algebra primitive event streams result algebra handed reactive part system 
point view algebra filtered primitive simply regarded separate primitive ect algebra 
filters applied result restriction policy result unexpected results 
example imagine detecting expression applying filter specifying instances value 
consecutive occurrences values result detection restriction policy considers instances valid 
consider investigating filters expressions define filters proper algebraic properties 
useful provide means specify instances composite events created 
keeping values simpler instances computing new value change properties algebra long start times consistent current semantics increase ciency chapter 
implementation 
implementing algebra event algebra proposed thesis forms core event detection mechanism additional required turn sharp implementation 
general event detection mechanism provide interface defining primitive events system possibly including information minimum separation type definitions values 
interface allow new composite events registered detection removal existing events 
handling events common subexpressions facilitated transformation algorithm create duplicates common subexpressions allows cient detection 
applications useful allow existing expressions dynamically modified resetting stored information 
example mode change system ect time value temporal restriction events span mode change detected 
requires extensions transformation algorithm 
intend investigate event algebra combined existing languages specifically target reactive real time systems 
prototype implementation algebra personal profile subset java suitable resource constrained devices 
real time specification java describes additions java platform allow java programs real time applications 
examine event algebra extended java platform 
functional reactive language suite including robot programming language frob time varying behaviours discrete events 
cient implementation event algebra facilitate development formal reasoning programs 
timber object oriented reactive language purely functional core designed target embedded systems particular 
reasonably straightforward develop timber implementation algebra current object oriented java implementation 
possible direction combine algebra synchronous language esterel 
esterel built notion discrete time intervals number events occur reacted 
incorporating event algebra esterel program reacts occurrences composite events primitive separate pure event detection rest application logic hopefully increase readability provability programs 
bibliography allen 
maintaining knowledge temporal intervals 
communications acm 
allen ferguson 
actions events interval temporal logic 
journal logic computation october 

real time event control active databases 
journal systems software 
bailey 
expressiveness issues decision problems active database event queries 
database theory icdt th international conference volume lecture notes computer science pages london uk january 
springer 
berry 
esterel language primer 
cma inria sophia antipolis france release edition may 
berry 
foundations esterel 
plotkin stirling tofte editors proof language interaction essays honour robin milner pages 
mit press 
gosling hardin turnbull 
real time specification java 
addisonwesley 
carlson 
interval algebra restricted event detection 
kim larsen peter editors int 
workshop formal modeling analysis timed systems bibliography formats volume lecture notes computer science marseille france september 
carlson 
event detection algebra reactive systems april 
submitted 
carlson 
event detection algebra reactive systems 
technical report se dep 
computer science engineering university sweden april 
available www se 
carlson 
improved algebra restricted event detection 
technical report se dep 
computer science engineering university sweden february 
available www se 
carlsson kieburtz 
semantic layers timber 
proceedings asian symposium programming languages systems volume lecture notes computer science beijing china november 
springer verlag 
chakravarthy 
kim 
composite events active databases semantics contexts detection 
th international conference large data bases pages santiago chile september 
morgan kaufmann publishers 
chakravarthy mishra 
snoop expressive event specification language active databases 
data knowledge engineering 
ghallab 
situation recognition representation algorithms 
proceedings th international joint conference artificial intelligence pages chambery france 
christophe 
alarm driven supervision telecommunication networks ii line chronicle recognition 
annals telecommunications pages october 
cnet france telecom 
bibliography galton 
approaches event definition 
proc 
database expert systems applications th int 
conference dexa volume lecture notes computer science 
springer verlag september 
dittrich 
events active object oriented database system 
proc 
st intl 
workshop rules database systems rids edinburgh uk september 
springer verlag 
dittrich 
detecting composite events active database systems petri nets 
research issues data engineering ride pages los alamitos ca usa february 
ieee computer society press 
gehani jagadish shmueli 
compose system composite specification detection 
advanced database systems volume lecture notes computer science 
springer 
gruber krishnamurthy panagos 
architecture ready event notification service 
proceedings th ieee international conference distributed computing systems middleware workshop austin tx usa may 
hayton bacon bates moody 
events build large scale distributed applications 
proceedings acm sigops european workshop 
hinze 
composite events notification services application logistics support 
technical report tr freie universitaet berlin 
hinze 
parameterized algebra event notification services 
proceedings th international symposium temporal representation reasoning time manchester uk july 
springer verlag 
kowalski 
database updates event calculus 
journal logic programming january 
kowalski sergot 
logic calculus events 
new generation computing 
bibliography liu mok 
unified approach specifying timing constraints composite events active real time database systems 
th ieee real time technology applications symposium pages washington brussels tokyo june 
ieee 
mellin 
resource predictable cient monitoring events 
phd thesis department computer science university june 
mellin adler 
formalized schema event composition 
proc 
th int 
conf real time computing systems applications pages tokyo japan march 
sun microsystems 
personal profile 
java sun com products 
accessed apr 
milner 
communication concurrency 
prentice hall 
mok liu 
early detection timing constraint violation runtime 
th ieee real time systems symposium rtss pages washington brussels tokyo december 
ieee 
mok liu 
cient run time monitoring timing constraints 
proceedings third ieee real time technology applications symposium pages washington brussels tokyo june 
ieee 
nilsson courtney peterson 
functional reactive programming continued 
proceedings acm sigplan haskell workshop haskell pages new york october 
acm press 
monica 
objects garbage collection 
java sun com developer alt august 
nilsson hager 
functional reactive robotics exercise principled integration domain specific languages 
proc 
th acm sigplan conference principles practice bibliography declarative programming ppdp pages 
acm press october 
sanchez sipma zhang dill manna 
event correlation language semantics 
embedded software third international conference volume lecture notes computer science pages 
springer 
wan hudak 
functional reactive programming principles 
acm sigplan notices may 
yi 
real time behaviour asynchronous agents 
proceedings theories concurrency unification extension pages 
springer verlag new york 
zimmer 
semantics complex events active database management systems 
proceedings th international conference data engineering pages 
ieee computer society press 
appendix experimental results detailed results experiments described section 
expressions containing operators created randomly equal probability operators occur 
temporal restrictions random time values generated uniformly limit assume information minimum occurrence separation available primitive events 
experiment repeated half primitive events having values uniformly generated 
configuration represented expressions 
results diagrams storage size measured number instances represented axis axis indicates expressions require particular storage size 
configurations especially transformation applied required storage size exceeds instances expressions 
significant parts readable storage sizes included diagrams 
experiment expression transformation algorithm applied resulting expression analysed respect maximum number instances stored detection algorithms order detect expression correctly 
diagrams figures chapter experimental results results 
experiment second experiment restricted expressions sequences form ensures detection performed limited resources 
results figures 
contains diagrams storage size transformation algorithm applied respectively 
transformation applied number expressions low storage size requirements increases dramatically 
total number expressions diagrams corresponding decrease large storage sizes scattered large part axis noticeable diagrams 
main cause storage size decrease temporal restriction sequence operators decreased transformation algorithm applied 
sawtooth ect diagrams expressions transformation indicates odd storage sizes common sizes especially small expressions 
ect visible experiment prominent class expressions experiment 
brief explanation note primitive event requires odd number instances stored 
consider ways expressions odd storage size combined composite expression notice storage size resulting expression odd 
contributing factor temporal restrictions removed transformation algorithm 
imbalance larger class expressions experiment 
general expressions sequences result storage size subexpressions odd storage sizes occur temporal restriction storage size odd 
experiment storage size instances operators operators operators operators storage size instances operators operators operators operators experiment storage requirement primitive events value top bottom 
chapter experimental results storage size instances operators operators operators operators storage size instances operators operators operators operators experiment storage requirement half primitive events random values top bottom 
experiment storage size instances operators operators operators operators storage size instances operators operators operators operators experiment storage requirement top bottom transformation primitive events value 
chapter experimental results storage size instances operators operators operators operators storage size instances operators operators operators operators experiment storage requirement top bottom transformation primitive events value 
experiment storage size instances operators operators operators operators storage size instances operators operators operators operators experiment storage requirement top bottom transformation half primitive events random values 
chapter experimental results storage size instances operators operators operators operators storage size instances operators operators operators operators storage requirement top bottom transformation half primitive events random values 
