phase transitions classical planning experimental study jussi rintanen albert universit freiburg institut informatik georges hler freiburg im germany proceedings kr extended fig phase transitions solubility problem instances known types computational problems relevant artificial intelligence notably satisfiability problem classical propositional logic 
phase transitions classical planning received far attention 
bylander investigated phase transitions theoretically experimentally simplified planning algorithms shown soluble problems solved na hill climbing algorithm 
simplicity algorithms investigate hard problems phase transition region 
address exactly problem 
introduce new models problem instances eliminating trivially insoluble instances bylander model restricting class problem instances 
perform experiments behavior different types planning algorithms hard problems phase transition region showing planner general purpose satisfiability algorithms outperforms planners heuristic local search 
existence phase transitions types problems artificial intelligence known papers huberman hogg cheeseman kanefsky taylor 
detailed investigation phase transitions satisfiability problem classical propositional logic carried mitchell selman levesque 
space problem instances fixed number propositional variables consists sets literal clauses 
space certain phase transition phenomena empirically analytically ratio number clauses number propositions approaches probability formula satisfiable increases 
similarly ratio approaches probability formula satisfiable decreases 
ratio probability far probability far 
phase transition coincides difficulty testing satisfiability formula known algorithms take exponential time size formulas clauses propositions ratio algorithms runtimes decrease sharply going direction 
easy pattern phase transition region 
similar phase transitions easy hard easy patterns discovered difficult computational problems including classical planning 
bylander carries investigation phase transitions classical planning 
shows model sampling space problem instances increasing number operators changes problem instances certainly plan certainly having plan 
bylander shows problem instances close phase transition region solved efficiently simple planning algorithms 
plans easy cases tested algorithm tests simple syntactic property problem instances 
similarly plans problem instances high number operators simple shot hill climbing algorithm search 
bylander carry empirical investigation actual computational difficulty realistic planning algorithms phase transition region algorithms shows effective outside phase transition region solve problems phase transition region 
phase transitions classical planning closely related properties random graphs bollob 
classical planning problem reachability problem transition graph encoded problem instance 
shown random graphs probability edges nodes increases certain probability giant component set nodes path nodes emerges consisting nodes graph 
corresponds having set operators plan initial state goal state 
similarities random graphs important differences 
difference random graphs transition graphs planning directed 
second succinct representation transition graph induces neighborhood structure random graphs example number state variables changed operator bounded edges state state differs state variables 
results random graphs directly applicable ing properties succinctly represented planning problems 
complement bylander pioneering phase transitions planning 
bylander analysis focused exclusively easy problem instances outside phase transition region 
empirically investigate difficult problem instances inside phase transition region 
propose improvement bylander method sampling space problem instances propose new model requirement state variable occurs number time operator effect 
random sampling problem instances section discuss model randomly sampled problem instances proposed bylander call model refinements model called model model model parameterized parameters characterizing size problem instances terms number state variables number operators properties operators number literals precondition number literals effect 
parameters description goal states 
combination parameters represents finite class problem instances 
classes finite number instances relatively small parameter values way investigated randomly samples testing computational properties drawing general members class general 
interest classes problem instances try conclude computational difficulty basis parameter values describing 
example experiments suggest computational difficulty problem instances model planners experimented peaks ratio number operators number state variables assuming certain fixed values rest parameters 
approach allows generate unbounded number problem instances difficult instances experimenting different kinds planning algorithms concluding properties algorithms respect instances having certain properties 
define models problem instances continue presenting results experiments performed different types planning algorithms 
model bylander bylander proposes models sampling space problem instances deterministic planning variable model number preconditions effects vary fixed model constant number preconditions effects 
models analogous constant probability model fixed clause length model propositional satisfiability selman mitchell levesque 
consider fixed model 
shown bylander deterministic planning strips operators having preconditions effects pspace complete just general planning problem cases preconditions effect precondition effects easier 
preconditions effects reduced case preconditions effects fixed variable model cover problem instances propositional planning 
definition model positive integers class cb consists problem instances 
set boolean state variables 
set operators conjunction literals occurrence state variable conjunction literals occurrence state variable 
initial state assignment state variables 
describes goal states 
partial assignment truth values state variables state variables assigned value value differing value initial state experiments consider case preconditions effects 
appears provide challenging problems class preconditions 
consider goal state descriptions describe exactly state values state variables state different values initial state 
classes problem instances consider cb different characterize number state variables operators may cn real number 
ratio convenient talking problem instances different sizes 
hoped bylander model yield phase transition fixed independent number state variables turned case 
problem bigger problem instances fixed probability goal literals effect operator goes probability plan existence simultaneously goes 
shown follows 
essentially choose cn operator effects literals effects cn operators 
ways choosing operator effects correspond total functions cn element set element set 
goal literals true operator corresponding function case preconditions reduced case preconditions type reductions introduce dependencies state variables 
result match instances computational properties differ 
surjection 
increases function surjection 
sets 
number surjections number partitions element set non empty parts stirling number second kind 
get asymptotic proportion surjections functions 
divide number surjections total number functions get approaches cn limit expression constant 
sets increase size infinitesimally small fraction functions surjections 
means number state variables increases constant cn operators suffices keeping probability plan existence increasing number operators needed keep probability having operator making state variable true high 
required ratio operators state variables increases logarithmically see bylander theorem characterize flaw bylander model sampling space problem instances especially bigger problem instances operators dominating reason plans 
see gent walsh discussion flaws models computational problems 
bylander intentionally includes trivially insoluble instances analysis algorithm detects exactly instances 
model define new model random problem instances trivially insoluble problem instances bylander model 
eliminate trivially insoluble instances impose restriction literal occurs effect operator 
definition model positive integers class cc consists problem instances cb occur effect operator model eliminates problem instances recognized insoluble algorithm bylander plan tests 
goal literals occur operator uninteresting reason plans 
model way operators effects chosen model fixed model bylander close resemblance fixed clause length model sampling space cnf formula proposed mitchell randomly choose fixed number state variables probability negate 
propositional satisfiability lead problems saw earlier operator effects 
proposition occur clause mean clause difficult satisfy planning problem state variable occur effect immediately means certain sub goals impossible reach 
similarly occurrence guaranteed model state variables occur effects small number times bigger problem instances similar phenomena arise state variable true operator precondition true operator precondition 
think interesting subclass instances choose effects independently literals clauses chosen fixed clause length model propositional satisfiability 
leads model idea state variable occurs operator effect approximately number times number times positively negatively 
result model trivially insoluble instances model model 
definition model positive integers class ca consists problem instances cb occur effect tm tm operators 
experimental analysis phase transition complete algorithms section experimentally analyze location insoluble soluble phase transition models randomly generated problem instances evaluate different types planning algorithms hard problem instances phase transition region 
planners 
constraint planner translation propositional logic finds plans satisfiability algorithm rintanen niemel 
refer planner sp 
satisfiability planning approach introduced kautz selman 
sp finds plans guaranteed minimal parallel length sequentially tries possible parallel plan length shows plans length continuing length 
shortest parallel plan having length necessarily correspond shortest sequential plan parallel plan length higher consisting smaller number operators 
sat solver version ryan 
solver sophisticated clause learning efficient sat solvers including zchaff 
runtimes report sums solution times reported include time spent front produces formulae 
second popular family planning algorithms distance heuristics local search bonet geffner ff planner hoffmann nebel 
third lpg planner gerevini similar ideas satisfiability planning planning graph graphplan algorithm blum furst uses local search increase plan length sequentially 
lpg ff chosen performance standard benchmark sets considered represent state art respect benchmark sets 
part investigation produced large collection soluble problem instances state variables tested runtime behavior planners 
plan tests carried complete bdd planner traverses state space breadth finds shortest existing plans reports plans exist 
runtime planner proportional number reachable states solved problem instance minutes 
planners general effective test plan 
second part investigation described section produced bigger problem instances state variables 
planners sufficiently efficient solve large fraction bigger instances restricted investigation bigger problem instances planner 
bigger problem instances perform complete solubility tests runtimes bdd planner high number state variables higher 
model produced soluble problem instances ratio operators state variables model 
smaller ratios involved testing solubility model model problem instances bdd planner complete solubility test 
restrictions available cpu resources prevented finding soluble instances 
diagrams depict empirically determined phase transition planning state variables corresponding runtimes planners 
times ghz intel xeon processor kb internal cache 
diagrams depict average plan lengths planners problem instances state variables 
diagram depicts plan length number operators number time steps parallel length parallel plans produced sp planner 
discussion results state variables section discuss solubility runtime data shown diagrams 
phase transition phase transition curve depicted matches expectation problem proportion soluble instances parallelism ratio steps length model parallel plan lengths phase transition region solubility sp length sp steps parallelism ratio ratio operators state variables number operators length time steps parallel length plans sp problem instances state variables stances turn certainly insoluble certainly soluble number operators grows 
change insoluble soluble model abrupt 
significant numbers soluble instances emerge variables ratio earliest possible smaller number operators effects impossible goal literals true certain solubility reached slowly ratio solubility growing slowly 
model hand transition steeper solubility probability reached soon ratio 
think difference due presence state variables occurring effect times model difference model easy hard easy pattern planner runtimes transition hard easy problem instances ratio operators state variables grows 
transition easy hard instances left curves ratio clear 
ratio soluble instances data runtimes testing planners general effective test 
presumably determining instances operators computationally easy 
difficulty model peaks operators variables ratio model ratio sp looking data bigger instances 
ff runtime curve suggest curves peak respectively ratios 
curves number instances ff lpg solve time limit minutes depicted suggest ratios model model difficult ones 
possibly ff slightly ratios difficult instances solved time limit high runtime contributes peak runtime curve 
numbers operators steps proportion soluble instances model phase transition region planner runtimes solubility ff lpg sp ratio operators state variables average time find plan secs proportion soluble instances model phase transition region planner runtimes solubility ff lpg sp ratio operators state variables plan existence phase transition passage hard easy planner runtimes soluble problem instances state variables 
averages include number problem instances solved minutes 
proportion soluble instances model plan lengths phase transition region solubility shortest ff lpg sp ratio operators state variables average plan length proportion soluble instances model plan lengths phase transition region solubility shortest ff lpg sp ratio operators state variables average shortest plan lengths phase transition region problem instances state variables average lengths plans planners 
difference satisfiability propositional logic models peak difficulty appear near cent solubility point 
sp runtimes lower lpg ff runtimes 
model instances runtime minute highest runtime model instances seconds 
model appears difficult instances exceeding time limit minutes runtimes seconds seconds ratio 
problem instances solved fraction second medians seconds ratios models lpg solves instances immediately high percentage problems ratios model ratios model solved minutes smaller percentage phase transition region model model 
included curves average lpg runtimes higher depicted 
ff runtimes vary lot 
instances solved quickly instances solved barely time bound seconds instances model model solved seconds included averages 
model ratios model 
depicts proportion soluble variable instances model remained unsolved lpg ff minutes 
give curves depicting minute success rate soluble instances variables 
state variables ff success rate close cent state variables cent hardest instances percent easy ratio 
distribution runtimes planners known heavy tail gomes runtimes concentrate average substantial number instances runtime average :10.1.1.21.1421
lpg uses fast restarts average time find plan secs average plan length proportion soluble instances model success rates ff lpg solubility ff ff ff lpg lpg lpg ratio operators state variables percentage soluble problem instances state variables ff lpg solved minutes 
state variables curves depict proportion number instances solved ff lpg number instances solved sp 
success rates state variables upper bound sp missed soluble instances 
proposed gomez technique weakening heavy tail runtime distributions single instances ff ff fares better lpg 
average characterization runtimes distribution runtimes heavy tail case meaningful gomes decided median state variable instances easy solve median completely ignores difficult instances distinguish planners problem instances size :10.1.1.21.1421
problem heavy tailed distributions dependency sample size general samples taken higher average increased likelihood obtaining extremely difficult instances 
obtain smooth runtime curves tested far higher number problem instances 
plan lengths plan lengths follow interesting pattern 
lengths shortest existing plans peak left curve followed slow decline 
expect instances short plans operators choice choosing operators leading short plans case 
number operators increased asymptotic length shortest plans times number state variables high probability sequence operators goal literals true applicable starting initial state 
state variable problems model ratio shortest plans average contain operators times number state variables 
plan lengths different planners guaranteed produce shortest plans follow pattern shortest plans exception percentage instances solved plan length peak left slightly 
constraint planner sp produces plans relatively close shortest ones average lengths times shortest difficult problems times easiest model 
guarantee shortest parallel plans implies number operators plans high 
ff plans twice optimal difficult problem instances lpg plans times optimal 
lpg plan lengths model appear peak higher operators variables ratio sp ff 
relations plan length number time steps plans produced sp depicted expect easier problems operators plans choose high number plans small number time points 
constrained problems average operators time point increases easiest problems 
experimental analysis phase transition higher number state variables ability ff lpg find plans hard problem instances declines quickly number state variables exceeds experiments state variables sp 
sp test considered problem instances insoluble plans minute evaluation formulae plans lengths fixed upper bound length 
may missed plans timeout consider sufficiently long plans 
plan length upper bound substantially higher average lengths plans plan length restriction smaller source missed soluble instances 
phase transition bigger problem instances depicted 
solubility test fail direction plan longer tried terminate run high runtime actual solubility curve may higher able determine sp 
account sided error detecting solubility obvious phase transition region narrower change insoluble soluble steeper number state variables increases 
clear especially curve model probability solubility reached earlier problem instances state variables 
curves compatible idea sp capable solving large fraction bigger difficult soluble instances state variables show case need efficient algorithms determining 
average runtimes solved instances 
median runtimes solved instances 
heavy tailed character distribution runtimes clear runtime curves 
ratios presence small number difficult instances causes curve peak average runtime proportion soluble instances model phase transition bigger problems solubility sp solubility sp solubility ratio operators state variables proportion soluble instances model phase transition bigger problems solubility sp solubility sp solubility ratio operators state variables phase transition problem instances state variables determined sp planner 
problem instance solved minutes shown plans maximum length considered insoluble 
proportion soluble instances model runtimes bigger problems solubility sp runtimes sp runtimes sp runtimes ratio operators state variables average time find plan secs proportion soluble instances model runtimes bigger problems solubility sp runtimes sp runtimes sp runtimes ratio operators state variables average sp runtimes problem instances state variables state variables appears ratios close higher state variables similarly curves state variables 
curves smooth solved moderate number instances ratio depending ratio smaller ratios number soluble instances small 
average plan lengths depicted 
lengths grow slightly faster increase state variables 
discussion results standard experimental methodology planning problem scenarios resembling potential real world applications simplified forms transportation planning simple forms scheduling simplified control problems resembling showing autonomous robotics similar areas 
details see mcdermott fox long 
appear identify inherently difficult problems problem instances 
fact standard benchmarks solvable low polynomial time simple problem specific algorithms computationally easy solve 
believe properties benchmarking strongly affects kind algorithms considered bad 
empirical results computational behavior algorithms complement obtained standard benchmarks 
planners heuristic local search popular years mainly success solving standard benchmark sets 
results suggest heuristic local search far weaker difficult problems differ standard benchmark problems 
heuristic search planners fare worse satisfiability planning random problem instances phase transition region fare relatively better standard benchmarks 
average time find plan secs proportion soluble instances proportion soluble instances model median runtimes bigger problems solubility sp runtimes sp runtimes sp runtimes ratio operators state variables median time find plan secs proportion soluble instances model median runtimes bigger problems solubility sp runtimes sp runtimes sp runtimes ratio operators state variables median sp runtimes problem instances state variables model plan lengths bigger problems solubility optimal lengths sp lengths sp lengths sp lengths ratio operators state variables average plan length proportion soluble instances model plan lengths bigger problems solubility optimal lengths sp lengths sp lengths sp lengths ratio operators state variables sp plan lengths problem instances state variables ff heuristic local search state space 
main reason popularity heuristic local search discovery polynomial time computable domain independent distance heuristics standard benchmarks easier solve bonet geffner 
improvements benchmarks obtained ad hoc techniques inspired benchmarks hoffmann nebel techniques address difficulties showing planning problems generally 
weakest point class planners distance heuristics fail drive search goal state quickly may huge state space search takes place explicitly enumerating states 
planners scale badly difficult problems 
satisfiability planning heuristic planners traversing state space ability reason values individual state variables different time points 
reasoning satisfiability algorithms effective general purpose techniques boolean constraint propagation clause learning 
way problem representation propositional logic allows inferences classes plans states represented partial assignments propositions rintanen 
example plan search inferred exist plans state variable having certain value certain time point 
possible having explicitly enumerate parts state space test reachability states initial state 
presumably kind reasoning greatly helps solving inherently difficult problems complicated operator interactions 
lpg problem representation shares properties representation planning satisfiability problem lpg utilize properties representation extent general purpose satisfiability algorithms 
example lpg uses forms constraint propagation op propagation gerevini restricted way 
important question implications results planning generally similarities difficult planning problems arising practical applications difficult median time find plan secs average plan length problems randomly sampled space problem instances 
practically relevant difficult problems surface structure quite different randomly sampled problem instances techniques developed planning symmetry reduction rintanen employed eliminating surface structure yield structured core problem instance 
similarly techniques satisfiability algorithms boolean constraint propagation attempt get past surface structure 
remains hard search problem structural properties take advantage 
unstructured problems may close randomly generated problem instances 
notice algorithms specifically designed solve problems randomly sampled space problem instances survey propagation algorithm parisi similar local search algorithms propositional satisfiability seitz weak solving instances practically interesting problem classes 
conventional satisfiability algorithms specialized solving hard random problem instances dubois 
sp planner rintanen niemel solves standard planning benchmarks efficiency comparable cases exceeds planners developed kinds benchmark problems mind 
related addition study bylander works directly related phase transitions planning slaney thi baux 
investigate relationships difficulty optimization corresponding decision problems 
example traveling salesman problem blocks world planning represented framework classical planning 
concentrated problem finding arbitrary plan 
corresponding optimization problem finding shortest cheapest plan decision problem finding plan cost relevant perspective applications 
important open problem analytic derivation tight upper lower bounds phase transition region 
suggested research propositional satisfiability phase transition experiments phase transition region increasingly narrow number state variables increases 
analogously sat phase transition presumably asymptotic phase transition point problem instances turn instantaneously insoluble soluble number operators increased 
techniques easily yield upper bounds propositional satisfiability phase transition directly applicable planning 
plan existence problem decidedly graph theoretic character separates satisfiability problem propositional logic 
upper bounds derived bylander applicable model lower bounds bounds bylander derived loose 
experimental evaluation complemented analysis techniques determining plans topic properly addressed planning research 
proposed approaches problem outside planning satisfiability testing appear best candidates try planning mcmillan sakallah 
blum furst 
fast planning planning graph analysis 
artificial intelligence 
bollob 
random graphs 
academic press 
bonet geffner 
planning heuristic search 
artificial intelligence 
bylander 
computational complexity propositional strips planning 
artificial intelligence 
bylander 
probabilistic analysis propositional strips planning 
artificial intelligence 
cheeseman kanefsky taylor 
really hard problems 
mylopoulos ed proceedings th international joint conference artificial intelligence 
morgan kaufmann publishers 
dubois 
backbone search heuristic efficient solving hard sat formulae 
nebel ed proceedings th international joint conference artificial intelligence 
morgan kaufmann publishers 
fox long 
third international planning competition results analysis 
journal artificial intelligence research 
gent walsh 
np phase transition 
technical report apes university strathclyde department computer science 
gerevini 
lpg planner local search planning graphs action costs 
ghallab hertzberg traverso eds proceedings sixth international conference artificial intelligence planning systems 
aaai press 
gomes selman crato kautz 
heavy tailed phenomena satisfiability constraint satisfaction problems 
journal automated reasoning 
hoffmann nebel 
ff planning system fast plan generation heuristic search 
journal artificial intelligence research 
huberman hogg 
phase transitions artificial intelligence systems 
artificial intelligence 
kautz selman 
pushing envelope planning propositional logic stochastic search 
proceedings thirteenth national conference artificial intelligence eighth innovative applications artificial intelligence conference 
menlo park california aaai press 
mcdermott 
ai planning systems competition 
ai magazine 
mcmillan 
interpolation sat model checking 
hunt jr somenzi eds proceedings th international conference computer aided verification cav number lecture notes computer science 
parisi 
analytic algorithmic solution random satisfiability problems 
science 
sakallah 
computing vertex eccentricity exponentially large graphs qbf formulation solution 
giunchiglia eds sat theory applications satisfiability testing number lecture notes computer science 
rintanen niemel 
parallel encodings classical planning satisfiability 
report albert universit freiburg institut informatik 
rintanen 
planning algorithm directional search 
cohn schubert shapiro eds principles knowledge representation reasoning proceedings sixth international conference kr 
morgan kaufmann publishers 
rintanen 
symmetry reduction sat representations transition systems 
giunchiglia muscettola nau eds proceedings thirteenth international conference planning scheduling 
aaai press 
ryan 
efficient algorithms clause learning sat solvers 
masters thesis simon fraser university 
seitz 
efficient local search method random satisfiability 
electronic notes discrete mathematics 
selman mitchell levesque 
generating hard satisfiability problems 
artificial intelligence 
slaney thi baux 
hardness decision optimisation problems 
prade ed proceedings th european conference artificial intelligence 
john wiley sons 
