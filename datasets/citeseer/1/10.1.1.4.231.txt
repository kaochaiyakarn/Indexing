liberty structural specification language high level modeling language component reuse neil david august departments computer science electrical engineering princeton university princeton nj princeton edu rapid exploration design space simulation models essential quality hardware systems research development 
despite striking commonalities hardware systems designers routinely fail achieve high levels reuse models constructed existing general purpose domain specific languages 
lack reuse adversely impacts hardware system design slowing rate ideas evaluated 
presents examination existing languages reveal fundamental limitations regarding reuse hardware modeling 
understanding solution described context design implementation liberty structural specification language lss input language publicly available high level digital hardware modeling tool called liberty simulation environment 
lss language enable low overhead reuse simultaneously supporting static inference hardware structure flexibility parameterizable structure 
lss introduces new type inference algorithm new programming language technique called specialization manner analogous type inference customizes reusable components statically inferring structural properties specified manually 
categories subject descriptors simulation modeling simulation languages simulation modeling model development model ing methodologies general terms design languages keywords liberty simulation environment lse liberty structural specification lss component reuse simulator construction structural modeling type inference specialization permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june washington dc usa 
copyright acm 

motivation digital hardware design early design decisions significantly impact quality system produced 
current analytical models fail provide guidance due complexity systems 
producing measuring candidate hardware prototypes test early design decisions prohibitively expensive 
result designers turn high level microarchitectural level software simulation models feedback iteratively refining critical early design decisions 
quality resulting high level design directly related rate high level design candidates explored 
just reuse software development significantly improves programmer efficiency reuse high level design modeling reduces model specification time dramatically increasing exploration rate design candidates 
reuse particularly attractive high level hardware design exploration replete opportunities employ behaviors arbitration queuing extremely common wide range hardware systems common structures exist designs exploration 
unfortunately current modeling systems support reuse require significant effort achieve reuse negating potential benefits 
consequently model construction modification times systems order months years severely limiting range alternatives explored early design phases negatively impacting final design quality 
general purpose microprocessor research design community manually coding simulator sequential programming language common method highlevel modeling method allow component reuse notion hardware component map type modular block 
concurrent structural modeling tools alternative modeling hardware components concurrently executing software components communicate statically connected communication channels 
modeling paradigm matches structural composition concurrent processing hardware components component reuse possibility 
systems fall categories static concurrent structural systems structural object oriented programming oop systems 
unfortunately described specification style systems forces trade ease building reusable components ease reusable components 
cases difficulties building reusable components discourage reuse practice 
th international symposium computer architecture papers simulation technique 
block block block input input output structural addition 
instantiate adder instance adder connect ports block input block input output block structural code component adder void compute int receive input receive input add send output behavioral code structural specifications 
hybrid model specification style allows easy construction easy flexible reusable components 
presents design implementation liberty structural specification language lss highlevel hardware modeling language uses hybrid specification style 
style opens door techniques possible limited utility static structural systems useful structural oop systems 
presents implementation techniques lss structural type inference presence component overloading parametric polymorphism specialization new technique reduce overhead flexible components 
techniques required development novel algorithm type inference unique evaluation semantics specialization 
remainder organized follows 
section provides overview high level concurrent structural modeling 
section identifies key attributes fully supporting componentbased reuse surveys existing modeling systems identify attributes missing 
sections describe design lss language including implementation challenges solutions challenges 
section summarizes experience lss language emphasizing applicability techniques described 
section discusses related section concludes 

concurrent concurrent structural systems general systems computation encapsulated concurrently executing system components communicate values sending receiving data predefined communication network 
typically component defines set input output ports continuously computes outputs current values inputs internal state 
components input ports connected particular output port receive value sent accordingly update internal state outputs 
synchronous digital hardware state update synchronized global clock example concurrent structural system 
concurrent static structural object oriented capability theory practice theory practice parameters structural algorithmic polymorphism parametric overloading static analysis instrumentation table capabilities existing methods systems 
structural modeling systems natural way model hardware purpose 
shows structural model adds numbers 
shows possible textual description structural model 
high level concurrent structural models focus primitive components port relation function adder component compute specified conventional function invocation code 
despite code particular component communication components occurs structurally 
distinction clearly separates functionality communication hallmark systems 
continuing earlier example shows possible description adder component behavior 

reuse existing methods high level concurrent structural modeling languages certain capabilities fully support component reuse 
languages support parameterizable components ability customize component properties parameters 
example cache component replacement policy selected enumerated set predefined policies 
structural customization ability customize hierarchical structure parameters 
allows existing components reused hierarchically create flexible component 
example customizing mix functional units bypass connection specification structurally specified reusable cpu core 
algorithmic customization ability inherit augment behavior existing component algorithm 
example customizing arbitration logic inside bus arbiter component 
polymorphism ability support reuse types 
parametric polymorphism ability create component models datatype independent fashion 
examples queues memories crossbar switches support types 
component overloading ability component implementation automatically selected family implementations support different datatypes 
note function overloading argument types select function implementation differs component overloading port connection types select component implementation 
example alu implementation family operates integer floating point numbers 
static model analysis ability analyze model optimization user convenience 
example type inference resolve polymorphic port types 
instrumentation ability insert probes model gen delays delays delays hole delayn block diagram stage delay chain specification 
modifying internals component 
allows models reused satisfy different data collection needs 
examples instrumentation performance measurement debugging visualization 
subsections relate abilities existing modeling methodologies static structural modeling structural modeling oop 
analysis identify desirable features highlight potential pitfalls methods 
insight gained guide design lss language remainder 
table discussion 
static structural modeling static structural modeling systems concurrent structural modeling systems statically describe model structure 
models systems interconnected components augmented component parameterizations typically tools drag drop graphical user interfaces construct models 
example tool ptolemy ii interface 
systems support features described 
components typically export parameters customized 
depending underlying language implement components inheritance may allow algorithmic customization 
systems support polymorphism type inference resolve polymorphism 
models instrumented aspect oriented programming aop weave instrumentation code structure described model 
unfortunately fact specifications static implies fundamental limitation static structural modeling systems 
consider structure shown 
static structural systems explicitly instantiate blocks dotted box 
chain blocks wrapped flexible hierarchical component length chain parameter static structural systems provide mechanism iteratively connect output block input parametric number times 
result permit flexibility simple hierarchical design discarded favor complex implementation primitive component 
implementing primitive component simple example may difficult complex examples controlling mix functional units processor model implementation monolithic primitive component overwhelming 
note static structural modeling systems may provide idioms common patterns chained connections 
fundamental lack general mechanisms parametrically programmatically control model structure remains 
structural modeling oop promising concurrent structural modeling approach taken systemc allows flexible primitive hierarchical components augment existing oop language concurrency class library support structural entities ports connections 
objects take place compo class delayn public public delay delays delayn int int new new delays new delay connect delays delays connect delays delays connect structural oop pseudo code stage delay chain 
nents simulator structure created run time code instantiates connects objects 
basic features object oriented languages provide capabilities described section 
object behavior customized instantiation parameters passed class constructors 
algorithmic customization supported class inheritance 
oop language added structural entities support parametric polymorphism type neutral components modeled 
component instantiation connection occur run time oop language basic control flow primitives loops statements algorithmically build structure system 
code encapsulated object internal structure easily customized structural parameters producing flexible hierarchical components 
example cycle delay component seen section built composing single cycle delay components shown pseudo code 
unfortunately run time composition structure provides component flexibility precluding static analysis model structure 
flexible components cumbersome 
example parametric polymorphism resolved explicit type instantiation user constraints type inference obtained model structure unavailable compile time 
ideally connecting output floating point register file overloaded alu automatically select alu implementation handles floating point data 
component overloading possible user codify particular alu implementation instantiation statement compiler automatically determining connectivity 
additionally parameters controlling extent port arrays specified explicitly user compiler automatically inferring extents connectivity 
implementing instrumentation orthogonal machine specification best cumbersome 
powerful techniques aspect oriented programming desired join points locations instrumentation code inserted parts model structure known run time 

lss language modeling methodologies discussed section section possessed capabilities necessary reuse lss interpreter analysis engine static code generator typed netlist lss specification executable simulator component library netlist lss compiler lss module description component runtime behavior overview lss compilation 
concurrent structural modeling tool 
unfortunately systems forced trade ability algorithmically control structure ability statically analyze 
liberty structural specification language lss language designed specify structure concurrent structural systems obviates trade combining desirable attributes existing methodologies 
allow algorithmic specification structure lss possesses common imperative control flow constructs addition structural modeling constructs 
constructs model structure built code similar 
modeling oop lss code executed compile time lss code describes model structure run time behavior 
lss code executed compile time model structure known statically analysis 
shows lss compilation process 
phase compilation lss specification undergoes interpreted execution build netlist represents static structure model 
netlist generated various static analyses performed netlist 
current implementation lss compiler analyses include structure type inference described section static concurrency scheduling 
static analysis code generator combines netlist leaf hierarchical component behavior specifications applies non structural customizations behaviors emits executable simulator binary 
refer language leaf module behaviors specified behavior specification language bsl section describes lss language features support desired capabilities listed section 
additionally section describe language sections discuss lss type inference problem implementation novel technique called specialization parameter value inference 
note lss designed algorithmic specification structure design decisions features differ traditional programming languages 
design decisions implications discussed section 
lss modules lss components created component templates analogous classes structural oop modeling called modules 
lss independent bsl component written lss particular bsl necessarily compatible component written lss bsl 
consequence independence discussion bsl details scope 
module delay parameter initial state int int int tar file delay tar bsl specific parameters lss module declaration leaf delay element 
instance delay instance delay 
initial state 
sample delay module 
body lss module specifies component parameterization interface communication interface constructor 
types modules lss 
leaf modules simple modules defined composing behavior modules 
second hierarchical modules complex modules obtaining behavior composition customization existing components 
sections describe leaf hierarchical modules parameterization 
leaf modules shows declaration leaf module named delay 
line declares parameter named initial state type int assigns parameter default value 
module parameters set user instantiating module customize behavior 
parameter values forwarded bsl code customize module behavior 
lines define communication interface module 
lines define input port named output port named 
computation links data received port data produced port specified externally leaf modules 
value internal parameter tar file shown line tells code generator find run time behavior instances module 
note internal parameters module parameters overridden user module 
shows example instantiating parameterizing delay module 
lines instantiate delay module create module instances named respectively 
line gives initial state parameter instance value 
line connects output input 
notice initial state parameter instance set 
assignments omitted parameter takes default value defined module body line 
notice figures parameters lss referenced nominally specified instantiation statement initial state referenced line positional argument list part instantiation statement 
choices flexible modules typically parameters 
nominal parameter clarify models parameter names describe parameter purpose better position argument list 
similarly flexible placement parameter assignment allows groups related parameter assignments component component component hierarchical component composition 
module delayn parameter int var delays instance ref delays new instance delay delays var int delays delays delays delays lss module declaration stage delay chain 
different module instances located scattered module instantiation location 
features flexible components parameters easier encouraging construction 
hierarchical modules addition leaf modules lss supports creation complex modules composing behavior existing modules new hierarchical modules 
hierarchical modules just leaf modules define parameterization communication interface defining ports parameters 
leaf modules behavior module specified instantiating modules connecting instances module input output ports see 
recall allowing parameters control structure modules requirement outlined section 
allow lss uses imperative control flow constructs guide sub component instantiation parameterization connection 
understand features consider lss code shown 
note lss version pseudo code shown 
code defines module models arbitrary depth delay pipeline built delay modules 
module delayn declares single parameter line controls number stages pipeline 
parameter structural parameter declaration body module read parameter guide created connected parameterized 
line create array instances delay module named delays bsl 
notice length array value enclosed brackets line controlled parameter lines connect delay instances chain shown 
notice general purpose loop causes length connection chain vary parameter notice loop able instance gen source instance hole sink instance delay delayn delay gen delay delay hole lss specification stage delay pipeline 
capture parameterized idiomatic connection pattern example lss supports constructs including loops conditionals permit general algorithmic specification structure 
allows non idiomatic connection pattern created parameterized 
shows delayn module create stage delay pipeline 
module instantiated line parameter set line instance connected lines 
block diagram system shown 
gen hole instances just provide data consume data pipeline respectively 
flexible communication interfaces module instances communicate input output ports defined modules instantiated 
facilitate scalable interfaces register file customizable number read ports port lss variable length array port instances 
connecting ports instances communicate connects port instances 
port instance number specified inferred interpreter 
port module port width number connections port available module body parameter 
parameter automatically set counting number connections port 
modules width parameter parameter customize components created 
automatic customization instance specialization discussed detail section 
lss supports leaving ports unconnected ports zero width 
width parameter module detect port connected customize behavior accordingly 
unconnected port semantics allow modules rich communication interfaces burdening user responsibility connecting ports 
feature may tempting replicate simple functionality reuse complex module ports unnecessary situation 
unconnected port semantics especially useful refining model precise model initial refined model reuse components initial model relies unconnected port semantics refined model connects ports achieve specific desired behavior 
customizing component computation lss provides mechanisms customize computation existing modules algorithmic customization increasing reusability 
mechanism simply wrapping existing module module adding modules computation paths customize behavior 
demonstrates done 
computation paths identical base component connected directly wrapping component input output ports 
component inherits behavior ports component component overrides behavior component output port com ponent placed component output component corresponding output 
way component extended component second way customize computation parameters 
algorithmic parameters accept string values content bsl code 
bsl code forms body function module instance function signature defined declaration declaring module body 
declaration identifies set arguments values may bsl code return type return value produced bsl code 
code invoked module behavioral specification accomplish computation state update task 
just parameters parameters default values allowing module define default behavior overridden user 
single parameter assignment module instance oop equivalent inheriting class overriding virtual member function instantiating inherited class 
allows dramatically reduce overhead inheritance inheriting module instantiating 
inheritance common structural modeling reduces specification overhead lss 
formal styles inheritance achieved assignment module wrapping 
allow maintain state invocations lss supports ability add state declaring runtime variables 
runtime variables variables available simulation model compilation 
allow initialization synchronous update added state modules possess system defined init timestep invoked simulation clock cycle respectively 
created users runtime variables help customize computation 
polymorphism support reuse datatypes lss supports types polymorphism parametric polymorphism component overloading 
parametric polymorphism supported type variables 
example port lss having basic type int may polymorphic type contains type variables 
line state port type specified type variable type variables lss 
type variable instantiated lss type 
fact ports type variable means ports basic type 
example demonstrates parametric polymorphism hierarchical component leaf components 
cases bsl code leaf component specialized basic type type variables 
component overloading lss achieved disjunctive types 
disjunctive type denoted type type lss specifies entity type may statically type type type simultaneously 
notice different union types may store type depending value assigned runtime 
modules may define ports implementing full cross product allowable overloaded configurations may extremely cumbersome 
types resolved statically implementing multiple entire behaviors component bsl specify type dependent code fragments code generator customize code statically resolved type information 
common polymorphic components model long chains polymorphic data routing components polymorphic state elements manually resolving polymorphism tedious 
practice hundreds explicit type instantiations necessary resolve polymorphism 
avoid overhead lss automatically resolves polymorphism type inference structure model 
example code shown delay module requires type int ports ports delayn module connected instances module type variable resolved type int 
ports disjunctive types lss type inference problem non trivial 
details regarding lss type inference problem section 
instrumentation allow model reused different data collection needs lss supports mechanism separate model specification model instrumentation 
possible static structural modeling lss uses aspect oriented data collection scheme 
module declare instances emit certain events runtime 
events behave join points aspect oriented programming aop 
time certain state reached value computed instance emit corresponding event userdefined collectors fill join points collect information statistics calculation reporting 
bsl code may specified collector processes data sent event accumulate statistics reported simulation visualization model debugging 
addition declared events lss automatically adds code emit event value sent port 
important hardware events synchronized communication useful statistics gathered just port firing events 

type inference described earlier lss attempt assign basic types ports type inference 
type inference greatly reduces tedium polymorphic components frees user explicitly specifying type 
type inference problem lss formulated trying assign values set type variables set constraints 
defining system ports connections user annotates port optionally annotates connection type scheme 
legal types type schemes system specified grammar basic types int type variables type schemes int identifiers identifier ports system connected constraint term equates corresponding type variables added constraint 
connection annotated type scheme pair constraint terms equate connected ports type variables annotated type scheme added constraint 
form legal constraint type inference problem grammar constraints constraint represents trivially true constraint constraint asserts equality type schemes constraint represents conjunction constraints type inference engine assign basic type type variables satisfying constraint 
type system constraints similar languages ml 
notice type scheme 
entity annotated type scheme statically single basic type accepted type schemes 
different union type values match type schemes passed run time 
disjunctive type scheme comes need allow overloading port types discussed section 
presence disjunctive type prevents typical unification algorithm working lss type system 
problem arises possible assign basic type type variable solely disjunctive type constraint disjunctive type scheme unbound type variables 
fact lss type inference problem np complete 
type system inference problem similar type system inference problems languages haskell 
haskell problem undecidable general 
exist restricted versions type system decidable 
unfortunately restrictions yield acceptable computational complexity desirable structural modeling environment forbid common port interface typings 
restricted versions type system know heuristic algorithms appropriate instances problem arise lss 
perform type inference lss uses modified version typical unification algorithm 
algorithm encountering constraint form recursively applies constraint systems form 
constraints solution solution original constraint 
straight forward extension unification algorithm slow practice heuristics algorithm practical 
constraint terms reordered nondisjunctive constraint terms simplified 
eliminates need re solve recursion handle disjunctive terms 
second heuristic employed intelligently solves certain disjunctive terms recursion 
third divide andconquer heuristic partitions disjoint constraint terms separate simpler constraints applied constraints solved separately 
factoring constraint way exponentially reduces number recursive calls 
heuristics type inference completes seconds cases observed expect comparable times practical models 
heuristics type inference times exceeded hours models 
detailed description analysis algorithm heuristics scope 

specialization just explicitly specifying types tedious unnecessary explicit parameter value specification tedious redundant 
manner analogous type inference lss compiler infers certain parameter values way component 
refer process components customizing inferred parameter values specialization 
specialization design simplest example specialization involves port widths 
consider delayn module 
delay module building block delayn mod module delayn parameter int parameter width int var delays instance ref delays new instance delay delays var int lss connect bus built iy lss connect bus delays width delays lss connect bus delays delays width lss connect bus delays width modified delayn module supports multiple port connections 
instance gen source instance hole sink instance delay delayn delay delay width lss connect bus gen delay lss connect bus delay hole modified delayn module 
ule supports multiple connections ports 
connections ports delayn module port instance connected internally 
alter behavior delayn change code defines width parameter multiple connections chain delay elements 
shows code look 
module instantiate new delayn set width parameter corresponding number connections instance 
instantiation code shown 
setting single width parameter overwhelming ports type construct quickly clutter code easily lead errors especially parameter kept consistent connectivity port 
specialization avoid scenario 
lss implicit parameter named width defined port 
user explicitly setting parameter value inferred counting number connections port 
specialization code identical line omitted 
modified omitting line replacing occurrences width width adding check ensure width width 
example extremely simple specialization extremely powerful 
consider example branch prediction module supports branch target buffer btb functionality 
clear requesting branch target information requires btb specialization branch prediction module infer btb behavior necessary checking see branch target port connected 
module 

width parameter arbitration policy args ret instance arb arbiter arb policy arbitration policy 


specialization exporting additional parameters example specialization 
module infers internal arbiter necessary comparing width input ports output ports 
arbiter necessary input port wider output port module export parameter arbitration policy parametrically specified lines 
specialization parameter arbitration policy exist default value set arbitration necessary 
default arbitration policy added 
case arbitration required having module quietly select policy undesirable reasonable default policies 
specialization eliminates trade providing best alternatives user required specify policy necessary required specify policy 
noted example demonstrates specialization allows module parameterization communication interface affected connectivity parameterization ports parameters module 
creates dilemma straight forward evaluation lss 
module instantiated constructor called code instantiation line executed 
resolve difficulty lss novel evaluation semantics described section 
specialization implementation specialization requires module body access values defined usage module instance number connections port values explicitly specified parameters 
specialization allows module interface module ports parameters depend values 
specialization requires deferring module body evaluation module instantiated conventional evaluation requires module body evaluated interface known 
remedy circularity lss uses novel evaluation semantics described section 
clearly evaluation module body occur soon instance created module body depends values module parameters 
invoking module body creating new instance name newly created instance module instantiated pushed instantiation stack 
code continues execute current module body assignment subfield sub instance line encountered assignment recorded po hole sink gen source width gen hole gen gen gen gen hole hole hole hole delay delayn instantiation records instantiation stack 
evaluation context width added step width added step width added step added step context delay 
lss interpreter state 
parameter assignment 
similarly connection subfield sub instance connection recorded potential port connection 
current module body finishes evaluation instance top instantiation stack popped module body executed 
module body declares parameter previously recorded potential parameter assignments consulted see parameter user specified value 
type value checked parameter type types match parameter assigned value 
assignments recorded parameter get value default parameter assignments inside module body exist 
similarly port declared recorded list connections consulted see attempts connect port 
port connected implicit width attribute set 
evaluation module completes potential subfield assignment potential connection records checked sure non existent parameters ports instance referenced 
additionally parameters checked ensure value 
example illustrate execution code shown 

line 
interpreter records instance source module named gen created pushing instantiation stack 

line 
done hole delay modules 

line 
interpreter records assignments potential parameters width 

line 
interpreter records connections 
point top level code finished module top instantiation stack popped constructor evaluated 
shows instantiation stack lss interpreter point execution 
case set code run delayn module shown 

line 
check see integer value record 
add evaluation context value record 
evaluation context shown 

line 
width parameter 

line 
record fact connections port valid compute port widths add width parameters context 

line 
execute code recording instantiations assignments connections 
code finished interpreter ensures connections non existent ports illegal parameter assignments 
example code correct evaluation continues 
instance stack case delay modules pushed stack evaluation instance delay popped stack evaluated 
behavior specified formally describing execution semantics lss language evolution program states 
execution semantics expressed way typically called small step semantics 
complete small step semantics numerous state transition rules closely resemble semantics common imperative programming languages 
section state transitions relate implementation specialization described 
section uses notation terminology harper defined differently 
state lss program execution represented tuple 
netlist design known current point program evaluation 
stack instances need processed 
evaluation context maps symbols values 
recorded list potential parameter assignments port connections obtained parent instance instance hierarchy currently processed 
context records potential parameter assignments port connections children current instance 
current expression evaluated current list statements evaluated 
program starts initial state 

defines built functions statement list toplevel lss specification 
state transition function lss program states expressed propositional logic 
transition rules items appear horizontal bar represent hypothesis logical statement 
items appear bar represent statement 
notation denote transition state transition rules identify legal transitions 
state lss program satisfies hypothesis transition rule transition rules define state transition function 
interesting rules lss evaluation new instance created 
rule statement shown 
note portion rules related augmenting shown extension straightforward 
current instance name dom dom body 
instance 
fn 

rule pushes constructor instance stack constructors evaluated continues evaluating statements current statement list 
note denotes stack element top stack 
notice differs standard evaluation immediately begun processing current instance finished statements left current statement list rule begins evaluating instance constructor 
current instance name extract strip 

function extract extracts parameter assignments connections instance named function strip strips prefix symbol names context state instance processed established extracting recorded potential assignments processed instance making set assignments new context 
hypothesis ensures assignments undefined parameters occur 
mechanism explained 
remaining small step inference rules similar imperative programming languages 
complex rules shown ones parameter port declarations 
parameter rule removes assignments parameter defined updates appropriately 
port declaration rule similar 
records removed module finishes evaluation assignment connection undeclared parameter port 

experience lss lss front language liberty simulation environment lse 
section gives background provides additional insight design lss describes experience lse discusses reuse provided lss 
lse originally static structural specification language lss 
system resembled described section 
system models created largest cycle accurate clone popular simulator hand coded simplescalar 
development larger ambitious models hindered lack flexible hierarchical components 
developing microarchitectural models common instance connection patterns emerged case structure width necessary varied slightly 
reasons described section patterns encapsulated reusable hierarchical components 
forced cut paste reuse formal reuse patterns described 
model complexity grew managing code cut pasted fragments overwhelming 
alternate solution clearly necessary 
response need lss language designed implemented 
direct conversion non lss version simplescalar model lss model reduction line count 
furthermore creation lss able build larger aggressive models research instruction 
table lists models 
lss allows creation flexible models components practice 
example ia chip multiprocessor cmp model model constructed instantiating ia cores model connecting shared cache hierarchy 
model sufficiently flexible allow exploration novel communication structure processor cores study effect number functional units mix evaluate effect static dynamic instruction scheduling measure effect various memory subsystems 
facilitate study processor core model exported parameters ranging simple parameters controlled number instructions fetched cycle complex parameters controlled processor issue instructions outof order 
researchers lss lse create flexible models libraries flexible components 
example researchers rice university lss model programmable network interface architectures 
lss features greatly simplified construction models 
table summarizes data quantifies benefits 
specialization able infer port widths instances instances modules explicit type explicit type inferred model hierarchical leaf instantiations instantiations port name instances modules modules module library library type infer 
type infer 
widths connections total model descriptions table 
values parenthesis discount trivial hierarchical modules simply wrap collection components 
table quantity component reuse model name model description style machine dlx instruction set 
single issue window 
model equivalent simplescalar simulator 
order processor core ia 
cores sharing cache hierarchy 
validated itanium processor model 
table models developed lss 
models obviating need keep parameter values consistent connections models 
obvious numbers manually specifying connections impractical algorithmic specification structure vital developing model 
notice type inference reduced total number required type instantiations reduction 
aspect oriented instrumentation features lss proved invaluable allowing easy migration data collection probes experimentation debugging probes correct inaccuracies models 
quality lse system degree component reuse improved dramatically addition lss 
table see component instances models came library components 
models module approximately times 
trivial hierarchical modules simply wrap collection components discounted module times models 
reuse translates reduced specification time 
example single student weeks able specify validate percent hardware cpi cycles instruction itanium model model 

related section described major classes concurrent structural systems oop concurrent structural systems static structural systems explained strength weakness 
section classify known concurrent structural modeling systems explore strengths weaknesses 
systemc 
systemc oop concurrent structural modeling system built library programming language 
limitations described section 
terms simulation speed reusable components lse lss fast custom components written systemc 
ptolemy ii 
ptolemy ii interface oop concurrent structural modeling system systems heterogeneous models concurrency 
ptolemy allows users define system structure directly java 
way suffers shortcomings systems described section 
point execution structure need immutable limiting static analysis capabilities described section 
lss ptolemy ii bsl address shortcomings bring powerful reuse heterogeneous system exploration 
ptolemy ii 
ptolemy ii interface static structural modeling system supports structure analyses parameterization non structural specification structural specification 
ptolemy simultaneously 
vhdl 
vhdl tool commonly rtl level modeling synthesis hardware systems high level modeling 
despite low level target vhdl flexible type system limited support parameter structure syntax behavioral opposed rtl specification 
vhdl support features outlined section making component reuse difficult 
example vhdl support polymorphic types forcing reimplementation common components arbiters datatypes involved 
furthermore vhdl inheritance mechanism allow customization extension components 
vhdl support specialization 
may possible add capabilities vhdl bsl lss 
balboa 
balboa structural modeling system designed allow components developed various incompatible modeling environments composed 
balboa separates interface definition structure component behavior interface definition language idl behavior specified 
call approach split level programming 
composition language balboa program split level programming closely related compilation process lss 
lss balboa structure specification language evaluated simulator run time suffers problems similar structural oop systems 
balboa runtime component connection provide component overloading 
idl program run determine structure model resulting structure infer particular version overloaded component instantiated correct component connected 
unfortunately approach resolve parametric polymorphism structure resolved types direct compilation behavioral code compile time 
note techniques balboa uses reconcile differences components different simulation systems conjunction lss gain benefits lss balboa 
note balboa type inference problem closely related lss type inference problem 
lss algorithm closely related basic unification algorithms languages ml 
polylith 
outside hardware specification domain structural interface definition languages idl mil language polylith software bus system employ concurrent structural modeling 
approach natural fit goal tools separate specification functionality specification interface communication 
similar static structural systems polylith mil structure specification language uses declarative syntax specify component interconnectivity 
features related reuse involve resolving differences datatypes communication semantics systems written different languages running different platforms distributed computing environment 
systems specify behavior program structurally composing components ideas add reuse ability reuse components structurally build new easy reusable components 
idl systems similar polylith exist comparison systems scope 

pseudo structural processor modeling tool developed digital equipment worked intel 
related high level architectural modeling goals line lse 
uses structural composition components uses functional composition communication clock cycle 
system purely concurrent structural making component reuse difficult 
system pure concurrent structural system techniques may directly applicable 
support component reuse inheritance 
details difficult evaluate tool openly available 

presents programming language techniques targeted improving hardware systems development increasing rate ideas evaluated 
techniques described context design implementation liberty structural specification language lss increase designer productivity encouraging wide scale component reuse 
prior structural modeling approaches forced trade easy reuse easy construction reusable components lss provides best hybrid solution 
lss language provides imperative programming constructs allow programmatic control structure flexible hierarchical components evaluated compile time allowing static analysis model structure 
static analyses allow properties flexible components inferred reducing specification overhead 
presents static type inference algorithm lss resolve parametric polymorphism component overloading 
presents new programming language technique called specialization manner analogous type inference customizes reusable components statically inferring component parameter values specified manually 
experience lss indicates features significantly improve reusability components dramatically improving productivity hardware modeling 
acknowledgments jason sharad malik vijay pai david ram rangan paul entire liberty research group support development lse lss 
supported national science foundation ngs intel 
opinions findings recommendations expressed necessarily views national science foundation intel 

burger austin simplescalar tool set version 
tech 
rep department computer science university wisconsin madison june 
doucet shukla gupta environment dynamic component composition efficient design 
proceedings conference design automation test europe 
doucet shukla gupta typing abstractions management component framework 
proceedings asia south pacific design automation conference 
emer ahuja luk manne mukherjee patil wallace juan performance model framework 
ieee computer february 
harper programming languages theory practice 
draft 
ieee 
vhdl ieee standard 
www ieee org 
lee liu liu sachs xiong heterogeneity ptolemy approach 
acm sigplan workshop languages compilers tools embedded systems june 
kiczales lamping mendhekar maeda lopes loingtier irwin aspect oriented programming 
proceedings th european conference object oriented programming pp 

milner tofte harper macqueen definition standard ml revised 
mit press cambridge ma 
odersky wadler second look overloading 
proceedings conference functional programming languages computer architecture pp 

open systemc initiative 
functional specification systemc 
www systemc org 
august optimizations simulator construction system supporting reusable components 
proceedings th design automation conference june 
polylith software bus 
acm transactions programming languages systems toplas january 
seidl haskell overloading dexptime complete 
information processing letters 
martonosi august hill lilja pai challenges computer architecture evaluation 
ieee computer august 
smith principal type schemes functional programs overloading subtyping 
science computer programming 
august microarchitectural exploration liberty 
proceedings th international symposium microarchitecture november pp 

malik august liberty simulation environment deliberate approach high level system modeling 
tech 
rep liberty liberty research group princeton university january 
pai liberty simulator programmable network interface architectures 
proceedings sigplan conference languages compilers tools embedded systems june 
xiong lee extensible type system component design 
proceedings th international conference tools algorithms construction analysis systems march pp 

