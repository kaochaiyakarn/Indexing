symmetric encryption automatic analyses confidentiality active adversaries laud university cybernetica email ut ee article technique static analysis correct respect complexity theoretic definitions security cryptographic protocols checking protocols satisfy confidentiality properties 
approach similar abadi rogaway define patterns cryptographic protocols formal expressions protocol secure iff patterns 
statically analyse patterns easier analyse protocols 
consider symmetric encryption cryptographic primitive protocols 
handling primitive far received comparatively attention approaches striving unite formal computational models cryptography 
cryptographic protocol expected satisfy certain security properties 
interested confidentiality properties state protocol runs look similar view adversary may depend secret information legitimate protocol party wishes transmit 
protocols verified satisfying required security properties 
verification procedure produce kind proof property satisfied 
possible craft proofs hand 
exist lot protocols automatic verification methods necessary 
methods exist tools take protocol descriptions inputs return protocols secure case insecurity may show attack 
methods necessarily give definite answer problem deciding protocol secure may hard depending definition security may option answer don know 
methods answer don know useful expected give definite answers reasonable protocols reasonably 
quite methods possible answers secure don know 
called safe side labeling insecure protocol secure may serious consequences labeling secure protocol potentially insecure 
existing tools methods automatic checking security properties common shortcoming dolev yao model assume perfect cryptography 
model exchanged messages modeled elements certain term algebra capabilities adversary security definitions terms algebra 
real life computational model messages formal terms bit strings 
adversary efficient algorithm 
theory gap dolev yao model computational model 
known results obtained dolev yao model carry computational model 
abadi rogaway started bridging gap defining patterns formal messages built atomic messages pairing symmetric encryption computational interpretations message pattern indistinguishable :10.1.1.29.1076
pattern formal message simpler structure message 
pattern determine secret atomic message message occur pattern message interpretation message surely leak abadi extended line basically giving protocol analysis results correct computational model consider passive adversaries :10.1.1.29.1076
approach similar 
protocol construct number protocols simpler structure set constructed protocols takes role pattern 
show constructed protocols leak original protocol leak protocol surely leak construction messages exchanged run protocol criterion decide security constructed protocols 
typically secret occurred encryption messages exchanged original protocol protocol secure occur constructed protocols criterion sufficiently powerful purposes 
earlier version analysis implemented 
structure 
reviewing related sec 
ii basic definitions sec 
iii state properties encryption system satisfy sec 
iv protocol sec 
give security definition protocol sec 
vi 
sec 
vii describe main contribution protocol transformation protocols easily analyzable 
correctness transformation security definition symmetric encryption 
contribution gives completely automatable method analyzing protocols preservation confidentiality secret messages 
results analysis correct computational model considering active adversaries 
describe simple conservative information flow analysis sec 
viii quite successful analyzing transformed protocols 
give example transformation subsequent information flow analysis sec 
ix 
full version available 
ii 
related automated cryptographically sound analysis usage cryptographic primitives new research topic 
done area considering passive adversaries abadi :10.1.1.29.1076:10.1.1.29.1076
papers analyses secure information flow equivalent programs written certain language containing cryptographic primitives 
particularly gave means automatically verify protocol preserves confidentiality passive adversaries :10.1.1.29.1076
explained may seen extension :10.1.1.29.1076:10.1.1.29.1076
sense probing approach extends setting active attacks 
similarly handle unbounded replication language contains replication operator explained chapter count :10.1.1.29.1076
backes pfitzmann framework faithful abstraction cryptographic primitives general setting allowing model details cryptographic primitive may may operate 
framework allows reason protocols considering primitives 
modeling details achieved introducing honest user system interacting primitive adversary 
abstraction primitive exists transformation adversaries honest user distinguish interaction real primitive adversary interaction primitive transformed version adversary notion called simulatability 
fully automatic analyses 
defined cryptographic library cryptographic operations implementations proved protocol secure respect semantics secure respect concrete semantics 
semantics similar dolev yao model exactly 
sense adversary attacking library respect semantics powerful adversary may nondeterministic 
opinion quite easy add dolev yao analyzer example blanchet framework show results cryptographically correct 
results subsumed combination 
consider different cryptographic primitive symmetric encryption library contains publickey encryption signing 
main improvement handling secret keys 
put restrictions 
library allows secret keys decryption signing may put expressions addendum lift restrictions put secret decryption keys 
constraint nontrivial removing means deal encryption cycles commitment problem described :10.1.1.29.1076
encryption cycle occurs adversary knows encryption secret key second encryption second secret key third encryption secret key 
computational security definitions say setup definitions allow adversary construct encryption cycles 
deal encryption cycles replacing concrete encryption primitive primitive key time 
determinism adversary attacking library respect semantics obviously weakness results backes may hamper extension results 
turns adversary really non deterministic achieve full power non determinism built definitions simulatability 
conceiving simulatable abstractions symmetric encryption account commitment problem occurs simulator receives ciphertext corresponding plaintext key 
backes pfitzmann give simulatable abstraction symmetric encryption condition commitment problem encryption cycles occur :10.1.1.3.4629
canetti framework similar backes pfitzmann 
details differ goals 
postulates analysis similar may possible 
cryptographic primitives framework example commitments secure channels multiparty computation similar cryptographic library :10.1.1.112.1891
apparently focus constructing protocols analyzing 
herzog computational implementation dolev yao model public key encryption cryptographic primitive respects properties formal model protocol secure formal model implementation secure computational model :10.1.1.20.5370
downside result extremely strong security condition encryption plaintext aware property achievable random oracle model herzog definition plaintext awareness sufficient purposes require random oracle needs third party :10.1.1.116.571:10.1.1.41.4144
security requirements put encryption primitive security adaptive cca ciphertext integrity achievable standard assumptions 
herzog handle encryption cycles simply assumed occur 
iii 
basic cryptographic notions function negligible positive polynomials exists 
cryptographic algorithms bit strings denote set bit strings 
algorithm takes number arguments returns result 
runs probabilistic polynomial time ppt exists polynomial number steps bounded length argument argument security parameter indicating desired security cryptographic algorithms security means longer running times 
definition probabilistic polynomial time spoke length argument security parameter algorithms unary denoted probability distribution finite countable set function 
denote set probability distributions set 
denote picking value random variable distribution notation denotes distribution random variable expression probability space defined list picking values random variables defining variables 
families probability distributions dn dn indistinguishable denoted ppt algorithms difference probabilities dn negligible function supposed role understand second argument distributed dn return return 
indistinguishability cryptographic equivalent sameness 
equivalence relation set families probability distributions 
algorithm fully specified 
may queries oracle 
oracle probabilistic algorithm 
algorithm may special commands query certain arguments 
queried runs returns result back denote making queries want stress may queries oracle write want stress takes argument write notation means may queries different oracles 
notion algorithms oracles allows generalize notion indistinguishability algorithms 
say algorithms oracles black boxes indistinguishable difference probabilities negligible ppt algorithms algorithms considered families probability distributions algorithms 
iv 
security encryption systems encryption system triple algorithms 
key generation algorithm encryption algorithm decryption algorithm 
algorithms probabilistic algorithm deterministic 
algorithms take security parameter represented unary argument 
additionally takes arguments key plaintext 
takes arguments key ciphertext 

may returned may returned algorithm return previous requirement stated inverse want encryption system secure want ciphertext give away information plaintext 
concretely want encryption system satisfy properties 
encryption system satisfies properties call secure 
secure adaptive attacks cca 
means probabilistic polynomial time adversary query second oracle values returned unable distinguish pair black boxes pair black boxes 
distributed denotes bit string zeroes length argument black box 
note security definition length ciphertext depend length plaintext security parameter 
preceding definition closely follows bellare variant call real random indistinguishability notion security cca appeared earlier 
notion non adaptive cca appeared adaptive cca 
second ciphertext integrity 
means probabilistic polynomial time adversaries negligible probability run oracle queried bit string valid ciphertext previously returned oracle distributed 
definition comes 
third want algorithm return different bitstring time queried 
absence encryption cycles property easily follows security chosen ciphertext attacks want property hold universally 
requirement encryption return different results formalized follows 
consider oracle 
oracle simply invokes encryption algorithm takes plaintext key arguments contrast oracle 
require adversary cause non negligible probability oracle give answer queries 
encryption system satisfying requirement constructed follows 
encryption system secure cca having ciphertext integrity systems exist standard assumptions see 
construct encryption system follows 
equal generates random bit string length constructs outputs 
computes 
pair bit strings outputs 
checks outputs outputs 
obviously probability returns answer twice bounded number queries adversary 
negligible polynomial theorem secure cca ciphertext integrity 
proof show secure cca 
assume opposite exists adversary distinguish passing output black box second 
easily construct adversary distinguish passing part output black box second 
adversary works just additionally implements definition terms hand adversary distinguish passing part output black box second follows directly security cca 
corresponds just certain choice bit strings submitted black box 
bit strings pairs bit string consisting zeroes random bit string 
distinguish distinguish distinguish passing part output black box second 
violates security cca 
corresponds just certain choice bit strings submitted black box 
bit strings pairs second component random bit string 
show ciphertext integrity 
assume opposite exists adversary interaction black boxes construct valid ciphertext seen 
exists adversary works additionally implements definitions interaction black boxes construct pair valid ciphertext decrypts 
seen pair 
output adversary obtained pair point output 
new valid ciphertext constructed impossible obtain valid ciphertext key syntax semantics protocols protocol consists set participants 
participant basically program certain programming language 
programs consist computing certain values ones known participants exchanging messages checking values received messages 
additionally long term secrets participants know share long term secrets identification different participants possible exchanged start protocol model exchange extra prelude protocol 
concreteness program sequence statements statements defined fig 

meaning statements clear give precise semantics protocol 
just mention superscript receive statement denotes expected length received message 
constant functions security parameter 
recipient send specified communication control adversary anyway 
message constructors key generation tupling encryption constant random number generation tag constructed message name constructor adversary obviously free generate possible messages 
goes wrong execution statement participant containing statement stuck 
gen key 
xm encr decr random send receive check constant 
xm variables set var 
fig 

statements assume protocol variable occurs left side assignment 
var sent set variables statement send occurs protocol 
currently shortcoming inability handle replication analyse bounded number protocol instances running simultaneously 
difficulties analyzing arbitrary number instances lay area static analysis area cryptography constructing new protocols keep track produced values loops simpler produced value unique name 
program language quite minimalistic extending example exception handling overly difficult 
expressiveness language similar strand spaces 
statements occur original protocols analysis may occur transformed protocols 
sem set semaphores 
statements signal wait sem implement simple synchronization primitive statement signal records semaphore passed statement wait checks passed stuck case 
semaphore may occur statement signal 
intermediate protocols may contain case statement form case 
xn yn obvious semantics 
var 
initial final protocols contain case statement intermediate ones 
parts set names protocol participants 
protocol function mapping element parts pre program 
parts program executed participant protocol prelude pre 
executed rest protocol 
initializing long term secrets real protocol starts 
parts denote set parts pre 
demand programs parts empty 
protocol runs parallel adversary 
adversary relays messages protocol participants 
adversary schedules participants letting adversary scheduling removed possible non determinism opposed semantics statements obviously probabilistic arising parallel execution participants 
computation similar 
ast set possible internal states adversary set ast isomorphic subset 
security parameter set adversary 
implements probabilistic function ast parts ast running time polynomial denotes set 
argument message sent participant latest moment 
return value message received protocol party executing receive moment second return value name protocol participant executes 
give precise description execution protocol 
run values assigned variables 
secret message var distinguished variable 
assume public knowledge encryption system hide lengths plaintexts 
denote distribution security parameter fixed secure encryption system possible keys produced fixed length 
polynomial efficiently computable injective function efficiently computable length depends lengths ciphertext key tuple random secret const fixed bit strings 
running protocol adversary proceeds follows 
initialization 
auxiliary variables necessary description running protocol 
variable sm contains message sent 
initialize message waiting 
variable rm contains message received network adversary 
initialize empty bit string 
programs parts contain parts programs 
initialize 
flags true false parts indicate participant running stuck 
initialize true 
internal state adversary 
initialize 
participant execute statement 
initialize pre 
variables var occurring flag shows variable initialised 
initialize true rest false 
variables var occurring value recorded initialize vm secret leave rest uninitialized 
semaphores occurring flag shows semaphore passed 
initialize flags false call sequence values execution state 
denote components execution state sm rm set execution states 
step 
step describes execution statement program protocol 
running protocol consists executing steps instruction execution reached 
step sub steps done consider conditions true execution protocol 
empty sequence statements 
pre pre empty sequence statements 
statement set rest 
false participant stuck set sm continue sub step 
consider statement send set sm 
case statement false variable value statement set false continue sub step 
gen key invoke set key 
set true 

xm set tuple xm xm true 
parse 
set xm conditions holds set false invocation fails 
tuple 
properly tagged applied component result ciphertext key random secret const tuple set true 
encr parse 
invocation fails key set false 
invoke set ciphertext 
set true 
decr parse 
invocation fails key ciphertext set false 
invoke 
invocation fails properly tagged set false 
set true 
random uniformly randomly generated bit string length 
set random true 
constant set const recall type true 
send set sm receive check rm properly tagged rm 
set rm true set false 
check set false 
set true signal set true 
wait check true 
set false 
case statement form false set false 
find index true false set false 
set true 
pre false execution protocol 
invoke adversary rm sm steps define probabilistic transition system value security parameter set execution states 
probabilistic effects introduced invocation adversary may employ random coin tosses second certain statements protocol generation random numbers new keys encryption 
certain probability execution transitions state state step 
sum probabilities non zero probability final state execution stopped state 
probabilistic transition system defines certain probability distribution set assign probability execution adversary ends state 
call probability distribution semantics denote 
want talk fixing random choices protocol 
set possible random choices adversary statements protocol execution 
going describe structure elements parts length program 
set parts 
element mapping 
secret value value contains random coins th statement participant value contains random coins adversary right execution th statement participant fixing random choices gives plain transition system set execution traces 
denote transitions fixed 
gives possibility talk executions protocol going lock step 
objects random coin tosses want talk value fixed tosses denote resulting value tosses 
example final execution state get security parameter random coin tosses protocol prelude program kas gen key kbs gen key constant constant receive dm decr kbs ab receive bm decr ab program program random send receive dm decr kas check dm send dm ab dm am encr ab send am receive kab gen key dfb kab fb encr kbs dfb dfa kab fb fa encr kas dfa send fa fig 

example protocol language note word protocol encompasses real protocols inputs analysis results transformation 
intuitive assumptions longer hold transformed protocols 
variables shared participants protocol 
may variables defined participant subsequently 
possible adversary scheduled participants way participant attempts variable value set 
reason keep track initialization variables 
obviously real protocols sharing occur 
transformed protocols intended realized protocols participants physically different locations merely analysis tool 
example consider needham schroeder key exchange protocol secret key encryption followed transmission secret message encrypted new key na encr kas na kab encr kbs kab encr kbs kab encr kab fig 
gives protocol programming language introduced 
brevity combined calculations 
superscripts statements statement labels 
sec 
vii 
denoted lengths expected inputs just 
length message security parameter length fa length fb length am functions 
easily represented lengths constants secret message security parameter arithmetic operations operations mapping length keys produced mapping length plaintext length corresponding ciphertext mapping lengths bit strings length applied bit strings 
want consider simultaneously run protocol find man middle attacks include program participant times number times corresponds number instances participant supposed take part 
instance reflects participant role instance initiator responder intended communications partners 
different instances different variables 
adversary may pose legitimate protocol participant long term key kes shared server fragment kes gen key send kes occur protocol prelude 
adversary choose key kes just statement kes receive occur prelude 
vi 
security definition var variable containing secret message approach easily extended secret variables 
view adversary final state 
protocol secure possible adversaries view adversary independent secret message 
security definitions independence common language security 
mean adversary deduces secret message applies randomly chosen secret message 
adversary deduced fact running protocol just simulating run randomly generated distribution genuine secret message distribution supposed known bitstring secret message 
deducible facts trivial nature 
define extended view adversary family probability distributions occurring left 
clearly extended views protocols indistinguishable secure insecure 

security protocol depends family distributions undesirable may universally quantify analysis correct definition 
vii 
rewriting protocols protocol analyzable changing certain ways 
sure changes valid change extended view adversary protocol 
section describes protocol transformation constructs protocol cryptographic operations 
protocol may contain case statements protocol may contain 
protocol secure iff protocol describe replace protocol protocols 
secure secure 
contain case statements 
protocols 
may analyzed information flow analysis purely information theory example section security follows security protocol 
protocols 
contains significant uses cryptography may apply protocol transformation 
practice protocol transformation consists iterations applying procedure turns initial protocol set protocols 
set finite cardinality determined structure 
iteration procedure applied protocols deemed contain significant uses cryptography changing protocol want find items want find key statement gen key able find uses key uses key created key generation statement 
able exactly point uses key approximation set uses allowed 
want find dead code statements executed 
permissible find subset dead code 
removing dead code may analysis sec 
viii precise send statements may removed 
reason find key aforementioned properties check uses key necessary creating view adversary replaced uses encryption decryption oracles encrypting decrypting key 
really case statements form encr may replaced encr new variable value set replacement change view adversary security encryption system adaptive cca 
removing dead code simplifies finding keys 
process defining steps 
remove dead code find simple syntactic analysis sec 
vii 
protocol abstractly interpreted 
variable assign term describes construction value variable atomic values keys random numbers constants secret message adversary inputs 
describe part sec 
vii 
interpretation necessary knowing keys statements 
suitable key selected 
suitability means key really necessary producing view adversary 
access black boxes encrypting decrypting key necessary 
describe part sec 
vii 
actual replacement statements occurs 
described sec 
vii changes define protocol sec 
vii describe protocols 
constructed protocol removing syntactically unreachable code order statements occurring protocol puts certain restrictions order may executed 
consider directed graph vertex set arcs parts recall number statements program arc 
parts arc pre pre 
statement signal statement wait sem arc 
clearly exists directed path node node possible execution statement executed statement executed earlier 
graph contains directed cycles statements cycles executed dead code 
remove statements 
assume directed acyclic graph 
interpreting protocol assume statements protocol labeled elements set lab statements different labels 
identify sets lab 
determine values variables constructed atomic values 
definition terms trm constituting values variables fig 


tm terms lab var 
see constructors trm correspond statements programming language 
meaning terms clearer give interpretation statements 
key random tuple 
tm const encr secret input decr fig 

set values said abstractly interpreting protocol assigns term variable 
trm denote term assigned variable secret var variable containing secret value 
rest terms defined examining statement defining interpretation statements defining value variable defines term 
defined label statement terms assigned variables right hand side statement 
definition fig 

see statement label included term iff result statement may depend arguments statement random numbers adversary input 

gen key key random random 
xm tuple 
encr encr decr decr receive input constant const fig 

definition terms interpretation send statement effect values variables 
give semantics terms trm 
random choices fixed 
define trm follows function defined terms occurring values variables subterms input equal value variable defined statement receive random choices fixed value key key key generated random coin tosses fixed represents arguments say key tagged key 
random uniformly generated bit string length polynomial determined length random bit strings generated random tagged random 
const const 
secret secret 
tuple 
tm 
tuple tm tm tuple constructed way execution tupling statement 

parsed exactly execution projection statement 
th element parse taken 
parse fails 
decr tagged key tagged ciphertext fails 
decr equal result decryption 
encr tagged key 
equal ciphertext 
denote set statements executed random choices execution protocol stopped reaching statement participant containing statement get stuck statement 
theorem var label statement defining 
theorem proven induction order executing statements determined 
mainly consists comparing definitions execution step rules deriving equality inequality terms possible derived certain terms 
example projection tupling cancel decryption encryption certain conditions 
example inequality different keys unequal 
rules semantically justified derive certain terms equal insignificant probability bit strings corresponding terms equal 
probability taken protocol runs 
denote derived equality terms protocol inequality derive semantics certain term denote stuck fig 
presents axioms inference rules defining stuck 
rules obvious 
rule nec says type value bit string represents determined bit string 
rules dif dif say different random bit strings different 
rule dif justified requirement encryption algorithm return bit string twice 
rules state projection decryption check types inputs 
say sound statement probability negligible similarly sound statement probability negligible soundness statement means really executed variables opposite negligible probability id 
tm ary constructor trm 
tm 
ind tuple 
tm decr encr key random const encr tuple tuple tuple 


nec key key dif random random dif tuple 
tm tuple 
dif encr encr dif key random const encr tuple 
tuple tuple 
stuck 
key random const tuple tuple 
stuck decr 
random const tuple tuple 
encr stuck decr 
stuck constructor trm stuck 

st fig 

equality inequality terms values terms equal 
determine soundness certain statement 
happens statement defining variable value path statement graph determined statement dead 
say stuck sound statement probability negligible statement defining variable value dead 
theorem rules fig 
sound 
statement protocol premises rule sound consequent rule sound see proof 
establishing soundness rule quite trivial 
consider graph rules fig 
determine nodes statements protocol dead 
fig 
described rules derive stuck may extra axioms general different sets axioms different nodes 
graph nodes corresponding statements executed extra axioms 
check statement adds axiom set axioms node nodes follow node 
statement check adds axiom 
check statement executed choice random coins equal 
equality necessary execution statements follow statement check 
sound statement check statements follow 
rules fig 
simplify terms 
rules applied subterms term left right 
introduce special term stuck stuck rules st simplification denoting stuck terms stuck 
shown simplifications sound certain sense theorem holds negligible fraction possible random choices derived relationships may useful simplification 
particular find holds statement defining variable term contains subterms input term contain subterms simplify summarize protocol analysis interpretation defines var fig 

simplifies terms 
annotates statement axioms form statements check precede order defined 
statements attempts determine dead 
analysis derive rules fig 
var definition definition precedes derive stuck var definition precedes remove dead statements protocol 
choosing key choose key replaced black boxes encrypting decrypting 
key may encryption decryption 
choosing key means choosing lab key occurs values variables 
adversary information protocol statements send var sent participants stuck 
values variables describe values variable constructed 
rule key key eligible chosen simple value variable way affects adversary view key may occur contexts encr key decr key 
variables elements var sent variables occurring check statements variables occurring ciphertexts decryption statements variables occurring keys encryption decryption statements exception key may value 
variables occurring right hand side projection statements statically know projection succeeds know outermost constructor tuple key random const secret encr 
replace key key black boxes encrypting decrypting dummy key key key context value plaintext encryption component tuple values variables mentioned change 
note having subterms input occurring terms invalidate choice key 
bit string corresponding input contain bit string corresponding key key sent occurs context var sent term var sent contained key contexts encr key decr key bitstring corresponding input contained bit string corresponding key combining adversary protocol obtain algorithm finds key black boxes 
existence algorithm means encryption system secure cca 
precise meaning replacing key encrypting decrypting black boxes 
consider change execution protocol described sec 
compute values right hand side statement defining take 
theorem remarks description simplifying terms negligible fraction random coin tosses value changes 
see values may communicated adversary computed access black boxes respectively encrypting decrypting key 
access value key necessary 
obviously going choose key chosen previous iterations transforming protocol 
replacing encryptions replace encryptions key encryptions bit strings zeroes sure decrypt values key created encrypting key recall definition security cca 
key key sent know exactly protocol 
encr 
xn encr kn encryption statements protocol key 
decr decryption statement protocol key replace case 
xn yn decr clearly replacement change execution protocol 
case statement somewhat different clause 

xn ciphertexts produced encrypting key encryption system ciphertext integrity expression decr clause fails value valid ciphertext 
may remove clause get case statement 
key key occurs protocol contexts allowed definition security cca 
replace statements encr 
defined encr variable initialised constant protocol prelude 
resulting protocol protocol removing case statements number branches case statement zero statement dead code 
remove succeeding 
assume case statement branch 

case statements protocol statement cases 
number protocols 
defined way 

choose 
protocols 
correspond possible choices 

sem semaphores occurring protocol obtain new protocol change case statement assume form way add signal immediately statement defining replace fragment wait check change applied case statements 
resulting protocol case statements 
basically going 
just means analyzing branches case statements separately 
analyzing branches separately may wonder missing implicit flows information 
words possible programs get transforming case statement secure original program secure 
fortunately possible 
programming language means value secret influence branches taken 
case statement original programming language 
choice branch depends adversary actions 
adversary know branches chosen chosen branch depend gives information adversary 
viii 
simple information flow analysis program analysis secure information flow trying find confidentiality secret message preserved 
analyses require specifying subsets var sets private input variables case public output variables case var sent 
analysis checks final values public output variables depend initial values private input variables 
simple information flow analysis similar 
participant protocol contains statement form 
xm expression 
xm variables occurring say information flow variable variable write protocol deemed secure holds satisfying conditions var sent occurs check statement occurs argument projection statement occurs ciphertext decryption statement occurs key encryption decryption statement 
denotes reflexive transitive closure 
protocol deemed potentially insecure 
analysis analyse set protocols construct section protocol 
conservative give interesting results original protocol 
correctness analysis easily proved similarly 
going prove result described analysis similar vein stating protocol secure instances protocol differ value secret variable execute lock step giving values public parts execution context 
execution states 
say similar denote components equal sm rm var secret kas key kbs key const const random input dm decr key input dm decr key input dm decr key input ab decr key input am encr decr key input secret input input kab key dfb tuple key const fb encr key tuple key const dfa tuple input const key encr key tuple key const fa encr key tuple input const key encr key tuple key const input dm decr key input ab decr key input input bm decr decr key input input fig 

interpretation protocol fig 
parts flags parts var sem var var tagged key 
possible results random coin tosses equal points 
theorem proof similar 
see 
initial execution states similar secret values theorem final states similar agree value final state adversary depend secret value 
ix 
example continue example sec 
protocol fig 
real protocol contain dead code 
consider interpretation protocol fig 

axioms added check statements allow simplify term 
step protocol transformation protocol prelude program kas gen key kbs gen key constant constant zd fa constant receive dm decr kbs ab receive bm decr ab program program random send receive dm case fa dfa check dm send dm ab dm am encr ab send am receive kab gen key dfb kab fb encr kbs dfb dfa kab fb fa encr kas zd fa send fa fig 

example protocol iteration replacing encryptions choosing key sec 
vii 
keys protocol key key key 
keys key key satisfy requirements put forth sec 
key key consider fa fa var sent 
required choose key transformation modified handle suitable keys choose key 
locate uses key 
just variable value key kas definition fa encrypting dm decrypting 
replace decryption case statement 
replacing encryption statement introducing variable dfa get protocol fig 

denote length dfa just case statement protocol fig 
single branch 
remove case statements get just new protocol 
sem semaphore 
new protocol fig 

continue iteration transformation 
syntactically dead code 
results interpretation protocol fig 
values changed previous iteration 
time key key satisfies requirements put forth sec 
vii key satisfies replacing statements key encryption change protocol 
locate uses key 
just variable value key kbs definition fb encrypting dm decrypting 
making changes replacing decryption case statement replacing encryption removing case statement get protocol fig 

denote length value variable dfb 
analysis sec 
viii consider protocol secure am am var sent iteration protocol transformation 
values variables fig 

protocol prelude program kas gen key kbs gen key constant constant zd fa constant receive dm decr kbs ab receive bm decr ab program program random send receive wait check fa dm dfa check dm send dm ab dm am encr ab send am receive kab gen key dfb kab fb encr kbs dfb dfa kab fb fa encr kas zd fa signal send fa fig 

example protocol iteration removing case statements var dfa const dm tuple input const key encr key tuple key const dm input dm encr key tuple key const ab key am encr key secret fa encr key const fig 

interpretation protocol fig 
changes protocol prelude program kas gen key kbs gen key constant constant zd fa constant zd fb constant receive wait check fb dm dfb ab receive bm decr ab program program random send receive wait check fa dm dfa check dm send dm ab dm am encr ab send am receive kab gen key dfb kab fb encr kbs zd fb signal dfa kab fb fa encr kas zd fa signal send fa fig 

example protocol second iteration var dfb const dm tuple input const key encr key const dm encr key const fb encr key const dfa tuple input const key encr key const dm tuple key const ab key bm decr key input fig 

interpretation protocol fig 
changes time key key satisfies requirements put forth sec 
vii 
set var sent dm am fa 
variables value am contains key occurs encryption key 
set variables occurring check statements fa dm fb 
values variables contains key 
set variables occurring ciphertexts decryption statements empty decryption statements 
set variables keys encryption decryption statements kas kbs kab ab ab 
value variables key permitted 
set variables occur projection statements dm 
variables value dm contains key 
outermost constructor dm tuple known statically projection succeeds fails case succeed projection operator 
replace decryptions key case statements encryption key encryption zm length remove case statement introduced sem semaphore giving protocol fig 

analysis sec 
viii consider protocol fig 
secure variable defining bm variable sent network termination execution depend value 
analysis checking cryptographic protocols preserve confidentiality secret messages 
analysis works applying transformation described sec 
vii protocol resulting transformed protocols 
security protocols checked analysis described sec 
viii 
original protocol deemed secure transformed protocols secure 
analysis correct respect computational semantics complexity theoretical definition confidentiality 
protocol prelude program kas gen key kbs gen key constant constant zd fa constant zd fb constant zm constant receive wait check fb dm dfb ab receive wait check am bm program program random send receive wait check fa dm dfa check dm send dm ab dm am encr ab zm signal send am receive kab gen key dfb kab fb encr kbs zd fb signal dfa kab fb fa encr kas zd fa signal send fa fig 

example protocol third iteration directions extended 
consider richer program languages expressing protocol parties 
mean interpretation sec 
vii choice keys sec 
vii complex 
possible longer replace case statement number equality checks assignments 
analysis similar sec 
viii may necessary find allowed 
case statements replace introduce new constructs set trm 
new constructs bring rules definitions 
consider integrity properties 
machinery protocol interpretation may quite helpful determining certain state reachable 
try add different cryptographic primitives 
probably add cryptographic primitive easily security definition requires indistinguishable ideal system 
workings ideal system easily expressible program language 
possible candidates public key encryption digital signatures message authentication codes may consider different security definitions cryptographic primitives example pseudorandom permutations symmetric encryption 
acknowledgments thankful anonymous referees ieee security privacy conference birgit pfitzmann comments 
supported estonian science foundation 
abadi rogaway reconciling views cryptography computational soundness formal encryption international conference ifip tcs ser :10.1.1.29.1076
lncs van leeuwen watanabe hagiya mosses ito eds vol 

sendai japan springer verlag aug pp 

abadi formal eavesdropping computational interpretation theoretical aspects computer software th international symposium tacs ser :10.1.1.29.1076
lncs kobayashi pierce eds vol 

sendai japan springer verlag sept pp 

hermann security analysis cryptographic protocols diploma thesis university may estonian english summary 
laud symmetric encryption automatic analyses confidentiality active adversaries cybernetica tech 
rep ar feb 
computationally secure information flow ph dissertation universitat des saarlandes 
handling encryption analyses secure information flow programming languages systems th european symposium programming esop ser 
lncs degano ed vol 

warsaw poland springer verlag apr pp 

pfitzmann waidner cryptographic security reactive systems workshop secure architectures information flow ser 
electronic notes theoretical computer science schneider ryan eds vol 

royal holloway university london elsevier science 
pfitzmann waidner composition integrity preservation secure reactive systems ccs proceedings th acm conference computer communications security 
athens greece acm press nov pp 

model asynchronous reactive systems application secure message transmission ieee symposium security privacy 
oakland california ieee computer society press may pp 

backes cryptographically sound analysis security protocols ph dissertation universitat des saarlandes 
backes jacobi ii cryptographically sound verification security protocols stacs th annual symposium theoretical aspects computer science ser 
lncs alt eds vol 

berlin germany springerverlag feb pp 

backes pfitzmann waidner universally composable cryptographic library proceedings th acm conference computer communications security 
washington dc acm press oct 
blanchet automatic verification cryptographic protocols logic programming approach invited talk th acm sigplan international conference principles practice declarative programming ppdp 
uppsala sweden acm press aug 
backes pfitzmann waidner symmetric authentication simulatable cryptographic library computer security esorics th european symposium research computer security ser 
lncs gollmann eds vol 

norway springer verlag oct pp 

backes pfitzmann symmetric encryption simulatable dolev yao style cryptographic library cryptology eprint archive report eprint iacr org :10.1.1.3.4629
canetti unified framework analyzing security protocols electronic colloquium computational complexity eccc vol 

canetti fischlin universally composable commitments advances cryptology crypto st annual international cryptology conference ser 
lncs kilian ed vol 

santa barbara california springer verlag aug pp 

canetti krawczyk universally composable notions key exchange secure channels advances cryptology eurocrypt international conference theory application cryptographic techniques ser :10.1.1.112.1891
lncs knudsen ed vol 

amsterdam netherlands springer verlag apr pp 

canetti lindell ostrovsky sahai universally composable party multi party secure computation proceedings th annual acm symposium theory computing 
montreal quebec acm may pp 

herzog computational soundness formal adversaries master thesis massachusetts institute technology sept :10.1.1.20.5370
bellare desai pointcheval rogaway relations notions security public key encryption schemes advances cryptology crypto th annual international cryptology conference ser 
lncs krawczyk ed vol 

santa barbara california springer verlag aug pp 

bellare rogaway random oracles practical paradigm designing efficient protocols ccs proceedings st acm conference computer communications security :10.1.1.41.4144
fairfax virginia acm press nov pp 

herzog liskov micali plaintext awareness key registration advances cryptology crypto rd annual international cryptology conference ser :10.1.1.116.571
lncs boneh ed vol 

santa barbara california springer verlag aug pp 

bellare authenticated encryption relations notions analysis generic composition paradigm advances cryptology asiacrypt th international conference theory application cryptology information security ser 
lncs okamoto ed vol 

kyoto japan springer verlag dec pp 

bellare desai rogaway concrete security treatment symmetric encryption th annual symposium foundations computer science 
miami beach florida ieee computer society press oct pp 

naor yung public key cryptosystems provably secure chosen ciphertext attacks proceedings second annual acm symposium theory computing 
baltimore maryland acm press may pp 

rackoff simon non interactive zero knowledge proof knowledge chosen ciphertext attack advances cryptology crypto th annual international cryptology conference ser 
lncs feigenbaum ed vol 

santa barbara california springer verlag aug pp 

thayer herzog guttman strand spaces proving security protocols correct journal computer security vol 
pp 

bellare rogaway provably secure session key distribution party case proceedings seventh annual acm symposium theory computing 
las vegas nevada acm press june pp 

yao theory applications trapdoor functions extended rd annual symposium foundations computer science 
chicago illinois ieee computer society press nov pp 

leino joshi semantic approach secure information flow mathematics program construction mpc ser 
lncs jeuring ed vol 

sweden springer verlag june pp 

lincoln mitchell mitchell scedrov probabilistic poly time framework protocol analysis ccs proceedings th acm conference computer communications security 
san francisco california acm press nov pp 

shannon mathematical theory communication bell system technical journal vol 
pp 

denning lattice model secure information flow communications acm vol 
pp 

denning denning certification programs secure information flow communications acm vol 
pp 

volpano smith irvine sound type system secure flow analysis journal computer security vol 
pp 

