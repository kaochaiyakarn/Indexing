software behavior automatic classification applications james james rehg mary jean harrold program behavior ultimately collection executions 
collection diverse unpredictable generally unbounded 
especially suited statistical analysis machine learning techniques 
explore thesis st nd order markov models event transitions effective predictors program behavior 
technique models program executions markov models clustering method markov models aggregates multiple program executions yielding statistical description program behaviors 
approach train classifiers recognize specific behaviors emitted execution knowledge inputs outcomes 
evaluate application active learning efficient refinement classifiers conducting empirical studies explore scenario illustrating automated test plan augmentation 
set potential research questions applications suggests 

software engineers seek understand software behavior stages development 
example requirements analysis may formal behavior models case analysis rapid prototyping specify software behavior 
implementation engineers aim assess reliability software behavior testing dynamic analysis 
program behavior ultimately collection executions 
collection diverse unpredictable generally unbounded 
potentially suited statistical analysis machine learning techniques 
challenge find productive applications statistical analysis techniques leverage collection executions solution software engineering problems 
college computing georgia institute technology atlanta georgia rehg harrold cc gatech edu basic question aggregate statistical measures program execution branch profiles accurate predictors program behavior 
broad range statistical machine learning techniques dynamic analysis tasks including automated oracle testing evaluation test plans detection behavior profiles deployed software reverse engineering tasks 
researchers explored questions :10.1.1.2.5030:10.1.1.14.8279
example dickinson leon podgurski demonstrate advantage automated clustering execution profiles random selection finding failures podgurski colleagues show efficacy automated classification failure reports 
example harder ernst operational difference technique automatically extract abstractions software behavior statistical summaries program executions 
researchers employed stochastic approach behavior classification uses sequences events program executions 
example munson posit event transitions actual executions final source reliability measures 
research demonstrates ability stochastic models summarize dynamic aspects program executions address directly classifying behaviors 
explore thesis st nd order markov models event transitions effective predictors program behavior 
branch profiles example extensively dynamic analysis equivalent st order markov models 
nd order markov models encode branch branch transitions potential greater predictive power modest additional cost 
previous works demonstrated power clustering techniques developing aggregate descriptions program executions 
clustering method markov models aggregates multi program test plan behavior oracle instrument profile event transitions stage 
prepare training instances execute label behaviors training instances event transition profiles behavior labels group behavior labels stage 
train classifier behavior groups bn train classifier group classifiers cb cbn 
building classifier stage prepare training instances stage train classifier 
ple program executions yielding statistical description program behaviors 
approach train classifiers recognize specific behaviors emitted execution knowledge inputs outcomes 
particular classifiers require distinct failure state detect failure 
key question statistical models characterize set behaviors induced test plan 
useful application automatic discovery new behaviors captured test plan 
application classifier identifies program executions unknown behaviors 
executions evaluated labeled refine classifier 
process known bootstrapping example class techniques known active learning 
ability identify executions behavior recognized allows characterize set executions evaluating subset containing unknown behaviors 
contributions technique models program executions markov models automatically clusters build classifiers 
application technique efficiently refines classifiers active learning bootstrapping demonstration advantages example automated test plan augmentation 
set empirical studies demonstrate markov models predictors program behavior clustering markov models train classifiers recognize unknown behaviors 

software behavior classification technique builds software behavior classifier stages 
describe basic flow technique detail illustrate algorithms 

overview assemble classifier classifier shows data flow diagram technique takes inputs subject program test plan behavior oracle outputs classifier test plan contains test cases detail inputs expected outcomes 
behavior oracle evaluates execution ek induced test case tk outputs behavior label bk restricted pass fail stage prepare training instances technique instruments get executes records event transition profiles 
event transition transition program entity types st order event transitions include branches source statement sink statement method calls caller callee pairs definition type nd order branch branch 
event transition profile frequency event transition occurred 
execution ek test case tk behavior oracle uses outcome specified tk evaluate label ek 
produces training instance consisting ek profile behavior label stored database 
stage train classifier technique groups training instances distinct behavior labels 
bn generated behavior oracle 
example behavior labels pass fail result behavior groups 
technique converts training instance group st order discrete time markov model referred markov model 
markov models encode order event transitions st nd order event transitions 
technique uses machinelearning paradigm called passive training train classifier cbk behavior group bk 
passive training classifier trains instances 
technique assembles behavior group classifiers cb 
cbn assemble classifier entry arc profile branch profile branch profile markov model branches st order event transitions entry entry exit entry arc exit entry exit exit branch profile exit branch profile profiled arcs execution shown solid arrows 
markov model branch branch nd order event transitions 
markov models profiles 
fore exploring algorithm shown discuss markov model building 

building markov models central technique markov models encode event transition profiles produced markov models capture time independent probability state time state time 
event transition profiles execution represent probability state event time state event time 
example consider control flow graph cfg 
arcs cfg event transitions branches loop backedges connections join points 
node branches leaving associated profile frequency execution probability branch taken function relative frequencies 
illustrate consider cfg 
branch profiles execution shown labels branch 
example branch profile denotes exercised times 
markov model built branch profiles simply adjacency matrix cfg profiles entries normalized row shown markov model branches control flow graph directed graph nodes represent statements basic blocks edges represent flow control 
algorithm input 
sn set states including final exit state sto profile list ordered triples transition profile string representing behavior label output markov model new array foreach sto profile profile return 
algorithm build model 

markov model possibility nd order branch branch transitions shown 
example markov model branch branch followed times time total branch branch transitions emanating 
algorithm shown example implementation transformation 
constructs behavior model matrix representation markov model execution profiles 
inputs set states identify event transitions 
contains event transitions profiles stored ordered triples describing transition state state sto corresponding profile sto profile 
behavior label model 
output triple model profile data label 
line matrix model initialized cardinality lines transition involves states recorded lines row matrix normalized dividing element row sum elements row sum zero 
execution shown inputs st order event transitions entry exit entry exit 
pass instance inputs nd order exit 
pass instance case output component corresponding markov model shown 
algorithm sim input 
sn set states including final exit state di bk list ordered triples sto profile string representing behavior label sim function compute similarity markov models output set markov models initially foreach di bk behaviors cb initialize classifier behavior foreach cb behaviors foreach di bk cb cb di bk deltas collect pair wise deltas stats new array cb cluster statistics cb agglomerative hierarchical clustering foreach mi di bk cb cb foreach mj dj bk cb cb deltas deltas sim mi mj stats cb deltas knee stats break mx min deltas dx dy bk mx cb add behavior models return 
algorithm train classifier 

training classifier algorithm shown trains classifier models generated 
inputs sim 
set states identify event transitions called 
list triples containing test case index data structure defined behavior label bk 
sim function tailored specific program behavior set study 
sim takes markov models arguments returns real number computed difference models 
define sim empirical study section 
lines empty classifier cbk initialized discrete behavior bk line begins processing bk 
lines classifier cbk populated models built applying training instance exhibiting bk 
lines initialize deltas stats explained 
remainder algorithm clusters models cbk reduce population merge similar redundant models sim 
approach adaptation agglomerative hierarchical clustering 
clustering proceeds follows 
algorithm uses sim calculate pair wise difference pairs models cbk selects pair models smallest difference 
pair models merged reducing cardinality cbk 
process repeats stopping criterion 
lines sim calculate pairwise differences accumulate deltas line 
iteration algorithm calculates standard deviation values deltas stores stats cbk line 
cardinality cbk decreases iteration serves index stats 
knee checks set standard deviations accumulating stats line determine rate change slope line fit 
knee detection done hand purposes empirical evaluations detect knee sum standard error sse linear regression data points stats increases factor iterations 
knee detected clustering stops behavior group models cbk added final classifier 
absence knee process stops model constraint line 
closest models merged lines calling union corresponding profile sets 
note clusters formed new models contains profiles training instances contributing cluster 
line clustered models cbk added classifier 
behavior groups processed final returned 

classifier classifier label new executions classify new execution ek constituent models rates ek probability score 
model highest probability score provides behavior label ek 
probability score probability model produced sequence event state transitions execution ek 
example refer consider execution program execution trace branches including entry arc entry arc 
calculate probability score markov model produced compute product successive probabilities transitions entry arc 

profile branches trace 
probability directly calculated profiles exponents model return probability score zero meaning unknown execution scoring zero probability model 
note probabilities calculated multiplication small ease computation standard transformation sum logarithms probability 

bootstrapping classifier number learning strategies training classifiers addition passive learning technique 
concentrate type active learning called bootstrapping 
application bootstrapping uses classifier score new executions collect executions remain unknown 
unknown executions considered candidates representing new behaviors evaluated behavior label identified new training instance classifier 
classifier retrained expanded set training instances 
explore application bootstrapping classifier training scenario section 
scenario inform empirical studies subsequent section 

scenario section scenario illustrates technique aid developer extending scope existing test plan 
developer dev designed implemented version program dev developed test plan plans expand test releases dev interested measuring quality test plan terms coverage requirements 
test plan development testing expensive developers release software tested accepted core functionality 
measure test plan quality dev estimate risks involved releasing current test plan 
goal creating new test cases test plan test additional behaviors 
design test case involves selecting test data induce new behavior evaluating outcome executing test data 
dev wants augment test plan new test cases seeks way reduce cost doing 
dev automated test data generator relies employees evaluate execution 
provide solution dev application bootstrapping refine classifier built technique 
data flow diagram application 
test data generator execute classify unknown behaviors test plan building classifier stage 
evaluate label outcome training instances building classifier stage 
see 
building classifier stages 

automating test case selection 
diagram stage technique produces instrumented set training instances initial test plan 
stage technique produces classifier application executes test data produced test data generator classifies execution bootstrapping process application selects candidates executions remain unknown 
candidates evaluated behavior label 
stored new training instances refining corresponding test case candidate generated added test plan 
application certain intervals augmented set training instances stopping rate detection unknown executions falls threshold 
application provides economic benefits dev 
rate unknown executions produced dev estimate risks associated current test plan 
secondly application dev improve efficiency new test cases new behaviors generated compared simply evaluating new executions 
explore gain efficiency empirical study section 

empirical studies validate technique explore described scenario performed empirical studies 

infrastructure subject studies program space interpreter antenna array definition language written european space agency 
space consists procedures loc versions containing fault discovered development set tests cases 
studies chose st order method calls nd order branch transitions event transitions models 
aristotle analysis system instrument fifteen randomly chosen versions space profile transitions executed version test cases stored results relational database 
built tool argo implements algorithms technique application 

empirical method empirical method evaluates classifiers built technique application bootstrapping 
studies chose behavior labels pass fail 
method steps database profiles branch branch method call event transitions space 
select version space 
select set test cases training 
build classifier 

evaluate classifier remaining test cases 
evaluations define metrics classifier precision classifier safety 
classifier precision ratio number unknown executions number classifications attempted 
classifier safety ratio number executions correctly classified difference number classifications attempted number unknown executions 
classifier precision measures ability classifier recognize behaviors 
classifier safety measures behavior detection rate 
example suppose scores total executions correctly classifies incorrectly classifies leaving unknown 
classifier precision classifier safety 
note possible classifier recognize executions incorrectly yielding maximum precision zero safety 
technique requires definition similarity function sim 
sim inputs models compared 
sim manipulates models permanently alter 
developed definition sim space trial error discovering agglomerative clustering binary metric performed better nd order branch branch excluded 
follows steps 
set entries branch branch transitions keeping method transitions 
set non zero entries 
calculate binary matrix difference sim ij ij 
study evaluating classifiers goal study evaluate technique passively training classifiers terms classifier precision classifier safety 
selected versions space repeated process times 
select random training sets sizes 

build classifier training set 

evaluate classifiers 
summarizes results classifiers evaluated 
graph horizontal axis represents size training set vertical axis represents classifier precision 
graph box plot summarizes distribution results classifiers built training set size 
top bottom box represent third quartiles respectively additional horizontal line box locates median 
instance training set size median quartile third quartile 
whiskers box mark extent iqr iqr inter quartile range vertical dimension box 
individual points whiskers shown outliers 
trend line fit medians shown graph quadratic 
table summarizes parametric statistics 
training set size listed left column table shows number classifiers mean standard deviation confidence interval mean 
size training set increases classifier precision improves size mean 
mean represents unknown test cases 
likewise standard deviation represents test cases 
quadratic trend line decreasing variation distribution classifier precision values increasing training set size suggest rate improvement continue decrease 
result property test comparative passive variables training set size performed jim classifier precision classifier precision passive learning training set size training number standard confidence set size classifiers mean deviation interval mean 
study classifier precision 
space distribution behaviors test suite 
results indicate classifier model able learn continuously improve data albeit slowing rate 
table summarizes parametric statistics classifier safety 
means uniformly high 
possible larger training set sizes reveal trend classifier safety current high value room improvement 
mean value page training set size represents wrongly classified behaviors 

study bootstrapping classifiers goal second study evaluate application bootstrapping refining classifiers built technique 
order compare results study chose approach bootstrapping gives classifier new executions number unknown executions reaches threshold 
study set threshold 
labeled executions size training number standard confidence set size classifiers mean deviation interval mean 
study classifier safety 
test comparative active variables training set size performed jim classifier precision classifier precision bootstrapping training set size training number standard set size classifiers mean deviation interval mean 
study classifier precision 
database lookup added training set classifier 
retrained classifier augmented set training instances repeated search unknown executions 
training set size increments parallel study 
instance study exact initial training set size study 
summarizes results classifiers evaluated graph table similar fig page ure 
variation distribution classifier precision values decreases increasing training set size 
classifier precision approaches training set size mean represents unknown executions 
quadratic trend line fit medians graph asymptotic classifier precision 
result property space distribution behaviors test suite 
results indicate study classifier model able learn continuously improve data albeit slowing rate 
table summarizes parametric statis size training number standard confidence set size classifiers mean deviation interval mean 
study classifier safety 
tics classifier safety 
study means uniformly high 
possible larger training set sizes reveal trend classifier safety current high value room improvement 
mean value training set size represents wrongly classified behaviors 
mean value slightly study comparison appropriate small size training set 

study passive learning vs bootstrapping goal third study compare rates growth classifier precision passive learning bootstrapping 
comparison motivates scenario 
comparison results study study shown 
dotted curve classifier precision passive learning vs bootstrapping training set size 
study comparison learning techniques 
shows means study solid curve shows means study 
sets classifiers initialized training set size 
training set size increases gain classifier precision bootstrapping passive learning 
example consider size difference executions 
imagine developer dev scenario space built initial classifier test cases test plan 
additional investment evaluations executions giving training set size classifier study yields average unknown executions 
corresponding classifier study yields average unknown executions 
benefit application bootstrapping passive learning classified executions investment evaluating executions 
graph clear rate improvement continues increase training set size 
second economic benefit dev estimation risks involved releasing current test plan 
simply technique build classifier test plan measuring rate unknown executions produces additional test data dev rate quality test plan 
instance fixed time new test data produce unknown executions dev confidence test plan 
hand high rate detection unknown behaviors expressed classifier precision signals risk deployment 

related previous closest spirit method podgurski colleagues 
uses clustering techniques build statistical models program executions applies tasks fault detection failure categorization 
primary differences technique previous central role markov models approach active learning techniques improve efficiency behavior modeling 
dickinson leon podgurski demonstrate advantage automated clustering execution profiles random selection finding failures 
various profiles including branch profiles basis cluster formation 
focus utility nd order markov models predictors program behavior 
podgurski clustering combined feature selection multidimensional scaling visualize resulting grouping executions 
works clustering methods passive sense clusters formed batch data subsequent analysis 
contrast explore active learning technique interleaves clustering evaluation greater efficiency 
group related papers share approach markov models describe stochastic dynamic behavior program executions 
whittaker markov chains model software usage specifications prior implementation 
contrast markov models describe statistical distribution transitions measured executing programs 
cook wolf confirm power markov models encoders individual executions study automated process discovery execution traces 
concentrate transforming markov models finite state machines models process 
comparison technique uses markov models directly classify program behaviors 
jha tan maxion markov models event traces basis intrusion detection 
address problem scoring events encountered training focus role clustering techniques developing accurate classifiers 
final category related uses wide range alternative statistical learning methods analyze program executions 
models methods works differ substantially detail share common goal developing useful characterizations aggregate program behaviors 
harder ernst automatically classify software behavior operational differencing technique 
method extracts formal operational abstractions statistical summaries program executions uses automate augmentation test suites 
comparison modeling program behavior exclusively markov statistics events 
gross colleagues propose software dependability framework monitors running programs collects statistics multivariate state estimation automatically builds models predicting failures execution 
comparison markov statistics events model program behavior 
munson posit actual executions final source reliability measures 
model program executions transitions program modules additional terminal state represent failure 
focus reliability estimation modeling transition probabilities failure state 
focus behavior classification programs may defined failure state 
ammons bodik larus describe specification mining technique extracting formal specifications interaction traces learning probabilistic finite suffix automata models 
technique recognizes stochastic nature executions focuses extracting invariants behavior mappings execution event statistics behavior classes 

discussion technique automated modeling classification software behaviors equivalence markov models st nd order profiles program executions 
application technique efficiently refines classifiers bootstrapping illustrated scenario application reduce costs help quantify risks software testing development deployment 
performed empirical studies validate technique application support scenario 
threats validity results 
threats arise fifteen versions medium sized program finite set test cases 
space commercial program versions contain actual faults development 
furthermore specific structure space may uniquely suited technique 
empirical studies fifteen versions space demonstrated application technique effective building training behavior classifiers space 
suggests number research questions additional applications 
discovered agglomerative hierarchical clustering sensitive granularity similarity metric 
investigate ways tune metrics suggested explore additional clustering algorithms 
second st nd order powerful modeling classification behaviors 
plan explore models order higher determine effective granularity modeling dependencies 
investigate uses models detect sub behaviors inside individual modules detect behaviors modeled operational profiling 
third empirical studies demonstrate effectiveness behavior labels pass fail saw classifiers behaviors composed models 
suggests may able automatically identify fine grained behaviors 
interested relationship markov models specific behaviors representation requirements specifications program 
relation may lead techniques evaluating quality test plan tools aid reverse engineering 
fourth empirical studies show subject bootstrapping improves rate classifier learns behaviors 
investigate machine learning techniques possible application training behavior classifiers 
particular interest determining best set event transitions colleagues suggest best set features train classifiers 
fifth empirical studies show effectiveness application classifying behavior subject 
need determine application perform programs 
formulate explore additional applications techniques detection behavioral profiles deployed software anomaly intrusion detection testing non testable programs 
explore ways provide programs self aware behaviors having access models behavior 
plan explore hidden markov models hmm extend behavior modeling technique 
hmm augments standard markov model set variables known observations 
state markov model hidden variable accessible observations emitted markov model 
hmms interesting perspectives 
simple st nd order markov models hidden state hmm induce complex distributions set observations marginalization 
observations event transitions hidden states correspond higher level categories transitions 
comparison markov models significantly complex distributions events modeled retaining attractive complexity properties current technique 
second advanced hmm models input output hmms conditional random fields support complex coupling execution events associated data program inputs outcomes 
advanced tools may enable powerful predictions program behaviors 
supported part national science foundation awards ccr ccr ccr eia georgia tech state georgia georgia tech mission office naval research national defense science engineering graduate fellowship 
william ribarsky provided key insights support 
alberto frankl filip provided space test cases 
gregg rothermel provided additional test cases advice experimental protocols 
ammons bodik larus 
mining specifications 
proceedings acm sigplan sigact symposium principles programming languages popl pages january 
aristotle research group 
aristotle software engineering tools 
www cc gatech edu aristotle 
booch rumbaugh jacobson 
unified modeling language user guide 
addison wesley boston 
harrold 
monitoring deployed software software tomography 
proceedings acm workshop program analysis software tools engineering pages november 
cohn atlas ladner 
improving generalization active learning 
machine learning 
cook wolf 
automating process discovery event data analysis 
proceedings th international conference software engineering icse pages january 
dickinson leon podgurski 
finding failures cluster analysis execution profiles 
proceedings rd international conference software engineering icse pages may 
dietterich 
machine learning sequential data review 
caelli editor structural syntactic statistical pattern recognition volume lecture notes computer science pages 
springer verlag 
duda hart stork 
pattern classification 
john wiley sons new york 
gross mcmaster porter votta 
proactive system maintenance software telemetry 
proceedings st international conference remote analysis measurement software systems pages may 
harder ernst 
improving test suites operational abstraction 
proceedings rd international conference software engineering icse pages may 
harrold rothermel wu yi 
empirical investigation relationship test behavior differences program spectra 
journal software testing verifications reliability september 
ilgun kemmerer porras 
state transition analysis rule intrusion detection approach 
software engineering 
jha tan maxion 
markov chains classifiers intrusion detection 
proceedings th ieee computer security foundations workshop csfw pages june 

behavior models specifying user expectations 
prentice hall englewood cliffs new jersey 
munson 
software reliability function user execution patterns 
proceedings annual hawaii international conference system sciences january 
musa 
software reliability engineering reliable software faster development testing 
mcgraw hill new york 
podgurski leon francis sun wang 
automated support classifying software failure reports 
proceedings rd international conference software engineering icse pages may 
linger 
cleanroom software engineering technology process 
addison wesley reading mass 
reps ball das larus 
program profiling software maintenance applications year problem 
acm software engineering notes november 
whittaker 
markov analysis software specifications 
acm transactions software engineering methodology january 
