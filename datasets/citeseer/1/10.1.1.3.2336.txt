rc december updated may computer science ibm research report survey adaptive optimization virtual machines matthew arnold stephen fink david grove michael hind peter sweeney ibm research division thomas watson research center box yorktown heights ny research division almaden austin beijing haifa india watson tokyo zurich limited distribution notice report submitted publication outside ibm probably copyrighted accepted publication 
issued research report early dissemination contents 
view transfer copyright outside publisher distribution outside ibm prior publication limited peer communications specific requests 
outside publication requests filled reprints legally obtained copies article payment 
copies may requested ibm watson research center box yorktown heights ny usa email reports ibm com 
reports available internet domino watson ibm com library nsf home version appear ieee proceedings vol 


survey adaptive optimization virtual machines matthew arnold stephen fink david grove michael hind peter sweeney member ieee virtual machines face significant performance challenges confronted traditional static optimizers 
portable program representations dynamic language features dynamic class loading force deferral optimizations runtime inducing runtime optimization overhead 
second modular program representations preclude forms program interprocedural opti mization 
third virtual machines incur additional costs runtime services security guarantees automatic memory management 
address challenges vendors invested considerable resources adaptive optimization systems production virtual machines 
today mainstream virtual machine implementations include substantial infrastructure online monitoring profiling runtime compilation feedback directed optimization 
result adaptive optimization begun mature widespread production level technology 
surveys evolution current state art adaptive optimization technology virtual machines 
index terms adaptive optimization dynamic optimization feedback directed optimization virtual machines past decade witnessed widespread adoption programming languages designed execute virtual machines 
notably java programming language common language runtime driven virtual machine technology mass marketplace 
virtual machine architectures provide software engineering advantages statically com binaries including portable program representations safety guarantees built automatic may draft version appear ieee proceedings vol 


memory thread management dynamic program composition dynamic class loading 
powerful features enhance user programming model driven success new languages 
cases dynamic features frustrate traditional static program optimization technologies introducing new challenges achieving high performance 
response industry invested heavily adaptive optimization technology 
technology aims improve performance monitoring program behavior information drive optimization decisions 
surveys major developments central themes development adaptive optimization technology virtual machines years 
categorize techniques categories selective optimization techniques determining parts program apply runtime optimizing compiler feedback directed code generation techniques profiling information improve quality code generated optimizing compiler feedback directed optimizations uses profiling information improve performance 
defining terminology section ii brief history adaptive optimization virtual machines section iii 
core addresses topics selective opti mization section iv profiling techniques section feedback directed code generation section vi feedback directed optimizations section vii 
concludes discussion research topics section viii section ix 
ii 
terminology software programs serve provide execution engine programs 
class software execution engines spans wide range domains ranging microcode binary translators interpreters high level languages apl 
domains tech drivers implementation trade offs vary significantly depending executed program representation level abstraction 
rau classified program representations categories high level representation hlr high level language algol apl java programming language directly interpretable representation dir intermediate representation simple syntax relatively small set simple operators jvm bytecode cli directly executable representation der executable binary representation bound machine architecture powerpc ia sparc 
may draft version appear ieee proceedings vol 


carry semantic information high level abstraction program representations designed help human understanding machine execution 
hlr optimizers focus providing effective translation high level abstractions program representation dir der 
translation cross wide gap simple translation generally considered expensive apply runtime hlr compilers operate offline 
optimizing hlr compilers apply aggressive program transformations relying high level semantic information expressed hlr 
hlr compilers emit der code machine execute directly runtime transla tion overhead 
main disadvantage der lacks portability machine architectures 
furthermore der carries relatively little semantic information obscuring opportunities program transformations 
result der translator comparatively little opportunity optimize program runtime environment 
provide middle ground gained favor years 
dir provides portability machine architectures machines execute dir relatively little runtime translation overhead 
dir carries semantic information falls categories representa tions facilitates aggressive program transformations easily attainable der 
define virtual machine vm software execution engine programs rau dir category 
includes implementations java virtual machine common language runtime smalltalk code 
addition providing direct execution engine modern vm architectures provide managed execution environment additional runtime services 
cierniak provide discussion typical runtime services managed execution environment including automatic memory management type management threads synchronization dynamic loading reflection exceptions :10.1.1.13.4410
cierniak discuss services introduces runtime overhead 
reviews adaptive optimization technologies designed mitigate overhead services 
iii 
brief history adaptive optimization virtual machines fundamental concepts adaptive optimization date back advent software 
due space constraints focuses directly transferred today vm cierniak term managed runtime refer call virtual machine :10.1.1.13.4410
proposes terminology virtual machine element modern runtime environment distinct subsystems compilers garbage collector 
single term virtual machine indicate sum parts 
may draft version appear ieee proceedings vol 


implementations 
refer reader aycock depth review genesis techniques survey related dynamic compilation techniques domains virtual machines 
domain virtual machines developments stand milestones evolu tion adaptive optimization lisp interpreters adaptive fortran parcplace smalltalk self java 
lisp interpreters probably represent widely virtual machines 
lisp best classified hlr syntax allows simple parsing nearly direct interpretation 
lisp implementations pioneered characteristic virtual machine services notably lisp drove development automatic memory management technology decades 
lisp provided early precursor dynamic loading lisp eval function evaluate expression current environment effect dynamically adding code running program 
hansen adaptive fortran provided depth exploration issues line adaptive optimization 
fortran certainly hlr hansen system executed dir compiler centric intermediate program representation 
hansen excellent thesis describes challenges facing adaptive optimizers regard selective recompilation including models heuristics drive recompilation dealing multiple optimization levels online profiling control systems 
influential deutsch schiffman described parcplace smalltalk virtual machine modern virtual machine 
smalltalk implementation introduced core concepts today including full fledged just time compiler inline caches optimize polymorphic dispatch native code caches 
furthermore demonstrated convincingly software virtual machines viable conventional architectures address key performance challenges language specific hardware support 
self project carried deutsch schiffman left developed advanced techniques appear virtual machines today 
technical highlights include polymorphic inline caches stack replacement dynamic deoptimization selective compilation multiple compilers type prediction splitting profile directed inlining integrated adaptive recompilation 
sun microsystems introduced java programming language stands mile stone jvm virtual machine major penetration mainstream markets 
competing customers java vendors poured resources virtual machine implementations may draft version appear ieee proceedings vol 


unprecedented scale 
quest java performance vendors embraced adaptive optimization technologies pioneered smalltalk self spurred renaissance research develop ment area 
microsoft followed java programming language common language runtime appears virtual machines continue proliferate foreseeable 
iv 
selective optimization term selective optimization denote policy virtual machine chooses apply runtime compiler 
section review development dominant concepts influenced selective optimization technology today virtual machines 
see depth review early development ideas applications arenas virtual machines 
interpreters discussed previous section early interpreters lisp may considered virtual machines 
lisp interpreter language implementations gained popularity including implementations high level languages apl snobol bcpl pascal 
day interpreters enjoy widespread implementations languages perl python matlab 
interpreters employed various techniques improve performance simplest switch implementations 
researchers investigated specialized hardware accelerate interpreters 
economics general purpose hardware driven approach favor 
important software optimization interpreters threading 
basic threading techniques interpreter jumps indirect branches directly implementation bytecode simplifying dispatch logic 
applied dynamic techniques improve basic threading runtime translation customize threaded interpreter implementation input program 
riccardi describe techniques dynamically generate threaded code order eliminate central dispatch site inline common bytecode sequences :10.1.1.23.8829
ertl gregg extended replicating code sequences investigating various interpreter generation heuristics focusing improving branch prediction accuracy :10.1.1.134.3903
gagnon hendren adapted riccardi techniques context dynamic class loading multi threading 
sullivan describe cooperation may draft version appear ieee proceedings vol 


interpreter implementation underlying dynamic binary optimizer improves efficacy underlying optimizer interpreter execution 
despite advances interpreter match performance optimizing compiler 
early papers discussed techniques cache interpreter actions effect producing simple runtime compiler see depth review 
progressively evolved full fledged runtime compilers common today vms 
interpreters remain attractive option domains space constrained devices 
just time compilers improve interpreter performance virtual machines began incorporate runtime compilers perform optimizing translation dir der fly 
simplest scheme commonly known just time jit compiler compiles code sequence directly native code immediately executes 
approach typified seminal parcplace smalltalk 
software smalltalk implementation executed interpretable virtual code code translating native code code needed 
system architecture supported mutually exclusive execution strategies interpreter simple non optimizing translator optimizing translator 
execution strategy chosen prior execution 
code space scarce resource system optimized code measured times larger corresponding code 
avoid paging fact experimental system reported virtual memory deutsch schiffman introduced code cache code discard regenerate code needed 
subsequently code caches proved effective contexts platforms code space scarce 
projects adopted jit strategy including initial self implementation initial production java virtual machines 
selective optimization concepts jit strategy introduces compilation overhead code sequence execute imposing heavy burden compilation resources compiled code space compile time scarce 
term jit commonly describe runtime compiler virtual machine selectively compile methods interpreted 
may draft version appear ieee proceedings vol 


situations virtual machine exploit known fact programs spend majority time small fraction code focus compilation resources frequently executed code sequences hot spots 
wave virtual machines implementations cheap default implementation interpreter fast non optimizing compiler expensive optimizer applied program hot spots 
system employing selective optimization requires basic components profiling mechanism identify candidates optimization decision making component choose optimizations apply candidate dynamic optimizing compiler perform selected optimizations 
components operate online program execution system minimize overhead order maximize performance 
concerning profiling mechanisms emerged obtaining low overhead coarse grained data drive selective optimization counters sampling 
counter mechanism associates method specific counter method 
counter counts method invocations loop iterations 
sampling mechanism periodically interrupts system records method methods top call stack 
external clock triggers sampling allows significantly lower overheard incrementing counter method invocation 
external clock trigger introduces non determinism complicate system debugging 
profile data decision making component selects methods code sequences optimization 
systems employ simple predetermined threshold strategy value method counter sample counter exceeding fixed threshold triggers compilation methods 
systems sophisticated strategies select methods levels optimization 
section reviews implementations strategies selective optimization systems 
selective optimization systems early suggested user optimize code selectively profile information 
knowledge hansen implemented system perform adaptive optimization automatically adaptive fortran 
adaptive fortran af compiler produced intermediate form directly interpreted optimized 
system selectively apply optimizations basic blocks loop segments code 
empirical tuning hansen settled system levels optimization addition direct interpretation 
experimental results showed may draft version appear ieee proceedings vol 


af adaptive optimization provided better performance jit strategies single optimization level 
self implementation applied hansen techniques 
self targeted interactive programming system system afford pauses compiled method highest level optimization 
self initially compiled method fast non optimizing compiler invoked optimizing compiler subset frequently executed hot methods 
considered observed pause times interactive user just total time spent runtime compiler 
self identified hot methods method invocation counts decayed time 
considered sampling identify hot methods rejected idea coarse granularity sampling 
self authors discuss open problems choosing counter heuristic project report depth studies issues 
detlefs agesen studied mixed mode execution detail exploring trade interpreter fast jit compiler slow traditional compiler adapted jit 
combination fast jit judicious slow jit longest running methods provided best results collection benchmarks 
oracle determine longest running methods 
java vms adopted compilation strategy interpreter mixed mode strategy 
self integrated recompilation decisions inlining decisions 
invocation count passed threshold self system traverse call stack starting top method heuristic find base method suitable recompilation 
compiler inline traversed call stack base method 
self team reported exploring wide range tuning values various recompilation policy heuristics 
hotspot server vm recompilation policy reported closely resembles self technique including inlining heuristic 
initial ibm mixed mode interpreter system relied invocation counts drive recompilation decisions different inlining policies 
addition counter selective optimization heuristic intel microprocessor research labs vm implemented continuous compilation uses spare processor periodically scan profile data determine methods hot need recompiled 
counter policies rely myriad heuristic tuning knobs 
hansen reports deeply iterative ad hoc tuning process find reasonable settings variety counter thresholds drive recompilation 
current industry practice vm vendors perform similar process laboriously tuning may draft version appear ieee proceedings vol 


values meet performance goals 
hansen situation determining optimization counts heuristically limitations hard change optimization count portion performance curve affected 
appreciable progress theoretical basis determining developed 

years academic projects begun exploring ad hoc counter strategies theoretically grounded policies selective optimization 
cytron considered online strategies selective optimization 
draw connection explicitly crossover strategy exactly ski rental problem online competitive algorithm guarantees online cost twice offline optimal cost 
cytron simulated study compilation file granularity 
compared jit selective optimization approaches considering background compilation thread uses spare processor continuously compile 
study simulated number scenarios calculated break points indicate long program run particular recompilation heuristic profitable 
kistler performed similar analysis realistic study virtual machine oberon 
kistler considered sophisticated online decision procedure driving compilation compiler phase estimates speedup rich set profile data 
kistler performed extensive study break points model implement model driven online algorithm virtual machine 
jikes rvm call stack sampling feed model driven optimization policy relying cost benefit model select multiple levels optimization 
jikes rvm method particular optimization level estimates benefit additional optimization outweighs cost recompilation 
estimate quantities system relies models predict speedup generated code due optimization cost recompilation period time method execute 
system estimates quantities relying aggregates offline profile data estimating point time method execute twice long point 
deferred partial compilation current production vms apply selective recompilation policies method level granularity 
recognized methods may provide best delimiters compilation units 
may draft version appear ieee proceedings vol 


hansen adaptive fortran selectively recompiled basic blocks single entry regions contain loops 
adaptive fortran associated counter basic block triggered selective compilation code sequence empirically derived heuristics 
hansen compiler perform inlining compiler applied selective optimization portions individual method selectively optimize procedure boundaries 
self optimize method boundaries inlining optimize partial methods deferred compilation 
self defer compilation code predicted execute infrequently called uncommon code 
policy saved compilation time compiler spend resources uncommon code 
program branch uncommon code system performed uncommon branch extension jumping trampoline code generate necessary code execute 
uncommon branch extension presents nontrivial engineering challenge method executable code rewritten method executes 
transition compiled versions called stack replacement osr 
hotspot server vm adopted self techniques inserting uncommon traps program points predicted infrequent require dynamic class loading 
addition hotspot server vm transfers interpreter optimized form long running loops performing osr convenient point loop 
technique adopted jvms especially important microbenchmarks :10.1.1.12.9870
investigated interplay deferred compilation inlining modest performance benefits 
dynamic deoptimization virtual machine services forms introspection debugging require virtual machine interpret stack frames program state generated optimized code 
adaptive optimization system produces code various optimization levels various conventions complicate introspective virtual machine services 
example smalltalk exposed method activation state programmer data objects 
deal deutsch schiffman implemented mechanism recover required code activation state code closure record 
optimizing translator identified distinguished points code sequence user may interrupt normal execution examine activation state 
points points compiler recorded mapping information recover desired code may draft version appear ieee proceedings vol 


state 
self pioneered deoptimization facilitate debugging 
self compiler mark distinguished safe points optimized code system maintain state recover original unoptimized state 
debugging breakpoint system dynamically optimized code osr transfer unoptimized version provide debugging functionality unoptimized representation 
technique allows nearly full speed debugging adopted today leading production java virtual machines 
deoptimization technology implement speculative optimizations invalidated osr needed 
discussion technique appears section vii 
profiling feedback directed optimization having compiler part runtime system allows vm apply fully automatic online feedback directed optimization fdo 
smith provides excellent discussion motivation history fdo 
particular smith highlights factors compelling motivation fdo fdo overcome limitations static optimizer technology exploiting dynamic information inferred statically fdo enables system change revert decisions conditions change runtime binding allows flexible easy change software systems 
number studies reported program transformations effectively offline profile informa tion improve performance static optimization technology 
implement fully automatic online fdo effectively virtual machine address challenges compensate overhead collecting processing profile information performing associated runtime transformations account partial profile availability changing conditions affect profile data stability 
section describes significant profiling technology driving fdo today virtual machines today 
profiling techniques key technical challenge effective online fdo collect accurate profile data low overhead 
selective optimization systems monitor running program identify candidates runtime optimization previously discussed section iv feedback directed optimizations require may draft version appear ieee proceedings vol 


fine grained profiling information 
example fdo techniques require profile data regarding individual program statements individual objects individual control flow paths 
collecting fine grained profile data low overhead presents major challenge making forms fdo difficult perform effectively online 
address challenge vm implementors investigated variety low overhead fine grained profiling techniques 
years sophisticated effective techniques emerged 
organize common mechanisms virtual machines gather profiling information fdo categories runtime service monitoring hardware performance monitors sampling program instrumentation 
review examples category approaches combine techniques 
runtime service monitoring technique system monitors state associated various virtual machine runtime services 
cases program runtime service exhibits temporal locality system exploit optimization 
section vii discusses variety optimizations dynamic dispatch monitor runtime data structures record past dispatch behavior 
section vii discusses optimizations monitor runtime state relating synchronization 
memory management system provides particularly rich body information drive fdo 
memory manager observe trends allocation garbage collection heap utilization great detail 
section vii describes optimizations exploit information 
hardware performance monitors microprocessors provide specialized hardware provide online profile information regarding processor level events 
despite fact mainstream processors provide rich variety hardware performance monitors vms exploited approach driving fdo 
aware published report describes orp vm hardware performance monitors guide memory prefetch injection 
takes advantages hardware support sampling cache misses itanium platform 
dcpi provides sampling system uses interrupts generated hardware performance counters alpha processor identify frequently executed portions program 
knowledge virtual machine employed technique 
speculate vms generally exploited hardware performance monitors due complexity architecture specific counter infrastructures difficulty mapping low level counter data high level program constructs 
remains seen vms develop techniques overcome difficulties effectively exploit hardware performance monitors 
may draft version appear ieee proceedings vol 


sampling sampling system collects representative subset class events 
observing limited percentage events sampling allows system limit profiling overhead 
sampling provide sufficient profile data drive vm services 
discussed section iv virtual machines sample executing methods derive execution time profile drive selective optimization 
feedback directed optimizations vms additionally sample program call stack 
call stack sampling provide context sensitive call graph profiles guiding feedback directed inlining 
self count scheme determine sample call stack jikes rvm timer approach 
feedback directed optimizations rely fine grained profile information basic block frequencies value profiles difficult collect efficiently purely sample approach 
systems collected profiles help hardware support 
program instrumentation inserting intrusive instrumentation running program virtual machine collect wide range profile data fine granularity 
studies report offline profiles collected instrumentation guide feedback directed optimization 
types instrumentation impose intolerable runtime overhead slowdowns ranging non instrumented code uncommon overheads range times slower reported 
vms apply techniques reduce overheads able apply instrumentation online acceptable performance 
primary mechanism reduce instrumentation overhead limit time mented code executes 
example vm instrument unoptimized code interpreted code allowing instrumentation terminate automatically vm selective optimization mechanism hot method 
contemporary vms apply technique 
approach number advantages instrumentation imposes minimal overhead poor performance unoptimized code optimizer profile data available method enabling early application fdo implementing approach requires relatively low engineering effort 
despite advantages instrumenting unoptimized code significant limitations 
system profiles methods early stages execution profile may reflect dominant behavior behavior changes early stages 
second certain profiles guiding fdo difficult collect unoptimized code 
example optimizations aggressive inlining drastically change structure method 
determining hot paths inlined may draft version appear ieee proceedings vol 


code nontrivial profile obtained prior inlining 
avoid profiling start behavior whaley proposed stage model fine grained profiling inserted second stage 
general solution adopted systems inserts instrumentation fully optimized code 
solution avoids aforementioned drawbacks instrumenting unoptimized code introduces challenges 
fact method selected optimization suggests method may executed frequently naive instrumentation result severe performance degradation 
kistler inserted instrumentation optimized code special mechanism enforce short profiling interval 
approach effective applications degrade performance unacceptable levels making approach risky production level vm 
ibm dk instrumented optimized code enforced short profiling period code patching dynamically remove instrumentation executed fixed number times 
improvements hierarchical structure enabling disabling counters collect accurate profiles fewer samples 
profiling shorter bursts increases probability observed behavior accurately reflect behavior 
combining instrumentation sampling combined instrumentation periodic sampling observe program behavior longer window execution 
code patching technique described repeated enabling disabling instrumentation collect data sets short bursts 
overhead maintaining cache consistency patching limit sample frequency achievable approach 
arnold ryder describe technique sampling instrumentation allows system enable disable instrumentation finer granularity 
technique introduces second version code instrumented method lightweight checks determine instrumented version executed 
technique online virtual machine collect profiling information fdo 
chilimbi modified technique online binary optimizer guide prefetching optimizations 
stability phases online system vm ability consider stability profile phases single execution may attempt react appropriately program enters new phase 
kistler pioneered approach interactive oberon vm periodically capturing vector composed number occurrences event basic block counter 
system computed similarity metric vectors 
value exceeded threshold system initiated new may draft version appear ieee proceedings vol 


profile optimization stage 
aside kistler little published describes online phase detection vm 
contributing factor certain types adaptive optimization require explicit phase shift detection profiling scheme automatically discover changes behavior 
example implementations selective optimization require explicit phase shift detection 
application behavior changes new methods hot selective optimization systems detect new hot methods guide optimization appropriately 
current vms take action previously optimized method cold discarding generated code important system limited code cache 
theory optimizations inlining code layout specialization benefit reconsideration running program enters new phase 
additionally optimization decision profitable phase degrade performance subsequent phase exhibits different characteristic behavior 
remains open adaptive optimization systems able exploit phase detection tailor optimizations effectively efficiently online 
number offline studies examined issues relating profile stability different inputs basic blocks receiver types procedure calls indirect control transfers memory 
wall level stability basic block profiles depended heavily event profiled 
grove receiver type profiles produced stable results 
wang rubin different users interactive programs different usage patterns observed performance degradation profiles different user drive profile directed optimizations 
dynamo binary translator addressed similar issues monitoring creation rate opti mized code fragments 
system detected increase optimization activity occur different collection instructions begins executing flush code cache 
chilimbi online optimization system accounted potential phase shifts periodically re gathering profile data fixed duration 
computer architecture community problem profile stability interest offline program execution online contexts 
studies employed phase detection identify phase profile representative complete program behavior reduce simulation time 
online phase detection dynamically adapt multi configuration hardware program behavior tailor code sequences frequently executed phases track predict phases 
may draft version appear ieee proceedings vol 


vi 
feedback directed code generation section review feedback directed code generation virtual machines 
section concentrates feedback directed techniques improve quality code generated optimizing compiler 
section vii discusses forms fdo virtual machines 
remainder section describes feedback directed variants inlining code layout instruction scheduling miscellaneous forms feedback directed code generation 
inlining inlining replacement call site contents method calls proved important compiler optimizations especially object oriented programs 
overly aggressive inlining impose steep costs compile time code size 
studies examined cost benefit trade offs profile directed inlining offline profile data 
considered inlining knapsack problem measuring inlining benefit obtained various inlining budgets greedy algorithm choose inlining candidates 
studies concluded profile driven greedy algorithms judiciously guide inlining decisions cover vast majority dynamic calls reasonable compile time overhead 
knowledge virtual machines adopted greedy inlining algorithms sack formulation 
central obstacle virtual machines tend consider recompilation decisions local method method basis knapsack inlining studies rely comprehensive global view entire program 
virtual machines relied variety ad hoc heuristics drive profile directed inlining 
self implementations introduced number techniques effective inlining 
compared mainstream languages self placed greater premium effective inlining deal extremely frequent method calls 
reviewed section vi self self self introduced progressively sophisticated optimizations predict types inline split code static type estimates 
self augmented techniques type feedback vm provide runtime compiler profile receiver types collected current run 
self compiler information choose inlining candidates guide transformations deal inlined dynamic dispatch 
reported results show significant speedup improvement type feedback show profile directed approach results significantly better code sophisticated optimizer self relied static type estimates 
may draft version appear ieee proceedings vol 


reviewed section iv self adaptive optimization system incorporated inlining decisions recompilation policy walking call stack find suitable root method recompile inlining 
hotspot jvm adopted self technique driving recompilation policies inlining decisions 
performs guarded inlining class hierarchy analysis profile indicated single receiver type 
dean chambers inlining trials approach systematically drive inlining decisions 
self compiler tentatively inline call site monitor compiler transformations quantify resultant effect optimizations 
virtual machine maintained history inlining decisions resultant effects drive inlining decisions history 
approach help guide intelligent inlining decisions effect inlining optimizations difficult predict 
waddell dybvig report similar approach dynamic scheme compiler 
aware production virtual machines adopted methodology 
studies report fully automatic online profile directed inlining java improves performance factors approximately compared comparable strategies ignore profile data 
jikes rvm incorporated inlining cost benefit model selective recompilation expected benefit recompiling method contains hot call site 
arnold augment scheme profiling hot methods determine hot basic blocks methods 
inlining budgets call sites hot blocks increased 
explored online profile directed inlining heuristics relying approximation dynamic call graph collected instrumenting hot target methods short time periods 
concluded non tiny methods heuristics solely profile data outperformed strategies rely static heuristics 
compiler uses call site frequency augment inlining heuristics improve guarded decisions 
grove explored advanced inlining heuristics consider static dynamic characteristics call stack 
code layout code layout code positioning frequently implemented forms feedback directed optimization 
transformation compiler rearranges code maximize instruction locality improve branch prediction attempts lay frequent code paths contiguously address space 
may draft version appear ieee proceedings vol 


pettis hansen detailed popular approach profile directed code positioning offline study show significant performance improvements possible 
arnold employ variant top code positioning online manner obtain modest improvements 
similar online variant reported ibm dk java 
adl tabatabai employ variant top code positioning algorithm extended perform tail duplication block laid 
profiles drive method splitting partitioning compiled code hot cold section alignment branch targets 
instruction scheduling related vein researchers documented significant improvements feedback directed struction scheduling 
instruction scheduling seeks order instructions maximize flow instructions microprocessor pipeline 
impact compiler project conducted number influential studies offline profile directed instruction scheduling 
naturally efficacy instruction scheduling depends highly underlying instruction architec ture implementation 
order superscalar processors large reorder buffers mitigate need instruction scheduling 
statically scheduled processors itanium place premium effective instruction scheduling 
adl tabatabai perform online profile directed instruction scheduling edge information obtained instrumentation derived sampling itanium performance monitors 
combines instruction scheduling trace formation tail duplication address phase ordering issues techniques 
adaptive technique compiler generates multiple implementations code sequence emits code choose best implementation runtime 
static compiler generates various versions purely information known compile time 
example describe compiler generated versions fortran loops runtime chooses best implementation runtime values loop bounds increment values access patterns 
similar techniques applied java programs 
example describe static create safe regions java code free exception dependencies certain aliases 
safe regions compiler apply aggressive optimizations 
may draft version appear ieee proceedings vol 


virtual machines form speculatively inline targets dynamic dispatch 
simplest mechanism introduce diamond testing runtime condition inlined method body branch line call runtime condition fail 
arnold ryder proposed mechanism called thin guards potentially expensive set runtime checks replaced small set boolean checks 
avoid entire runtime cost conditional check vm may speculatively insert op instruction patch point insert runtime check 
invalidation vm replace patch point code sequence equivalent aforementioned runtime check 
aggressive implementation break diamond deferred compilation discussed section iv 
technique pioneered self adopted hotspot jikes rvm 
failed inline guard jumps osr point contains code models method exit 
control flow reaches point system dynamically generates code handle failed guard 
infrequent path models method exit forward dataflow facts path merge back frequent path resulting improved dataflow properties code guard 
fink qian evaluated impact breaking diamonds jikes rvm find significant value improved dataflow guarded inlining 
self implementations pioneered sophisticated static techniques call message splitting 
self compiler replicate control flow downstream merge point preserve type information 
technique compiler optimize downstream exploiting specific type information 
self project documented progressively sophisticated forms downstream splitting starting local splitting immediately merge extended splitting handle type information lost merges splitting loops path splitting 
self enhanced efficacy splitting incorporating type feedback online profile observed receiver types 
problem static due space overhead compile time costs possible generate possible variant code sequence 
runtime compiler profile information select possible versions 
self implementations relied heavily form dynamic technique called customization 
self system generate new version method customized type receiver 
technique compiler resolve call self object compile time bypassing expensive dynamic dispatch allowing effective inlining 
focused specialization dynamic speculative runtime may draft version appear ieee proceedings vol 


constants properties 
research relied programmer annotations directives guide policies 
mock extended automated techniques derive appropriate directives 
knowledge product vm documented fully automatic profile directed specialization 
describe sophisticated automatic approach exploit runtime constant primitive values types array lengths type relationships aliasing relationships thread local properties 
systems performed simpler forms dynamic runtime profiles 
arnold edge profiling split control flow graph merge nodes 
similarly adl tabatabai perform hot path splitting tail duplication ia itanium architectures 
generated code uses absolute criteria runtime values determine implementation execute 
alternative approach empirical optimization system measure performance various implementations training period choose best implementation production period 
rinard describe instantiation technique called dynamic feedback fully automatic compiler supported system selected possible synchronization optimizations runtime 
voss eigenmann describe advanced empirical adaptive system called adapt 
adapt user describes possible optimizations domain specific language 
adapt compiler generates application specific runtime system searches best optimization parameters runtime 
time runtime system maintains best known version forms experiments evaluate experimental version generated different optimization parameters 
adapt system runtime hot spot detector focuses effort important loops identified profile data 
adapt system implemented loosely coupled coarse grain system invokes full fledged static fortran compiler runtime optimizer 
targeted compiler writers tool prototyping variants adaptive optimizations 
interesting evaluate approach full fledged virtual machine technique deal potential non intuitive effects adaptive optimization 
today production vms collect profile data course execution profile data tended aspects runtime compiler 
times fdo fairly straightforward applications individual optimization may limited impact 
result comprehensive studies miscellaneous profile directed optimizations may draft version appear ieee proceedings vol 


vms 
addition optimizations discussed sections inlining code reordering splitting arnold evaluate impact edge profiles improve loop unrolling heuristics jikes rvm 
additionally jikes rvm optimizing compiler uses profile information drive register alloca tion spill heuristics live range splitting 
runtime improvements optimizations small formally documented 
hotspot server compiler reports similar techniques 
hotspot interpreter collects counts method entries backward branches type profile call sites null information branch frequencies 
optimizer exploits information various optimizations including inlining heuristics global code motion 
years researchers ibm tokyo research lab documented number fdo applications ibm dk java 
report jit uses runtime trace information guide code generation register allocation addition code layout reported earlier 
describe feedback directed optimization accelerate exception handling required profiling determine call tree paths frequently traversed exceptional control flow 
describe speculative stack allocation optimization relying escape analysis stack replacement invalidate lazily instantiate objects 
researchers intel microprocessor research labs explored dynamic optimization tech niques accelerate exception handling handle speculative optimizations presence tions 
researchers examined software prefetching offline profile data discover access patterns 
papers reported results automatic online profile directed prefetching 
developed sophisticated lightweight profiling mechanism discover stride access patterns loop iterations 
adl tabatabai hardware performance monitors help guide placement prefetch improve access linked data structures 
chilimbi describe automatic online der rewrite tool profiles application find frequently recurring data sequences called hot data streams 
having identified hot data stream system automatically rewrites binary detect prefixes hot data streams insert software prefetch instructions exploit stream pattern 
may draft version appear ieee proceedings vol 


vii 
feedback directed optimizations section review feedback directed techniques code generation virtual machines 
subsections explore broad themes adaptive runtime systems exploiting temporal locality speculative tailoring runtime services aspects application dynamic behavior 
final subsections discuss facets memory management optimizations improve garbage collection improve program spatial locality 
temporal locality caching number runtime services quite expensive worst case significantly accelerated average case applying form caching assuming application exhibits exploitable form temporal locality 
example key characteristic object oriented programming object behavior depends runtime type opposed declared static type 
program behavior depends strongly runtime types object oriented systems pioneered adaptive techniques improve performance dynamic dispatch type testing 
techniques rely temporal locality effective 
early smalltalk systems dynamic caching avoid performing full method lookup message send 
runtime system began method lookup consulting global hash table cached results method lookups 
consulting hash table significantly cheaper full method lookup relatively expensive 
smalltalk systems added inline caches mechanism avoid consulting global cache 
inline cache system overwrites call method lookup routine direct call method called call site 
system modifies callee method prologue check receiver type matches calls method lookup routine check fails 
inline caches perform extremely call site monomorphic target exhibits temporal locality perform poorly call site dispatches multiple target methods quick succession 
polymorphic inline caches pics developed overcome weakness inline caches 
polymorphic inline cache call site invokes dynamically generated pic stub executes sequence tests see receiver object matches previously seen cases 
match stub invokes correct target method match pic terminates call method lookup routine may turn choose generate new pic stub call site extended may draft version appear ieee proceedings vol 


handle new receiver object 
implementations pics move front heuristic exploit temporal locality 
similar issues arise dispatching interface method calls java programming language 
jvms pics dispatch interface methods 
commonly technique itable virtual method table class restricted methods match particular interface class implementation 
dispatch interface method system locate appropriate itable class interface pair load target method known offset itable 
general runtime system search relevant itable dispatch time 
straightforward implementation search time increases number interfaces implemented class 
pics systems augment basic mechanism itable cache move front heuristic exploit temporal locality 
object oriented languages language constructs java instanceof require runtime system test runtime type object 
number non adaptive schemes answering questions efficiently explored discussion techniques krall 
specialized schemes particular semantics java 
virtual machines caching exploit temporal locality type testing 
example ibm dk java caches result type inclusion test class object 
temporal locality exploited reduce cost java synchronization 
observe common object locked repeatedly java thread 
exploit thread locality locking allowing lock object reserved single thread 
thread obtain lock cheaply threads attempt acquire lock cause reservation canceled expensive operation 
speculative optimizations runtime services section vi reviewed techniques compiler speculatively emit code recover speculative invariant fail 
similarly runtime system apply speculative techniques optimize runtime data structures 
pervasive data structures object oriented languages objects depend vm object model 
object model dictates vm represents objects storage best object model maximize efficiency frequent language operations minimizing storage overhead 
addition programmer specified data elements object virtual machine adds additional state may draft version appear ieee proceedings vol 


object header support operations virtual dispatch garbage collection synchronization hashing 
observed usage different portions object header varies object instance 
virtual machines adaptive object models elide portions object header determined particular object instance need 
example observed java objects need default hash code 
allocating space hash code headers object instances virtual machines tri state encoding technique bacon developed independently agesen sun evm states object hashed hashed moved 
states hash code object address 
garbage collector moves object state hashed changes state hashed moved copies old address new version object 
scheme objects space allocated header hash code necessary virtual machine adapt object model object basis accommodate hash code 
similarly java objects synchronized need portion object header 
heuristic deciding object instances predict object class locked synchronized method methods contain synchronized statements 
heuristic bacon define family object models word headers proposed adaptively adding back object instances mispredicted heuristic copying garbage collection 
speculative optimizations require runtime support invalidate optimization conditions change 
example despite possibility dynamic class loading jvms apply simple program analyses speculating set currently loaded classes entire program dynamic class loading occur optimizing accordingly 
virtually production virtual machines speculatively apply class hierarchy inlining 
optimization assumes class hierarchy complete number techniques including code patching stack replacement recover dynamic class loading changes class hierarchy invalidates speculative optimization 
may draft version appear ieee proceedings vol 


heap management garbage collection automatic memory management commonly referred garbage collection gc complex services provided vm 
garbage collectors inherently somewhat adaptive rate garbage collection amount done collection cycle depends heavily application runtime behavior 
jones lins describe rich diversity gc algorithms developed 
virtually algorithms deployed vm generally accepted best gc algorithm 
section discuss areas vms apply interesting forms adaptation online choice gc algorithms heap size management scheduling garbage collection 
interesting approach adaptively switch garbage collection algorithms adjust appli cation dynamic behavior 
reports dynamically switching mark sweep mark compact algorithms manage mature space generational collector 
describe radical approach extended version jikes rvm dynamically swap radically different garbage collection algorithms adapt application behavior 
knowledge level adaptive gc deployed production level vms 
production vms dynamically adjust size heap portion vm address space support application dynamic memory allocation requests 
heuristics rarely fully described literature 
contains detailed description policy versions ibm dk adjusts vm heap size heap utilization fraction time spent gc 
generational gc algorithms divide heap multiple regions 
objects initially allocated nursery space promoted mature space survive certain number collections 
systems fixed size nursery 
appel describes system fraction total heap utilized nursery dynamically adjusted application behavior 
vms schedule gc adaptive policies 
normally vm triggers gc memory resource exhausted exhausted exact details vary algorithm algorithm 
systems explored heuristics triggering gc memory exhausted hopes increasing efficiency gc reclaiming free memory unit gc 
hayes observed key objects unreachability indicates high probability large data structures just unreachable indicates attractive time schedule gc 
build idea suggesting scheduling gc connectivity may draft version appear ieee proceedings vol 


analysis 
sophisticated heuristics proposed schedule garbage collections stack height number pops stack 
heap optimizations spatial locality automatic memory management imposes overheads discussed previous section offers opportunities vm improve performance 
safe language prevents user code directly reading writing pointers gives vm freedom rearrange heap layout improve spatial locality 
researchers explored field reordering technique rearrange layout fields object improve spatial locality 
technique attempts lay fields object concurrently accessed hot fields fall cache line 
additionally kistler franz show order fields cache line impact performance order hardware fills individual bytes cache line 
compute field layout model takes factor account 
chilimbi proposed object splitting divides object hot cold fields separate sub objects offline profile 
system accesses cold sub object indirectly pointer hot sub object 
bringing hot fields cache object splitting improves spatial locality 
chilimbi addressed objects proposed form object splitting arrays uses offline profile information 
splits array objects particular type multiple arrays containing subset type fields 
analyzed object trace application hot spots determine splitting policy matched data access patterns 
third technique object location places concurrently accessed objects cache line 
online approaches reported 
chilimbi object affinity graph dynamic object location cecil programs 
generational garbage collector interpreted graph determine locate objects copying objects semispace 
kistler franz temporal relationship graph dynamic object location oberon 
technique detects advantageous change layout particular data structure affected code background atomically updates code data structure layout 
papers reported significant speedups object location high runtime cost maintaining object affinity graph remains problem impeded adoption techniques production vms 
may draft version appear ieee proceedings vol 


shuf proposed simpler type affinity allocation alternative 
offline profile data shuf identified small set prolific types types allocated frequently short lived 
set prolific types system enhanced method allocate cluster prolific type objects 
papers explored profile directed techniques improve locality profile data collected offline 
aware online object location object splitting field reordering results production vms time 
viii 
discussion having reviewed evolution adaptive optimization technology discuss areas appear ripe research 
optimization control policies reviewed current techniques controlling optimization rely ad hoc policies demanding extensive tuning 
agree theoretically grounded approach valuable significant technical challenges path 
satisfactory methods automatically predict impact particular transformation 
promising approach problem centers empirical optimization policies described section vi 
papers reviewed begun applying approach adaptive optimization notably adapt system inlining trials 
domain high performance numerical libraries empirical optimization succeeded number high profile projects 
hand reported model driven optimization compete empirical approach simple numerical kernels 
trade offs empirical vs model driven optimization applications described understood 
deep analysis optimizations reviewed involve substantial interprocedural analysis ipa 
ipa expensive method granularity analysis remains open question design policies runtime ipa justifies effort 
papers examined runtime ipa optimizations knowledge techniques appeared production vms 
may draft version appear ieee proceedings vol 


approach stage analysis effort performing bulk offline cheap analysis runtime 
quicksilver project investigated quasi static compiler pre compile code offline integrate code full fledged vm runtime 
philipose describe scheme automatically generate compilers staged analysis applied quasi static scenarios 
potential dynamic class loading hampers potential transformations rely interprocedural analysis language features java sealed packages mitigate impact dynamic class loading 
propose drastic approach specializing entire vm respect fixed application 
approach sacrifices dynamic class loading may suit embedded devices 
general deep analysis ipa attempt prove invariants profile information system speculate invariants hold generating proof 
vm apply transformations speculatively relying invalidation mechanisms osr heap rewriting mechanisms 
clear dominant trend deep analysis prove invariants aggressive speculation advanced invalidation combination 
ras runtime compilation especially driven sampling adds level non determinism running program 
adaptive optimization testing difficult provides opportunities non deterministic bugs past testing 
additionally sophisticated runtime optimizer adds significant complexity vm 
ignored ras reliability availability implications adaptive opti mization 
academic papers started address subject 
dejavu project investi gated enhancing vm deterministic replay aid debugging 
describes similar deterministic replay facility rivet virtual machine 
ras implications adaptive optimization technology left unaddressed threaten slow adoption new technologies 
compiler engineering research dynamic code generation focused extremely cheap code generation 
example lee leone report system consumes cycles instruction generated engler reports cycles instruction generated vcode optimizer 
hand current vms evolved side compiler cost spectrum providing full fledged may draft version appear ieee proceedings vol 


traditional runtime compilers spend thousands cycles instruction generated 
fact driven selective optimization discussed section iv 
remains seen pendulum swing back extremely cheap techniques 
example vms evolve ubiquitous speculative specialization frequent invalidation 
alternatively seen incremental improvements compile time 
example vms adopted cheap near linear register allocation techniques place graph coloring 
chen olukotun describe jit engineered major passes designed execute significantly faster smaller footprint current production jits 
evaluate optimizations jit ibm dk java report cheapest compiler optimizations provide speedup benefits 
architectural impact remains open adaptive optimization drive requirements microprocessor architecture design 
obvious issue adaptive optimization entails self modifying code 
deutsch schiffman noted self modifying code generally modern practice 
current vms dynamic code generation relatively rare event compared normal computation cost memory barriers self modifying code appear significant problem 
describe interesting study architectural impact virtual machines review related java workload characterization 
related issue concerns binary translation 
clear underlying binary optimizer dynamo improve performance vm performs adaptive optimization 
dynamic code generation certainly help problems providing binary portability solving legacy problem vliw implementations 
additionally processors ones transmeta include low level binary translators closely tied hardware target instruction set architecture isa 
open question concerns cooperation software virtual machines isa level binary translators deliver additional benefits 
new vm domains focused mainstream vms targeting fairly low level program representations 
current industry trends point proliferation higher level runtime systems provide higher level services ee asp net web services bpel 
runtime systems currently provide forms adaptive optimization management runtime structures thread pools may draft version appear ieee proceedings vol 


communication queues 
clear higher level vms benefit new specialized forms dynamic code generation optimization provided underlying vms 
anecdotal evidence suggest vms suffer severe performance problems areas adaptive optimization technology help 
current trend appearance vms small extremely space constrained devices embedded systems 
domain features plethora instruction set architectures portable program representations add significant value 
domain presents different optimization challenges including requirements minimize memory footprint power consumption reduce network transfer delay 
ix 
reviewed progression adaptive optimization technology niche academic interest widespread competitive production technology 
seen direct transfer research ideas technical literature today production systems explosion new research activity area 
selective optimization clearly major impact production systems serving core technology production vms 
feedback directed optimizations progressed research production systems mainstream vm vendors support fdo expect product vms incorporate fdo technology years 
ideas reviewed rely profound theoretical concepts 
date progress adaptive optimization technology centered overcoming formidable engineering challenges 
past research groups possessed substantial resources necessary build maintain credible vm research infrastructure 
situation changed 
today researchers build number high quality open source vms jikes rvm mono orp 
availability technology lower barriers entry field spur faster innovation coming years 
gosling joy steele java language specification 
addison wesley 
meijer gough technical overview common language runtime wilkes application microprogramming medium scale computer design conference record th annual workshop microprogramming 
acm press pp 

digital fx combining emulation binary translation digital technical journal vol 
pp 

may draft version appear ieee proceedings vol 


jr apl interpreter written apl seventh international conference apl 
acm press pp 

rau levels representation programs architecture universal host machines th annual workshop microprogramming 
ieee press pp 

cierniak eng glew lewis open runtime platform flexible high performance managed runtime environment intel technology journal vol :10.1.1.13.4410
pp 

forward managed runtime technologies intel technology journal vol 

aycock brief history just time acm computing surveys vol 
pp 

mccarthy history lisp acm sigplan notices vol 
pp 
aug 
hansen adaptive systems dynamic run time optimization programs ph dissertation carnegie mellon university 
deutsch schiffman efficient implementation smalltalk system conference record eleventh annual acm symposium principles programming languages jan pp 

chambers ungar making pure object oriented languages practical acm conference object oriented programming systems languages applications nov pp 

lzle ungar third generation self implementation reconciling responsiveness performance acm sigplan notices vol 
pp 
oct 
griswold history snobol programming languages acm sigplan notices vol 
pp 
aug 
richards implementation bcpl software portability brown ed 
cambridge university press pp 

jensen jacobi pascal compiler implementation notes rev ed institut fur informatik eth zurich tech 
rep 
perl directory perl org www perl org 
python programming language www python org 
mathworks main product page www mathworks com products 
steele jr sussman design lisp microprocessor communications acm vol 
pp 

berlin wu scheme system interpreting scheme acm conference lisp functional programming 
acm press pp 

frick high level language oriented hardware post von neumann era th annual symposium computer architecture 
acm press pp 

bell threaded code communications acm vol 
pp 

riccardi optimizing direct threaded code selective inlining acm sigplan notices vol 
pp 
may published part proceedings pldi 
ertl gregg optimizing indirect branch prediction accuracy virtual machine interpreters acm sigplan notices vol 
pp 
may published part proceedings pldi 
gagnon hendren effective inline threaded interpretation java bytecode preparation sequences compiler construction th international conference ser 
lncs ed vol 

warsaw poland springer april pp 

may draft version appear ieee proceedings vol 


sullivan baron amarasinghe dynamic native optimization interpreters proceedings workshop interpreters virtual machines emulators 
acm press pp 

manjunath krishnan sec portable interpreter optimizing technique embedded java virtual machine usenix java virtual machine research technology symposium jvm aug pp 

sommer chandler smith managed runtime environments generation mobile devices intel technology journal vol 

bala duesterwald banerjia dynamo transparent dynamic optimization system acm sigplan notices vol 
pp 
may published part proceedings pldi 
chambers ungar iterative type analysis extended message splitting optimizing dynamically typed object oriented programs acm sigplan notices vol 
pp 
june published part proceedings pldi 
knuth empirical study fortran programs software practice experience vol 
pp 

lzle ungar reconciling responsiveness performance pure object oriented languages acm transactions programming languages systems vol 
pp 
july 
detlefs agesen case multiple compilers oopsla vm workshop simplicity performance portability virtual machine design nov pp 

cierniak 
practicing java dynamic optimizations acm sigplan notices vol 
pp 
may published part proceedings pldi 
arnold fink grove hind sweeney adaptive optimization jalape jvm acm sigplan notices vol 
pp 
oct proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
click java hotspot server compiler usenix java virtual machine research technology symposium apr pp 

komatsu nakatani dynamic optimization framework java just time compiler acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
whaley virtual machine compiler infrastructure workshop interpreters virtual machines emulators june pp 

sundaresan java just time compiler virtual machine improvements server middleware applications usenix rd virtual machine research technology symposium vm may 
cytron just time better late conference record th acm sigplan sigact symposium principles programming languages jan pp 

karp line algorithms versus line algorithms worth know proc 
ifip th world computer congress vol 
aug pp 

kistler continuous program optimization ph dissertation university california irvine 
kistler franz continuous program optimization case study acm trans 
program 
lang 
syst vol 
pp 

may draft version appear ieee proceedings vol 


nakatani region compilation technique java just time compiler acm sigplan notices vol 
pp 
may published part proceedings pldi 
fink qian design implementation evaluation adaptive recompilation stack replacement international symposium code generation optimization 
ieee computer society pp 

whaley partial method compilation dynamic profile information acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
lzle chambers ungar debugging optimized code dynamic deoptimization acm sigplan notices vol 
pp 
july published part proceedings pldi 
java platform debugger architecture java sun com products jpda 
smith overcoming challenges feedback directed optimization acm sigplan notices vol 
pp 
july 
pettis hansen profile guided code positioning acm sigplan notices vol 
pp 
june published part proceedings pldi 
chang mahlke 
hwu profile information assist classic code optimizations software practice experience vol 
pp 
dec 
hwu mahlke chen chang warter hank holm superblock effective technique vliw superscalar compilation journal supercomputing 
kluwer academic publishers pp 

cohn lowney design analysis profile optimization compaq compilation tools alpha journal instruction level parallelism vol 
pp 
apr 
mock chambers eggers tool automating selective dynamic compilation th international symposium microarchitecture dec pp 

arnold hind ryder online feedback directed optimization java acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 

adl tabatabai hudson serrano prefetch injection hardware monitoring object metadata acm conference programming language design implementation pldi june 
anderson dean ghemawat henzinger tak leung sites vandevoorde waldspurger weihl continuous profiling cycles gone acm transactions computer systems vol 
pp 
nov 
grove adaptive online context sensitive inlining international symposium code generation optimization 
ieee computer society pp 

dean hicks waldspurger weihl hardware support instruction level profiling order processors th international symposium microarchitecture dec pp 

sastry bodik smith rapid profiling stratified sampling th annual international symposium computer architecture july pp 

ball larus optimally profiling tracing programs acm transactions programming languages systems vol 
pp 
july 
may draft version appear ieee proceedings vol 


calder john austin cache conscious data placement acm sigplan notices vol 
pp 
nov published part proceedings asplos viii 
grove dean garrett chambers profile guided receiver class prediction acm sigplan notices vol 
pp 
oct published part proceedings oopsla 
calder feller eustace value profiling optimization journal instruction level parallelism vol 
mar 
komatsu nakatani efficient online path profiling framework java just time compilers international conference parallel architectures compilation techniques sept pp 

arnold ryder framework reducing cost instrumented code acm sigplan notices vol 
pp 
may published part proceedings pldi 
chilimbi bursty tracing framework low overhead temporal profiling th acm workshop feedback directed dynamic optimization dec pp 

chilimbi dynamic hot data stream prefetching general purpose programs acm sigplan notices vol 
pp 
may published part proceedings pldi 
wall predicting program behavior real estimated profiles acm sigplan notices vol 
pp 
june published part proceedings pldi 
wang rubin evaluating importance user specified profiling nd usenix windows nt symposium aug 
sherwood calder basic block distribution analysis find periodic behavior simulation points applications international conference parallel architectures compilation techniques sept 
sherwood calder automatically characterizing large scale program behavior tenth international conference architectural support prog 
lang 
oper 
sys 
asplos oct 
smith managing multi configuration hardware dynamic working set analysis th annual international symposium computer architecture may pp 

barnes nystrom merton mei hwu vacuum packing extracting hardware detected program phases post link optimization th international symposium microarchitecture nov pp 

sherwood calder phase tracking prediction th annual international symposium computer architecture june pp 

smith comparing program phase detection techniques th international symposium microarchitecture dec 
garey johnson computers guide theory np completeness 
freeman 
scheifler analysis inline substitution structured programming language communications acm vol 
pp 
sept 
chang mahlke chen 
hwu profile guided automatic inline expansion programs software practice experience vol 
pp 
may 
ayers schooler gottlieb aggressive inlining acm sigplan notices vol 
pp 
may published part proceedings pldi 
ramakrishnan evaluating inlining techniques computer languages vol 
pp 

may draft version appear ieee proceedings vol 


arnold fink sarkar sweeney comparative study static profile heuristics inlining acm sigplan notices vol 
pp 
july published part proceedings dynamo 
dean chambers better inlining decisions inlining trials lisp functional programming pp 

waddell dybvig fast effective procedure inlining th international symposium static analysis sept 
nakatani empirical study method lining java just time compiler usenix java virtual machine research technology symposium jvm aug pp 


adl tabatabai bharadwaj 
chen menon murphy serrano compiler dynamic compiler managed runtime environments intel technology journal vol 
pp 
feb 
takeuchi komatsu nakatani overview ibm java just time compiler ibm systems journal vol 
pp 
feb 
chang mahlke chen warter 
hwu impact architectural framework multiple instruction issue processors proc 
th international symposium computer architecture pp 

chen mahlke warter hwu profile assisted instruction scheduling international journal parallel programming vol 
pp 
apr 
ia architecture ieee computer vol 
pp 
july 
ia application developer architecture guide may order number 
davies wolfe multiple version loops international conference parallel processing pp 

gupta midkiff moreira automatic loop transformations parallelization java international conference supercomputing may pp 

gupta 
choi hind optimizing java programs presence exceptions th european conference object oriented programming june pp 

arnold ryder thin guards simple effective technique reducing penalty dynamic class loading th european conference object oriented programming june 
komatsu nakatani study techniques java just time compiler acm sigplan notices vol 
pp 
oct proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language acm sigplan notices vol 
pp 
july published part proceedings pldi 
philipose mock eggers chambers evaluation run time optimizations acm sigplan notices vol 
pp 
may published part proceedings pldi 
lee leone optimizing ml run time code generation acm sigplan notices vol 
pp 
may published part proceedings pldi 
poletto hsieh engler kaashoek tcc language compiler dynamic code generation acm transactions programming languages systems vol 
pp 
mar 
may draft version appear ieee proceedings vol 


rinard dynamic feedback effective technique adaptive computing acm sigplan notices vol 
pp 
may published part proceedings pldi 
voss high level adaptive program optimization adapt acm sigplan notices vol 
pp 
july published part proceedings ppopp 
komatsu nakatani study exception handling dynamic optimization java acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 

luk mowry compiler prefetching recursive data structures acm sigplan notices vol 
pp 
sept published sigops operating systems review december sigarch computer architecture news special issue october 
wu efficient discovery regular stride patterns irregular programs compiler prefetching acm sigplan notices vol 
pp 
may published part proceedings pldi 
komatsu nakatani stride prefetching dynamically inspecting objects acm sigplan notices vol 
pp 
may published part proceedings pldi 
krasner smalltalk bits history words advice 
addison wesley 
lzle chambers ungar optimizing dynamically typed object oriented languages polymorphic inline caches th european conference object oriented programming july pp 

dietz sleator algorithms maintaining order list nineteenth annual acm symposium theory computing may pp 

ramalingam srinivasan object model java ibm research division tech 
rep dec 
fitzgerald knoblock ruf steensgaard tarditi marmot optimizing compiler java microsoft research tech 
rep msr tr june 
krall vitek horspool near optimal hierarchical encoding types th european conference object oriented programming finland june 
alpern cocchi grove dynamic type checking jalape usenix java virtual machine research technology symposium apr pp 

click rose fast subtype checking hotspot jvm joint acm java grande conference pp 

lock reservation java locks atomic operations acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
bacon murthy serrano thin locks featherweight synchronization java acm sigplan notices vol 
pp 
may published part proceedings pldi 
bacon fink grove space time efficient implementations java object model th european conference object oriented programming june 
dean grove chambers optimization object oriented programs static class hierarchy analysis th european conference object oriented programming aug pp 

detlefs agesen inlining virtual methods th european conference object oriented programming june pp 

may draft version appear ieee proceedings vol 


jones lins garbage collection algorithms automatic dynamic memory management 
chichester england john wiley sons 
hot swapping mark sweep mark compact garbage collector generational environment usenix java virtual machine research technology symposium apr pp 

bacon adaptive application specific garbage collection university california santa barbara tech 
rep mar 
arora kuiper java server performance case study building efficient scalable jvms ibm systems journal vol 
pp 
feb 
appel simple generational garbage collection fast allocation software practice experience vol 
pp 
feb 
hayes key object opportunism collect old objects acm conference object oriented programming systems languages applications 
acm press pp 

diwan hertz connectivity garbage collection acm conference object oriented programming systems languages applications oct pp 

wilson opportunistic garbage collection acm sigplan notices vol 
pp 
dec 
lieberman hewitt real time garbage collector lifetimes objects communications acm vol 
pp 

chilimbi davidson larus cache conscious structure definition acm sigplan notices vol 
pp 
may published part proceedings pldi 
kistler franz continuous program optimization design evaluation ieee transactions computers vol 
pp 
june 
kistler franz automated data member layout heap objects improve memory hierarchy performance acm transactions programming languages systems vol 
pp 

data remapping design space optimization embedded memory systems acm transactions embedded computing systems vol 
pp 
may 
chilimbi larus generational garbage collection implement cache conscious data placement acm sigplan notices vol 
pp 
mar 
shuf gupta franke appel singh creating preserving locality java applications allocation garbage collection times acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
rubin bod chilimbi efficient profile analysis framework data layout optimizations acm sig plan notices vol 
pp 
jan proceedings th acm sigplan sigact symposium principles programming languages popl 
johnson fftw adaptive software architecture fft ieee international conference acoustics speech signal processing vol 

ieee pp 

whaley dongarra automatically tuned linear algebra software university tennessee tech 
rep ut cs 
bilmes 
chin demmel optimizing matrix multiply portable high performance ansi coding methodology international conference supercomputing pp 

may draft version appear ieee proceedings vol 


li ren dejong padua pingali wu comparison empirical model driven optimization acm sigplan notices vol 
pp 
may published part proceedings pldi 
singh shape analysis run time usenix java virtual machine research technology symposium jvm apr pp 

sreedhar burke 
choi framework interprocedural optimization presence dynamic class loading acm sigplan notices vol 
pp 
may published part proceedings pldi 
sarkar dynamic optimistic interprocedural analysis framework application acm sigplan notices vol 
pp 
nov proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
qian hendren dynamic interprocedural analysis jvms usenix rd virtual machine research technology symposium vm may 
diwan hind pointer analysis dynamic class loading th european conference object oriented programming june 
serrano midkiff gupta quicksilver quasi static compiler java acm sigplan notices vol 
pp 
oct proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
philipose chambers eggers automatic construction staged compilers acm sigplan notices vol 
pp 
jan proceedings th acm sigplan sigact symposium principles programming languages popl 
feldman sealed calls java packages acm sigplan notices vol 
pp 
oct proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
choi srinivasan deterministic replay java multithreaded applications sigmetrics symposium parallel distributed tools aug pp 

systematic testing multithreaded java programs master thesis massachusetts institute technology 
engler vcode retargetable extensible fast dynamic code generation system acm sigplan notices vol 
pp 
may published part proceedings pldi 
poletto sarkar linear scan register allocation acm transactions programming languages systems vol 
pp 
sept 
burke 
choi fink grove hind sarkar serrano sreedhar srinivasan whaley jalape dynamic optimizing compiler java acm java grande conference june pp 

just time compiler memory constrained low power devices usenix java virtual machine research technology symposium jvm aug pp 

chen olukotun targeting dynamic compilation embedded environments usenix java virtual machine research technology symposium jvm aug pp 

takeuchi ogata may draft version appear ieee proceedings vol 


komatsu nakatani effectiveness cross platform optimizations java just time compiler acm conference object oriented programming systems languages applications oct pp 

georges de java programs interact virtual machines level acm conference object oriented programming systems languages applications oct pp 

transmeta transmeta crusoe www transmeta com crusoe 
vijaykrishnan kandemir kim irwin energy behavior java applications memory perspective usenix java virtual machine research technology symposium jvm apr pp 

calder lee zorn overlapping execution transfer non strict execution mobile programs acm sigplan notices vol 
pp 
nov 
calder lzle reducing transfer delay java class file splitting prefetching acm sigplan notices vol 
pp 
oct published part proceedings oopsla 
jikes research virtual machine rvm www ibm com developerworks oss jikesrvm 
mono go mono com 
open runtime platform orp net 
place photo applications 
member acm 
place photo computation 
member acm 
matthew arnold received degree rensselaer polytechnic institute ph degrees rutgers university respectively 
thesis developed low overhead techniques performing online profiling feedback directed optimization java virtual machine 
matthew research staff member software technology department ibm watson research center continuing research language level profiling techniques developing profiling visualization tools distributed web services stephen fink received degree duke university ph degrees university california san diego respectively 
stephen research staff member software technology department ibm watson research center 
member team produced jikes research virtual machine currently investigating application static program analysis enterprise java beans 
research interests include programming language implementation techniques program analysis parallel scientific may draft version appear ieee proceedings vol 


place photo place photo david grove received degree yale college ph degrees university washington respectively 
david research staff member software technology department ibm watson research center 
member jikes rvm core team helped develop adaptive optimization system optimizing compiler runtime system 
research interests include program language design implementation virtual machines adaptive optimization 
member acm 
michael hind received degree state university new york new paltz ph degrees new york university 
michael professor computer science state university new york new paltz 
michael research staff member software technology department ibm watson research center working jalape project project produced open source jikes rvm 
manager dynamic optimization group ibm research 
research interests include program analysis adaptive optimization memory latency issues 
member acm 
place photo peter sweeney member ieee received degrees computer science columbia university respectively 
peter software engineer software technology department ibm watson research center 
research staff member 
research interests include understanding behavior object oriented programming languages reduce space time overhead 
member acm 
may draft 
