framework evaluating replica placement algorithms magnus karlsson christos mahalingam hp laboratories page mill road palo alto ca contact author mail karlsson hpl hp com introduces framework evaluating replica placement algorithms rpa content delivery networks cdn rpas fields applicable current cdns 
framework classifies qualitatively compares rpas generic set primitives capture problem definitions heuristics 
second provides estimates decision times rpas analytic model 
achieve accuracy model takes account disk accesses message sizes addition computational complexity message numbers considered traditionally 
third uses goodness produced placements compare rpas different problem definitions 
evaluations identify open issues potential areas research 
index terms replica placement algorithms content delivery networks evaluation framework 
design replica placement algorithms rpa foremost problems content delivery networks cdn akamai digital island 
algorithms decide data replicate storage nodes order achieve improved performance low infrastructure cost 
number rpas proposed cdn literature systematic way classify compare 
rpas concerned read data target simple performance metrics 
earlier reported simple caching schemes outperform best rpas hard performance guarantees required 
cdns expected support modifications consistency various qos guarantees 
rpas probably way meet requirements 
rpas generation cdns issue needs investigated 
performance example latency throughput availability 
replica placement problem studied extensively distributed computing fields including file assignment problem distributed databases data management mention 
fields require rpas may consider writes consistency availability strict compounded guarantees update propagation bounds questions raised consequence approaches related systematically represent evaluate algorithms cdns rpas fields cdns areas provide opportunities research 
propose framework comparing evaluating replica placement algorithms cdns 
framework defines rpa problem definition heuristic 
problem definition consists cost function minimized constraints 
heuristic produce near optimal solutions resulting problem usually np complete 
section ii introduces set primitives describe rpas multiple disciplines 
primitives serves purposes 
clarifies fundamental differences existing algorithms 
second simplifies comparing new algorithms prior art 
third problem definition identifies heuristics problem 
find potential problems cdns solutions fields 
section iii shows existing algorithms support scales cdns 
propose analytic approach estimating decision time algorithms 
traditionally computation message complexities considered 
show message sizes disk access times due memory constraints need taken account provide accurate estimates 
rpas cdns usually scale worse today cdn rpas 
highlights need research scalable algorithms solve complex replica placement prob lems cdns 
section iv compares algorithms produced placement problem existing cdn literature algorithms compared minimized cost function values 
comparison algorithms different problem definitions impossible target goal system 
way circumvent problem compare respective impact system performance cost 
particular developed rpa generator produce placement rpas described framework facilitate comparisons prior art 
power method illustrated comparing number algorithms compared diverse problem definitions 
related section conclude section vi 
ii 
replica placement algorithms replica placement typically formulated problem definition approximates goal performance cost improvement workload target system 
problems usually np complete 
usually require heuristics find approximate solutions feasible time 
algorithm refer heuristic applied specific problem definition 
limit scope consider algorithms aim solely improving availability reliability system algorithms dealing migration 
consider rpas applicable general tree topologies interested topologies 
system model goal system considered data repository consisting set nodes interconnected links 
nodes store objects represent data files websites volumes 
clients connect nodes access objects stored 
goal replica placement problem decide location object replicas system order maximize client perceived performance existing infrastructure minimize infrastructure cost specified system performance 
system goal abstracted problem definition optimization goal 
problem definition framework replica placement problem formally stated follows 
system consists set clients nodes objects links physical communication channel nodes link added nodes 
client assigned node object incurring specific cost cost function 
example function may reflect average latency clients accessing objects system nodes 
extensive sample cost functions shown table problem formulation augmented number constraints 
binary variable ijk indicates client sends requests object node jk indicates node stores object constraints problem definitions numbers refer equations states client send requests object exactly node states nodes store object respond requests imply objects requests split 
optional additional constraints described section 
basic problem find solution minimum maximum cost satisfies constraints 
ijk ijk jk jk ijk cost functions existing rpas shown table parameters reads reads ik rate read accesses client object reflected probability access object reads ik time units 
writes writes ik rate write accesses client object distance dist ij distance client node represented metric network latency link cost 
update propagation costs algorithms minimum spanning tree distance node nodes copy object denoted mst jk storage cost sc jk cost storing object node storage cost reflect size object throughput node fact copy object residing specific node called replication cost 
object size size size object bytes 
access time jk time stamp indicating time object accessed node hit ratio hr ij hit ratio cache path literature number additional constraint primitives added constraints problem definition storage capacity sc size 
jk sc 
upper bound storage capacity node 
load capacity lc reads ik writes ik 
ijk lc 
upper bound load characterized rate requests node serve 
node bandwidth capacity bw reads ik writes ik 
size 
ijk bw 
constraint maximum rate bytes node transmit 
link capacity cl reads ik writes ik 
size 
cl 
bandwidth constraint link nodes 
client uses link access object zero 
problem definitions separate reads writes object replications 
notations ilk read accesses ilk writes ilk objects replicated 
number replicas jk 
constraint limiting number replicas placed 
origin copy oc jk specifies location original copy object 
delay specifies desired maximum response time requests system 
mathematical definition 
availability av specifies desired minimum availability objects system 
mathematical definitions 
table maps replica placement problem definitions disparate fields proposed cost function primitives constraints 
table lists problem definitions believe useful cdn 
comprehensive list 
problem definitions broken main groups 
group ignores client accesses group accounts read accesses group considers read write accesses including consistency requirements 
groups divided categories problem definition takes account single multiple objects considers storage costs 
single object formulations handle intra object constraints storage constraints easier solve 
drawback problem definitions group place replicas object nodes 
clearly practical objects placed system 
useful substitute group problem definitions objects accessed uniformly clients system utilization nodes system requirement 
case group algorithms orders magnitude faster ones group placement decided applies objects 
problem definitions proposed literature cdns fall group 
applicable read read workloads 
problem definitions cdns 
main differences consider single multiple objects consider storage costs 
cost function captures impact allocating large objects possibly object size highly variable 
proposed allocating caches 
distance parameter consists distance client cache plus distance cache node cache misses 
cdn problem definition distance measured client closest node copy object 
context cdns storage costs sc jk order minimize amount changes previous placement 
far know evaluation cdn benefits consideration 
open question storage load nodal bandwidth link capacity constraints need considered 
scalable heuristics problem definitions 
little research cdn algorithms enforce qos guarantees client perceived latency 
considering impact writes addition reads important content providers applications able modify documents cdn 
main characteristic group contains problem definitions interest cdns 
problem definitions represent consistency protocol different ways 
cost number writes times distance client closest node object plus cost distributing updates replicas object 
updates distributed system minimum spanning tree 
update message sent writer copy 
specified updates propagated 
consider cost exchanging information considers channel cost 
main difference definitions minimize maximum link congestion rest minimize average client table problem definitions heuristics dealt 
constraints column shows constraints literature conjunction specific cost function possible ones 
various components cost function weighted 
shown table 
cost function constraints group consider object accesses 
single object max dist ij 
ijk dist ij 
ijk group considers read accesses objects 
single object reads ik 
dist ij 
ijk lc bw reads ik 
hr ij 
dist ij hr ij 
dist ij dist js multiple objects reads ik 
dist ij 
ijk sc oc reads ik 
dist ij 
ijk sc bw reads ik 
dist ij 

ijk sc single object storage cost sc jk 
jk dist ij 
reads ik 
ijk lc bw multiple objects storage cost sc jk 
jk dist ij 
reads ik 
ijk group considers read write accesses update propagation 
single object reads ik 
dist ij 
ijk writes ik 
dist ij mst jk 
ijk reads ik 
dist ij writes ik 
dist ij dist jn 

ijk max reads ik 
ilk writes ik 
ilk cl single object storage cost reads ik 
dist ij 
ijk writes ik 
dist ij mst jk 
ijk sc jk 
jk reads ik 
dist ij writes ik 
dist ij dist jn 

ijk sc jk 
jk reads ik 
dist ij 
ijk sc jk update cost jk 
jk reads ik 
dist ij 
ijk writes ik 
update dist ij 
availability ijk 
jk sc jk 
jk av max reads ik 
ilk writes ik 
ilk sc jk 
cl max reads ik 
ilk writes ik 
ilk sc jk 
info exchange lk cl multiple objects storage cost reads ik 
dist ij 
ijk writes ik 
dist ij mst jk 
ijk sc jk 
jk sc channel cost 
ilk sc jk 

jk cl av max reads ik 
ilk writes ik 
ilk sc jk 
info exchange lk cl sc access latency client perceived costs 
minimizing link congestion useful bandwidth scarce cdn 
note problem definitions considers load nodal bandwidth constraints consider storage constraints 
constraints shown important open research issues space 
interesting question problem definitions extended constraints bound update propagation time important property cdn 
problem definitions consider client perceived latency availability guarantees 
see corresponding heuristics proposed literature scalable 
research opportunities designing scalable algorithms 
heuristic primitives np complete problem defined previous section solved heuristics 
heuristics characterized axes metric scope approximation method cost function simplification 
metric scope 
refers clients nodes objects links considered placing objects 
chosen scope affects techniques 
example node considered heuristic decentralized independently executed single node system 
hand nodes considered executed centralized way 
local object knowledge specified objects stored local node objects referenced local node considered 
approximation method 
technique placement decisions 
methods heuristics ranking plain greedy 
compute cost impact possible combinations metric scope placing extra object node 
sort costs select best violate constraints 
constraint violated try placement list 
greedy ranking heuristic recomputes cost function object placed 
ranking generic approximation method problem definitions 
fixed threshold threshold 
object placed specific node cost function specified threshold 
approximation method usually independent problem definition 
improvement method 
methods try improve solution introducing small changes 
distance improvement heuristic evaluates permutations solution bits decision variables changed 
numerous interchange methods referenced 
improvement methods independent problem definition 
relaxation techniques re method 
encompass number techniques 
lagrangian relaxation relaxes constraints problem definition moving cost function 
linear relaxation relaxes integer constraints original problem 
possible fast linear optimization techniques slow integer ones 
heuristic refers traditional heuristics approximation algorithms 
algorithms designed specifically problem definition 
dynamic programming dp 
method saves intermediate results avoid recalculation 
rules applied order merge intermediate results 
method specific problem definition 
parametric pruning pp 
technique specific problem definition prunes irrelevant portions search space conservative estimate optimal cost 
hierarchical 
aforementioned approximation methods hierarchical fashion 
example ranking node leaf level 
results ranking aggregated nodes higher level perform ranking aggregated data root node 
multi phase method method 
techniques described combined certain ways 
example greedy ranking followed improvement heuristic 
multi phase techniques combined methods 
cost function simplification 
original cost function problem definition 
example problem definition specify cost function reads ik 
dist ij 
ijk example hotspot heuristic see table ii disregards distance uses just reads ik 
ijk simplified cost function anyway 
table ii lists previously proposed heuristics replica placement problems mapped framework 
table serves main purposes 
qualitatively compare existing heuristics literature 
main observation problem definitions groups combination generic heuristics case group exception problem definition 
observation proposed ranking heuristics quite similar 
second purpose table new heuristics described reported 
note table primitives give high level view heuristics order faithfully implement source consulted 
plethora caching algorithms basic lru included due space constraints 
excluded caching algorithms differs cost function simplifications metric scopes cooperative caching 
heuristics table ii approximation table ii existing heuristics mapped framework 
means clear entry child means metric scope children node topological tree 
vicinity means number entities close node see corresponding details 
problem definition column lists problem definitions heuristic applied literature 
metric scope cost function problem heuristic approximation method client node object simplification definition ranking heuristics greedy global greedy ranking local plain local local popularity plain local local reads ik hotspot plain vicinity reads ik fan plain indep indep fanout ranking dist plain local local dist ij lru caching plain local local jk group improvement heuristics combinations distance dist greedy greedy dist hierarchical plain dist child child child dist ij max dist ij threshold heuristics radar place reads ik ijk local local 
delete ijk local local 
awerbuch fap reads reads ik reads ik writes plain writers dist ij dist awerbuch reads reads ik local vicinity local reads ik writes plain local writers local writers dist ij edge strategy reads reads ik local local writes writes ik local local heuristics problem definition specific min center pp indep dist ij tree dp linear re linear linear imp re linear drop add drop lagrangian re lagrangian lagrangian imp re lagrangian add drop methods designed line algorithms 
classical definition line algorithm guarantees come valid setting accesses known 
conversely line algorithm guarantees valid settings known 
line algorithms designed invoked frequently single access 
generally afford re evaluate placement single invocation 
fast execution time accomplished example having heuristic placing object deleting object 
algorithms explicit delete heuristic typically line algorithms object deletion implicit heuristic decides object placement nodes included placement delete object 
evaluation section iv consider algorithms line setting realistic original line guarantees lost 
iii 
decision time decision time time required algorithm placement decision objects specific system 
algorithm distributed maximum completion time nodes system 
previously computation time time due number messages sent considered estimating decision times 
section advocate message sizes disk accesses taken account provide estimate 
develop analytic model primitives previous section estimates decision time algorithms formula tot ccomp 
tcomp comp 
tot local 
msg max 
disk 
disk component total decision time computation time comp 
computational complexity algorithm times average time takes perform iteration calculation comp 
comp data main memory 
message cost msg time spent sending receiving messages 
include message transfer times assume asynchronous message passing 
useful computations scheduled messages transit 
message cost consists components proportional number messages msg 
msg msg time sending receiving zero length message proportional size transmitted data 
total size data needed decision minus local data set node tot local times time spent byte transmitted data 
disk cost disk time required accessing data disk data fit node main memory 
amount memory required decision minus effective amount memory node req 
multiplied number times data reused decision disk time takes read byte data disk 
analytic model estimate decision times rpas having build test actual algorithms real emulated environment 
approach particularly important target systems large new algorithms designed need evaluated quickly 
accuracy analytic model section compare decision times estimated proposed analytic model times actual algorithm executions systems relatively small size 
model provides sufficiently accurate estimates approximate comparisons 
demonstrate computation message disk costs taken account order provide estimate 
developed tool called generates evaluates rpas 
implements problem definitions heuristics described previous sections 
execute rpas different system sizes measure actual decision times algorithms 
table iii shows values various parameters analytic model 
parameters top rows measured means actual rpa implementations 
values obtained workstation mhz pa processor mb memory 
entire data set kept memory comp measurements 
data set larger available memory 
msg chosen node receives kb messages second value typical static web serving 
case ranking improvement approximation methods values applicable possible heuristics 
case lagrangian relaxation values applicable specific problem definition new measurements required problem definitions 
parameters calculated analytically 
computational complexities comp table iii deduced studying code implementations getting computational complexities original papers 
dist equations number iterations approximation methods execute 
tot calculated adding number variables node requires decision assuming byte variables 
local calculated way data gathered local node 
accuracy analytic model predicting decision times evaluated heuristics applied problem definition 
compared decision times estimated analytic model parameter values table iii versus actual decision times observed actual execution algorithms 
comparisons systems different sizes increments clients nodes 
problem definition considers single object time 
comparisons show model error test cases shown 
larger errors occur smaller systems mainly data start fit processor caches 
validated heuristics problem definitions showing errors similar scale shown 
greedy hotspot fan swap greedy lagrangian relative error analytical model fig 

relative error jt real real analytic model heuristics various systems 
table iii parameters decision time model 
represent metric scope clients nodes objects respectively 
number replicas placed node decision time runs algorithm 
dist heuristic uses distance demand matrix respectively 
parameter value parameter value parameter value tcomp tcomp dist tcomp re 
mb ccomp greedy ccomp plain ccomp dist dist ccomp re greedy dist plain dist dist dist re nc disk greedy rk disk plain disk dist dist disk re ki model provide sufficiently precise decision time estimates cases 
new algorithm proposed uses problem approximation method decision time estimated model pre computed parameter values table table iii 
algorithms implemented order evaluate decision time 
second heuristic problem definition specific approximation method proposed implemented tool 
small scale executions parameter values model measured model estimate decision times large scale infeasible emulate deployments 
decision time existing heuristics section discusses decision times algorithms proposed literature analytic model introduced previous section 
depicts decision times representative heuristics table ii optimizing problem definition number replica constraint 
numbers nodes clients respectively graphs number objects main drawn 
heuristics dominated computation cost message costs disk cost signifying importance take factors account 
example looking computation time greedy heuristic system nodes conclude feasible fact take weeks longer due disk accesses system 
model disk accesses correctly estimated dominant decision time factor 
dominant factor heuristic may change different system sizes problem definitions see example cost greedy graphs 
second difference decision times various heuristics large orders magnitude third relatively small scale studied heuristics infeasible take weeks terminate 
shows decision costs system clients nodes objects moderately sized global storage repository oceanstore 
due system size measure variables 
assume dist seeded placement heuristic 
believe swap scales meaningful 
case lagrangian relaxation algorithm assume terminates iterations 
scales single existing heuristic feasible 
fan feasible decision time places objects nodes practical objects considered 
main observations take away 
heuristic low metric scope feasible scales 
second order able solve replica placement problem systems size need aggregate data clients nodes objects links point scale problem manageable low metric scope heuristics 
greedy hotspot fan greedy lagrangian days years clients nodes objects computation messages message size disk fig 

decision costs heuristics oceanstore scales 
iv 
goodness placement literature goodness heuristic solving specific problem definition evaluated example competitive ratios minimized cost function values 
greedy hotspot fan swap greedy lagrangian ms min days clients nodes objects greedy hotspot fan swap greedy lagrangian ms min days clients nodes objects computation messages message size disk fig 

decision costs existing heuristics medium scales 
scale left diagram disk access time data fits memory 
dist 
cdns fields algorithms proposed different problem definitions system goal 
goodness placements algorithms compared aforementioned methods compared target system goal 
tackle problem propose quantitatively evaluate algorithm impact performance cost system intended 
words evaluate achieved system performance cost due placement produced various rpas far optimal cost function value solution useful context single problem definition shown reflects problem definition corresponds system goal 
focus evaluation system performance evaluation money cost straight forward 
comparing placement produced algorithms different problem definitions important factor penalty meeting certain constraints certain parameters account 
performance impact placement measured actual system factors automatically reflected result 
performance evaluated analytic models simulators constraint violations parameter exclusions associated costs explicitly included model 
proposed goodness evaluation approach illustrated comparing number rpas cdns compared 
intended exhaustive comparison algorithms just example approach 
base evaluation system simulation 
experimental methodology ingredients required compare goodness performance placement different rpas performance metric representative workload produced placements 
placements rpas produced described section iii 
issues discussed paragraphs 
performance metric depends system 
cdn client perceived latency threshold performance metric 
evaluation refers cumulative distribution function cdf latency access objects produced placements 
larger ratio access threshold better 
world cup web logs generate realistic workload cdn 
reduce client population tractable size evaluations logs days clustered encountered client ip addresses autonomous system belong 
clustering preserves topological locality clients reduces number clients 
clusters represent clients system nodes objects may placed 
matrix reads ik obtained counting number requests cluster generates 
simulate systems nodes choose desired number nodes way preserves original access distribution 
url treated separate object 
objects days log studied reduced objects random selection 
ideal world matrix dist ij represent average latency nodes impossible measure happens specific routing paths 
obtain latency approximations counting number level hops nodes 
shown fair approximation actual latencies internet 
turn hop numbers latencies variation actual latencies undoubtedly formula latency 
hops 
ms 
random value 
evaluation example illustrate systems centric approach evaluating rpas address questions 
clustering similar results fewer coarser clusters 
latency ms nodes objects storage mb greedy greedy mo greedy rds popularity reads size random cdf latency ms nodes objects storage mb greedy greedy mo greedy rds popularity reads size random storage capacity algorithm mb mb greedy greedy mo greedy rds popularity reads size random fig 

cumulative distribution function client perceived latencies various algorithms respective minimized cost function millions table right 
system point object size consideration rpa 
second case currently best way represent object size rpa 
intended thorough evaluation topic just illustration benefits evaluation method 
illustrates cumulative distribution function client perceived latency system nodes objects leftmost figures respective minimized cost function values table right 
figures greedy refers problem definition constraint combined greedy global heuristic 
algorithm take storage constraints consideration 
objects allocated node node store objects accessed frequently drop rest 
penalty assigned ignoring storage constraints rpa 
greedy mo refer heuristic previous algorithm problem definitions respectively storage constraint 
popularity table ii decentralized ranking heuristic considers reads storage constraint 
reads size cost function reads ik size main points take away 
minimized cost function values results cdf graphs differ substantially 
depending latency threshold relative goodness algorithms varies lot 
cost function values think greedy substantially worse popularity 
thresholds ms mb storage capacity case 
minimized cost function values show specific heuristic minimizes cost function performance benefits rpa provide system 
second decentralized popularity reads size algorithms best 
third algorithm greedy rds workload system 
related despite importance replica placement problem practical implications little done compare various approaches applicability different system models 
survey file assignment problem published 
focuses problem definitions classification comparison feature feature basis 
levin morgan introduced framework replica placement problems context distributed databases 
categorize algorithms parameters workload static dynamic information partial complete problem includes placement just data programs computation 
levin morgan seen higher level classification framework 
vi 
introduces framework classification evaluation existing new replica placement algorithms rpa 
considers rpas developed specifically cdns rpas fields may applicable existing cdns 
specifically framework ways identifies qualitative differences rpas canonical set primitives reflect problem definitions heuristics 
uses analytic model estimating decision times rpas large systems 
model takes account computational complexity message numbers disk accesses due memory constraints message sizes produce estimates 
allows comparison rpas different problem definitions goodness produced placements 
proposed framework shows existing algorithms cdns scale systems nodes 
algorithms fields file allocation problem applicable cdns take consideration issues writes update propagation qos guarantees latency availability scale worse existing cdn algorithms 
evaluation placement goodness system performance metrics client perceived latency results realistic systems specific comparisons algorithms comparison minimized cost function values 
evaluation existing approaches identifies areas research 
include design algorithms systems constrained resources algorithms optimize trade multiple goals time 
algorithms guarantee qos properties bounded update propagation times maximum client perceived latency important cdns 
believe effort put decentralized algorithms decentralized aggregation schemes address scalability problem existing rpas 
best knowledge attempt analyze rpas cdns wide spectrum fields 
aim provide point wishes understand compare evaluate instance replica placement problem existing cdns 
akamai cambridge ma usa www akamai com 
digital island www com 
karlsson mahalingam need replica placement algorithms content delivery networks proceedings international workshop web content caching distribution wcw august 
foster comparative models file assignment problem acm computer surveys vol 
pp 

levin morgan optimizing distributed data bases framework research proceedings afips ncc pp 

maggs meyer auf der heide exploiting locality data management systems limited bandwidth proceedings symposium foundations computer science october pp 

optimal allocation resources distributed information networks acm transactions database systems vol 
pp 
march 
tewari adam distributed file allocation consistency constraints proceedings international conference distributed computing systems pp 

optimum location switching centers absolute centers medians graph operations research vol 
pp 

jamin jin jin raz shavitt zhang placement internet instrumentation proceedings ieee infocom march pp 

jamin raz shavitt constrained mirror placement internet proceedings ieee infocom april pp 

li golin italiano deng optimal placement web proxies internet proceedings ieee infocom march pp 

plaxton analysis local search heuristic facility location problems journal algorithms vol 
pp 
october 
qiu padmanabhan voelker placement web server replicas proceedings ieee infocom april pp 

govindan estrin topology informed internet replica placement computer communications vol 
pp 
march 
krishnan raz shavitt cache location problem ieee acm transactions networking vol 
pp 
october 
kelly location interacting hub facilities transportation science vol 
pp 

roberts ross object replication strategies content distribution networks computer communications vol 
pp 
march 
plaxton rajaraman placement algorithms hierarchical cooperative caching journal algorithms vol 
pp 
january 
leff wolf yu replication algorithms remote caching architecture ieee transactions parallel distributed systems vol 
pp 
november 
dahlin bandwidth constrained placement wan acm symposium principles distributed computing podc august 
rajaraman approximation algorithms data placement arbitrary networks proceedings th annual acm siam symposium discrete algorithms january pp 

integer programming methods uses computation management science vol 
pp 

kutten optimal allocation electronic content proceedings ieee infocom april pp 

kurose simha microeconomic approach optimal resource allocation distributed computer systems ieee transactions computers vol 
pp 
may 
wolfson milo multicast policy relationship replicated data placement acm transactions database systems vol 
pp 
march 
wolfson jajodia distributed algorithms dynamic replication data proc 
acm pods symposium principles database systems june pp 

wolfson jajodia huang adaptive data replication algorithm acm transactions database systems vol 
pp 

cook pressman optimal location replicas network read write policy distributed computing vol 
pp 

kalpakis dasgupta wolfson optimal placement replicas trees read write storage costs ieee transactions parallel distributed systems vol 
pp 
june 
approximation algorithms data management networks proceedings symposium parallel algorithms architecture july pp 

lund reingold westbrook yan competitive line algorithms distributed data management siam journal computing vol 
pp 
may 
fisher hochbaum database location computer networks journal acm vol 
pp 
october 
chandy file allocation distributed systems proceedings international symposium computer performance modeling measurement evaluation march pp 

meyer auf der heide provably practical strategies non uniform data management networks proceedings european symposium algorithms july pp 

awerbuch bartal fiat competitive distributed file allocation proceedings acm symposium theory computing pp 

awerbuch bartal fiat distributed paging general networks journal algorithms vol 
pp 
july 
bartal fiat rabani competitive algorithms distributed data management extended proceedings acm symposium theory computing pp 

meyer auf der heide caching networks proceedings th acm siam symposium discrete algorithms january pp 

karlsson mahalingam framework evaluating replica placement algorithms tech 
rep hpl hp laboratories july www hpl hp com personal magnus karlsson 
cormen leiserson rivest algorithms isbn 
mit press 
current schilling discrete network location models facility location theory applications methods eds forthcoming 
vazirani approximation algorithms isbn 
springer verlag 
rabinovich aggarwal radar scalable architecture global web hosting service proceedings th international world wide web conference may pp 

rabinovich rabinovich rajaraman aggarwal dynamic object replication migration protocol internet hosting service international conference distributed computing systems may pp 

kubiatowicz oceanstore architecture persistent storage proceedings international conference architectural support programming languages operating systems november pp 

meyer auf der heide data management networks experimental evaluation provably strategy proceedings symposium parallel algorithms architecture july pp 

arlitt jin workload characterization world cup web site tech 
rep hpl hp laboratories 
krishnamurthy wang network aware clustering web clients sigcomm august pp 

obraczka silvia network latency metrics server proximity proceedings ieee globecom november 
