temporal induction incremental sat solving niklas en niklas chalmers university technology sweden cs chalmers se 
show modest modi cation typical modern sat solver enables solve series related sat instances eciently 
apply idea checking safety properties means temporal induction technique strongly related bounded model checking 
give ecient way constraining extended induction hypothesis called loop free paths 
performed rst comprehensive experimental evaluation induction methods 
years sat methods hardware veri cation important complement traditional bdd model checking 
methods proven usefulness number industrial applications particular bounded model checking bmc cff 
focus attention sat veri cation procedures implemented eciently tighter integration underlying 
main contributions 
firstly show number similar sat instances solved incrementally modest modi cation modern cha sat solver mz 
technique propose simpler previous attempts obtaining performance increase magnitude 
secondly demonstrate incremental technique temporal induction sss method checking safety properties nite state machines fsm 
show impact incremental approach experimentally proving correctness nding counter examples 
thirdly re ne method ensuring completeness temporal induction 
standard method works requiring states induction hypothesis unique 
simple analysis fsm able exclude uniqueness constraints resulting stronger requirements 
may exponentially reduce induction depth needed 
prove strengthening sound 
additionally demonstrate speed adding unique states requirement dynamically pairs states needed 
experiments performed prototype tool tip show properties proven speeds comparable mature bdd tools cadence smv cmu smv 
preliminaries consider safety properties nite state machines fsm 
states fsm vectors booleans de ning values state variables 
assume fsm set legal initial states safety property speci ed propositional formula state variables 
reachable state space mean states fsm reachable initial states 
task prove property holds state reachable state space 
standard manner assume transitions fsm represented propositional formula set initial states formula denote safety property 
sn denote state variables time step introduce shorthand notation pn tn sn sn sn 
sat problem bool denote boolean domain vars fx nite set boolean variables 
literal boolean variable negated boolean variable clause set literals implicitly 
sat instance set clauses implicitly conjoined 
valuation function vars bool literal said satis ed valuation variable mapped literal variable mapped 
clause said satis ed literals satis ed 
model satisfying assignment sat instance valuation clauses satis ed 
sat problem nd model set clauses 
converting formulas sat 
ways translating propositional formula clauses way satis ability preserved 
typically done introducing auxiliary variables giving names subformulas generating clauses establish de nitional relation introduced variables truth values respective subformulas 
model translated problem contains variables property restriction original set variables yields model original formula 
assume existence translation technique introduce notation de nition 
denote set clauses de ning literal representing truth value formula 
call de nition literal 
write short hand fpg 
example may translated clauses fp xg fp yg fp yg temporal induction section brie summarizes veri cation technique temporal induction sss 
word temporal suggests induction car authors word induction presentation adopted term temporal induction contexts 
base case induction step fig 

th base case unsatis able read exists step path state violating property assuming property holds rst steps 
th induction step unsatis able read step trace property holds exists state fails 
time steps fsm 
standard induction proof temporal induction proof consists parts base case 
simplest form base case states property hold initial states induction step states property preserved transitions fsm 
expressing parts induction proof sat problems straight forward resulting method interesting complement bdd veri cation methods especially systems transition relation succinct bdd representation 
method complete induction step provable property true 
method complete induction step strengthened ways 
firstly property assumed hold path successive states just 
means longer base case proven 
secondly states path assumed unique 
follows immediately niteness second strengthening method complete sense length induction step provable 
soundness treated detail section 
formalize strengthened induction de ning formulas pn tn pn step pn tn pn unique interpretation formulas depicted fig 

note proving correctness show formulas unsatis able 
base case assume shorter base cases proved add property state tends resulting sat problem easier 
de nitions state algorithm looking bugs longer longer lengths trying prove property deeper deeper induction steps algorithm 
temporal induction 
satis able base return property fails satis able step unique return property holds variations algorithm meaningful 
instance checking base case gives pure bug hunting algorithm delivers counter examples quickly 
altering formula base case slightly possible start higher bigger leaps 
checking size may unnecessarily costly 
bug proof deep bigger leaps means solving fewer sat problems 
bug algorithm stated nd shortest counter example 
may important 
remainder article show cost incrementing greatly reduced solving sat problems incrementally 
incremental sat typical stand sat solver accepts problem instance input solves outputs model unsatis able statement result 
inadequate wish solve similar sat instances 
obvious overhead re parsing clause set 
importantly expensive inferences may carried 
equipping sat solver interface allows sat instance speci ed incrementally current solved instance certainly remove parsing problem may reduce number inferences 
focus type solver introduced ms con ict analysis clause recording 
solver implements dpll style backtracking search procedure dll 
idea augmenting basic procedure con ict analysis con ict detected search ort spent nding reason con ict encoded clause added clause set 
recorded clauses serve cache type con icts parts search space 
example assuming true led con ict clause fx yg may recorded 
assuming true part search tree immediately give implied value variable avoiding repetition possibly includes sat solvers grasp sato zchaff authors solvers 
lengthy derivation 
ectiveness idea empirically established authors 
motivation incremental sat recorded clauses may useful parts search tree sat instance similar sat instance 
describe di erent design issues encountered implementing incremental sat system adopt object oriented view solver object stores problem clauses current sat instance learnt clauses recorded clauses 
solver methods modifying solving current sat instance 
simplest imaginable interface contain methods clause add clause clause database 
solve solve current instance 
interface user allowed add clauses speci ed rst sat problem 
solve check problem satis able 
may add clauses constrain problem re run solve 
procedure repeated sat instances interest solved 
typically instance unsatis able point extension satis able 
approach incremental sat introduced limited user remove added 
interesting incremental requires form clause removal 
suggested interface solver clause clause remove existing clause solve clause database 
interface set related problems solved incrementally 
ability remove clauses clashes con ict clause recording 
con ict analysis guaranteed produce clauses implied problem clause set adding clauses cause unsoundness 
removing problem clauses may suddenly render recorded clauses invalid 
detailed dependency analysis carried remove invalid clauses turn may require extra book keeping actual solving process 
longer treatment approach see 
contrast propose interface enables removal unit clauses 
motivation simple implement lines code solver expressive encompass interesting incremental sat problems expressible original interface clause solve assumptions extra list literals passed solve viewed unit clauses added particular solving removed return solver 
reason approach simpler learned clauses safe keep extra book keeping needed 
see safe note extra unit clauses seen implemented internal assumptions search procedure inherent property con ict clauses independent assumptions occur 
incremental induction section saw straight forward algorithm proving disproving safety properties induction 
break algorithm parts bug nder induction step upper bound prover show implemented incrementally sat interface section 
algorithm extending base 
pn pn solve fp satisfiable return property fails tn algorithm extending step 
solve fg unsatisfiable return ind step holds tn pn sn rst observation algorithms build trace states related transition relation di erent directions decremented step 
growing trace forwards base case allows keep strong formula xed sat solver 
building trace opposite direction force put initial state constraints assumption literal solve undesirable ect making recorded con ict clause depending initial state ine ective successive iterations 
similarly step growing trace backwards unnecessary assumption literal promotes reuse recorded clauses iterations 
di erent top level strategies combine algorithms safety checking procedure possible 
emulate algorithm section algorithms run parallel solver instance 
soon induction step succeeds particular length unsatis able length constitute proof safety property 
possible mix algorithms 
break natural direction building trace base case 
arbitrarily chose sacri ce induction step 
fact general interface simulated large extent 
inserting clause fxg passing assumption literal achieve ect inserting asserting true clause true forever removed clause database top level simpli cation procedure solver 
algorithm zig zag 
de nition literal pn pn pn de nition literal pn solve fp step include unsatisfiable pn hold 
return property holds solve fz pn base case include satisfiable counter example 
return property fails assert pn tn assert transition sn sn add uniqueness constraints sn reason stating algorithm partly show possible ways encoding safety checking procedure incrementally 
algorithm sat solver allowed share con ict clauses induction step may bene cial 
include algorithm benchmark section 
discussion try draw map possible induction safety checking algorithms 
term bad state state safety property hold 
generally observed checking safety properties symmetric respect initial states bad states 
point carried backwards roles initial states bad states exchanged transition relation inverted 
going adopt symmetrical view 
view regard induction step method nding upper bound length shortest counter example base case way producing counter example 
shortest counter example look 
start initial state bad state states initial bad shortest counter example 
bad view set possible shortest counter examples pictorially length ib length ib ib length ib ib ib length ib ib ib ib length ib ib ib ib ib line depicting shortest counter example corresponds conjunction constraints 
lot sharing counter examples di erent lengths remove initial nal th counter example ib ib ib ib ib ib counter example length longer include constraints 
means constraints subset yields unsatis able problem possible shortest counter examples longer lengths 
upper bound shortest counter example 
picture contain constraints derivable fact considering shortest counter example 
conclude 
states shorter path 
weaker 
non neighbors transition state unique 
weaker 
states 
facts proving upper bound 
long keep adding constraints ful lled shortest counter examples contradiction reached means established upper bound 
reason stating weaker versions shortest path requirement versions implemented eciently 
furthermore noted third condition procedure complete 
section describe implementation condition improved 
subset counter example view induction step algorithms viewed selecting subset containing including uniqueness constraints dictated condition 
experiments choice worked practice 
finding counter example 
user knows reason believe property false may want run just base case quickly produce counter example 
case clear extra constraints added trace 
algorithm chose add constraints mean clauses solver leads slower propagation smaller search tree 
ects predominant particular case hard judge 
general adding weak constraints seldom idea 
bmc tools optionally produce sat problem stating property fails rst steps exactly steps 
care taken adding extra constraints formulations 
instance longer require states unique 
assume modify recurrence diameter introduced similarly viewed subset containing uniqueness constraints 
transition relation state risk getting unsatis able problem due deadlock presence bug 
comparison shot method incremental base case included experiments 
improving unique states requirement uniqueness constraints described section algorithm require pair states di erent 
requirements statically added number grow quadratically length 
problems requiring high induction length risk adding numerous possibly super uous constraints tax sat solver heavily 
propose dynamic approach models returned solver induction step examined states equal constraint stating di erent added 
solver run may possibly cost adding super uous constraints hopefully incrementality approach means re run quick 
veri ed experimentally method perform better general 
question treated suciently earlier presentations induction variables included uniqueness constraints 
unusual describe fsm form sequential circuit 
standard interpretation circuit consider latches state holding elements inputs state variables fsm 
fairly clear need include inputs uniqueness constraints 
states equal inputs value inputs assume second state assumed rst 
safe require latch variables di erent stronger condition 
fact implemented cs 
note failing remove super uous state variables uniqueness constraints gives ine ective induction algorithm extra state variable potential doubling depth needed prove step 
hand fsm propositional formulas clear variables excluded 
propose solution 
include variables occurring current state transition relation 

add uniqueness constraints including rst state trace 
refer uniqueness constraints reduced set state variables strong uniqueness 
result parsing smv le leaves just 


reg reg reg reg reg reg reg fig 

picture shows contraction counter example state variables constrained transition relations point gluing printed boxes remaining trace represented 
correctness 
prove temporal induction strong uniqueness sound 
recall induction step strengthened holds shortest counter example 
suces show counterexample strongly unique shortest 
introduce notation left vars left right right vars right left reg left right model formula encoding counter example depth tn bn show construction reg reg strongly unique shorter counter example 
de ne fs follows sk reg reg constitutes counter example depth 
contracted counter example simply removing states depicted fig 

potential problem lies gluing head tail state constraints containing contain variables letting false similarly contain variables reg reg model constraints proof easily extended establish exclusion rst state super uous variables occur state variables occur current state experimental results ideas implemented prototype tool tip integrated sat solver 
benchmarks performed ghz pentium mb memory running linux 
set time launches minutes memory limit mb 
benchmarks collected sources 
tables benchmark name tagged source problem cadence example les cadence smv distribution 
cmu example les cmu smv distribution 
ken smv case studies ken mcmillan web page 
nusmv example les nusmv distribution 
vis example les vis distribution 
texas texas benchmarks available berkeley university 
eijk iscas sequential equivalence checking eijk 
irst problems model checking group irst 
problems converted smv format boolean variables sub modules 
problem safety properties extracted 
process ctl formulas ef changed ag fairness constraints removed 
di erent properties system indicated subscript system name 
counting property separate instance total problem instances collected 
rst experiment ran tip cadence smv cmu smv nusmv instances 
tools run default set options providing problem speci variable ordering tip reorder nusmv ag dynamic coi instances solved second tools considered trivial removed leaving instances 
comparison bdd tools 
result comparative experiment table 
default strategy tip runs base case induction step algorithm parallel solver instance 
algorithms equal amount cpu time point base case fails counter example induction step proven remaining base cases proved cpu 
purpose experiment relate performance induction applied methods show lack correlation hardness bdd methods hardness induction methods 
tool tip sat solver benchmarks article downloaded www cs chalmers se een tip able solve instances bdd veri cation failed showing induction may valuable complementary method 
ect incrementality 
second experiment performed comparison algorithm incremental interface external solver 
experiment problem instances property held 
result table 
experiment establishes substantial speed incremental approach 
unsurprisingly gain larger instances long needed prove property 
table see induction step usually takes longer prove base case 
observed behavior instances property failed 
reason default strategy tip increase lengths step base evenly devotes amount cpu 
bugs may due hard futile induction steps 
solver instance 
third experiment compared algorithm zig zag solver instance running induction step base case separate solver instances 
dual 
experiment step base incremented evenly methods solve minimal number sat instances 
include standard implementation complete induction sss 
results table 
experiment suggests separate solver instances base step favorable 
table see incremental implementation induction clearly outperforms standard implementation 
bmc comparison 
fourth experiment compared incremental search counter example shot approach described section 
result table 
experiment shows know exact length shortest counter example shot method advantageous 
uniqueness constraints 
nal experiment studied ect adding uniqueness constraints dynamically statically including instances constraints added instances provable uniqueness constraints 
result table 
ect sharpening constraints removing variables clearly advantageous 
study eijk equivalence checking problems need uniqueness constraints showed solved time bound sharpening 
problems tcas ii problems nusmv distribution originally model checking large software speci cations cab 
tool solved solving cadence smv tip cmu smv nusmv table 
tool comparison 
left column shows total number solved instances minutes 
right column show instances tool solve 
cadence smv proving instances prove instances tip 
instances unique tip solved problems nusmv cmu smv failed plus cadence smv solve 
name len step step ext base base ext dual zigzag cmu periodic eijk eijk eijk eijk eijk eijk eijk eijk ken oop nusmv guidance nusmv guidance nusmv tcas nusmv tcas texas vis vis vis vis vis vis vis vis vis table 
experimental results ect incremental sat vs external sat 
times seconds 
experiment includes instances property proved hold rst experiment 
launches methods took seconds left 
dual stands running iteration alg alg interchangeably zigzag refers alg stands standard induction uniqueness constraints statically added external sat solver 
name length incremental perfect bmc guess guess nusmv tcas nusmv tcas nusmv tcas nusmv tcas texas texas texas proc texas proc vis eisenberg table 
experimental result incremental bmc vs sat instances xed length 
times seconds 
perfect guess means sat instance encode bug length length shortest counter example 
means multiplied 
launches methods took seconds left 
name len time time ban ban conf conf cmu periodic eijk eijk ken oop nusmv guidance vis vis vis vis vis vis vis table 
experimental results dynamic vs static uniqueness constraints induction step 
times seconds 
launches seconds having shorter length left 
superscript means dynamic demand adding uniqueness constraints 
superscript means static adding uniqueness constraints pairs states 
ban number constraints added banning states equal 
nal number clauses solver 
conf total number con icts search tree solver 
problems needed uniqueness constraints provable cases incurred cost add 
cases constraints necessary adding dynamically lead speed 
uniqueness constraints problem provable induction 
dynamic method saves user guessing problem uniqueness constraints incurring extra cost 
related incremental bmc independently introduced ofer sakallah 
approach di ers previous attempts keep clauses previous iterations including con ict clauses 
complete method incremental temporal induction 
includes techniques enhance sat solving bmc problems including internal constraints replication copying invariant con ict clauses time steps trace bmc speci variable decision strategies 
related techniques proving upper bounds bmc ks computing recurrence diameter approximating diameter structural analysis 
particular authors ks suggest solution quadratic blow uniqueness constraints adding sorting network state variables sat problem 
temporal induction prove upper bounds bmc sss 
orts authors established costly gradually increase depth induction proof external sat solver 
shown integrating sat solver induction procedure overcomes cost 
furthermore sharpened unique states constraints syntactic analysis transition relation improvement absolutely necessary benchmarks go 
extensive testing reinforced view induction important complement bdd methods safety checking 
combination techniques results authors believe rst ecient complete induction checker produced academia 
enabled incremental sat interface explored online method adding uniqueness constraints demand 
large extent method saves user deciding manually add constraints making temporal induction push button technique 
side ect implementing temporal induction incrementally got incremental bmc safety properties 
orts incremental bmc extensive adaptation 
shown results magnitude achieved smaller modi cation solver 
standard way applying bmc generate single sat problem encoding presence bug time steps 
compared method iterating incrementally incremental approach faster cases speci ed close length shortest counter example 
single signi cant factor success temporal induction induction depth needed 
believe important direction research methods automatically strengthening induction step order reduce depth 
successful method achieving eijk bc 
works nding invariant equivalences implications state variables internal points 
casting method incremental system looks promising 
stronger constraints shape shortest counter example suggested sss successfully applied 
investigate dynamic approach similar uniqueness constraints helpful 
possible ways tuning sat solver incremental temporal induction 
particular wish explore native uniqueness constraints methods specialized variable orderings constraint replication 
acknowledgments mary sheeran careful reading valuable criticism manuscript 
baumgartner abraham property checking structural analysis cav lncs springer verlag 
bc claessen 
sat veri cation state space traversal fmcad lncs springer verlag 
biere cimatti clarke zhu 
symbolic model checking bdds tacas lncs springer 
biere clarke zhu 
verifying safety properties powerpc tm microprocessor symbolic model checking bdds cav lncs 
bry bryant 
graph algorithms boolean function manipulation ieee trans 
computers aug 
cab chan anderson beame burns notkin reese model checking large software speci cations ieee tran 
software engineering jul cff fix giunchiglia vardi 
bene ts bounded model checking industrial setting cav lncs 
cs claessen sheeran 
tutorial lava hardware description veri cation system www cs chalmers se koen lava dll davis loveland 
machine program theorem proving communications acm vol 
eijk van eijk 
sequential equivalence checking state space traversal proc 
conf 
design automation test europe 
hooker solving incremental satis ability problem journal logic programming vol 
ks ecient computation recurrence diameters lncs springer verlag 
ms marques silva sakallah 
grasp search algorithm propositional satis ability ieee transactions computers vol 
mz moskewicz madigan zhao zhang malik cha engineering ecient sat solver dac 
tuning sat checkers bounded model checking cav lncs springer verlag 
pruning techniques sat bounded model checking problem proc 
th advanced research working conf 
correct hardware design veri cation methods 
sss sheeran singh st 
checking safety properties induction sat solver fmcad lncs 
kim sakallah 
new incremental satis ability engine dac acm press 

