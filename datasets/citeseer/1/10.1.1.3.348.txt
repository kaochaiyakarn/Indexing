static analysis versus software model checking bug nding dawson engler computer systems laboratory stanford university stanford ca cs stanford edu describes experiences software model checking years static analysis nd errors 
initially thought trade clear static analysis easy mainly nd shallow bugs model checking require strictly better nd errors errors deeper approach powerful 
expectations wrong 
documents lessons learned course software model checking years projects 
rst projects static analysis model checking third model checking sharply re enforced trade previously observed 
rst project described section checked flash cache coherence protocol implementation code :10.1.1.134.9305
rst static analysis nd violations flash speci rules messages sent way prevent deadlock follow applied model checking 
startling result despite model checking power far fewer errors relatively shallow static analysis bugs versus 
second project described section checked aodv network protocol implementations 
rst checked cmc model checker directly checks implementations :10.1.1.114.6315
statically analyzed 
model checking worked nding errors roughly lines code half involve protocol properties dicult check statically 
class properties methods handle static analysis errors model checking 
took ort couple hours model checking ort took approximately weeks 
nal project described section cmc linux tcp network stack implementation 
startling result just dicult model check real code designed 
turned easier run entire linux kernel tcp implementation cmc cut tcp linux working test harness 
bugs linux tcp implementation 
main goal compare merits approaches nding bugs system software 
properties checked methods static analysis clearly successful took time analysis errors 
static analysis simply requires code compiled model checking system requires carefully crafted environment model 
static analysis cover paths code straightforward manner 
hand model checker executes paths explicitly triggered environment model 
common misconception model checking su er false errors errors typically static analysis result 
experience true 
false execution paths model checker triggered erroneous environments leading false errors 
errors dicult trace debug 
false errors static analysis typically arise infeasible paths eliminated simple analysis manual inspection 
advantage model checking ability check richer set properties 
properties require reasoning system execution amenable static checking 
protocol speci properties routing loops protocol deadlocks fall category 
model checker excels exploring intricate behaviors system nding errors corner cases accounted designers implementors system 
importance checking properties signi cantly weigh additional ort required model check system 
describes drawbacks software model checking compared static analysis taken approach 
model checking camp intend continue research area 
goals surprised applying model checking large real code bases 
minds discussions researchers shown naivete entirely unreasonable 
methodologies set case studies broad study static analysis model checking 
limits universality believe general trends observe hold actual coecients observed practice di er 
model checking approach case studies traditional explicit state model checkers 
innovation terms actual model checking engine challenges face roughly mirror faced 
believe optimistically estimates ort needed model check code 
major drawback current model checking approaches need manually write speci cation checked system 
approaches dispense step 
rst automatically extracts slice functionality translated model check ing language similar automatic extraction done prior notably bandera 
second approach eliminates extraction entirely directly model checking implementation code 
similar verisoft executes programs successfully check communication protocols java pathfinder uses modi ed java virtual machine check concurrent java programs 
static analysis approach general area static analysis bug nding extremely active 
known static tools include include pre esp esc mops slam combines aspects static analysis model checking :10.1.1.134.652:10.1.1.19.162
static tool approach discussed compiler extensions checkers dynamically linked compiler applied ow sensitively control ow graph representation source code 
extensions perform intra inter procedural analysis discretion checker writer 
practice approach ective nding hundreds thousands errors linux bsd various commercial systems 
claims static analysis general focuses static analysis approach mc personal experience 
approach idiosyncratic features compared static approaches kept mind 
particular features generally reduce needed nd bugs compared static analysis techniques 
approach unsound 
code errors pass silently checker 
goal nd maximum number bugs minimum number false positives 
particular checkers determine needed fact emit warning 
contrast sound approach conservatively emit error reports prove error occur 
unsoundness lets check ectively properties done soundly overwhelm user false positives 
second relatively shallow analysis compared simulation approach pre 
mild amount path sensitive analysis prune infeasible paths model heap track variable values sophisticated alias analysis 
heavier reliance simulation increase tool require having build accurate working models environment missing code 
sense simulation pushes static analysis closer model checking shares weaknesses strengths 
third approach tries avoid need annotations part statistical analysis infer checkable properties :10.1.1.134.9305
need annotations dramatically increase ort necessary tool 
case study flash section describes experience checking flash cache coherence protocol code static analysis model checking :10.1.1.134.9305
flash multiprocessor implements cache coherence software 
gives exibility places serious burden programmer 
code runs approach errors code checked pre properties depth checking entirely sided 
cache optimized 
time single bug controller deadlock livelock entire machine 
checked flash protocols static analysis model checking 
protocols ranged lines long control ow paths 
average path lines code maximum roughly lines 
intra procedural paths span conditionals uncommon 
purposes code representative low level code variety embedded systems highly optimized dicult read dicult get correct 
purpose nding errors flash hard test time checked undergone years testing simulation real machine protocol model checked manually constructed model 
checking flash static analysis flash code dicult reason nice property rules obey mapped clearly source code readily checked static analysis 
rule representative example 
flash code incoming message bu ers read macro read db 
reads preceded call macro wait db full synchronize bu er contents 
increase parallelism wait db full called paths require access bu er contents called late possible paths 
rule checked statically traversing program paths hit call wait db full point path hit call read db point emit error 
general static checkers roughly follow similar pattern match speci source constructs extensible state machine framework ensure matched constructs occur occur speci orders contexts 
table gives representative listing flash rules checked 
primary job flash node receive respond cache requests rules involve correct message handling 
common errors deallocating message bu ers errors mis specifying length message errors 
rules easier generally locations obeyed 
errors total false positives 
obtained numbers years ago 
current system reduced false positive rate due simple infeasible paths eliminate 
severity errors rate perfectly acceptable 
model checking flash static analysis worked code visible rules diculty properties visible source code implied invariants data structures values produced code operations 
example sharing list dirty cache line empty count sharing nodes equaled number caches line 
hand sort properties flash structure general suited model checking 
unfortunately known hard problem model checking real code need write speci cation model describes software 
example took graduate student months build rule loc bugs false wait db full come read db data parameter message sends match speci ed message length len len word len 
message bu ers allocated deallocated deallocation 
message handlers send pre speci ed lanes 
total table representative flash rules number lines code mc rule checker loc number bugs checker bugs number false positives fp 
elided useful checkers total bug cost false positives 
hand written heavily simpli ed model single flash protocol 
model checking approach problem static analysis automatically extract models source code 
started project noticing close correspondence hand written speci cation flash implementation code 
flash code heavy stylized macros naming conventions 
latent speci cations relatively easy pick code relevant various important operations message sends interactions subsystem automatically translate checkable model :10.1.1.134.9305
model checking system involves steps 
user provides metal extension run extensible compiler marks speci source constructs message bu er manipulations sends 
extensions essentially abstraction functions 
second system automatically extracts backward slice marked code dependencies 
third system translates sliced code mur model 
fourth mur model checker checks generated model hand written environment model 
table lists representative subset rules checked static analysis diculty 
surprisingly relatively errors properties compared shallow properties checked static analysis 
myth model checking nd bugs general perception bug nding community model checking deeper static analysis take time model check code nd errors 
true case study 
flash static analysis roughly times bugs model checking despite fact spent time model checking ort 
di erential aggressively tried increase bug counts 
highly motivated published bugs publishing follow technique required fewer 
bugs model checking missed static analysis 
counter ows deeper sense required deep execution trace nd 
potentially static analysis doing required special case checker 
main underlying reason lower bug counts simple model checking requires running code static analysis just requires compile 
model checking requires working model environment 
environments messy hard specify 
formal model simplify 
main simpli cations caused model checker flash bugs static analysis 
model cache line data model state cache lines actual messages sent 
omission simpli ed model state space 
main implication terms nding errors model ensure data bu ers send receive cache lines allocated deleted synchronized correctly 
result model checking missed errors bu er allocation errors bu er race conditions 

model flash subsystem primarily intricate 
caused model checker message length errors static checker 

model uncached reads writes 
node controllers support reads writes explicitly bypass cache going directly memory 
rare paths operating system 
paths rare appears testing left relatively larger number errors compared common paths 
errors static analysis missed model checker model simpli cation 

model message lanes 
prevent deadlock real flash machine divides network number virtual networks lanes 
di erent message type associated lane 
simplicity model assumed restrictions 
result missed deadlock errors static analysis 

flash code dual code paths support simulation running actual flash hardware 
errors simulation code detected checked code run hardware 
broader view main source false negatives incomplete models need create model 
cost paid new checked system nite resources preclude checking new code invariants counter ow maintains number sharers 
single master copy cache line exists basic coherence 
node put sharing list sharing list remote nodes 
outstanding requests cache lines exclusive state 
nodes send network messages 
nodes ow network queues 
nodes ow software queues queue suspend handlers 
protocol tries invalidate exclusive line 
protocol put data processor cache response request 
table description representative subset invariants checked flash protocols model checking 
checking static analysis dicult 
limit checking just code properties environment speci ed minimum fuss 
example flash time limitations caused skip checking sci protocol missing bu er management errors serious minor static analysis 
summary static analysis works checking properties clearly map source code constructs 
model checking similarly leverage feature automatically extract models source code 
case study shows rules checked small simple static checkers 
approach ective nd errors code written veri cation years 
approaches static analysis important advantages model checking 
sharp contrast thorough working code understanding demanded model checking static analysis allowed understand little flash check mainly compile sentences describing rules 
second static analysis checks paths code compile 
model checking checks code run code paths execute 
fact hurt bug counts case study 
case study aodv section describes experiences nding bugs aodv routing protocol implementation model checking static analysis 
rst describe cmc custom model checker built give overview aodv compare bugs approaches 
cmc overview automatically slicing model flash far superior hand constructing approach problems 
required user intimate knowledge system ectively select automatically mark stand subparts 
second mur modeling languages lacks constructs pointers dynamic allocation bit operations 
omissions general translation dicult 
countered problems building cmc model checker checks programs written :10.1.1.114.6315
cmc motivated observation fundamental reason model checkers weak input language 
executes implementation code directly removes need provide model tremendously reducing ort required model check system 
implementation captures behaviors system cmc longer restricted behaviors represented conventional modeling languages 
cmc explicit state model checker works mur lacks mur advanced optimizations 
cmc checks full implementation abstraction handle larger states state spaces 
counters state explosion problem aggressive approximate reduction techniques various heuristics slice unnecessary detail state :10.1.1.114.6315
aodv overview aodv ad hoc demand distance vector protocol loop free routing protocol ad hoc networks 
designed handle mobile nodes best ort network lose duplicate corrupt packets 
aodv guarantees network free routing loops 
error speci cation implementation causes routing loop appear network protocol mechanism detect recover allowing loop persist forever completely breaking protocol 
crucial comprehensively test aodv protocol speci cation aodv implementation loop freeness thoroughly possible 
aodv relatively easy model check 
environmental model greatly simpli ed fact input deals user requests route destination 
easily modeled nondeterministic input enabled states 
apart aodv node responds events timer interrupt packet received aodv nodes network 
straightforward model 
model checking aodv cmc cmc check publicly available aodv implementations mad hoc version kernel aodv version aodv uu version 
clear implementations tested di erent testbeds network simulation environments 
average implementations contain lines code 
assertion type examples generic segmentation violations memory leaks dangling pointers 
routing loop routing tables nodes form routing loop 
routing table entry destination 
route self aodv uu implementation 
routing table hop count route self 
hop count nity number nodes network 
message field reserved elds set 
hop count packet nity 
table properties checked aodv 
protocol checked correctness environment state code speci cation network stubs canonicalization mad hoc kernel aodv aodv uu table lines implementation code vs cmc modeling code 
implementation model consists core set unmodi ed les 
model executes environment consists network model simpli ed implementations stubs implementation functions included model 
table describes model environment implementations 
models reuse network model 
cmc developed case study dicult gauge time spent building models opposed building model checker 
rough estimation took weeks build rst mad hoc model 
building subsequent models easier took week build models 
table describes assertions cmc checked aodv implementations 
cmc automatically checks certain generic assertions segmentation violations 
additionally protocol model checks routing tables loop free instants generated message route inserted table obey various assertions 
table gives lines code required add correctness properties 
cmc total errors 
unique errors implementations error underlying aodv speci cation 
table summarizes set bugs 
kernel aodv implementation bugs shown parentheses table instances bug mad hoc 
aodv speci cation bug causes routing loop implementations 
static aodv checking paths code bugs cursory check aodv implementations set static analysis checkers looked generic errors memory leaks invalid pointer accesses 
entire process checking implementations analyzing output errors took hours 
static analysis total bugs 
table compares bugs static analysis cmc 
classi es bugs broad classes depending properties violated generic protocol speci generic errors results matched flash case study static analysis bugs model checking 
static analysis bugs cmc nd 
previous case study fundamental reason di erence static analysis check paths code compile 
contrast model checking check code triggered speci environment model 
errors cmc parts code included model cut environment modeling 
instance static analysis cases malloc failures multicast routing code 
cmc models omitted code 
additionally cmc missed errors subtle mistakes environment model 
example mad hoc implementation uses send datagram function send packet memory leak function fails 
environment erroneously modeled send datagram succeeding 
cmc missed memory leak 
environmental errors caused cmc errors total 
static analysis error dead code executed cmc model 
model checking won checks bugs class protocol speci errors cmc errors static analysis 
partly check protocol speci properties errors dicult nd statically 
categorize errors model checking missed static analysis classes describe 
executing code model checker check properties easily visible static inspection static analysis 
protocol speci properties fall class 
properties deadlocks routing loops involve invariants objects multiple processes 
detecting loops statically require reasoning static analysis null pointer violation environment models 
count error 
mad hoc kernel aodv aodv uu malloc failures memory leaks free invalid routing table entry unexpected message generating invalid packets program assertion failures routing loops total loc bug table number bugs type implementations aodv 
gures parenthesis show number bugs instances bug mad hoc implementation 
bugs cmc mc cmc mc generic malloc failures properties memory leaks free invalid routing table entry protocol unexpected message speci generating invalid packets program assertion failures routing loops total table comparing static analysis mc cmc 
note mc results ran set generic memory pointer checkers writing aodv speci checkers 
generating mc results took hours weeks required aodv 
entire execution protocol dicult task 
static analyzers diculty analyzing properties heap objects 
error example 
error requires reasoning length linked list similar heap invariants static analyzers diculty 
code attempts allocate msg dst cnt temporary message bu ers 
correctly checks malloc failure breaks loop 
calls rec rerr contains loop assumes msg dst cnt list entries allocated 
list fewer entries expected code attempt null pointer get segmentation fault 
second advantage model checking checks actual errors having reason di erent ways error caused 
catches particular error type matter cause error 
example model checker cmc runs code directly detect null pointer dereferences deadlocks operation causes runtime exception code crash lock 
importantly detect having understand anticipate ways errors arise 
contrast static analysis checks look speci ways causing error 
errors caused actions checker know analyze agged 
minimize false positives looking errors speci analyzable contexts 
example error cmc aodv speci cation shown 
error arises speci cation check sequence number received packet 
node receives packet stale route old sequence number 
code speci cation erroneously updates sequence number current route checking route packet valid 
results routing loop 
cause routing loop known possible easy statically ensure sequence number updates routing table received packets involve validity check 
places specialized checks applied making hard cost writing checker 
exhaustively enumerating di erent causes routing loop possible 
hand model checker check actual errors need reasoning causes 
general sense model checking checks mean give guarantees closer total correctness static analysis 
surprised code passed realistic static checks immediately crashed run 
hand environment model input sequences model checked code works 
model checking verify code totally correct executions tested state reduction techniques allow executions cover initial portion search space dicult implementation eciently get new untested areas 
risk optimistic suggests residual bugs model checked implementation hard trigger aodv aodv recv message step break tp malloc break tp msg dst enqueue list 
msg dst tp 
step rec rerr assumes dst cnt elements msg rec rerr info msg msg int rec rerr struct info tmp info struct rh 
step iterates rh dst cnt times elements rh dst dst cnt tp tp error tp null 
tmp tp dst ip memory error missed static analysis requires reasoning values example model checking beat static analysis 
rerr rec rerr recv rt route just received network 
cur rt current route entry ip address 
cur rt recv rt dst ip cur rt null 
bug updates sequence number checking received packet newer route table entry 
cur rt dst seq recv rt dst seq aodv speci cation error 
common pattern bug caught static analysis places check dicult recover overhead building checker 
ectively 
nal model checking advantage true bugs methods catch happen labeled false positives static analysis 
contrast model checking produces execution trace bug correctly labeled 
best example case aodv node receives route response packet reply route request message sent 
code rst looked route reply packet ip address route table entry checking null 
route table lookup return null general particular lookup null node sends route requests valid route table entries 
unchecked dereference agged static analysis labeled false positive 
node sends message reboots receives response entry null 
model checking gave exact sequence events error relatively clear 
summary high bit aodv model checking hit properties static hit code checked property static won 
surprising implies bugs shallow requiring little analysis code dicult analysis understand similarly hard programmers understand 
flash di erence time signi cant hours static versus weeks model checking 
view trade approaches static analysis checks code checks implications code relatively poorly 
hand model checking checks implications relatively better problems abstraction coverage ective checking actual code 
results suggest model checking get results real systems code order justify signi cant additional ort target properties checkable statically 
case study tcp section describes orts model checking linux tcp implementation 
decided check tcp relative success aodv hardest code think terms nding bugs 
sources diculty 
version checked linux roughly times larger aodv code lines versus 
second mature frequently audited code 
third linux sites constantly tcp heaviest tested pieces open source code 
expected tcp require modest ort aodv 
section describes expectation wildly naive 
section shows di erent matter get code run getting run comprehensively test 
environment problem lots time lots false positives system model checked typically larger execution context 
instance linux tcp im plementation linux kernel closely interacts kernel modules 
model checking necessary extract relevant portions system model checked create appropriate environment allows extracted system run stand 
environment contain stubs external functions system depends 
implementation level model checker cmc process similar building harness unit testing 
building comprehensive environment model large complex system dicult 
diculty known extent model checking literature typically 
extracting code amounts deciding external function system calls function included checked code base create stub function include stub environment model 
advantages including function checked code model checker executes function potentially nd errors need create stub maintain stub code evolves 
including external function system function potentially increase state space call additional functions stubs need provided 
conventional wisdom dictates cut narrowest possible interface 
idea requires emulating fewest possible number functions minimizing state space 
surface sense utter failure tcp 
discuss expect cause similar problems complex system 
failure building kernel library rst attempt model check tcp obvious thing cut tcp code proper tightly coupled modules ip tried kernel library emulated functions code called 
unfortunately tcp comprehensive interaction rest kernel meant despite repeated attempts reduce interface functions write stub 
abandoned ort months trying get stubs correctly 
mainly failed tcp large complex subsystems large complex messy interface host system 
writing harness perfectly replicates exact semantics poorly documented interface dicult 
practice stubs myriad subtle corner case mistakes 
model checkers tuned nd inconsistencies corner cases generate steady stream bugs false 
matters worse false positives tend harder diagnose caused static analysis 
typically require seconds rarely minutes diagnose 
contrast tcp complexity meant spend days trying determine error report true false 
example apparent tcp storage leak socket structure caused incorrect stub implementation linux timer model 
tcp implementation uses function mod timer modify expiration time previously queued timer 
function return value depends timer pending function called 
initial stub returned value 
mistake confused counting mechanism socket structures obscure way causing memory leak took lot manual examination unravel 
conceivable eventually replicated functions interface perfection semantics changed 
reaching xed point fact additional false positive harder diagnose 
easier approach 
surprising success run linux cmc intuitive cut smallest interface point intuitive cut de ned documented interfaces 
turns tcp expect complex code general better bet 
greatly simpli es environment modeling 
additionally interfaces change revisions allowing environment model re system implementation evolves 
approach may force model checker deal larger states state spaces bene ts clean environment model outweigh potential disadvantage 
turns tcp ned interfaces system call interface de nes interaction user processes kernel hardware abstraction layer de nes interaction kernel architecture 
cutting code level means wind pulling entire kernel model 
initially sounded daunting practice turned dicult port kernel cmc providing suitable hardware abstraction layer 
ease part reuse lot user mode linux uml project solve problems aim run working kernel user process 
order check tcp implementation protocol compliance wrote tcp model tcp rfc 
cmc runs alongside implementation providing inputs implementation reports states inconsistent protocol violation error 
coverage problem execute bug dynamic checking tools model checking nd errors executed code paths 
practice quite dicult exercise large amounts code 
section measures comprehensively check tcp 
metrics measure coverage 
rst line coverage implementation achieved model checking 
measure means may correspond system checked ectively detect parts tested 
second protocol coverage corresponds protocol behaviors tested model checker 
calculate protocol coverage line coverage achieved tcp model mentioned 
roughly represents degree protocol transitions explored 
metrics detect model checking comprehensive 
low coverage helped pointing errors environment model 
table gives coverage achieved step model re nement process 
measured coverage cumulatively search techniques breadth rst depth rst random 
random search generated state description line coverage protocol coverage branching factor bugs standard server client simultaneous connect partial close message corruption combined coverage table coverage achieved model re nement 
branching factor measure state space size 
random priority 
table reports branching factor state space measure size lower branching factors mean state increases exponentially step 
rst models branching factor calculated number states queue depth breadth rst search 
fourth model cmc ran resources depth branching factor calculated depth 
rst model consists single tcp client communicating single tcp server 
connection established client server exchange data directions closing connection 
standard model discovered protocol compliance bugs tcp implementation 
second model adds multiple simultaneous connections initiated nondeterministically 
third model lets connection nondeterministically decide close data transfer 
improved coverage resulted discovery errors 
remaining untested functionality code handle bad packets corrupted packets nondeterministically toggling selected key control ags tcp packet 
corrupted packets triggered lot recovery code resulted enormous increase state space 
tweaking environment right way achieve ective search remains interesting unsolved problem 
detected errors linux tcp implementation 
instances implementation fails meet tcp speci cation 
errors fairly complex require intricate sequence events trigger error 
discussion section discusses lessons learned static analysis large real systems 
features bug nding analysis unexpected 
started thought dicult nd bugs large working system detecting just success 
fact thought historical data demonstrate approach able nd bugs live system 
view dramatic overestimation needed nd interesting bugs 
code obey checked property couple times certainly nd violations analysis certainly broken 
practice anytime push lines code checker nd immediately assume bug system 
second analysis needed check property easier write code needed articulate property violated 
requires tracking analysis step done detect error searching shortest number steps needed cause error 
unsurprisingly saying happened takes saying happened 
analysis needed check properties actual code simpler need fully general case 
part come fact code dealing human level properties check lock followed call unlock arbitrarily complex understood programmer 
code hard analysis understand hard people understand 
look issues detail 
ease inspection really matters surprise static analysis just important ease inspection cases hard error users simply ignore measure may ignore errors general principle 
example commercial pre tool explicitly avoided nding race conditions deadlocks simply errors dicult inspect 
initial commercial orts similarly scaled back analysis sophistication focus errors easy reason 
bugs easy examine hard absence additional discriminatory information severity likelihood rst better 
myth analysis better eld initially believed analysis better came form model checking simulation deeper static analysis 
view simplistic adding analysis improve results worse 
ideal error easy diagnosis true error easy generally speaking analysis required nd error worse metrics 
typically analysis nd error harder error reason 
inspection user mentally emulate analysis step aliases determined interprocedural call path feasible determine plausible countered 
steps emulation 

number analysis steps increases chance went wrong 
analysis approximation mistakes 
analysis widespread ects mistake 

hard errors nd hard errors example initial static checkers syntactic 
result errors certainly errors trivial inspect 
added interprocedural support simple aliasing errors dicult inspect 
fact deliberately reverted weaker analysis nd errors system supports simply specializing error classes cherry picks easy diagnose bugs 
common case design checkers explicitly intraprocedural analysis despite fact system supports transparent interprocedural analysis local bugs easier diagnose interprocedural ones 
strong analysis rank error reports number analysis steps required 
example bugs involving aliasing spanning procedure calls demoted 
myth bugs matter initially thought bugs matter bugs xed 
true 
nd small number bugs people 
nd thousands 
observed open source projects commercial systems bugs detected open 
prior pre group observed similar dynamic giving stack defects ective way elicit blank stare question great ones matter 
nd lot bugs 
tools ective obvious 
users really want nd bugs really matter ones hurt large number customers absorb bulk debugging time general belief bugs follow distribution 
errors account pain waste resources fact xing errors may worsen system quality introducing additional errors draining resources orts testing code reviews 
unfortunately current tools easily segregate errors di erent types inspected priority security holes storage leaks null pointer dereferences lack ective methods identifying important errors 
identifying area research 
described trade static analysis model checking surprises encountered applying model checking large software systems 
static analysis model checking stage dominates 
model checking gets properties static analysis hit code checked property static analysis won 
main advantages static analysis model checking gets paths code compile just executed paths code run requires shallow understanding code applies hours weeks easily checks millions lines code tens thousands nd thousands errors tens 
rst question ask static analysis big code 
nicely bigger better lets amortize xed cost setting checking 
model checking rst question code 
program classes model checked doing requires intimate understanding code 
code surprised static analysis gets results surprised model checking attempt abandoned 
direct implications fact model checking runs code static analysis 
believe static analysis generally win terms nding bugs possible 
sense better bugs gets users closer desired goal absence bugs total correctness 
model checking advantages hard static analysis match check implications code just surface visible properties checks routing table loops having anticipate craft checks ways error type arise gives stronger correctness results surprised code crashed model checked surprised crashes statically checked 
signi cant model checking drawback need create working correct environment model 
realized just dicult large code bases 
cases added weeks months ort compared static analysis 
practicality forced omissions model behavior deliberate accidental 
flash aodv unmodeled code omitting system multicast support led false negatives 
model perfectly replicate real behavior ght quite tricky false positives development 
tcp problem eventually forced resort running entire linux kernel inside model checker creating set fake stubs emulate tcp interface 
anticipated 
model checking case studies reinforced lessons 
model implementation 
modi cation translation approximation done potential producing false positives danger checking far system behaviors course missing critical errors 

manual required model checking process immensely dicult scale system increases 
order scale model checker require little user input annotations guidance possible 

unit test framework available de ne system boundary known public interfaces 

try cover possible code trigger bugs nd useful model checking acknowledgments research done 
particular david lie andy chou discussions lessons learned model checking flash code bulk david park signi cant help developing cmc model checking tcp 
especially david dill valuable discussions years 
willem visser thoughtful comments previous version 
research supported part darpa contract mda marco sa jb stanford networking research center 
dawson engler partially supported nsf career award 
thomas ball majumdar todd millstein sriram rajamani 
automatic predicate abstraction programs 
proceedings sigplan conference programming language design implementation 
brat havelund park visser 
model checking programs 
ieee international conference automated software engineering ase 
bush pincus static analyzer nding dynamic programming errors 
software practice experience 
chandra patrice godefroid christopher palm 
software model checking practice industrial case study 
proceedings international conference software engineering icse 
hao chen david wagner 
mops infrastructure examining security properties software 
proceedings th acm conference computer communications security pages 
acm press 
chou chelf engler heinrich 
meta level compilation check flash protocol code 
ninth international conference architecture support programming languages operating systems november 
corbett dwyer laubach pasareanu robby zheng 
bandera extracting nite state models java source code 
icse 
perkins royer das 
ad hoc demand distance vector aodv routing 
ietf draft www ietf org internet drafts draft aodv txt january 
das lerner mark 
esp path sensitive program veri cation polynomial time 
conference programming language design implementation 
david dill andreas drexler alan hu han yang 
protocol veri cation hardware design aid 
ieee international conference computer design vlsi computers processors pages 
engler chelf chou hallem 
checking system rules system speci programmer written compiler extensions 
proceedings operating systems design implementation osdi september 
engler chen hallem chou chelf :10.1.1.134.9305
bugs deviant behavior general approach inferring errors systems code 
proceedings eighteenth acm symposium operating systems principles 
erik nordstrom aodv uu implementation 
user uu se aodv 
flanagan leino lillibridge nelson saxe stata 
extended static checking java 
conference programming language design implementation pages june 
godefroid 
model checking programming languages verisoft 
proceedings th acm symposium principles programming languages 
hallem chelf xie engler 
system language building system speci static analyses 
sigplan conference programming language design implementation 
holzmann smith 
software model checking extracting veri cation models source code 
invited 
proc 
forte publ 
kluwer 
gerard holzmann 
model checker spin 
software engineering 
luke klein berndt kernel aodv implementation 
nist gov aodv kernel 
heinrich simoni gharachorloo chapin baxter horowitz gupta rosenblum hennessy :10.1.1.134.9305
stanford flash multiprocessor 
proceedings st international symposium computer architecture april 
lie chou engler dill 
simple method extracting models protocol code 
proceedings th annual international symposium computer architecture july 
mad hoc aodv implementation 
mad hoc 
net 
lundgren nielsen nordstrom tschudin 
large scale testbed reproducible ad hoc protocol evaluations 
ieee wireless communications networking conference march 
david park andy chou dawson engler david dill :10.1.1.114.6315
cmc pragmatic approach model checking real code 
proceedings fifth symposium operating systems design implementation december 
park dill 
veri cation flash cache coherence protocol aggregation distributed transactions 
proceedings th acm symposium parallel architectures pages june 
pincus 
personal communication 
pre target data races user interface complexities reporting diagnosis march 
stern dill 
new scheme memory ecient probabilistic veri cation 
ifip tc wg joint international conference formal description techniques distributed systems communication protocols protocol speci cation testing veri cation 
user mode linux kernel 
user 
sourceforge net 
