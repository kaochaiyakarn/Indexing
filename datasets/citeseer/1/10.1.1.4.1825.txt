collision detection glide rotations samuel buss department mathematics univ california san diego la jolla ca september introduce framework collision detection pair rigid polyhedra 
initial final positions orientations objects algorithm determines bodies collide 
collisions including collisions di erent times computed 
kind collision information useful handling multiple nearly concurrent contact points real time applications computer games 
relative motions rigid body limited glide rotation screw motion 
limitation completely accurate give bounds error introduced assumption 
implementation uses approximate position time collisions 
allows level detail techniques provide tradeo accuracy computational expense 
collision detection algorithms approximate glide rotation limitation 
quite robust rigid bodies give consistent information collisions avoid sensitivity errors 
collision detection important problem physical simulations motion planning 
di cult problem especially important collision detection fast robust tolerant supported part nsf dms 
email ucsd edu errors 
presents algorithm performing collision detection moving modeled objects 
original motivations algorithm detecting collisions computer game applications particular racing games collision detection performed objects moving high speed 
situation objects frequently significantly completely pass single simulation step 
designed algorithm robust presence significant interpenetration handle significant translational rotational motion 
addition algorithm discovers multiple collisions just collisions 
identifying multiple collisions concurrent possible handle high speed collisions games maintain multiple contact points contacting objects 
algorithm described takes input initial prior position final position object uses estimate intermediate motions objects screw motion 
algorithm computes collision occurs motion initial position final position 
addition single pass algorithm determines times positions collisions need back time binary search find time objects 
algorithm computes simultaneously collisions initial final positions just collision 
collisions classified proper proper ness depends objects facing locally collision 
data subsequent application dependent algorithms recognize concurrent collisions 
detecting collisions intermediate times objects relative motion assumed screw moving glide rotation 
assumption exactly correct reasonable common assumptions rotation translating axis 
addition error introduced glide rotation assumption quantified quite small see section 
authors glide rotations collision detection rossignac kim advocate screw motions intermediate relative motion kim rossignac redon screw motions collision detection 
principal idea algorithm glide rotations allow view rigid objects moving fixed track rotation curvature induced curvature position mean position orientation 
track 
allows set curved collision screen project objects collision screen similar spirit way objects orthogonally projected flat plane 
collisions examining points objects project common points screen 
implemented algorithm restricted solid rigid objects defined surfaces consisting polygonal patches 
allow arbitrary objects including nonconvex objects 
form algorithm implemented works objects far convex readily extended handle highly nonconvex objects screw fitting screw hole 
describe implementation collision algorithm uses techniques analytic methods redon 
algorithm di ers looks collisions entire polyhedra treating facets polyhedra individually 
allows algorithm quite robust tolerant errors 
furthermore adjusting resolution allows tradeo accuracy computational cost 
collision detection algorithm intended component large scale simulation collisions contacts multiple moving bodies 
moving objects time consuming check collisions pairs objects 
space partitioning algorithms bsp trees trees prune set possible collisions bounding volumes swept spheres obbs dops quickly decide objects collide 
intended algorithm preliminary tests check remaining potentially colliding pairs objects 
subsequently data collision detection algorithm application dependent algorithms decide handle collisions calculate forces changes motion result collisions 
consider prune intersection testing calculate collision responses 
examine question determining single pair rigid objects collided 
prior motivations collision detection recognized years important area computer graphics early papers include field grown large survey 
discuss relevant order contrast algorithm primary focus collision rigid polyhedral objects 
see survey collision detection 
number collision detection algorithms convex objects 
include algorithms lin canny exploit voronoi diagram space convex objects linear algebra methods gilbert enhancements algorithms cf 

algorithms compute distance non overlapping convex bodies convex bodies detected algorithms reliably converge decision collided 
moving bodies discovered time backed binary search procedure bisection find approximate time position collision convex bodies 
algorithms may collisions bodies pass single simulation step 
class algorithms attempts deal directly objects particularly convex objects 
give algorithms finding minimum interpenetration distance overlapping convex bodies 
extend algorithms apply nonconvex objects decomposition convex pieces 
algorithms attempt deal directly bodies may estimate collision times positions 
algorithm restrict purely translational motion 
various techniques speed collision detection algorithms 
coherence greatly increase speed collision detection 
second dobkin kirkpatrick gave method time preprocessing perform distance calculations non overlapping convex bodies arbitrary orientations log time total number edges faces bodies 
impressive algorithms tracking multiple moving polygonal planar objects detecting collisions kinetic data structures see 
addition swift systems track large number polyhedra multilevel hierarchy polyhedra 
algorithms space objects convex decomposed convex objects 
discussed algorithms detect collisions discrete points time prior algorithms directly calculate collisions intermediate times needing bisection find collision time 
gave algorithm find collisions moving polygonal objects moving purely purely rotationally 
cameron describes dimensional approach handled piecewise linear motion convex polyhedra 
canny extended methods find collisions polygonal faces moving rotating approximately uniform rate 
thiele gave subquadratic algorithm find point intersection polyhedra moving rotating fixed axis 
redon algorithms polygonal objects moving rotationally non classical screw motion 
von herzen interval arithmetic find collisions moving objects movements allowed general objects allowed deform 
redon interval arithmetic colliding polygons polygon soup framework arbitrary sets polygons checked collisions allowed polygons relative motion screw motion rotations 
rossignac authors screw motions discussed analytic methods colliding polygons relative motion screw motion collision points times computed closed form newton iterations approximate collision 
algorithm uses screw motions call glide rotations 
di er methods ways 
prominently collide objects manner colliding pairs facets 
possible glide rotation movement viewed moving fixed track set collision screen polygonal facets drawing lines edges collision screen look potential collisions 
number advantages including possibility round errors allow vertex slip adjacent edges object 
lets find collision point potential collision points discussed section 
side ect glide rotations allows particularly sophisticated form culling back facing faces 
discussed described section glide rotations back face culling cut polygonal faces sub polygons part front facing part back facing 
collision detection portions face discarded 
improves back face culling methods redon discard face vertices back facing 
line prior earlier unpublished software racing car games pc game consoles published angel studios racing games run midnight club 
algorithms handle arbitrary polygonal objects take motion account capable detecting collisions objects completely passed attempt identify multiple nearly concurrent collisions 
earlier algorithms handle rotation ad hoc production susceptible occasionally yielding erroneous results 
reduce erroneous results get faster computation times angel studios uses geometric shapes boxes spheres cylinders custom collision detection algorithms geometric shapes general collision detection algorithm polyhedra 
experience angel studios deeply influenced outlook collision detection especially opinion described section useful find possible collisions objects just 
intermediate motion multiple collisions section argue helpful collision detection algorithms consider relative motion potentially colliding objects find collisions occur just ones 
find collisions meant find instances portions objects contact assumption motion continues collisions ect motion 
motivations arose collision detection real time computer games particularly high speed car racing games 
games speeds excess mph uncommon 
speed simulations performed time steps second vehicle moves substantial meters time step 
simulation rates frames second distance substantial meters single time step 
allows considerable interpenetration vehicle may penetrate stationary object distance resp meters single simulation step 
worse vehicles colliding head potentially twice squares 
absence information objects movement collision direction 
penetration 
motion account collision detection give wrong results cars appearing pass completely colliding wrong way cars hit object head collision occurs sideways 
give simple dimensional examples illustrate objects motions collision detection algorithm 
consider overlapping squares 
wish determine reasonable estimate manner squares collided say purposes separating squares avoid visual interpenetration purposes computing dynamic response collision 
information motion squares plausible ways collided 
symmetry indicate leftmost vertex collided rightmost vertex hand discuss section vertex vertex collisions usually desirable collision multiple concurrent collisions vertex face 
occur deciding lower left face collided upper right face case reporting face face collision algorithm report vertex face collisions left vertex upper right face plus right vertex lower left face alternatively upper left face may collided lower right face shows examples rectangles colliding horizontally 
collision entirely unproblematic collision algorithm course reports simultaneous collisions left vertices object right face object second collision object tilted slightly lower left vertex contacts upper left vertex 
case algorithm reports collisions collision lower left vertex right face second collision occurs slightly upper left dimensional example face synonym edge analogous collisions dimensions vertex face collisions 
collision collision collision 
rectangles collided 
rectangle left stationary 
rectangle right translating horizontally leftward 
general polygon collided translating horizontally 
vertex face collisions assigned proper ness rating 
collision entirely proper second slightly improper 
due fact left face inside upper left vertex collides indicates collision collision point locally 
part shows di erently shaped object translating horizontally 
case algorithm reports proper collisions vertices right face occur slightly di erent times 
treatment multiple non concurrent collisions improper collisions depends application 
real time video game applications obtained results collisions improper calculating collision impulses collision response assumption collisions occurred simultaneously 
see methods calculating impulses forces response multiple collisions 
consequence collisions depicted parts give rise similar collision responses 
hand collision shown handled objects possibly leading immediately collisions ultimately di erent physical simulation 
points advantage treating multiple collisions simultaneously bodies modeled completely rigid treat collisions singly model physical responses impulses huge number collisions occur short period time 
number authors simultaneous collisions form multiple contacts bodies objects stack come rest 
errors real distinction ous collisions nearly simultaneous collisions useful know collisions just 
possibilities deciding collisions handled 
physically accurate simulation necessarily real time occurring collision require backing time time collision restarting simulation point time 
mirtich describes kind approach 
possible hybrid methods useful collisions occur certain arbitrary time treated simultaneous 
shall discuss collision response 
definition collision section 
glide rotations collision detection algorithm initial positions final positions objects estimates intermediate movement positions 
assumes relative movement objects forms glide rotation screw 
explain suppose initial positions objects pair rigid orientation preserving ne transformations final positions represent positions objects resp translate resp local coordinate system global coordinate system 
point local coordinates represent initial final positions point expressed global coordinates 
express motion point view local coordinate system 
suppose point moving rigidly initial configuration position local coordinate system 
final position point expressed local coordinate system 
course rigid orientation preserving ne transformation 
known transformation translation glide rotation 
see instance 
glide rotation rigid orientation preserving ne transformation defined rotation axis line specified point unit vector line contains parallel direction uniquely determined 
glide angle 
glide distance glide rotation acts point rotating angle rotation axis direction rotation determined right hand rule translating distance direction rotation axis vector just point origin glide rotation simple form consists rotating angle axis plus translating upwards distance glide rotation cx sx cx sx sin cos 
glide rotations property generated smooth flow 
say velocity field point specifies velocity point position velocity field generates glide rotation unit time period 
flow associated glide rotation gj equivalently 
describes velocity particles object initially position carried unit time period 
determination glide rotation discuss transformation represented glide rotation similar construction rossignac kim 
transformation rotation matrix plus translation amount ax express glide rotation express rotation matrix rotation radians axis unit vector 
see algorithms determining 
vector direction glide rotation axis 
point closest point rotation axis origin formula tan 
equation verified examination calculation simplified somewhat half angle formula tan cos sin 
determination point rotation axis 
rotation axis pointing straight 
tan perpendicular rotation axis 
determining glide rotation axis angle change coordinates glide rotation axis axis 
coordinates origin 
forward facing surfaces crucial property glide rotations rigid object transformed glide rotation flow surface object consistently divided forward facing regions backward facing regions 
intuition forward facing regions areas surface outward surface normal looking forward direction motion 
precisely position point surface surface normal point forward facing provided 
points backward facing 
rigid object moves glide rotation flow portions object surface forward backward facing remain unchanged 
forward facing point surface stays forward facing 
symmetry flow glide rotation axis fact object rotates part facing rotation axis 
performing collision detection rigid objects compute forward facing faces glide rotation backward facing faces glide rotation 
backward facing faces symmetrically viewed transformed inverse viewpoint assumption initial configurations set collisions involve forward facing faces backward facing faces re forward facing surfaces solid lines backward facing surfaces dotted lines square rotating origin 
backward facing surfaces cube 
cube carried lines glide rotation 
attention appropriate forward backward facing edges reduced number faces need considered collision candidates 
shows simple dimensional example forward facing surfaces 
shows square rotating counterclockwise origin 
forward facing faces shown solid lines backward facing faces shown dotted lines 
note faces edges forward backward facing components 
figures shows dimensional example backward facing faces cube 
cube drawn wireframe backward faces shown solid blue rectangles 
rest faces forward facing drawn 
see simple compute forward backward facing parts modeled surface 
consider polygonal patch lies plane normal 
forward facing parts satisfy 
gj gj 
zero constant equal gj depending sign plane forward facing backward facing 
defines plane normal direction fact perpendicular intersect line splits forward facing backward facing parts 
patch intersected splits polygonal forward facing backward 
computed clipping patch plane mentioned section construction forward facing rossignac kim 
algorithm works entire set forward facing edges additional complication polygons projected collision screen twice order collisions 
discussed section 
logically distinct process culling back faces implemented algorithm time 
error estimate cases assumption objects relative motion glide rotation completely correct 
justify glide rotations arguments 
see arguments glide rotations intermediate motion 
assumption motion glide rotation priori worse assumptions 
think better assumption object rotate axis assumption incorrect physically moving bodies general rotate fixed axis 
second glide rotations nice properties constancy forward facing surfaces fact forward facing portion polygonal face polygon 
reasons algorithm described sections requires glide rotations 
third error introduced glide rotations turns quite small 
estimate error refer point moves position position rotating origin 
compare circular path straight line path 
instance moving point center mass object rotating translating correct path line segment glide rotation predict circular arc total rotation angle maximum distance circular arc line segment length short dotted line estimated error bound rotation angle 
cos distance rotation center 
arc length estimate error terms ratio maximum distance arc length 
percentage error estimated cos 
sample percentage error values table 
equation applies measured radians table uses degrees 
angle error angle error shown table rotation gives estimated error error level may quite acceptable low accuracy applications computer games 
event rotation quite large single step simulation frequently rotations clamped simulation step general principle large rotations step yield unstable unreliable results physical simulations 
rotation simulation step gives error estimate just 
conclude glide rotations give quite acceptable accuracy applications 
applications wish limit collision detection algorithm situations total rotation applications require high levels accuracy noted absolute error compared percent error decreases quadratically simulation step size 
types collisions working modeled surfaces collisions categorized face face ff face edge fe face vertex fv edge edge ee edge vert ev vert vert vv type colliding facets 
di erent applications want di erent types collisions 
instance edge colliding parallel interior face viewed ef edge face collision vf vertex face collisions vertices endpoints edge 
example physical simulations ectively vv collisions normal vector describing direction collision usually required determine collision response vv collision uniquely determined collision normal 
collision detection algorithm finds collisions types resolves collisions vertices faces types vf fv edge edges type ee 
collision computes time collision spatial position vertex edges face involved collision normal vector collision direction measure collision 
local condition measures extent collision involves facets locally facing 
fv collision face body vertex body normal unit normal pointing outward vertex degree 
unit vectors pointing adjacent edges 
order collision locally proper sense body outside body necessary 
define collision minimum values min 
value nonnegative vertex colliding face outside side 
negative values indicate edges face time collision case collision called improper 
value negative close zero collision slightly improper 
ee collision vectors colliding edges 
collision normal unit vector direction sign intended chosen point body body 
normals faces adjacent edge define nb nb similarly 
value collision min nb nb 
common kinds collisions viewed fundamental see instance 
sign direction determined picking sign maximizes 
value nonnegative edges adjacent faces properly oriented locally facing collision 
collision detection algorithm finds collisions stages 
identifies vv ev ee vf fv collisions 
resolved vf fv ee collisions 
ev resp collisions resolved fv resp vf collisions choosing faces adjacent edge collision face yields largest value 
vv collision resolved fv vf collision algorithm considers possible collision vertices faces adjacent vertex chooses vertex face pair maximizes value 
overview algorithms give high level description collision detection algorithms glide rotation 
input algorithm rigid objects specified modeled surfaces initial final positions 
modeled surfaces stored winged edge structure similar data structure permits easy access adjacency information list edges adjacent vertex pair faces adjacent edge 
compute glide rotation associated flow corresponds relative motion bodies 
backward facing faces forward facing faces 
faces edges vertices candidates collisions natural idea design algorithm consider pairs facets faces edges vertices object facets object decide collide 
fast avoid computation time space partitioning 
couple drawbacks 
motion may considerable facet may move cells large region space space partitioning may ciently 
second performing collision detection pair facets independently possible errors lead collisions completely missed 
di erent method exploits adjacency information 
collision detection works projecting facets collision screen lies perpendicular glide rotation motion 
screen nonconvex objects moving horizontally moving leftward rightward speed 
vertical collision screen set left 
horizontal axis measures time point hit screen 
subtracting times points gives twice time collide 
instance hit screen time hit screen time units past 
points collide time 
hand collide motion appear collided time units past 
points facets calculate elapsed time points hit screen 
point point project point screen di erence elapsed times gives twice collision time 
intuition shown greatly simplified 
collision screen behaved flat screen simple spiral screen kind tilted surface points fixed radius glide axis screen proper spiral 
collision detection works drawing facets collision screen 
draws superimposed screen 
vertices projected points screen edges projected curves screen 
faces project regions screen bounded curves 
edges project curves straight lines algorithm approximates projected edges series straight line segments closely match curve 
projections edges intersect potential edge edge ee collision likewise projection vertex resp 
lies projection face resp 
potential vf resp 
fv collision 
point point project common point screen potential vv collision 
vertex body projects projection edge body potential ev collision 
potential collision find preimages collision objects view transformed glide rotation transformed negative glide rotation flow calculate times required point point reach screen 
half di erence times gives collision time potential collision 
collisions times interval preserved potential collisions 
algorithm checks potential collision 
collisions improper reported algorithm 
section presents formulas projecting facets collision screen 
version algorithm implemented uses screen consists pixels hold information facets project pixel 
approach backward resp forward facing vertex body resp 
projected pixel screen appropriately facing edge drawn pixels screen 
pixel may hold information multiple vertices edges 
pixels holding edge information hold information adjacent faces information detect vertex pixels potentially collide faces 
pixel approach possibilities 
instance alternate method treat projection vertices actual points projections edges curves approximated straight line segments techniques determine faces intersected vertices body edges body intersect edges body 
method quite fast little prone errors causing discrepancies interpenetration status simulation step 
interesting see fleshed implemented done 
pixel algorithm described fully sections 
projection collision screen collision screen spirals glide rotation axis somewhat complicated way 
points collision screen indexed pairs 
value radius point distance point glide rotation axis 
fixed value value stands height measures distances spiral perpendicular velocity flow points radius orient collision screen geometry screen coordinate collision time points distance glide axis 
axis points usual axis points axis axis 
point projected right angles lie axes 
contains positive axis points positive axis 
point bodies calculate coordinates collision screen elapsed time required point impact collision screen carried glide rotation flow 
shows geometry calculation 
distance glide axis 
second arctan angle point lies relative axis 
express position cylindrical coordinates 
fixed value unwrap cylinder radius plane axes shown 
vector shows motion point glide rotation unit period time 
time axis axis contains 
axis defined perpendicular flow 
note slope axis slope axis depends 
point projected orthogonally axes 
coordinate equal distance coordinate equal 
argument similar triangles shows coordinates summarize coordinates collision screen calculated computing formulas compute sign chosen time takes point screen reach default interval discussed section needs outside range 
point lies glide rotation axis value undefined 
formulas points 
projection simpler case glide rotation just translation 
construction just perform orthogonal projection collision screen 
case simplified fact straight edges project straight lines screen 
ing recall variable total rotation glide rotation cylindrical coordinates points arctan 
example suppose consider point object value equal value point increases point potentially collide points stationary object value problematic example point may collide points value problem point value greater example default projected collision screen di erent choices general project point di erent point collision screen give di erent collision time hand just points 
point potentially collide points 
point projected twice collision screen general values returning radians point object value interval point projected twice collision screen 
works long 
event usually order control glide rotation error section point twice polygon abcd replaced polygons 
projected call point 
discuss section collision detection algorithm works projecting polygonal face objects collision screen 
project polygonal face project series edges 
projecting face body check points need 
face edges modified appropriately properly portions edges 
cases consider main ones shown figures 
polygonal face contains points need intersect glide axis 
shows top view looking glide axis polygon seen intersect line line 
polygon split adding new vertices vertices value vertices 
single polygon split polygons projected collision screen 
shows polygon abcd intersects glide rotation axis contains points need 
polygon create new vertices point polygon intersects glide rotation axis usually 
polygon abcd replaced polygon edges polygon self overlapping region collision screen values start monotonically decrease point value lies glide rotation axis 
situation similar projecting body slightly simpler points need 
need take polygon abcd replaced polygon care edges cross boundary 
projecting body exactly algorithm projecting body set equal zero 
example situation body replaced zero points correspond point edge 
pixel algorithm implementation outline pixel algorithm implemented 
input algorithm includes initial final positions orientations addition modeled bodies data structure allows quick lookup adjacency information vertices edges faces 
supplied bounding spheres step 
desired resolution collision screen specified 
resolution specified terms distance pixels values discretized resolution resolution time 
step algorithm determine glide rotation parameters describe relative motion objects see section 
choose coordinate system axis glide rotation axis 
origin coordinate system chosen bounding spheres objects lie close xz plane possible 
bounding spheres attempt place axis needed 
quick reject test bounding spheres bound maximum minimum values points check collision possible 
algorithm halts reporting collisions 
compute save initial vertex positions edge directions face normals coordinate system order save re computation 
second step clips edges forward resp backward faces resp considered 
clipping done separately face face clipped non trivial way edges clipped 
edge faces means edge potentially split segments 
step information recorded edge 
split edge segments 
addition type shown face may need 
note creates new edges called virtual edges edges gh ef ge fg 
result second step list clipped edges original object edges sub edges generated clipping 
sub edge store information original edge edge virtual identity left right faces forward facing 
sub edges resp adjacent forward resp backwards facing edge discarded 
third step project sub edges pixels collision screen space generating list pixel records 
edge considered separately 
find values edges endpoints time endpoints contact collision screen described section 
divide conquer scheme projects edge curve formed pixels collision screen 
done projecting midpoint edge collision screen recursively considering second halves edge 
divide conquer assumes positional accuracy projecting pixel screen needs better pixel size likewise time value need accurate time resolution input value 
accuracies achieved rest projected edge filled algorithm 
successive pixels edge project value combined single pixel record 
projected pixel record contains value maximum minimum values min hmax time value addition pixel record holds information edge comes left right adjacent appropriately facing faces pixel important edges hit collision screen somewhat perpendicularly range values pixel substantial projection vertex body 
aid steps store redundant information pixel including information slope direction projection edge point 
fourth step pixels sorted lexicographically value second shell sorted min value 
copy pixel arrays re sort copy sorted lexicographically hmax pixels body body kept separate 
create list pixels vertices pixels vertices sorted fifth step finds places vertex body projects interior projection face body value scan list order increasing values pixels vertices ii pixel records sorted min iii pixel records sorted hmax pixel records type ii tell projection face entered pixel records type iii tell projection face exited 
encounter pixels type vertices note list vertex potentially colliding currently entered faces process repeated roles reversed 
sixth step looks places collision screen projection edge crosses intersects projection edge scan pixel records lexicographically letting range minimum maximum value scanning pixel records bodies order increasing values 
time pixel non virtual edges cross store information potential intersection 
small hash table contains information edge edge ee collision 
edges pixels time information computed third step pair edges intersects multiple pixels say edges coincide series pixels pixel time potential collision minimized 
ee collisions involve endpoints 
stored ev vv collisions appropriate 
hash table store avoid considering multiple occurrences collision 
fifth sixth steps extracted potential ee vv ev fv vf collisions 
final steps resolved ee fv vf collisions discussed section 
collisions value necessary consider ee collisions virtual edges virtual edges collide 
threshold discarded application determine threshold threshold works driving game applications 
collisions edges information values collision obtained pixel records ado 
collisions vertices faces position vertex course known 
collision resolved ev ee collision pixel records give collision time 
collision vf fv vertex colliding interior face pixel screen collision time obtained just pixel record 
iterative newton method find point face projects position collision screen vertex projected collision time easily calculated 
convexity considerations prove newton method fast guaranteed convergence correct answer 
algorithm returns list potential ee fv vf collisions 
collision record contains information edges vertex face collided time collision spatial position normal vector collision 
run times tested algorithm described shapes including cubes simple modeled car shown torus composed rectangular faces edges 
run time comparisons sensitive details implementations execution environment useful report typical run times 
report runtimes resolutions collision screen pixels lowest resolution length typical short edge projected sideways collision screen approximately pixels 
medium resolution length approximately pixels 
high resolution length approximately pixels 
approximate runtimes microseconds reported table tests performed ghz pentium iv 
line cube colliding cube second line car versus car third line colliding complex tori 
low res medium res high res cubes cars tori clearly direct tradeo runtime algorithm resolution accuracy 
low resolution collisions qualitatively quite close look show collisions approximate 
general fixed resolution runtime expected approximately log part algorithm projects edges vertices pixels collision screen sorts pixels values sorting records takes time log 
rest algorithm expected take time approximately number pairs facets project pixel screen 
worst case unavoidable collisions need reported 
runtime potentially reduced significantly modified algorithm sorted pixels time addition change allow algorithm highly non convex objects instance screws threads screw hole 
di cult runtime comparisons published algorithms bulk extensive hierarchical methods cull collision testing numbers full collision test 
fair comparison runtime mentioned algorithms angel studios 
able crude approximate comparisons algorithm appears close speed angel studios algorithms slightly slower 
add angel studios algorithms greatly optimized period years implementation fairly preliminary better implementations improve algorithm speed faster 
importantly new algorithm handles rotation properly gives higher quality results robust results works situations 
compare runtimes algorithms 
algorithms solve penetration depth problem non convex bodies assumption unknown purely translational motion 
colliding tori report times seconds seconds ghz pentium geforce hardware acceleration depending tori interlocked 
specify tori designed tori apparently polygonal complexity similar faces runtimes nearly orders double precision floating point single precision su ce 
simple polygonal model car vertices edges faces 
magnitude faster particularly sensitive tori interlocked 
comparison completely fair seeking unknown translational amount algorithm works known motion glide rotation 
examples figures show screen shots collision detection tori 
initial final positions tori shown part 
point view torus middle object torus object moved completely glide rotation screw motion shown black curves 
torus moved di cult see figures moved considerable distance away viewer 
collision shown 
top front collided bottom front 
front meant part distant viewer front meant part closest viewer 
part second collision shown 
left top part collided bottom part part third collision occurs 
collision right portion front collided back inside collisions proper collisions occur shows tori drawn form collision screen 
collision algorithm ect projects tori form overlays drawings finds points intersection overlaid drawings 
tori colliding 
torus moving away upward 
torus stationary 
described robust algorithm collision detection gives approximate results 
algorithm reports potential collisions bodies period time 
robustness means algorithm confused bodies colliding 
mean algorithm may report collision fact bodies approached closely rarely valid collisions bodies just barely missed care algorithm designed course multiple simulation steps rigid bodies reported collision 
di culty robustness part bodies approach closely slightly generating collision simulation step glide rotation motion may completely changed bodies may appear moving way collision occurring projections tori collision screen 
horizontal axis axis vertical axis axis 
occurred 
collision detection completely robust algorithm modified find collisions facets approach pixel resolution 
relatively simple change step algorithm increase runtime modestly mean pixel resolution need finer trigger collisions bodies collided 
collision detection algorithm intended component larger collision detection system 
best suited applications tolerate small amount error applications require high speeds computer games 
front accurate collision detection system say collision detection method detect approximate information collision higher quality detection method find collision exactly 
expect algorithms improved extended ways 
alternative implementations algorithm described give faster implementation 
possibility mentioned section 
mention hash table hold pixels projected screen detect places edges intersect cross sorting sequentially scanning 
second noted algorithm extended handle highly non convex objects screw fitting screw hole sorting pixels time 
third interesting extend algorithm rigid shapes say spheres cylinders kind robustness important applications particular objects static contact frequently touching barely 
generally quadrics 
natural question algorithm lends implementation graphics hardware 
graphics hardware acceleration successfully motion planning generally computation voronoi diagrams see 
algorithm appear di cult adapt graphics hardware multiple points may projected pixel collision screen development sophisticated algorithms graphics chips allows hope graphics chips accelerate collision detection algorithm 
agarwal guibas har peled sharir penetration depth convex polytopes nordic computing pp 

baraff fast contact force computation rigid bodies computer graphics pp 

proc 
siggraph 
rigid body simulation ii 
siggraph course notes 
polyhedral representation computer vision proc 
afips natl 
computer conf vol 
pp 

interference detection solids surfaces communications acm pp 

cameron study clash detection problem robotics proc 
ieee international conf 
robotics automation pp 

collision detection dimensional intersection testing ieee transaction robotics animation pp 

enhancing gjk computing minimum penetration distances convex polyhedra proc 
ieee international conf 
robotics automation pp 

canny collision detection moving polyhedra ieee transactions pattern analysis machine intelligence pp 

chatterjee new algebraic rigid body collision law impulse space considerations journal applied mechanics pp 

dobkin hershberger kirkpatrick suri computing intersection depth polyhedra algorithmica pp 

dobkin kirkpatrick determining separation preprocessed polyhedra unified approach proc 
th international colloquium automata languages programming icalp lecture notes computer science springer verlag pp 

lin accelerated proximity queries convex polyhedra multi level voronoi marching proc 
international conf 
intelligent robots systems pp 

accurate fast proximity queries polyhedra convex surface decomposition computer graphics forum pp 

proc 
eurographics 
guibas stolfi zhang collision detection convex objects proc 
acm siam symp 
discrete algorithms soda pp 

bradshaw sullivan complementarity multiple point collision resolution prof fourth irish workshop computer graphics eurographics ireland pp 

gilbert johnson keerthi fast procedure computing distance objects dimensional space ieee robotics automation ra pp 

goldstein classical mechanics addison wesley 
gottschalk lin manocha obbtree hierarchical structure rapid interference detection proc 
acm siggraph new york acm press pp 

herzen barr geometric collisions time dependent parametric surfaces computer graphics pp 

siggraph 
hoff iii lin manocha fast computation generalized voronoi diagrams graphics hardware computer graphics pp 

acm siggraph 
hubbard collision detection interactive graphics applications ieee transactions visualization computer graphics pp 

kim rossignac collision prediction polyhedra screw motions proc 
th acm symp 
solid modeling applications pp 

kim lin manocha deep dual space expansion estimating penetration depth convex polytopes proc 
ieee international conf 
robotics automation 
kim lin fast penetration depth computation physically animation acm transactions graphics pp 

siggraph 
kirkpatrick optimal search planar subdivision siam computing pp 

kirkpatrick snoeyink kinetic collision detection simple polygons international computational geometry pp 

kirkpatrick kinetic maintenance context sensitive representations disjoint simple polygons proc 
st acm symp 
computational geometry pp 

klosowski held mitchell cient collision detection bounding volumes dops ieee transactions visualization computer graphics pp 

reichert donald greenberg real time robot motion planning computer graphics hardware computer graphics pp 

siggraph 
sch omer framework collision detection response proc 
th european simulation symposium exhibition ess pp 

lin collision detection animation robotics phd thesis berkeley 
lin canny cient algorithms incremental distance computation proc 
ieee international conference robotics automation pp 

lin gottschalk collision detection geometric models survey proc 
ima conf 
mathematics surfaces pp 

manocha interactive geometric computations graphics hardware 
siggraph course notes 
mirtich clip fast robust polyhedral collision detection acm transactions graphics pp 

rigid body simulation proc 
acm siggraph pp 

purcell buck mark hanrahan ray tracing programmable graphics hardware acm transactions graphics pp 

siggraph 
redon coquillart algebraic solution problem collision detection rigid polyhedral objects proc 
ieee international conference robotics automation vol 
pp 

contact arbitrary motions collision detection proc 
th ieee international workshop robot human interactive communication roman pp 

fast continuous collision detection rigid bodies computer graphics forum 
proc 
eurographics 
gauss constraints principle rigid body simulation proc 
ieee international conference robotics automation vol 
pp 

back face culling collision detection proc 
ieee rsj international conference intelligent robots systems vol 
pp 

rossignac kim computing visualizing motions computer aided design pp 

sch omer thiel cient collision detection moving polyhedra proc 
th annual acm symp 
computational geometry pp 

geometrical methods robotics springer verlag new york 
shepperd quaternion rotation matrix journal guidance control pp 

shoemake animating rotation quaternion curves computer graphics pp 

siggraph 
snyder woodbury fleischer barr interval methods multi point collisions timedependent curved surfaces computer graphics pp 

siggraph 
van cek jr back face culling applied collision detection polyhedra journal visualization computer animation pp 


