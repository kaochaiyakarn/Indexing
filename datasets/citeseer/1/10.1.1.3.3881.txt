geometric surface processing normal maps ross whitaker paul stanley osher univ utah univ utah ucla ucla cs utah edu whitaker cs utah edu com math ucla edu uucs submitted siggraph review research 
school computing university utah salt lake city ut usa january generalization signal image processing surfaces entails filtering normals surface filtering positions points mesh 
variational framework smooth surfaces minimize norm derivative surface normals total curvature 
penalty functions surface normals computed shape metrics minimized gradient descent 
produces set partial differential equations pde 
introduce novel framework implementing geometric processing tools surfaces step algorithm operating normal map surface ii manipulating surface fit processed normals 
computational approach uses level set surface models processing depend underlying parameterization 
iterating step process implement geometric fourth order flows efficiently solving set coupled second order pdes 
demonstrate framework provides wide range surface processing operations including edge preserving smoothing high boost filtering 
furthermore generality implementation appropriate complex surface models constructed directly measured data 
chapter fundamental principles signal processing give rise wide range useful tools manipulating transforming signals images 
generalization principles processing surfaces important problem computer graphics visualization vision 
instance range sensing technologies produce high resolution descriptions objects suffer noise 
medical imaging modalities mri ct scans produce large volumes scalar tensor measurements surfaces interest extracted segmentation process fitted directly measurements 
state art surface processing includes number useful tools processing meshes 
date general framework geometric surface processing 
general mean things 
framework provide broad variety capabilities including surface processing tools resemble state art image processing algorithms 
second framework apply general class surfaces 
users able process complex surfaces arbitrary topology obtain meaningful results little priori knowledge shapes 
geometric mean output surface processing algorithms depend surface shape resolution independent arbitrary decisions representation parameterization 
presents framework proposition natural generalization image processing surfaces surface normal vectors 
smooth surface smoothly varying normals 
light differences surface processing image processing threefold 
normals live manifold surface necessarily processed flat metric typically done surface processing examples 
images 
normals vector valued constrained unit length processing techniques accommodate 
normals coupled surface shape normals drag surface values modified processing 
presents implementation represents surfaces level sets volumes computes processing normals deformation surfaces solutions set partial differential equations pde 
strategy enables achieve black box behavior reflected nature results 
results show level complexity models processing algorithms demonstrated literature 
generality comes cost significant computation time 
method practical state art computers poised benefit parallel computing architectures due reliance local iterative computations 
shows results processing surface model different algorithms 
algorithms consist smoothing feature preserving smoothing surface enhancement 
processes consistent mathematical generalizations counterparts 
note surfaces represented rendered marching cubes algorithm 
applications animation models manually generated designer parameterization arbitrary important aspect geometric model 
cases mesh processing methods offer powerful set tools hierarchical editing possible proposed representation 
applications segmentation surface reconstruction pro cessing data driven surfaces deform quite far initial shapes change topology 
furthermore considering processes isotropic smoothing nonlinear smoothing high boost filtering creation sharpening small features exhibit noticeable effects mesh topology features aligned mesh treated differently 
techniques offer new set capabilities especially interesting processing measured data examples show 
specific contributions novel framework geometric processing surfaces relies surface normals numerical method solving fourth order level set equations simpler steps avoiding explicit computation unstable high order derivatives examples geometric processing algorithms applications data sets complex previously demonstrated literature 
chapter related majority surface processing research context surface fairing motivation smoothing surface models create aesthetically pleasing surfaces triangulated meshes :10.1.1.21.1887
surface fairing typically operate minimizing fairness penalty function favors smooth surfaces :10.1.1.34.215
fairness functionals depend geometry surface parameterization 
geometric functionals invariants principal curvatures parameterization independent intrinsic properties surface 
geometric approaches produce results affected arbitrary decisions parameterization geometric invariants nonlinear functions surface derivatives computationally expensive evaluate 
simpler parameterization dependent functionals linear approximations geometric invariants 
functionals equivalent geometric invariants surface parameterization isometric poor approximations parameterization irregular non differentiable 
isometric surface parameterization requires parameter coordinate axis orthogonal arc length parameterized 
context surface fairing meshes concepts referred geometric parameterization smoothness outer inner fairness 
way smooth surface incrementally reduce surface area 
accomplished mean curvature flow mcf point mean curvature surface surface normal time evolution surface shape 
parameterized surfaces surface area translates membrane energy functional du dv surface parameterization domain respectively 
isometric parameterization reduces surface area 
larger smaller approximation surface area distorted proportionally 
variational derivative laplacian dx uu vv equivalent mean curvature isometric case 
laplacian mean curvature flow closely tied gaussian filtering standard method smoothing images 
propose meshed intrinsic flow incorporates weighted sum principle curvatures depends local surface shape :10.1.1.10.97
second order penalty function total curvature ds shown deform surfaces spheres 
total curvature geometric invariant property surface 
mesh fairing approach minimizes involves fitting local polynomial basis functions local neighborhoods computation total curvature 
polynomial basis functions range full quadratic polynomials constrained planar approximations 
depending complexity local neighborhood algorithm choose location basis employ 
ambiguities result locations multiple basis provide equally representations 
authors search directly intrinsic pde produces fair surfaces deriving pdes variational framework 
propose laplacian mean curvature meshes laplace beltrami operator laplacian parameterized surfaces 
approach sufficiently general satisfy goals closely related proposed method 
discuss sec 

penalize parameterization non geometric equation thin plate energy functional uu uv vv du dv defined 
thin plate energy surface fairing :10.1.1.34.215
variational derivative operator linear linear energy functionals underly signal processing approach surface fairing pioneered derived natural vibration frequencies surface laplacian operator :10.1.1.21.1887
taubin observes gaussian filtering causes shrinkage 
eliminates problem designing low pass filter weighted average laplacian operator 
weights fine tuned obtain non shrinking property 
analyzed frequency domain low pass filter seen gaussian smoothing shrinking step followed step 
polynomial transfer function frequency domain implemented method 
describe related approach surface smoothed simultaneously solving membrane thin plate energy functionals 
signal processing approach uses umbrella operator discretization laplacian 
edge lengths connecting nodes mesh angles adjacent edges node known face angles introduce parameterization dependencies 
setting edge weights umbrella operator reciprocal edge length dependency edge length removed dependency face angles remain :10.1.1.21.1887
scale dependent intrinsic umbrella operator defined removes dependencies 
time steps explicitly integrating scale dependent umbrella operator proportional square shortest edge length 
desbrun overcome limitation introducing implicit integration scheme 
weights umbrella operator recomputed iteration maintain intrinsic property 
non uniform relaxation operator introduced minimize locally weighted quadratic energy second order differences 
sequin propose geometric fairness functional penalizes variation principle curvatures third order geometric penalty function corresponding sixth order variational derivative requires large computation times 
analysis implementation general penalty functions second order remains open problem scope 
evidence suggests fourth order geometric flows form sufficient foundation general geometric surface processing system 
related chopp sethian derive intrinsic laplacian curvature implicit curve solve resulting fourth order nonlinear pde argue numerical methods solve second order flows practical lack long term stability 
propose new numerical schemes completely satisfactory due slow computation inability handle singularities 
results solve equation effectively demonstrate example general class useful surface processing techniques 
joint interpolation vector fields gray level functions succesfully filling missing parts images 
chapter geometric surface processing underlying strategies geometric surface processing output process depends shape input surface contain artifacts underlying parameterization 
motivation strategy discussed detail influence mesh parameterization surface fairing results clearly shown higher order geometric flows intrinsic laplacian curvature proposed solution 
illustration importance higher order geometric processing consider results fig 
demonstrates differences processing surfaces mean curvature flow mcf intrinsic laplacian mean curvature flow 
amount smoothing mcf chosen qualitatively similar important differences observed smaller features original model 
mcf shortened horns original model remain sharp desirable behavior smoothing process 
behavior mcf documented cylindrical objects expected variational point view mcf minimizes surface area quickly eliminate smaller parts model 
authors proposed volume preserving forms second order flows processes compensate enlarging object exhibits qualitatively behavior small features 
intrinsic laplacian mean curvature flow fig 
preserves structure features better smoothing 
alternative solving fourth order equation directly decouple pair second order equations 
instance step solution meshes proposed 
approach works meshes relies analytic properties steady state solutions dh fitting surface primitives properties 
second fourth order surface smoothing 
left right original model mean curvature flow intrinsic laplacian mean curvature flow 
shown process begins shape constructs normal map distance transform left modifies normal map pde derived penalty function center re fits shape normal map right 
formalism generalize applications surface reconstruction solution combination measured data fourth order smoothing term 
apply types smoothing processes minimize nonlinear feature preserving penalties 
authors penalize smoothness vector field simultaneously forcing gradient directions gray scale image closely match vector field 
penalty function normal field proportional divergence normal vectors 
forms high order interpolation function shown useful image inpainting recovering missing patches data images 
strategy simultaneously penalizing divergence normal field mismatch field image gradient closely related total curvature penalty function 
formulation proposed emphasizes processing normals arbitrary surface manifold flat geometry image explicit relationship fourth order surface flows 
furthermore establishes new directions surface flows edge preserving surface smoothing feature enhancement 
dg dn dd df flow chart section generalize intrinsic laplacian mean curvature level set surfaces introduce method breaking simpler pdes 
pair equations solved allowing surface shape lag normals filtered catch separate process 
shows step process graphically shapes give rise normal maps filtered give rise new shapes 
limit approach equivalent solving full blown intrinsic fourth order flow generalizes wide range processes assumptions shapes solutions 
sec 
show results different kinds surface filters 
appendix describes numerically stable discrete solver system equations 
level set methods remainder addresses higher order geometry implicit surfaces level sets 
surface fairing results obtained meshes drawbacks meshes parametric models purposes simple smoothing low pass filtering 
believe level set methods better suited wide range surface processing reasons 

surface processes anisotropic diffusion high boost filtering capability introducing new features fundamental difference smoothing 
meshes form discontinuities edges face triangles coincide edges surface 

modest amount smoothing evolve surface far original shape 
requires creation deletion faces meshes maintain original resolution 
implicit surfaces exhibit problem 

surface reconstruction range imagery tomographic data evolving surface undergo topological changes 
surface meshes readily allow topological changes level set surfaces 
facilitate discussion einstein notation convention subscripts indicate tensor indices repeated subscripts product represent summation index dimensions underlying space 
furthermore convention subscripts quantities represent derivatives parenthesis case refer vector valued variable 
gradient vector scalar quantity ir 
ir 
hessian laplacian ii vector field ir 
ir divergence field scalar operators differentials behave usual way 
gradient magnitude jf differential coordinate system dx dx dx dx level set surface models rely notion regular surface collection points topology allows point modeled locally function variables 
describe deformation surface velocity constituent points represent surface implicitly time notice surfaces defined way divide volume parts inside outside 
common choose signed distance transform approximation thereof 
surface remains level set time total derivative respect time chain rule gives notice proportional surface normal affects direction surface normal surface motion direction merely change parameterization 
framework pde describes motion surface mean curvature ii sections give mathematical description process outlined fig 

derive energy functional minimizing total curvature normal map 
variation total curvature results second order pde normals 
process denoted fig 
dg dn loop 
sec 
show energy functional fitting surface evolved normal map resulting secondorder pde dd df loop fig 

show process simultaneously solving pdes shown fig 
equivalent 
establishes mathematical foundation proposed method 
intrinsic laplacian mean curvature flow normal maps implicit representations account fact derivatives functions defined surface computed projecting derivatives tangent plane surface 
ir normal map field normals perpendicular family embedded isosurfaces projection matrix implicit surface normal returns projection identity matrix 
projection plane perpendicular vector field tangent projection operator normal circumstances normal map derived gradient projects vectors tangent planes level sets computational strategy proposing allows lag normal map 
tangent projection operators differ denote projections tangent planes level sets denote projections planes perpendicular normal map 
shape matrix surface describes curvature independent parameterization 
shape matrix implicit surface obtained differentiating normal map projecting derivative tangent plane surface 
euclidean norm shape matrix total curvature jk derived directly gives il jk strategy treat expressions penalty functions develop surface processing methods solving pdes result variation surface integrals penalty functions 
notice take variation obtain fourth order pde take variation respect allowing remain fixed obtain second order pde see variation re express norm identity jjajj trace 
gives penalty function total surface curvature dx process normal map letting lag ensure maintains unit length constraint 
expressed penalty function lagrange multipliers 
constrained penalty dx lagrange multiplier variation solving introduces projection operator variation keeps unit length 
variation respect dg dn gradient descent metric dg dn results pde smoothes normal map minimizing total curvature maintaining unit normal constraint 
notice precisely solving constrained diffusion equation method solving pdes implicit manifolds described 
derivation consider base case subsequent sections introduce processes normal maps 
surface evolution normal maps shown evolve normals minimize total squared curvature final goal reconstruction surface requires evolving normal map 
step relate evolution evolution suppose normal map set surfaces necessarily level sets case filter lag 
manipulate catches minimizing penalty function quantifies discrepancy 
penalty function dx ir domain gradient descent minimizes penalty function dd df jjf jj jf mean curvature level set surface induced curvature normal map 
surface moves difference curvature normal field 
factor jf typical level set formulations comes fact manipulating shape level set embedded 
propose solve fourth order flows level sets splitting strategy entails processing normals allowing lag catch separate process 
correct know limit lag small solving full fourth order pde show analyze iteration main loop fig 

processing normals derived evolving normal map small amount time dt gives dg dn dt immediately apply fit new normal map ij dg dn dt derived directly gives expression changes order infinitesimal lag dg dn express penalty function terms take variation respect quantities 
relationship dg dn dg df established integrating parts dg df dg dn dt 
update lags small amount dg df gradient descent level sets total curvature surface 
analysis shows strategy depicted figs 
valid mechanism implementing base case implicit level set surfaces 
strategy broader implications 
sec 
show choices options image processing literature produce different kinds surface processing algorithms 
furthermore sec 
demonstrate general strategy processing normals separately surfaces phase process offers set useful tools go strict variational framework 
chapter applications isotropic diffusion discussed detail sec 

results diffusion process 
shows model various stages diffusion process 
iterations main processing loop fig 
remove smallest scale features model 
iterations start smoothing global shape model 
model shown example consists volume 
computation time required iteration main processing loop model minutes ghz intel processor 
models examples rest approximately level complexity 
anisotropic diffusion minimizing total squared curvature surface works smoothing surfaces eliminating noise deforms removes important features 
type smoothing called isotropic corresponds solving heat equation normal map constant scalar conduction coefficient 
equivalent convolution surface normals gaussian kernel isotropic metric flat surface 
isotropic diffusion particularly effective goal de noise surface underlying structure fine features 
scenario common extracting surfaces imaging modalities magnetic resonance imaging mri various stages isotropic diffusion original model iterations iterations iterations 
measurements inherently noisy 
example skin surface extracted mri data set 
notice roughness skin noise artifact measurement process 
model quite complex despite best efforts avoid isosurfaces include convoluted passages neck 
indication complexity consider marching cubes produces triangles volume 
times number faces standard models demonstrate surface processing algorithms 
strategy treat surfaces measured volumetric representation process data indirectly simplified fitted surface mesh 
isotropic diffusion shown fig 
marginally effective de noising head surface 
notice sharp edges eyes nose lips ears lost process 
problem preserving features smoothing away noise studied extensively computer vision 
anisotropic diffusion introduced successful dealing problem wide range images 
perona malik proposed replace laplacian smoothing equivalent heat equation 
nonlinear pde 
generally grey level image 
edge stopping function decreasing sigmoidal function 
perona malik suggested jij positive free parameter controls level contrast edges affect smoothing process 
notice approaches edges generally associated large image gradients diffusion edges stopped regions relatively flat undergo smoothing 
mathematical analysis shows solutions exhibit inverse diffusion near edges enhance sharpen smooth edges gradients greater 
anisotropic diffusion surface processing meshes proposed :10.1.1.10.97
authors move surface weighted sum principle curvatures weighting depends surface geometry 
variational formulation generalization 
performs convex re weighting principle curvatures reduce smoothing exhibit sharpening features 
furthermore level set implementation proposing allows produce results significantly complex surface shapes 
generalization anisotropic diffusion surfaces achieved variational principles minimizing penalty function dx processing results mri head model original isosurface isotropic diffusion surface normals anisotropic diffusion surface normals 
small protrusion nose physical marker registration 
computed 
variation respect surface normals gives gives vector valued anisotropic diffusion level set surface straightforward generalization 
take variation respect obtain fourth order pde modified version preserves enhances areas high curvature call creases 
creases generalization edges surfaces 
solve variational problem solving second order pde normals framework introduced sec 

strategy fig 
replace dg dn variation penalty function 
gives dg dn total curvature edge stopping function rest process shown fig 
remains unchanged 
de noising measurement data important applications anisotropic diffusion 
differences anisotropic diffusion isotropic diffusion clearly observed fig 

smooth areas original model forehead cheeks noticeable difference results processes 
significant differences exist lips eyes 
creases areas eliminated isotropic diffusion preserved anisotropic process 
running anisotropic diffusion time steps produces surfaces piecewise smooth normals analogous behavior perona malik equation images corresponds smooth planar surface patches bounded sharp creases 
shows evolution dragon model anisotropic diffusion 
iterations loop fig 
smallest details scales dragon skin disappear fig 

iterations fig 
finest details face spikes ridge back suppressed 
going observe surface starting polyhedral fig 

non linear progression elimination details smallest scale largest fig 
suggests possibility improved surface compression strategies details desired scale kept effectively unchanged 
sharp contrast isotropic diffusion mean curvature flow distorts features generates sharp discontinuities features disappear 
various stages anisotropic diffusion original model iterations iterations iterations 
enhanced surface iterations high boost filtering 
results support proposition processing normals surface natural generalization image processing 
processing normals surface processing vector valued image color image distance metric varies domain 
contrast processing points surface directly lower order flows offers clear analogy methods established image processing 
high boost filtering surface processing framework introduced sec 
flexible allows implementation general image processing methods 
demonstrate describing generalize image enhancement high boost filtering surfaces 
high boost filter frequency transform amplifies high frequency components 
image processing achieved masking 
low pass filtered version image high frequency components high boost output sum input image fraction high frequency components positive constant controls amount high boost filtering 
algorithm applies surface normals simple modification flow chart fig 

recall dg dn loop produces define new set normal vectors jj jj new normal map input dd df catch loop 
effect extrapolate previous set normals direction opposite set normals obtained isotropic diffusion 
recall isotropic diffusion smooth areas high curvature significantly affect smooth areas 
processing loop modification effect increasing curvature areas high curvature leaving smooth areas relatively unchanged 
able obtain high quality surface enhancement fairly complex surfaces arbitrary topology figs 

effects high boost filtering observed comparing original dragon model fig 
high boost filtered model fig 

scales skin ridge back enhanced 
note different amounts enhancement achieved controlling number iterations main loop 
degree low pass filtering obtain controls size features enhanced 
shows example high boost filtering notice enhancement features particularly wings 
high boost filtering original model filtering close original filtered model 
chapter natural generalization image processing surfaces normals 
variational processes surface corresponding variational formulations surface normals 
generalization image processing surface normals requires process normals metric surface manifold simple flat metric images 
framework diffusion surface normals corresponding motions surface equivalent particular fourth order flow intrinsic laplacian mean curvature 
processing normals separately solve pair coupled second order equations order equation 
typically allow equation surface lag lag gets small matter 
solve equations implicit surfaces representing implicit function discrete grid modeling deformation method level sets 
level set implementation allows separate shape model processing mechanism 
method generalizes virtually wish normal map 
generalization anisotropic diffusion constrained vector valued function defined manifold gives smoothing process preserves creases 
want enhance surface enhance normals allow surface catch 
implementation method applies equally surface represented volume 
consequently results show level surface complexity goes previous methods 
study usefulness interesting image processing techniques total variation local contrast enhancement 
date dealt post processing surfaces combine method segmentation re construction techniques 
current shortcoming method computation time significant 
process lends parallelism advent cheap specialized vector processing hardware promises significantly faster implementations 
bibliography cline marching cubes high resolution surface reconstruction algorithm proceedings siggraph pp 

guskov sweldens schroder multiresolution signal processing meshes proceedings siggraph pp 

malladi sethian vemuri shape modeling front propagation level set approach ieee trans 
pami vol 
pp 

whitaker level set approach reconstruction range data int 
computer vision vol 
pp 

welch witkin free form shape design triangulated surfaces proceedings siggraph pp 

taubin signal processing approach fair surface design proceedings siggraph pp :10.1.1.21.1887

desbrun meyer schroder barr implicit fairing irregular meshes diffusion curvature flow proceedings siggraph pp 

schneider kobbelt generating fair meshes boundary conditions geometric modeling processing proceedings pp 

sequin functional optimization fair surface design proceedings siggraph pp 

welch witkin variational surface modeling proceedings siggraph pp :10.1.1.34.215
july 
halstead kass derose efficient fair interpolation surface proceedings siggraph pp 

schneider kobbelt geometric fairing irregular meshes free form surface design www informatik rwth aachen de geom fair pdf appear computer aided geometric design 
anisotropic geometric diffusion surface processing proceedings ieee visualization pp :10.1.1.10.97

compact surfaces total curvature tech 
rep university tubingen germany 
taubin zhang golub optimal surface smoothing filter design european conf 
computer vision vol 
pp 

kobbelt 
seidel interactive multi resolution modeling arbitrary meshes proceedings siggraph pp 

chopp sethian motion intrinsic laplacian curvature interfaces free boundaries vol 
pp 

caselles sapiro filling joint interpolation vector fields gray levels ieee trans 
image processing vol 
pp 
august 
sapiro geometric partial differential equations image analysis 
cambridge university press 
osher sethian fronts propagating curvature dependent speed algorithms hamilton jacobi formulation computational physics vol 
pp 

sethian level set methods evolving interfaces geometry fluid mechanics computer vision material sciences 
cambridge university press 
differential geometry curves surfaces 
prentice hall 

cheng osher sapiro variational methods partial differential equations implicit surfaces computational physics vol 
pp 

levin schroder fitting subdivision surfaces proceedings ieee visualization pp 

perona malik scale space edge detection anisotropic diffusion ieee trans 
pattern analysis machine intelligence vol 
pp 
july 
gonzalez woods digital image processing 
addison wesley publishing 
rudin osher fatemi nonlinear total variation noise removal algorithms physica vol 
pp 

sethian fast level set method interfaces computational physics pp 

peng merriman osher 
zhao kang pde fast local level set method computational physics vol 
pp 

appendix numerical implementation embedding surface models volumes converted equations describe movement surface points nonlinear pdes defined volume 
step discretize pdes space time 
embedding function defined volume domain time 
pdes solved discrete sampling forward differences time axis 
issues discretization accuracy stability numerical solutions ii increase computational complexity introduced dimensionality domain 
notation brevity discuss numerical implementation extension straightforward 
function 
ir discrete sampling grid location 
refer specific time instance function superscripts vector space refer components consistent notation sec 

calculations need different approximations order derivatives forward backward central differences 
denote type discrete difference superscripts difference operator forward differences backward differences central differences 
instance differences direction discrete grid unit spacing time superscript left conciseness 
application difference operators vector valued functions denotes componentwise differentiation 
numerical solution describing numerical solution refer flow chart fig 
time step main loop 
step numerical implementation calculation surface normal vectors recall surface level set defined 
surface normal vectors computed unit vector direction gradient gradient computed central differences normal vectors initialized fixed allowed lag evolution time steps evolution denoted different superscript evolution dg dn implemented smallest support area operators 
dg dn rewrite component component 
laplacian function applied steps gradient divergence 
gradient normals produces matrix divergence operator collapses vector 
diffusion normal vectors tangent plane level sets requires compute flux directions denote ix iy columns flux matrix computed independently ix iy time index remains fixed increment derivatives normal vectors computed forward differences staggered located grid computation grid offset grid defined shown fig 
case 
furthermore notice offset half pixel direction differentiation locations different locations respectively 
evaluate computed respectively 
computations done smallest support area operators symmetric grid samples staggered point shown fig 
heavy rectangle 
instance backwards differences flux matrix compute divergence operation dg dn ix iy notice backwards difference ix defined original grid location holds iy components dg dn located original grid tangential projection operator new set normal vectors computed dg dn dg dn dg dn starting initialization iterate fixed number steps 
words aim minimizing energy dg dn loop fig 
reduce 
minimization total mean curvature function achieved iterating main loop 
sec 
shown minimize total mean curvature dg dn loop processed time step processing dd df loop iteration main loop 
dd df loop computationally expensive part algorithm run times reduced running main loop times possible 
effect dg dn loop processed multiple time steps moving dd df loop 
number iterations main loop necessary obtain result reduced approach iterations main loop examples 
evolution concluded evolved catch new normal vectors 
denote evolved normals solve calculate induced mean curvature normal map words curvature hypothetical target surface fits normal map 
calculation curvature field normals central differences components normal vectors 
needs computed initialization normal vectors remain fixed phase 
time step index dd df loop 
mean curvature moving level set surface time step calculated smallest area support grid gradients denominator calculated staggered neighborhood 
pde solved finite forward differences wind scheme gradient magnitude avoid overshooting maintain stability 
wind method computes sided derivative looks wind direction moving wave front avoids overshooting 
interested single level set solving necessary 
different level sets evolve independently compute evolution narrow band level set interest re initialize band necessary 
see details numerical schemes efficient solutions level set methods 
upwind scheme narrow band methods computed curvatures computed 
loop iterated energy ceases decrease inal denote final iteration loop 
set iteration main loop see fig 
inal repeat entire procedure 
number iterations main loop free parameter generally determines extent processing amount smoothing 
