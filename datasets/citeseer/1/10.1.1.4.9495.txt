improving generation object oriented test suites avoiding redundant tests tao xie darko marinov david notkin department computer science engineering university washington seattle wa usa notkin cs washington edu mit computer science artificial intelligence laboratory cambridge ma usa marinov lcs mit edu object oriented tests consist sequences method invocations 
behavior invocation depends state receiver object method arguments invocation 
existing tools automatic generation object oriented test suites jtest jcrasher java typically ignore object states 
tools generate redundant tests exercise method behavior increases testing time increasing ability detect faults 
propose formal framework detecting redundant tests fully automatic techniques framework 
techniques developed test minimization tool removes redundant tests test suites test generation tool iteratively augments test suites non redundant tests 
evaluate tools subjects taken variety sources 
experimental results show test minimization remove tests generated jtest subjects tests generated jcrasher half subjects decreasing quality test suites 
results show test generation effectively generate new tests increase quality test suites generated jtest jcrasher 

existing tools automatic generation object oriented test suites jtest commercial tool java jcrasher research prototype java test class generating sequences method invocations class 
test consists sequence sequences differ tools conservatively assume tests equivalent 
cases different method sequences exercise behavior class test 
example sequences produce equivalent objects invocations modify state different state modifications result state 
intuitively invoking methods equivalent objects redundant 
testing typically constrained time limits key issue avoid redundant tests increase testing time increase ability detect faults 
propose formal framework detecting redundant tests equivalent objects 
framework fully automatic techniques detecting equivalent objects 
techniques require user input techniques assume class test implements equality method 
java equals method defined technical report uw cse january java lang object class overridden subclasses pervasively example compare elements java collections framework 
equals method satisfy set properties implementing equivalence relation collections behave expected 
testing tools require user provide abstraction function classes objects equivalent map value 
view techniques automatically defining abstraction function equals conservative abstraction function fully automatic 
projects observational equivalence define equivalent objects :10.1.1.13.5473
checking observational equivalence expensive definition takes infinite time practice approximations 
techniques give conservative results observational equivalence take time 
developed test minimization tool removes redundant tests test suite test generation tool iteratively augments test suites non redundant tests 
execution existing test suite test generation tool monitors collects method sequences lead non equivalent object state 
monitors collects method arguments exercised existing test suite 
tool uses form combinatorial testing exhaustively exercise non equivalent object state methods collected arguments 
test generation exploits knowledge existing tests generate arguments novel approach complements generation arguments default values user defined values :10.1.1.122.9788
combinatorial generation new non equivalent objects encountered process iteratively continues user defined number iterations 
test generation guarantees generated test non redundant 
main contributions propose formal framework detecting equivalent object states redundant tests 
techniques framework 
develop test minimization tool removes redundant tests test suite sacrificing quality test suite 
develop test generation tool iteratively augments test suites non redundant tests 
tool require users define extra input new tests fully exploits information existing test suite 
evaluate test minimization generation subjects taken variety sources 
experimental results show test minimization remove tests generated jtest subjects tests generated jcrasher half subjects 
results show test generation effectively add tests increase branch coverage test suites 

example illustrate techniques determine redundant tests 
running example integer stack implementation shown taken henkel diwan 
array store contains elements stack size number elements index free location stack 
pop appropriately increases decreases size writing reading element 
additionally push pop grows shrinks array size equal half array length 
observer checks stack elements method equals compares stacks equality 
example test suite tests intstack class test intstack new intstack isempty push push pop push test intstack new intstack push push test intstack new intstack push push pop test method sequences objects class 
example creates stacks invokes methods 
tests form generated tools jtest jcrasher 
tests correctness checking depends design contract annotations 
code annotations tools translate run time assertions evaluated execution 
annotations tools check robustness code execute tests check uncaught exception thrown 
determine redundant tests techniques monitor executions tests 
execution test consists transitions state java program 
techniques track transitions granularity methods test case execution produces sequence method executions 
method execution characterized actual method invoked representation state receiver object method arguments execution 
call state method entry state simply state clear context 
instance method executions 
constructor arguments invoked 
push adds empty stack 
push adds previous stack 
list english language describe method entry states 
techniques compare formal representations state approaches determining equivalent states section 
public class intstack private int store private int size private static final int initial capacity public intstack store new int initial capacity size public void push int value size store length int store new int store length system store store size store store store size value size public int pop int result store size size store length initial capacity size store length int store new int store length system store store size store store return result public boolean isempty return size public boolean equals object null return false instanceof intstack return false intstack intstack size size return false int size store store return false return true integer stack implementation java call method executions equivalent invocations method respective equivalent states 
test generation approaches concerned redundant tests test redundant test suite method execution test equivalent method execution test suite 
section presents test minimization approach removes redundant tests test suite test generation approach generates non redundant tests 
briefly explain different techniques determining equivalent states illustrate redundant tests techniques find example test suite 
wholeseq conservative technique models existing test generation tools 
tools typically consider tests equivalent identical 
technique represents state method sequences create objects compares state sequence equality 
finds example tests non redundant 
modifyingseq technique improves previous state representation method invocations modify state 
finds redundant exercises subset method executions exercises 
wholestate technique uses concrete state representation compares states isomorphism defined section 
finds redundant 
find redundant tests different concrete states push array store value value ins 
monitorequals technique leverages equals method extract relevant parts state 
finds redundant 
concrete states push different relevant parts states subarray 
pairwiseequals technique uses directly equals method compare pairs states 
running example finds redundant tests previous technique 

formal framework section formalizes notions introduced informally previous section 
describe approaches representing states comparing equivalence 
describe techniques builds appropriate representation finds equivalent states 
show equivalent states give rise equivalent method executions define redundant tests test suite minimization 
discuss assumptions techniques code test 
state representation comparison techniques main approaches state representation method sequences concrete state objects 
approaches assume classes test set methods distinguished java name entire signature consider constructors methods 
method sequences execution test creates objects invokes methods objects 
method sequence approach represents state sequences method invocations represent objects henkel diwan representation mapping java classes algebras 
state representation uses symbolic expressions concrete grammar shown 
object value represented expression 
arguments method invocations represented sequences zero expressions receiver treated method argument 
representation assumes method invocation modify state receiver object arguments return result 
state retval expressions denote state receiver method invocation result invocation respectively 
brevity specify types expressions typed java typing rules 
example object represented push push init state state state init represents constructor method 
constructor takes receiver init state represents object state created constructor method invocation 
object state receiver method 
techniques represent method entry states tuples expressions 
tuples equivalent iff expressions component wise identical 
tests may contain loops arithmetic operations 
example manually written tests shown left right columns respectively test test intstack new intstack intstack new intstack int int push push push precisely method represented signature different methods different representation name 
exp prim state retval method exp prim null true false 
grammar symbolic expressions method sequence approach monitors invocations methods collects method calls actual argument values 
approach represents object states push push init state state state concrete state execution test operates program state includes program heap 
concrete state approach considers parts program heap 
call part heap view graph nodes represent objects edges represent object fields 
set consisting primitive values including null integers booleans set objects fields form set 
array elements considered object fields labelled indices 
definition 
heap edge labelled graph 
define heap isomorphism graph isomorphism node bijection 
definition 
heaps isomorphic iff bijection 
note definition allows nodes vary isomorphic heaps fields objects values primitive fields 
techniques rooted heaps state representation 
definition 
rooted heap pair root object heap nodes reachable techniques construct rooted heap program heap tuple 
vn pointers primitive values vi construction creates heap vi root object 
creates rooted heap oh eh subgraph contains nodes reachable edges oh set objects reachable eh oh 
polynomial time algorithm known checking isomorphism general graphs possible efficiently check isomorphism rooted edge labelled graphs 
approach linearize heaps sequences checking heap isomorphism corresponds checking sequence equality 
shows pseudo code linearization algorithm 
traverses entire heap depth order starting root 
visits node assigns unique identifier node keeping mapping ids 
cycle heap traversal visits nodes time uses previously assigned identifiers represent nodes 
similar linearization applied model checking encoding states 
easy show linearization normalizes rooted heaps sequences 
theorem 
rooted heaps isomorphic linearize 
techniques table shows techniques compare 
different techniques different representations method entry states different comparisons equivalent states 
method entry state describes receiver object arguments method invocation 
explain details techniques 
wholeseq technique uses method sequence approach represent state 
represents object expression includes methods invoked object created including constructor 
implementation obtains representation executing tests maintaining mapping objects corresponding expressions 
method entry state simply tuple expressions represent receiver object arguments 
states equivalent iff tuples identical 
example technique represents states push init state state push isempty init state state state respectively 
technique states equivalent 
modifyingseq technique uses method sequence approach 
represents object expression includes methods modified state object created including constructor 
implementation executes tests determines run time method modifies state 
technique builds compares method entry states previous technique 
uses coarser representation objects find method entry states equivalent 
example isempty modify state stack technique represents states push push init state state finds equivalent 
wholestate technique represents method entry states entire concrete state reachable receiver object arguments 
assume test case execution invoke method program heap execution evaluated receiver object arguments values vi 
recall set primitive values 
technique represents method entry state rooted heap obtained 
vn states equivalent iff rooted heaps isomorphic 
monitorequals technique leverages user defined equals methods extract relevant parts state 
previous technique technique represents state rooted heap heap subgraph entire rooted heap 
conceptually technique obtains entire rooted heap program heap values 
vn receiver arguments previous technique 
invokes vi equals vi execution returns true properly implemented map ids maps nodes unique ids int linearize node root heap ids new map return lin root int lin node root heap ids root return ids get root int id ids size ids put root id int seq id edge fields root foreach root fields seq add seq append lin return seq pseudo code linearization algorithm non primitive vi monitors field accesses executions 
rationale technique invocations equals access relevant object fields define state 
technique represents method entry state rooted heap edges consist accessed fields edges root 
formally entire rooted heap ea set fields accessed equals executions method entry state rooted heap ea technique states equivalent iff rooted heaps isomorphic 
illustration recall example consider state stacks calls push 
concrete state ofs shown left right column push push store store ff store length store length store store store store store store 
store store size size values store array identifiers addresses prefixed 
states equivalent store differs 
execution equals accesses fields size store elements store indices value size 
example accessed part shown left right column equals equals push push store store ff store store size size states identical address differs isomorphic technique reports method entry states equivalent 
pairwiseequals technique leverages user defined equals methods detect equivalent states 
implicitly uses entire program heap equals methods 
executions may additionally allocate temporary objects access fields fields objects objects unreachable executions 
represent method entry states 
compare parts states isomorphism 
runs test build concrete objects correspond receiver arguments uses equals method compare pairs states 
states equivalent iff equals 
redundant tests execution test produces sequence method executions 
definition 
method execution pair method method entry state define equivalent method executions equivalent states 
definition 
method executions equivalent iff equivalent 
test minimization generation approaches concerned redundant tests 
definition 
test redundant test suite iff method execution exists equivalent method execution test test suite minimal redundant test 
definition 
test suite minimal iff redundant 
test suite minimal test suites minimization uses greedy algorithm find minimal test suites additionally find test suite optimal minimizes number tests total number method executions tests optimization problems called minimum set cover minimum exact cover respectively known np complete practice approximation algorithms 
assumptions techniques assumptions code test methods deterministic 
different executions input may produce different results modelchecking techniques applicable testing 
execution methods depends state reachable receiver arguments 
means code test example reads files accesses network 
method sequence representation additionally assumes method modify state receiver return result 
techniques equals methods additionally assume methods properly implemented contract java lang object pure modify state temporarily allocate execution 

implementation section presents details implementation 
implementation techniques collecting method entry states comparing equivalence 
test generation tools 
technique representation comparison wholeseq entire method sequence equality modifyingseq part method sequence equality wholestate entire concrete state isomorphism monitorequals part concrete state isomorphism pairwiseequals entire concrete state equals table techniques state representation comparison techniques byte code engineering library rewrite bytecodes class class loading time 
collect state representation entry exit method call candidate object usually instance class test clients 
collect object states method calls internal candidate object 
object state collection collect receiver object method signatures arguments method entries returns method exits candidate object 
instrument test classes collect receiver object method signatures arguments return call sites method sequences lead argument object states candidate object method 
collected method call information construct method sequence leads particular state candidate object argument object 
wholeseq modifyingseq techniques constructed method sequences represent object states 
implementation pairwiseequals technique execute collected method sequences reproduce object states 
wholestate technique uses java reflection mechanisms recursively collect fields reachable candidate object 
monitorequals modifyingseq techniques need collect accesses fields reachable candidate object 
monitorequals technique represents object state non primitive vi collected field accesses vi equals vi 
modifyingseq technique determines method modifies receiver object state observing write field reachable receiver object 
collect field accesses insert code instance field read write site class bytecodes loading time 
inserted code invokes runtime analysis routines collect accessed fields reachable candidate object 
field access monitoring collection instrumentation bytecodes class loading time specifications aspects weaved bytecodes tools jml tool set aspectj compiler monitor field accesses specifications aspects collect field values relevant ones state representation 
implementations techniques modifyingseq technique technique argument object state representation receiver object state representation 
due engineering considerations collect field accesses receiver object method sequence leads argument object candidate object method 
determine method sequence modifies receiver object state 
implementations technique represent argument object states different represent receiver object states 
techniques representing argument object states modifyingseq technique represent receiver object states 
intersection field sets reachable receiver object argument object empty accuracy concrete state representation compromised method sequence state representation argument object states 
test minimization terms testing behavior method equivalent method executions redundant 
redundancy equivalent method executions unavoidable test suite 
example order test public method calls class particular object state duplicate method call sequence produces object state times number public state modifying methods 
ideally expect test exercises new method execution 
test test suite produce new method execution equivalent produced previously executed tests test suite consider test redundant removed test suite 
instrument entry exit test method test class 
test method entry insert method call runtime analysis routine notify test 
test method executed tool collects method executions exercised test method sees representations method executions exist trie data structure 
trie initially empty running tests test class 
tool find collected representation method execution trie tool adds representation trie 
test method exit insert method call runtime analysis routine notify test 
execution test exists method execution added trie test determined non redundant redundant 
execute test methods test class process source code test class commenting source code redundant test methods save processed source code new minimized test class 
test generation divide test generation problem sub problems object state setup method parameter generation 
object state setup puts object class test particular state invoking methods 
method parameter generation produces particular arguments method invoked object state 
method argument list characterized method signature arguments method 
argument lists non equivalent iff method signatures different corresponding arguments non equivalent 
method execution non equivalent method argument list include method entry state 
method parameter generation generate arguments collected method argument lists executions existing tests 
complements existing method parameter generation dedicated test data pool contains default data values user defined data values 
practice programmers write unit tests tests contain representative argument values 
method parameter generation takes advantage tests requiring programmers explicitly define representative argument values 
manually written tests class generate non equivalent method argument lists tests generated existing test generation tools 
test generation type combinatorial testing 
generate tests exercise possible combination non equivalent object states non equivalent method argument lists 
object state setup collect non equivalent object states executions existing tests 
non equivalent object states exhaustively exercised non equivalent method argument lists generate tests exercise non equivalent set set int set new set set set frontiers int frontiers size set new set foreach frontiers foreach test add add frontiers return pseudo code implementation test generation algorithm 
object state non equivalent method argument lists 
execute new generated tests collect new non equivalent object states encountered executions existing tests 
apply test generation technique generate tests exercise iteration 
pseudo code test generation algorithm 
set existing tests user defined maximum iteration number test generation algorithm runs existing tests collect runtime information including non equivalent method argument lists non equivalent object states 
collect method sequence leads non equivalent object state argument method argument list 
method sequences reproduce object states arguments 
put collected non equivalent object states frontier set 
iterate object state frontier set invoke method argument list object state 
combination object state method argument list forms test 
generate tests combinations run new tests generated current iteration collect runtime information 
collect new non equivalent object states encountered current iteration set new frontier set 
new frontier set start subsequent iteration reached maximum iteration number frontier set object state 
return collected generated tests iterations 
tests exported test class 
invoking state preserving method object state change state invoke methods object state test 
merge generated tests possible reusing sharing object states multiple method argument lists 
reduces number generated tests execution cost generated test suite 
generated test suite contains redundant tests combinatorial generation mechanism guarantees method execution produced test equivalent method execution produced earlier executed tests 
tool implementation java reflection mechanisms generate execute new tests online 
test generation export tests generated iteration junit test class code jcrasher test code generation functionality 

experiments section presents experimental results test generation tools 
hypothesize test minimization tool reduce significant number tests automatically generated existing test generation tools test generation tool effectively generate non redundant tests exercise non equivalent object states 
conduct experiments validate hypotheses compare effectiveness different techniques 
perform experiments linux machine pentium iv ghz processor sun java sdk jvm default configurations 
subjects java classes experiments 
intstack class running example 
classes taken experimental subjects stotts 
class popular example junit 
bankaccount class examples distributed jtest 
linkedlist classes data structures textbook 
columns table show class name number public method number non comment non blank lines code subject respectively 
third party test generation tools jtest jcrasher automatically generate test inputs program subjects 
jtest allows users set length calling sequences range 
experiment set length calling sequences 
jtest tries calling sequences length followed length sequentially 
jcrasher automatically constructs method sequences generate non primitive arguments uses default data values primitive arguments 
jcrasher generates tests length calling sequences 
columns table show number jtest generated tests exercised method executions jcrasher generated tests exercised method executions respectively 
experimental results discussed section modifyingseq technique represent argument object states implementation 
experiments focus comparison different techniques represent receiver object states wholeseq technique conservative represent argument object states 
experiment apply test minimization tool minimize tests automatically generated jtest jcrasher 
show percentage minimized redundant tests tests generated jtest jcrasher respectively 
show percentage minimized method executions method executions generated jtest jcrasher respectively 
observe techniques wholeseq technique substantially remove tests method executions generated jtest subjects ones generated jcrasher half subjects 
concrete state representation techniques minimize tests method sequence representation techniques 
significant difference number minimized tests concrete state representation techniques 
show elapsed real time test minimization jcrasher generated tests respectively 
elapsed time include instrumentation time test class techniques ranging seconds minute 
concrete state representation techniques take longer time method sequence representation tech table subject programs experiments program size ncnb jtest jcrasher loc tests tests intstack bankaccount linkedlist niques 
significant difference elapsed time minimized tests concrete state representation techniques 
measure branch coverage number different uncaught thrown exceptions original test suite generated jtest jcrasher minimized test suite 
results show minimized test suite achieves branch coverage number different uncaught thrown exceptions original test suite 
second experiment test generation tool augment tests automatically generated jtest jcrasher 
set maximum iteration number 
show average number averaging subjects tests method executions generated jtest jcrasher tool 
bars marked existing indicate average number tests generated jtest jcrasher respectively 
remaining bars show average number tests generated test generation tool jtest generated jcrasher generated tests different techniques 
include results wholeseq technique figures test generation wholeseq technique causes memory exceptions subjects second iteration 
shows average number non equivalent object states exercised tests generated jtest jcrasher test generation tool 
bars associated jtest existing existing indicate results existing tests generated jtest jcrasher respectively 
bars associated jtest iteration jcrasher iteration show results tests generated test generation tool jtest generated jcrasher generated tests respectively 
shows branch coverage percentage tests generated subject jtest jcrasher test generation tool 
branch coverage achieved tests generated different techniques put different subjects different techniques axis 
results test generation observe test generation tool techniques wholeseq technique generate fewer tests jtest tests exercise non equivalent object states branches 
addition tests generated test generation tool jtest generated tests throw different uncaught exceptions original tests generated jtest subject throw different uncaught exceptions 
test generation tool generates slightly tests jcrasher tests exercise non equivalent object states branches 
tests generated test generation tool jcrasher generated tests increase number different uncaught exceptions zero subject subject zero subject 
percentage redundant tests jtest generated tests percentage minimized method executions jtest generated method executions elapsed real time seconds test minimization jtest generated tests percentage redundant tests tests percentage minimized method executions jcrasher generated method executions elapsed real time seconds test minimization jcrasher generated tests average number tests generated jtest jcrasher test generation tool jcrasher generated tests iterations average number method executions generated jtest jcrasher test generation tool jcrasher generated tests iterations average number non equivalent object states exercised tests generated jtest jcrasher test generation tool jtest generated tests iterations branch coverage percentage tests generated jtest jcrasher test generation tool jcrasher generated tests iterations threats validity threats external validity primarily include degree subject programs third party test generation tools representative true practice 
mainly data structures subject programs 
third party tools jtest testing tools popularly industry 
threats reduced experiments wider types subjects third party tools 
main threats internal validity include instrumentation effects bias results 
faults tools jtest jcrasher cause effects 
reduce threats manually inspected collected execution traces program subjects 
main threats construct validity include uses measurements experiments assess tools 
assess effectiveness test generation tool mainly measured number new non equivalent object states different uncaught exceptions percentage branches exercised new generated tests 
plan measure fault detecting capability new generated tests thoroughly 

related previous developed techniques detect object state equivalence 
observational equivalence techniques expensive techniques :10.1.1.13.5473
techniques give conservative results observational equivalence techniques 
serialize hash technique similar wholestate technique 
previous techniques detecting object state equivalence verify correctness axioms infer axioms algebraic specifications 
detect equivalent object states mainly avoiding redundant tests test generation 
research projects encoding comparing program object states 
zimmermann zeller develop memory graph visualization capture explore program states program executions 
reduce comparison program states comparison graphs 
zeller compares memory graphs isolate cause effect chains program failure 
iosif robby similar linearization technique encode states model checkers 
apply technique collect relevant object fields collect fields 
previous uses front daikon tool output program states method entry exit points :10.1.1.137.4260
assemble program states different ways form different levels value spectra 
compare value spectra executions old new program versions results aid regression fault exposure localization 
plan apply state representation techniques value spectra approach object oriented programs 
lines previous generate tests exercise object states requiring specification 
buy data flow analysis symbolic execution automated deduction generate method call sequences exercising definition pairs object fields 
test generation tool generates method calls fully exercise non equivalent object states 
generated tests exercising object states implicitly generate method sequences 
ball approach automated testing container classes combinatorial algorithm state generation 
tool applies similar combinatorial mechanism 
approach totally automatic ball approach requires dedicated state generator 
kung propose object state test model symbolic execution statically extract model source code 
test model guide test generation 
approach dynamically detects equivalent object states incrementally exercise new object states 
specifications program research projects generate tests exercise object states 
boyapati develop korat tool exhaustively generate valid object states bounded user defined size 
korat monitors field accesses execution java predicate uses information prune search valid test inputs 
monitorequals technique uses actual values accessed fields represent state uses isomorphism compare states equivalence 
korat generation guarantees generated objects non isomorphic 
allow user define indistinguishability properties group infinite states state machines equivalence classes called 
tool incrementally produces finite state machines executing state machines 
test generation works similar way incrementally producing new object states 
whaley dynamically extract java component interface models accesses field 
statically determine method state modifying 
extracted models assume state modifying method transits object state 
assumption extracted models compact 
modifyingseq technique dynamically accurately determines particular method call state modifying 
object state representations techniques conservative accurate whaley approach 
ongoing extract state transition model test executions object state equivalence 
preliminary experiments observe extracted models complex accurate models extracted whaley approach 
previous integrates daikon jtest uses operational violations select small valuable subset automatically generated tests inspection :10.1.1.137.4260
view new test minimization technique trying conservatively minimize automatically generated tests removing useless tests 
lines minimizing prioritizing tests regression testing 
changing program redundant test old version redundant apply regression test prioritization techniques non equivalent object state coverage 
addition method sequences old version produce equivalent object states modifications affect executions method sequences safely determine ob ject states resulting sequences new version equivalent 
plan investigate application techniques regression testing 

proposed framework detecting redundant tests equivalent objects techniques framework 
test minimization test generation tools techniques 
tools produce non redundant tests 
conducted experiments assess effectiveness minimizing augmenting tests generated third party test generation tools 
results show substantially reduce size test suites generated tools effectively generate tests augment test suites exercise non equivalent object states 
results strongly suggest tools techniques generation object oriented test suites consider avoiding redundant tests 

arnold gosling holmes 
java programming language 
addison wesley longman publishing 
ball hoffman ruskey webber white 
state generation automated class testing 
software testing verification reliability 
beck 
test driven development example 
addison wesley 
gaudel 
software testing formal specifications theory tool 
softw 
eng 

boyapati khurshid marinov 
korat automated testing java predicates 
proceedings international symposium software testing analysis pages 
acm press 
buy 
automated testing classes 
proceedings international symposium software testing analysis pages 
acm press 
cheon leavens 
simple practical approach unit testing jml junit way 
proc 
european conference object oriented programming ecoop june 
clark 
junit primer 
draft manuscript october 
smaragdakis 
jcrasher documents 
online manual december 
dahm van 
byte code engineering library april 

frankl 
astoot approach testing object oriented programs 
acm trans 
softw 
eng 
methodol 
ernst cockrell griswold notkin :10.1.1.137.4260
dynamically discovering program invariants support program evolution 
ieee trans 
softw 
eng 
foundations software engineering microsoft research 
test generator tool 
research microsoft com fse doc html 
fredkin 
trie memory 
commun 
acm 
gurevich schulte 
generating finite state machines state machines 
proceedings international symposium software testing analysis pages 
acm press 
harder ernst 
improving test suites operational abstraction 
proceedings th international conference software engineering pages 
ieee computer society 
henkel diwan 
discovering algebraic specifications java classes 
cardelli editor th european conference object oriented programming pages darmstadt germany 
springer 
hughes stotts 
systematic algebraic testing oo programs presence side effects 
proceedings international symposium software testing analysis pages 
acm press 
iosif 
symmetry reduction criteria software model checking 
proceedings th spin workshop software model checking volume lncs pages 
springer july 
johnson 
approximation algorithms combinatorial problems 
comput 
system sci 
junit 
www junit org 
kung suchak gao hsia 
object state testing 
proceedings computer software applications conference compsac pages 
ieee computer society press 
leavens baker ruby 
preliminary design jml behavioral interface specification language java 
technical report tr department computer science iowa state university june 
liskov guttag 
program development java abstraction specification object oriented design 
addison wesley 
meyer 
eiffel language 
prentice hall new york 

jtest manuals version 
online manual october 
robby dwyer hatcliff iosif 
space reduction strategies model checking dynamic systems 
proceedings workshop software model checking july 
rothermel chu 
prioritizing test cases regression testing 
ieee trans 
softw 
eng 
srivastava thiagarajan 
effectively prioritizing tests development environment 
proceedings international symposium software testing analysis pages 
acm press 
stotts lindsey 
informal formal method systematic junit test case generation 
proceedings xp agile universe pages 
sun microsystems 
java platform standard edition api specification 
java sun com se docs api 
aspectj team 
aspectj programming guide 
online manual 
visser havelund brat park 
model checking programs 
proc 
th ieee international conference automated software engineering ase grenoble france 
weiss 
data structures algorithm analysis java 
addison wesley 
whaley martin lam 
automatic extraction object oriented component interfaces 
proceedings international symposium software testing analysis pages 
acm press 
xie notkin 
checking inside black box regression fault exposure localization value spectra differences 
technical report uw cse university washington department computer science engineering seattle wa december 
xie notkin 
tool assisted unit test selection operational violations 
proceedings th ieee international conference automated software engineering pages 
ieee computer society 
zeller 
isolating cause effect chains computer programs 
sigsoft softw 
eng 
notes 
zimmermann zeller 
visualizing memory graphs 
dagstuhl seminar software visualization volume lncs pages 
springer verlag 

appendix appendix presents detailed results experiments 
discussion results section 
table appendix shows actual numbers test minimization results 
tests column shows percentage minimized redundant tests generated tests column shows percentage minimized removed method executions method executions executed generated tests sec column shows elapsed real time seconds spent minimization 
table appendix show actual numbers test generation results jtest generated tests tests respectively 
orig columns show data jtest jcrasher generated tests generated tests iteration generated tests second iteration respectively 
tests column shows number generated tests column shows number generated method executions column shows number exercised non equivalent object states time sec shows elapsed real time seconds spent generation 
elapsed time include execution time existing tests roughly equal test minimization time table 
apply technique iteration encounter memory exception put corresponding entry 
set time iteration minute iteration time put corresponding data entry 
table appendix show numbers different thrown uncaught exceptions branch coverage percentage generated tests jtest generated tests jcrasher generated tests respectively 
exceptions column shows number different thrown uncaught exceptions column shows branch coverage percentage 
table experimental results test minimization jtest generated tests jcrasher generated tests subject technique time time tests sec tests sec intstack wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals bankaccount wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals linkedlist wholeseq modifyingseq wholestate monitorequals pairwiseequals table experimental results test generation jtest generated tests tests time sec subject technique orig orig orig intstack wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals bankaccount wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals linkedlist wholeseq om om om om om om om om modifyingseq wholestate monitorequals pairwiseequals table experimental results test generation jtest generated tests exceptions subject technique orig orig intstack wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals bankaccount wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals linkedlist wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals table experimental results test generation jcrasher generated tests tests time sec subject technique orig orig orig intstack wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate monitorequals pairwiseequals wholeseq om om om om modifyingseq wholestate om om om om monitorequals pairwiseequals bankaccount wholeseq om om om om modifyingseq om om om om wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals linkedlist wholeseq om om om om modifyingseq om om om om wholestate monitorequals pairwiseequals table experimental results test generation jcrasher generated tests exceptions subject technique orig orig intstack wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals bankaccount wholeseq modifyingseq wholestate monitorequals pairwiseequals wholeseq modifyingseq wholestate monitorequals pairwiseequals linkedlist wholeseq modifyingseq wholestate monitorequals pairwiseequals 
