dls easy diego calvanese giuseppe de giacomo maurizio lenzerini dipartimento di informatica sistemistica universit di roma la sapienza salaria roma italy dis uniroma demonstrate way alternating automata nite trees provide elegant ective formal tool addressing reasoning expressive dls 
encoding dl concept checked satis ability automaton checked non emptiness intuitive comparable tableaux rules ii modular construct dealt separately iii short encoding polynomial iv computationally adequate optimally complexity class reasoning 
claims concrete illustrate decide satis ability expressive dls increasing complexity reg corresponds converse pdl local functionality reg extends reg boolean combinations roles reg extends reg quali ed number restrictions 
vardi introduced techniques way alternating automata nite trees reasoning modal logics programs 
techniques adopted devising new results dls xpoints 
demonstrate provide elegant ective formal tool addressing reasoning expressive dls 
particular di erently usual oneway nondeterministic tree automata provide high level description automaton computation abstracts combinatorics allows concentrate logical aspects 
result encoding dl concept checked satis ability automaton checked non emptiness intuitive comparable tableaux rules modular construct dealt separately short encoding polynomial computationally adequate optimally complexity class reasoning 
typical diculty tableau techniques expressive dls establishing suitable termination conditions dealt elegantly appropriate acceptance conditions 
claims concrete illustrate decide satis ability expressive dls increasing complexity reg corresponds converse pdl local functionality reg extends reg boolean combinations roles reg extends reg quali ed number restrictions expressive form number restrictions considered dls 
automata nite trees nite trees represented pre closed nite sets words set positive natural numbers 
formally nite tree set words 
elements called nodes empty word root nodes 
successors convention take 


branching degree node denotes number successors branching degree nodes tree bounded say tree branching degree nite path pre closed set exists unique node jxj labeled tree alphabet pair tree maps node element 
alternating automata nite trees generalization nondeterministic automata nite trees introduced 
allow elegant reduction decision problems temporal program logics 
set positive boolean formulae built inductively applying starting true false elements set formula say satis es assigning true elements false true 
positive integer kg 
way alternating tree automaton ata running nite trees branching degree tuple input alphabet nite set states transition function initial state speci es acceptance condition 
transition function maps state input letter positive boolean formula intuitively pair appearing corresponds new copy automaton going direction suggested starting state example automaton state reading node labeled letter proceeds sending copies states respectively rst successor 
sending copy state predecessor 
copy state 

run ata labeled tree labeled tree node labeled element node labeled describes copy state reads node labels adjacent nodes satisfy transition function formally run labeled tree satisfying 



possibly empty set satis es 

de ned 


run accepting nite paths satisfy acceptance condition nite path inf set states appear nitely second components node labels 
consider uchi acceptance conditions 
uchi condition state set subset nite path satis es inf 
nonemptiness problem consists determining ata set trees accepts nonempty 
results provide complexity characterization nonemptiness 
theorem ata states input alphabet elements deciding nonemptiness done time exponential polynomial reasoning reg consider dl reg de ned syntax id denote respectively atomic concepts atomic roles denote respectively arbitrary concepts roles 
denote basic roles reg atomic inverses atomic roles 
semantics standard 
concentrate concept satis ability determining exists interpretation concept nonempty extension 
virtue internalization results hold reasoning services knowledge bases particular logical implication 
show decide satis ability reg concepts reducing nonemptiness 
rst de ne syntactic closure reg extends standard fischer ladner converse pdl treating functional restrictions atomic concepts 
technical reasons include closure additional elements representing basic roles negations 
particular closure clf reg concept de ned smallest set condition imposed nite paths run 
concepts clf assuming expressed means denote clf clf form clf clf clf clf clf clf clf clf clf clf clf clf id clf clf clf clf cardinality clf linear length shown lines proof converse deterministic pdl reg enjoys tree model property satis able concept model structure possibly nite tree branching degree linearly bounded size concept 
precisely result 
theorem satis able reg concept tree model branching degree kc equal twice number elements clf 
property allows check satis ability reg concept building ata accepts labeled trees correspond tree models set atomic concepts appearing set atomic roles appearing inverses 
construct reg concept ata checks satis ed root input tree 
represent node tree information atomic concepts true node basic role connects predecessor node node root 
precisely label node set atomic concepts basic roles 
atomic concepts true reg contains root single basic role reached predecessor 
stands atomic role reached predecessor stands predecessor reached root contains basic role 
reg concept construct automaton accepts trees correspond tree models technical reasons convenient consider concepts negation normal form negations pushed inside possible 
easy check transformation concept equivalent negation normal form performed linear time size concept 
denote nnf negation normal form cl nnf set clf automaton ini de ned follows 
remind stand arbitrary concepts stand arbitrary roles 
alphabet fqg sets consisting atomic concepts basic role 
corresponds labeling node tree truth assignment atomic concepts role reach node predecessor 
set states fs ini cl nnf ini initial state intuitively automaton state cl nnf visits node tree means automaton check holds atomic concept resp 
basic role amounts check node label contains resp 

set nal states set concepts cl nnf form observe concepts form nal states su cient guarantee concepts satis ed accepting runs automaton 
transition function de ned 

containing basic role transition initial state ini nnf transition checks root tree labeled basic role moves state veri es root 

atomic concept basic role transitions true false true false transitions check truth value atomic concepts negations current node tree 
transitions check role current node reached 
recall cl nnf contains atomic roles appearing inverses 

concepts cl nnf transitions kc id nnf kc id transitions involving inductively decompose concepts roles move appropriate states automaton nodes tree 
transitions involving treat equivalent concept transitions involving treat equivalent concept 
concept form cl nnf transition kc transitions check node labeled exists node predecessor successors reachable 
concept form cl nnf transition kc transitions check node labeled exist nodes predecessor successors reachable run automaton nite tree starts root checking holds item 
inductively decomposing nnf appropriately navigating tree item arrives atomic concepts functional restrictions negations 
checked locally items 
concepts form propagated equivalent concepts respectively 
propagation concepts may generate nite branches run 
run automaton may contain nite branch resolved choosing disjunct choosing disjunct nite branch run corresponds nite path tree iterated forever ful lled 
semantics requires ful lled nite number iterations nite path satisfy acceptance condition automaton requires nite branch run contains state form rules nite branches accepting runs 
run deferring ful llment contain nite branch states form 

post observe remaining nite branches run arise propagating concepts form inde nitely 
acceptance condition allows branches 
labeled tree accepted de ne interpretation 
follows 
de ne atomic role relation follows xi xi xi xi relations de ne atomic concept atomic role lemma labeled tree accepted model conversely tree model branching degree kc obtain labeled tree branching degree kc follows 
fa xi fa xi fq xi node xi lemma tree model branching degree kc labeled tree accepted lemmas tree model property reg theorem get result 
theorem reg concept satis able set trees accepted empty 
theorem follows algorithms nonemptiness check satis ability reg turns decision procedure optimal computational complexity 
ata number states linear size alphabet exponential number atomic concepts occurring theorem get upper bound reasoning reg matches exptime lower bound 
theorem concept satis ability logical implication reg exptime complete 
boolean combinations roles technique reasoning reg extended straightforward way deal boolean combinations atomic roles inverses 
precisely consider logic reg extends reg allowing basic roles boolean combinations negation restricted di erence atomic roles inverses 
obtain reg replace syntax rule basic roles reg assume di erence applied atomic inverse atomic roles 
rst extend de nition closure take account additional constructs 
closure cl reg concept de ned clf replacing rule dealing basic roles ones cl cl cl cl cl cl cl cl cl cl cl cl cl nnf de ned similarly cl nnf show reg enjoys tree model property 
precisely satis able reg concept tree model branching degree kc equal twice number elements cl notice cl takes account boolean combinations roles 
ata ini check satis ability reg concept de ned similarly reg follows alphabet set states fs ini cl nnf 
set nal states set concepts cl nnf form transition function de ned automaton reg additional transitions handle boolean combinations atomic inverse atomic roles 
remember roles atomic inverse atomic state automaton 
show result 
theorem reg concept satis able set trees accepted empty 
number states linear size theorem get result 
theorem concept satis ability logical implication reg exptime complete 
quali ed number restrictions extend investigation quali ed number restrictions 
precisely consider logic reg extends reg allowing concepts quali ed number restrictions form nq nq non negative integer boolean combination negation restricted di erence atomic roles inverses arbitrary reg concept 
rst extend de nition closure take account quali ed number restriction 
closure clq reg concept de ned adding rules cl ones nq cl cl nq cl cl cl nnf de ned logics 
show reg enjoys tree model property 
precisely satis able reg concept tree model branching degree kc equal max 
max maximal number appearing inside quali ed number restriction number elements clq 
ata ini check satis ability reg concept de ned similarly reg follows alphabet set states fs ini cl nnf sq sq fh nq ji nq cl nnf kc ng fh nq ji nq cl nnf kc intuitively states nq ji check quali ed number restriction nq satis ed node counting number nodes predecessor successors reached holds 
precisely automaton state nq ji rst successors th successor predecessor nodes reached holds 
set nal states set concepts cl nnf form transition function de ned automaton reg additional transitions handle quali ed number restrictions denote 

nq 
nq nq nnf 
nq 
nq nq ji nnf nq ji nq kc nq ni true kc nq kc ji false nq ji nnf nq ji nq kc nq false kc nq kc ji true show result 
theorem reg concept satis able set trees accepted empty 
numbers inside quali ed number restrictions coded unary number states polynomial cubic size applying theorem get result 
theorem concept satis ability logical implication reg exptime complete assuming numbers inside quali ed number restrictions coded unary 
obviously assumes numbers coded binary theorem provide exptime upper bound concept satis ability 
deal numbers coded binary adopting complex reduction concept satis ability reg nonemptiness 
observe binary coding exponential blowup size reasons 
necessity explicitly transitions kc successors node binary coding kc exponential size 
necessity count maximum number max appearing inside quali ed number restrictions exponential 
cope point construct ata accepting trees branching degree kc accepts binary trees represent standard encoding ary trees binary trees rst child node left successor sibling node right successor 
observe node connected node basic role kc ary tree may far away corresponding binary tree 
possible take account introducing linear number additional states suitable transitions automaton works binary tree 
cope point transitions simulate automaton binary counter unary counter done number states polynomial max coded binary 
possible show techniques concept satis ability logical implication reg decided exptime numbers inside quali ed number restrictions coded binary 
shown provide intuitive short modular computationally adequate encoding reasoning services expressive dls nonemptiness automata nite trees 
main research directions pursued exploit reasoning dls 
characterizing reasoning new combinations constructs new reasoning services 
respect new results dls exploit power tree automata rephrased away combinatorial noise put forward main argument 
second great interest study practical methods testing nonemptiness exptime complete light optimization techniques developed current state art tableau dls systems 
vardi wolper 
automata theoretic approach branching time model checking 
proc 
th int 
conf 
computer aided veri cation cav volume lecture notes computer science pages 
springer 
calvanese de giacomo lenzerini 
reasoning expressive description logics xpoints automata nite trees 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
emerson jutla 
tree automata mu calculus determinacy 
proc 
nd annual symp 
foundations computer science focs pages 
fischer ladner 
propositional dynamic logic regular programs 
computer system sciences 
harel kozen tiuryn 
dynamic logic 
mit press 
hollunder baader 
qualifying number restrictions concept languages 
proc 
nd int 
conf 
principles knowledge representation reasoning kr pages 
lutz 
interval temporal reasoning general tboxes 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
lutz sattler 
complexity reasoning boolean modal logics 
wolter wansing de rijke editors advances modal logics volume 
csli publications 
muller schupp 
alternating automata nite trees 
theoretical computer science 
sattler vardi 
hybrid calculus 
proc 
int 
joint conf 
automated reasoning pages 
schild 
correspondence theory terminological logics preliminary report 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
thomas 
automata nite objects 
van leeuwen editor handbook theoretical computer science volume chapter pages 
elsevier science publishers north holland amsterdam 
tobies 
complexity results practical algorithms logics knowledge representation 
phd thesis theoretical computer science germany 
vardi 
reasoning past way automata 
proc 
th int 
coll 
automata languages programming icalp volume lecture notes computer science pages 
springer 
vardi wolper 
automata theoretic techniques modal logics programs 
computer system sciences 
preliminary version appeared proc 
th acm sigact symp 
theory computing stoc 
