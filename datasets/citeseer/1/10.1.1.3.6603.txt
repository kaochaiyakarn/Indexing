predicting refactoring activities time series antoniol massimiliano di merlo antoniol ieee org merlo info ca research centre software technology university department engineering ex italy refactoring activities carefully planned advance different reasons expensive terms resources needed ii refactoring highly requested clones code smells potential problems reach threshold iii activities performed evolution software system stable period 
proposes apply time series forecasting determining releases correspondence refactoring activities performed 
idea analyze different metrics size complexity cloning ratio number smells past releases predict optimal refactoring point 
keywords refactoring time series forecasting 
software systems evolve cope user changing needs 
despite general agreement cost change interventions maintenance evolution purposes largely exceed development costs contributions addressed problem identifying managing refactoring interventions keep software system quality acceptable level 
changes maintenance interventions rarely planned advance limited bug fixing undesired consequence inevitably contributing deteriorate structure software system 
deterioration se may extremely difficult define quantify measured terms different factors clones code smells library sizes organization cohesion coupling measures correct design patterns 
assume factors reach certain critical values different form actions cole polytechnique de montr montr canada taken bring back software maintainable evolvable state 
possible actions include limited clone detection refactoring code smells removal library reorganization reduce size modules subsystem reorganization increase cohesion decreasing coupling 
interventions performed promote limit usage design patterns limited considered symptom poor design excessive cause overhead 
worth pointing refactoring interventions carefully planned ahead consideration technical organizational managerial implications different choices 
example may true clone refactoring contribute improve software system maintainability reliability introduce new bugs unpredicted impact 
refactoring activities expensive performed period significant evolution system risky especially terms system reliability 
example avoided perform refactoring right important release milestone 
suggested refactoring activities performed periods software system evolution terms size complexity functionalities particularly significant 
words prior activity preliminary phase identifying suitable windows opportunity carry refactoring required 
turn highlights need organization able track predict software evolution 
considerations propose approach relying time series ts forecasting plan refactoring activities 
shown different types metrics different granularity levels extracted current past versions monitored software system 
metric ts built predict values 
values determine window opportunity optimal refactoring point release particular refactoring activities performed 

time series forecasting ts defined sequence observations ordered single dimension time 
ts data arise monitoring industrial processes business metrics general temporal behavior phenomenon 
possible objectives analyzing ts prediction observed ts may want predict values 
kind analysis applications economic forecasting analysis stock market analysis process quality control census analysis 
methods model forecast ts widely adopted box jenkins auto regressive integrated moving average arima models box jenkins multivariate models holt winters exponential smoothing multivariate autoregression 
ts may affected main phenomena nonstationarity presence trends fluctuations 
purpose worth pointing ts related size exhibits trend ts related smells clones characteristics involved refactoring may exhibit 
fact may happen clones tend increase refactoring performed fall tend increase 
ts prediction process thought sequence steps metrics extraction model building value prediction 
foremost features predicted metrics cloning ratio number code smells extracted past release software system 
worth noting accuracy prediction highly correlated size training set number past releases build model 
subsequently ts modeled mentioned model possible predict values steps ahead 
determine model performance ts points points ts realization build model predict values match actual values 
th steps ahead predicted value compared actual value order evaluate th steps ahead prediction error 
predicted value time actual value magnitude relative error mre defined mre rel 
rel 
rel 
rel 
step ahead steps ahead steps ahead rel 
rel 
release 
linux kernel mre prediction 
mean magnitude relative error sequence experiments defined prediction errors usually low predicted quantity useful planning managing software projects 
example achievable accuracy reports mre prediction sequence linux kernel releases 
values different metrics different steps ahead shown 
results prediction cloning evolution cloning predicted step ahead examples clone refactoring occurred linux kernel evolution shown 
locs functions cycl 
complexity steps ahead 
linux kernel metrics prediction 
rel 
timeline metrics extraction release smells detection metrics time series forecasting 
refactoring plan indicators release metrics extraction smells time series forecasting stated shown refactoring point may located means ts forecasting 
particular different aspects considered 
foremost forecasting ts obtained dimensional structural metrics locs average cyclomatic complexity number functions classes modules help determine stable evolution region region refactoring activities take place 
determined candidate refactoring point forecasting different software system characteristics help select activities performed 
particular classify characteristics monitored follows 
presence source code clones writing device driver porting existing application new processor reason developers may decide copy entire working subsystem modify code cope new hardware 
technique ensures unplanned effect original piece code just copied 
evolving practice promotes appearing duplicated code snippets said clones 
literature proposes various methods identifying clones software system 
shown clone refactoring activities performed improve source code structure possibly maintainability 
result refactoring consistently performed software system evolution new clones tend appear time old ones refactored cloning ratio tend kept stable 
ts forecasting approaches help analyze cloning ratio evolution suggest possible refactoring activities 
source code smells large list source code smells portions source code benefit 
smells detection estimated metrics estimated smells refactoring decision 
determining refactoring point 
release refactoring release refactoring extensively described 
examples long methods temporary variable different purposes different assignments 
cordy proposed method automatic detection removal smells 
believe monitoring prediction evolution help identify applying refactoring transformations 
library size cohesion coupling new functionalities added software system libraries tend increase size new objects spread software system coupling level different modules libraries tend increase 
consequence memory requirements applications tend increase 
increasing resources may pose serious problems porting applications limited resource devices 
maintainability system deteriorated 
suggests periodically reorganizing libraries example splitting biggest smaller ones clustering added objects new libraries adding existing libraries 
consequence indicators average size libraries cohesion coupling levels monitored predicted releases 
presence design patterns monitoring evolution object oriented software systems worth investigating presence design patterns design documents source code 
identification design pattern instances provides insight software artifact structure reveals places changes reuse extensions expected 
design pattern extraction give maintainers measure source code design quality helps identification extraction components existing software systems 
trade pursued benefits design patterns side effects excessive design patterns may cause overhead 

proposes ts forecasting determine candidate refactoring points releases refactoring performed 
determined different factors comprising stability software system evolution level refactoring indicators presence clones code smells library size cohesion coupling 
previous studies indicated effectiveness ts predicting dimensional structural metrics cloning level 
progress devoted apply approach correlate software evolution refactoring points study evolution characteristics code smells design patterns 
lehman belady software evolution processes software change 
academic press london 
cordy comprehending reality practical barriers industrial adoption software maintenance automation proceedings ieee international workshop program comprehension portland usa pp 
may 
fowler beck brant opdyke roberts refactoring improving design existing code 
addison wesley publishing 
harvey forecasting structural time series models kalman filter 
cambridge university press 
box jenkins time series forecasting analysis control 
san francisco usa holden day 
mukhopadhyay software effort estimation exploratory study expert performance information systems research vol 
pp 
dec 
antoniol di merlo modeling clones evolution time series proceedings ieee international conference software maintenance florence italy pp 
nov 
antoniol merlo di analyzing cloning evolution linux kernel information software technology vol 
pp 
oct 
baker finding duplication large software systems proceedings ieee working conference reverse engineering july 
baxter moura anna bier clone detection syntax trees proceedings ieee international conference software maintenance pp 

inoue token code clone detection system large scale source code ieee transactions software engineering vol 
pp 
july 
kontogiannis de mori bernstein merlo pattern matching clone concept detection journal automated software engineering march 
cordy automatic code smell detection source transformation proceedings ieee working conference reverse engineering victoria bc canada ieee cs press nov appear 
antoniol di library miniaturization static dynamic information proceedings ieee international conference software maintenance amsterdam netherlands pp 
ieee press sep 
antoniol di object oriented design patterns recovery journal systems software pp 

kontogiannis role design patterns quality driven re engineering european conference software maintenance reengineering budapest hungary pp 
mar 
assessment design patterns software reengineering lessons learned large commercial project european conference software maintenance reengineering lisbon portugal ieee press mar 
di measuring predicting linux kernel evolution workshop empirical studies software maintenance nov 
