generic approach static analysis detecting runtime errors java programs jia division software engineering school computer science telecommunication information systems depaul university chicago illinois mail jia cs depaul edu cs depaul edu presents generic approach statically analyze java programs order detect potential errors bugs 
discuss framework supports approach carries static analysis java code automatically 
approach automatically detect potential bugs report program executed 
java class invariants related category error examination automatically generated assess validity variable usage implementation class 
approach distinctive emphasis provide generic mechanism error detection capable addressing error detection variety error categories web specialized components 
research prototype developed demonstrates feasibility ectiveness approach 

detecting errors programs active areas research computer science 
numerous research orts resulted techniques allow reason programs 
concerns program correctness led hoare triples dijkstra weakest precondition currently complete veri cation environments higher order logic hol prototype veri cation system pvs 
large number programming notations exists variety mechanisms prevent potential errors occurring notify user safe manner errors occur 
examples mechanisms include strong typing smart compilers runtime checking 
java example programming language strongly typed extensive sophisticated runtime checking mechanism 
sophisticated compilers limited ability detect potential errors 
due certain time resources performance constraints limit amount compilers perform 
serious problems cause runtime exceptions attempts access null pointers bounds array caught compiler 
kinds errors usually caught 
approach problem potential error detection formal methods 
provide partial solution generic mechanism capable detecting avariety errors 
apply static analysis veri cation techniques automatically analyse java programs detect potential bugs detected compilers data ow analysis techniques 
approach logical concepts class invariant weakest precondition 
developed generic deterministic detection mechanism capable addressing problem error detection variety runtime errors 
detection mechanism comprises set generic specialized carry analysis java code automatically 
consists components generic analysis provide framework kind analysis need 
specialized analysis 
specializes behavior steps de ned generic mechanism 
prototype 
fully functional prototype implements algorithms provides feedback enhance strengthen approach approach uses generic mechanism carrying static analysis java programs provides number specialized components take account details category errors trying detect 
detection mechanism approach certain limitations mainly due intractability theorem proving process 
guarantee absolute success nding bugs restricted types analysis discussed earlier 
goal nd errors nd majority fully automatic transparent way 
key characteristics contributions approach summarized follows generic detection mechanism 
approach speci detect errors deterministically generic provide cient ective framework extensive variety error categories 
complete automation 
entire process analyzing source code reporting potential violations fully automatic 
need formal speci cations 
require formal speci cations 
recover relevant speci cations source code 
flexibility 
approach easily extended incorporate user provided speci cations strengthen capability analysis component extend set potential errors ectively check 
section discuss generic framework algorithms 
section presents overview prototype tool components 
section discusses experiments carried prototype tool 
related comparisons approach section 
discuss section conclude section summary main ndings results 

analysis framework important concept approach invariant class 
class invariant condition satis ed non transient states instances class 
generic algorithm determine invariant developed 
uses number generic specialized components order determine invariants related speci analysis performed 
invariant determination process takes consideration di erent initialization semantics static instance variables static variables instantiated rst active type class 
generic algorithms listed 
algorithm responsible generating verifying class invariant 

splits candidate invariant predicates involving static variables predicates involving instance variables 

checks predicate regarding class level variables invariant 

statement predicate calculates weakest precondition 
prove 
call prover attempts discharge proof obligations 

analyzes implementation class class invariant check potential errors 
uses number generic specialized algorithms 
specialized analysis achieved number speci algorithms carry analysis speci categories bugs 
algorithms listed 
constructs potential invariant category error check mutate 
goal mutation algorithm provide array weaker predicates store order strength starting strongest predicate unchanged ones predicate mutated anymore weakest mutated form predicate true 
creates veri cation conditions ensure safe variables java code 
determining class construction candidate invariant mutation checking satis es requirements invariant 

algorithm informally de ne concepts static invariant condition regarding static variables java class ensured static initialization blocks preserved constructors public methods 
instance invariant condition regarding class level variables java class ensured constructors preserved public methods 
class 
initialization invariant seq predicate hi seq predicate hi 
constructing candidate static instance invariants class 
determine invariant related static variables mut pred mut pred pred break 
determine invariant instance variables mut pred si mut pred pred break 
invariant invariant return invariant algorithm accepts input java class returns predicate satis ed non transient instances class 
reads class level variables static non static forms candidate invariant 
breaks formed invariant predicates expresses condition static variables variables 
invariant broken sets order examine properties depend instantiation java class ones 
predicate examined ful lls requirements invariant added invariant class 
output algorithm invariant forthe java class examination 

determining invariant need establish condition invariant true relevant variables time class instantiated 
algorithm described determine invariants related static instance variables 
boolean si precond boolean progress false candidate ci progress prove precond ci candidate progress break progress mj methods progress prove candidate mj candidate progress break return progress due di erent instantiation semantics static instance variables run algorithm di erent inputs consider di erent instantiation blocks 
speci cally static invariant determination static blocks ensure potential invariant instance invariant consider init blocks constructors 
precondition holds instantiation class 
case class static variables precondition reduced predicate true 
precondition input algorithm candidate invariant candidate 
invariant regarding instance variables ensured constructors preserved public method 

check violation algorithms algorithms previous section determine invariant regard speci property try ensure 
check usage relevant variable detect possible violations 
void 
pre condition statements assertion attempt prove 
dereference statements order provide algorithm scans implementation class locates variables forms appropriate veri cation conditions 
class invariant 
initialization 
check static block potential bugs 
precondition true true 
check constructors potential bugs 
precondition cj cj 
check public methods potential bugs 
precondition invariant mj methods mj invariant 
return potential violations return order identify potential errors need carefully check statement implementation class locate points variables form appropriate predicate needs true order variables safely program point execution 
shown general form block precondition 
initialization seq statement hi boolean condition true boolean correct false targets 
check java block code bugs precondition statement si block hsi targets si targets pred targets correct prove precondition pred correct fsi 
return potential bugs block code return 
prototype development main components prototype listed model constructor modeling activity set classes provide support java programming construct class method block code statements types syntax tree created control ow graph program constructed 
control ow graph model paths execution identi ed 
invariant generator uses generic customizable algorithms derive invariant regarding speci property investigation 
violation detector invariant invariant generator scans class implementation form veri cation conditions passes prover 
general theorem proving involves unrestricted predicates intractable 
approach focused restricted predicates 
examples restricted predicates checking illegal dereference variable type 
predicate 
checking array index falling bounds accessing ith element 
formulate predicate length 

experiments assess capabilities approach number small experiments 
results show prototype serve vehicle research area 
rst goal demonstrate feasibility approach 
small scale projects conducted results evaluated 
research ort 
success judged experiments theoretical proofs analyses 
experimentation feedback mechanism theoretical studies solutions 
goal gain demonstrate ectiveness experimentation 
experimental prototype allows gain insight discover obstacles limitations techniques 
feedback tool re ne enhance approach 
conducted large number tests prototype tool exhibited key characteristics complete java coverage 
able cover entire java language 
syntactical semantical restriction original language imposed 
guarantee program correctness 
approach doesnot promise absolute correctness absence errors 
strives identify certain types potential errors application formal methods approach promotes formal methods way completely transparent user 
apply formal methods little cost concrete gains 
gains 
prototype tool development provides means measuring effectiveness capability approach 
early experiments indicate approach radical changes way practitioners develop code 
removes burden proof software practitioners analysis fully automatic developed classi cation scheme di erent causes errors kinds specialized analysis discussed null pointer array bounds 
kind anomaly analyzed enumerated causes scenarios violation occur program 
error scenario null pointer class level var initialized array bounds array initialized size size null pointer class level var null arbitrary array bounds array created accessed local scope null pointer var dereferenced condition blocks array bounds class level array initialized int constant remains constant may change various constructors null pointer null var dereferenced path array bounds array access guarded arr length null pointer var initialized null null pointer var null loop iteration null pointer var initialized dereferenced guarded experimental scenarios shown fig 

prior testing test cases successfully compiled ensure syntactic correctness code 
ed cases performed complete set permutations di erent scenarios measure ectiveness approach 
prototype capable nding errors scenario 
summary early experiments 
prototype development extensive case studies planned 

related flow control techniques successfully part modern compilers java provide early detection various anomalies minimize number inconsistencies programs 
unfortunately techniques dealing invariant properties pre post conditions prevent number tedious bugs occurring 
bugs include dereferencing null pointer array index falling bounds kinds problems capabilities compilers subsequently transfered runtime environment languages er exception handling mechanisms 
research dec laboratories resulted extended static checking esc checking object invariants 
attempt formal methods identify particular kinds bugs programming language provide kind feedback programmer potential bugs 
esc translates form dijkstra guarded command 
logical framework untyped rst order predicate calculus lack type information proofs covered background predicate includes type axioms 
unsuccessful proof return information reason failure 
generalisation extension null pointer detection carried members formal methods group software engineering division depaul university 

lays foundation comprehensive analysis java classes 
evolve main directions order provide stronger analysis techniques cover complicated cases dened categories potential bugs extensive array algorithms capable handling di erent cases broader coverage kinds errors automatically checked 
include limited illegal string index bounds 
usually checking errors rst priorities software developer 
errors escape detection testing products released customers number bugs hidden code 
approach provides solution problem focusing detection certain kinds bugs 
approach algorithms described dealing concept class invariant check implementation class 
implication instance created public constructor class public thread safe method invoked order 
address obstacles prevent formal methods widely software industry 
formal methods theorem proving software practitioner 
sacri cing guarantee absolute lack errors provide mechanism detect arguably signi cant number common errors part daily debugging routine software practitioner 
approach focused certain types anomalies source code detected automatically 
key feature approach practical complete automation entails practicality 
dijkstra 
guarded commands formal derivation program 
communications acm 
gordon melham 
hol theorem proving environment higher order logic 
gosling joy steele 
java tm language speci cation 
addison wesley 
gries 
science 
springer verlag 
hoare 
axiomatic basis computer programming 
communications acm 
gosling steele 
java speci cation language 
technical report 
available www javasoft com 
jackson 
formal speci cation language detecting bugs 
phd thesis massachusetts institute technology 
detlefs 
overview extended static checking 
proc 
workshop formal methods practice pages 
acm sigsoft 
leino 
object oriented programming language axiomatic semantics 
proc 
fool fourth international workshop foundations object oriented languages 
leino stata 
checking object invariants 
technical report digital equipment research center 
palo alto ca 
owre rushby 
pvs prototype veri cation system 
lecture notes arti cial intelligence 

applying static analysis detecting null pointers java programs 
technical report oct 
ms thesis 
