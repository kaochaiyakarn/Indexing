contents comparing proofs programming paradigms andrew glenn strong november methodology 
model world file system 
operations 
fopen operation 
fclose operation 
fwritei operation 
freadi operation 
model signature summary 
connecting model abstracted programs 
syntaxes common syntax 
common expressions 
functional language expressions 
syntax 
statements 
programs 
clean syntax 
clean expressions 
clean hash elements 
clean programs 
haskell syntax 
haskell expressions 
updated version january haskell monadic statements 
haskell programs 
real programs real program 
real clean program 
real haskell program 
abstracted programs io abstraction 
concrete programs io abstraction 
abstracted program 
abstracted clean program 
abstracted haskell program 
syntax forms 
syntax program 
syntax clean program 
syntax haskell program 
denotational semantics common semantic domains 
value semantic domain 
environments 
handles 
environment 
denotation functions 
note type correctness 
denotational semantics 
program state 
program denotations 
statement denotations 
expression denotations 
builtin denotations 
clean denotational semantics 
clean program state 
clean program denotations 
clean expression denotations 
clean pattern match 
clean builtin function denotations 
haskell denotational semantics 
denotational proofs property 
proof program 
program labelled syntax 
proof 
lemma cd 
lemma cd 
lemma cd 
lemma cd 
proof clean program 
clean program labelled syntax 
proof 
lemma kd 
language semantics language semantics 
hoare triple rules 
wp rules 
program language semantics 
model hoare triple form 
io model language form 
clean language semantics 
io model clean language form 
haskell language semantics 
io model haskell language form 
language proofs language proof 
condition annotated program 
statement 
statement 
statement 
statement 
statement 
statement 
finishing proof 
lemma 
lemma 
clean language proof 
lemma 
lemma 
lemma 
lemma 
lemma 
lemma 
lemma 
lemma 
lemma 
haskell language proof 
lemmas haskell proof lemma 
lemma 
lemma 
lemma 
lemma 
cited advantage functional programming languages supposed easier reason imperative languages bw pj bd hen pp dav property referential transparency getting prominent mention notion side effect deprecated round 
long time major disadvantage functional programming languages inability adequately handle features side effects intrinsic component file operations gor xi 
methodologies emerged decade combine side effect world referentially transparent world functional programming uniqueness type system programming language clean bs monads haskell language gor bir chp pp 
consequence developments functional programs written languages look imperative programs evidenced sample programs appearing 
immediately raises concerns relative ease reasoning programs compared similar programs done imperative style 
question technical machinery necessary handle pure functional languages led situation correctness proofs difficulty imperative programs question technical developments applied imperative programs order easier reason words ended situation little choose functional imperative languages comes reasoning real world programs interact environment effective man ner second issue concerns relative ease reasoning technical alternatives uniqueness typing monads 
uniqueness typing approach uses type system ensure external world accessed single threaded fashion underlying implementation safely implement operations world side effects maintaining referential transparency 
programmer perspective changes program satisfy type checker 
monadic approach uses datatype enforces single threaded world resources requires programmer explicitly datatype operations 
effect monad acts wrapper potentially dangerous operations 
question explicit monadic wrapper laws monadic program harder reason compared similar uniquely typed program methodology key aim establish effect choice paradigm ease reasoning 
particular wish avoid differences introduced idiosyncrasies associated real world instances paradigms 
paradigms study known real world instances imperative explicit side effects sequencing assignment kr 
uniquely typed referentially transparent side effects guaranteed singlethreaded type system dealing uniqueness clean pve 
monadic referentially transparent side effects guaranteed single threaded embedding monads haskell ph 
programming language unix operating system led fairly standardised set system calls similar names signature behaviour clean system 
haskell system differences names signatures consequent differences behaviour 
clean system system calls counterpart facilitate uniqueness type system 
order factor differences needed modified versions language system appear uniform possible 
case study involved steps 
choose task performed program 
write run real programs check 
develop standardised model 
rework programming languages uniform 
re write programs conform languages model 
develop formal denotational semantics languages 
state property proved attempt proofs 

develop non denotational semantics languages 
state prove properties task choice wanted small case study start order get swamped messy detail 
key requirement program performed desired property refer external world property data involved 
chose simple task involved opening file fixed filename reading integer closing re opening writing square integer back 
property checked existence file integer file integer value square original value 
real programs real programs written clean haskell compiled run 
step particularly important clean program key issue discussed detail rely uniqueness typing ensure single threaded functions 
needed real program certain required uniqueness typing 
similarly haskell ensured io monad usage correctly typed 
haskell program auxiliary function definition structure programs 
model common background cases developed uniform model file proofs 
model captures notion filesystem behaviour required file manipulation functions 
languages programming languages re designed minimise differences apart form paradigm difference study 
particular language assumed expression syntax value space available clean haskell languages 
re worked languages kept small covering features needed case study 
re working ensured structure program changed order avoid risk introducing type errors 
programs programs translated re worked languages main involved renaming file operation functions re ordering arguments 
denotational semantics initially decided develop denotational semantics sch re worked languages largely approach felt getting semantic model correct 
denotational semantics produced clean languages language identical clean language case 
denotational proofs proofs denotational semantics attempted clean programs 
proofs rapidly unwieldy largely due environment information handed 
short struggle decided abandon proofs favour tractable techniques 
partial proofs shown section 

domains developed denotational semantics prove useful semantic models effort entirely wasted 
non denotational semantics decided develop semantics support proofs program text level called laws programming transformation rules 
language explored hoare triples hj weakest precondition mor settled hoare triples proof methodology 
functional languages simply built collection re write rules perform proofs giving complete set 
cases integrated model semantics developed 
interestingly haskell semantics required additional machinery introduced 
non denotational proofs paradigm stated property proved appropriate manner 
proceeded proofs ensuring proofs complete necessary lemmas handled paying particular attention pre conditions operations 
model develop io model suit case study 
world file system posit world interest happens world fs events www events 
www 
world contains interesting sub systems file system local machine gui event queues internet access including world wide web 
shall interested file system component fs 
file system maps filenames files fs fname file fname file file includes file data contents file state 
purposes shall simply view file data sequences integers shall adopt principle exercise file opened times reading writing 
simultaneously opened reading writing 
file state ensures sensible patterns access maintaining information files opened reading writing ensuring writer exists point keeping track number readers 
closed write read file opened file status block tracks state open file 
fstatus hwrite fname hread fname split read data portions read remaining read order simulate motion read head 
read status hread denotes file portion read section waiting 
put filename file status block facilitate process file closing sort back link filesystem 
need define file mode order able specify kind file status required fread fwrite operations give definitions operations 
shall adopt standard framework order semantics definitions kept uniform 
general operation takes control input data argument world relevant portion second argument returns tuple consisting result value modified world val world val world assume val includes possible program values 
val input result omit component 
file operations restrict file system part world fopen operation val fs val fs fopen operation takes filename file mode file system argument returns file system file status block operation defined fopen fname fs fstatus fs mode write file exist mode write file exists open mode read file exists closed open reading 
pre fopen fname fs pre fopen fwrite dom closed true pre fopen fread dom write false behaviour operation follows mode fwrite file created contents erased state set write file status block built returned 
mode fread file status set read reader count adjusted 
file status block returned read left read 
fopen fwrite hwrite write fopen fread fclose operation hread read closed fclose operation takes file status block file system argument returns file system operation defined fclose fstatus fs fs file filesystem filesystem version mode pre fclose fstatus fs pre fclose hwrite dom write pre fclose hread dom read note file exist satisfy pre condition long system filesystem files generated fopen freadi fwritei 
add condition stress important property 
behaviour operation follows file open writing file data file status block file state closed 
file open reading status block discarded count file state decremented 
count reaches zero state closed 
fclose hwrite closed fclose hread fwritei operation read closed read fwritei operation takes file status block integer arguments returns modified file status block operation defined fwritei fstatus fstatus status block mode hwrite 
pre fwritei fstatus pre fwritei hwrite true pre fwritei hread false behaviour operation follows integer appended file data sequence fwritei hwrite hwrite freadi operation freadi operation takes file status block input returns modified file status block integer result operation defined freadi fstatus fstatus status block fread mode integer read 
pre freadi fstatus pre freadi hwrite false pre freadi hread behaviour operation follows head list items read transferred tail items read list returned outcome read 
freadi hread hread model signature summary world fs events www events 
www 
fs fname file fname file closed write read fstatus hwrite fname hread fname fread fwrite fopen fname fs fstatus fs fclose fstatus fs fs fwritei fstatus fstatus freadi fstatus fstatus connecting model abstracted programs give signatures function appear model programming language model fopen fname fs fstatus fs fname fstatus clean fname fs fstatus fs haskell fname io fstatus model fclose fstatus fs fs fstatus clean fstatus fs fs haskell fstatus io model fwritei fstatus fstatus fstatus clean fstatus fstatus haskell fstatus io model freadi fstatus fstatus fstatus clean fstatus fstatus haskell fstatus io syntaxes syntax forms programming languages facilitate generation semantics 
common syntax parts syntax constant variables certain forms expression common languages defined 
common expressions start constants variables lexical entities const fopen fclose fwritei freadi fread fwrite 
var typical identifier lexemes basic expression constant variable tuple expressions application expression const const var var tuple app functional language expressions functional languages introduce patterns extend expression syntax 
patterns patn basic expressions restricted constant variables tuples patn const const var var tuple patn obtain functional expressions adding lambda abstractions expressions basic expressions const const var var tuple app abs var patn syntax statements statement cstmt assignment procedure call programs cstmt asg var call program sequence statements clean syntax clean expressions cstmt clean expressions extended hash notation clean hash elements const const var var tuple app abs var patn hash clean hash construct list hash elements binding pattern expression clean programs patn clean program basically abstraction var haskell syntax haskell expressions haskell expressions extended monadic notation const const var var tuple app abs var haskell monadic statements patn haskell syntax components look vaguely imperative statements 
monadic statement monadic assignment binding monad function call expression return haskell programs bind var haskell program basically expression usually expected expression 
real programs real programs ran 
real program include stdio int main file int fopen prog return fscanf fclose fopen prog return fprintf fclose return real clean program module prog import start fopen freadi fclose fopen fwritei fclose real haskell program import io main openfile io int hclose openfile show hclose abstracted programs simplify matters ensure focus differences inherent basic reasoning models language specific details particular languages re written functions uniform appearance io functions names structure 
io abstraction table showing abstracted io operations equivalents programming languages clean haskell fopen fopen fopen openfile freadi fscanf freadi fclose fclose fclose hclose fwritei fprintf fwritei show note haskell function form lazy read associated open reading integer 
need decision 
decision shall define haskell version freadi getchar similar 
concrete programs io abstraction abstracted program main fopen fread freadi fclose fopen fwrite fwritei fclose rename functions appropriate discard variable declarations error checking 
abstracted clean program main fopen fread freadi fclose fopen fwrite fwritei fclose remove return condition values discarding conditional 
abstracted haskell program slightly different names mainly easier distinguish haskell functions underlying model functions 
main openfile hclose openfile hclose handle io int io int isspace return cs return cs note auxiliary definition gives semantics required io model 
definition assume obvious semantics 
syntax forms transform examples fully syntax forms 
basis denotational style proofs 
syntax program asg app const fopen tuple const const fread asg app const freadi var call const fclose var asg app const fopen tuple const const fwrite call app const fwritei tuple var app const tuple var var call const fclose var syntax clean program hash tuple var var app const fopen const const fread var tuple var var app const freadi var var app const fclose var var tuple var var app const fopen const const fwrite var var app const fwritei var app const tuple var var var app const fclose var var var syntax haskell program bind app const fopen const const fread bind app const freadi var app const fclose var bind app const fopen const const fwrite app const fwritei var app const tuple var var app const fclose var denotational semantics start giving denotation semantics language 
assume semantic domains defined io model additional value components 
common semantic domains value semantic domain define semantic domain io include components domain model including world 
io world fs fstatus 
define value semantic domain val disjoint union integer values handles range io types tuples values continuous computable functions values val io handle val val val assume function maps lexical constants values const val fopen fopen 
depending paradigm may override default values modified versions 
environments shall define local variable environment finite mapping variables values var val program variable environment penv stack local variable environments represented non null sequence 
penv stack form handle nested scopes 
extend map lookup sequences maps looking maps sequence match maps exhausted 
extend map override map sequences stating acts map 
handles paradigms need hand handles information structures allow side effects occur 
shall view handle natural number map appropriate structures 
handles instances relevant structure allocated freed required 
shall parameterise handles handle mapping type information structure handle new structure handle map allocate new entry structure return handle 
handle currently 
adopt easy way guarantee handle max dom free structures really necessary semantic purposes handle environment environment env paradigm tuple containing world program variable environment components handle maps specific paradigm env world penv paradigms clean haskell 
denotation functions cases denotation program prog function world world prog world world prog top top stmt function build initial environment call denotation function top level structure strip final world value result 
note type correctness sequel assumed programs type correct functions applied correct argument type 
lot functions defined total type correct programs partial possible programs 
denotational semantics program state state program consist world environment file status handle map env world penv fstatus program denotations statement denotations pc world world pc ssc ssc cstmt env env ssc ssc ssc sc sc cstmt env env sc asg ec sc call ec app procedure call function call result discarded 
expression denotations ec env val env ec const ec var ec tuple tuple ec app ec app note function application strict arguments evaluated function call 
tuple val env val env tuple rev tuple ec builtin denotations tuple applications currently assume function expression builtin constant handle case case basis 
shall denote world highlighting file system component denote rest 
app val env val env app const fopen fopen app const fclose fclose app const fwritei fwritei app const freadi freadi note pass return handles file status blocks 
clean denotational semantics clean program state state clean program consist local environment env world components identified program variables appear local environment 
clean program denotations top level clean program application abstraction argument denotes world returns world pk world world pk ek clean expression denotations ek env val ek const ck ek var ek tuple ek ek app ek ek ek abs ek ek ek mk ek hash ek hash ek mk ek hash clean pattern match clean pattern match simply binds pattern variables values returning binding local environment mk const mk patn val mk var mk tuple mk zip record match succeeds fails point 
clean builtin function denotations clean constants denote functions directly 
exception fopen fclose need wrapper select filesystem component world ck fopen hi fopen fclose hi fclose haskell denotational semantics denotational semantics produced haskell program considered additional insight provided clean semantics gained 
denotational proofs property want show existence file called program run containing integer file exists containing integer square prior value 
denote state world program run dom closed capture initial condition writing starting state closed denote state program terminated want show prog closed shall label parts syntax easier refer components 
shall concrete syntax convenient abbreviations proof program program labelled syntax shall shorthand si 
si 
asg app const fopen tuple const const fread fopen fread asg app const freadi var freadi call const fclose var fclose asg app const fopen tuple const const fwrite fopen fwrite call app const fwritei tuple var app const tuple var var fwrite call const fclose var fclose proof pc defn 
pc defn 
pc ssc defn 
ssc defn 
ssc ssc sc introduce shorthand noting property defn ssc 
continue si ssc si si sc si ssc sc shorthand sc shorthand sc fopen fread defn 
sc asg ec fopen fread introduce shorthands see lemma cd continue read hread ec fopen fread lemma cd clause override penv shorthand prop 
si sc shorthand sc freadi defn 
sc asg ec freadi introduce shorthands see lemma cd continue hread ec freadi lemma cd clause override defn shorthand prop 
si sc shorthand sc fclose defn 
sc call ec app fclose defn 
ec var shorthands app fclose clause app fclose introduce shorthand see lemma cd continue closed app fclose lemma cd projection lemma cd ec fopen fread defn 
ec app app fopen ec fread defn 
ec tuple const app fopen fread defn 
app fopen fread closed defn 
app fopen fopen fread closed lemma cd hread read defn 
max hread read nd clause hread read st clause read hread shorthand lemma cd fopen fread closed defn 
fopen hread closed read closed closed closed 
map lookup properties hread closed read closed closed closed 
projection conditional hread closed read map property override extend hread read clause hread read lemma cd ec freadi defn 
ec app app freadi ec defn 
ec var shorthand app freadi defn 
app freadi freadi shorthands map application freadi hread defn 
freadi hread clauses hread defn 
override hread shorthands lemma cd app fclose defn 
app fclose fclose map lookup fclose hread defn 
fclose read closed 
map lookup read read closed 
st clause closed 
conditional closed clause closed shorthands defn closed override shorthands closed clauses closed shorthands proof clean program clean program labelled syntax program pronged hash hash adopt shorthand hi 
annotated labelled syntax hash tuple var var app const fopen const const fread var fopen fread tuple var var app const freadi var freadi var app const fclose var var fclose tuple var var app const fopen const const fwrite var fopen fwrite var app const fwritei var app const tuple var var fwritei var app const fclose var var fclose var proof pk defn 
pk hash defn 
pk ek hash introduce shorthand ek hash expand ek hash fopen fread defn ek ek mk ek fopen fread hash introduce shorthands see lemma kd continue hread read ek mk ek fopen fread hash lemma kd ek mk hash defn 
mk tuple map reduce ek hash override ek hash shorthand ek hash lemma kd ek fopen fread defn 
ek app ek fopen ek fread map defn 
ek const var currying fopen fread defn 
fopen ck currying application fopen fread closed lemma hread read clause hread read shorthand language semantics semantics operational character main transformation laws inference rules preserve programs meaning 
language semantics hoare triple rules hj pp change notation 
deduce assignment rule long mention hj wp rules hj change notation program language semantics assume global program variables world fs fsh denoting world file system component file system handle environment corresponding semantic variables world fs fstatus 
assume fs component world struct 
assume existence maps map manipulators language 
introduce program environment penv semantic domain 
world fs 
program initialises fsh define meaning simplifies main fsh model hoare triple form hoare triple form fopen dom write fopen fread max dom hread read closed dom closed fopen fwrite max dom hwrite write hoare triple form fclose dom hread dom read fclose closed read dom hwrite dom write fclose closed hoare triple form fwritei dom hwrite fwritei hwrite hoare triple form freadi hread freadi hread io model language form model exists solely able give hoare triple wp semantics io call 
define behaviour programming constructs ascii forms modelling concepts maps derive relevant hoare triples 
derivation hoare triple fopen read 
call equivalent dom write fopen fread lookup phi ds snd fst closed fst fst read ds phi override phi fs hread ds fsh fsh fs proceed compute post condition dom write lookup phi ds snd fst closed fst fst closed read ds read phi override phi fs hread ds hread fsh fsh fs variables visible outside fopen summarise effect fopen read dom write fopen fread max dom hread read closed derivation hoare triple fopen write 
call equivalent dom closed write phi override phi fs hwrite fsh fsh fs fopen fwrite proceed compute post condition dom closed write write phi override phi fs hwrite hwrite fsh fsh fs variables visible outside summarise effect dom closed fopen fwrite max dom hwrite write derivation hoare triple fclose read 
call fclose opened reading equivalent dom hread dom read fs lookup fsh fst fs read ds lookup phi closed read phi override phi ds fsh fsh computing dom hread dom read fs lookup fsh fst fs read ds lookup phi read closed read closed read phi override phi ds fsh fsh variables visible summarise effect dom hread dom read fclose closed read derivation hoare triple fclose write 
call fclose opened writing equivalent dom hwrite dom write write ds lookup fsh phi override phi closed ds fsh fsh computing postcondition dom hwrite dom write write ds lookup fsh hwrite phi override phi closed ds closed fsh fsh variables visible outside fopen summarise effect fopen write dom hwrite dom write fclose closed derivation hoare triple fwritei call equivalent fwrite hwrite hwrite ds lookup fsh fsh override fsh hwrite ds hwrite obtain post condition immediately 
derivation hoare triple freadi call equivalent freadi hread hread dsr lookup fsh fsh override fsh hread dsr hread obtain post condition immediately 
clean language semantics symbol letb rewrite indicate scoping form different scoping usual expression clean haskell indicated evaluation rule 
expr expr hash syntactic sugar letb expr expr reduction letb evaluation letb partial evaluation letb letb letb swap provided free letb letb evaluation io model clean language form pre fopen fwrite phi member dom phi fst lookup phi closed true fopen fwrite phi rest override phi rest hwrite write pre fopen fread phi member dom phi fst lookup phi write false fopen fread phi rest override phi rest hread ds read ds lookup phi fst closed fst fst ds snd pre fclose hwrite ds phi member dom phi fst lookup phi write fclose hwrite ds phi rest override phi closed ds rest pre fclose hread phi member dom phi fst lookup phi read fclose hread phi rest override phi ds rest read ds lookup phi closed read pre fwritei hwrite true pre fwritei hread false fwritei hwrite ds hwrite ds pre freadi hwrite false pre freadi hread rd rem rem freadi hread rd rest hread rd rest haskell language semantics notation rewritten explicit bind seq lambda forms defined haskell report desugaring bind elimination letb val desugaring seq elimination letb evaluation partial evaluation swap evaluation clean semantics 
io model haskell language form fopen fclose freadi fwritei functions clean semantics 
handle versions file operations needed encode haskell io system 
io int fstatus openfile override fs fs fopen int override fs int fs freadi fs fs lookup override fs fs fwritei fs fs lookup hclose remove fclose fs fs lookup fread fwrite max dom language proofs language proofs ones program text directly possibly extra notation 
language semantics previous section transform program condition property proved seen immediately 
language proof shall try hoare triples prove closed closed expands closed main closed condition annotated program 
closed fopen fread freadi fclose fopen fwrite fwritei fclose closed proof statement si proceed showing pi pre si having identified substitution generate pi statement pre condition fopen fread dom write show implies assuming closed try show pre condition satisfied 
dom write lemma true write prop 
calc lemma closed write defn proj closed write ineq true post condition max dom hread read closed evaluate term assumption 
max dom val 
max defn 
max arith hread val 
defn 
hread lemma hread closed defn 
proj hread read closed lemma read closed closed defn 
proj read closed closed cond read clause read val 
closed read prop 
override extend read lemma read closed defn 
proj read postcondition hread read merge obtain dropping primes read hread statement freadi show implies pre condition instance freadi hread assuming show pre condition satisfied dom hread val 
dom hread hread hread defn 
dom true hread hread prop 
calc map appl hread hread eq precondition holds true binding 
post condition freadi substitutions hread evaluate term assumption hread defn 
conc hread val 
hread hread defn 
override hread postcondition hread merge dropping primes get read hread statement fclose show implies pre condition instance fclose dom hread dom read assuming show pre condition satisfied dom hread dom read val 
dom hread hread hread dom read prop dom map appl true hread hread dom read prop 
calc eq dom read val 
dom read lemma true read prop 
calc lemma 
fs read read read eq precondition holds true binding 
post condition fclose substitutions closed read evaluate term assumption val 
defn 
closed read defn 
cond closed clause closed lemma closed read defn 
proj closed val 
read closed prop 
closed postcondition closed merge dropping primes get closed statement fopen fwrite show implies pre condition instance fopen dom closed assuming show pre condition satisfied dom closed lemma false closed prop 
calc lemma closed closed defn 
proj closed closed eq true post condition fopen substitutions max dom hwrite write evaluate term assumption max dom val 
max dom prop 
dom max arith hwrite val 
hwrite extend val 
hwrite write val 
closed write prop 
write postcondition hwrite write merge dropping primes get write hwrite statement fwritei show implies pre condition instance fwritei hwrite assuming show pre condition satisfied dom hwrite val 
dom hwrite hwrite hwrite def 
dom true hwrite hwrite prop 
calc map app hwrite hwrite eq pre condition holds true resulting binding 
post condition fwritei substitutions hwrite evaluate assumption hwrite def 
hwrite hwrite val 
hwrite hwrite prop 
hwrite val 
hwrite postcondition hwrite merge dropping primes get write hwrite statement fclose show implies pre condition instance fclose dom hwrite dom write assuming show satisfied dom hwrite dom write val 
dom hwrite hwrite hwrite dom write prop 
dom map app true hwrite hwrite dom write prop 
calc eq dom write subs dom write lemma true write prop 
calc lemma write write eq true prop 
calc holds subject substitutions 
post condition fclose substitutions closed evaluate term assumption val 
defn 
closed val 
write closed map props closed postcondition closed merge dropping primes get closed finishing proof annotated program closed fopen fread read hread freadi read hread fclose closed fopen fwrite write hwrite fwritei write hwrite fclose closed imply closed case lemma show dom val 
dom defn 
dom dom set theory rue dom true lemma show val 
fs defn 
application fs clean language proof wish show fs fs lookup phi closed phi main extend phi closed program re written hash syntactic sugar rule follows main letb fopen fread letb freadi letb fclose letb fopen fwrite letb fwritei letb fclose main extend phi closed defn 
main extend phi closed shorthand letb fopen fread extend phi closed reduction letb fopen fread extend phi closed lemma letb hread override phi read expand letb hread override phi read letb freadi partial letb override phi read letb freadi hread lemma defn freadi letb override phi read letb hread expand letb override phi read letb hread letb fclose evaluation letb hread letb fclose override phi read partial evaluation letb letb fclose hread override phi read lemma letb letb override phi closed expand letb letb override phi closed letb fopen fwrite evaluation letb letb fopen fwrite override phi closed lemma letb letb hwrite override phi write expand letb letb hwrite override phi write letb fwritei evaluation letb hwrite override phi write letb fwritei partial evaluation letb override phi write letb fwritei hwrite lemma defn 
fwritei letb override phi write letb hwrite expand letb override phi write letb hwrite letb fclose evaluation letb override phi write letb fclose hwrite evaluation letb fclose hwrite override phi write lemma defn 
fclose letb override override phi write closed prop 
override letb override phi closed evaluation override phi closed shown main extend phi closed override phi closed evaluate property lookup phi phi main extend phi closed just demonstrated lookup phi phi override phi closed clause lookup override phi closed lookup closed proof complete lemma fopen fread extend phi closed lemma defn 
fopen override extend phi closed hread ds read ds lookup phi fst closed ds snd prop 
override extend override phi hread ds read ds lookup phi fst closed ds snd eval subs 
override phi hread ds read ds fst closed closed ds snd closed eval fst snd subs 
override phi hread ds read ds closed closed ds eval ds snd cond 
subs 
override phi hread read subs hread override phi read lemma pre fopen fread extend phi closed defn pre fopen member dom extend phi closed fst lookup extend phi closed closed true defn dom member dom phi union fst lookup extend phi closed closed true prop 
member true fst lookup extend phi closed closed true cond 
fst lookup extend phi closed closed defn 
lookup 
fst closed closed defn 
fst eq 
true lemma fclose hread override phi read lemma defn fclose override override phi read ds read ds lookup override phi read closed read prop 
override override phi ds read ds lookup override phi read closed read lookup override override phi ds read ds read closed read clause override phi closed read cond clause override phi closed lemma pre fclose hread override phi read def 
pre fclose member dom override phi read fst lookup override phi read read prop 
dom member lookup true fst read read prop 
calc defn 
fst eq 
true lemma fopen fwrite override phi closed lemma defn 
fopen override override phi closed hwrite write prop 
override override phi hwrite write clause hwrite override phi write lemma pre fopen fwrite override phi closed defn 
member dom override phi closed fst lookup override phi closed closed true prop 
member dom true fst lookup override phi closed closed true cond 
fst lookup override phi closed closed lookup fst closed closed fst eq 
true lemma pre freadi hread defn 
lst eq 
true lemma pre fwritei hwrite defn 
true lemma pre fclose hwrite override phi write defn 
pre fclose member dom override phi write fst lookup override phi write write defn 
dom defn 
lookup member dom phi union fst write write prop 
member defn 
fst true write write eq prop 
calc true haskell language proof start program text transform effectively replacing notation monads expressions lambda order world explicit 
converted form main openfile hclose openfile hclose desugaring main openfile hclose openfile hclose bind seq elimination main letb openfile letb letb hclose letb openfile letb hclose definition main wish show lookup phi closed phi main extend phi closed evaluation main main extend phi closed definition main extend phi closed expansion letb openfile extend phi closed reduction letb openfile extend phi closed lemma letb override phi read override hread partial evaluation letb override phi read override hread expansion letb override phi read override hread reduction letb override phi read override hread lemma letb letb override phi read override hread partial evaluation letb letb override phi read override hread expansion letb letb hclose override phi read override hread reduction letb letb letb hclose override phi read override hread lemma letb letb override phi closed evaluation letb letb override phi closed expansion letb letb letb openfile override phi closed reduction letb letb letb openfile override phi closed lemma letb letb letb override phi write override hwrite partial evaluation letb letb letb override phi write override hwrite evaluation letb letb override phi write override hwrite expansion letb letb letb override phi write override hwrite reduction letb letb letb override phi write override hwrite evaluation letb letb override phi write override hwrite substitution letb letb override phi write override hwrite lemma letb override phi write override hwrite evaluation letb override phi write override hwrite expansion letb hclose override phi write override hwrite reduction definition hclose override phi closed shown main extend phi closed override phi closed clean proof lookup establish property 
lemmas haskell proof lemma openfile extend phi closed definition openfile override fs extend phi closed fs fopen substitution conversion override fs extend phi closed fs fopen fread reduction override fs fs fopen fread extend phi closed lemma override fs fs hread override phi read substitution override phi read override hread lemma override phi read override hread definition reduction int override phi read override fs int fs freadi fs fs lookup override hread definition lookup int override phi read override fs int fs freadi fs fs hread substitution fs int override phi read override fs int fs freadi hread definition freadi int override phi read override fs int fs hread substitution freadi override phi read override hread lemma hclose override phi read override hread definition hclose remove override phi read override hread fclose fs fs lookup reduction remove override hread fclose fs override phi read fs lookup override hread lookup substitution fs remove override hread fclose hread override phi read remove fclose hread override phi read definition fclose override phi closed substitution override phi closed lemma openfile override phi closed definition openfile substitution override fs override phi closed fs fopen fwrite reduction override fs fs fopen fwrite override phi closed substitution override fs fs fopen fwrite override phi closed lemma override fs fs hwrite override phi write substitution override phi write override hwrite lemma override phi write override hwrite definition argument substitution override fs override phi write override hwrite fs fwritei fs fs lookup reduction override phi write override override hwrite fs fs fwritei fs fs lookup override hwrite lookup substitution fs override phi write override override hwrite fs fs fwritei hwrite definition fwritei override phi write override override hwrite fs fs hwrite substitution fs override phi write override override hwrite hwrite override override phi write override hwrite bd richard bird oege de moor 
algebra programming 
series computer science 
prentice hall international london 
bir richard bird 
functional programming haskell 
series computer science 
prentice hall second edition edition 

ban tre jones le tayer 
prospects functional programming software engineering volume esprit research reports project 
springer verlag berlin 
bs erik barendsen smetsers 
uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science pp 
url ftp ftp cs kun nl pub clean papers bare ps gz 
bs andrew glenn strong 
comparing proofs programming paradigms baseline 
technical report tcd cs dublin university computer science department trinity college dublin august 
bw bird wadler 
functional programming 
series computer science 
prentice hall international london 
dav davie 
functional programming systems haskell 
cambridge computer science texts 
cambridge university press 
gor andrew gordon 
functional programming input output 
distinguished dissertations computer science 
cambridge university press 
hen henson 
elements functional languages 
computer science texts 
blackwell scientific publications 
hj hoare jifeng 
unifying theories programming 
series computer science 
prentice hall international london 
kr brian kernighan dennis ritchie 
programming language 
software series 
prentice hall nd edition 
mor carroll morgan 
programming specifications 
series computer science 
prentice hall international london nd 
edition 
ph simon peyton jones john hughes haskell 
technical report www haskell org 
url www haskell org 
pj peyton jones 
implementation functional programming languages 
series computer science 
prentice hall international london 
pve rinus plasmeijer marko van eekelen 
concurrent clean version 
technical report high level software tools university nijmegen 
url ftp ftp cs kun nl pub clean clean doc pdf gz 
sch david schmidt 
denotational semantics 
william brown iowa 

