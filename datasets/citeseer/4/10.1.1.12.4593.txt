automating type soundness proofs decision procedures guided reductions don syme andrew gordon microsoft research cambridge 
operational models fragments java virtual machine net common language runtime focus considerable study years particular interest speci cations machine checked proofs type soundness 
aim increase level automation checking type soundness formalizations 
semi automated technique reducing range type soundness problems form automatically checked decidable rst order theory 
deciding problems fragment exponential theory ecient practice time required proof checking controlled hints user 
applied technique case studies type soundness properties subsets net clr 
case studies turn aided informal analysis system 
formalizations virtual machines java virtual machine jvm net common language runtime clr focus considerable study years :10.1.1.12.7398
particular interest speci cations proofs type soundness systems frequently involving proofs interactive theorem provers 
automation available interactive theorem provers increased kind automation applied rewriting manner application tactics tend substantially ad hoc 
proof scripts needed check properties thousands lines long 
aim increase level automation applied problem focusing automated decision procedure particular form user guidance 
isolate user guidance component called guided reduction indicates extract relevant facts proof go particular cases 
applying reduction automated process transforms type soundness problem form automatically checked case splitting validity checking combination decidable rst order theories 
particular decision procedure algorithm stanford validity checker svc successfully applied large hardware veri cation proofs 
applied technique models subsets clr turn aided informal analysis system 
structured follows 
remainder section consider background including number studies jvm 
describe spark model fragment il clr explanatory purposes 
describe guided reductions new technique semi automatically converting high level statements type soundness form suitable analysis automated decision procedure 
apply combination techniques case studies discuss interesting potential avenues 
background type soundness virtual machines section consider typical structure type soundness speci cation virtual machine 
supply examples exists compare structure examined examples check fall general structure described 
structured operational semantics sos type soundness proof typically components formal description programs formal description typechecking formal description execution type soundness property 
property typically speci es certain errors occur execution ii machine progress 
formal descriptions systems complex jvm clr vary substantially speci cation methodology exact logic system formalized individual choices model operations logic 
components recognisable 
primary points departure di erent descriptions system big step small step models execution representation error conditions atomicity execution steps degree realism model execution models features optimizations 
give example forms terms predicates di erent components 
stress exact form functions predicates di er detail systems essence techniques 
programs type prog programs rog de ned structural types lists nite maps records integers strings products sums checking predicate indicating program type usually de ned compositionally terms number predicates item item indicating various sub components item welltyped context program 
execution type state states initial state set terminal states relation indicating machine state running program may take step state relations functions type soundness de ned inhabitation transition relation proposition 
terminal exists propositions typically proved invariant speci es states type recording expected shapes state structures arising runtime stack frames heap entries predicate indicating state conforms state type 
statement proposition 
terminal exists furthermore proof property ectively automatable obviously depends nature relations 
stress previous machine checking propositions applied essentially ad hoc automation techniques 
attempt achieve complete automation proofs properties ers rst step direction 
related wright felleisen systematic syntactic approach range type soundness proofs source languages aspects methodology 
prior attempted systematically apply decision procedures particular automated techniques type soundness proofs 
considerable interactive theorem proving kinds proofs 
syme java restrictive proof style applied decision procedures prove resulting obligations 
orts formalize aspects virtual machine descriptions mechanized proof checking set extensive state machine asm descriptions jvm :10.1.1.12.7398
inspired treatment general background hol theorem proving 
spark give concrete example type soundness speci cation serves motivate techniques substantially automate type soundness proofs 
larger case study discussed 
example motivated instruction set clr called spark 
describe execution veri cation spark programs programming functions caml dialect ml 
code avoids imperative features ml recursion 
directly interpret ml data structures procedures mathematical sets total functions respectively 
import code declare theorem prover interpreting ml de nitions phrases higher order logic 
program spark bytecode language consists single method implementation consisting array instructions paired signature 
ml type de nitions describe indexes particular program addresses arguments local variables de ne numeric constants instruction set 
types int float primitive type integers ieee oating point numbers 
spark intermediate language type addr int bytecode address type arg idx int argument index type loc idx int local variable index type const constant const int integer const float ieee number type instr instruction ret exit method arg idx load argument arg idx store argument ldc const load integer oat loc idx load local loc idx store local br addr unconditional branch ble addr conditional branch pop pop element stack add addition mul multiplication metadata accompanying method implementation signature describes number types arguments type result number types local variables 
item types method signatures methods type item type signed integer ieee number type msig method signature list argument types return types listg local variable types type meth method msig method signature instrs instr listg method implementation spark execution veri cation semantics description execution individual instructions line ml function step acts functional description deterministic transition relation 
type involves types item state follows items states steps type option type item item int int integer float float ieee number type state execution state item list items arguments locs item list items local variables stack item list items stack pc program counter val step meth state state option type step function space reasons omit full de nition step 
represent veri cation checks relation relies summary information typically inferred execution series veri cation checks 
nipkow shown formalize link veri cation algorithm relational view checks veri cation 
follow approach de ning veri cation checks particular instructions shared algorithmic relational speci cation 
precondition address simply list types representing shape stack prior execution address 
ml type represents precondition 
preconditions addresses method represented ml values type list indexed addresses 
stack method typings type list types items stack type addr address type type list stack type addr main subroutine function dests simulates instruction computes destinations 
depends subroutine effect simulate ect running instruction precondition 
effect msig instr option dests meth addr list option de nition functions takes lines ml code 
omit de nitions space reasons important note contain details checks need mentioned proof scripts 
remainder checks de ned relational form continue program syntax consistency 
relation hastype primary typing predicate means method typed respect stack type relation hold instructions method typed respect preconditions actual formulation precondition rst instruction empty stack 
de nition read list int option indexes list 
typing predicates match read false addr hastype addr mt match read addr true match dests addr dests dests 
mt false hastype mt addr 
addr hastype addr mt type soundness spark conformance relations section de ne means execution state conform method typing relation primary conformance predicate means execution state conforms preconditions relation hold arguments locals conform signature method precondition assigned current program counter stack conforms conformant items stack locals arguments states vt match vt int true float true false stack length stack length likewise 
st args st locs st match read pc stack false key type soundness propositions stated proposition 
hastype exists step 
want substantially automate proof similar complex propositions decision procedure combined user guidance 
controlling decision procedures guided reductions orts shown feasible machine check type soundness properties non trivial models execution veri cation certainly including propositions proposition 
techniques currently require substantial amounts human guidance 
reiterate open question practical fully automated techniques exist checking classes type soundness properties proposition simple example 
important remember execution veri cation checks arbitrarily complex example shown previous section way doing proofs realistic implementations fully featured virtual machines 
properties remain challenging fertile area applying automated techniques time come 
aim full automation seek reduce limit amount human intervention required proof ort 
pragmatic reasons interested decision procedures perform automated reasoning necessary produce simple counterexamples failed proof orts 
apply technique implemented svc equally applicable successor cvc 
procedure checks validity quanti er free formula rst order logic respect theories arithmetic products arrays maps sums conditionals 
counterexamples generated proofs fail 
svc axioms nite discrimination induction datatypes axioms uses indexed data structures apply equally lists accessed indexing functions partial functions total functions nite maps 
svc successfully proofs abstracted descriptions microprocessors 
open question decision procedures applied kind proofs described 
variations transform give decision procedure theme ad hoc basis theorem proving combination automatic transformations decision procedures occurs computing 
transformations automatic non trivial represent insight part user 
order demonstrate resorted full blown interactive theorem proving need characterization input speci ed user 
rigorously separate proof checking steps 
user speci es transformation reduces problem recognised decidable logic 
system automatically applies transformation 
resulting formula passed decision procedure returns ok counterexample 
proof divided away call guided proof checking call particular technique guided reduction 
contrast call techniques user interactively applies proof methods residue problems interactive proof checking 
techniques human interaction required just called decision procedures 
motivating guided reductions unfortunately type soundness problems may solved immediately application svc decision procedure 
consider problem immediately provable svc vt large expression stack length stack length stack stack hd stack hd stack tl stack stack stack hd stack hd stack tl stack stack stack stack stack case dup duplicate instruction proving proposition 
problem immediately solvable svc technique reasons 
operators length nth lie theories understood decision procedure procedure regards uninterpreted 
looking way way de ned universal rst order predicate lead reasoning rst order equational theories simultaneously 
rst order theorem prover throw axioms operations perform proof search 
known combining problems dicult progress determine forms problems tractable clear techniques scale large veri cation problems providing high quality counterexample feedback required 
second problem statement may include large irrelevant de nitions 
heuristic case splitting decision procedure svc easily misled presence terms 
better heuristics help ultimately de nitions needed branches proof presence branches greatly hinders automation interpretation counterexamples 
predicate de ned recursively left right list 
automated routine determine times unwind recursion 
addition number depends branch problem branches may indexed parameter example arguments consumed call instruction virtual machine 
furthermore techniques cope random access structures nite maps nicely recursive framework 
proof guidance describe technique user avoid problems associated uncontrolled unwinding large de nitions rst order quanti ers 
proof script parts speci cation set problematic predicates functions 
speci cation apply fundamental rules associated problematic predicates 
called guided reduction 
speci cation additional heuristic information necessary eciency decision procedure example case split orderings 
constitutes full input speci ed user 
formedness guided reduction checked automatically 
process applying reduction involves expanding de nitions terms representing applications rules expanding de nitions non problematic predicates functions replacing pattern matching equivalent test get form 
problem submitted decision procedure 
problematic predicates functions speci ed rst part proof script typically de nition recursive de nition involves operators lie outside theory supported target decision procedure uncontrolled expansion creates unacceptable blow proof checking times rules problematic predicates 
non problematic predicates functions typically lone equational axiom form xn xn contains problematic predicates 
problem domain problem speci cations complex shallow majority predicates problematic 
example 
problematic functions 
assume set rules available problematic predicates 
rule simply de nitions predicate may useful lemma follows immediately de nition see results derived automatically de nitional forms equations involving quanti ers xed point operators 
consider forms rules problematic predicate de nitional 
rule form 
weakening 
rule form 
strengthening 
rule form 
indexed weakening 
rule form 
indexed strengthening 
rule form 
multiple rules exist problematic predicate function 
example rules derived de nition 
stack match stack true ht tt ht tt false stack stack hd stack hd tl stack tl trivial rearrangement quanti ers de nitional rule weakening rule 
rely rules forms consider induction principles inductive relations recursive term structures example 
algebra guided reductions second part proof script speci cation apply fundamental rules associated problematic predicates called guided reduction 
consider informal speci cation guided reduction problem speci ed instruction dup apply rule input stack characterized fact twice output stack characterized fact 
informally applying reduction problem means replacing speci ed facts goals right rule leaving remaining instances uninterpreted 
problem immediately solvable decision procedure svc 
example ectively guided reductions controlled rewriting 
note uncontrolled rewriting rule terminate 
example indicates guided reductions combinators meaningful ways example chaining disjunction conditionals conditionals abstracted criteria binary instruction primitive syntactic criteria list speci instructions 
formally guided reduction predicate speci cation replacement predicate forms identity 
predicate 
rule operator 
operator corresponding rules supplied appropriate guided reductions arguments speci ed 
monotone combinator 
guided reductions combined combinators monotone anti monotone arguments examples 
guided reductions categorized weakening strengthening 
information preserving rule weakening strengthening 
fundamental property required guided reduction weakening reduction satisfy strengthening reduction satisfy 
easily demonstrated forms describe 
identity reductions problematic predicate guided reduction indicating reduction performed 
information preserving 
example guided reduction information preserving guided reduction 
rule reductions de nitional rule form problematic predicates gives rise operator parameterized predicate variables vn occurrence problematic predicate 
qn holds vn 
replacement qn replaces individual occurrences example rule gives rise operator stack match stack true ht tt ht tt false position nesting rst order connectives de ned positive negative neutral usual way markup scheme 
example variables occur positive positions right side de nition 
guided reduction form weakening likewise strengthening weakening likewise strengthening corresponding position positive strengthening likewise weakening corresponding position negative information preserving corresponding position neutral 
example guided reduction weakening weakening strengthening strengthening 
words rule de nes operator monotone anti monotone neutral predicate arguments way predicates corresponding arguments body rule 
weakening likewise strengthening indexed rules form problematic predicate give rise operator building weakening likewise strengthening guided reductions 
example indexed rule justi es random access list args match read args read true vt vt false spark rule follows de nition argument conformance 
gives operator building weakening guided reductions curried syntax extra higher order arguments 
args match read args read true vt vt false words operator lets pick index reveal fact holds furthermore reveal additional information value giving appropriate argument operators give compact notation supplying important instantiations chaining inferences 
ect advantage fact complex shallow problem domains specifying critical inferences open way automation useful amounts 
conditions apply argument predicate variables particular positive likewise negative position right de nition weakening likewise strengthening guided reduction 
example guided reduction weakening reduction information preserving 
combining reductions easy write operators combine guided reductions operator typically applied guided reductions transform goals ectively describes multiple ways proving goal 
operator applied guided reductions transform facts ectively describes derive multiple pieces information fact 
guided reductions built operators weakening strengthening arguments weakening strengthening 
reductions discard facts goals weakening strengthening true false operator lets user choose appropriate reduction condition 
strengthening strengthening likewise weakening 
operators conditionally extract extra information fact goal branches proof guard holds 
guided reductions term replacement example authoring guided reduction user directly replaces uses problematic predicates applications operators 
correctness process determined syntactically checking weakening likewise strengthening guided reductions applied facts likewise goals 
guided reductions authored forms tactics theorem prover hol isabelle 
important practical bene ts representing guided reductions predicate replacement terms type checked combination term de ning problem captures errors early terms may involve proof constants problem speci cation terms occur directly position operation reducing fragility guided reduction vis vis reorderings problem statement 
back example 
guided reduction formalized replacing predicate formulae dup dup respectively 
replacement justi ed guided reductions respectively weakening strengthening automatically checked 
application guided reduction simply involves expanding de nitions operators non problematic predicates functions applying decision procedure checks validity resulting formula 
case studies case study spark consider techniques prove proposition 
proof script required prove rst part proposition proof script spark soundness proposition hastype step problematic predicates hastype replace pc replace binop ret ble pop loc version actual proof script little arcane 
arg pc pc match read instrs pc loc match arg match rules problematic predicates derived immediately de nitions 
rule derived de nition composes guided reductions input stack locals arguments 
practice prove full soundness property step similar script proposition hastype match step false state ok really promising thing proof scripts just mentioned 
particular examine de nitions mention functions step dests effect 
decision procedure fed large term de nitions functions expanded 
process case splitting instructions failure success cases implicit execution veri cation semantics happens automatically 
applying reduction resulting formula passed decision procedure counterexample returned 
expanded problem sent decision procedure run hundreds pages subterms shared problem 
implementation svc decision procedure takes prove rst part soundness proof mhz pentium iii case splits unique terms constructed 
proof times dramatically reduced simple natural case split orderings 
example specify rst split kind instruction time reduces case splits 
producing counterexamples 
consider happens omit check veri cation rules particular omit check type item stack instruction matches type expected argument slot 
type soundness longer holds line counterexample printed containing things nth get int hd stack suggests veri er unsound instruction oating point number expected rst value stack integer value bug detected 
counterexample predicates solved give sample input unknowns exposes error 
counterexample concrete searching arbitrary terms satisfy remaining non structural constraints implemented 
case study investigating bil second case study consists verifying type soundness small step term rewriting system corresponding bil fragment described :10.1.1.12.7398
fragment included subtyping relation appropriate rules 
aspects proof scope particular guided reductions presence inductively de ned relations recursive term structures 
apart core technique described 
bil instructions veri ed corresponding soundness property include loading constant sequencing conditionals loops virtual call instructions loading storing arguments boxing inline values objects allocating new objects creating new inline objects loading address argument loading address eld object loading storing pointer 
components speci cation term model programs consisting lines ml datatype de nitions pseudo functional small step execution semantics comprising lines ml code including uninterpreted operations function resolves virtual call dispatch assumed functional type checker comprising lines ml code uninterpreted operations speci cation conformance akin 
proof assumes lemmas proved inspection weakening strengthening rules problematic predicates lemmas recursive operations write nested location struct inline value path value lemma existence heap typing records types allocations occur execution lemma connecting typechecking process term conformance predicate kind stated proved chapter 
guided reduction speci ed tabular form rows corresponding rewrite action execution semantics columns specifying guided reductions input heap stack frames input term execution step output heap output stack frames output term 
table sparse entries indicating special reasoning needed item branch proof 
left entries couple identi ers long 
contrast proof performed took lines proof script despite considerable automation 
executed proof instruction independently instruction took verify 
mistakes veri er model execution process 
directions new semi automated technique mechanically checking type soundness virtual machines case studies applying technique 
rst time svc decision procedures extensively applied problem domain previously exclusively tackled interactive theorem proving 
manual part proof technique algebra guided reductions built combinators automatically derived de nitions rules predicates functions manipulated 
guided reductions allow user control unwinding recursive de nitions give instantiations certain crucial rst order rules 
gives compact controlled way specifying information necessary di erent parts proof proof hints combined express nite proof search conditional guidance 
automated part proof uses svc validity checking quanti er free theory arithmetic structured terms 
exponential theory proved ecient controllable practice giving hints case split orderings 
mirrors experiences algorithms hardware veri cation 
described case studies applying techniques fragments clr intermediate language 
compared interactive theorem proving case studies certainly bene ted increased automation 
semi automatic proof checking process ective helping understand aspects second larger case study 
results case studies indicate problem domain highly automatable worthwhile pursue disciplined combination proof guidance proof automation 
regard possible directions certain automation applied problem domain achieving fully automated checking important classes soundness properties 
properties type soundness bene approach taken 
addition applying combination techniques new speci cations reveal transfer practice 
example applying techniques outlined extensive asm descriptions jvm determine scale larger formal models 
proof guidance technique described novel especially automatic generation combinators proof algebra speci cation basic axioms problematic predicates functions 
described inductive second order proof techniques framework 
interesting apply similar techniques problem domains 
particular strong need disciplined ways decomposing hardware veri cation properties problems independently model checked 
guided reductions may role play 

barrett dill levitt 
validity checking combinations theories equality 
srivas editors formal methods computeraided design volume lecture notes computer science pages 
springer verlag november 
palo alto california november 

barrett dill stump 
generalization shostak method combining decision procedures 
frontiers combining systems lecture notes arti cial intelligence 
springer verlag april 

voronkov 
equality reasoning sequent calculi 
handbook automated reasoning volume pages 
elsevier science mit press 

gordon syme 
typing multi language intermediate code 
th annual acm symposium principles programming languages january 

gordon melham 
hol theorem proving environment higher order logic 
cambridge university press 

jensen rgensen klarlund paige sandholm 
mona monadic second order logic practice 
tools algorithms construction analysis systems international workshop tacas lncs 

xavier leroy 
objective caml system documentation user guide 
inria rocquencourt 
available caml inria fr 

serge 
inside microsoft net il assembler 
microsoft press 

tobias nipkow david von oheimb 
java embedding programming language theorem prover 
bauer editors foundations secure computation 
proc 
int 
summer school marktoberdorf pages 
ios press 


formalised hol 
phd thesis university cambridge 


proving soundness java bytecode veri er speci cation isabelle hol 
tacas lecture notes computer science 
springer verlag 

qian 
formal speci cation java virtual machine instructions objects methods subroutines 
alves foss editor formal syntax semantics java volume lecture notes computer science pages 
springer verlag 

robert st ark joachim schmid egon 
java java virtual machine 
springer verlag 

stata abadi 
type system java bytecode subroutines 
proceedings popl pages 
acm press 

syme 
declarative theorem proving operational semantics 
phd thesis university cambridge 


machine assisted proof programming language properties 
phd thesis university pennsylvania may 

von oheimb nipkow 
machine checking java speci cation proving type safety 
alves foss editor formal syntax semantics java volume lecture notes computer science pages 
springer verlag 

andrew wright matthias felleisen 
syntactic approach type soundness 
information computation 
