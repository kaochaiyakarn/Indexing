bounded ltl model checking stable models ilkka niemela helsinki university technology department computer science engineering laboratory theoretical computer science box fin hut finland ilkka niemela hut fi bounded model checking asynchronous concurrent systems introduced promising application area answer set programming 
model asynchronous systems generalisation communicating automata safe petri nets 
shown safe petri net requirement behaviour net translated logic program bounded model checking problem net solved computing stable models corresponding program 
stable model semantics leads compact encodings bounded reachability deadlock detection tasks general problem bounded model checking linear temporal logic 
correctness proofs devised translations experimental results translation smodels system 
novel paradigm applying declarative logic programming techniques proposed 
approach called answer set programming term coined vladimir lifschitz problem solved devising logic program models program provide answers problem 
stable model semantics extended version titled bounded ltl model checking stable models th international conference logic programming nonmonotonic reasoning lpnmr vienna austria september 
financial support academy finland projects foundation technology helsinki finland gratefully acknowledged 
financial support academy finland projects gratefully acknowledged 
fairly cient systems dlv www dbai tuwien ac proj dlv smodels www tcs hut fi software smodels computing stable models logic programs 
answer set programming system problem solved writing logic program stable models capture solutions problem employing system compute solution stable model 
put forward symbolic model checking promising application area answer set programming systems :10.1.1.111.7245
particular demonstrate bounded model checking problems asynchronous concurrent systems reduced computing stable models logic programs 
verification asynchronous systems typically done enumerating reachable states system 
tools approach various enhancements include spin system supports extended state machines communicating fifo queues prod tool petri nets 
main problem enumerative model checkers amount memory needed set reachable states 
symbolic model checking widely applied especially hardware verification 
main analysis technique ordered binary decision diagrams bdds 
cases set reachable states represented compactly bdd encoding 
approach successful di culties applying bdd techniques particular areas outside hardware verification 
key problem boolean functions compact representation bdds size bdd representation boolean function sensitive variable ordering 
bounded model checking proposed technique overcoming space problem replacing bdds satisfiability sat checking techniques typical sat checkers polynomial amount memory :10.1.1.42.8033
idea roughly 
sequential digital circuit temporal property verified bound behaviour sequential circuit unfolded steps boolean formula negation property verified represented boolean formula translation boolean formulas done satisfiable system behaviour violating property length bounded model checking provides directly interesting practically relevant benchmarks answer set programming system capable handling propositional satisfiability problems 
bounded model checking applied synchronous hardware verification little attention knowledge representation issues developing concise cient logical representation system behaviour 
study knowledge representation problem employ ideas reducing planning stable model computation 
aim develop techniques behaviour asynchronous concurrent system encoded compactly inherent concurrency system exploited model checking system 
illustrate approach simple basic petri net model asynchronous systems safe place transition nets nets interesting generalisation com running example automata :10.1.1.24.6050
properties finite state systems composed finite state machine components verified model checkers safe petri nets 
structure rest 
section introduce petri nets bounded model checking problem 
develop compact encoding bounded model checking problem finding stable models logic programs 
show treat reachability properties deadlocks demonstrate extend approach cope properties expressed linear temporal logic ltl 
discuss initial experimental results concluding remarks 
petri nets bounded model checking petri net derived models literature 
nets simplest forms petri nets 
running example net fig 

triple net 
elements called places elements transitions 
places transitions called nodes 
places represented graphical notation circles transitions squares flow relation arcs 
identify characteristic function set 
preset node denoted set 
running example 
postset node denoted set 
running example 
marking net mapping 
marking identified multi set contains copies tuple net system called net net marking called initial marking 
marking graphically denoted distribution tokens places net 
running example fig 
net initial marking 
marking enables transition 
enabled occur leading new marking denoted defined 
running example enabled initial marking 
marking deadlock transition enabled running example marking deadlock 
marking mn reachable execution possibly empty sequence transitions 
markings 
mn 
mn mn marking reachable bound execution transitions reachable 
net system may infinite executions infinite sequences transitions 
markings 

maximal executions net system infinite executions net system finite executions leading deadlock marking 
marking safe 
net safe reachable markings safe 
restrict finite nets safe transition nonempty pre 
safe net say set transitions concurrently enabled marking transitions enabled ii pairs transitions holds 
set concurrently enabled marking fired step denoted marking reached firing transitions step arbitrary order 
easy prove safeness net possible interleavings transitions step enabled lead final marking running example marking step enabled lead back initial marking denoted notice enabled transition singleton set containing transition step 
say marking mn reachable step semantics safe net step execution possibly empty sequences 
sn steps 
mn markings furthermore holds 
mn sn mn marking reachable bound step semantics step execution steps reachable 
refer normal semantics interleaving semantics 
infinite step executions maximal step executions defined similar way interleaving case 
note marking reachable transitions interleaving semantics reachable steps step semantics 
converse necessarily hold 
theorem implicitly follows results :10.1.1.42.8033
theorem finite safe nets set reachable markings interleaving step semantics coincide 
linear temporal logic ltl 
linear temporal logic ltl widely logics model checking reactive systems see :10.1.1.111.7245:10.1.1.20.9147
basic idea specify properties system ltl 
model checker check behaviours system models specification formula 
model checker outputs behaviour system violates specification 
finite set ap atomic propositions syntax ltl ap note define time operator commonly tradeo case allows combination step semantics ltl model checking 
ap alphabet 
denote finite sequences excluding empty sequence infinite sequences word finite sequence 
xn infinite sequence 
word define denote su starting define length word case define greater natural number 
relation defined inductively follows ap exists define shorthand ltl formulas arbitrary fixed ap temporal operators called release eventually globally 
definition semantics ltl somewhat redundant 
done purpose ltl formulas positive normal form restricted negations allowed 
specific ltl formula said positive normal form negations formula appear directly atomic proposition 
formula put positive normal form equivalences duals note converting formula positive normal form involve blowup 
examples practical ltl formulas cs cs holds processes time critical section req ack case request eventually followed sch sch tr cs process scheduled infinitely entering process trying section followed process eventually entering critical section 
safe net chosen subset places atomic propositions ap maximal interleaving execution 
satisfies corresponding word ap ap 
satisfies 
say satisfies maximal execution starting initial marking satisfies 
alternatively satisfy exists maximal execution starting satisfies 
call execution counterexample 
notice restrict maximal executions counterexamples infinite executions finite executions leading deadlock recall definition maximal executions 
temporal logic ltl specify quite complex properties reactive systems 
cases su ces reason simpler temporal properties 
typical example reachability marking satisfying condition ltl setting corresponds finding counterexample formula important reachability problem deadlock detection 
definition deadlock detection safe net reachable marking enable transition 
analysis questions including deadlock detection ltl model checking pspace complete size safe petri net see :10.1.1.20.9147
bounded model checking fix bound look counterexamples shorter bound example case bounded deadlock detection look executions reaching deadlock transitions 
easy show bounded deadlock detection problem npcomplete bound unary coding 
idea applied ltl model checking 
bounded ltl model checking introduced :10.1.1.42.8033
discuss ensure bound su cient guarantee completeness 
unfortunately getting exact bound computationally infeasible easily obtainable upper bounds large 
case safe nets exponential number places net 
bounded model checking results usually conclusive counterexample 
bounded model checking best bug hunting easily applicable verifying systems correct 
bounded model checking answer set programming section show solve bounded ltl model checking problems answer set programming normal logic programs stable model semantics 
basic idea reduce bounded model checking problem stable model computation task devise net bound temporal property checked logic program stable models program correspond directly executions net bound violating property 
implementation stable model semantics perform bounded model checking tasks 
briefly review stable model semantics discuss couple useful shorthands encodings basis answer set programming methodology rules 
address encoding checking reachability properties extend approach handle full ltl model checking 
stable model semantics encoding bounded model checking problems normal logic programs stable model semantics 
normal rule form 

ground atom 
models program sets ground atoms 
set atoms said satisfy atom negative literal 
rule form satisfied head satisfied body literal 

satisfied program satisfied rule satisfied denoted 
stable models program sets ground atoms satisfy rules program justified rules 
captured concept reduct 
program set atoms reduct defined 



reduct contain negative literals unique subset minimal set atoms satisfying 
definition set atoms stable model program unique minimal set atoms satisfying employ extensions seen compact shorthands normal rules 
integrity constraints rules 

empty head 
constraint taken shorthand rule 

new atom 
notice stable model satisfies integrity constraint body literals satisfied 
expressing choice include atom stable model choice rules 
normal rules head brackets idea head included stable model body holds left 
construct represented normal rules introducing new atom 
example choice rule left corresponds normal rules right new atom 
compact encoding conflicts needed rules form 
saying stable model contain atoms set atoms 

rule expressed example adding rule new atom pair 
rules 
choice conflict rules simple cases cardinality constraint rules 
smodels system provides implementation cardinality constraint rules includes primitives supporting directly constraints translating corresponding normal rules 
straightforward method logic program rules answer set programming generate test idea 
set rules plays role generator capturing stable models corresponding candidate solutions set rules testers eliminate non valid ones 
systematic way method simple modularity properties stable model semantics propositions straightforward consequences splitting theorem 
propositions play important role proving correctness logic program encodings 
says rules defining new atoms added stable model original program obtained directly stable model extended program 
tester encoded stratified set rules integrity constraint 
propositions show introduce new stable models extends original ones possibly eliminates 
proposition programs atoms heads rules occur stable model atoms stable model atoms denotes set atoms appearing proposition program stratified program atoms heads rules occur stable model unique stable model atoms 
proposition program 
stable model satisfies integrity constraint ic stable model ic 
reachability checking devise method translating bounded reachability problems safe nets tasks finding stable models 
consider net step bound 
construct logic program captures possible executions steps follows 
place include choice rule 
transition 
include rule 

preset stable model contain transition instance step preset holds step place transition preset 
include rule 
say holds step preset transitions current step 
place 
cardinality postset 
include rule 
rule states transitions conflict occur 
place 


set transitions having preset 
frame axiom stating continues hold transition occurs 
disallow execution transitions followed idling 

include rules idle 
idle idle 
set transitions 
rules force idling happen followed non idling time steps 
example consider net fig 
program fig 

idle idle idle 
program initial marking constrained 
show limit markings rules construct set rules eliminates stable models satisfy boolean expression marking conditions step set includes rule set rules defining systematic translation condition step explained 
boolean expression encoded rules introducing non atomic subexpression new atom rules capturing conditions subexpression satisfied way 
boolean expression connectives subexpression form mapped rule subexpression mapped rules new atoms introduced nonatomic subexpressions 
needed atomic ones atom conditions step obtained indexing atoms encoding marking conditions illustrated considering condition saying step set rules approach solve reachability problem set initial markings condition markings reached specified condition theorem safe net initial markings satisfying condition net initial marking satisfying marking satisfying condition reachable steps stable model 
proof see appendix 
deadlock detection problem just special case reachability property rules exclude markings transition enabled 
set rules denoted consists rule live program includes transition preset 
rule live 

running example rules live live live live bounded ltl model checking strategy finding counterexamples ltl formula executions satisfying :10.1.1.42.8033
main di erence allow system model checking reachable deadlocks translation allow 
di erence previous 
counterexamples basic shapes 
left fig 
loop counterexample right counterexample loop 
loop counterexamples specify infinite execution counterexamples loop specify finite execution 
arcs denote state state 
notice loop counterexample equivalent state mn state state mn counterexamples loop additionally divided deadlock executions deadlock state non maximal executions state deadlock 
case non maximal executions encoding cautious find counterexamples exist matter non maximal execution extended maximal 
recall defined semantics mn 
il mn il mn el nl il counterexample possibilities ltl maximal executions net system 
finding non maximal counterexample executions fact optimisation 
introduced allows counterexamples smaller bounds possible :10.1.1.42.8033
encoding auxiliary atoms el le nl il intuition see fig 
example 
el atom stable model state equivalent state le model loop exists el model 
nl atom model state state il model states loop 
ltl formula positive normal form formula model checked formula equivalent negations pushed bound construct program ltl follows 
guess state equivalent 
add rule el 
disallow guessing 
guessing allowed 
add rule el el 
el 
check guess correct 
include rules el el 
specify auxiliary loop related atoms 
include rules le el nl el il el il il 
require loop exists step contains transition disallow looping idling 
add rule le idle 
positive normal form required handle non maximal counterexample executions duality see :10.1.1.42.8033
formula type translation ap ap nl nl le il live translation ltl formula allow visible transition step eliminate steps interleaved yield counterexample 
add rule 

set visible transitions transitions firing changes marking place appearing formula formally transition visible exists place ap 
recursively translate formula translating subformulas follows 
add rules fig 

require top level formula hold initial marking 
program ltl get main result 
theorem ltl formula positive normal form safe net initial markings satisfying condition program ltl stable model maximal execution initial marking satisfying satisfies proof see appendix 
equivalence explaining release translation 
completeness result translation 
define notion looping execution 
finite execution 
mn mn looping execution exists index mn looping execution index finite witness existence corresponding infinite maximal execution net system visits infinite repeating sequence states 



theorem ltl formula positive normal form safe net initial markings satisfying condition looping deadlock execution length starting initial marking satisfying corresponding maximal execution satisfies ltl stable model 
proof see appendix 
size program theorem linear size net formula 
semantics ltl defined interleaving executions 
novelty translation allows concurrency invisible transitions 
simplify ltl translation ways 
firstly net system known deadlock free release translation fig 
simplified removing rule live unnecessary subprogram 
secondly remove possibility obtaining non maximal counterexample executions release translation removed fully equivalence adding obvious translation negation 
done non maximal counterexamples equivalence hold case 
example deduce fact holds non maximal execution holds maximal execution prefix counterexample executions quite valuable practice violations safety properties smaller bounds 
chose complicated translation release 
forcing interleaving semantics 
create interleaving semantics versions bounded model checking problems adding set rules 
includes time step rule 

set transitions 
rules eliminate stable models having transition firing step 
corollary program solving bounded model checking problem step semantics translations 
program solves problem interleaving semantics 
relation previous logic programming techniques model checking branching time modal logics modal mu calculus ctl model checking reduced solving equations greatest fixed points 
state art example approach xmc system extended handle linear temporal logic ltl standard tableau style approach 
method disadvantage size resulting tableau exponential size temporal formula checked 
exponential worst case space complexity typical ltl model checkers avoided bounded model checking space complexity remains polynomial temporal formula 
previous bounded model checking little attention knowledge representation problem encoding succinctly unfolded behavior temporal property 
address problem develop encoding behavior asynchronous system linear size system description petri net formula number steps 
approach extends previous respects 
earlier research interleaving semantics 
allows step semantics enables exploitation inherent concurrency system model checking 
standard approach assumes system model checked deadlock free ltl model checking systems reachable deadlocks :10.1.1.42.8033
develop compact encoding bounded ltl model checking 
encoding linear size net formula bound 
encoding superlinear size formula :10.1.1.42.8033
provides upper bound size formula states polynomial size formula common subexpressions shared quadratic bound 
observations optimised version translation 
compactness encoding due fact stable model semantics supports fixed point evaluation recursive rules exploited translating release formulas 
simple temporal properties reachability deadlock detection approach quite directly basis similar treatment propositional logic satisfiability sat checkers 
fairly straightforward ideas clark completion fages theorem encoding produces acyclic programs choice rules need special treatment 
experiments implemented deadlock detection ltl model checking translations previous section bounded model checker called uses smodels underlying stable model finder 
implementation performs optimisations fixed initial marking place transition atoms added time step appear 
atoms places initial marking created time 
add transition atoms transitions place atoms preset exist 
ii add place atoms places place atom exists transition atom preset exists 
duplicate rules removed 
duplicates appear 
compare state art model checker nusmv nusmv irst itc contains di erent model checking engines :10.1.1.41.863
nusmv bmc bounded ltl model checker includes improvements :10.1.1.42.8033
uses zchaff www ee princeton edu chaff underlying sat solver 
second engine nusmv bdd cient implementation traditional bdd model checker 
benchmarks set deadlock detection benchmarks collected corbett hand crafted ltl model checking problems models :10.1.1.41.863
corbett models available communicating automata input language nusmv model checker 
communicating automata models converted safe nets romer 
models deadlock non trivial model check 
deadlock checking experiments model semantics increment bound deadlock 
report time smodels find stable model bound time nusmv model checker 
cases model reasonable time seconds case report time prove deadlock reported bound 
deadlock checking experimental results table 
denote fact nusmv ran mib memory limit engines comparison case 
performing state space size comparisons petri net nusmv models problems communicating automata petri net translation resulting model di erences elev hart 
excluded models comparison denoting table 
columns problem problem name size instance parenthesis 
table deadlock checking experiments problem st st int int bmc bmc bdd states dp dp dp dp key elev elev elev elev hart hart hart hart st smallest integer deadlock step semantics case largest integer prove deadlock bound step semantics 
st time seconds find stable model prove stable model 
see st 
int int defined st st interleaving semantics 
bmc bmc int int nusmv bmc bounded model checking engine 
bdd time needed nusmv bdd engine compute set reachable states find state set successors 
states number reachable states model known 
time reported average runs timing measured usr bin time command gib ram ghz amd athlon pc running linux 
time needed creating smodels input small omitted 
nusmv bmc engine directly support deadlock checking modify models slightly add proposition live models true transition enabled 
ask counterexamples loop ltl property live nusmv bdd engine forward reachability checking combined transition relation totality check limited reachable states 
default dynamic variable reordering method 
disable deadlock checking experiments time consuming unnecessary deadlock checking fairness set calculation nusmv bdd model initialisation 
table ltl model checking experiments problem st st int int bmc bmc bdd states dp dp dp dp comparing bounded model checker step interleaving semantics note experiments step semantics version finds deadlock smaller bound interleaving 
bound needed find deadlock fairly small bounded model checker performing 
examples elev hart able find counterexample step semantics 
key example able find counterexample semantics problem known small number reachable states 
contrast problem large state space despite counterexample length obtained 
comparing nusmv bmc observe step semantics translation quite competitive nusmv bmc better key 
believe mainly due smaller bounds obtained steps 
somewhat surprisingly nusmv bmc worse interleaving dp 
due translation solver di erences 
examples small fairly regular state space 
nusmv bdd engine competitive expected 
exception rule reason nusmv bdd engine uses mib memory 
results promising particular small bounds step semantics 
large collection ltl model checking problems available 
pick model family dining philosophers problems dp hand crafted ltl formula model 
nusmv bdd ltl model checking engine works deadlock free models remove deadlocks examples making deadlock state successor 
formulas checked hand crafted demonstrate potential differences proposed method :10.1.1.42.8033
study nested formulas translation complex :10.1.1.42.8033
model atomic proposition meaning fork available eat meaning philosopher eating 
model check formulas 
philosophers formula eat eat eat philosophers formula eat eat eat eat 
counterexample model formula form deeply nested formulas 
counterexample hold infinitely 
example way hold philosophers case find state eat eat eat holds 
experimental results ltl model checking table 
set experiments run time limit seconds try smaller bounds limit exceeded 
columns table deadlock checking experiments looking counterexample ltl formula 
examples nusmv run default dynamic bdd variable reordering 
experiments show step semantics able obtain counterexample dp methods unable 
nusmv bmc engine scales worse interleaving semantics translation 
investigating notice dp zchaff solver takes seconds generation sat instance solver takes seconds 
believe large part overhead due size generated ltl model checking translation 
nusmv bdd ltl model checker scaling worse corresponding deadlock checking examples observed number bdd operations required ltl model checking significantly larger 
tools models formulas logic programs available www tcs hut fi experiments 
introduce bounded model checking asynchronous concurrent systems modelled safe nets interesting application area answer set programming 
mappings bounded reachability deadlock detection ltl model checking problems safe nets stable model computation 
approach capable doing model checking set initial markings 
usually di cult achieve current enumerative model checkers leads state space explosion 
handle asynchronous systems step semantics previous bounded model checking uses interleaving semantics :10.1.1.42.8033
furthermore encoding compact previous approach employing propositional satisfiability :10.1.1.42.8033
rule approach allows represent executions system frame axioms succinctly supports directly recursive fixed point computation needed evaluate ltl formulas 
feature ltl translation require deadlock freeness assumption employ systems proved deadlock free :10.1.1.42.8033
experimental results indicate stable model computation quite competitive approach searching short executions system leading deadlock worth study 
experimental comparisons needed determine strength approach 
particular comparing sat checking techniques interesting develop similar treatment asynchronous systems sat encoding compare logic program approach 
relating net unfolding method see bounded model checking interesting 
alternative semantics applying bounded ltl model checking left 
best devillers :10.1.1.42.8033
sequential concurrent behaviour petri net theory 
theoretical computer science 
biere cimatti clarke zhu :10.1.1.42.8033
symbolic model checking bdds 
tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer verlag march 
burch clarke mcmillan dill hwang 
symbolic model checking states 
information computation 
cimatti clarke giunchiglia giunchiglia pistore roveri sebastiani :10.1.1.41.863
nusmv opensource tool symbolic model checking 
proceeding th international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag july 
cimatti pistore roveri sebastiani 
improving encoding ltl model checking sat 
proceeding workshop verification model checking interpretation volume lecture notes computer science pages 
springerverlag january 
clarke grumberg peled :10.1.1.111.7245:10.1.1.20.9147
model checking 
mit press 
corbett :10.1.1.41.863
evaluating deadlock detection methods concurrent software 
technical report department information computer science university hawaii 
desel reisig :10.1.1.24.6050
place transition petri nets 
lectures petri nets basic models volume lecture notes computer science pages 
springer verlag 
esparza :10.1.1.20.9147
decidability complexity petri net problems 
lectures petri nets basic models volume lecture notes computer science pages 
springer verlag 
fages 
consistency clark completion existence stable models 
journal methods logic computer science 
gelfond lifschitz 
stable model semantics logic programming 
proceedings th international conference logic programming pages 
mit press august 

logic programs stable model semantics solve deadlock reachability problems safe petri nets 
fundamenta informaticae 

bounded reachability checking process semantics 
proceedings th international conference concurrency theory concur volume lecture notes computer science pages 
springer verlag august 
niemela 
bounded ltl model checking stable models 
proceedings th international conference logic programming nonmonotonic reasoning lpnmr volume lecture notes computer science pages 
springer verlag september 
holzmann 
model checker spin 
ieee transactions software engineering 
lifschitz :10.1.1.43.2727
answer set planning 
proceedings th international conference logic programming pages 
mit press december 
vladimir lifschitz hudson turner 
splitting logic program 
proceedings eleventh international conference logic programming pages cambridge mass 
mit press 
marek truszczynski 
stable models alternative logic programming paradigm 
logic programming paradigm year perspective pages 
springer verlag 
romer 
deadlock checking net unfoldings 
proceeding th international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag june 
moskewicz madigan zhao zhang malik 
cha engineering cient sat solver 
proceedings th design automation conference dac pages 
acm june 
niemela 
logic programming stable model semantics constraint programming paradigm 
annals mathematics artificial intelligence 
niemela simons 
extending smodels system cardinality weight constraints 
minker editor logic artificial intelligence pages 
kluwer academic publishers 
robert ramakrishnan 
model checking linear temporal logic tabled logic programming 
workshop tabulation parsing deduction 
ramakrishnan ramakrishnan smolka dong du 
xmc logic programming verification toolset 
proceedings th international conference computer aided verification cav volume lecture notes computer science pages 
springerverlag 
lilius 
prod advanced tool cient reachability analysis 
proceedings th international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag june 
proofs proof theorem recall proof objective 
safe net initial markings satisfying condition want prove net initial marking satisfying marking satisfying condition reachable steps stable model 
proof lemmata establish correspondence stable models bounded step executions safe net say step execution 
mn sn mn derived stable model 


lemma safe net initial markings satisfying condition stable model step execution starting initial marking satisfying proof consider step execution derived stable model 
satisfies rules marking satisfies condition show valid step execution starting showing step execution valid marking valid holds 

consider 
stable model supported implies rule head body literals satisfied 
candidate rule place preset implies transition enabled satisfies rules concurrently enabled marking concurrently enabled step holds safe net 
complete proof showing holds consider place 

rule head body literals satisfied 
types candidate rules 
case body satisfied transition implying condition holds 
body satisfied transition having preset implies condition holds 
condition holds 
rule type condition holds transition 
satisfies rule lemma safe net initial markings satisfying condition step execution empty steps initial marking satisfying containing steps stable model derived step execution 
mn sn mn step execution execution empty steps added 
proof step execution initial marking satisfying steps 
step execution 
mn sn mn steps empty sn mn consider set atoms idle 
idle atoms corresponding subexpressions condition satisfied show stable model establishing ii imply minimal set atoms satisfying 
construction rules satisfied 
consider rules case case show rules resulting satisfied 
rules resulting satisfied directly construction 
consider rule assume 
implies 
rule satisfied concurrently enabled implying contain transition sharing place 
consider reduct rule case 
transition postset 
transition preset implying 
rules straightforwardly satisfied construction 
holds 
ii consider set assume atom atom place fact similarly idle corresponding fact consider atom smallest index suppose implies case satisfies rule type case implies cases holds implying implying enabled place preset place preset satisfies rule 

preset contradiction 
proof theorem 
stable model proposition stable model atoms 
lemma step execution starting initial marking satisfying satisfies rule marking mn satisfies condition 
initial marking satisfying marking satisfying condition reachable steps lemma stable model derived step execution 
mn sn mn step execution mn rules stratified heads occur 
proposition unique stable model atoms 
mn satisfies condition satisfied implying proposition stable model 
concludes proof theorem 
proof theorem recall proof objective 
ltl formula positive normal form safe net initial markings satisfying condition want prove stable model ltl program ltl construct maximal execution net system initial marking satisfying satisfies proof proceeds follows 
derive step execution stable model ltl create maximal step execution index obtained ltl show maximal interleaving execution obtained show lemma stable model ltl step execution net system initial marking satisfying proof proposition ltl obtain stable model subprogram lemma execution step execution starting initial marking satisfying stable model step execution obtained proof lemma 
show adding rules evaluate marking reached deadlock 
lemma stable model stable model 
live marking reached deadlock 
proof rules stratified 
proposition unique stable model atoms 
live rule body satisfied atoms body satisfied enabled transition marking reached 
direction enabled transition marking 

preset 
live proposition ltl lemma show live ltl marking reached deadlock 
case analysis di erent types counterexamples 
stable model ltl belongs exactly mutually exclusive cases nl ltl infinite maximal execution represent pair nl ltl nl ltl live ltl finite maximal execution represent pair nl ltl live ltl non maximal execution represent pair 
analyse stable model ltl lemma holds di erent cases ltl nl ltl nl ltl le ltl il ltl live ltl nl ltl live ltl le ltl live ltl nl ltl live ltl le ltl proof rule nl head nl el get el ltl rule satisfied know holds el ltl le el know le ltl rules il el il il fact el ltl combined simple induction get il ltl rules imply mn rule le ltl get idle ltl step sn non empty 
mn step sn non empty implies mn deadlock live ltl nl ltl know el ltl 
rules having le head rules form le el le ltl record facts discovered proof lemma case 
corollary case holds mn step sn non empty 
state additional property show maximal step execution obtained pair 
lemma step contains visible transition 
proof proposition rules subprogram ltl 
lemma stable model ltl maximal step execution net system initial marking satisfying proof cases initial marking satisfies case know corollary mn generate infinite maximal step execution pair 
corresponding infinite step execution mn sn mn mn sn mn know corollary step sn non empty 
contains infinitely non empty steps 
case step execution maximal step execution case pick interleaving execution concatenation followed maximal step execution state existence maximal executions stable model ltl lemma stable model ltl maximal interleaving execution net system initial marking satisfying proof procedure described obtain maximal step execution ltl removing idle time steps maximal step execution replacing step linearisation permutation transitions step construct maximal interleaving execution initial marking initial marking satisfies words corresponding step executions discussed respectively 
prove ltl formula need technical notion stuttering equivalence words 
intuition equivalence words stuttering equivalent satisfy exactly ltl formulas 
definition stuttering equivalence motivated similar definition chapter longer discussion :10.1.1.111.7245:10.1.1.20.9147
definition words stuttering equivalent infinite words infinite sequences positive integers 

property crucially depends non existence time operator definition ltl 
finite words exist integer finite sequences positive integers 

proposition proved simple induction structure formula definition ltl semantics 
proposition ltl formula stuttering equivalent words 
lemma words corresponding maximal execution maximal step execution stuttering equivalent 
proof lemma implies step consists visible transition case su interleaving definition 
step execution contains visible transition 
step replaced linearisation proof lemma step changed possibly empty stuttering original atomic propositions possibly followed change followed possibly empty stuttering new atomic propositions 
step replaced stuttering equivalent sequence implying sequence stuttering equivalent 
lemma implies correctly evaluate ltl formula word correctly evaluate know correctly evaluate ltl formula word know prefix word index case 
evaluation case exact case approximate case known su word evaluating formula assume finite word length index knowledge case 
induces word case cases su cient assumptions base program call stable model want show adding translation formula fig 
obtain program unique stable model respects semantics ltl sense di erent cases case specifies prefix word 
encoding cautiously approximates semantics ltl formulas presence uncertainty su notice case word cyclic semantics ltl follows cycle evaluate su ces evaluate assumptions program stable model follows 
atoms appearing heads ltl translation occur program 

exactly cases nl nl le il live nl le live nl le live lemma assumptions stated hold base program stable model program obtained adding translation ltl formulas fig 
stable model follows semantics ltl proof note assumption 
proposition fact translation fig 
stratified imply stable model combined program exists unique 
proof induction structure formula assume translation subformulas follow semantics ltl 
prove translation follows semantics ltl 
case split formula type ap ap assumption 
translation directly follows semantics ltl 
show follows semantics ltl establishing ii follows semantics ltl proof equivalence valid operator suppose cases implying rule supporting 
holds extending case 
consider case 
suppose implies stable model contradiction 
take smallest index suppose implying stable model contradiction 
implies inductive hypothesis holds 
suppose holds 
case holds rule case rules translation 
ii suppose supporting rule head body literals satisfied candidate rules 
inductive hypotheses case second case imply direction cases 
rules inductive hypotheses follows holds 
show follows semantics ltl establishing ii follows semantics ltl 
consider case 
rules supporting direction implying case rule supporting implies extending cases condition holds 
consider case equivalence ltl formulas 
consider cases case implies case 
show similar argument previous case operator 
implies rules nl evaluation rules formula 
case case condition holds 
ii equivalence valid imply direction possible rules supporting 
imply condition ii holds 
final proof theorem 
ltl stable program ltl 
lemma obtain ltl maximal interleaving execution initial marking satisfying consider subprogram consist rules ltl 
proposition lemma stable model ltl projected atoms satisfies assumptions required lemma 
lemma lemma imply stable model ltl word corresponding maximal step execution holds word stuttering equivalent word corresponding lemma proposition implies stable model ltl rule implies ltl completes proof theorem 
proof theorem recall proof objective 
ltl formula positive normal form safe net initial markings satisfying condition want prove looping deadlock execution length starting initial marking satisfying corresponding maximal execution satisfies ltl stable model 
know deadlock looping execution call length corresponding maximal execution holds mutually exclusive cases looping execution 
notice case sn step non empty 
loss generality select minimal index mn corresponding maximal execution maximal execution visits sequence states 



deadlock execution 
case maximal execution set di erentiate previous case 
note case proof theorem needed consider non maximal executions 
lemma implies program stable model derived execution obtained adding empty steps execution 
keep name step execution derived adding idle steps add idle steps corresponding maximal execution 
loop point increased compensate addition idle steps 
clearly obtained step execution length deadlock execution original looping execution original corresponding maximal execution satisfies formula addition idle steps word corresponding extra copies stuttering initial atomic propositions proposition detected ltl formula 
assume length exactly consider program consists rules program ltl 
pair show program stable model capturing essential properties 
lemma pair construct stable model program claims stated hold 

exactly cases nl nl le il live nl le live proof proofs case case know claim holds stable model program derived 
know lemma fact derived stable model program stable model live loop execution deadlocked deadlock execution 
stable model incrementally add rules program head atoms appear program added 
step prove stable model extended program exists 
proposition project final stable model atoms obtaining fulfils claim part second claim 
rest second claim proved incrementally stating properties stable models extending stable model satisfies rest second claim 

add shorthand rules obtaining program show stable model exists extends follows 
case analysis el el el case shorthands contribute reduct fact el fact el clearly smallest set removing el el leave corresponding fact unsatisfied 
stable model case similar fact el reduct fact el 
add integrity constraints obtaining stable model case integrity constraint satisfied el index loop execution integrity constraints satisfied 
case el indices integrity constraint satisfied integrity constraints satisfied 

add rules obtaining added rules stratified proposition unique stable model exists extends follows 
case analysis le nl il proof case proceeds starting fact el get le nl il get il simple induction rules il il 
case el indices implies rules satisfied stable model 

add rule obtaining integrity constraint satisfied case step sn non empty looping executions 
integrity constraint satisfied case le cases stable model 
add integrity constraints obtaining integrity constraints satisfied time step contains transition 
stable model setting shown stable model program projected atoms proposition satisfies claim part second claim concerning atom live rest second claim incrementally proved cases 
program consists translation ltl formula fig 
finite word corresponding execution lemma lemma fact implies program stable model 
recall case evaluation corresponding maximal execution exact 
add constraint rule program obtain full program 
integrity constraint satisfied stable model 
completes proof theorem 

