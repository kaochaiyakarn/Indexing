journal artificial intelligence research submitted published flecs planning flexible commitment strategy manuela veloso peter stone department computer science carnegie mellon university pittsburgh pa usa cmu edu cmu edu evidence commitment planners efficiently handle planning problems involve difficult goal interactions 
evidence led common belief delayed commitment best possible planning strategy 
evidence eager commitment planners handle variety planning problems efficiently particular difficult operator choices 
futility trying find universally successful planning strategy devised planner study domains problems best planning strategies 
article introduce new planning algorithm uses flexible commitment strategy respect plan step orderings 
able strategy delayed commitment eager commitment 
combination delayed eager operator ordering commitments allows flecs take advantage benefits explicitly simulated execution state reasoning planning constraints 
flecs vary commitment strategy different problems domains course single planning problem 
flecs represents novel contribution planning explicitly provides choice commitment strategy planning 
flecs provides framework investigate mapping planning domains problems efficient planning strategies 

general purpose planning long history research artificial intelligence 
different planning algorithms developed ranging pioneering gps ernst newell variety algorithms snlp mcallester rosenblitt family 
basic level purpose planning find sequence actions change initial state state satisfies goal statement 
planners actions provided domain representations try achieve goal 
different planners different means 
faced variety different planning algorithms planning researchers including authors increasingly curious compare different planning gies 
general purpose planning known undecidable chapman common belief commitment planning best efficient planning strategy planning problems 
belief evidence commitment planners efficiently handle planning problems involve difficult plan step interactions barrett weld kambhampati minton bresina drummond 
delayed commitments particular step orderings allow plan ai access foundation morgan kaufmann publishers 
rights reserved 
veloso stone steps remain unordered interactions visible 
similar situations eager commitment planners may encounter severe efficiency problems early commitments incorrect orderings 
engaged investigation sorts planning problems handled efficiently planning strategies 
planning driven heuristics identified different sets heuristics correspond different planning methods 
designed sets planning domains problems test different planning strategies 
studying impact different strategies different kinds planning problems came evidence eager commitment planners efficiently handle variety planning problems particular difficult operator choices stone veloso blythe 
date state allows informed planning choices particularly terms operator alternatives available 
similar situations delayed commitment planners may need backtrack incorrect operator choices veloso blythe 
came believe planner consistently better different domains problems 
futility trying find universally successful planning strategy felt need study domains problems best suited planning methods 
order devised implemented planner operator ordering commitment strategy continuum extreme delayed commitment eager commitment 
planner completely flexible dimension planning heuristics operator ordering commitments 
main contribution completely describe planning algorithm put forth tool studying mapping heuristics domains problems 
risking possibility planner get overlooked relegated architecture section cs underlying philosophy contribution right 
continuum heuristics explored planning algorithm lies operator ordering commitment strategies delayed commitment eager commitment backward chaining planners situate broad range planning problem solving methods 
possible planning strategy search possible states reached initial state find satisfies goal 
method called progression forward chaining impractical 
accessible states world efficiently search complete state space 
alternative planners constrain search regression backward chaining 
considering possible actions executed initial state searching recursively forward state space search backwards goal 
search driven set actions directly achieve goal 
main ways performing backward chaining 
planners regression searching space possible plans 
planners noah tweak snlp 
commitment planners really delay commitments plan step orderings variable bindings 
article term delayed commitment contrast eager commitment context step orderings 

similar concerns regarding different constraint satisfaction algorithms led design multi tac architecture minton 
system investigates problem find combination heuristics collection available ones solve problem efficient way 
flecs planning flexible commitment strategy descendants chapman mcallester rosenblitt mcdermott sacerdoti tate wilkins plan space planners delayed commitment strategy 
particular delay decision ordering operators long possible 
consequently planner reasons initial state set constraints regressed goal 
hand planners gps strips prodigy family carbonell knoblock minton fikes nilsson rosenbloom newell laird eager commitment strategy 
backward chaining select plan steps relevant goals 
eager commitment plan explicit internal representation state world internal state order operators possible reason updated version state 
trade risk eager commitment benefits explicit updated planning state 
article introduce planning algorithm cs uses flexible commitment strategy respect operator orderings 
fl cs designed provide planning researchers framework investigate mapping domains problems efficient planning strategies 
algorithm represents novel contribution planning introduces explicitly choice commitment strategy 
ability change commitment strategy useful studying tradeoffs delayed eager commitments 
flecs descendant prodigy current implementation directly top prodigy 
extends prodigy reasoning explicitly ordering alternatives having ability change commitment strategy different problems domains course single planning problem 
article gradually introduces cs 
section gives top level view algorithm describes different ways uniquely specified state world 
section introduces concepts algorithm 
provide annotated example illustrate details planning concepts defined 
section presents css planning algorithm full detail explains algorithm step step 
discuss different heuristics guide css choices particular flexible choice commitment strategy 
analyze advantages disadvantages delayed eager plan step ordering commitments 
section shows specific examples planning domains problems devised support need flexible commitment strategy 
performed empirical analysis planning performance domains 
corresponding empirical results demonstrate tradeoffs discussed show evidence flexible commitment necessary 
section draws 

planners prodigy family include prodigy minton knoblock kuokka gil joseph carbonell veloso prodigy carbonell blythe etzioni gil joseph kahn knoblock minton reilly veloso wang 
prodigy opposed prodigy require linearity assumption goal independence search spaces complete fink veloso 
control commitment choices opposed earlier total order planners 

needed new name algorithm flecs represents significant change philosophy implementation prodigy 
veloso stone 
top level view flecs prodigy flecs differ significantly state art planning systems search solution planning problem combining backward chaining regression simulation plan execution veloso 
back chaining commit total ordering plan steps uniquely specified world state 
planners maintain internal representation state update simulating execution operators relevant goal backward chaining 
note simulating execution planning differs interleaving planning execution option un simulating rolling back remain open 
interleaved planning execution generally done separate modules planning monitoring executing replanning steel 
flecs delay eagerly carry plan simulation 
way planning algorithm flexibility able delay operator ordering commitments able effects previously selected operators help determine goals plan operators achieve goals 
short emulate delayed commitment planners eager commitment planners 
table shows top level view fl cs algorithm 

initialize 

terminate goal statement satisfied 

compute pending goals applicable operators 
pending goals achieved preconditions operators selected plan 
applicable operators preconditions satisfied current state 

choose subgoal apply backtrack point subgoal go step 
apply go step 
select pending goal backtrack point operator achieve backtrack point go step 
change state specified applicable operator backtrack point go step 
table top level view flecs 
step numbers correspond step numbers detailed version algorithm table section refines steps adds additional necessary step 
terms table fully described detailed version algorithm section 
section focus main characteristics algorithm internal state flexibility respect commitment strategies 
flecs planning flexible commitment strategy simulated planning state flecs uses internal state purposes 
terminates goal problem current version state current state point complete plan sequence operators transformed initial state current state hs nd planning process cn 
second cycle uses internal state determine goals need planned nd hve means ends strategy 
planners ll possible effects operators hve changed initial state rl cs simply checks goal true current state 
third planner uses state determine operators preconditions re ll true state 
fourth rl cs cn state choose operator nd bindings re goal minimum planning effort blythe veloso 
nd fl cs uses state determine goal statement hs step goals need step operators re step operators try planning step 
planners keep internal state ll steps require considerable planning effort re ll 
contrast fl cs cn perform steps sub quadratic time 
furthermore planners hve ny methods choosing possible operators goal 
state hs shown provide significant efficiency veloso blythe 
rl cs state big difference chooses change state apply operator time 
operator informed planning results ech bove steps 
choice operator involves commitment order operator ll operators hve 
commitment temporary plan cn operator position operator cn un simply changing internal state bck previous status 
requirement operators explicit order opens possibility exponential 
planning 
due state fl cs cn reduce likelihood requiring operator choice point 
doing increase likelihood operator ordering choice point 
hs flexibility ble come side tradeoff 

note goal state fully instantiated matching accomplished constant time goal hash table literals 
veloso stone choice commitment strategies order control tradeoff eager delayed state changes flecs toggle determines algorithm prefers subgoaling applying operator step 
option flecs considers may affect path search space consequently planning efficiency 
ability accommodate different types search novel part algorithm 
significance lies difference subgoaling applying 
difference subgoaling applying illustrated 
subgoaling best understood regressing goal backward chaining means ends analysis 
includes choices goal plan operator achieve goal 
seen section choices affected flecs internal state 
subgoaling updating internal state applying operator lead uninformed planning decisions 
hand subgoaling extensively flecs select large set operators appear plan deciding order apply 
flecs takes account conflicts threats operators orders appropriately applying 
subgoaling operator achieves precondition operator true state applying preconditions operator true state applying changes state 
diagram fink veloso illustrates difference sub applying 
search node consisting head plan 
head plan contains operators applied changed initial state current state tail plan consists operators selected achieve goals goal statement operators selected achieve preconditions operators shows planner subgoal apply search node 
applying operator flecs way changing current internal state subgoaling decisions informed 
applying operator com temporary backtracking possible operator executed flecs planning flexible commitment strategy 
essential tradeoff eagerly subgoaling eagerly applying eagerly subgoaling delays ordering commitments delayed commitment eagerly applying facilitates informed subgoaling eager commitment 
cs switch toggle change behavior eager subgoaling eager applying vice versa time 
feature significant improvement flecs prodigy predecessors 
saw evidence delayed commitment eager commitment search strategies consistently effec tive stone felt need provide fly cs toggle 
fly cs combine advantages delayed commitments eager commitments 

illustrative example section example illustrates detail planning situations arise general planning problem 
planning may understood general past descriptions planning algorithms directly addressed situations full detail 
ftv cs algorithm designed handle situations 
order describe fly cs completely need define variables maintained algorithm proceeds 
easier understand algorithm familiar concepts variables denote annotated example figures formally presenting fly cs 
recommend variables functions change annotated example definitions represents current internal state planner 
uses summarized section 
set goals subgoals planner aiming achieve 
goals fringe subgoal tree 
goals may goals planned goals achieved trivially operator needs preconditions operator applied 
set pending goals goals may need planned current state 
stands set instantiated operators selected achieve goals subgoals 
set applicable operators operators preconditions satisfied current state needed current state achieve goal 
goal set ancestor goal sets sequences goals caused member 
trivially goal ancestor preconditions operator selected achieve goal 
set sets different sets ancestors 
concept clearer example 

section discuss different heuristics guide choice discuss view toggle perfect focus learning 
veloso stone operator set goals selected achieve causes 
applying establishes member 
illustrated functions needed determine goals pending operators applicable 
analogous causal links determine threats planners chapman mcallester rosenblitt 
sequence planning decisions example de signed illustrate uses variables functions 
recommend familiar spending time carefully tracing values returning definitions example 
note figures show tail plan mention applied operators state changes text 
goals circles solid circles true dashed circles true current state 
operators boxes arrows pointing goals produce goals operators selected achieve causes 
turn preconditions operators goals arrows pointing operators consume 
operators applicable current state appear bold boxes 
changes functions underlined captions 
example 
shows initial planning situation consider planning problem literals goal statement ga ga 
literal initial state 
goals true initial state operators selected operators applicable point top level goals goals ancestors applicable operators step subgoal pending goals 
gl gl example initial specification planning situation 
shows planning situation lics subgoals suppose operator preconditions selected achieve chosen achieve indicated 
note operators preconditions replace causes set fringe goals true current state included set pending goals 
cause similarly flecs planning flexible commitment strategy 
new goals nonempty ancestor sets go 
applicable operators applied go applied rl cs subgoals 
oa gt resulting planning situation subgoaling 
shows planning situation flecs subgoals 
suppose operator selected achieve preconditions gs 
gs 
causes operators change previous step 
similarly go remain unchanged 
sets ancestor goals 
understand need keep ancestor sets consider possibility achieved unexpectedly side effect unrelated operator achieved planned 
case remain pending goal needed achieve 
applicable operators fl cs subgoal pending goals 
go resulting planning situation subgoaling 
veloso stone shows planning situation subgoals 
suppose operator precondition 
selected achieve 

true current state applicable operator 
note necessarily ordered cause precondition operators 
usual cause new operator stored 
addition ancestors 
augmented include new ancestor sets cl 
applicable operator assume flecs chooses delay commitment order step plan subgoals pending goal 
go gs 

gz resulting planning situation subgoaling 
shows planning situation flecs subgoals 
suppose oper ator achieve selected 
need update causes operator ancestors precondition 
subgoaling remaining pending goal apply 
note decision corresponds early commitment terms ordering operators operators selected achieve unordered current planning constraints 
pub cs changes delayed commitment strategy eager commitment strategy 
gd resulting planning situation subgoaling 
flecs planning flexible commitment strategy shows planning situation fly cs applied 
operator wets order gs etre true current fringe tree etre 
notice consumed 
etre true current etre pending 

precondition selected ets 
etre ets preconditions etre true current 
fly cs commitment continues oper 
fly cs orders deletes precondition effects etre shown 
resulting 
shows mv cs suppose wets selected ets side effect 
hets effect wets visible simply looked promising ets ett time wets selected 
gs 
resulting 
veloso stone case gt planning done longer needed longer pending goal sole ancestor fortuitous achievement goal reason need functions adjust sets pending goals applicable operators wasted effort flecs plan achieve 
note precondition pending goal relevant achieving 
point ancestors reset 
pending goals flecs apply remaining applicable operator 
shows final planning situation flecs applied point top level goals true current state 
despite fact planning tree remains flecs recognizes done terminates 
final plan sequence operators applied head plan shown corresponding steps figures 
algorithm veloso carbonell convert sequence partially ordered plan capturing dependencies 
final planning situation applying 
flecs detailed description aside variables functions introduced preceding section need define things presenting complete algorithm 
initial state goal statement corresponding ground literals problem definition 
sec ond operator pre add del instantiated preconditions add list delete list respectively 
ri cs takes values straight domain representation may include disjunctions negations existentially universally quan preconditions effects conditional effects carbonell 
conditional effects add del determined dynamically state time applied 
third relevant instantiated operators achieve step operators operators fully specified bindings flecs planning flexible commitment strategy add positive goal del negative goal 
fourth toggle variable determines flavor search described 
planning algorithm planning algorithm full detail table 
examining algorithm notice fringe goals selected operators ancestor function cause function current state maintained incrementally 
hand pending goals applicable operators toggle recomputed pass algorithm 
step initializes variables 
planning process goals goal statement current state initial state operators selected empty 
ancestor function cause function initialized constant function maps practice domain set goals domain set operators appear problem 
goals operators determined algorithm called initialize functions unrestricted domains 
step termination condition 
called time new operator applied 
algorithm terminates successfully goal goal statement true satisfied current state step sets pending goals applicable operators computed current state 
pending goals goals planner may need plan 
initially pending goals fringe goals currently true true initial state 
applicable operators selected operators preconditions true state 
step computes pending goals applicable operators active current state 
pending goal active long fringe subgoal tree needs planned 
goal longer active ancestor sets goal achieved purposes goal selected longer exist case 
applicable operator active current state long achieve goal useful plan 
applicable operator longer active causes true current state longer active 
step novel part algorithm 
allows flexible search strategy single planning algorithm 
step fl cs terminated active pending goals active applicable operators non empty 
choice 
hand non empty proceed step step 
sake completeness keep options open option flecs considers may affect amount search required 
changing 
detail algorithm allows reader carefully study re implement flecs 

planner backtrack initial state keep goals initial state pending goals sake completeness 
veloso stone 
initialize goal statement 
initial state 

vg 
vo 
terminate goal statement 
compute applicable operators pending goals 
initial state 
pre 

adjust contain active members ss oc 
current state fringe goals pending goals instantiated operators applicable operators ancestor goal sets causes vg vs 

subgoal apply set reset toggle sub app set default delayed eager commitment 
go step 
go step 
choose apply subgoal backtrack point toggle sub subgoal go step 
toggle app apply go step 
choose goal backtrack point 
choose goal true current state means ends analysis 
get set relevant instantiated operators achieve ii 
fail backtrack 
iii 
go step 
choose operator backtrack point 
choose operator minimum conspiracy number operator appears achievable amount planning 
ou 


vg pre 
go step 
choose operator backtrack point interactions 
heuristic find operators fewer interactions similar heuristic 
apply add del 
vg pre st 
pre 

go step 
table full description flecs 
flecs planning flexible commitment strategy value toggle done pass loop flecs change type search works problem 
pass body algorithm visits step step 
subgoaling step active pending goal chosen 
note corresponding choice step choice subgoals backtrack point 
operators achieve goal goal chosen step 
means ends analysis heuristic prefer subgoaling goals currently true 
operator chosen achieve chosen goal step 
new operator existing selected achieve selected achieve cs 
choice operator backtrack point 
heuristic provided minimum conspiracy number heuristic determine operator tried blythe veloso 
short heuristic selects instantiated operator appears achievable amount planning 
returning top loop affected variables updated 
added set union operator appears twice step 
second preconditions added removed step operator selected achieve longer fringe subgoal tree 
third cause augmented include step 
fourth ancestor sets preconditions augmented include sets goals comprised ancestors step 
explained ancestor sets included 
state changed termination condition met 
algorithm returns step 
applying operator step applicable operator chosen 
heuristic analyzes applicable operators choose best possible operator 
heuristic analyzes interactions operators identifying negative threats similarly heuristic stone 
short heuristic prefers operators delete preconditions effects deleted operators 
choice applicable operator backtrack point orderings interacting applicable operators considered 
different orderings completely independent operators need considered 
completely independent operators interactions ancestor sets 
application operator difference application need consider ordering operators 
chosen promptly applied step 
application involves changing current state prescribed note conditional effects expanded point 
relevant variables updated 
updating involves removing set selected operators step 
second ancestors preconditions ancestor sets include step need planning 
shows example precondition ancestor remaining 
third applied preconditions goals reason longer fringe causes step re achieved 
fourth case selected operator achieve goal reset step 
current state altered algorithm returns step termination condition checked 
veloso stone discussion backtracking heuristics properties pay close attention placement backtrack points algorithm 
particular subgoal apply choice step choice operator achieve goal step choice applicable operator step 
choice goal subgoal step backtrack point prodigy algorithm backtrack point 
flecs need backtrack point choice apply apply operator time left open step significantly different orders applying applicable operators considered step 
explained previous subsection different orderings completely independent operators considered 
orderings lead solution considered 
backtracking choice subgoal cause redundant search 
elimination backtrack point significant improvement flecs previous implementations prodigy 
note new backtrack points added offset eliminated backtrack point 
flecs explicit failure point step occurs algorithm chosen subgoal pending goals relevant operators 
failures implicit 
backtrack point choices unsuccessfully tried algorithm backtracks 
algorithm terminates unsuccessfully entire search space exhausted 
causes failure goal loops state loops depth bounds time limits incorporated manner prodigy carbonell 
choice point heuristic determine branch try 
step goal chosen means ends analysis operator minimum conspiracy number chosen achieve goal 
step choice mechanism heuristic determine applicable operator try 
step toggle changed time determines default commitment strategy eager subgoaling eager applying 
note pending goals true current state pending goals planner may apply applicable operator regardless value toggle 
similarly applicable operators planner subgoal toggle indicates prefer applying 
toggle new variable guide heuristic search existing choice point branching factor represent addition new backtrack point 
discussed provides ability change commitment strategy 
suggested name toggle values sub app indicating eager subgoaling eager applying respectively 
describe domain independent heuristic guide changes value toggle 
heuristic allow eager commitments reason believe need backtrack resulting operator linearization 
case setting toggle app increase planning efficiency converting partially ordered set operators sequence leads single possible state guide subsequent planning 
process equivalent starting new smaller planning problem previous choices embedded state 
situation described similar arises alpine system constructs efficient abstraction hierarchies knoblock 
alpine guarantee flecs planning flexible commitment strategy planning generated abstraction hierarchies lead backtracking refinement spaces 
illustrates fly cs abstraction planning information control value toggle 
toggle changes app particular planning step completely refined abstraction hierarchies preserve ordered monotonicity property need backtrack resulting operator ordering 
toggle change back sub fly cs continue planning updated state information 
abstraction level ti 
continue planning step ply comet 
abstraction information guide changes toggle 
abstraction driven heuristic method exploiting choice point 
similarly minimum conspiracy number heuristic heuristic ways guide choices instantiated operator applicable operator respectively 
heuristics changed claim ones provide defaults best possible heuristic time 
planning algorithm sound complete searches entire search space technique iterative deepening korf 
rt cs sound terminates reached goal statement result applying operators 
application operator sequence returned final plan entirely simulated time planner terminates 
preconditions operator true time operator executed operators executed goal statement satisfied 
consequently fly cs sound 
step algorithm prunes search space lv cs iteratively increasing depth bound complete solution planning problem lv cs find 
insure property need show lv cs consider possible operators may achieve goal orderings interacting applicable operators 
lv cs maintaining backtracking points choice operator step points operator ordering affected choice applicable operator step choice subgoal apply step 
selecting veloso stone apply commits ordering operators currently applicable currently applicable operators 
note completeness achieved maintaining choice goals subgoal backtrack point step regardless order operators chosen applied possible interactions similarly resolving negative threats 
cs search space significantly reduced prodigy preserving completeness 
see appendix formal proofs soundness completeness 

empirical analysis heuristics control commitment strategy seen introduces notion flexible choice point delayed eager operator ordering commitments 
appreciate need flexibility consider extreme heuristics eagerly subgoaling delaying commitment eagerly applying eager commitment 
heuristic chooses subgoal long active pending goal subgoal applying chooses apply long active applicable operators subgoal try apply 
section show empirical results demonstrate extremes lead highly sub optimal search particular domains 
believe single domain independent search heuristic perform domains stone 
reason equipped ability extreme domain independent heuristic moderate heuristic iteration algorithm opportunity change eagerly subgoaling eagerly applying vice versa 
define different heuristics guide choice leave choice user interactively 
flexibility search method provides algorithm ability search sensibly wide variety domains 
algorithm flexible susceptible coming domains handle efficiently barrett weld veloso blythe kambhampati 
cs flexibility possible study heuristics best situations 
addition flexible choice perfect learning opportunity 
single search method solve planning problems learning techniques help determine experience search strategies try 
illustrate need different search strategies provide real world situation eagerly subgoaling leads directly optimal solution eagerly applying intermediate policy best 
examples intended exhaustive demonstration rl cs capabilities 
examples intended illustrate need consider problems traditional goal ordering problems motivate potential impact rl cs 
eagerly subgoaling better consider class tasks true operators initially executable performed specific order operator deletes preconditions operators supposed executed earlier 
instance suppose single paint brush objects need painted different colors 
paint brush washed fairly comes completely flecs planning flexible commitment strategy clean 
reason lighter paint darker paint darker paint show painted object project 
shade red darker shade green 
paint chair red seat green legs better paint legs 
consider range colors ordered light dark white yellow green black 
initially paint object color 
start painting black paint 
order represent situation planner created domain operators shown table 
operator paint white paint yellow paint black preconds usable white usable yellow 
usable black adds white yellow 
black obj deletes usable white 
usable white 
usable yellow usable brown table example domain delayed step ordering commitment results efficient planning 
assume colors usable initial state 
painting object certain color deletes precondition painting object lighter color dition re achieved operator adds predicate usable colors specific order 
painting domain rem world interpretation artificial domain intro duced barrett weld 
operators dm look operator ai preconds ii adds gi deletes operator deletes preconditions operators numerically operators applied increasing numerical order 
corresponds operator white corresponds yellow domain experiments run sparc station 
generated random problems having fifteen goals problems number goals 
problems test extreme heuristics 
get data points averaged results problems number goals 
raw data contained online appendix 
graph average time flecs took solve problems versus number goals 
shown stone eagerly applying leads exponential behavior function number goals domain eagerly 
began study new planning algorithm named flecs 
consider version prodigy stone ed preliminary implementation flecs 
veloso stone operator choice heuristic study leads approximately linear behavior backtracking 
problem eagerly applying example goal solved flecs immediately apply backtrack unsuccessfully tries apply 
eagerly subgoaling allows flecs build set operators need apply order appropriately selecting application order avoids conflicts threats 
shows graphic comparison different behaviors 
oo eager subgoaling eager applying 
number goals flecs performance different heuristics domains eager subgoal ing applying correspond delayed commitments eager commitments respectively 
eagerly applying better consider class tasks true operators achieve goal operator 
similar example suppose trying paint different parts single object different colors 
suppose multiple brushes come clean brush color safely 
instance painted green parts brush need brush brush brush paint red parts 
table represents operators new domain 
operator paint brush paint brush 
preconds unused 
unused brush adds painted 
painted deletes unused 
unused brush table example domain eager step ordering commitment state results efficient planning 
note operator color deletes precondition 
capture essential features domain artificial domain called 
operators look flecs planning flexible commitment strategy operator ai preconds adds deletes operator achieve goal operator deletes precondition 
operator corresponds painting different brush 
domain better eagerly apply eagerly subgoal 
eagerly subgoaling causes fl cs select operator achieve goals 
deterministic method selecting operators minimum conspiracy number order appearance domain specification tie breaker selects operator achieve different goals 
apply need backtrack select different operator goals 
shown eagerly applying outperforms eagerly subgoaling case 
generated results way results previous subsection 
age eager applying 
numberof goals performance different heuristics domains 
intermediate heuristic possible find solutions eagerly subgoaling example eagerly applying second need include variable toggle rl cs simply eager subgoal mode eager apply mode 
cases alternatives suffices 
need eagerly subgoal portions search eagerly apply 
heuristic changing commitment strategy abstraction driven method described section 
domain form heuristic 
time consider class tasks true top level goals take operators achieve irreversible executed limited number times restricts bindings operators 
representative class way rocket domain introduced veloso carbonell 
sake consistency representative class domains painting context 
suppose painting walls rollers 
paint wall veloso stone need ready wall purpose example means decide wall needs painted designate color roller paint wall 
fill selected roller appropriately colored paint 
paint wall 
unfortunately limited supply rollers clean filled paint clean selected paint wall 
reason ready walls want paint roller fill roller paint 
reader familiar way rocket domain fill roller operator analogous move rocket operator domain executed due limited supply fuel executed fully loaded 
table shows possible set operators painting domain 
operator designate roller fill roller paint wall preconds clean clean ready needs painting chosen filled paint adds ready filled paint painted chosen deletes clean ready needs painting table example domain flexibility commitments results efficient planning 
domain representation flecs difficult time apparently simple problems uses search strategy entire search 
example consider problem walls rollers equivalent problem way rocket domain objects destinations initial state needs painting needs painting needs painting needs painting needs painting clean clean roller goal statement painted red painted red painted red painted green painted green optimal solution flecs planning flexible commitment strategy directly find solution eagerly subgoaling eagerly applying 
search efficiently subgoal considered walls need painted color apply applicable operators continuing 
explicit information domain telling roller red roller green 
reason eagerly subgoals initially selects roller paint walls 
extensively backtracks finding correct bindings 
realize ready walls going painted color filling roller 
eagerly applies operators tries filling roller soon wall 
note planning variables solve problem planner need binding selections subgoaling paint wall facing problems 
tries solve problem strategy described succeed reasonable amount time 
rl cs complete certainly succeed eventually eventually long time away dealing np hard problem commitment strategies leads solution problem seconds search time 
lost 
changing value toggle appropriate times rl cs easily find solution problem 
fact just seconds toggle manually changed appropriate times 
time sec solution eager applying eager subgoaling variable strategy eagerly subgoals decided paint roller eagerly applying 
walls painted red lics subgoaling danger preparing walls wrong roller roller clean 
example change state allows minimum conspiracy number heuristic select correct instantiated operator 
general heuristic toggle set sub walls need painted color considered 
toggle set app applicable operators applied 
toggle set back sub process continues 
way need little backtracking quickly reach solution 
heuristic corresponds abstraction hierarchy deal separately interactions different colors different walls 

planner intended studying correspondence planning problems search heuristics suited problems 
fl cs ability eagerly subgoal delaying operator ordering commitments eagerly apply maximizing advantages maintaining internal state flexibly interleave strategies 
operate point continuum operator ordering heuristics important dimension planning 

problem common planning syntactically correct way restrict bindings domain representation maintaining intended flexibility generality domain 
veloso stone explained advantages disadvantages delayed eager commitments 
cs algorithm full detail carefully motivating concepts illustrating clear examples 
discussed different heuristics guide cs choice points discussed properties 
showed examples specific planning tasks corresponding empirical results support position general purpose planner able flexible commitment strategy 
planning problems solvable complete planners fl cs may solve problems efficiently planners ability change commitment strategy may fall worst case unique commitment strategy 
fl cs provides framework study characteristics different planning strategies mapping planning domains problems 
fl cs represents view domain independent planning strategy uniformly efficient different domains problems 
fl cs addresses particular operator ordering choice flexible planning decision 
allows combination delayed eager operator ordering commitments take advantage benefits explicitly simulated execution state reasoning planning constraints 
currently continuing understanding tradeoffs different planning strategies different dimensions 
plan study effects eager versus delayed commitments point operator instantiations 
investigating effects combining real execution fl cs 
plan machine learning techniques cs choice points gain possibly automated understanding mapping efficient planning methods planning domains problems 
appendix proofs prove flecs sound iterative deepening complete 
consider algorithm table 
planning problem determined initial state goal statement set operators available domain 
plan totally ordered sequence instantiated operators 
returned plan generated fl cs planning problem sequence applied operators termination 
solution planning problem plan operators applied problem initial state reach state satisfies goal statement 
justified solution solution subsequence operators solution solution 
fl cs terminates successfully termination condition met step 
theorem 
flecs sound 
show fl cs algorithm sound algorithm terminates successfully returned plan solution planning problem 
assume fl cs terminates successfully returned plan 
fl cs applies operator preconditions operator satisfied current state step 
construction operators ok satisfied point termination current state satisfies goal statement step 
reached initial state applying operators solution 
qed 
flecs planning flexible commitment strategy theorem 
rl cs iterative deepening complete 
recall completeness informally means solution particular problem algorithm find 
show rl css search space complete rl css search algorithm complete long explores branches search space example iterative deepening korf 
tm iterative deepening involves searching bound number search steps may performed particular search path suspended expansion solution particular depth bound search repeated larger depth bound 
planning problem assume os justified solution 
show rl cs searches iterative deepening find solution 
rl cs algorithm choice points 
choice points backtrack points choice subgoaling applying step choice operator achieve goal step choice applicable operator apply step 
choice point backtrack point choice goal subgoal step 
prove completeness show backtrack point possible choice lead cs finding plan matter choices cs non backtrack choice point 
rl cs explores branches search space searching iterative deepening eventually find finds solution length 
proof involves constructing oracles tell rl cs choices backtrack points find 
matter choices choice point finds solution plan 
consider point search operators ok applied 
oracles backtrack points operate follows 
choice subgoaling applying step oracle rl cs choose apply ok applicable rl cs subgoal 
rl cs chooses apply ok reaches choice point choice operator apply step 
oracle flecs select precisely step ok chooses subgoal ok choose goal set pending goals step 
step backtrack point oracle determine choice point 
show independently choice point cs find solution find solution consequence construction oracle controls final choice point 
oracle guarantees selected member goal statement precondition operator 
final choice point selection operator achieve step 
third oracle flecs choose operator achieve solution planning problem member goal statement precondition operator operator achieves operator chosen 
operators selected 
opposed breadth search iterative deepening harm efficiency 
combines efficiency searching depth completeness searching breadth 
veloso stone condition pending goals goal statement preconditions operators maintained 
oracles lead rl cs justified solution justified operator necessary achieve goal goal statement precondition operator 
consequently third oracle chooses operators operator eventually chosen applied prescribed oracles 
operator applied termination condition met solution fl cs terminate successfully 
qed 
recognize particular contributions jim blythe eugene fink research 
jim blythe highly responsible current implementation prodigy cs 
eugene fink helped formalization algorithms proofs 
eugene fink karen haigh gary wang anonymous reviewers comments article 
research sponsored wright laboratory aeronautical systems center air force material command usaf advanced research projects agency arpa number 
views contained document authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory government 
steel 

integrating planning execution monitoring 
proceedings seventh national conference artificial intelligence pp 
st paul mn 
barrett weld 

partial order planning evaluating possible efficiency gains 
artificial intelligence 
blythe veloso 

analysis search techniques totally ordered nonlinear planner 
proceedings international conference ai planning systems pp 
college park md carbonell blythe etzioni gil joseph kahn knoblock minton reilly veloso wang 

prodigy manual tutorial 
tech 
rep cmu cs department computer science carnegie mellon university 
carbonell knoblock minton 

prodigy integrated architecture planning learning 
vanlehn 
ed architectures intelligence 
erlbaum hillsdale nj 
technical report cmu cs 
chapman 

planning conjunctive goals 
artificial intelligence 
flecs planning flexible commitment strategy ernst newell 

gps case study generality problem solving 
acm monograph series 
academic press new york ny 
fikes nilsson 

strips new approach application theorem proving problem solving 
artificial intelligence 
fink veloso 

prodigy planning algorithm 
technical report cmu cs school computer science carnegie mellon university 
kambhampati 

tradeoffs partial order plan space planning 
pro ceedings second international conference ai planning systems aips pp 
chicago il 
knoblock 

automatically generating abstractions planning 
artificial intelligence 
korf 

depth iterative deepening optimal admissible tree search 
artificial intelligence 
mcallester rosenblitt 

systematic nonlinear planning 
proceedings ninth national conference artificial intelligence pp 

mcdermott 

planning acting 
cognitive science 
minton 

integrating heuristics constraint satisfaction problems case study 
proceedings eleventh national conference artificial intelligence pp 

minton bresina drummond 

commitment strategies planning comparative analysis 
proceedings twelfth international joint conference artificial intelligence pp 

minton knoblock kuokka gil joseph carbonell 

manual tutorial 
technical report cmu cs school computer science carnegie mellon university 
rosenbloom newell laird 

knowledge level soar role architecture knowledge 
vanlehn 
ed architectures intelligence 
erlbaum hillsdale nj 
sacerdoti 

structure plans behavior 
american elsevier new york 
stone veloso blythe 

need different domain independent heuristics 
proceedings second international conference ai planning systems pp 



generating project networks 
proceedings fifth international joint conference artificial intelligence pp 

veloso stone veloso blythe 

examining causal link commitments partial order planning 
proceedings second international conference ai planning systems pp 

veloso 

nonlinear problem solving intelligent casual commitment 
technical report cmu cs school computer science carnegie mellon university 
veloso carbonell 

analogy prodigy automating case acquisition storage utilization 
machine learning 
veloso carbonell 

nonlinear planning parallel resource allocation 
proceedings darpa workshop innovative approaches planning scheduling control pp 
san diego ca 
morgan kaufmann 
wilkins 

domain independent planning representation plan generation 
artificial intelligence 

