pado new learning architecture object recognition astro teller manuela veloso carnegie mellon university artificial intelligence systems today simple problems artificial domains rely accurate sensing task world 
object recognition crucial part sensing challenge machine learning stands position object recognition real world domains 
date machine learning delivered general object recognition propose different point attack learning architectures 
developed method directly learning combining algorithms new way imposes little burden bias humans involved 
learning architecture pado new results brings problem natural image object recognition focus chapter 

general ai systems symbols represent knowledge reason tasks 
systems today simple problems artificial domains 
main reasons common assumption sensing perfect sensors return specific symbols raw data 
signal symbol problem task converting raw sensor data set symbols data seen representing 
main goals computer vision provide solution symbol problem 
particular goal involves object recognition ability recognize objects shown image 
machine learning induction set examples learn discriminate classes 
fields machine learning computer vision natural mates particularly suited cooperate object recognition tasks 
proven machine learning architectures neural networks integrated computer vision results recognition ev teller veloso objects modest best 
possible better parameter values training data faster computers allow architectures significant advance field object recognition 
chapter proposes different view experienced current architectures profitable path investigate new architectures 
clearly solution object recognition problem needs grounded algorithm processes intensity values image signal 
consider particular task differentiating different images natural objects natural settings 
task solved learning separate algorithm discriminating image signals object class 
new architecture pado technique learning algorithms directly built commitment manner algorithm investigates image arrives decision 
features chosen pado attention focusing strategy built 
pado parallel algorithm discovery orchestration uses evolutionary strategy accomplish self generation 
motivation pado details pado results challenging vision problem topic chapter 
challenging vision problem object recognition high resolution noisy images real world objects natural settings 
course chapter image set introduced example domain pado learn perform 
pado impressive performance recognition problem repeated second vision domain different characteristics 
chapter provide solid basis understanding unique architecture works 
experimental results show pado promise new practical solution general object recognition problem 
pado architecture entirely independent signal type classified construction promises similar results signal types varied sonar speech text 
chapter dissection tested approach new way doing signal understanding 

motivation signal symbol problem major problem ai right symbolic parts ai need symbols raw data 
introduced pado designed attack general signal symbol problem 
pick vision pado test domain 
real reason vision ai weakest link 
obvious examples agents performing signal symbol translation hearing seeing 
humans animals effortlessly take information unfairly represented dimensional waves quickly conscious effort determine correspondence raw perceptions notions real world 
humans call notions symbols 

pado learning object recognition extracting symbols vision hearing hard problems 
relative ultimate goal human level performance clear ai success engineering solutions sound problem vision problem 
important ai unsolved field chose vision pado problem domain 
detailed section learning relatively new field computer vision brought modest improvements areas 
learning vision modest success rate unconstrained problems suggest effort concentrated effort scale architectures better human intervention preprocessing 
neural networks nn example designed model visual cortex brains 
inspired small pieces brain 
reason think large amount processing go order general object recognition done nn inputs tens hidden units 
ignoring obvious nns easy train function complex mapping images classes 
designed architecture directly addresses issues 
chapter organized follows 
section discusses related areas object recognition genetic programming gp 
section provides short learning power evolution 
section details pado architecture language choices experiments 
section gives experimental background set example pictures 
section shows results series experiments 
section discuss puzzling points chapter brings 
section looks forward progress near goals 
section concludes bringing highlights chapter 

related object recognition heavily researched area years 
objects recognized usually highly geometrical shape 
majority cases recognizer model explicit cad implicit hand coded features objects task really try find objects picture correctly identify pose 
demand robust systems constraints coupled rising cost programmer time relative computer cycles pushed object recognition machine learning 
field computer vision far big sketch 
focus vision learning claim obtain similar results chapter hand coded system feasible require significant amount programmer time 
teller veloso learning variety purposes respect object recog nition 
researchers tried learn hand coded features particular problem 
researchers tried learn models objects number constrained images objects models mentioned 
learning applied larger level particularly form neural networks 
major problem neural networks today technology nns take full video images input 
imagine small image resolution 
ann just hidden units fully connected inputs weights fix 
back propagation take long time train net 
preprocessing done significantly reduce images resolution preserving relevant information nns effective 
course occurs problem difficult preprocessing clever 
preprocessor clever problem really solved simply moved problem creating nice preprocessor 
directly concerned object recognition pomerleau driving alvinn nn example successful application nn computer vision problem 
preprocessor little clever problem difficult previous assumed 
important largely pomerleau apply learning kind real time reactive vision problem 
thrun mitchell nns visual object recognition example goals similar 
take video images preprocess get low resolution images nn object recognition training 
focuses studying effect lifelong learning ability find general object type invariants 
mentioned experimental similarities data experiments discussed chapter 
part pado system type genetic programming mention sort vision related done paradigm 
far know published results sort discussed chapter apply genetic programming genetic algorithms directly full video images object recognition basis input 
done fall major categories bitmap recognition learned aids vision problems including object recognition 
examples genetic programming applied bitmaps usually font bitmaps order classification 
works applied gp restricted subset black white silhouettes person tried learn hands 
learned aids object 
pado learning object recognition recognition seen works 
example gp improve performance army system locating tanks learning choose existing system components 
significant amount related pado single piece combination covers details pado architecture 
method orchestration parallel execution learned algorithms signal classification unexplored 

evolution inductive generalization evolutionary computation biologically motivated 
nature see combination survival fittest fitness proportionate reproduction genetic recombination extremely powerful finding solutions biological problems 
section introduce basic nature genetic evolutionary processes 
suppose large group things measure thing apply measure things get approximate exact fitness thing 
suppose allow thing represented new group things proportion fitness relative things group 
best things old group greater representation new group worst things old group representation new group 
new group fixed size old group scheme accomplishes survival fittest fitness proportionate reproduction 
changed successive group current group soon filled instances fit thing group 
initialize population random things new population things 
measure fitness thing quit fitness goal achieved create mating pool fitness proportionate reproduction 
temporary population apply genetic recombination mating pool mating pool new population 
suppose measuring fitness thing new group change random semi random way 
general form genetic recombination 
changes introduce chance new things higher fitness old things 
new groups come gone expect best thing current group better measure things teller veloso original group 
concept evolution 
see chart 
evolutionary computation form best search 
exponentially increasing representation things highest fitness points space exponentially examined relative points consideration things group 
vocabulary evolutionary computation group things called population 
distinguish successive populations referred generations 
initial population traditionally called generation successive generation numbered increasing integer order 
exact structure thing varies field field evolutionary computation 
genetic algorithms things called allele strings usually take form bit strings 
genetic programming things called functions take form lisp nested primitive function calls 
pado things programs 
functions programs 
function simple finite mapping inputs outputs 
word functions reactive 
programs algorithms procedures incorporate current past inputs iterative recursive process may eventually produce output 
algorithms deliberative 
basis distinction expanded chapter 
difference functions programs important distinctions traditional gp pado 
see appendix example pado program 
genetic recombinations come different varieties 
common directly relevant chapter crossover mutation 
crossover things chosen subpart selected 
subparts exchanged new things placed back population 
mutation thing chosen subpart selected 
subpart changed random way new thing placed back population 
cases syntax things usually constrained changes produce legal new things 
crucial aspect evolutionary computation random search space things 
extent correlation syntactic functional similarity recombinations explore things similar fitness 
correlation essence hill climbing 
combine version hill climbing aspects best search mentioned powerful tool searching space decomposable elements fitness variation 

pado part pado architecture falls general heading evolutionary computation 
section discuss way pado works central 
pado learning object recognition component instance general scheme described previous section 
part section inputs considered arbitrary signals 
section rest chapter specific signal type video image example 
pado architecture designed apply signal type introduced 

architecture goal pado architecture learn take signals input output correct labels 
classes choose pado starts learning different systems 
system responsible signal input returning confidence class correct label 
clearly systems worked perfectly labeling signal correctly simple picking unique non zero confidence value 
example system returned non zero confidence value correct label 
real world systems perfectly 
leads recurring questions pado architecture 
pado learn components systems programs 

pado orchestrate maximum effect 
explain pado systems section 
delve systems built 
system built programs 
programs exactly system takes signal input returns confidence value label correct label 
reason redundancy justified discussed section 
pado orchestration programs single system discussed section 
pado evolves programs general lines described previous section 
programs learned pado written algorithmic language pado specific 
training phase learning programs interpreted compiled 
lisp programs compiled interpreted construction phase simply interpreted 
learning session main population filled programs randomly generated grammar legal syntax language 
programs language constrained syntax return number interpreted confidence value minimum confidence minconf maximum confidence 
new generation program population training signals confidences returns recorded 
population divided distinct groups size programs group programs recognized class better class sense reward function reward class pad considering assigning program 
teller veloso int reward program class int guess loop return images program return reward multiplied happens times images account half reward 
reason able important say appropriate say appropriate cases respectively coverage 
normalization provides average zero reward purely random classification strategy 
group sorted increasing fitness program ranked accordingly 
mating pools temporary groups created putting copy prob ability rank 
ex pected number copies best program expected number copies median program expected number copies worst program 
method called rank proportionate reproduction 
libraries programs able programs 
division population guess confidence program returned image reward value 
number classes 
object type appears image initialize population random programs new population 
measure confidence reaction program set training images separate main population pools programs respective xtract best pool object recognition create mating pools fitness proportionate reproduction 
update libraries fitness weighted 
smart operators choose recombination site genetic recombination ting pool mating pools merged new population libraries updated widely 
statistics weighted fitnesses programs called 
percent programs mating pool subjected crossover percent subjected mutation 
crossovers take place programs mating pool 
means 
pado learning object recognition recognizers class 
crossover pado complicated standard form genetic algorithms genetic programming 
pado programs chosen smart crossover algorithm 
algorithm examines programs chooses sub graphs 
subpart programs exchanged 
new pairs sub graphs reconnected creating new programs 
new programs replace old programs population 
smart mutation pado complicated general case described previous section 
program chosen intelligently chosen subpart replaced intelligently generated new element 
changed program replaces old program new total population 
point merge mating pools back new total population 
process evaluation reproduction recombination repeats 
generations find best programs population better created randomly start process 
extract programs systems pause process evaluation step generation copy programs scored best near best group architecture anytime learning system time generate system signal classification learned far 

te language pado program sketches structure pado program 
program constructed arbitrary directed graph nodes 
arbitrary directed graph nodes node arcs outgoing 
arcs indicate possible flows control program 
pado program node parts action branch decision 
program private stack indexed memory 
actions pop inputs stack push result back stack 
actions equivalent gp terminals non terminals 
indexed memory array integers indexed integers 
seen program ability access element memory read write 
memory scheme conjunction main loop described shown turing complete 
practice memory finite range integers indexed element hold integers finite range 
indexed memory seen simplest memory structure practically support memory structures 
indexed memory successfully build complex mental models local geography 
action node executed arc taken new node 
branch decision function current node decision 
chapter outgoing arcs node 
teller veloso indexed memory basic structure pado program 
mini programs pado program 
mini program may referenced main program local mini program library program 
node branch decision function may top stack previous state number memory constants pick arc special nodes shown 
node start node 
special way node executed program begins 
node node 
node reached action executed program halts 
program halts response considered current value residing particular memory location response memory 
program halts sooner pre set time threshold started start node erasing memory stack give chance revise confidence value 
weighted average responses program gives particular execution computed interpreted answer 
weight response time responses count total response program 
time threshold pado programs guaranteed halt respond fixed amount time 
node executes private mini program action 
executes branch decision function normal 
mini program associated main program bears similarity concept adf automatically defined functions 
may called point main program evolves main program 
mini programs way normal pado programs size constrained smaller main programs 
name mini denotes owned main program 
mini programs may recursively call globally available library programs just main program may library programs globally available programs executed time just mini programs 

pado learning object recognition mini programs mini may run execution pado program part library programs publicly available entire population 
method library programs change shown detail discussion section 
brief summary language actions effects algebraic primitives add sub mult div max min functions allow basic manipulation integers 
values con strained range 
example div results maps set 
memory primitives read write functions access memory program 
program memory organized array integers take values 
read returns integer stored position memory array 
write takes value writes position indexed memory 
write returns old value position write read side effect 
memory cleared positions set zero program execution 
branching primitives calling branching primitives may misleading 
cases prim itive pops stack replaces depending value test 
test varies 
primitives action branch decision functions 
case effect flow control 
signal primitives pixel average variance difference language functions access signals 
order demonstrate pado power flexibility primitives image sound data 
pixel returns intensity value point image sound 
signal functions pop top values stack 
numbers interpreted specifying rectangle image 
points specified negative area opposite interpretation taken function applied positive area rectangle 
average variance difference return respective functions applied region image 
difference difference average values second half line 
routine primitives mini library programs called main program 
addition may called 
programs simple functions effect stack memory completion unknown 
portion discussion section devoted justification language design ramifications teller veloso mini mini extra legal terminals extra terminals local variables take values top values popped stack mini called 
mini program private main program uses called times desired main program 
program exactly mini evolves main 
general main program mini programs private 
distinctions main mini programs mechanism referring calling mini mini programs may library programs 
main programs currently may 
library library programs 
really parameter 
action calling library program program main mini library program look library 
mini programs library programs pop values stack stores values local read variables legal terminals library programs 
library programs available programs population 
library programs created changed discussed section 

experiments discussion results focus sets data 
set taken 
set taken sebastian thrun works learning vision 
purposes call set second set elements sets video images level grey 
set classes book bottle cap coke glasses hammer shoe 
lighting position rotation objects varies widely 
floor wall underneath objects constant 
object image 
distance object camera ranges feet severe foreshortening objects image 
see columns sample images 
set classes bear long flute pan flute book 
class collection images empty show hand holding object cup ball classes 
pictures taken variety solid colored backgrounds contain part hand arm 
hand holds objects partially occluding 
location rotation object constrained object completely image 
lighting varies dramatically intensity position 
distance object camera ranges feet 
objects severely 
see columns sample images 
set created criteria mind 
wanted set images easily distinguished people trivially different way computer notice 
wanted noise images 
pado learning object recognition want unconstrained backgrounds 
wanted sufficient number classes results give indication pado practical value 
important number classes small learning science lost engineering 
result chose grey scale images classes listed set backgrounds varied color solid 
noise form hand arm 
general hand arm take half area image object signal noise ratio 
chose test system classes 
initial tests proved pado effectiveness class object recognition problem slightly doubling number classes qualitative step difficulty 
set created sebastian thrun 
pictures took originally color allowing pado access color images turned easy pado classification accuracy removed color saturation information kept brightness information 
thought important important include data images taken different purpose real goal pado project 
ability distinguish classes signals way designed taken preprocessed pado mind 
images object argued results shown sections object recognition classification images object shown image 
distinction 
object recognition different image classification theory image contains shoe hammer correctly classified shoe image hammer image 
reasonable distinction object recognizer just know object existence image 
able locate image segment rest image 
short machine learning community probably label object recognition vision community probably label image classification 
distinction loose chosen label results object recognition 
said discussion section finding object image 
sections show different experiments 
experiments general methodology 
training set consisted images class total images 
testing set consisted different images class total images 
order prevent fitting training images subjected variety transformations mirror image contrast add content preserving noise 
environment initialized random programs random library programs random smart operators 
environment run generations examining fitness program relative training images 
object recognition best programs determined performance teller veloso sample train images sample test images sample train images sample test images randomly selected images sets 
pado learning object recognition training set extracted orchestrated testing complete pado recognizer 
obtain reliable results experiment done times 

experimental results analysis section show pado accomplishes difficult tasks visual object recognition 
results shown hurdles pado 
fact results pado 
give accurate easy understand picture sort performance pado currently deliver real tasks 
section organized parts 
subsection explain experiment detail results give basic analysis implications 

tier ali pado technique generation program placed group maximizes reward 
see page section reward function 

results figures show average reward top programs class generation test images 
words programs class highest reward training images selected 
programs generation reevaluated test images reward performed test images 
rewards averaged give score class plotted graph 
pado parameter chapter set 
data taken separate runs graph average runs 
range possible rewards 
random guessing result average reward 
reward positive distance lowest possible reward highest possible reward 
learning improvement continues generation learning rate continues diminish 
order number experiments necessary reliable data experimental runs allowed continue past generation 

analysis figures show increasing ability best programs population distinguish class 
obvious feature graphs curves graphs get positive reward 
mean generation fit programs having hard time distinguishing class 
basically answer 
teller veloso discrimination reward percentage bear 


book 

random 







generations pado discrimination reward percentage test images set discrimination reward percentage book bottle cap coke glasses hammer shoe generations pado discrimination reward percentage test images set remember random choice average reward 
pado learning object recognition numbers programs return confidences possible right picture getting maximum possible reward 
example program designated program returns confidence seeing image reward maximal 
program returns confidence reward minimal 
program returns confidence example reward dose maximum reward obtain picture 
fact curves climb near reward reasons 
problem hard training set size small noise added prevent fitting 
noise nearly impossible program perfectly fit data 
second reason interesting 
pictures class 
sense programs trained discriminate images objects class images learn express real levels confidence think picture believe 
example angles may look bear 
cases appropriate recognizing programs return non maximal confidences 
second important facet graphs figures variation curves graph 
surprising classes easier distinguish 
example class set hard learn set features identifies set 
learning distinguish class requires finding features classes 
helps explain curve lowest 
relatively slowly rate performance increase generation indication difficulty level image classes non trivial 

incl pado subsection details similar set experiments 
experiments classes trained early generations 
classes added incrementally periods generations starting generation fifteen 

results figures show results obtained reward average 
notice newly added class discriminators rise quickly point trained 
generation incremental learning technique half computation time standard pado learning took classes 
generation incremental learning technique computer cycles standard method uses 
notice average incrementally learned classes slightly better standard technique 
tried different training class orderings obtained similar results 
teller veloso bear discrimination reward percentage book 

rand 
generations incremental pado reward percentage test images set discrimination reward percentage bo bottle cap coke glasses hammer 
shoe 
lt ando 
generations suggests special order incremental 
pado learning object recognition classes introduced period introductions 
exception rate new classes faster generations learning curve quite steep 
probably period generations classes trying get speed 
waiting longer introductions produces similar rise performance 
short graph showing incremental learning process particular rate particular sequence class 
graphs representative graphs various orderings classes various speeds 

analysis incremental learning graphs figures show similar properties discussed figures arguments continue valid 
difference graphs classes trained generation 
starting generation new class new training images added fifth generation 
graphs standard pado technique graphs show dramatic jumps performance small number generations 
jumps constant increase steepness number increases 
class added learns level fellow classes faster previously added classes 
curves added classes jump quickly meet rest curves continue trained 
impossible give definitive answer question 
consider plausible explanation 
generation choose add class 
means number groups population divided generation increase training set size increase equal number image class including new image class 
new group formed individuals population performed best discriminators new class 
generation expect non negligible performance 
new object objects 
programs old class similar serve better discriminator pick random 
generations effect important sufficient explain sizable jumps reward 
second half explanation lies mechanism libraries 
delve finish discussion natural course discussion libraries 
results incremental experiments tell quickly get new class comparable performance current classes 
may mean larger numbers classes learned tractably cheaply leveraging existing knowledge incremental learning technique 
teller veloso 
object recognition pado outlined section object recognition classes accomplished pado orchestration different systems 
systems composed fit programs corresponding group current generation 
order show object recognition generation necessary learn program classes 
incremental technique average produce slightly better programs generation respectively classes programs object recognition proceed set test images containing objects classes learned 
graphs hard decipher simply picked programs standard pado strategy 
system built programs best learned recognize object class responses programs return seeing particular image weighted weighted average responses interpreted confidence image question contains object class pado object recognition orchestrating responses systems 
confidence response system initially weighted equally 
particular test case function max takes weighted confidences selects class image object class 
pictures orchestration learning process 
object classification output system system confidence output prog prog prog 
prg 
po weights trained early testing 
prog training results generation 

pado learning object recognition 
results experiments followed orchestration method learning test phase 
orchestration phase orchestration images class shown constructed pado recognizer 
orchestration weights adjusted telling pado guess right wrong 
specifically program particular system weight vj adjusted initial tests weight increases returns confidence near correct confidence decreases returned confidence far correct confidence 
similarly weight wz adjusted manner 
strategy shown ways orchestration accomplished 
orchestration strategies tried similar success 
orchestration strategy chosen obtain results works simple explain 
extra learning orchestration adds milliseconds total testing time 
pre testing phase orchestration phase actual testing phase done 
phase images group test pado performance 
test images images pado seen learning orchestration 
data averaged runs 
run generation pado program compiled systems built best programs available generation 
pado program ability correctly recognize object test images tested 

analysis shows ability pado object recognition sets image data 
crux chapter pado succeed task object recognition 
pado worth trouble 
important thing point constructed simple system simply guessed class image choosing class random right time shown dotted line 
generation percent time pado correctly identifies image class times random performance 
images unconstrained images objects unfriendly objects real difference 
issues scalability potential application pado discussed sections 
items note object recognition graphs 
graphs single class chosen orchestration 
shown graphs data taken percent time correct class ranked second orchestration ranking confidences 
data sets percentage middle 
means time correct class top orchestration ranking 
interesting symptom pado fails fail highlights number classes teller veloso oo real measure pado success object recognition correct set set generations pado object recognition percentage correct sets test images 
choose increases easier get bad vote disrupts orchestration image 
second item relative heights graphs 
average image set hand easier generalize set hand 
data sets difficult different reasons 
set includes full rotation translation includes hand arm possibly occlude part object question 
objects set parallel image plane 
set case 
hand absent objects rotated translated 
hand arm introduce significant amount noise results surprising 
issue assessing difficulty level dividing set signals classes open question 
discussion previous section gave information reader read graph extract data graphs represent 
set results parts previous section dedicated interpretation data ramifications 
really understand results ramifications complete explanation process required 
section question answer format try explore puzzling issues pado task object recognition 

pado learning object recognition 
language architecture helpful image related language primitives 
described chapter ways get basic inten sity information input image see section 
pado mechanism independent details language 
example div action div top elements stack redefined re tests get similar results 
certainly language primitives put language improved results shown 
obvious example spatial differential re turn spatial differential line defined points extreme example results edge segmenter edge joiner available language primitives 
reasons 
spirit trying non traditional approach computer vision worthwhile see level success achieve borrowing notions structures traditional computer vision 
originally motivated lack success computer vision natural objects natural scenes 
fact believe results non trivial reason justified 
second reason trying create learning architecture requires minimal input help user 
time programmer spend customize language order get results autonomous system shown chapter bare minimum input user extremely basic functions getting image intensity results possible 
course better results sought system improved ways trying language primitives 
indexed memory memory structure 
indexed memory shown highly successful memory structure field genetic programming 
successful programs performance plotted figures typically memory spots heavily ignore largely ignore rest memory elements 
size memory chosen elements simply legal value legal pointer memory memory element accessed pointer legal value 
possible memory sizes results shown sensitive changes long approximately memory slots 
possible different memory size needed different problem elements bits provide approximately different states 
part libraries play pado functionality 
initially library programs initialized random legal program teller veloso characteristics 
generation worst library programs removed library replaced successful programs generation 
chapter set 
goodness library program sum adjusted fitnesses programs called multiplied called ceiling fitness case 
adjusted fitness program rank program minrank 
notice main mini programs individual library programs evolve 
storage place best ideas population bad ideas moved favor ideas chance 
sense library population evolves fact evolves main population smart operator population individual library programs receive fitness proportionate reproduction genetic recombination 
bad library programs determined removed new ones created active area research 
smart operators traditional crossover 
evolving functions programs see section distinction issues related evolvability 
important language rep resentation genetic change paradigm genetic change operator 
gp language representation usually lisp structure 
pado radically different language representation genetic change paradigm genetic change operators gp longer appropriate 
gp main genetic change paradigm crossover 
standard crossover nodes picked expression tree 
nodes subtrees exchanged 
pado maintain general paradigm programs evolution arbitrary graphs trees dags 
knew equivalent crossover strategy general graphs picking subgraphs switch random 
space algorithms difficult negotiate space functions 
pado developed smart operators help choose subgraphs exchange exchange 
smart operator program takes program graphs input main mini deliberation indicates subgraphs program exchanged 
smart operators written pado language 
smart operators evolve separate pool time main population 
means act changes changing needs main population 
new approach genetic operators successful attribute pado success 
details smart operators fill chapter subject publication 
pad evolve programs functions 
just mentioned evolution difficult requires 
pado learning object recognition smarter recombination programs replace functions type thing see section population 
benefit programs functions pado avoid lot 
turns results shown chapter obtained similar fashion functions programs 
order achieve chapter results functions pado requires times space memory times hours computation 
experiments results near object recognition rate shown section 
pado ensure program stops fixed time 
mentioned section pado language turing complete 
pado waited program finished finished defined returned value state memory pado get past generation programs generated randomly run forever 
pado avoids problem constructing program anytime algorithm 
means program run long wants time pado may interpret done far answer answer memory 
programs execute main program reach node times program execution 
pado environment stops program milliseconds interprets series values program returned memory location main program answer 
program return single value series values averaged 
values near execution informed correct answer having time think series values linearly weighted value returned time weighted just way problem waiting programs halt 
ways constrain construction programs halt bounded amount time 
techniques investigated 
finish remarking pado architecture requires get fitness program bounded amount time 
pre set time threshold experiments milliseconds 
enforce program completion implementation detail feature general pado architecture 
program milliseconds run 
second second learning taken times long 
result information better programs long stretch think single image 
tests done time thresholds large milliseconds 
increase peak performance generation account longer time run generation rate increase computer cycles peak performances generation higher rates closer milliseconds 
machines change environment teller veloso improves second may second 
relevant talk gets done time allotted 
second program able evaluate approximately nodes 
numbers course machine implementation dependent 
remember nodes terminals pushing stack simple non terminals add evaluate quickly 
nodes take long time evaluate 
variance takes milliseconds 
program small fixed amount time run decide design code balance difference time cost evaluating various nodes 
answer second chosen number balanced criteria just mentioned 
choice means object recognizer take seconds object recognition 
results described section seconds 
point worth mentioning programs interpreted time run 
programs pado object recognizer compiled lisp pascal compiled assembly run 
probably yield speed increase fold 
parallel pado 
mentioned pado classes took seconds prediction 
number machine implementation dependent 
speed little slow reactive agent computer vision general speed reasonable 
scale classes kept programs system take seconds recognize image 
compiled programs mentioned probably drop seconds speed little slow 
brings pado parallel 
learned systems complex job pado easily parallelized 
classes programs selected groups programs run processors available time find answer cut factor 
programs take exactly amount time run speed parallelism exactly linear 
robot processors board recognize classes half second current compiled pado technology 
orchestration weight vector tuning 
orchestration important part pado architecture 
implementation orchestration important partly solutions 
example alternative method orchestration pado tested 
orchestration procedure program developed separate pado run inputs outputs different object discrimination programs output confidence 

pado learning object recognition program easy see learn return program gave largest input orchestration program 
orchestration program fact implement weight vector tuning memory complicated 
implementation orchestration required second smaller training set took time example chapter 
results object recognition comparable shown section 
additional piece appeal weight vector tuning fast really reason leave time testing phase 
life span usefulness conditions may change periodic 
continual orchestration tuning allow learned system quickly turn decision making programs suited current conditions 
continual adjustment reasonable way test performance system 
line pado large amount computation learning 
testing may case system gets feedback doing 
additional learning real time allowed encouraged 
orchestration take place part training phase word orchestration learning partly activity orchestrating parts important counts learning testing 
time take get results 
discussed orchestration takes entire cost develop pado recognizer time takes evolve programs pado recognizer 
takes approximately hours cpu time decstation train classes generations 
incremental learning generation takes hours cpu time 
approaches megabytes memory 
environment written improvements exploration alternative techniques explored current research 

related issues program decide confidence class 
best program best trusting response program best pado able 
reason approach optimal top programs picked determined training phase 
guarantee individual best fit training data generalize best 
reason top programs group information ex program image similar responses specific pictures highly correlated reason 
correlation relatively low 
turns errors best program group test images largely independent errors second best program group test images 
similarly teller veloso second best relative third means approximately reduce error programs 
chance majority wrong goes number increases 
top programs fit able discriminate correctly example average program group disadvantage pado object recognition 
pado object recognizer programs predictions 
pado takes programs group small constant 
pado grows linearly time space increasing group size 
know images aren easy distinguish 
image average intensity book bottle cap coke glasses hammer image average intensity bear book sampled picture sampled picture average image intensity random images rom ass 
shows average intensity randomly selected images class set images total 
clearly piece global information partition images correct classes 
fact course rule existence global property image partitioning done successfully 
non local image primitives programs average variance difference tested global properties 
graphs primitives data types look shown 
large amount variance pictures class tests suggests real predictive power values 
successful technique recognizing objects images part ability focus attention 
just concluded pado recognizer doing difficult say hard images distinguish 

pado learning object recognition complexity density programs hard ascertain example particular successful program looking light dark boundaries looking particular shapes textures type visual clue 
detail note pado may give object position free images single object 
mentioned section people may feel object recognition requires object position location image pose determination 
image primitive pado executes pixel average variance difference takes place particular part image 
simple computation find image particular best program class looks center mass image primitive locations turns high probability center mass near center object image 
object typically takes image moves widely images happens regularity pado demonstrates ability focus attention returns free piece information object location image 
reasons exist believing pado scale classes 
pad ranks population different dimensions 
turns best class program class words turn generation program best distinguishing bottles objects happens pretty distinguishing coke cans objects 
coke sprite bottle visual similarities shape size 
scale number classes introduce hierarchical orchestration 
difficult part pad construction hierarchical structure classes 
indications similarity just mentioned find correlations image classes build hierarchy 
said section 
pado similar classes 
results shown chapter tests pado passed 
example set originally dimensions color saturation brightness 
pado color information performance object recognition jumped 
reason images different dimension 
dimension color 
objects different colors information indicator class 
effort problem harder gave pado brightness data greyscale images shown 
pado didn problem got harder 
mentioned section 
pado performance different shoe classes question certainly chosen objects signals represent objects similar 
teller veloso 
issue scalability critical success pado 
trying design learning architecture build useful systems applied natural environments 
pado designed eye success scientific advancement able scale hard problems 
obvious area scalability number classes 
chapter dealt system performed environment classes 
real applications recognizing classes applications need able recognize hundreds classes 
discussion section mentioned new types orchestration active part current 
doing hierarchical structure orchestration hope number classes pado handle move hundreds 
second important area scalability performance 
pado results set set better random perfect 
applications useful error applications require error rates tolerate 
pado ability improve performance critical pado 
issue important remember pado begins tackle hundreds objects tens objects difficulty problem rises quickly impressive pado maintain current performance classes number classes rises 
pressing time factor scalability issue pado 
require pado perform better classes number generations necessary achieve state 
learning done line non time critical way increasingly important find faster ways implement pado better architectural choices require space time 
point pado favor evolutionary computation lends easily massive parallelization 
processors divide pado learning time fold 
additional avenue started explore incremental learning 
discussed section possible train classes add new class 
ability get new classes quickly speed improves may able conquer time problem way 
partly difficult understand hard know exactly role libraries smart operators play pado performance 
clearly performance pado depend heavily improve features pado architecture 
investigation greater understanding parts pado architecture understood 
examples just mentioned libraries smart operators 
cases indications vital functioning 
pado learning object recognition system don completely understand 
doing better understand different aspects pado help change things achieve goals scalability mentioned 
example pado aspect investigated programs 
understanding better accomplish tasks may able learn general object recognition signal understanding done 
innovative applications pado pado designed specifically images 
designed able classification set signals 
important steps pado growth series classification tests variety signal types designed pado mind 
signal types include speech sonar radar text 
news pado applied noises recorded real world environments achieved classification rates high sounds images reported chapter 
summary open questions research effort pado scale large number classes 
pado learn amount faster 
pado improve performance number classes increase 
pado prove general signal classification learning architecture 
investigation questions part immediate research agenda 

chapter began motivation signal symbol problem 
ai systems need reason high level information world provides huge amount noisy raw data 
bridge realms significant tool ai 
humans depend heavily signal symbol translation visual cortex 
cue decided tackle problem object recognition 
object recognition major flaw address unconstrained natural environments 
machine learning aside small pockets success delivered area 
level success may learning architectures applied designed task understanding real world signals 
belief new architectures pado born 
chapter shown application pado related tasks different sets image data 
sets image data fall outside constraint boundaries object recognition tasks usually require 
translation rotation lighting foreshortening allowed object classes 
addition objects classes simple uni colored geometric rigid cases 
difficult problems pado achieved object recognition rate teller veloso 
classes times better random guessing accomplish 
mentioned discussion section pado performance images set jumps original color images 
performance described chapter image sets deliberately dicult 
pado achieved performance help users domain specific information kind 
prove point pado primitives accessing images simplest possible functions pixel average variance difference 
fact primitives coded pado half hour sucient different image set set supports hypothesis pado achieve significant level performance little outside intervention 
design pado architecture provides exciting features 
point learning process program group signal understanding systems extracted immediately object recognition 
pado incorporates evolution design providing chance exploit myriad different solutions orchestration 
orchestration independent solutions possible simple run pado parallel machine linear speed increase 
architecture independence particular examined signal viable pado signal type 
paths pado research diverse 
near hope see pado performing better fewer examples classes harder images 
addition pado designed perform signal understanding signal type text sonar spectrum speech 
goal performance current highest levels learned understanding signal type try 
mentioned previous section pado applied noises recorded real world environments 
pado achieved classification rates high sounds number classes images reported chapter 
researchers today spend significant amount time finding right learning algorithm task tweaking algorithm performs 
simply domains lead real progress 
believe pado domain independent learning architecture significant impact solving general signal symbol problem 
gratefully acknowledge sebastian thrun permission images tom mitchell providing hardware take images 
peter stone perez eric siegel joseph matt mark wheeler invaluable readers 

pado learning object recognition appendix sample program program best recognizing hand held generation 
legend gn meaning ii sign meaning ii sign meaning action action node arc start node branch branch decision node branch constant main action branch action branch div mult div read max variance min max max write sub mult sub mult read min add write max read eq eq div read eq eq read read average mult add sub library add div write read div div add add sub mult write sub add library eq mult min average eq div mult library action branch action branch eq diff add add add library sub mult read div library action branch action branch read library max add read div div variance sub sub pixel add pixel eq eq eq eq mult add write library action branch action branch write max div eq write eq min sub write sub add max mini eq sub add add min sub mini called program teller veloso david andre 
automatically defined features simultaneous evolution dimensional feature detectors algorithm 
jr kenneth kinnear editor advances genetic programming pages 
mit press 
aggarwal 
cad vision object recognition cluttered range images recognition strategies 
image understanding pages 
ablex 
david 
marvel system recognizes world location stereo vision 
ieee transactions robotics automation pages 
ieee 
michael patrick johnson evolving visual routines 
rodney brooks pattie maes editors artificial life iv pages 
mit press 
david goldberg 
genetic algorithms search optimization machine learning 
addison wesley press 
john koza 
genetic programming 
mit press 
john koza 
genetic programming ii 
mit press 
li 
vision range images optimization framework 
image standing pages 
ablex 
nguyen thomas huang 
evolvable model object recogni tion systems 
jr kenneth kinnear editor advances genetic programming pages 
mit press 
dean pomerleau 
neural network perception mobile robot guidance 
phd thesis carnegie mellon university school computer science 
walter tackett 
genetic programming feature discovery image discrimination 
stephanie forrest editor proceedings fifth international conference genetic algorithms 
morgan kauffman 
walter tackett 
recombination selection genetic construction computer programs 
phd thesis university southern california 
available technical report 
dept electrical engineering systems 
walter tackett 
greedy recombination genetic search space computer programs 
whitley vose editors proceedings third international conference foundations genetic algorithms pages 
morgan kauffman 
astro teller 
evolution mental models 
jr kenneth kinnear editor advances genetic programming pages 
mit press 
astro teller 
genetic programming indexed memory halting problem cu 
proceedings th annual flairs pages 
ieee press 
astro teller 
turing completeness language genetic programming indexed memory 
proceedings ieee world congress computational intelligence pages 
ieee press 
astro teller 
evolving programmers 
proceedings sixth international conference genetic algorithms 
morgan kauffman 
submitted review 
astro teller manuela veloso 
program evolution data mining 
international expert systems journal 
ieee 
submitted review 
thrun mitchell 
learning thing 
technical report cmu cs department computer science carnegie mellon 
mark wheeler ikeuchi 
sensor probabilistic hypothesis gen eration robust localization object recognition 
ieee transactions pattern analysis machine intelligence volume march 
