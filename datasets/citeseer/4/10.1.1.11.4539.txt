source code instrumentation quantification events robert filman riacs nasa ames research center ms moffett field ca mail arc nasa gov aspect oriented programming making quantified programmatic assertions programs annotated receive assertions 
varieties aop systems characterized quantified assertions allow permit actions assertions including actions interact base code mechanisms achieve effect 
argue quantification dynamic events describe preliminary developing system maps dynamic events transformations source code 
discuss possible applications system particularly respect debugging concurrent systems 
categories subject descriptors programming languages language constructs features aspects 
programming languages language classifications aspect oriented programming 
software engineering coding tools techniques 
testing debugging debugging aids 
general terms languages 
keywords quantification events dynamic events debugging program transformation model checking 

argued programmatic essence aspect oriented programming making quantified programmatic assertions programs annotated receive assertions :10.1.1.28.287
aop system wants able say things form program happens execute behavior having go marking places desired behavior happen 
varieties aop systems characterized quantified assertions allow permit actions assertions including actions interact base code mechanisms achieve effect 
describe preliminary developing system takes notion aop quantification logical extreme 
goal develop system behavior attached event program execution 
describe planned implementation system discuss possible applications technology klaus havelund kestrel technology nasa ames research center ms moffett field ca havelund email arc nasa gov particularly respect debugging validating concurrent systems 

events quantification implies matching predicate program 
predicate domain 
quantification implicit invocation papers distinguished static dynamic quantification 
static quantification worked structure program 
static quantification programming language structures system 
examples structures include program variables calls subprograms loops conditional tests 
common aop implementation techniques understood terms quantified program manipulation static structure program 
example wrapping seen composition filters aspectj effectively embedding particular function bodies complex behavior 
aspectj provide call side wrapping understood surrounding calling site additional behavior 
operation asserting class class hyper realized substituting common generated variable text dynamic quantification described papers speaks matching events happen course program execution 
example dynamic quantification problem method behaves differently depending called calling stack sense specified routine 
examples interesting dynamic events include stack exceeding particular size fifth unsuccessful call login routine different password change number object confluence variable values blocking thread synchronization lock change executing thread 
cflow operator aspectj dynamic quantification predicate 
coming belief events dynamic 
static quantification understood just events simply inferred basis structures program 
static quantification attractive straightforward aop implementation lower complexity independence programming environment implementation starts processing program comments little table events event loci event syntactic locus accessing value variable field variable modifying value variable field assignments variable invoking subprogram subprogram calls cycling loop loop statements branching conditional conditional statement initializing instance constructors object throwing exception throw statements catching exception catch statements waiting lock wait synchronize statements resuming lock wait notify synchronizations testing predicate fields modification fields changing value path control data flow analysis statements slices swapping running thread reliably accessible may possible stack subprogram calls freeing storage reliably accessible try built primitives throwing error reliably accessible happen static structure program isn marked dynamic execution 
syntax tree domain static quantification domain dynamic quantification 
considering examples section really events change state data state program counter base language interpreter 
defining terms interpreter problematic 
illustrated smith lisp programming languages defined terms interpreters 
language implemented different interpreters 
set events generated implementation language may correspond events generated 
example run time environment manages threads relies underlying operating system thread management 
takes advantage multiple processors real multiprocessor machine 
second compilers traditionally allowed rearrange programs long preserve input output semantics 
optimizing compiler may rearrange elide obvious sequence expected events 
data state interpreter including memory grand awkward thing manipulate 

language events view limitations bumps road barriers 
may able capture goes particular interpretive environment get close practical purposes 
strategy adopt argue dynamic events necessarily localized particular spot source code tied places source code 
table illustrates primitive events associated code loci 
users want express just primitive events 
language events want describe relationships events event occurred set events match particular predicate event occurred particular event matching particular predicate occurred 
suggests event language need temporal relationships temporal quantifiers concrete temporal relationships referring clock time cardinality relationships number times event occurred aggregation relationships describing sets events 

system architecture envision mechanism description set pairs program compiler 
event action pair include sentence describing interesting event event language action executed event realized 
said actions programs parameterized respect elements matching events 
examples assertions call method foo class implements interface replace second parameter call foo result applying method parameter 
value object class exceeds print message log reset 
call method foo occurs level stack method baz intervening call source java code event action descriptions event edit compilation transform parse ast system architecture target java code method omit call method gorp body foo 
examples natural language 
course actual system employ formal 
clearly sufficiently meta interpretation mechanism give access interesting events interpreter enabling direct implementation ideas 
observed meta interpretative reflective systems build aop systems 
meta interpreters traditionally exhibited poor performance 
looking implementation strategies cost event recognition paid event recognition 
suggests compiler transform programs basis assertions 
compiler extended syntax tree representation program 
map predicate event language program locations affect semantics event 
mapping requires syntax tree generation parsing symbol resolution developing primitives respect control data flow program determining visibility lifetimes symbols analyzing atomicity actions respect multiple threads 
java compiles intermediate form java byte codes 
dealing java choice process respect source code byte code 
advantages disadvantages 
byte codes real issues interest actual access variables power consumption instructions revealed precisely bytecode level 
working byte codes allows modify classes hasn source code including java language packages 
example aop system performs transformations byte code level 
hand source code naturally understandable allows writing transformations human level eliminates need understanding jvm actions compiler 
de prolog meta programming system example source level transformation aop 
find complexity arguments appealing 
implementation plan source code level 

examples event quantification general framework supporting aspect oriented programming 
functionality enhancement program extended aspects add new functionality 
example program reliable transforming database update events send messages backup log 
functionality extension general goal aop discuss examples area program verification 
cases expect able extend program behavior functionality insurance recovering classes program failure 
previous studied various program verification techniques analyzing correctness programs 
classified categories program monitoring program scheduling :10.1.1.29.7274
called model checking 
specification monitoring consists monitoring execution program represented sequence events validating events requirements specification 
specification written formal language typically temporal logic 
example typical requirement temp seconds alarm true typical requirement specification assertions 
want able run program monitor specification assertions hold event trace 
java system implements kind capability 
uses bytecode engineering tool instrument java bytecode emit events observer contains data structure representing formulae checked 
event emitted running program causes modification data structure 
warning raised specification violated 
plan experiment event quantification source code level bytecode level 
events caught obviously implicitly referred formula example updates variables temp alarm 
variables updated event consisting variable name value timestamp emitted observer 
evaluation temporal formula performed part quantification action separate observer real time performance issue 
operating source code level clear advantage simplifying creating instrumentation high level language bytecode 
commercial available temporal rover system performs specification monitoring automated code instrumentation 
algorithm monitoring specification monitoring watches execution program emitting events 
matching user defined specifications monitoring uses certain general algorithms detecting particular kinds error conditions 
examples algorithms detection deadlock data race potentials concurrent programs 
algorithms interesting actual deadlocks data races occur execution trace order identified potential problem 
arbitrary execution trace normally suffice identify problems 
example cyclic relationship locks program thread takes lock thread takes potential deadlock 
similar algorithm exists data races 
algorithms implemented bytecode engineering anticipate trying event quantification 
thread scheduling consists influencing program scheduling order explore thread interleavings achieved normal testing techniques 
example mentioned deadlock situation explicitly demonstrated scheduling threads takes immediately takes schedule seen normal test program 
thread scheduling achieved introducing centralized scheduler forcing threads communicate scheduler shared data structures locks accessed 
scheduler decides thread run time keeping track scheduling choices 
information direct program explore new interleavings 
earlier developed java pathfinder system performing scheduling analysis model checking :10.1.1.29.7274
order avoid exploring reachable subtree program state times states stored cache search aborted state visited 
quantification plan experiment state model checking program different interleavings explored storing states 
example program modification detect synchronization faults contest 

related de workers argued doing aop program transformation prolog system working text java programs 
want extend ideas program semantics combining textual locus dynamic events transformations requiring complex analysis source code 
ecoop aop workshop fradet argued certain classes aspects expressed static program transformations 
expanded argument ecoop aop workshop checking robustness non localized dynamic properties system state 
fradet realized implementation ideas applying syntactic semantic program transformations enforce desired properties programs 
system user specify desired property program regular expression syntactically identified points program program transformed raises exception property violated 

concluding remarks examined idea implementing aop systems programs transformed quantified responses dynamic events 
comments place system order things worth making talking implementation environments software engineering 
underlying implementation imply right organization separate concerns user 
particular completely agnostic appropriate structure actions action event pairs 
may case unqualified event language raw action code snippets software engineering wonder doubt 
environment map quantified dynamic events modified code excellent environment experimenting building systems aop 
sense ideas viewed domain specific language developing aspect oriented languages 

acknowledgments patel tom comments draft 

bergmans aksit composing crosscutting concerns composition filters 
comm 
acm vol 
pp 

de de jumping aspects 
workshop aspects dimensions concerns ecoop cannes france jun 
cs 
utwente nl workshops adc papers pdf cohen recombining concerns experience transformation 
workshop multi dimensional separation concerns object oriented systems oopsla oct 
www cs ubc ca murphy workshop oopsla position papers ws cohen pdf fradet enforcing trace properties program transformation proc 
th acm symp 
principles programming languages boston jan pp 

des rivieres smith implementation procedurally reflective languages 
conference record acm symposium lisp functional programming austin texas aug pp 

de mens hondt logic meta programming framework domain specific aspect programming languages 
www cs ubc ca binaries cacm aop pdf de hondt aspect oriented logic meta programming 
proceedings meta level architectures reflection second international conference reflection 
lncs springer verlag pp 

temporal rover atg rover 
spin model checking software verification lncs klaus havelund john penix willem visser eds springer pp 

nir ur multithreaded java program test generation 
ibm systems journal vol 
pp 

filman aspect oriented programming revisited workshop advanced separation concerns th european conference object oriented programming budapest jun 
cs utwente nl workshops ecoop papers filman pdf filman barrett lee linden inserting controlling communications 
comm 
acm vol 
jan pp 

filman friedman aspect oriented programming quantification obliviousness workshop advanced separation concerns oopsla minneapolis oct 
cs utwente nl workshops oopsla papers filman pdf fradet generic framework aspect oriented programming third aop workshop ecoop workshop reader lncs pp 
jul 
cs utwente nl aop ecoop papers fradet pdf fradet aspect language robust programming int 
workshop aspect oriented programming ecoop jun 
cs utwente nl papers fradet pdf godefroid model checking programming languages verisoft proc 
th acm symp 
principles programming languages paris france jan pp 

havelund model checking java programs java pathfinder 
international journal software tools technology transfer vol 
apr pp 

havelund rosu monitoring java programs java 
proceedings international workshop runtime verification rv electronic notes theoretical computer science vol 
elsevier science paris france jul 

compaq 
www compaq com java download kiczales hilsdale hugunin kersten palm griswold overview aspectj proceedings ecoop knudsen ed 
berlin springer verlag lncs pp 

kiczales hilsdale hugunin kersten palm griswold getting started aspectj 
comm 
acm vol 
pp 

ossher tarr shape things come multi dimensional separation concerns hyper re shape evolving software 
comm 
acm vol 
pp 

pnueli temporal logic programs 
proceedings th ieee symposium foundations computer science pp 

savage burrows nelson sobalvarro anderson eraser dynamic data race detector multithreaded programs 
acm transactions computer systems vol 
nov 
stoller model checking multi threaded distributed java programs 
international journal software tools technology transfer press 
sullivan aspect oriented programming reflection meta object protocols 
comm 
acm vol 
pp 

teitelman masinter interlisp programming environment computer vol 
pp 

visser havelund brat park model checking programs 
proceedings ase th ieee international conference automated software engineering 
ieee cs press sep pp 

