aachen department computer science technical report liveness rewriting urgen giesl hans zantema issn 
informatik berichte 
aib rwth aachen 
department computer science 
jan revised version publications department computer science rwth aachen aachen university technology general accessible world wide web 
aib informatik rwth aachen de liveness rewriting urgen giesl hans zantema informatik ii rwth aachen 
aachen germany giesl informatik rwth aachen de department computer science tu eindhoven box mb eindhoven netherlands zantema tue nl 
show problem verifying liveness properties related termination term rewrite systems trss 
formalize liveness framework rewriting sound complete transformation transform liveness problems trss 
transformed trs terminates original liveness property holds 
shows liveness termination essentially equivalent 
apply approach practice introduce simpler sound transformation satis es part 
re ning existing techniques proving termination trss show liveness properties veri ed automatically 
examples prove liveness property waiting line protocol network processes liveness property protocol ring processes 
usually liveness roughly de ned eventually happen remarked termination particular case liveness 
liveness general precise setting study relationship liveness termination 
framework reduction term rewrite systems 
classically trss applied model evaluation programming languages 
aim rewrite systems study liveness questions high importance practice protocol veri cation distributed processes 
particular show verify liveness properties existing termination techniques trss 
sect 
de ne suitable notion liveness reduction 
sect 
notion specialized framework term rewriting show liveness expressed rewrite relation 
discuss actual liveness properties veri ed 
sect 
investigate connection liveness termination 
precisely sound complete transformation allows express liveness problems termination problems ordinary trss 
shows techniques proving termination trss infer liveness properties 
order apply approach practice preceding results sound incomplete technique perform termination proofs liveness properties sect 
signi cantly easier 
contrast model checking related methods technique require niteness state space 
demonstrate approach case studies networks shared resources token ring protocol sect 

liveness reduction section give formal de nition liveness framework reduction 
assume set states notion computation expressed binary relation means computation step possible 
computation sequence reduction de ned nite sequence nite sequence write re exive transitive closure represents zero computation steps 
de ne liveness assume set states set initial states 
reduction maximal nite element set normal forms nf ft ug 
liveness property live holds maximal reduction starting contains element de nition liveness set states denote nite sequence states 
live holds 

nf example termination strong normalization sn special liveness property describing non existence nite reductions sn theorem property sn holds live nf holds 
proof 
part sn hold nite reduction 
due nf de nition nite reduction contain elements nf contradicting property def 

conversely sn holds property de nition live nf holds trivially 
property holds nf 
ut thm 
states termination special case liveness 
theorem proves kind converse 
purpose restrict computation relation may proceed current state de nition def 

relation holds show live equivalent sn 
part holds conditions 
part demand contains normal forms nf reachable nf fu nf ug 
terminating sequence sn live 
theorem nf live holds sn holds 
proof 
part assume sn 
property def 
holds nf property hold nite reduction elements starting contradicting sn 
conversely assume live holds sn hold 
nite sequence contradicting property def 

ut thm 
allows verify actual liveness properties nf verify termination nf sn implies liveness property nite computations 
sect 
show techniques prove termination trss termination liveness term rewriting focus liveness rewriting study property live rewrite relation corresponding trs term rewriting reader referred example 
signature containing constant set variables 
write set terms set ground terms 
term denote variables function symbols occurring represents computation states 
thm 
live equivalent sn nf order verify liveness want prove sn approaches termination proofs ordinary trss 
depending form di erent techniques required 
remainder restrict sets form ft contain instance pg term words contains terms written context substitution 
holds term may reduced contains instance term typical example liveness property eventually processes requesting resource granted access resource see sect 

process waiting resource represented unary function symbol old terms denote state network de ne ft contain instance old live means eventually reaches term symbol old 
arbitrary terms trss notion useful symbol arity contains variable written context termination implies termination full rewrite relation reason nite reduction 
gives rise nite reduction 

cases terms concentrate particular case top rewrite systems designated symbol top 
trss regarded special forms typed rewrite systems 
de nition top rewrite system signature top new unary function symbol 
term top term root top top occur root 
top denote set ground top terms 
trs signature top rewrite system rules top terms case speak top rule contain symbol top non top rule top rewrite systems typically suce model networks processes network represented top term 
clearly top rewrite systems top terms reduced top terms 
systems consider liveness properties live top 
want prove maximal reduction ground top terms contains term instance example simple liveness example consider rule trs top top clearly terminating nite reductions top top top top top reduction eventually reaches term liveness property ful lled ground top terms 
note fc fg nf top nf top thm 
sucient verify terminating top reduction possible top normal form liveness termination section investigate correspondence liveness termination framework term rewriting 
previous section consider liveness properties live top top rewrite systems consists terms contain instances subterm provided nf top thm 
liveness property equivalent sn top 
aim prove termination top means termination trss 
way existing techniques termination proofs term rewrite systems including developments order prove liveness properties 
rst step direction taken termination proof technique dependency pairs verify certain liveness properties telecommunication processes 
aim develop approach connect liveness termination general 
trs term de ne trs terminates terms sn top 
transformation direction holds called sound direction holds called complete 
existence sound complete transformation shows rewrite relations liveness termination essentially equivalent 
construction motivated existing transformation developed completely di erent purpose termination contextsensitive rewriting 
introduce number new function symbols resulting extended signature proper checks ground term original signature lemma match checks addition matches lemma 
case proper match reduce ok 
ease formulation match rules restrict linear terms variable occurs variable introduce fresh constant denoted corresponding upper case letter write ground term obtained replacing variable corresponding fresh constant way suces handle ground terms match rules 
new symbol check investigates argument ground term contains instance lemma 
case check reduces nd instance check may propagated downwards term reaches instance active denotes may reduced contains instance active may propagated downwards desired redex term 
reduction step active replaced mark propagated upwards top term 
checks resulting term contains instance newly introduced function symbols 
mark replaced check 
instance check turned propagated top term replaced active 
trs designed way nite reductions possible process repeated nitely lemmata investigate behavior formally 
de nition top rewrite system top linear 
trs signature ftop match active mark check proper start fx consists rules non top rules top rules top top arity constants active mark top active top mark top mark top check check proper check proper check start match match match match match ok match proper proper ok proper proper proper ok ok ok start ok ok ok top top active active active mark mark example transformation simple liveness example recall system ex 

transformation yields trs 
active mark proper ok top active top mark proper proper top mark top check ok ok check check start ok check start match match match top top active match proper active active mark mark note really necessary introduce symbol proper check term contain new symbols 
proper rules removed remaining proper terms replaced arguments ok ok terms ok replaced transformation complete 
counterexample regard fa fg trs top top top top top top trs satis es liveness property ground top term steps reaches term obtains top top 
modi ed transformation get non terminating cyclic reduction term top mark top check top check top check top active check top mark prove soundness completeness transformation need auxiliary lemmata reductions 
rst lemma states proper really checks argument contain symbols 
lemma reducing proper proper ok proof 
proof identical lemma 
ut show match checks matches 
lemma reducing match linear 
match ok 
proof 
direction note variable constant 
match proper ok lemma 
easy induction structure term constant implies match match ok ok 
form 
matches obtain matches note induction hypothesis implies match ok 
obtain match match match match ok ok ok ok 
prove direction induction length reduction 
words prove match ok implies matches 
induction hypothesis match ok implies matches provided reduction match ok shorter reduction match ok 
rst reduction step match match ok term induction hypothesis states note implies proves lemma 
rst reduction step root position normal form 
variable obviously matches obtain match proper ok lemma 
constant root reduction possible obtain match match ok 
case lemma holds 
root reduction 
match match match match ok 
reduce ok arguments reduce ok terms 
match ok formally prove match ok induction smaller induction relation induction hypothesis match ok 
induction hypothesis instantiated arbitrary terms 
similar forms induction 
reductions shorter reduction match ok 
induction hypothesis implies substitutions linear combine implies proves lemma 
ut lemma proves check works properly checks argument term contains instance lemma reducing check linear 
check contains subterm 
proof 
direction easy structural induction proof prove direction induction length reduction 
rst reduction step proof analogous lemma 
check start match 
start rule implies match ok term lemma matches check proper check proper 
way reduce term term argument reduces reduce ok 
terms check proper ok length reduction check shorter length check induction hypothesis yields contains 
lemma implies 
lemma proved 
ut lemma shows top rules applied alternating way 
lemma reducing active check active 
active 
ok check 
mark proper 
mark proof 
induction show reduction active ok length rst reduction step claim follows induction hypothesis 
reduction starts root step 
rst step active mark root symbol mark reduced 
active active active 
order rewrite term ok term particular active rewritten ok term contradicts induction hypothesis 
induction length reduction 
reduction starts inside claim obvious 
reduction start check start match start reduced term reduced 
constant obtain similar contradiction reduction form proper proper ok ok reduced 
check check proper check proper proper proper proper proper 
order reduce terms mark term arguments reduced mark term contradiction induction hypothesis 
ut prove top rules crucial termination behavior 
lemma terminating 
proof 
termination proved recursive path order precedence active check match proper start ok mark fx ut relating study connection lemma 
active mark top active top mark top top 
proof 
direction easy induction direction rst prove active mark implies induction length reduction 
rst reduction step root position 
active mark root position rule active active active mark 
active mark 
induction hypothesis implies show top active top mark implies top top 
rst reduction step root position position root active 
top active top mark root position top top instance rule 
top active top mark position rule top top 
top active top active top active top mark 
active mark 
shown active mark implies top top 
ut theorem soundness completeness top rewrite system top linear 
trs terminating terms relation terminating top proof 
rst show direction 
terminate top nite reduction top top 
lemma top active top mark 
lemma implies check contains instance obtain contradiction termination 
top active top mark top check top top active direction assume terminating 
type show exists nite reduction ground top terms 
due lemma reduction contains nitely applications rules 
rules applied alternating order active reduce check reduce mark lemma 
reduction form reductions rules displayed 
top mark top check top top active top mark top check top top active lemma contains instance lemma implies top top 
obtain top top contradiction termination top ut example termination proof simple liveness example thm 
existing techniques termination proofs trss verify liveness systems ex 

instance termination transformed trs ex 
easily shown dependency pairs 
dependency pairs cycles estimated dependency graph top active top mark top mark top check top top active check check match match proper proper ok active active mark dependency pair narrowed top mark top check top mark top start match narrowed top mark top start match longer cycle estimated dependency graph 
narrowed top top mark summarize top dependency pairs replaced top mark top check top mark top start match top top mark note due lemma cycle top dependency pairs contains pair 
suces just strictly decreasing weakly decreasing 
argument ltering maps start maps match match 
resulting constraints satis ed recursive path order precedence active mark check match proper ok considered equal 
proving liveness sect 
sound transformation suitable mechanizing liveness proofs complete transformation preceding section 
reason new transformation termination transformed trs easier show 
hand approach section incomplete succeed examples 
subsequently sect 
introduce preprocessing technique semantic labelling simplify termination proofs 
way rewriting techniques veri cation liveness properties 
sound transformation liveness goal sound transformation liveness properties live top transform original trs trs ls required property sn top concluded termination transformed system 
idea introduce new symbol check application top rule 
check nds instantiation check may removed 
check remains term may block reductions 
de nition ls top rewrite system top ls consist rules 
non top rules top top check top rules top top check check arity check example simple example revisited illustrate transformation reconsider system ex 

ls trs termination proved dependency pairs recursive path order dependency pair top top check cycle dependency graph 
top top check check check check show transformation sound 
words termination proof veri es liveness property example 
theorem top rewrite system top ft contain instance ls terminating nite reduction top terms 
proof 
assume nite reduction top terms top top top occur form context substitution prove theorem show top ls top obtain nite ls reduction 
top top application non top rule top ls top contained ls 
top top top rule top top 

ls contains rules check check arity obtain top top ls top check top check ls top check ls top top ut example sound transformation complete transformation incomplete shown top rewrite system top top fa fg example normal forms contain nite reduction top terms reaches term top contain symbol 
liveness property holds 
ls admits nite reduction top 
top check 
top check 
top check 
transformation def 
incomplete check remains term necessarily block nite reductions 
preprocessing procedure verifying liveness aim sound transformation def 
simplify possibly automate termination proofs required order show liveness properties 
trss resulting transformation particular form method preprocess trss 
preprocessing especially designed form trss way termination proofs simpli ed signi cantly 
method consists steps performed automatically deletes rules cause non termination 
applies known transformation technique semantic labelling particularly chosen model labelling 
restricted form semantic labelling done automatically 
deletes rules cause non termination 
uses existing automatic technique recursive path order dependency pairs prove termination resulting trs 
delete rules step lemma 
function symbol term number symbols occurring 
lemma trs non duplicating rule variable occurs rules 
consist rules satisfy 
terminating terminating 
proof 
part holds part assume terminating nite reduction 
due conditions lemma step step due foundedness natural numbers nite reduction contains nitely steps 
removing nite initial part containing steps remaining part nite reduction gives contradiction 
ut application lemma easily automated follows sets small checked rules rules satisfying removed 
process repeated rule removed 
rst example apply lemma trs ex 

counting occurrences note number symbols strictly decreases rule remains rules 
due lemma drop rule proving termination trs 
turns case repetition process succeed removing rules 
termination procedure step apply particular instance semantic labelling 
describing instance brie explain semantic labelling works tool prove termination trs signature starts choosing model trs de nes non empty carrier set function symbol arity interpretation chosen 
usual variable assignment extended terms inductively de ning 
interpretation model rule variable assignment model trs signature transformed labelled trs labelled signature 
function symbol arity may labelled elements ff arity mg arity arity variable assignment de ne function lab labels function symbol interpretations arguments lab lab lab lab trs de ned consist rules lab lab variable assignments rules main theorem semantic labelling states terminating terminating 
general semantic labelling permits lot freedom hard automate may choose arbitrary models 
full semantic labelling may arbitrary labellings 
restrict case 
nitely possibilities interpretations model 
means restriction termination method consisting steps fully decidable 
improve eciency avoid checking possibilities element model semantic labelling propose heuristics choosing interpretations model 
heuristics adapted special form trss resulting transformation def 
verifying liveness properties 
main objective want distinguish terms contain instances terms 
aim interpret terms terms 
intention check occurrence check interpreted constant function 
top occurs top top may choose constant function 
having objectives mind arrive heuristic choosing operations model top check root symbol constant min symbols long con ict model requirement 
particular remaining unary symbols tries choose applying heuristics example results interpretation top check checks model trs 
essential rst removed rule 
labelling results trs top top check check check check step termination procedure apply lemma 
counting occurrences top drop rst rule 
counting second rule removed counting check delete third rule 
remaining trs just contains rule check check termination trivial prove recursive path order 
example indicates preprocessing trs steps simpli es termination proof considerably 
original trs ex 
needs dependency pairs termination proof transformation simple recursive path order sucient 
case studies liveness demonstrate applicability approach regard examples liveness properties networks processes 
model protocols trss approach represent state network processes top term 
sect 
discuss straightforward extension approach unary top symbol framework easily extended top symbols arbitrary arity 
similarly extension liveness terms pn just easily possible 
shared resource single waiting line case study motivated protocols similar bakery protocol 
describe network processes want gain access shared resource 
processes waiting resource served 
maximal size waiting line xed new process enter waiting line process current line served granted access resource 
example state space nite maximal length waiting line arbitrary 
words show liveness property holds 
techniques classical model checking applicable 
processes line served rst rst basis corresponds serving clients shop 
front waiting line process may served serving denoted constant serve 
process served place line replaced free place denoted free 
place front process free process may take free place creating free place original position 
line free place back new process new may enter waiting line position free place 
apart new processes represented new consider old processes represented old line initially 
want verify liveness property eventually old processes served 
introducing symbol top back waiting line network described top rewrite system top free top new new serve free serve new free free new old serve free serve old free free old note trs admits nite reductions top terms 
instance top new serve top free serve top new serve describes protocol serving processes letting new processes enter may go forever 
prove nitely steps reaches term symbol old eventually old processes served 
terminology liveness property represented live top ft contain instance old note liveness property hold various variations system 
instance processes allowed swap new old old new new processes allowed line top top new liveness destroyed 
top serve ground top term normal form conclude nf top thm 
required liveness property equivalent sn top 
prove termination property thm 
may prove termination trs ls top free top check new new free free new old free free old new serve free serve old serve free serve check free free check check new new check check old old check check old old standard techniques automated termination proofs trss succeed trs preprocessing steps termination easily shown automatically 
rst delete rules uence termination 
counting occurrences old lemma remove rule 
step apply heuristics semantic labelling arrive top check old newm free serve 
model trs 
purpose remove rule old serve free serve 
corresponding labelled trs top free top check new new free free new old free free old new serve free serve check free free check check new new check check old old check check old old 
remains prove termination trs rules 
step repeatedly apply lemma 
consecutively choosing ffg top old new free free check rules nally removed 
termination remaining system consisting rules easily proved recursive path order precedence satisfying check old free check new free new free liveness property example proved automatically 
emptying local memories processes example variant process veri cation problem 
simplify presentation details variant represents basic underlying problem 
essentially process keeps sending messages local memory removed memory 
general process receive messages result new items stored local memory 
order empty local memories processes empty message sent process keeps sending rst messages memory repeatedly xed number course memory contains items send messages memory 
memory empty sends empty message 
goal verify eventually memory process empty 
trs describe case 
top value local memory argument goal prove eventually memory empty 
memory modelled list want prove eventually non empty list 
aim prove liveness term list constructor 
precisely prove nite reduction ground top terms eventually reach term 
exist normal forms containing depends set initial terms 
current local memory send indicates local memory contains list messages rst message sent deleted 
term sent denotes sending taken place remaining list messages local memory 
top sent top send send nil sent nil send sent sound transformation def 
results trs ls 
top sent top check send send nil sent nil send sent check sent sent check check send send check check check check check check due lemma counting occurrences drop rule 
function symbols labelled heuristic top check sent send nil 
model trs 
labelling rules results top sent top check send send nil sent nil check sent sent check check send send check check ij check check ij check check ij ij 
apply lemma count occurrences top drop rst rule 
lemma drop second rule counting occurrences send fourth rule 
similarly third rule determined lemma counting occurrences sent allows drop rst rule counting occurrences sent regarding occurrences check lemma determines fth rule sixth rule 
rule deleted counting occurrences check obtain check sent sent check check send send check check check check check termination trivial prove recursive path order choosing check maximal precedence 
communication ring processes consider protocol ring processes similar token ring protocol 
process states sent rec received 
initially processes state rec means received message token 
protocol de ned follows process state rec may send message right neighbor state rec process state sent 
clearly process state rec procedure go forever prove eventually process state 
means eventually processes received message typical liveness property proved 
requirement nf fact nf 
consisting con gurations containing rec easily seen hold protocol level 
thm 
proving desired liveness property suces show sn 
protocol encoded unary symbols sent rec right neighbor symbols corresponds root argument 
obtain ring topology add unary symbol top constant bot 
symbol argument bot right neighbor de ned symbol just top 
state ring network represented top term top bot search space nite size ring arbitrary 
order pass messages bot process top process auxiliary unary symbol introduced 
rec rec sent rec rec sent sent rec rec sent rec rec bot sent bot rec rec sent sent top rec top rec top sent top rec top top rec prove nite top reduction reaches term proving desired liveness property 
applying thm 
done proving termination ls consists rules top rec top check rec top sent top check rec top top check rec check check check sent sent check check rec rec check check check check termination easily proved completely automatically heuristics 
respectively choosing lemma rules removed 
heuristics apply semantic labelling model top check bot rec sent 
easily checked rules left hand side right hand side yield value model 
labelled system reads rec sent sent rec rec bot sent bot rec rec sent sent top sent top check rec check check check sent sent check check rec rec check check check check 
labelled trs apply lemma consecutively choosing ffg top rec sent sent check rules removed 
remaining system rules get termination recursive path order precedence check rec sent check shared resource waiting lines order handle general protocols approach easily extended top symbols arbitrary arity 
signature non top symbols signature top top symbols top 
top terms terms root top root variables symbols 
top denote set ground top terms 
trs top rewrite system rule top rule sides top terms non top rule sides terms 
sound complete transformation def 
adapted top rewrite systems follows add new symbol top original signature top addition symbol check checks argument contains instance symbol check top checks argument top contains instance top rules top mark top check top top top active 
contains active mark rules including top rules 
rule check top similar check requires argument starts symbol top top rules check top proper check proper rules check match proper start rules ok ok ok remain unchanged rules 
contrast rules ok ok active active mark mark required top modi ed transformation theorem corresponding thm 
terminating terminating top prove claim needs lemmata corresponding lemma lemma 
lemma remain unchanged 
lemma extended observation check top top contains subterm 
lemma need additional observation check top 
mark 
lemma remains unchanged proof precedence updated active check top check sound transformation def 
modi ed slightly 
order handle top rewrite systems top symbols arbitrary arity top rule ls contain rules check remaining rules ls constructed def 

soundness transformation easily shown thm 

case study example top rewrite system non unary top symbols 
modify example sect 
considering waiting lines processes want gain access shared resource 
want prove liveness property eventually old processes lines served 
problem considerably dicult sect 
liveness holds lines synchronized suitable way 
instance communication lines new processes may freely choose lines case line serving processes goes forever line processes served 
non serving line contains old process desired liveness property hold 
hand new process free choose lines 
subtle way achieve impose extra requirement lines er free positions alternating way 
represent waiting lines term top 
order keep track information lines allowed generate free position new process symbol top symbols top top top means waiting line allowed er free position new process 
behavior inside waiting line exactly rules sect 

obtain top rewrite system binary symbols top top act top symbols top ftop top 
top free top new top free top new top free top new top free top new new free free new old free free old new serve free serve old serve free serve want prove nite reduction ground top terms nite number steps term symbol old achieved 
corresponds liveness property eventually old processes served 
nf top ftop serve free serve ing ftop free serve serve ing suces prove termination top applying sound transformation def 
old done proving termination trs 
extended sound transformation handle top symbols arbitrary arity described 
top free top check new top free top new check top free top check new top free top check new top free top check new top free top new check top free top check new top free top check new new free free new old free free old new serve free serve old serve free serve check free free check check new new check check old old check check old old due lemma rule removed counting number old symbols 
apply semantic labelling model heuristics top top check old newm free serve 
checks model trs 
remains prove termination labelled system consisting rules top ij free top check new ij top ij free top new check ij top ij free top check new ij top ij free top check new ij top ij free top check new ij top ij free top new check ij top ij free top check new ij top ij free top check new ij new free free new old free free old new serve free serve check free free check check new new check check old old check check old old 
rst step apply lemma symbol old rule removed 
apply lemma symbol top rules removed 
lemma symbol top rules removed 
remaining trs symbols top top occur 
count occurrences symbols top top rules number top top strictly decreases rules number remains 
remove rules 
similar way remove rules counting symbols top top apply lemma counting symbols free free new number occurrences symbols decreases rules remains rules 
dropping rules obtain system just rules 
top free top new check top free top check new top free top new check top free top check new new free free new old free free old new serve free serve check free free check check new new check check old old check check old old 
lemma longer applicable 
termination system proved automatically dependency pairs 
resulting dependency pairs cycles estimated dependency graph top free top new check top free top check new top free top new check top free top check new new free new old free old check free check check new check check old check 
argument ltering eliminates rst arguments top top top top eliminates second argument top top top top term top replaced top argument ltering maps check argument term check replaced resulting constraints satis ed recursive path order precedence top symbols equal top symbols equal new free old check considered equal 
precisely dependency pairs rules weakly decreasing remaining dependency pairs strictly decreasing 
sucient dependency pair cycle strictly decreasing form cycles 
dependency pair cycle cycle 
concludes termination proof trs ls liveness property system waiting lines proved 
similar example waiting lines corresponding liveness property proved system waiting lines 
top rules trs top free top new top free top new top free top new top free top new top free top new top free top new order prove trs satis es liveness property term old proceed exactly case 
rst uses transformation def 

example top rules ls top free top check new top free top new check top free top check new top free top check new step remove rule old serve free serve rule counting occurrences old 
apply semantic labelling model top labelled system rules top changed top free top check new top free top new check top free top check new top free top check new obtain similar rules symbols 
labelled system contains top rules 
lemma applied repeatedly case 
check old old check rule removed counting old lemma delete top rules label left hand side di ers label righthand side 
counting free free new remaining top rules eliminated right hand side contains new check remaining labelled top rules top free top new check top free top new check top free top check new top free top check new termination trs proved dependency pairs 
top top symbols argument ltering removes argument positions labelled 
argument ltering maps check argument 
resulting constraints satis ed recursive path order top symbols equal top symbols equal new free old check considered equal precedence 
precisely dependency pairs free left hand sides strictly decreasing dependency pairs weakly decreasing 
sucient cycle dependency pairs contains pair free left hand side 
cycle containing dependency pairs form top free cycle 
labels tuple symbols cycle change imply 
symbols label longer current trs 
proved liveness property network waiting lines arbitrary 
showed relate liveness termination term rewriting 
sound complete transformation liveness holds transformed trs terminating 
simpler sound transformation re ning techniques proving termination trss developed approach verify liveness properties mechanically 
discussed extensions approach demonstrated applicability case studies liveness networks processes 

alpern schneider 
de ning liveness 
information processing letters 

arts giesl 
termination term rewriting dependency pairs 
theoretical computer science 

baader nipkow 
term rewriting 

univ pr 

dershowitz 
termination rewriting 
journal symbolic computation 

giesl arts 
veri cation erlang processes dependency pairs 
applicable algebra engineering communication comp 

giesl middeldorp 
transforming context sensitive rewrite systems 
proc 
th rta volume lecture notes comp 
sc pages 

giesl middeldorp 
transformation techniques context sensitive rewrite systems 
technical report aib rwth aachen germany 
extended version 
available aib informatik rwth aachen de 

lamport 
new solution dijkstra concurrent programming problem 
communications acm 

middeldorp 
type equational rewriting 
acta informatica 

zantema 
termination term rewriting interpretation type elimination 
journal symbolic computation 

zantema 
termination term rewriting semantic labelling 
fundamenta informaticae 
informatik berichte list technical reports 
obtain copies technical reports please consult aib informatik rwth aachen de send request informatik rwth aachen 
aachen email biblio informatik rwth aachen de staudt von subsumption checking knowledge bases nissen hubert jarke requirements analysis multiple perspectives experiences conceptual modeling technology staudt jarke incremental maintenance externally materialized views peters jeusfeld business process oriented information management conceptual models rams jarke proceedings fifth annual workshop information technologies systems hans st winkler distributed execution functional logic programming hanus chr 
prehofer higher order narrowing de nitional trees moerkotte optimal ordering selections joins acyclic queries expensive predicates pohl pro art enabling requirements pre traceability pohl requirements engineering overview jarke marquardt design evaluation computer aided process modelling tools semantics comprehensive semantics functional programs sripada entropy limitations second law thermodynamics hanus ed proceedings poster session alp fifth international conference algebraic logic programming conradi westfechtel version models software con guration management weise fast decision algorithm timed re nement pohl jarke marquardt ce environment managing evolution chemical process simulation models pohl jarke framework process integrated tools major india intelligent networks data intensive application final project report june staudt environment validating re ning rule bases jarke jacobs nissen con ict analysis heterogeneous viewpoints formalization visualization jeusfeld bui decision support components internet jeusfeld papazoglou information brokering design search transformation peters jarke simulating impact information ows networked organizations jarke peters jeusfeld model driven planning design cooperative information systems de michelis dubois jarke matthes mylopoulos pohl schmidt woo yu cooperative information systems manifesto jacobs filling html forms simultaneously architecture functionality jacobs con ict management design full parallel boltzmann machines optimization winter sch modules updatable graph views programmed graph rewriting systems tobies implementing context patterns glasgow haskell compiler unterst die nicola jarke design evaluation wireless health care information systems developing countries ur ar probleme sprachen blostein sch computing graphs graph rewriting 
westfechtel feedback handling dynamic task nets nicola jarke integrating replication communication performance models distributed databases optimising memory management higher order functional programs baumann client server distribution structure oriented database management system high level parallel programming ecient implementation numerical algorithms nagel sch fine grained structure oriented integration tools needed product development processes einige zur von nach westfechtel und sch mobile robots dynamic environments st tobies truth veri cation platform distributed systems arnold erdmann pohl studer survey scenario twelve selected industrial projects aust und nat th 
lehmann am beispiel nicola jarke performance modeling distributed replicated databases westfechtel ager modeling dynamic software processes uml appelt jarke interoperable tools cooperation support world wide web semantik mit huch erlang programs interpretation model checking extended version jarke nicola adr replication manager hanus lucas vidal specialization functional logic programs needed narrowing th 
wilke ctl exponentially succinct ctl dot depth monadic quanti er alternation pictures jens marcin discrete strategy improvement algorithm solving parity games andreas stefan matthias jarke exploring semantic structure technical document collections cooperative systems approach cooperative document management christoph eds proceedings fifth international workshop language action perspective communication modelling markus pieter koopman eds proceedings th international workshop functional languages thomas arts thomas noll verifying generic erlang client server implementations benedikt martin deciding ltl mazurkiewicz traces thierry power letter rational languages benedikt martin michael weber local parallel model checking alternation free mu calculus benedikt martin thomas noll regular msc languages achim pre recognisable graphs monadic secondorder logic martin stefan existential locality theorem james taylor eds proceedings sixth international workshop language action perspective communication modelling thomas arts urgen giesl collection examples termination term rewriting dependency pairs achim tree interpretable structures klaus thomas noll eds programmiersprachen und grundlagen der programmierung urgen giesl middeldorp transformation techniques context sensitive rewrite systems benedikt martin thomas noll generalised regular msc languages urgen giesl middeldorp innermost termination contextsensitive rewriting horst thomas von der ma en thomas weiler modelling requirements architectures software product lines henry party message complexity better party ones proving lower bounds size minimal nondeterministic finite automata markus open framework data flow analysis java markus interfaces default implementations java martin logics mazurkiewicz traces reports available printed version 
please contact biblio informatik rwth aachen de obtain copies 

