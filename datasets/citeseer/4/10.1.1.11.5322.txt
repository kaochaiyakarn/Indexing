preprint appear proceedings seventeenth annual ieee symposium logic computer science held july copenhagen denmark 
copyright ieee 
separation logic logic shared mutable data structures john reynolds computer science department carnegie mellon university john reynolds cs cmu edu joint peter hearn early ideas burstall developed extension hoare logic permits reasoning low level imperative programs shared mutable data structure 
simple imperative programming language extended commands expressions accessing modifying shared structures explicit allocation deallocation storage 
assertions extended introducing separating conjunction asserts subformulas hold disjoint parts heap closely related separating implication 
coupled inductive definition predicates data structures extension permits concise flexible description structures controlled sharing 
survey current development program logic including extensions permit unrestricted address arithmetic dynamically allocated arrays recursive procedures 
discuss promising directions 

shared mutable data structures structures updatable field referenced point widespread areas diverse systems programming artificial intelligence 
approaches reasoning technique studied decades result methods suffer limited applicability extreme complexity scale poorly programs moderate size 
partial bibliography 
problem faced approaches correctness program mutates data structures usually portions author research described survey supported national science foundation ccr basic research computer science www brics dk centre danish national research foundation 
depends complex restrictions sharing structures 
illustrate problem approach solution consider simple example 
program performs place reversal list nil nil notation denotes contents storage address 
invariant program state lists representing sequences reflection initial value obtained concatenating reflection list list predicate list defined induction length list def nil list 
def 
list 
read points 
unfortunately program malfunction sharing lists prohibit extend invariant assert nil reachable list list reach reach nil reach def reach def def 
worse suppose list representing sequence supposed affected execution program 
share invariant list list 
list reach reach nil reach reach reach nil trivial situation sharing prohibited evident form reasoning scales poorly 
key avoiding difficulty introduce novel logical operation called separating conjunction independent spatial conjunction asserts hold disjoint portions addressable storage 
effect prohibition sharing built operation invariant written list list 
invariant list list list 
fact go inference rule called frame rule infer directly program affect list fact assertions refer list 
central concept separating conjunction implicit burstall early idea distinct tree system 
lectures fall described concept explicitly embedded flawed extension hoare logic 
soon intuitionistic logic idea discovered independently hearn 
realizing logic instance logic bunched implications hearn introduced separating implication intuitionistic character logic implied monotonicity property assertion true portion addressable storage remain true extension portion created storage allocation 
hearn classical version logic impose monotonicity property reason explicit storage deallocation showed version expressive intuitionistic logic translated classical logic 
intuitionistic classical version logic addresses assumed disjoint integers refer entire records particular fields address arithmetic precluded 
generalized logic permit reasoning unrestricted address arithmetic regarding addresses integers refer individual fields 
form logic described 
describe hearn frame rule permits local reasoning components programs 
logics idea structure assertion describe separation storage disjoint components come term separation logics extension predicate calculus separation operators resulting extension hoare logic 
precise name storage separation logics apparent underlying idea generalized describe separation kinds resources 

programming language programming language simple imperative language originally axiomatized hoare extended new commands manipulation mutable shared data structures 
cons hexpi hexpi allocation hexpi lookup hexpi hexpi mutation dispose hexpi deallocation semantically extend computational states contain components store stack mapping variables values semantics simple imperative language heap mapping addresses values representing mutable structures 
early versions separation logic integers atoms addresses regarded distinct kinds value heaps mappings finite sets addresses nonempty tuples values values integers atoms addresses integers atoms addresses disjoint heaps fin addresses values permit unrestricted address arithmetic version logic assume values integers infinite number addresses assume atoms integers addresses heaps map addresses single values values integers atoms addresses integers atoms addresses disjoint heaps fin addresses values permit unlimited allocation records arbitrary size require set addresses contain infinitely consecutive sequences length instance occur finite number positive integers addresses 
versions logic assume nil atoms stores values states stores heaps finite set variables 
intent capture low level character machine language 
think store describing contents registers heap describing contents addressable memory 
view enhanced assuming address equipped activity bit domain heap finite set active addresses 
semantics ordinary boolean expressions simple imperative language hexpi exp fin fv stores values bexp fin fv stores ftrue falseg fv set variables occurring free phrase 
particular expressions depend heap defined cause side effects 
expressions contain notations cons refer heap 
follows new heap manipulating commands instances simple assignment command hexpi write familiar operator 
fact obey hoare inference rule assignment 
alter store variable say commands cons 
dispose modify simple way define meaning new commands small step operational semantics defining transition relation configurations nonterminal command state pair hc fv dom terminal state abort 
write indicate finite sequence transitions indicate infinite sequence transitions semantics heap manipulating commands specified inference rules allocation hv cons exp exp addresses 
lookup exp hv exp exp hv abort mutation exp exp exp exp abort deallocation exp dom exp sg exp abort denotes function maps arguments domain notation fes denotes restriction function domain 
allocation operation activates initializes cells heap 
notice aside requirement addresses cells consecutive previously inactive choice addresses indeterminate 
remaining operations cause memory faults denoted terminal configuration abort inactive address dereferenced deallocated 
important property language effect restricting heap execution command 
essentially restriction removes address dereferenced deallocated command restricted execution aborts executions similar presence unchanging extra heap cells unrestricted execution 
state property precisely write indicate heaps disjoint domains 
indicate union heaps 
hc abort hc abort 
hc hc abort hc 
hc hc abort hc 

assertions inference rules addition usual formulae predicate calculus including boolean expressions quantifiers introduce new forms assertion describe heap 
emp empty heap hexpi 
hexpi singleton heap separating conjunction separating implication new forms meaning assertion boolean expression depends store heap asrt fin fv stores heaps ftrue falseg specifically emp asserts heap empty emp asrt iff fg 
asserts heap contains cell address contents 
asrt iff exp sg exp exp asserts heap split disjoint parts hold respectively asrt iff 
asrt asrt asserts current heap extended disjoint part holds hold extended heap asrt iff asrt implies asrt 
semantics coupled usual interpretation classical connectives result instance resource semantics bunched implications advanced david pym 
useful introduce complex forms abbreviations 
def 
free 
def 
true 
def 



def 


iff 
true forms conjunction easy describe simple sharing patterns concisely 

asserts points adjacent pair cells containing store maps values address heap maps 

asserts points adjacent pair cells containing 


asserts situations hold separate parts heap 


asserts situations hold heap happen values hj 


asserts may hold heap may contain additional cells 
simple examples reveal occasionally surprising behavior separating conjunction 
suppose distinct addresses fhs ig fhs ig heaps disjoint singleton domains 
asrt 






false 














false 
true 

illustrate separating implication suppose assertion holds store maps variable address heap maps 

holds store heap dom obtained removing domain 

holds store heap differs mapping 
anticipating concept partial correctness specification introduced section fx 

fpg 
inference rules predicate calculus remain sound enriched setting 
presenting sound rules new forms assertions note rules fail 


see contraction weakening sound 
separation logic substructural logic 
species linear logic linear logic written rule dereliction gives validity 
state 
true 
false true 
false false 
sound axiom schemata separating conjunction include commutative associative laws fact emp neutral element various distributive laws emp free free inference rule showing separating conjunction monotone respect implication rules capturing relationship separating conjunction separating implication semantically defined classes assertions useful special properties contain easily defined syntactic subclass 
assertion said pure store independent heap 
syntactically assertion pure contain emp 
axiom schemata show assertions pure distinction kinds conjunctions implications collapses pure pure pure pure pure say assertion intuitionistic iff stores heaps asrt implies asrt show true strongest intuitionistic assertion weaker true weakest intuitionistic assertion stronger syntactically intuitionistic assertions assertion expressions intuitionistic assertions pure assertion 
true true intuitionistic assertions true intuitionistic true intuitionistic noted define operations def true def true def true assertions built pure assertions 
operations form image hearn modal translation intuitionistic separation logic classical version 
yang singled class strictly exact assertions assertion strictly exact iff asrt sh asrt sh implies syntactically assertions built expressions 
strictly exact 
utility concept true strictly exact 
strictly exact assertions belong broader class domain exact assertions assertion domain exact iff asrt sh asrt sh implies syntactically assertions built expressions quantifiers domain exact 
assertion laws earlier full distributive laws domain exact free domain exact give axiom schemata predicate 
regrettably far complete 





emp 
assertion language developed section programming language developed previous section limited fact variables range integers 
go limitation ways sufficiently obvious formalize semantics variables denoting data types predicates assertions assertion language variables denoting procedures programming language 
consider assignment variables 

specifications inference rules notion program specification similar hoare logic variants partial total correctness partial total fv fv fv 
fpg fqg holds iff states asrt implies abort states implies asrt holds iff states asrt implies abort states implies asrt notice specifications implicitly quantified stores heaps allocation indeterminate possible executions 
execution giving memory fault falsifies partial total specifications 
hearn paraphrased milner specified programs don go wrong 
consequence execution programs proved meet specifications unnecessary check memory faults equip heap cells activity bits assuming programs executed initial states satisfying relevant precondition 
roughly speaking fact specifications preclude memory faults acts concert indeterminacy allocation prohibit violations record boundaries 
notion record boundaries dissolves valid specification program tries form field record gluing field records fx 

skip dispose dispose cons fx 
new setting command specific inference rules hoare logic remain sound structural rules consequence fpg fqg fp fq auxiliary variable elimination fpg fqg pg qg free substitution fpg fqg fpg fqg variables occurring free modified variable occur free 
inference rules section partial total correctness 
exception called rule constancy section section fpg fqg fp rg fq rg variable occurring free modified long understood rule vital scalability permits extend local specification involving variables command adding arbitrary predicates variables modified preserved execution 
unfortunately rule constancy sound separation logic 
example instance fx 
fx 
fx 

fx 

valid precondition preclude aliasing occur hearn realized ability extend local specifications regained deeper level separating conjunction 
place rule constancy proposed frame rule frame rule fpg fqg fp rg fq rg variable occurring free modified frame rule extend local specification involving variables parts heap hearn calls footprint adding arbitrary predicates variables parts heap modified mutated frame rule key local reasoning heap understand program works possible reasoning specification confined cells program accesses 
value cell automatically remain unchanged 
valid specification fpg fqg tight sense cell footprint allocated asserted active locality opposite property asserted active belongs footprint 
role frame rule infer local specification command global specification appropriate larger footprint enclosing command 
see soundness frame rule assume fpg fqg asrt 
suppose hc abort 
property described section hc abort contradicts fpg fqg suppose hc 
previous case hc abort contradict fpg fqg property section hc 
fpg fqg implies hc stores give value variables modified include free variables implies yang shown frame rule complete sense suppose know command partial correctness specification fpg fqg valid 
validity fp fq semantic consequence knowledge fp fq derived fpg fqg frame rule rules consequence auxiliary variable elimination substitution 
frame rule move local versions inference rules primitive heap manipulating commands equivalent global versions 
mutation example obvious local rule mutation local fe 
fe 
leads directly mutation global 
rg 
rg rederive local rule global emp 
global rule 
valid implication derive third rule mutation suitable backward reasoning substitute assertion postcondition mutation backwards reasoning 

fpg rederive global rule backward 
valid implication 
similar development works deallocation global form suitable backward reasoning deallocation local fe 
dispose deallocation global backwards reasoning 
rg dispose frg way give equivalent local global rules noninterfering allocation commands modify fresh variables 
abbreviate allocation noninterfering local cons fv 
free allocation noninterfering global frg cons 
rg free avoid restrictions occurrences assigned variable give backward reasoning rule rules lookup introduce quantify additional variables 
allocation lookup give equivalent rules kinds relevant derivations complicated auxiliary variable elimination properties quantifiers laws 
rules indicate substitution priming metavariables denoting expressions assertions write abbreviate allocation local fv cons fv 
distinct allocation global frg cons 
distinct free allocation backwards reasoning 
cons fpg distinct free lookup local fv 
fv 
distinct 
lookup global 

distinct occur free free lookup backwards reasoning 

fpg free free 
strictly exact easy obtain equivalent succinct rule backward reasoning lookup lookup alternative backward reasoning 
fpg free free new commands backward reasoning forms give complete weakest preconditions 
simple illustration detailed proof outline local specification command uses allocation mutation construct element cyclic structure containing relative addresses cons fx 
ag cons 










lists specify program adequately usually necessary describe form structures sharing patterns relate states program values denote 
necessary define set values algebraically recursively define predicates values structural induction 
standard methods definition treat formally novel aspects logic 
lists relevant values sequences notation sequences write empty sequence 
single element sequence containing 
omit brackets sequence 
composition followed reflection length ith component simplest list structure representing sequences singly linked list 
describe representation write list list segment representing sequence straightforward define predicate induction structure list def emp list 
def 
list prove basic properties list 
list 
list list list 
list 
second property composition law proved structural induction comparison definition list generalized lists list segments separating conjunction prohibit cycles list segment 
precisely list 





distinct constrained list 
may hold 
obvious properties list nil nil list say empty nil 
common situations insure empty nil example refers heap cell separate list segment separate list list 
list list nil hand simply determine emptiness 
example cyclic buffer containing active segment inactive segment described list list 
buffer may empty full list illustrated proof outline command deletes element list flist 

list fi 

list fi 

list dispose fi 
list dispose flist flist complex example body command list reversing program final assertion invariant command list nil list nil 
list 
nil list nil 


list nil list nil 


list nil list nil 


list nil list nil 

list nil list 
nil 

list nil list nil 
list nil list nil 
elaborate representation sequences provided doubly linked lists 
write dlist represented doubly linked list segment forward linkage second fields backward linkage third fields inductive definition dlist def emp dlist 
def 
dlist prove basic properties dlist 
dlist 
dlist dlist dlist 
dlist 
utility unrestricted address arithmetic illustrated variation doubly linked list second third fields record replaced single field giving exclusive contents 
write xlist represented list define predicate xlist def emp xlist 
def 
xlist basic properties analogous dlist 
mention idea richard denoting sequence data items list structure denote sequence collection addresses data items stored 
case simply linked lists write listn list segment containing sequence addresses view leads definition listn def emp listn 
def 
listn notice listn extremely local holds heap containing second cell record list structure 
reader may verify body list reversing program preserves invariant listn nil listn nil original sequence addresses data fields list fact shows addresses change invariant embodies stronger notion place algorithm 

trees dags move list tree structures possible patterns sharing structures richer 
section focus particular kind value called expression lisp community 
set exps values set exps iff atoms 
exps course just particular simple initial algebra 
take carriers sorted initial algebra data complicate exposition adding little interest 
clarity vital maintain distinction values representations 
call values expressions calling representations sharing trees representations sharing loops dags directed acyclic graphs 
write tree dag indicate root tree dag representing expression predicates defined induction structure tree iff emp tree 
iff 
tree tree dag iff dag 
iff 
dag dag emp omitted definition dag pure intuitionistic 
induction easily seen dag intuitionistic fact vital want dag dag hold heap contains possibly overlapping sub dags assert sub dags identical 
express simple algorithms manipulating trees introduce recursive procedures 
avoid problems aliased variables interfering procedures limit order procedures global variables case recursion name procedure defined explicitly indicate formal parameters modified procedure body 
procedure definition form 
xm 
yn 
yn free variables modified 
xm free variables declare procedures blocks simply assume program reasoned presence procedure definitions 
setting appropriate inference rule partial correctness procedures 
xm 
yn fpg 
xm 
yn fqg 
fpg fqg fpg 
xm 
yn fqg essence prove specification call procedure actual parameters formal parameters procedure definition proves similar specification body definition recursion hypothesis recursive calls satisfy specification proved 
course able deduce specifications calls actual parameters differ formals 
purpose structural inference rule substitution suffices takes variables modified 
xm 
yn 
yn note restrictions rule prevent creation aliased variables expressions 
example expect tree copying procedure copytree newvar copytree copytree cons satisfy ftree copytree ftree tree proof outline similar specification procedure body ftree emp emp emp emp emp 
tree 
newvar 

tree tree copytree 

tree tree tree copytree 

tree tree tree tree cons 

tree tree 
tree tree 
tree 
tree 
ftree tree obtain specifications recursive calls proof outline recursion hypothesis frame rule move footprint recursive call larger footprint procedure body 
detail specification recursive call outline obtained inferences ftree copytree ftree tree ftree copytree ftree tree 

tree tree copytree 

tree tree tree 

tree tree copytree 

tree tree tree 

tree tree copytree 

tree tree tree substitution rule frame rule rule consequence axiom pure auxiliary variable elimination 
proved copytree general possible 
fact procedure insensitive sharing input satisfies copytree tree try prove specification mimicking previous proof encounter problem say recursive call point frame rule infer 
dag dag copytree 
dag dag tree presence prevents frame rule reason recursion hypothesis strong imply specification recursive call imply copytree leaves unchanged portion heap shared dags representing example suppose 



permit copytree change state dag false 
way problem extend assertions contain assertion variables extend substitution rule include assertion variables ordinary variables assertions substituted assertion variables 
assertion variable specify property heap active executing copytree remains true execution fp dag copytree fp tree leave proof outline reader show inference specification recursive call recursion hypothesis substitution rule auxiliary variable elimination fp dag copytree fp tree 
dag dag copytree 
dag tree 
dag dag copytree 
dag tree 
arrays iterated separating conjunction straightforward extend programming language include heap allocated dimensional arrays introducing allocation command number consecutive heap cells allocated specified operand 
simplest leave initial values cells indeterminate 
syntax 
allocate hexpi operational semantics hv allocate 
exp describe arrays helpful extend concept separating conjunction construct iterates finite consecutive set integers 
syntax 
hexpi hexpi meaning asrt exp exp heaps implies hi hj hi asrt hi axiom schemata useful emp pure true simple example array cyclic buffer 
assume element array allocated address allocate variables number active elements address active element address inactive element buffer contains sequence satisfy assertion 

modulo somewhat surprisingly iterated separating conjunction useful making assertions structures involve arrays 
example connection list listn list listn 
elaborate example provided program accepts list representing sequence integers produces list lists representing necessarily contiguous subsequences program variant lisp example illustrate storage economy obtained lisp straightforward sharing 
interest iterated separating conjunction specify sharing pattern sufficient detail show amount storage 
sequence sequences define ext sequence sequences obtained prefixing integer sequence ext def ext def 
define ss assert sequence subsequences particular order produced iterative program ss def ss 
def ss ext obtain different order produced simple recursive program remove reflection operator 
define assert sequence lists components represent components def list nil true stage specify behavior subsequence program subseq flist nil subseq ss list nil capture sharing structure iterated separating conjunction define assert element empty list previous element consists single integer cons ed element def nil emp 
heap described component iteration contains single cons pair heap described contains cons pairs 
full specification flist nil subseq ss list nil heap described list nil contains entire heap described postcondition contains cons pairs 

proving waite algorithm ambitious application separation logic yang proof waite algorithm marking structures contain sharing cycles 
proof uses older form classical separation logic address arithmetic forbidden heap maps addresses records containing case address fields boolean fields 
significant features proof evident main invariant stack stack stree root allocated reach stack heap described invariant footprint entire algorithm exactly structure reachable address root 
addresses refer entire records easy assert record allocated allocated def 
active records marked def allocated 
true dangling address def nil allocated active record contains dangling address def 
yang uses helpful convention predicates names intuitionistic 
second line invariant stack holds part heap called spine linked list records root current address links reversed variable stack sequence determining contents spine 
line stack describes contents spine links restored stree root asserts structure stree spanning tree heap 
assertion stree root appears precondition algorithm 
second third lines invariant separating implication elegantly assert spine correctly restored heap spanning tree initially 
fact proof goes stree root predicate independent boolean fields records spanning trees determined heap boolean fields 
author knowledge part invariant conceptual separating implication real proof opposed formal expressing weakest preconditions rest invariant heap partitioned marked unmarked records asserted active unmarked record reached variable certain fields spine 
assertion lies right operand separating conjunction separates marked unmarked notes paths unmarked records reached consist unmarked records 
author section tried verify kind graph traversal informally appreciate extraordinary succinctness lines yang invariant 

computability complexity results existence weakest preconditions new commands assures central property hoare logic preserved extension program specification annotated loop invariants recursion hypotheses total correctness variants reduced collection assertions called verification conditions validity insure original specification 
central question computability complexity decide validity assertions separation logic 
yang examined decidability classical separation logic arithmetic expressions variables values addresses nil heap maps addresses field records 
showed characteristic operations separation logic emp 
prohibited deciding validity assertion recursively enumerable 
consequence hope find axiomatic description 
hand yang showed characteristic operations permitted quantifiers prohibited validity assertions algorithmically decidable 
case yang investigated complexity 
specifically languages tabulated considered mc model checking problem asrt sh hold specified state 
val validity problem asrt sh hold states 
case determined problem complete indicated complexity class language mc val 

conp false emp np pspace pspace pspace 
garbage collection logic permits programs unrestricted address arithmetic little hope constructing general purpose garbage collector 
hand situation older logic addresses disjoint integers hopeful 
clear logic permits assertions heap contains elements falsified execution garbage collector realistic sense execution unobservable 
author example shown proof outline ftrueg cons fx 

nil 
final assertion describes disconnected piece structure falsified disconnected piece reclaimed garbage collector 
case assertions intuitionistic hard reasonable program logic prohibit derivation 
hearn explored ways avoiding problem defining existential quantifier nonstandard way defined rich variety logics insensitive garbage collection 
unfortunately brief way relating logics discussed 

directions 
new forms inference yang proof waite algorithm thirteen assertions semantically validated consequences known inference rules far specific considered axioms 
surprising state affairs consequence novel character proof especially quantification allocated addresses crucial separating implication fact algorithm deals sharing fundamental way studied separation logic 
generalization assertions may fertile source new inference rules 
example suppose intuitionistic allocated emp 
elaborate example suppose say assertions hold overlapping heaps 
precisely iff stores heaps function asrt sh asrt sh hand easy find assertions intuitionistic false valid allocated allocated 
valid 
hand true true valid 
examples sound useful proof specification real program 
may special cases generally useful rules inference mechanisms 
hearn suspects prospects find useful proof theory separation logic labeled deduction 
noted yang proof depends critically fact waite algorithm performs place computation 
new problems may arise trying prove say program copies reachable structure preserving sharing patterns express isomorphism structure copy 
particulars state separation logic theoretically incomplete pragmatically incomplete applied new ways need new kinds inference 

taming address arithmetic realized separation logic generalized simplified permitting address arithmetic benefit 
problems 
example consider definition dag section assertion dag 


holds states distinct records overlap similarly iff try recast waite proof logic address arithmetic difficult necessary assert distinct records overlap address values program denote fields records 
problems called skewed sharing difficult types records differing lengths field types 
possible solution may augment states mapping domain heap attributes set program described assertions tested determine abort 
attributes similar auxiliary variables sense owicki gries values influence values variables heap cells flow control 
redefine dag avoid skewed sharing allocation cons creates record dag give attribute dag record 
definition non atomic dag changed dag 
iff dag record 
dag dag version waite proof address arithmetic give attribute record address record 
add record 
record nil record nil boolean boolean invariant assertion record place allocated 
distinct flavor types attributes attributes record information purposes proof typed programming language checked compiler discarded runtime 
alternative course move typed programming language goal keep programming language low level simplicity flexibility proof system replace types supplement 

concurrency hoare brinch hansen argued prevent data races processes attempt access storage synchronization concurrent programs syntactically restricted limit process interference explicitly indicated critical regions 
presence shared mutable structures processes interfere ways subtle detected syntactically 
hand turns program verification clear separation logic specify absence interference 
simplest situation concurrent execution processes interfere described inference rule fp fq fp fq fp fq variable free modified viceversa 
going trivial case hearn extended hoare logic concurrency devised owicki gries turn extension hoare treat critical regions framework separation logic 
basic idea just program variables syntactically partitioned groups owned different processes resources heap similarly partitioned separating conjunctions proof program 
interesting aspect partition heap changed executing critical regions associated resources ownership particular address move process resource process 
example process may allocate addresses place buffer process removes addresses buffer deallocates 
similarly concurrent version quicksort array segment divided concurrent recursive calls 
unfortunately writing proof hearn inference rules sound 
difficulty hearn words ownership eye changing partitions heap determined program assertions proof 
concurrent programming common permit processes read variable long process modify value simultaneously 
natural useful extend notion passivity heap cells specification process indicate portion heap evaluated mutated allocated deallocated process 
capability provide alternative way specify action copytree dags discussed section 
semantically require activity bits take third intermediate value read 
concurrency changes focus terminating programs programs usefully run forever hoare logic limited usefulness 
programs helpful extend temporal logic separating operators 

storage allocation separation logic describes programming language explicit allocation deallocation storage scenes garbage collector suitable reasoning allocation methods 
challenging example regions sense tofte 
provided explicitly programmable region facility program allocator regions storage equipped allocator 
prove program routines deallocates region safe deallocate storage allocated region 
separation logic incompatible generalpurpose garbage collection unrestricted address arithmetic permitted possible construct verify garbage collector specific program 
situation able far aggressive possible general purpose garbage collector recovering storage minimizing extra data needed guide traversal active structure 
example representation described dag section permissible collector increase amount sharing 
key correct garbage collector need maintain assertion hold point collector called preserving value certain input variables determine values computed 
addition total correctness collector increase value loop variants insure termination 
instance list reversal example section collector called body required maintain invariant list nil list nil preserving input increasing variant length interesting note garbage collector required respect partial equivalence relation determined invariant states equivalent satisfy invariant specify values input variables 
considering partial equivalence relations give semantics types reinforces view types assertions semantically similar 

relationship type systems types assertions may semantically similar actual development type systems programming languages quite separate development approaches specification hoare logic refinement calculi model checking 
particular idea states types executing command may change type state taken hold study type systems low level languages alias types devised walker morrisett 
separation logic closely related type systems 
commonality captured roughly simple type system integer emp straightforward translate state types system assertions classical separation logic formulation address arithmetic alias types 
may possible devise richer type system accommodates limited degree address arithmetic permitting example addresses point interior records relative addresses 
basically real question dividing line types assertions erased 

embedded code pointers low level language simple imperative language axiomatized hoare deficient making provision occurrence data structures addresses refer machine code 
code pointers appear compiled translation programs higher order languages scheme sml object oriented languages java 
appear low level programs techniques higher order objectoriented programming 
difficult describe order world hoare logic deal embedded code pointers free separation logic hoare logic simple imperative language 
evidence go comes success type theorists extending types machine language particular output compilers 
higher order functional language side effects comes resemble low order machine language restrictions imposed continuation passing style cps functions receive return addresses way receive parameters 
free variables prohibited expressions denote functions functions represented code pointers closures pair code pointers data 
fact restricted language formally similar imperative language programs flat control paths come jumping common label 
raises question marry separation logic cps prohibition free variables function expressions appears irrelevant logical point view 
simple example cps provided function append appends list list mutation input lists unchanged passes resulting list continuation letrec append nil cons append believe key specifying cps program introduce reflection operator allows cps terms occur assertions manner reminiscent dynamic logic 
specifically cps term assertion holds state aborts executed state situation say safe execute state 
suppose command satisfying hoare specification fpg fqg cps term executing effect executing calling continuation 
specify assertion xm xn xm subset variables xn 
ignore difference separating operators ordinary conjunction implication asserts safe execute state satisfying mapping procedure safe execute xn state satisfying account nature asserts safe execute state part heap satisfies mapped procedure safe execute xn part heap satisfied replaced part satisfies universal quantifier indicates variables value may changed executes xn 
example cps form append specified list nil list nil list nil list list nil append discouraging go back read directions sections old papers realize directions successfully pursued 
fortunate half ideas suggestions section bear fruit 
field young game possibilities tantalizing 
encouragement numerous suggestions am indebted researchers separation logic students courses taught subject 
particularly grateful peter hearn helpful comments reading preliminary draft 
opinions errors 

explicit description bi pointer logic 
unpublished june 
burstall 
techniques proving correctness programs alter data structures 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh scotland 
monteiro 
verifiable executable specifications concurrent objects hankin editor programming languages systems esop volume lecture notes computer science pages berlin 
springer verlag 

program logics presence garbage collection 
henglein hughes niss editors space informal proceedings workshop semantics program analysis computing environments memory management page 
university copenhagen 

semantic logical properties stateful 
ph 
dissertation universita di genova genova italy 
hearn 
garbage program logic 
foundations software science computation structures volume lecture notes computer science pages berlin 
springer verlag 
hearn 
program logic equivalence presence garbage collection 
submitted july 
yang hearn 
computability complexity results spatial assertion language data structures 
mukund vinay editors fst tcs foundations software technology theoretical computer science volume lecture notes computer science pages berlin 
springer verlag 
cardelli gardner ghelli 
spatial logic querying graphs 
hennessy widmayer editors automata languages programming lecture notes computer science berlin 
springer verlag 
cardelli ghelli 
query language ambient logic 
sands editor programming languages systems esop volume lecture notes computer science pages berlin 
springerverlag 
cardelli gordon 
anytime modal logics mobile ambients 
conference record popl th acm sigplan sigact symposium principles programming languages pages new york 
acm 
ghelli albano 
query language tql 
proceedings th international workshop web databases webdb madison wisconsin 
galmiche 
proof search generation propositional bi logic 
kobayashi pierce editors theoretical aspects computer software volume lecture notes computer science pages berlin 
springer verlag 
galmiche pym 
resource tableaux 
submitted 
harel kozen tiuryn 
dynamic logic 
mit press cambridge massachusetts 
hoare 
axiomatic basis computer programming 
communications acm october 
hoare 
proof program find 
communications acm january 
hoare 
theory parallel programming 
hoare editors operating systems techniques volume studies data processing pages london 
academic press 
hearn 
bi assertion language mutable data structures 
conference record popl th acm sigplan sigact symposium principles programming languages pages new york 
acm 
morrisett crary glew walker 
stack typed assembly language 
leroy ohori editors types compilation volume lecture notes computer science pages berlin 
springerverlag 
hearn 
notes conditional critical regions spatial pointer logic 
unpublished august 
hearn 
notes separation logic shared variable concurrency 
unpublished january 
hearn pym 
logic bunched implications 
bulletin symbolic logic june 
hearn reynolds yang 
local reasoning programs alter data structures 
fribourg editor computer science logic volume lecture notes computer science pages berlin 
springer verlag 
owicki gries 
verifying properties parallel programs axiomatic approach 
communications acm may 
pym 
semantics proof theory logic bunched implications 
applied logic series 
kluwer academic publishers boston massachusetts 
appear 
reynolds 
craft programming 
prentice hall international london 
reynolds 
intuitionistic reasoning shared mutable data structure 
davies roscoe woodcock editors perspectives computer science pages hampshire 

reynolds 
lectures reasoning shared mutable data structure 
ifip working group school seminar state art program design logic argentina september 
reynolds hearn 
reasoning shared mutable data structure invited lecture 
henglein hughes niss editors space informal proceedings workshop semantics program analysis computing environments memory management page 
university copenhagen 
slides lecture available ftp ftp cs cmu edu user ps gz 
tofte 
talpin 
implementation typed callby value calculus stack regions 
conference record popl st acm sigplan sigact symposium principles programming languages pages new york 
acm press 
walker morrisett 
alias types recursive data structures 
harper editor types compilation volume lecture notes computer science pages berlin 
springer verlag 
yang 
example local reasoning bi pointer logic waite graph marking algorithm 
henglein hughes niss editors space informal proceedings workshop semantics program analysis computing environments memory management pages 
university copenhagen 
yang 
local reasoning stateful programs 
ph 
dissertation university illinois urbana champaign illinois july 
yang hearn 
semantic basis local reasoning 
nielsen engberg editors foundations software science computation structures volume lecture notes computer science pages berlin 
springer verlag 

