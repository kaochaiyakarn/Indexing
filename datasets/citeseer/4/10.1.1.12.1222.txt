project reconciling mobile code security execution efficiency wolfram peter dalton jeffery von peter frohlich christian stork vivek michael franz department information computer science university california irvine ca technical report january comprehensive research project investigating techniques transporting programs securely potentially insecure channels 
central focus project development blueprint generation mobile code distribution format 
problem previous approaches mobile code security additional provisions security lead loss efficiency extent making security scheme unusable trivial programs 
project strives deviate common approach studying security isolation focuses simultaneously multiple aspects mobile code quality 
security aspects include encoding density speed dynamic code generation eventual execution performance 
gives high level overview project presents initial results 
project reconciling mobile code security execution efficiency wolfram wolfram ics uci edu dalton ics uci edu peter frohlich phf acm org vivek ics uci edu peter acm org jeffery von ics uci edu christian stork ics uci edu ics uci edu michael franz franz uci edu department information computer science university california irvine irvine ca usa comprehensive research project investigating techniques transporting programs securely potentially insecure channels 
central focus project development blueprint mobile code distribution format 
problem previous approaches mobile code security additional provisions security lead loss efficiency extent making security scheme unusable trivial programs 
project strives deviate common approach studying security isolation focuses simultaneously multiple aspects mobile code quality 
security aspects include encoding density speed dynamic code generation eventual execution performance 
gives high level overview project presents initial results 
effort sponsored defense advanced research projects agency darpa air force research laboratory air force materiel command usaf agreement number 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright annotation thereon 
views contained authors interpreted necessarily representing official policies endorsements expressed implied defense advanced research projects agency darpa air force research laboratory government 
ability send mobile code machine important enabling technologies internet age 
mobile code especially forms mobile code target machine independent greatly alleviate previously existing problems software distribution version control maintenance 
mobile code provides means entirely new approaches executable content documents 
unfortunately mobile code fraught risks 
adversary succeeds deceiving executing malicious program supplied may catastrophic consequences may lead loss confidentiality loss information integrity loss information combination outcomes 
costs avoid executing programs potentially cause harm 
line defense incidents shield computer systems communications information intruders physical logical access controls 
second line defense cryptographic authentication mechanisms detect mobile code hasn originated known trusted code provider tampered transit 
project concerns third line defense independent complementary mentioned assume intruder successfully managed penetrate system breaking defense able mobile program falsely authenticates uncompromised trusted party circumventing defense prevent causing damage answer question studying particular class representations target machine independent mobile programs provably encode legal programs 
way adversary substitute malicious program corrupt host computer system formed mobile program expressible encoding guaranteed map back source program deemed legal original source context mobile programs formed rejected trivially 
encoding designed guarantee referential integrity type safety single distribution module enforce properties compilation unit boundaries 
problem previous approaches mobile code security additional provisions security lead loss efficiency extent making security scheme unusable trivial programs 
conversely project outset striving deviate common approach studying security isolation focused satisfying multiple goals mobile code quality simultaneously 
additional qualities consider mobile code format encoding density important factor transfer wireless networks ease high quality native code generated just time compiler eventual target site 
remainder outlines various facets project starting definitions scope project architecture presenting preliminary results 
definitions scope understand term mobile code compiler construction perspective intermediate representation fulfills criteria ffl completeness intermediate representation executable semantics independent external information 
ffl portability intermediate representation free assumptions eventual execution platform processor family operating system 
ffl security intermediate representation shipped safely channels potential compromising execution platform 
ffl density intermediate representation encoded compact form minimize impact bandwidth limited channels 
ffl efficiency intermediate representation wellsuited generating efficient directly executable object code just time compilation techniques 
apart fundamental criteria properties desirable ffl extensibility intermediate representation general allow multiple source languages transported effectively 
ffl intermediate representation enable pipelining decoding decompression code generation 
project developing infrastructure mobile code transportation standard 
infrastructure takes form documented extensible component framework 
architecture framework similar architecture modern compiler usually deployed distributed fashion ffl code producers compilers various source languages called front ends architecture compile applications mobile code intermediate representation 
ffl code consumers compilers intermediate representation called back ends architecture generate native object code suitable execution machines 
code producers code consumers separated time space mobile code shipped producers consumers variety channels 
design space bounded requirements fundamental design decisions ffl cryptographic approaches security orthogonal project 
techniques rely trust relationships code producers code consumers 
enable producer malicious code identified protect execution platform compromised 
ffl compilation time requirements stringent code consumer site code producer site 
beneficial load timeconsuming compilation tasks code producer provided computed information shipped compactly tamper proof manner 
ffl compressing mobile code viable time transmission decompression lower transmission time uncompressed code 
transmission speed slowest link path producer consumer important emerging application areas including military ones low bandwidth wireless 
definitions scope immediately wonders compares currently dominant industry solution java virtual machine jvm 
jvm quickly de facto standard encoding mobile programs transport internet 
unfortunately solution embodied java fails deliver execution efficiency native code reasonable levels dynamic compilation effort 
main reason deficiency jvm instruction format capable transporting results program analyses optimizations 
consequence java byte code transmitted site recipient repeat analyses optimizations performed just origin 
java fails preserving parallelism transporting programs written languages fortran leading loss information essential optimizations completely reconstructed code recipient site 
main reason java byte code deficiencies allow verification recipient 
untrusted mobile code needs verified prior execution protect host system potential damage 
fundamental validation step ascertain arriving mobile program type safe breach type system subvert security policy 
type safe source language remove necessity verification 
barring additional authentication mechanism guaranteed piece mobile code originated valid source program place explicitly hand crafted corrupt host 
verifying type safety piece java code non trivial time consuming activity 
interestingly elaborate course project identified certain mobile program representations remove need verification altogether transport tamper proof manner results program analyses benefiting code generation eventual target machine 
hinted key idea doing away verification representation provably encode legal programs place 
policy assumptions guarantees security approach type safety typing model source language restricted particular language type safety model 
typesafe source language requirement 
underlying idea security guarantee exists source language level just preserve stages code transportation 
requirements mobile code transportation system ffl mobile programs need programmed typesafe language ffl host system needs publish policies terms type safe api mobile code transportation system guarantees type safety host library routines guaranteed called parameters correct type mobile program 
capabilities object pointers owned host manipulated mobile client application specified host interface definition example visibility modifiers private protected 
forged altered 
example host file system interface procedure open 
file returns file object 
type safety security scheme able guarantee mobile client program alter file object way prohibited specification access contents allowed explicit visibility modifiers 
conversely additional security policies mobile program open files directory need implemented host side 
semantics transportation scheme identical sending source code incidentally model programmers falsely assume anyway 
note efficiency reasons guard trade secrets embedded mobile code approach sending source code usually option 
consequence subtle problems arise semantics intermediate language different source language example programs expressed java virtual machine byte code language equivalent java source language level 
situations avoided 
type safety sufficient 
interestingly model transporting equivalent source code enables automatic support user specified security policy cast language construct 
take example andrew myers java information flow language 
language provides additional modifier additional dimension type space variables specifies security attribute variable owner 
information flow restricted statically components occur low security high security vice versa 
clearly new security property supported current mobile code transportation schemes 
property property mapped language construct easily supported grammar mobile code transportation schemes developed 
key approach completely preserves type semantics underlying source language 
encoding legal programs investigating class encoding schemes mobile programs rely semantic information guarantee legal programs syntactic typing rules underlying grammar encoded place 
essentially achieved constantly adjusting language encoding reflect semantic entities legally available aforementioned rules point encoding process 
program encoded manner tampered yield program violates rules 
modification transit worst case result creation legal program guaranteed conform original rules 
encoding schemes exploring related data compression yield exceptionally high encoding densities side effect 
example probabilistic encoding concrete example encoding property able encode legal programs consider probabilistic encoding mechanism parses intermediate syntax tree representation program encodes intermediate representation grammar continuously adapted probabilistic model 
step encoding alternatives possibly occur point enumerated 
type grammatical class different probability distribution encoder decoder keep track distributions 
example statement assignment statement statement 
probability assignment usually highest 
similarly assignment left hand side local variable global external variable array access pointer access local variable choices limited declarations program relative probability past history 
encoding form arithmetic coding 
probabilities various occurring constructs define sub intervals range bit pattern represents encoding corresponds real number designating sub interval 
example assignment probability designate interval represent assignment 
assume probability target assignment local variable lead stand assign local 
local variables assignment equal probability assignments represented 

step interval narrowed manner highly probable events contribute information probable ones 
real number final interval represents encoded construct 
probabilities constantly adjusted encoding proceeds 
consequence individual constructs contribute just fraction bit final encoding programs exhibit high degree self similarity 
note bit pattern ultimately emitted needn buffered indefinitely output progressively rescaling interval appropriately 
note encoding provably encode legal programs elements forbidden point zero probability represented 
hand bit pattern maps back legal program original rules corresponding real number falls interval 
note performance enhancing semantically irrelevant annotations easily superimposed encoding stream simply incorporating probabilistic model 
technical approach technique improvement earlier slim binary method dictionary encoding scheme syntax trees 
slim binary scheme dictionary grown speculatively time contains subexpressions previously occurred constituent semantic entities variables data members 
visible source language scoping rules 
encoding schemes investigating project exert finer control encoding dictionary general context step temporarily removing sub expressions aren applicable 
research direction elaborated separate section entitled compression syntax trees 
slim binary method investigated applying encoding richer starting representations syntax trees 
example encoding applied programs represented variant static single assignment ssa form performing common sub expression elimination copy propagation 
ssa encoding disambiguates different values variable simplifies generation high quality native code receiver site leads fewer alternatives encoding step consequently denser encoding 
encoding ssa led genuinely new intermediate representation called safetsa described separate section 
alternative bottleneck interface 
core calculus approach somewhat separate research separate section 
core calculus source program generally goes different internal representations different stages compiler 
strings source program text 
streams lexical tokens 
syntax trees asts generated parsing process 
medium level internal representation compiler uses analyze source transform optimization 
improve retargetability compilers representation normally independent final compilation target 

low level internal representation explicit actual machine instructions 
representation dependent compilation target designed allow scheduling resource allocation additional target dependent optimizations 

machine language representation containing actual bits executed target machine 
program transported code producer code consumer representation levels may 
tradeoffs may influence choice representation ffl higher representation levels allow program portable wider range targets 
ffl similarly higher representation levels easier optimize program specific target characteristics 
may critical performance modern architectures 
ffl higher representation levels easier consumer prove disprove type safety program 
ffl correspondingly higher representation levels require part consumer increasing time required energy required embedded applications program executed 
ffl lower representation levels program independent programming language program written 
ffl lower representation levels increase difficulty reverse engineering program 
representation level java bytecodes somewhat mixed containing features specific java language features typical lowlevel encoding 
proven adequate transporting code number source languages variety popular machine architectures direct interpretation allowing validation code consumer 
mismatches representation level semantics representation result bad performance languages java 
potential sources problems include insufficient flexibility object storage resulting inefficient space differences semantics subtyping object dispatch primitive operations lack support parallelism specialized language constructs 
shortly jvm introduced shivers fahlman proposed solving problem providing mechanism extending java virtual machine 
mechanism allow new language specific instructions added jvm compilers 
new instructions described low level format register transfer language rtl 
due unsafe low level nature extension language extension programs part trusted computing base code consumer side require sort cryptographic authentication mechanism 
proposal implemented adequate transport mechanism mobile code advanced programming languages 
alternative method solving problem core calculus approach 
base ap proach encoded high level intermediate representation source language specific syntax tree ast just slim binaries system 
addition transporting encoding ast proven target compression mapping transported giving semantics source language ast terms core calculus 
programs transmitted approach follows code producer uses traditional compiler front produce syntax tree source program directly encodes tree transmission 
mapping describing semantics source language transmitted obtained library mappings common languages 
code consumer decodes original syntax tree mapping applies mapping obtain original program represented core calculus 
consumer compiles program representation machine code target architecture 
ensure safety scheme necessary core calculus type preserving 
possibility safetsa described language specific aspects safetsa result problems described earlier java virtual machine 
representation chosen line research typed lambda calculus system 
representation studied extensively programming language community amenable compiler analysis known techniques 
advantages scheme include ffl high level representation possible compress code 
ffl source languages added ad hoc user intervention increasing size trusted computing base 
ffl easier write mapping file develop full compiler back system serve part language design workbench ffl programs transmitted high level compilation machinery code consumer possible provide convenient api code writing programs 
ffl source program transmitted high level representation remains possible potentially efficient language specific compiler backend commonly languages 
system described far places burden code consumer 
mapping changed map lower level code core calculus possible variable amounts optimization code transmitted 
allows flexibility choose best place continuum representation levels application hand 
compression syntax trees major approaches mobile code compression schemes code factoring compiler optimizations reduce code size leaving code directly executable schemes compress object code exploiting certain statistical properties underlying instruction format schemes compress syntax tree ast program statistical dictionary approaches 
approach falls category 
source code modulo comments layout names internal identifiers easily regenerated ast 
ast composed grammar ag domain knowledge underlying language achieve compact encoding general purpose compressor achieve 
compression framework applies different kinds code 
convenient think compression algorithm applied source language decompression code receiver site compiled native code 
generally scheme applies code formats expressed form grammar 
theoretically includes forms code source code intermediate representations byte code object code 
prototype implementation compresses java source programs compiled native code circumventing compilation byte code execution jvm 
chose compression java programs opposed languages proof concept sizeable body compression java programs exists especially pugh jar file compression 
gives viable yardstick gauge results 
compression scheme assume source code re generated code consumer site 
fact current implementation decompressor interfaces directly gcc backend 
framework source code required order generate compressed ast inversely compressed ast intrinsic capability regenerate source code deprived comments internal identifier names 
facts position encoding ideal distribution format open source software 
files course format meant replacement binary dis format compact span architectures reducing maintainance effort packaging 
compression format contains information provided programmer source language level runtime system code consumer site information provide optimizations services source language guarantees 
kistler uses availability ast dynamic re compilation runtime feasible 
furthermore distributing code source language equivalent form provides runtime system choice platform tailored intermediate representation 
success transmeta code morphing technology shows viable approach starting unsuitable intermediate representation lower abstraction level 
lastly high level encoding programs protects code consumer kinds attacks lowlevel instructions hard control verify 
encoding desirable characteristic malicious manipulation generate asts adhere grammar additional semantic constraints providing degree safety construction 
contrast byte code programs go expensive verification process prior execution 
compression techniques asts computer program sources phrases formal languages represented character strings 
programs proper really character strings sense natural numbers digit strings entities 
conventional context free grammars concrete grammars mix necessary information nature programs irrelevant information catering human machine readability 
ast tree source program abstracting away concrete details symbols open close block statements 
constitutes ideal starting point compressing program 
note properties precedence different forms nesting implicit ast tree structure 
due equivalence terms ast source program interchangeably 
grammars ast complies grammar ag just source program complies concrete gram tribution open source software 
right modify source documentation integral part open source philosophy format alternative fully commented source text 
example note java language provides restrictive control flow java byte code allows arbitrary branches 
mar ags give succinct syntactically correct programs eliminating semantically superfluous details source program 
ags consist rules called productions defining symbols concrete grammars define non terminals 
phrases languages defined concrete grammars character strings phrases languages defined ags asts 
ast node corresponds rule refer kind node 
purpose simple presentation discuss forms rules suffice specify sensible ags 
rules subset rules framework 
rules compound rules defining symbols corresponding known non terminals concrete grammars 
aggregate rule defines ast nodes gate nodes fixed number children 
example rule loop statement defines node children kind expression statement expression statement second form compound rule choice rule defines ast nodes choice nodes exactly child 
kind child node chosen fixed number alternatives 
simplified rule says statement node assignment child statement 
statement assignment kind rule string rule defines string nodes 
right hand side string rule predefined string symbol 
string rules define equivalent terminals concrete grammars 
string nodes contain arbitrary string leaf nodes ast 
define ident node string node write 
ident string user defined symbols ags defined exactly rule exception predefined string symbol 
usual symbol marked start symbol ag 
encoding asts order encode store transport asts need serialized 
asts serialized writing welldefined traversals 
serialize ast generating preorder representation 
traversal provides linearization tree structure 
order encode term syntactically refers convention context free nature grammar 
information stored nodes mechanisms exist 
common technique pre scans tree node attributes stores separately maintained lists augment tree representation indices lists 
ignore problem efficiently compressing strings node attributes sake simplicity assume strings directly encoded appear 
actual tree representation effective ag 
ag information preorder encoding redundant 
particular order kind children aggregate nodes known 
encoding boils noting choices choice node 
order alternatives choice nodes fixed suffices encode position chosen alternative 
course alternative choice needs encoded 
arithmetic coding far reduced serialization compound rules encoding choice choice node integer ng depends kind choice node equal number alternatives 
want bits possible encoding choice options huffman coding arithmetic coding 
huffman code discussed stone fast flexible compared arithmetic coding 
cameron shows arithmetic coding appropriate compression results 
arithmetic coder best means encode number choices alternative ng certain probability kind choice node 
tuple pn called model arithmetic coder 
encoding arithmetic coder takes sequence choices respective models argument outputs sequence bits information arithmetic coder produces compact encoding sequence choices 
decoding arithmetic coder takes sequence bits sequence models arguments 
model reproduces choice important note model depend previous choices gamma choice models determines compression ratio 
probabilities picked optimal fashion available information account adapting probabilities appropriately encoding maximal entropy 
simple fast way chose models fix probability distributions kind node 
static models determined statistics representative set programs 
prediction partial match prediction partial match ppm statistical predictive text compression algorithm 
ppm variations consistently outperformed dictionary methods statistical methods text compression 
ppm maintains list seen string prefixes conventionally called contexts 
context keeps track occurrences characters 
example processing string contexts empty context ab ba bc aba bab abc abab 
length called order 
counted subsequent characters say ab occurrence 
normally efficient implementations ppm maintain contexts dynamically context trie 
context trie tree characters nodes path root node represents context formed concatenating characters path 
root node contain character represents empty context prefix 
context trie children node constitute characters seen context 
order keep track number times certain character followed context number occurrences noted edge 
information ppm assign probabilities potentially subsequent characters 
adapting ppm asts adapted unbounded variant ppm algorithm ppm asts text 
applying ppm trees problem solve definition contexts asts 
context ast node defined concatenation nodes root exclusively 
means modified ppm algorithm treats ast nodes original ppm algorithm treats characters 
alphabet corresponds symbols rules ag 
ppm algorithm applied sequences nodes appear traversing ast depth order 
changes sufficient adapt ppm asts 
maintenance procedure context trie needs augmented input seen modified ppm consist contiguous characters anymore 
change needed tree traversal child node 
corresponds familiar addition current context 
happens traversal subtrees current context 
necessitates enhanced context trie functionality 
ppm maintains set nodes context note aggregate node children kind position relevant context 
happen implemented refinement 
trie called active nodes 
active nodes mark positions current contexts 
root trie representing empty prefix active 
new nodes context trie created children active nodes 
adaptation ppm regular ppm come path syntax tree leaf node pop context nodes marked active root context trie moved node parents 
ensures children node ast appear children context trie 
works traverse ast depth order building contexts 
desirable consequence technique depth context tree depth syntax tree compressing 
weighing strategies order generate model encoding decoding step look counts symbols seen current context context trie 
active nodes direct pointers correspond seen symbol fast lookup involve traversing trie 
counts ways build model 
normally context trie contains counts contexts various orders 
decide weigh get suitable model 
tradeoff shorter contexts occur fail capture specificity longer contexts symbol occurs times long context chance occurring long context high longer contexts occur symbols give predictions 
note characteristics ast contexts differ text contexts 
tried various weighing strategies experiments indicate order contexts simply occurrence counts symbols form level context trie weighing predictions equally yields best compression 
compressing constants sizable part average program consists constants integers floating point numbers string constants 
string constants sense encompass usual string literals hello world type names java lang object field names 
simplified definition ags predefined string symbol embody case constants asts 
ast contexts bound depth ast tend repetitions prefixes nodes subtree 
string node attributed arbitrary string 
observing strings asts typical programs apparent strings multiple times 
saves space encode different strings refer occurrences 
index list strings 
higher number strings bits needed encode corresponding index 
distinguishing different kinds strings type names field names method names different lists strings created 
split lists smaller global list 
context determines list access strings split lists require space encode 
considerations show context sensitive opposed context free information symbol tables encoded compressed varying degrees sophistication 
preliminary results current implementation prototype written python consisting roughly modules handling grammars syntax trees encoding decoding 
frontend written java uses parsing java programs 
information necessary specify ast encoding compression condensed configuration file 
configuration file contains ag augmented additional information compress symbol table 
framework code producer consumer sites additional requirement supported language identical copies configuration file sites 
chose primarily pugh compression scheme comparison see table knowledge provides best compression ratio java class files freely available educational purposes 
comparable compression scheme syntax oriented coding 
scheme detailed compression numbers available indication average compression ration format regular class files 
noted pugh designed compression scheme jar files collections class files 
algorithm perform small files bigger ones 
assume due overhead caused fact small streams data compressed separately zlib library 
evaluation version pugh java packing tool 
furthermore compare results widely available general purpose compression algorithms gzip bzip 
pugh compression tool works java jar note conventional symbol tables conveniently expressed kind ast appropriate string nodes 
name class file tar gzip tar bzip jar pugh ppm ppm pugh main table 
file sizes compressed files classes javac numbers bytes 
files individual class files jar file individual class files compress resultant jar file pugh tool 
order fair comparison tar class files running bzip gzip 
purposes include size original class file 
choice single classes tries representative sizes classes jvm suite 
javac official java compiler package compare results available source form 
table shows compression scheme improves compression pugh results 
experience shows ppm adapts fast program peculiarities efforts improve compression initially statistically determined probabilities yield significant gains compression 
related compression initial research syntax directed compression conducted primarily order reduce storage requirements source text files 
describes coding technique essentially equivalent technique described section 
reduces size pascal source original size 
achieve similar results automatically generated encoders decoders 
implemented compression system probabilistic grammars lr parsing 
cameron introduces combination arithmetic coding encoding scheme section 
statically assigns probabilities alternatives appearing grammar uses probabilities encode preorder representation asts 
furthermore uses different pools strings encode symbol tables variable function procedure type names 
deploying non context free techniques achieves compression pascal sources original size 
survey tree compression general methods particular 
tarhio suggests application ppm drive arithmetic coder fashion similar 
reports increases compression pascal asts excluding constants compared technique close cameron 
techniques concerned compressing preserving source text program compact form attempt represent program semantic content way suited processing dynamic code generation interpretation reflects incorrect semantics tree 
franz tree encoding executable mobile code 
java currently prominent mobile code platform attracted attention respect compression 
horspool compress java class files roughly original size compression scheme specifically tailored java class files 
follow bradley horspool vitek improve compression ratio scheme extend applicability java packages jar files 
better compression scheme jar files proposed pugh 
format typically size corresponding compressed jar file size original class files 
pugh offers tool free evaluation 
java compression schemes start byte code java class files contrast source program written java programming language 
eck employ compression scheme similar cameron apply java sources 
report compression original source file detailed information needed assess approach 
contrast pugh evaluation tools available 
safetsa representation java virtual machine bytecode format jvmcode de facto standard transporting mobile code internet 
generally acknowledged jvm code far ideal mobile code representation considerable amount unfortunately learned cameron tarhio developed solution independently 
cessing required convert jvm code representation amenable optimizing compiler dynamic compilation context preprocessing takes place user waiting 
due need verify code safety arrival target machine due specific semantics jvm particular security scheme possible optimizations performed source jvm code compiler done eventual target machine cumbersome perform code producer site 
example information redundancy type check may front compiler prove value question correct type path leading check fact communicated safely jvm code stream needs re discovered just time compiler 
communicated safely mean way malicious third party construct mobile program falsely claims check redundant 
take common subexpression elimination compiler generating jvm principle perform cse store resulting expressions additional compiler created local variables approach clumsy best 
approach taken safetsa developed project radically different jvm stack virtual machine 
safetsa representation genuine static single assignment variant differentiates variables original program unique values variables 
safetsa contains assignments register moves encodes equivalent information phi instructions model dataflow 
straightforward ssa representations safetsa provides intrinsic tamper proof referential integrity formedness property encoding 
key idea safetsa type separation values different types kept separate manner hand crafted malicious program undermine type safety concomitant memory integrity 
interestingly type separation enables elimination type range checks code producer side manner falsified 
safetsa programs transmitted common subexpression elimination removes redundancies leading smaller efficient programs 
referential integrity program ssa form contains assignments register moves instruction operand refers directly definition phi function models merging multiple values control flow 
straightforward ssa unsuitable application domains require verification referential integrity context possibly malicious code suppliers 
ssa contains unusually large amount needing verified far original source program making verification process expensive 
example consider program 
left side shows source program fragment right side sketch look translated ssa form 
line ssa representation corresponds instruction produces value 
individual instructions implicitly values generate labeled integer numbers assigned consecutively illustration arrow left instruction points label designates specific target register implicitly specified instruction 
previously computed values instructions denoted enclosing label previous value parentheses depiction placeholders instructions compute initial values uses uninitialized variables java instructions exist cases correspond values propagated constant pool 
problem representation lies verifying correctness 
example value referenced phi function may parameter second parameter phi function 
malicious code supplier want provide illegal program instruction instruction program takes path undermine referential integrity prevented 
solution insight ssa instruction may values dominate lie path leading entry point referencing instruction 
leads representation prior instructions represented pair denotes basic block expressed number levels removed current basic block dominator tree hierarchy denotes relative instruction number basic block 
index denotes appropriate preceding block control flow graph nth argument phi function corresponding nth incoming branch higher numbers refer block dominators 
corresponding transformation program 
resulting representation provides referential integrity intrinsically requiring additional verification trivial ensuring relative instruction number exceed permissible maximum 
fact exploited encoding pair 
sub add add cmp bgt add phi add ssa form sub phi add add cmp bgt add add safe ssa form int int bool void int add int phi int int int add const int sub const int int int add const int add const bool bgt int cmp typed safe ssa form 
example program type separation second major idea representation type separation 
implied machine model ordinary ssa unlimited number registers values safetsa uses model separate register plane type disregarding moment added complication part naming individual registers temporarily disregarding type polymorphism java language supported format explained 
register planes created implicitly account predefined types imported types local types occurring mobile program 
type safety achieved turning selection appropriate register plane implied part operation making explicit 
safetsa instruction automatically selects appropriate plane source destination registers operands instruction merely specify particular register numbers selected planes 
destination register appropriate destination register plane chosen implicitly plane registers simply filled ascending order 
example operation integer addition takes register numbers parameters src src 
implicitly fetch source operands register integer src deposit result available integer register register integer plane having index zero index greater integer result produced basic block 
way malicious adversary change integer addition operate operands integers generate result integer cause holes value numbering scheme basic block 
give second example operation integer compare takes source operands integer register plane deposit result available register boolean register plane 
safetsa combines type separation concept referential integrity discussed previous section 
having separate register plane type additionally complete twodimensional register set basic block 
results applying type separation safe numbering program fragment shown 
construction memory safety type ref machine model provides matching type safe ref implies corresponding value null checked 
similarly array arr provide matching type safe index arr instances may assume values index values legal range null checking operation takes explicit ref source type explicit register number corresponding register plane 
check succeeds ref value copied implicitly register available plane corresponding safe ref type exception generated 
similarly index check operation take array number integer register check integer value bounds check succeeds copy integer value appropriate safe index register plane 
beauty approach enables transport null checked index checked values 
phi functions strictly type separated operands phi function result reside register plane 
necessary combine ref type corresponding safe ref type single phi operation safe ref type needs downcast need support dynamically sized arrays safe index types bound array values static types 
corresponding unsafe ref type 
downcast operation modeling function safetsa result actual code eventual target machine 
null checking index checking generalized include type cast operations operation involves dynamic check cause exception fails 
case success copy value cast available free register plane target type dynamic check result actual code target machine copy operation 
downcast operation fails result actual target code 
memory operations safetsa require storage designator safe state operations take operands register plane safe ref safe index type corresponding unsafe types 
example primitive data member write access ref type object field value ref type denotes type type table object designates register number plane corresponding safe ref type field symbolic data member ref type value designates register number plane corresponding type field 
operation corresponding arrays ones may modify memory accordance type declarations type table 
key type safety entries type table taken mobile program corrupted malicious code provider 
pertinent information may included mobile code distribution unit ensure safe linking parts type table refer primitive types underlying language types imported host environment libraries generated implicitly tamper proof 
suffices guaranteeing memory safety host presence malicious mobile code 
particular case java programs safetsa able provide identical safety semantics java source code transported target machine compiled linked locally 
prototype compiler capable encoding information approximately space equivalent java bytecode instructions preliminary results building system consisting compiler takes java source files translates safetsa representation dynamic class loader takes safetsa code distribution units executes sparc fly code generation 
currently compiler process programs written complete java language produce safetsa intermediate code 
class loader dynamic code generator produce competitive results progressed sufficiently confident correctness approach 
safetsa provides safe mechanism transportation optimized code 
take advantage fact perform optimizations reduce size eventually execution time transmitted code 
proof concept currently implement constant propagation common subexpression elimination dead code elimination local level 
measurements compare size number instructions programs compiled java byte code safetsa optimized safetsa 
benchmarks programs sun java development kit 
include classes java compiler javac java interpreter java classes math linpack packages 
classes demonstrate reductions array checking instructions 
compare java refer byte code produced version sun javac 
columns show sizes numbers instructions safetsa files compared java class files cases safetsa number instructions java byte code requires 
mentioned optimizations reduce significantly number instructions safetsa form cases programs 
constant propagation leads improvement program size 
dead code elimination generally effective reducing number phi instructions number instructions 
majority code size reduction due common subexpression elimination 
measurements reduction due 
sizes safetsa files usually smaller equivalent java byte code files substantially 
gives detail practical influence optimizations performed prior transmission code 
contains information reduction phi instructions null checks array checks 
particular interest lead information needs transmitted eventually faster execution 
seen number phi instructions reduced cases 
surprisingly eliminate safely transport program cases fewer cases reduction achieved 
surprisingly optimizations knowledge safe values common subexpression elimination context sensitive analysis 
class name instruction count phi instruction null checks array checks jvm opt 
delta delta delta sun tools javac main sun tools java scanner parser sun math linpack linpack 
number phi null check array check instructions optimization 
benchmarks include lot array manipulation 
see reduction number array check instructions 
note safetsa sizes contain explicit null checks typechecks index checks need transported java byte code removed consequence 
related typed irs difficult generate quality native code jvmcode 
situation exacerbated jit compilers need operate user waiting need favor compilation speed code quality linear scan register allocation graph coloring 
jvm hard verify 
particular checking operand accesses stack valid requires data flow analysis 
safetsa promises alleviate concerns 
years native code optimizing java compilers intermediate representation ssa form developed swift compiler marmot hotspot server compiler 
jalapeno uses ssa certain optimizations 
intermediate representation microsoft announced net platform offers improvement stack virtual machine allowing second ssa form description added stack representation 
net details released unclear provisions net may guaranty consistency stack ssa representations type safety ssa representation 
approach proof carrying code pcc aims safe execution untrusted possibly mobile code 
target machine receives native code proof native code complies target machine security policy 
pcc support arbitrarily complex security policies proofs automatically similar guarantees enforced safetsa 
tal typed assembly language guarantees similar level safety overlaying type system machine code 
compiler noteworthy maintaining typing compiler phases intermediate representations similar ssa 
project contributions areas syntax tree compression mobile code representations 
continuing explore trade offs security flexibility compactness efficiency 
authors thomas kistler laski sumit contributions early stages project 
christian designed implemented reusable library general compression algorithms 
sun hotspot compiler java 
java sun com products hotspot 

file compression probabilistic grammars lr parsing 
phd thesis university 
alpern attanasio jalapeno virtual machine 
ibm system journal february 
benitez davidson 
advantages machine dependent global optimization 
plsa international conference programming languages architectures pages mar 
spiegel 
front java 
technical report freie universitat berlin dec 
bradley horspool vitek 
jazz efficient compressed format java archive files 
proceedings cascon pages toronto ontario nov 
cameron 
source encoding syntactic information source models 
ieee transactions information theory july 
cleary teahan 
unbounded length contexts ppm 
computer 
cleary witten 
data compression adaptive coding partial string matching 
ieee transactions communications 

compact coding method syntax tables 
phd thesis reading university england 

compact coding syntactically correct source programs 
software practice experience 
debray evans muth 
compiler techniques code compression 
workshop compiler support system software may 
eck 
new compression scheme syntactically structured messages programs applications java internet 
data compression conference page 
ernst evans fraser lucco proebsting 
code compression 
proceedings acm sigplan conference programming language design implementation pages 
published sigplan notices 
fitzgerald knoblock marmot optimizing compiler java 
microsoft technical report march 
franz 
code generation fly key portable software 
phd thesis eth zurich mar 
franz kistler 
slim binaries 
communications acm dec 
fraser 
automatic inference models statistical code compression 
proceedings acm conference programming language design implementation 
horspool 
tailored compression java class files 
software practice experience oct 
hummel azevedo nicolau 
annotating java bytecodes support optimization 
concurrency practice experience nov 
special issue java computational science engineering simulation modeling ii 

tree compression optimization applications 
international journal foundations computer science 

syntax directed compression program files 
software practice experience 
kistler 
continuous program optimization 
phd thesis university california irvine nov 
kistler franz 
automated data member layout heap objects improve memory hierarchy performance 
acm transactions programming languages systems may 
lucco 
split stream dictionary program compression 
proceedings acm conference programming language design implementation 
meyer 
theory programming languages 
phi series computer science 
prentice hall 
morrisett walker crary glew 
system typed assembly language 
acm trans 
prog 
lang 
sys may 
myers 
jflow practical static information flow 
proceedingsof th acm symposium principles programming languages popl san antonio texas usa jan 
necula 
proof carrying code 
popl paris france jan 
poletto sarkar 
linear scan register allocation 
acm trans 
prog 
lang 
sys september 
pugh 
compressing java classfiles 
acm sigplan conference programming language design implementation pages 
scales randall ghemawat dean 
swift java compiler design implementation 
wrl research report compaq research april 
shivers 
supporting dynamic languages java virtual machine 
proceedings dynamic objects workshop boston may 
standard performance evaluation 
spec jvm benchmarks 
see online www spec org osg jvm information 
stone 
choice grammar parser compact analytical encoding programs 
computer journal 
tarhio 
context coding parse trees 
proceedings data compression conference page 

