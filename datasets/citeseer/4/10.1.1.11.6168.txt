nominal unification christian urban andrew pitts murdoch gabbay university cambridge cambridge uk generalisation order unification practically important case equations terms involving binding operations 
substitution terms variables solves equation equated terms equivalent equal renaming bound names 
applications mind consider simple textual form substitution names occurring terms may captured scope binders substitution 
able take nominal approach binding bound entities explicitly named nameless de bruijn style representations get version form substitution respects equivalence possesses algorithmic properties 
achieve adapting existing idea introducing key new idea 
existing idea terms involving explicit substitutions names names explicit permutations bijective substitutions 
key new idea unification algorithm solve equational problems problems freshness names terms 
simple generalisation classical order unification algorithm setting retains pleasant properties unification problems involving equivalence freshness decidable solvable problems possess general solutions 

decidability unification equations firstorder terms algorithms computing general unifiers form fundamental tool computational logic applications programming languages computer aided reasoning 
potential applications fall outside scope order unification involve term languages binding operations wish distinguish terms differing renaming bound names 
large body studying languages binders various calculi term rep resentation languages leading higher order unification algorithms solving equations terms modulo equivalence 
higher order unification technically complicated completely satisfactory pragmatic point view 
reason lies difference substitution order terms terms 
simple operation textual replacement called grafting context substitution sect 
involves renamings avoid capture 
capture avoidance ensures substitution respects equivalence complicates higher order unification algorithms 
furthermore simple textual form substitution complicated capture avoiding form occurs informal applications unification modulo equivalence 
example consider schematic rule form part inductive definition binary evaluation relation expressions imaginary functional programming language app fn 
metavariables standing unknown programming language expressions 
binders fn may capture free occurrences instantiate schematic rule replacing metavariable expression 
instance rule scheme bottom search proof substitution involve capture order unify goal rule generating new goal app fn hypothesis 
problem informal practice usually identify terms equivalence textual substitution respect equivalence 
example equivalence goal 
think erroneously 
rule changing rule hypothesis trying equivalence disappear infrastructure able replace part equivalent part 
tempted unify textual substitution apply substitution hypothesis obtain wrong goal app fn 
calculus higher order unification saves sloppy thinking expense having explicit dependence metavariables names function variables application 
example rule replaced app fn app fn modulo equivalence goal problem unifying substitution fine situation pleasant order terms higher order unification problems undecidable decidable lack general unifiers unifiers imposing restrictions see survey higher order unification 
started wanting compute binders modulo equivalence process making possibly capturing substitution respectable led function variables application capture avoiding substitution equivalence 

thing authors noted sense possibly capturing substitution modulo equivalence explicit substitutions term representation language see 
compared works number simplifications 
find need function variables application equivalence representation language leaving just binders equivalence 
secondly explicit substitutions names names explicit permutations names 
idea name permutations particular name dealing conversion dates back growing evidence usefulness see example :10.1.1.38.9383
name substitution permutation function induces terms terms bijection gives operation permuting names logical properties compared name substitution 
consider example equivalent terms fn fn distinct 
apply substitution renaming free occurrences get fn fn longer equivalent 
renaming substitutions respect equivalence general unification algorithm ing needs take extra precautions inadvertently change intended meaning terms 
traditional solution problem introduce complicated form renaming substitution avoids capture names binders 
contrast simple operation respects equivalence example applying name permutation swaps occurrences free bound binding terms gives fn fn equivalent 
exploit properties name permutations give conceptually simple unification algorithm 
addition explicit name permutations compute symbolically predicates expressing freshness names terms 
key novelty approach 
arises naturally reported easy see directly need computing freshness take nominal approach binders :10.1.1.62.9845:10.1.1.62.9845:10.1.1.11.7844:10.1.1.11.7844
words stick concrete versions binding equivalence bound entity named explicitly de bruijn style representations example 
basic instance generalised form equivalence identifies example fn fn provided fresh subterm indicates explicit permutation swapping waiting applied write fresh symbolically intended meaning relation occur free ground term may substituted know may able eliminate explicit permutation example knew holds replaced clear simple examples setting appropriate notion term equality bare equation hypothetical judgement form freshness environment finite set 
xn freshness assumptions 
example fn fn valid judgement nominal equational logic 
similarly judgements freshness take form 
summarise represent languages involving binders usual notion order terms sorted signature certain distinguished constants function symbols 
give terms distinguished constants naming entities call atoms terms expressing generic form binding atom term terms representing explicit permutation atoms waiting applied term substituted variable section presents term language syntax directed inductive definition provable judgements form ground terms ones variables agrees usual relations equivalence free variable 
section considers unification problems setting 
solving equalities abstractions 
entails solving equalities 
freshness problems 

general form nominal unification problem finite collection individual equality freshness problems 
problem solved providing substitution terms variables freshness environment property hold individual equality 
freshness 
problem main result solvability decidable solvable problems possess general solutions reasonably obvious notion general 
proof unification algorithm similar order algorithm common transformational style 
see sect 
sect 
expositions 
section considers relationship version unification modulo equivalence existing approaches 
section assesses achieved prospects applications 
appreciate kind problem nominal unification solves try quiz calculus apply algorithm solve section 
quiz assuming distinct variables possible find terms 
pairs terms equivalent 








possible find solution problems describe possible solutions problem answers see example 
nominal equational logic take concrete approach syntax binders bound entities explicitly named 
particular languages may require different sorts names example ml programming language names value identifiers names type variables 
want allow possibility names different names variables example calculus tion operator binds channel names quite separate names unknown processes :10.1.1.36.865
names bound entities called atoms 
partly historical reasons stemming second authors set theory atoms semantics binding freshness partly indicate internal structure names irrelevant care identity atom fact supply atoms :10.1.1.62.9845
general frameworks literature specifying languages binders meet requirements mentioned previous paragraph 
simply typed calculus purpose common discussed leads problematic unification theory 
order frameworks plotkin notion binding signature unsorted equates names binding names variables standing unknown terms sufficiently general 
order framework meet requirements notion nominal algebras 
nominal signatures mild practically useful generalisation nominal algebras name abstraction pairing mixed freely arities insisting argument sort function symbol normalised tuple abstractions 
definition 
nominal signature specified set sorts atoms typical symbol disjoint set sorts data typical symbol set function symbols typical symbol arity form 
ranges compound sorts grammar terms sort binding abstractions atoms sort terms sort 
explain syntax properties terms moment 
example 
nominal signature expressions small fragment standard ml sort atoms vid sort data exp function symbols vr vid exp app exp exp exp fn vid exp exp lv exp vid exp exp lf vid vid exp exp exp function symbol vr constructs terms sort exp representing value identifiers named atoms sort vid app constructs application expressions pairs expressions fn lv lf constructs terms representing respectively function abstractions fn local value declarations val local recursive function declarations fun 
unit abstraction unit atom pair ds abstraction atom arities function symbols specify binders way arguments bound 
example expression fun binding occurrence value identifier scope binding occurrence value identifier scope just 
binding scopes reflected argument sort function symbol lf 
kind specification binding scopes course feature higher order syntax function types simply typed calculus abstraction sorts 
shall see elementary order properties compared 
definition 
nominal signature assume countably infinite pairwise disjoint sets atoms typical symbol sort atoms variables typical symbol sort atoms data 
terms nominal signature sorts inductively defined follows write indicate term sort 
unit value 
pairs 
data function symbol arity 
atoms atom sort 
atom abstraction atom sort 
suspension bn finite list elements ai bi pairs atoms ai bi sort variable pair function symbol 
inductive definition 
abstraction suspension abstraction suspension function symbol sort 
case empty list just write recall finite permutation expressed composition ai bi list pairs atoms occurring suspension term specifies finite permutation atoms waiting applied know variable substituting example 
represent finite permutations way really operation swapping plays fundamental role theory 
semantically speaking see semantics swapping commutes term forming operations normalise terms involving explicit swapping operation pushing swap far go reaches variable cf 
fig 
terms definition normalised way explicit front variables giving called suspensions 
wish give definition equivalence terms nominal signature respected substitution terms variables may involve capture atoms binders 
need auxiliary relation freshness atoms terms intended meaning atom occur free substitution instance term 
discussed judgements term equivalence need contain hypotheses freshness atoms respect variables goes judgements freshness 
gives syntax directed inductive definition equivalence freshness judgements form terms sort nominal signature atom freshness environment def def def def def def def 
permutation action terms finite set freshness constraints specified atom variable 
rules abstraction suspension suspension fig 
definitions 
definition 
recall definition specify finite permutations atoms finite lists bn representing composition finitely pairs atoms ai bi ai bi sort 
apply permutations terms left order composition right left 
representation composition permutation followed swap list cons written composition followed permutation list concatenation written identity permutation empty list inverse permutation list reversal written permutation action finite permutation atoms term defined fig 
pushes list structure term piles front suspensions applying actual permutation represents atoms meets way 
disagreement set permutations rule suspension fig 
defined ds def 
note subset finite set atoms occurring lists occur lists fig 
get illustrate disagreement sets consider holds rule suspension disagreement set 
lemma 
equivalence relation preserved term forming operations definition respects freshness relation 
preserved permutation action fig 
sense proof 
proof results tedious mainly large number cases entirely straightforward properties permutation action disagreement sets need established statements omitted 
machine checked proof isabelle www cl cam ac uk cu unification main reason suspensions syntax terms enable definition substitution terms variables allows capture free atoms respecting equivalence :10.1.1.36.865
lemma establishes 
give terminology notation term substitution 
definition 
substitution sort respecting function variables terms property finitely variables shall write dom finite set variables satisfying dom consists distinct variables 
xn xi ti shall write 
xn tn 
write result applying substitution term term obtained replacing suspension ranges dom term got letting act term definition fig 

example substitution freshness environments write mean holds 
substitutions freshness environment write mean holds dom dom 
lemma substitution 
substitution commutes permutation action 
substitution preserves sense 
proof 
sentence follows induction structure second follows induction proofs rules fig 
sentence proof lemma 
claim relation defined fig 
gives correct notion equivalence terms nominal signature 
reasonable lemma fact definition satisfies rules abstraction abstraction 
evidence provided theorem shows ground terms agrees traditional definition equivalence 
definition na equivalence 
define binary relation terms nominal signature sort respecting congruence relation satisfying atom sort occurring term indicates result replacing free occurrences theorem adequacy 
ground terms terms variables suspensions nominal signature relation definition holds provable rules fig 

furthermore provable set fa free atoms proof 
proof similar proof proposition 
non ground terms relations differ 
example holds provable disagreement expected noted preserved substitution lemma know soundness completeness 
evidence status provided natural interpretation nominal equational logic universe fm sets sound complete judgements provable rules fig :10.1.1.62.9845:10.1.1.62.9845

details appear full version 

unification terms sort nominal signature decide substitution terms variables equal sense relation introduced previous section 
instances general established modulo freshness constraints sense ask substitution freshness environment holds 
ordinary order unification solving equational problem may throw equational subproblems added complication rule abstraction fig 
equational problems may generate freshness problems ones involving relation 
led definition unification problems nominal equational logic 
definition 
unification problem nominal signature finite set atomic problems equational problem 
terms equal sort signature freshness problem 
atom term signature 
solution consists pair freshness environment substitution satisfying 

pair general solution solution substitution satisfying 
notation denotes substitution composition followed def 
theorem nominal unification 
algorithm nominal unification problem decides solution returns general solution 
proof 
describe algorithm labelled transformations directly generalising presentation order unification sect 
turn approach 
see sect 
detailed exposition labels 
types labelled transformation unification problems substitution identity single replacement freshness environment empty singleton 
legal transformations fig 

uses notation indicate disjoint union problem sets notation indicate problem resulting applying substitution terms occurring problem unification problem algorithm proceeds phases 
phase applies transformations possible non deterministically 
results problem containing equational subproblems proceeds second phase halts signalling failure 
second phase applies transformations possible non deterministically 
result empty problem halts signalling failure constructed transformation sequence form unit 
pair 
function symbol 
abstraction 
abstraction 






provided atom 
suspension 

ds variable 

provided occur unit 
pair 
function symbol 
abstraction 
abstraction 
atom 
suspension 
contain equational subproblems algorithm returns solution 
hard devise founded ordering nominal unification problems show phase algorithm terminate 
just show algorithm fails solution algorithm succeeds solution produces general solution 
failure happens certain subproblems manifestly solution example phase 


occurring second phase 

part consequence properties transformations write set solutions problem 



provided provided 
labelled transformations 

part shows 
fact gets sequence exists def 
furthermore get solution satisfies general solution 
example 
function symbols nominal signature example represent terms quiz translates unification problems signature distinct atoms sort vid 
distinct variables sort exp def fn fn app vr 
fn fn app vr def fn fn app vr 
fn fn app vr def fn fn app vr 
fn fn app vr def fn fn app vr 
fn fn app vr 
applying nominal unification algorithm described find solution general solution vr vr general solution fn app vr 
fn app vr 
fn app vr abstraction app vr 
app vr 
fn app vr abstraction 
vr vr 

fn app vr pair vr vr 
vr 
fn app vr vr variable 

fn app vr vr function symbol fail fn app vr 
fn app vr abstraction app vr 
app vr 
app vr abstraction 


app vr function symbol 

app vr atom 
app vr variable 
vr function symbol 

function symbol 
atom suspension general solution 
derivations sketched fig 

adequacy theorem interpret solutions statements terms mentioned quiz 
quiz answers 
term making pair terms equivalent 

solution second problem take 
third problem take term long take result swapping occurrences 

problem take term contain free occurrences long take result swapping occurrences equivalently free result replacing free occurrences atoms variables 
nominal unification unifies variables unify atoms 
operation identifying atoms renaming necessarily preserve validity judgements fig 

example holds renaming judgement get hold long 
example derivations referring definition see allow variables ranging sorts atoms variables unified variables 
variable appear abstraction position just specifically restricted abstraction range atoms arbitrary terms atom sort 
restriction necessary obtain single general solutions nominal unification problems 
restriction rule abstraction fig 
allow variables appear left hand side freshness relations suspended permutations 
get unification problems 
variables atom sort incomparable solutions 

related previous unification languages binders forms higher order unification solving equations terms modulo equivalence capture avoiding substitution terms function variables 
notable miller higher order pattern unification logic programming language 
kind unification retains properties order unification linear time decision procedure existence general unifiers 
imposes restriction form terms unified function variables may applied distinct bound variables 
empirical study michaylov pfenning suggests unifications arising dynamically higher order logic programming satisfy miller restriction rules useful programming idioms 
main disadvantage common approaches higher order syntax directly express common idiom possibly capturing substitution terms metavariables 
replace metavariables function variables applied distinct lists bound variables 
xn capture avoiding substitution 
requires conversion defined operation terms wants unify weak form conversion necessary miller calls conversion variable 
requirement annoying languages calculus reduction primitive notion 
manages add possibly capturing substitution language miller 
achieved adding syntax explicit renaming operations recording implicit dependencies variables names typing context 
mathematical foundation system model binding syntax fiore 
mathematical foundation appeared concurrently sense complementary :10.1.1.38.9383:10.1.1.38.9383
system typing context restricts terms may substituted variable giving finite set names contain free names term give finite set names term free variables avoid 
conversion phrased terms avoidance freshness names approach natural wants compute equivalences concretely 
top name permutations arbitrary renaming functions leads technical simplifications 
case bottom line system complicated possess general unifiers 

proposed solution problem finding possibly capturing substitutions unify terms involving binders conversion 
considered sorted order term language distinguished collections constants called atoms atom abstraction operations binding atoms terms 
provides simple flexible framework specifying binding operations scopes bound entities explicitly named 
variables prefixed suspended atom permutations substitution terms variables allow capture atoms binders respect equivalence renaming bound atoms 
definition equivalence term language auxiliary freshness relation atoms terms generalises free atom relation ground terms terms variables furthermore variables stand unknown terms unknown free atoms necessary hypotheses freshness atoms variables judgements term equivalence freshness 
reliance freshness main novelty arises reported :10.1.1.62.9845:10.1.1.11.7844
leads new notion unification problem instances equivalence freshness solved giving term substitutions possibly freshness conditions variables solution 
showed unification problem decidable unitary 
currently investigating extent nominal unification resolution proof search form order logic programming languages binders view providing better structural operational semantics 
logic programming language permit concrete nominal approach bound entities programs ensuring computation case computation answers queries respects equivalence terms 
similar facilities functional programming exist freshml language built foundations see www freshml org interested special case nominal matching application term rewriting modulo equivalence 
applications show nominal unification practically useful important study complexity 
presentation term language section algorithm section chosen clarity efficiency 
terms canonical form suspended pushed term far possible meet variables solve unification problems efficiently probably just push constructor pairing function symbol application atom abstraction order proceed step decomposition 
similarly organised algorithm phases equation solving followed order proof correctness easier see www cl cam ac uk cu unification isabelle proof scripts results solve freshness problems eagerly 
case remains investigated swapping freshness computations added ordinary firstorder unification result greater linear time complexity 
gilles dowek roy dyckhoff dale miller helmut schwichtenberg inspiration comments andy gordon term nominal 
research supported uk epsrc gr urban gr pitts gabbay 
baader nipkow 
term rewriting 
cambridge university press 
barendregt 
lambda calculus syntax semantics 
north holland revised edition 
cardelli 
spatial logic concurrency part ii 
jan car ret ku editors concur concurrency theory th international conference brno czech republic august 
proceedings volume lecture notes computer science pages 
springer verlag berlin 
cardelli gardner ghelli 
manipulating trees hidden labels 
submitted 
dowek 
higher order unification matching 
robinson voronkov editors handbook automated reasoning chapter pages 
elsevier 
dowek hardin kirchner 
higher order unification explicit substitutions 
tenth annual symposium logic computer science pages 
ieee computer society press washington 
fiore plotkin turi 
syntax variable binding 
th annual symposium logic computer science pages 
ieee computer society press washington 
gabbay pitts 
new approach syntax involving binders 
th annual symposium logic computer science pages 
ieee computer society press washington 
gabbay pitts :10.1.1.62.9845
new approach syntax variable binding 
formal aspects computing 
gordon 
nominal calculi security mobility 
volpano irvine smith editors darpa workshop foundations secure mobile code pages naval postgraduate school monterey 
gunter 
semantics programming languages structures techniques 
foundations computing 
mit press 

logic programming language binding algebras 
kobayashi pierce editors theoretical aspects computer software th international symposium tacs sendai japan october proceedings volume lecture notes computer science pages 
springer verlag berlin 

simple unification terms context holes 
ringeissen verma editors th international workshop unification unif 
unpublished proceedings 
hashimoto ohori 
typed context calculus 
theoretical computer science 
honsell miculan 
axiomatic approach metareasoning nominal algebras hoas 
orejas spirakis leeuwen editors th international colloquium automata languages programming icalp crete greece july 
proceedings volume lecture notes computer science pages 
springer verlag heidelberg 
klop 
term rewriting systems 
abramsky gabbay maibaum editors handbook logic computer science volume pages 
oxford university press 
martelli montanari 
efficient unification algorithm 
acm trans 
programming languages systems 
michaylov pfenning 
empirical study runtime behaviour higher order logic programs 
miller editor proc 
workshop prolog programming language pages 
university pennsylvania 
cis technical report ms cis 
miller 
logic programming language function variables simple unification 
journal logic computation 
milner parrow walker 
calculus mobile processes parts ii 
information computation 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
paulson 
isabelle manual 
isabelle tum de doc ref pdf 
pfenning elliott 
higher order syntax 
proc 
acm sigplan conference programming language design implementation pages 
acm press 
pitts 
nominal logic order theory names binding 
kobayashi pierce editors theoretical aspects computer software th international symposium tacs sendai japan october 
proceedings volume lecture notes computer science pages 
springer verlag berlin 
pitts gabbay 
metalanguage programming bound names modulo renaming 
backhouse oliveira editors mathematics program construction 
th international conference mpc ponte de lima portugal july 
proceedings volume lecture notes computer science pages 
springer verlag heidelberg 
plotkin 
illative theory relations 
cooper perry editors situation theory applications volume volume csli notes pages 
stanford university 
sato sakurai kameyama 
simply typed context calculus class environments 
journal functional logic programming 
