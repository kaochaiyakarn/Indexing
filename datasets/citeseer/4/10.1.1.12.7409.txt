data exchange getting core ronald fagin ibm almaden research center fagin almaden ibm com data exchange problem data structured source schema creating instance target schema reflects source data accurately possible 
source instance may solutions data exchange problem target instances satisfy constraints data exchange problem 
earlier identified special class solutions call universal 
universal solution homomorphisms possible solution general possible solution 
source instance may universal solutions 
naturally raises question best universal solution best solution data exchange 
answer question considering known notion core structure notion studied graph theory played role conjunctive query processing 
core structure smallest substructure homomorphic image structure 
universal solutions core isomorphism show core universal solution smallest universal solution 
uniqueness core universal solution minimality core ideal solution data exchange 
furthermore show core best universal solutions answering unions conjunctive queries inequalities 
investigate computational complexity producing core 
known re sults chandra merlin imply popa ibm almaden research center almaden ibm com polynomial time algorithm structure input returns core structure output 
contrast context data exchange identify natural fairly broad conditions polynomial time algorithms computing core universal solution 
analyze computational complexity decision problem underlies computation cores graphs core earlier results imply problem np hard conp hard 
pinpoint exact complexity establishing dp complete problem 
partially supported nsf iis 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pods june san diego ca 
copyright acm 
kolaitis uc santa cruz kolaitis cse ucsc edu 
summary results data exchange problem data exchange problem materializing instance adheres target schema instance source schema specification relationship source schema target schema 
problem arises tasks requiring data transferred independent applications necessarily adhere data format schema 
importance data exchange recognized long time ago fact early data exchange system express main functionality convert data hierarchical schemas 
need data exchange steadily increased years pronounced years proliferation web data various formats emergence business applications need communicate data remain autonomous 
data exchange problem related data integration problem sense problems concerned management data stored heterogeneous formats 
problems different reasons 
data exchange main focus materializing target instance reflects source data accurately possible serious challenge due inherent underspecification relationship source target 
contrast target instance need materialized data integration main focus answering queries posed target schema views express relationship target source schemas 
previous formalized data exchange problem embarked depth investigation foundational algorithmic issues surround 
motivated practical considerations arising ongoing development clio prototype system schema mapping data exchange autonomous applications :10.1.1.19.6308
data exchange setting quadruple source schema target schema set source target dependencies express relationship set dependencies express constraints setting gives rise data exchange problem instance source schema find instance target schema satisfy source target dependencies satisfies target dependencies instance called solution data exchange setting 
general different solutions instance may exist 
question solution choose materialize reflects source data accurately possible 
solution efficiently computed 
investigated issues data exchange settings relational schemas set tuple generating dependencies tgds set tgds equality generating dependencies egds isolated class solutions called universal solutions possessing properties justify selecting semantics data exchange problem 
specifically universal solutions homomorphisms possible solution particular homomorphisms equivalent 
universal solutions general solutions precise sense represent entire space solutions 
shall explain shortly universal solutions compute certain answers queries unions conjunctive queries target schema 
set certain certain answers query target schema respect source instance consists tuples intersection varies solutions denotes result evaluating 
notion certain answers originated context incomplete databases see survey 
certain answers query answering data integration 
data integration context abiteboul duschka studied complexity computing certain answers 
showed certain answers unions conjunctive queries obtained simply evaluating queries arbitrarily chosen universal solution 
showed fairly general practical conditions universal solution exists solution exists 
furthermore showed conditions satisfied polynomial time algorithm computing canonical universal solution algorithm classical chase procedure 
data exchange cores equivalent universal solutions need unique 
words data exchange setting may universal solutions source instance natural ask universal solution better universal solution 
best universal solution course best really mean 
best universal solution efficiently computed 
addresses questions offers answers minimality key criterion constitutes best universal solution 
universal solutions come different sizes share unique isomorphism common part core viewed relational structures 
definition core structure smallest substructure homomorphic image structure 
concept core originated graph theory number results properties established see instance 
early days database theory chandra merlin realized core structure useful conjunctive query processing 
evaluating joins expensive basic relational algebra operations fundamental problems query processing join minimization problem conjunctive query find equivalent conjunctive query involving smallest possible number joins 
turn problem amounts computing core relational instance obtained putting fact conjunct see 
consider data exchange setting set tgds set tgds egds 
universal solutions source instance equivalent easy see cores isomorphic 
show core universal solution solution follows core universal solutions smallest universal solution ideal candidate best universal solution terms space required materialize 
justify selection core best universal solution establishing usefulness answering queries target schema core universal solutions source instance discussed earlier universal solution certain answers conjunctive queries obtained simply evaluating shown simple conjunctive queries inequalities evaluating universal solu tion produces proper superset set certain answers show evaluating conjunctive queries inequalities core universal solutions yields best approximation smallest superset set certain answers universal solutions 
show union conjunctive queries inequalities set tuples entries elements source instance equal intersection varies universal solutions having established preceding properties core data exchange address issue hard compute core universal solution 
chandra merlin showed join minimization np hard problem pointing graph colorable element clique core disjoint sum follows polynomial time algo rithm structure input outputs core 
sight result casts doubts tractability computing core universal solution 
data exchange give natural fairly broad conditions polynomial time algorithms computing cores universal solutions 
specifically show polynomial time algorithm computing core data exchange setting arbitrary set tgds empty target constraints 
extend result showing holds arbitrary set egds 
conjecture polynomial time algorithm computing core broader data exchange settings may contain tgds leave open problem 
analyze computational complexity decision problem called core identification underlies computation cores graphs core seen results chandra merlin imply problem np hard 
hell ne set ril showed deciding graph core conp complete problem turn implies core identification conp hard problem 
pinpoint exact computational complexity core identification showing dp complete problem dp class decision problems written intersection np problem conp problem 

preliminaries section reviews main definitions related data exchange needed results 
presenting necessary definitions follow closely earlier 
data exchange problem schema finite sequence relation sym fixed arity 
instance schema sequence associates relation symbol arity shall abuse relation notation denote relation symbol relation interprets 
may refer relation tuple occurring relation denote association call fact 
schema dependency sentence logical formalism schemas relation symbols common 
refer source schema source relation symbols 
refer target schema target relation symbols 
denote schema instances called source instances instances called target instances 
source instance target instance write instance schema source target dependency general dependency form free variables logical formalism formula free variables logical formal ism logical formalisms may different 
notation vector variables target dependency general dependency target schema formalism express target dependency may different source target dependencies 
source schema may dependencies assume satisfied source instance 
source dependencies may play important role deriving source target dependencies play direct role data exchange take source instance :10.1.1.19.6308
definition 
data exchange setting consists source schema target schema set target dependencies set target dependencies 
data exchange problem associated setting finite source instance find finite target instance satisfies satisfies called solution simply solution source instance understood context 
practical purposes results proposition source target dependency tuple generating dependency tgd form conjunction atomic formulas conjunction atomic formulas target dependency tgd form equality generating dependency egd form dependencies conjunctions atomic formulas variables drop universal quantifiers front dependency implicitly assume quantification 
write existential quantifiers 
source target tgds natural powerful language expressing relationship source schema target schema 
dependencies automatically derived representation schema mapping clio system 
furthermore data exchange settings tgds source target dependencies include special cases lav gav data integration systems views sound defined conjunctive queries see lenzerini tutorial detailed discussion lav gav data integration systems sound views 
lav data integration system sound views defined conjunctive queries special case data exchange setting source schema consisting views lav terminology target schema global schema lav terminology set target dependencies empty source target tgd form single relation symbol source schema view lav terminology conjunction atomic formulas target schema gav setting similar tgds form single relation symbol target schema view gav terminology conjunction atomic formulas source schema general source target tgd relates conjunctive query source schema conjunctive query target schema data exchange setting strictly expressive lav gav fact thought glav global local view system 
similarities data integration data exchange notwithstanding main difference data exchange materialize finite target instance best reflects source instance 
data integration exchange data required target remain virtual 
general may multiple solutions data exchange problem 
example illustrates issue raises question solution choose materialize 
example 
consider data exchange problem source schema relation symbols attributes target schema relation symbol attributes assume source target tgds source instance tgds completely specify target instance multiple solutions consistent specification 
solution represent unknown values values occur source instance 
values called labeled nulls distinguished values occuring source instance called constants 
instances constants labeled nulls specific data exchange 
long considered various forms context incomplete indefinite databases see context data integration see 
current example instances solutions labeled nulls 
note labeled nulls uses constants witness existentially quantified variables tgds 
review notion universal solutions proposed general solutions 
universal solutions denote const set possibly infinite values occur source instances call constants 
assume infinite set var values called labeled nulls var const reserve symbols instances source schema values const 
reserve symbols instances target schema values const var 
require solutions data exchange problem values drawn const var 
schema instance values const var const denotes set constants occurring relations var denotes set labeled nulls occurring relations definition 
instances values const var 
const const var var const 
homomorphism mapping fact fact 
equivalent homomorphisms 
definition universal solution 
consider data exchange setting source instance universal solution solution solution exists homomorphism example 
solutions example universal 
particular homomorphism homomorphism solutions contain extra information required specification 
contrast easily shown homomorphisms solution 
universal 
universal solutions possess properties justify selecting opposed arbitrary solutions semantics data exchange problem 
universal solution general arbitrary solution definition mapped solution 
universal solutions definition homomorphisms equivalent 
computing universal solutions addressed question check existence universal solution compute exists 
particular identified fairly general practical conditions guarantee universal solutions exist solutions exist 
showed polynomial time algorithm computing canonical universal solution solution exists algorithm classical chase procedure 
result summarizes findings 
theorem 
assume data exchange setting set tgds union weakly acyclic set tgds set egds 

existence solution checked polynomial time 

universal solution exists solution exists 

solution exists universal solution produced polynomial time chase 
notion weakly acyclic set tgds arose conversation third author deutsch 
independently term constraints stratified witness 
class guarantees termination chase quite broad includes sets full tgds sets acyclic inclusion dependencies 
note set target constraints empty universal solution exists canonical constructible polynomial time chasing example instance canonical universal solution 
set target constraints contains egds possible universal solution exists solution exists theorem 
occurs see chase fails attempting identify constants trying apply egd chase fail result chasing canonical universal solution 
certain answers universal solutions data exchange setting may possible solutions target instance 
question result answering queries target schema 
data integration adopted notion certain answers semantics query answering 
recall set certain certain answers respect source instance set tuples appear solution arbitrary solution denote set null free tuples set tuples formed entirely constants 
proposition shows null free evaluation conjunctive queries arbitrarily chosen universal solution gives precisely set certain answers 
universal solutions solutions property 
proposition 
consider data exchange setting source schema target schema dependencies sets arbitrary 

union conjunctive queries target schema source instance universal solution certain 
source instance solution conjunctive query certain universal solution 

multiple universal solutions give simple example showing restrict attention universal solutions arbitrary solutions may multiple non isomorphic universal solutions data exchange problem 
universal solutions equivalent different sizes 
example shows evaluating conjunctive queries inequalities universal solutions may produce certain answers 
contrast proposition deals case unions conjunctive queries 
example 
consider data exchange problem source schema relation symbol attributes target schema relation symbol attributes source target tgds assume source instance instances universal solutions labeled nulls 
easy verify universal 
size perspective smaller shown universal solution contain tuple form null smallest size universal solutions 
argue data exchange 
proposition queries unions conjunctive queries give answers certain answers applied solutions universal 
consider conjunctive query inequality returns evaluated returns empty set evaluated particular shows certain answer query evaluation universal solution case may strict superset set certain answers empty set example 
hand coincides set certain answers 
general exact equality set certain answers may possible smallest universal solution obtain best approximation shall prove section 
justification selecting intuition define study section cores universal solutions 
prove general cores universal solutions enjoy properties 
specifically smallest universal solutions provide best approximation set certain answers universal solutions 
combined fact universal solution isomorphism shall prove gives strong justification core universal solutions data exchange 

data exchange cores semantics query answering cores universal solutions find convenient define instance defined earlier closely related notion structure 
difference structure defined universe universe instance implicitly taken active domain set elements appear tuples instance 
furthermore target instances data exchange settings structures necessarily distinguished elements constants mapped homomorphisms 
formally structure schema sequence non empty set called universe associates relation symbol relation arity instances shall abuse notation denote relation symbol relation interprets 
may refer nite 
structure substructure say proper substructure substructure containments proper 
relation finite say structure fi definition 
substructure structure called core homomorphism homomorphism proper substructure structure called core core homomorphism proper substructure note core core substructure homomorphism concept core graph studied extensively graph theory see 
proposition summarizes basic facts cores proof 
proposition 
statements hold finite structure core cores finite structure isomorphic 
finite structure equivalent core 
consequently finite structures equivalent cores isomorphic 
core finite structure homo morphism universe member view proposition finite structure unique isomorphism core denote core similarly define notions subinstance instance core instance 
identify instance corresponding structure universe structure taken active domain instance distinguish constants universe 
require homo morphism constant section 
results cores structures carry cores instances 
defined seen earlier universal solutions unique homomorphic equivalence need unique isomorphism 
proposition implies cores isomorphic words universal solutions core isomorphism 
core solution universal solution core equivalent 
general dependencies arbitrary core solution instance data exchange problem need solution 
result shows happen set tgds union set tgds set egds 
proposition 
data exchange setting set tgds union set tgds set egds 
source instance solution core solution consequently universal solution core universal solution proof tgd tuple constants solution tuple elements homomorphism constant core consequently core core satisfies tgd 
tgd core core core tuple elements subinstance solution follows tuple part core core sition homomorphism particular core core follows satisfies tgd 
egd elements tuple elements core core core subinstance solution follows core satisfies egd corollary 
data exchange setting set tgds union set tgds set egds 
source instance universal solution exists unique isomorphism universal solution having properties core isomorphic core universal solution universal solution homo morphism sizes refer core universal solutions 
simple illustration concepts discussed subsection recall data exchange problem example 
core universal solutions query answering cores corollary reveals addition unique core universal solutions smallest universal solution compact universal solution materialize 
follows show core query answering clear advantages universal solutions purpose 
union conjunctive queries target certain schema universal solution 
suppose conjunctive query inequalities target schema 
general universal solution may properly contain certain fact proper containment may hold core universal solutions 
proposition shows equals intersection choices varies universal solutions 
consequently unions conjunctive queries inequalities query evaluation core universal solutions provides best approximation universal solutions set certain answers 
proposition says property characterizes core universal solutions 
proposition 
data exchange setting set tgds union set tgds set egds 
source instance universal solution exists core universal solutions 
union conjunctive queries inequalities certain target schema universal solution 
universal solution conjunctive query inequalities target schema universal solution isomorphic core universal solutions 
proof known easy see conjunctive queries inequalities preserved homomorphisms 
homomorphism ary conjunctive query inequalities universal solution play role respectively homomorphism core corollary 
follows ary conjunctive query inequalities target schema tuple constants identity constants recall homomorphism 
universal show reverse inclusion 
define renaming null way nulls common 
universal easy see second part assume universal solution union conjunctive queries inequalities target schema universal solution particular canonical conjunctive query inequalities associated boolean conjunctive query inequalities asserts exist distinct elements number elements describes tuples occur relations target schema clear true implies true 
turn true implies homomorphism time homomorphism corollary 
null free evaluation union conjunctive queries inequalities core universal solutions gives precisely set tuples guaranteed appear output universal solution difference set universal solution set certain isomorphic certain answers intersection solutions just universal solutions argued universal solutions preferred solutions data exchange problem 
corollary suggests introduce alternative notion certain answers universal solutions 
case evaluating core gives precisely set certain answers alternative notion 
having established properties core universal solutions address problem computing 
mentioned earlier universal solutions canonically computed chase 
result chase universal solution need core 
section established known different chase sequences may yield non isomorphic results universal solutions results chase core 
sections study takes compute core 

complexity core identification chandra merlin realize computing core relational structure important problem conjunctive query processing optimization 
unfortunately full generality problem intractable 
note computing core function problem decision problem 
way gauge difficulty function problem analyze computational complexity underlying decision problem 
definition 
core identification de core cision problem structures schema substructure easy see core identification np hard problem 
consider polynomial time reduction colorability graph colorable complete graph nodes disjoint sum operation graphs 
reduction chandra merlin 
hell ne set ril studied complexity recognizing graph core 
precise terms core recognition decision problem structure schema core 
clearly problem conp 
main result hell ne set ril asserts core recognition conp complete problem inputs undirected graphs 
established exhibiting sophisticated polynomialtime reduction non colorability graphs girth gadgets reduction pairwise incomparable cores certain additional properties 
follows core identification conp hard problem 
appears exact complexity core identification 
sequel establish core identification dp complete problem 
background material complexity class dp 
core class dp consists decision problems written intersection np problem conp problem equivalently dp consists decision problems written difference np problems 
class introduced papadimitriou yannakakis discovered dp complete problems 
prototypical dp complete problem sat unsat boolean formulas satisfiable unsatisfiable 
problems express critical property turn dp complete see 
instance critical sat dp complete instance problem cnf formula question determine unsatisfiable clauses removed resulting formula satisfiable 
cosmadakis showed certain problems related database query evaluation dp complete 
note dp contains np conp subclasses furthermore dp complete problem np hard conp hard 
prevailing belief computational complexity containments proper proving remains outstanding open problem 
case establishing certain problem dp complete interpreted signifying problem intractable fact intractable npcomplete problem 
establish core identification dp complete problem exhibiting reduction colorability non colorability graphs girth reduction directly inspired reduction non colorability graphs girth core recognition 
theorem 
core identification dp complete inputs undirected graphs 
proving theorem essential result special case theorem 
recall girth graph length shortest cycle graph 
theorem 
positive integer sequence connected graphs 
colorable girth edge cycle 
core homomorphism 
nodes 
polynomial time algorithm constructs sequence machinery needed prove theorem 
proof theorem core identification dp structures schema substructure determine core check homomorphism np core conp 
show core identification dp hard inputs undirected graphs polynomial time reduction colorability non colorability 
stepping stone reduction define core homomorphism variant core identification structures homomorphism core 
simple polynomial time reduction core homomorphism core identification instance mapped reduction homomorphism core core polynomial time reduction colorability non colorability core homomorphism 
remains show hell ne set ril showed colorability np complete input graphs girth follows colorability non theorem self loop 
colorability input graphs girth assume graphs having girth enumeration nodes enumeration nodes having properties listed theorem 
sequence sequence connected graphs constructed time polynomial assume graphs pairwise disjoint sets nodes 
graph obtained identifying node arbitrarily chosen node keeping edges nodes intact 
nodes nodes appear edges edges edges identification 
similarly graph obtained identifying node arbitrarily chosen node keeping edges nodes intact 
claim colorable colorable homomorphism core 
hell ne set ril showed core recognition conp complete showing graph girth colorable graph core 
property order establish claim 
assume colorable colorable 
colorable graph colorable homomorphism fact 
shown core colorable 
direction assume homomorphism core 
results infer colorable 
remains prove colorable 
homomorphism claim maps colorable 
consider image graph homomorphism observe mapped image cycle homomorphism cycle length equal length girth homomorphism observe edge cycle image contained reason image contain nodes different maps contain nodes fact girth 
consequently homomorphism map colorable 
consider implications intractability core recognition problem computing core structure 
stated earlier chandra merlin observed graph colorable core fol lows polynomial time algorithm computing core structure 
algorithm existed determine polynomial time graph colorable running algorithm compute core checking answer equal note data exchange interested computing core universal solution core arbitrary instance 
consequently assume priori intractability carries data exchange setting polynomial time algorithms computing core universal solutions may exist 
address 

computing core data exchange contrast case computing core arbitrary instance computing core universal solution data exchange polynomial time algorithms certain natural data exchange settings 
section gives polynomial time algorithm computing core universal solution data exchange set ting target constraints section essentially algorithm works proof quite bit complicated remove emptiness condition allow contain egds 

show polynomial time case target constraints define notions needed order state algorithm prove correctness polynomial time bound 
definitions assume arbitrary instance elements consists constants const nulls var 
say elements adjacent exists tuple relation elements occur 
definition 
gaifman graph nulls undirected graph nodes nulls exists edge nulls nulls adjacent block nulls set nulls connected component gaifman graph nulls 
null may refer block nulls contains block note definition blocks set var nulls partitioned disjoint blocks 
instances elements const var 
recall subinstance tuple relation tuple corresponding relation definition 
homomorphism denote result applying subinstance call endomorphism endomorphism useful proper subinstance 
lemma simple characterization useful endomorphisms proving main results subsection subsection 
lemma 
instance endomorphism useful 
proof assume 
domain range fact instance finite 
tuple containing useful 
assume 
simply renaming members isomorphism number tuples subinstance fact instance finite 
useful 
follows rest subsection assume data exchange setting source instance assume canonical universal solution data exchange problem 
result chasing goal compute core en subinstance proper subinstance property condition equivalent endomorphism proper subinstance 
central idea algorithm shall see show mentioned endomorphism composition polynomial length sequence local small endomorphisms polynomial time 
define local means 
definition 
instances nulls form subset nulls var var endomorphism block nulls say local 
nulls nulls sense consider null belongs block say local local block lemma crucial existence polynomial time algorithm computing core universal solution 
lemma 
assume data exchange setting set tgds subinstance canonical universal solution exists useful endomorphism exists useful local endomorphism proof useful endomorphism lemma know 
null appears appear block 
define letting 
show endomorphism tuple relation show tuple relation subinstance tuple tuple relation definition block nulls block cases depending assume definition null constant 
endomorphism know tuple relation tuple relation assume tuple relation desired 
endomorphism algorithm computing core universal solutions algorithm 
core algorithm input source instance output core universal solutions 
compute canonical universal solution chasing 
compute blocks initialize 
check exists useful local endomorphism result 
update return step 
order prove upper bound execution time algorithm need introduce parameters 
parameter denoted maximal number existentially quantified variables tgds fixed quantity constant 
follows easily construction canonical universal solution chasing upper bound size block second parameter denoted maximum number elements number tuples canonical universal solution theorem 
assume data exchange setting set tgds algorithm correct polynomialtime algorithm computing core universal solutions 
proof show algorithm correct final instance algorithm core universal solution 
time apply step algorithm replacing instance homomorphic image 
final instance result applying composition homomorphisms input instance homomorphic image canonical universal solution homomorphisms step endomorphism subinstance assume core shall derive contradiction 
core endomorphism applied resulting instance proper subinstance useful endomorphism lemma exist useful local endomorphism algorithm stopped step desired contradiction 
core show algorithm runs polynomial time 
recall parameters introduced earlier upper bound size block maximum total number elements total number tuples instance execution step 
block check useful endomorphism local exhaustively check possible functions domain functions 
check function useful endomorphism requires time blocks time determine block useful local endomorphism updating time step lemma step executed null 
initially nulls instance follows number loops algorithm performs running time algorithm step step executed number loops times step step take polynomial time follows entire algorithm executes polynomial time 
crucial observation polynomial time bound total number endomorphisms algorithm explores step block strong contrast case minimizing arbitrary instances constants nulls may need explore larger number endomorphisms general minimization step 
target constraints subsection extend theorem showing polynomial time algorithm finding core set egds 
know extend allow tgds full tgds interesting open problem 
assume data exchange setting set egds 
source instance denote instance target schema result chasing note canonical universal solution case replace data exchange setting reason call canonical pre universal instance 
denote instance target schema result chasing set egds 
canonical universal solution data exchange setting source instance 
goal compute core subinstance endomorphism property 
case central idea algorithm show mentioned endomorphism composition polynomial length sequence small endomorphisms polynomial time 
case small mean local 
precise lemma 
lemma crucial existence polynomial time algorithm core computing non trivial generalization lemma 
proper subinstance lemma 
assume data exchange setting set tgds set egds 
canonical pre universal instance image canonical universal solution exists useful endomorphism exists useful local endomorphism proof lemma requires additional definitions additional lemmas 
start required definitions 
canonical pre universal instance canonical universal solution produced chasing set egds 
define directed graph nodes members nulls constants 
chase process null gets replaced null constant edge graph 
reflexive transitive closure graph 
easy see reflexive partial order 
node define maximal result chase 
clear member form clear constant write intuitively means node intuitively eventually gets replaced eventually collapse element result chase 
definition 
instance elements con nulls 
element say rigid homomorphism 
particular constants occuring rigid 
key step proof lemma surprising result says nulls different blocks collapse element result chase rigid endomorphism lemma rigidity lemma 
assume data exchange setting set tgds set egds 
canonical pre universal instance result chasing set egds 
nulls non rigid null block proof assume nulls different blocks show rigid dia gram instance conjunction expressions tuple relation 
treating members constants nulls variables 
egd follows chase sets variables equal logically forced result appears papers characterize implication problem dependencies see instance 
satisfies follows satisfies wish show rigid homomorphism show block assignment variables obtained letting 
show valid assignment conjunct necessarily tuple relation conjunct tuple construction chase know relation tuple relation cases depending tuple relation desired 
null constant tuple relation 
null constant third equality holds homomorphism constant 
cases tuple relation homomorphism know tuple relation tuple relation desired 
valid assignment satisfies follows different block 
desired 
shows contrapositive lemma says nulls different blocks set equal transitively chase rigid lemma 
endomorphism rigid element rigid element proof rigid element element element rigidity 
homomorphism show homomorphism composition homomorphisms homomorphism 
rigidity follows desired 
ready give proof lemma minimization algorithm subsection 
proof lemma endomorphism useful endomorphism lemma null appears appear block contains define letting 
shall show useful local endomorphism show endomorphism tuple relation show tuple relation show non rigid null block non rigid nulls show block tuple relation subinstance know tuple relation construction chase know tuple relation non rigid nulls follows lemma non rigid nulls constant constant 
lemma block similarly non rigid null 
similarly non rigid follows block block desired 
cases depending assume non rigid rigid including nulls constants showed tuple relation know tuple relation tuple relation homomorphism desired 
assume non rigid showed non rigid rigid tuple relation desired 
endomorphism definition local 
show useful 
appears lemma tells need show range contain range include range contain useful 
useful local endomorphism algorithm computing core set egds 
mentioned earlier target constraints include egds may possible solutions universal solutions 
case detected algorithm failure returned 
algorithm 
egd core algorithm input source instance output core universal solutions solutions exist failure 

compute canonical pre universal instance chasing 
compute blocks chase produce canonical universal solution chase fails failure 
initialize 
check exists useful local endomorphism result 
update return step 
theorem 
assume data exchange setting set tgds set egds 
algorithm correct polynomial time algorithm computing core universal solutions 
proof proof essentially theorem lemma lemma 
fact chasing egds step polynomial time procedure 
note essential polynomial time upper bound endomorphisms explored algorithm local merely local 
argued earlier case blocks bounded size constant maximal number existentially quantified variables tgds true general blocks chase egds obtain may generate blocks unbounded size 
intuitively egd equates nulls different blocks creates new larger block union blocks 
open problems previous argued universal solutions best solutions data exchange setting general possible solutions 
unfortunately may universal solutions 
pick particular universal solution core arbitrary universal solution argue best universal solution best best 
core unique isomorphism universal solution smallest size fewest tuples 
core gives best answer universal solutions queries union conjunctive queries inequalities 
best answer mean core provides best approximation universal solutions set certain answers 
fact redefine set certain answers occur universal solution core gives exact answer 
consider question complexity computing core 
show complexity deciding graph core graph dp complete 
np polynomial time algorithm producing core arbitrary structure 
hand case interest data exchange give natural conditions polynomialtime algorithms computing core universal solutions 
believe opens door number fascinating questions 
questions performance core query answering 
core perform answering queries general unions conjunctive queries inequalities 
second questions complexity constructing core 
case prove polynomial time algorithm computing core set target constraints contains egds exponent may somewhat large 
efficient algorithm computing core case 
question extending polynomial time result generally 
polynomialtime algorithm computing core consists full tgds 
general data exchange setting contains arbitrary set egds necessarily full tgds 
slightly different note similarities problems interesting see techniques minimizing universal solutions applied problem minimizing chase generated universal plans arise comprehensive query optimization method introduced 
reported addresses data exchange relational schemas 
hope investigate extent results extended general case xml nested data exchange 
acknowledgments 
ren miller val tannen moshe vardi helpful suggestions 

abiteboul duschka 
complexity answering queries materialized views 
pods pages 
abiteboul hull vianu 
foundations databases 
addison wesley 
beeri vardi 
proof procedure data dependencies 
journal acm 
chandra merlin 
optimal implementation conjunctive queries relational data bases 
stoc pages 
cosmadakis 
complexity evaluating relational queries 
information control 
cosmadakis kanellakis 
functional inclusion dependencies graph theoretic approach 
advances computing research volume pages 
jai press 
deutsch popa tannen 
physical data independence constraints optimization universal plans 
vldb pages 
deutsch tannen 
reformulation xml queries constraints 
icdt pages 
fagin kolaitis miller popa 
data exchange semantics query answering 
icdt pages 
friedman levy millstein 
navigational plans data integration 
aaai pages 
halevy :10.1.1.13.2900
answering queries views survey 
vldb journal pages 
hell ne set ril 
core graph 
discrete mathematics 
kanellakis 
elements relational database theory 
handbook theoretical computer science volume formal models pages 
elsevier mit press 
lenzerini 
data integration theoretical perspective 
pods pages 
maier mendelzon sagiv 
testing implications data dependencies 
acm tods dec 
miller haas hern ndez 
schema mapping query discovery 
vldb pages 
papadimitriou yannakakis 
complexity facets facets complexity 
stoc pages 
papadimitriou 
computational complexity 
addison wesley 
popa miller hernandez fagin 
translating web data 
vldb pages 
shu taylor ghosh lum 
express data extraction processing amd restructuring system 
acm tods 
van der meyden 
logical approaches incomplete information survey 
logics databases information systems pages 
kluwer 
