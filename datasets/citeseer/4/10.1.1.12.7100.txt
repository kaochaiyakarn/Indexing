reprinted journal computer system sciences rights reserved academic press new york london vol 
october printed belgium probabilistic counting algorithms data base applications philippe flajolet inria rocquencourt le chesnay france nigel martin ibm development laboratory park hampshire jn united kingdom received june revised april introduces class probabilistic counting estimate number distinct elements large collection data typically large file stored disk single pass small additional storage typically binary words operations element scanned 
algorithms statistical observations bits hashed values records 
con struction totally insensitive structure elements file context distributed systems degradation performances prove especially useful context data bases query optimisation 
academic press 
data base systems allow user specify complex queries need arises efficient processing methods 
complex query generally evaluated different manners performance data base system depends crucially selection appropriate decomposition strategies particular case 
trivial computing intersection collections data lends number different treatments see 
sort search element retain appears 
sort sort perform merge operation determine inter section 
eliminate duplicates hashing hash filters form algorithm 
evaluation strategy cost essentially determined number records number distinct elements typical sorting methods costs copyright academic press rights reproduction form reserved 
probabilistic counting algorithms strategy log log strategy log log 
number similar situations appears apart sizes files operates number records major determinant efficiency cardinalities underlying sets number distinct elements comprise 
situation gets complex operations projections selections multiple joins combination various boolean operations appear queries 
example relational system system sophisticated query optimiser 
order perform task programme keeps statistics relations data base 
important ones sizes relations number rent elements key fields 
information determine selectivity attributes time order decide choice keys choice appropriate algorithms employed computing relational operators 
choices order minimise certain cost function depends specific cpu disk access costs sizes cardinalities relations fields 
system information periodically recomputed kept catalogues companions data base records indexes 
propose efficient algorithms estimate cardinalities multisets data commonly encountered data base practice 
trivial method consists determining card building list elements replication method advantage exact cost number disk accesses auxiliary storage log sorting higher possible gains obtain information 
method propose probabilistic nature result depends particular hashing function particular data operates 
uses minimal extra storage core provides practically useful estimates cardinalities large collections data 
accuracy inversely related storage binary words typically bits attain typical accuracy words accuracy improves 
degrade files get large bit words safely count cardinalities 
assumption records hashed suitably pseudo uniform manner 
appear severe limitation empirical studies large industrial files reveal careful implementations standard hashing techniques achieve practically uniformity hashed values 
furthermore design algorithms totally insensitive replication structures files opposed sampling techniques simplest sampling algorithm take sample size file size estimate cardinality vo sample direct algorithm return vo estimate cardinality file 
flajolet martin result elements appear times just times 
theoretical standpoint techniques constitute illustration gains may achieved situations probabilistic methods 
mention morris approximate counting algorithm maintains approximate counters expected constant relative accuracy log log bits order count morris algorithm see detailed analysis analogies may reduce factor memory size necessary store large statistics large number events com puter systems 
structure follows section describe basic counting procedure called count forms basis algorithms 
may worth noting non trivial analytic techniques enter justification design algorithms techniques developed section 
section presents actual counting algorithms count procedure probabilistic tools section 
section concludes indications contexts methods may notably employed fly context distributed processing minimal exchanges information processors degradation performances 
preliminary results reported 

probabilistic counting procedure analysis basic counting procedure assume disposal hashing function hash type function hash records scalar range 
transforms records integers sufficiently uniformly distributed scalar range equivalently set binary strings length non negative integer define bit kth bit binary tation bit 
introduce function represents position significant bit binary representation suitable convention probabilistic count ng algorithms 
ranks numbered starting zero 
observe values hash uniformly distributed pattern kl appears probability idea consists recording observations occurrence vector bitmap 

multiset cardinality sought perform operations bitmap index hash bitmap index bitmap index bitmap equal iff execution pattern form il appeared hashed values records notice construction vector bitmap depends set hashed values particular frequency values may repeat 
remarks concerning pattern probabilities expect number distinct elements bitmap accessed approximately times bitmap approximately times 
execution bitmap certainly zero og og fringe zeros ones og example took line documentation corresponding volume manual unix system installations 
consists lines distinct 
considering lines records hashing standard multiplicative hashing bits bitmap vector leftmost value zero appears position rightmost value position 
propose position leftmost zero bitmap ranks start indicator log 
quantity shall see assumption hashed values uniformly distributed expected value close og 
intuition justified 
fact correction factor plays quite important role design final algorithms propose 
shall flajolet martin prove reasonable probabilistic assumptions standard deviation close estimate typically binary order magnitude exact result fact calls elaborate algorithms developed section 
probability distributions proceed justify rigorously claims concerning distribution value parameter basic counting procedure 
probabilistic model 
denote set infinite binary strings 
model assumes bits elements uniformly independently distributed 
equivalently strings considered real numbers interval model assumes numbers uniformly distributed interval 
functions bit extended trivially 
denote random variable defined assuming independence analogue parameter ii 
introduce notations concerning probability distribution uniform model 
pr 
pr denote number ones binary representation instance 
theorem 
probability distribution characterised proof integer define events subsets probabilistic counting algorithms eo el ek kk form disjoint complete set events 
elements drawn formal polynomial eo represents set possible events sense expand taken non commutative polynomial indeterminates interpreting sums disjoint unions events products successions events monomial degree obtain complete disjoint representation interested obtaining 
expression polynomial 
represents similar fashion succession events corresponding polynomial 
formed subset noncommutative monomials appearing 
start examples 
po ko eo eo obtained case monomial corresponding situation strings drawn value 

eo take cases value value appear doing eliminated case values twice 
general polynomial indeterminates el polynomial formed monomials degree indeterminates obtained inclusion exclusion type formula ij notation means replacement general obtained applying expression 

evaluate probabilities take measures events described polynomial rules kk additivity measure disjoint sets events relation trials assumed independent 
examples find way general flajolet martin sum extends tuples integers distinct integers interval 
notice changing summation indexes ls rewritten distinct integers interval 

words shown 
inside completes proof theorem 
turn derivation asymptotic forms probabilities 
theorem 
ii distribution satisfies estimates ne log fi log iii proof approximation log tail distribution exponential main device consists repeatedly exponential probabilistic count ng algorithms inside terms form expression set case term noticing increases terms decrease find og inequality qn ne ig established 
ii case 
set log range og terms get 
denote sum appears define similarly nc 
comprise terms iq ql quantity log 
derive final expression complete sum set ko flajolet martin error term satisfies iei ns 
combining eqs 
establishes sum expression appears claim ii statement 
derive product form appeal general identity qs 
jo iii case log 
bound probabilities observing value taken pr range values considered expression order proof part iii completed 
sequel introduce real function exp jx 
theorem expresses essentially existence sort limiting distribution probability distribution gets large 
table describes values probabilities compared approximation 
shows excellent agreement approximations 
reveals tail decreases sharply decrease theorem may established 
asymptotic analysis theorem follows 
expectation oj sati es probabilistic counting algorithms table values exact probabilities approximations italics note 

problem estimating asymptotically reduces estimating sum function large purpose appeal mellin transform techniques context analysis algorithms due de bruijn see pp 
seq 
mellin transform function defined real definition complex function mir dx 
succinctly recall salient properties mellin transform referring reader precise statements 
mellin transform function defined strip complex plane determined asymptotic behaviours oo 
satisfies important functional property ax 
complex inversion formula ds chosen strip integral absolutely convergent 
flajolet martin interest inversion formula cases evaluated means residue theorem residue corresponding term asymptotic expansion lemma 
mellin transform euler gamma function entire function analytic continuation function defined re js proof 

transform re follows basic functional property fact transform exp gamma function 
similarly re get 
exponentially small transform analytic complex find analytic possibly points log denominator vanishes 
direct calculations lemma show analytic re analytic 
basic functional property valid re claim lemma 
probabilistic counting algorithms need establish constructive properties re proof lemma 
lemma 
function satisfies 
furthermore satisfies 

property terms definition may grouped find observe general term sum gets large 
confirms defined analytic 
obtain bounds split sum terms si sum isu uniformly find contribution terms isl isl uniformly say 
substituting gives 
come back asymptotic study inversion formula 
em average value parameter satisfies log tog constant oo jp pp flajolet martin periodic continuous functions period amplitude bounded lemma problem reduces obtaining asymptotic expansion oo terms 
principle consists evaluating complex integral form residues 
inversion theorem mellin trans forms oo ds 
io consider positive integer rectangle contour defined corner points traversed order fk log log log log 
residue theorem ds es ir fixed gets large integral segment log log tends 
lemma exponential decrease integrals tog log log log tend zero exponentially fast functions 
integral log log stays bounded absolute value oo rr dt oo constant 
exponential decrease guarantees con vergence integral 
letting oo re sum residues absolutely convergent decrease 
remains evaluate residues 
double pole simple poles tog integer different find easily res log log log probabilistic counting algorithms may rewrite log res form pi 
summing residues find announced asymptotic form kz gory details bound amplitude left dix 
evaluate standard deviation similar fashion 
second moment 
approximated function kl transform re triple pole 
computing done inversion theorem followed residue calculations finds theorem standard deviation log aj periodic function mean value period 
mention passing aj closed form expression og log pa fourier coefficients defined 
probabilistic counting algorithms seen previous section result count procedure average close log tpn standard deviation close 
values flajolet martin amazingly close instances show 
observation justifies hope obtaining estimates observation parameter correction factor tp 
dispersion results corresponds typical error binary order magnitude certainly high applications 
simplest idea remedy situation consists set hashing functions design parameter computing different bitmap vec tors 
way obtain estimates considers average 
distinct elements file random variable tation standard deviation satisfy og may expect provide estimate typical error measured standard deviation estimates relative value 
algorithm direct averaging provably performances expected relative error disadvantage requiring calculation number hashing functions cpu cost element scanned gets essentially multiplied factor turns effect similar straight averaging may achieved device call stochastic averaging 
idea consists hashing function order distribute record lots computing mod update corresponding bitmap vector address rest information contained div 
determine compute average 
hoping records lots may expect elements fall lot reasonable approximation re 
corresponding algorithm called probabilistic counting stochastic averaging short 
described fig 

claim cost element scanned distinguishable count procedure relative accuracy improves roughly xf 
sequel shall call standard error quotient standard deviation estimate value quantity precise indication expected relative accuracy algorithm estimating neglecting periodic fluctuations extremely small amplitude shall call bias algorithm ratio estimate exact values large standard error bias probabilistic counting algorithms program csa const nmap typically nmap corresponds variable count multiset data ol type records records index integer bitmaps ay nmap integer getelement vat reads element type file con hashes record integer scalar range returns position bit ranks start 
beg beg getelement hh nmap index div nmap index index nmap beg trunc nmap nmap result estimates 
fig 

probabilistic counting stochastic averaging 
table ii bias standard error values number bitmap vectors bias standard error flajolet martin algorithm various values design parameter displayed table ii 
remainder section going justify claims rigorously particular show estimates table ii deduced 
denote random variable computed bitmaps denote random variable distinct elements file denote average value standard deviation propose establish theorem 
estimate algorithm average value es elan npm log second moment satisfies qm log ji 
expressions pm represent periodic functions period mean value amplitude bounded theorem 
notation express property gn lu characterisations bias standard error algorithm quantities rl sati cy gets large log error terms theorem theorem uniform probabilistic counting algorithms analysis algorithm proceed proof theorem 
start estimate lemma 
setting fixed ni dq pq log dq log pq periodic function amplitude 
proof start bounds tail distribution 
consider probability pr og 
positions bitmap set event probability quantity range values 
og bound applies replaced fl sum 
consider error comes replacement asymptotic equivalent small bounds theorem finds ta og quantity 
oo flajolet martin asymptotic behaviour determined mellin transform techniques transform function 
poles log find claim lemma inversion theorem dq res 
step proof theorem establish algorithm behaves asymptotically elements perfectly distributed groups 
lemma 
elements distributed cells fixed probability element goes cell probability probability cells number elements satisfying log hg constant proof 
set number elements fall cell 
obeys binomial distribution pr pkq logarithms pn rsn finds pr pn exp log probability exponentially small 
conclude proof observing binomial distribution unimodal pr log logn 
conclude proof part theorem 
denote sum pr hi kl 
km probabilistic counting algorithms 
nl nm nl nm call quantity ec sum terms ni log lemmas ne hog 
central contribution bounded og 
equation combined lemma sufficient establish estimates theorem provided check amplitudes periodic fluctuations grow fact proved methods described appendix 
estimates second moment derived exactly way equality el 
dependence results number bitmaps conclude indication easy proof theorem 
theorem need determine asymptotic behaviour quantities og fi ln flajolet martin gets large neglect effect small periodic fluctuations 
achieved performing standard tedious asymptotic expansions large 
task carried help macsyma system symbolic computations 
find bias standard error values closely approximated formulae bias standard error 

implementation issues factors taken account applying algorithm choice hashing function 
ii choice length bitmap vectors 
iii number nmap bitmap corresponding quantity analyses 
corrections types may introduced iv corrections systematic bias table ii 
corrections initial nonlinearities algorithm 
briefly proceed discuss issues 

hashing functions 
simulations textual files see ranging size kilobytes megabyte indicate standard multiplicative hashing leads performances depart detectable way predicted uniform model sections 
record 
xp formed ascii characters hashed ord mod ord denoting standard ascii rank character agreement theoretically predicted practically observed performances accordance empirical studies concerning standard hashing techniques conducted large industrial files lum 

length bitmap vector 
probability steep distribution suffices select way log nmap 
pointed nmap possible safely count cardinalities files car probabilistic counting algorithms 
probabilities obtaining underestimates probabilistic model assumes infinite computed previous results satisfied error introduced 
number bitmaps 
expected relative accuracy algorithm standard error theorems inversely proportional closely approximated nmap leads standard error nmap error decreases see table ii 

bias 
bias algorithm table ii negligible compared standard error soon nmap exceeds 
smaller values nmap corrected results theorems 
practical algorithm suffices estimates theorem achieves changing instruction programme trunc nmap nmap nmap 
doing obtain algorithm apart small periodic fluctuations amplitude asymptotically unbiased estimator car 
initial non linearities 
asymptotic estimates form basis algorithm extremely close actual average values soon nmap exceeds 
small cardinalities estimated characterisation probability distributions corrections computed introduced algorithm 
corrections calculation exact average values formulae asymptotic estimates 
simulations conducted fairly extensive simulations algorithm applied textual data 
files called man man man correspond chapters online available systems versions man correspond files obtained preceding ones segmentation character blocks 
standard multiplicative hashing described eq 

counted case number different records compared corresponding values estimated algorithm record line text man letter block man 
sample runs reported table iii show agreement estimates values 
files mixtures text english names commands typesetting commands 
taken files subjected algorithm varying constants 
provides empirical values bias flajolet martin table iii sample executions algorithm files multiplicative hashing function file card 
man man man man ho man man note 
displays file name exact cardinality estimated cardinality nmap ratio estimated cardinalities exact cardinalities italics 
standard error averaging simulations files appear amazingly agreement theoretical predictions 
results reported table iv compared table ii 
correction small values nmap described inserted algorithm fig 
applica ions distributed computing assume fine partitioned fs need disjoint 
situation occurs routinely context distributed data bases 
table iv empirical values bias standard error simulations bias standard error note 
different hashing functions applied files man mans probabilistic counting algorithms global cardinality file may determined follows process separately algorithm 
gives rise bitmap vectors bitmap 
processors sends result central processor computes logical bitmaps 
resulting bitmap vector construct estimate remarkable accuracy estimate construction affected way records spread 
number messages exchanged small algorithm results net sj factor scrolling matrix bitmap vectors specific form starts rows ones followed fringe rows consisting mixed zeros ones followed rows zeros 
suggests naturally compact encoding bitmap may quite useful distributed applications minimises sizes messages exchanged processors 
idea indicate left boundary fringe followed standard encoding fringe instance bitmap matrix needs represent leftmost boundary fringe binary words 
technique amounts keeping small window bitmap matrix scrolling necessary 
practical window size suffice storage requirement version close og nmap bytes 
deletions keeping bits record occurrences patterns form kl keeps counts occurrences obtains algorithm maintain running estimates cardinalities files subjected arbitrary sequences insertions deletions 
price paid somewhat increased storage cost 

probabilistic counting techniques particular algorithmic solutions problem estimating cardinality multiset 
quite clear flajolet martin observable regularities hashed values records conjunction direct stochastic averaging 
mention passing rank rightmost bitmap parameter flatter distribution results appreciably accurate algorithm terms stan dard error binary logarithm minimal hashed value encountered hashed values considered real numbers provides approximation log resulting algorithm appears slightly accurate 
common feature algorithms estimate cardinality multiset real time auxiliary storage log relative accuracy form interest determine appreciably better storage accuracy trade achieved prove possible infor mation theoretic standpoint 
practical purposes algorithm quite satisfactory 
consumes operations element scanned may assembly language instructions accuracy described length previous sections may gather statistics files fly eliminating cost disk accesses 
vax running berkeley unix non optimised version pascal tests typically twice fast standard system sorting routine 
version algorithm implemented ibm san jose context system project 
appendix amplitude periodic fluctuations purpose appendix show fluctuations form fourier series appear theorems precisely bounded 
notice problem reduces showing fourier coefficients sufficiently small values 
fourier coefficients values functions form ro behaved function taken points gk ik log non zero integer 
quantity depends particular problem considered theorem theorems 
shall give proof case theorem proofs entirely similar 
need find bounds fourier series probabilistic counting algorithms proof 
proof depends easy observations log follows immediately inequality rewriting definition exponential form find xt log pk fl behaviour gamma function imaginary axis known rr sinh rt decreases fast going away real axis 
instance finds ik log ic ic 
required effective bounds follows easily refining approach taken proof lemma 
define real function see eq 

lemur 

flajolet martin remainder satisfies ir 
log obtain tx lemma purposes bounding values large bounding truncation errors estimating sum terms 
cop sati es proof 
consider form 
notations lemma 

define jo max jo sum jo 
modulus direct numerical computations 
values check ipl pk smaller exponentially decreasing basis exponential equal 
probabilistic counting algorithms acknowledgments author express gratitude ibm france ibm san jose research laboratory invited visit subject done large part 
due young wang implemented method fagin support stimulating discussions 
note added proof sequence occurred repeatedly classical thue sequence 
dirichlet generating function 
automates de dirichlet inform 
math publ 
math 
universit de obtained interesting properties sequence including proof curious identity compare theorem oo 
der laplace transformation birkhauser basel 

flajolet approximate counting detailed analysis bit 

flajolet anon 
martin probabilistic counting proc 
th ieee sympos 
foundations computer science nov pp 


art computer programming sorting searching addison wesley reading mass 

lum yuen dodd key address transformations fundamental study large existing formatted files comm 
acm 

morris counting large numbers events small registers comm 
acm 

munro sorting searching multisets slam comput 

griffiths selinger astrahan chamberlin lorie pr ice access path selection relational database management system report rj ibm san jose res 
lab aug 
printed st catherine press bruges belgium 
