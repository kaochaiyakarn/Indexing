run time behavior usage scenarios interaction pattern mining approach mohammad el paul sorenson cs ualberta ca key challenge facing organizations today evolution adopting business practices gives rise need reengineering underlying software systems 
reengineering effort aware functional requirements subject system order violate integrity intended uses 
software systems get regularly maintained lifecycle documentation requirements obsolete get lost 
address problem software requirements loss developed interaction pattern mining method recovery functional requirements usage scenarios 
method analyzes traces run time system user interaction discover frequently recurring patterns patterns correspond functionality currently exercised system users represented usage scenarios 
discovered scenarios provide basis reengineering software system web accessible components supporting discovered scenarios 
describe ipm interaction pattern discovery algorithm illustrate case study real application give overview reengineering process context employed 
keywords sequential pattern mining software engineering interaction reengineering software requirements recovery usage scenarios run time behavior analysis 

motivation background software application deployed actively organization requires continually evolved bug fixing adaptations behavior enhancements permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigkdd july edmonton alberta canada 
copyright acm 
department computing science university alberta hall edmonton alberta canada cs ualberta ca sorenson cs ualberta ca functionality lehman laws software evolution 
process original functional requirements properly documented blurred outdated 
problem requirements loss especially critical existing software system needs reengineered order current functionality accessible new platforms web 
understanding requirements existing software system key problem research today 
substantial body research aiming understanding reverse engineering software 
great extent research focused analyzing application code order extract model static architecture terms high level modules 
code scarcely structured includes dead obsolete fragments glue code incremental updates ignorant violate original software architecture 
code fairly structured models produced code analysis consist modules correspond closely syntactic constructs programming language software developed semantically coherent packages functionality 
extracting reusing modules reengineered application may result violations integrity underlying legacy information system 
obtain richer understanding software methods proposed 
representation interesting software fragments terms plans clich program comprehension task recognize instances plans program 
representation language usually supports functional specification plans instances approach quite effective reverse engineering functional requirements programs scalable 
context software development methodologies object oriented example functional requirements specified terms usage scenarios 
fact preliminary requirements recovery research analysis object oriented code produces specifications case scenarios 
alternative source information regarding usage scenarios program applicable interactive applications object oriented ones run time interaction program user 
interaction program users follow scenarios accomplish tasks 
project adopts interaction approach reverse engineering traces users interaction legacy application constructs state transition model legacy interface behavior 
context software requirements recovery problem formulated sequential pattern mining problem 
underlying intuition traces run time user interaction represent walks legacy interface model 
frequently occurring patterns traces interpreted purposeful paths executing type task documentation functionality delivered legacy application 
similar rationale motivated research reverse engineering processes collaborative virtual environments environment data logs mined discover individual tasks processes sequences tasks 
rest organized follows 
section gives context background interaction pattern mining problem 
section presents necessary terminology formally defines problem 
section reviews related pattern discovery literature 
section presents ipm algorithm developed interaction pattern mining 
section case study evaluation algorithm 
section summarizes date concludes lessons learned pointers 

interface migration goal project develop intelligent lightweight semi automated method legacy user interface reverse engineering migration web 
fundamental methodological assumption actual run time behavior legacy application constitutes operational specification desired functionality functionality exercised current users 
process takes input recorded traces system user interaction proprietary legacy platform produces output new task centered user interface ui accessible variety web platforms 
method consists phases 
reverse engineering phase legacy navigation domain identifier prototype produces model legacy interface behavior 
state model corresponds distinct screen legacy interface 
screen snapshots classified distinct interface screens classifier induced clustering trace snapshots visual similarity 
transition model corresponds possible user action sequence cursor movements keystrokes particular screen causes transition interface current screen new 
expert user reviewed validated produced legacy interface model step discovery frequently occurring interaction patterns 
instances discovered interaction pattern represent multiple executions single user task 
examples user task modeled demonstrational programming approach 
resulting model reviewed elaborated user specifies information exchange user legacy application performing subject task 
model effect scenario specification functionality legacy application 
forward engineering phase declarative user interface specification modeled scenario constructed prototype environment 
specification executable suite special purpose platform specific components 
new multi platform user interface frontend original legacy user interface 
drives underlying application executing instructions captured scenario model task protocol original legacy system see 
consider new user interface taxi driver saves individual walking legacy user interface interface state transition model road map 
task model path map going origin destination location map 
taxi api traverses path 
text ui legacy system task model task centered gui state transition graph state transition graph api legacy data transfer protocol text ui legacy system legacy user interface migration approach 
cornerstone new front interface construction availability examples task scenario currently accomplished legacy interface 
examples mined instances frequently occurring patterns system user traces ipm sequential pattern mining algorithm 
example case study illustrate process case study evaluate ipm 
case study conducted library congress information system traces recorded user retrieved detailed information pieces federal legislation ibm public connection user started making menu selections needed open relevant library catalog 
performed information retrieval tasks times 
shows consecutive screen snapshots recorded traces keystrokes occurred snapshot 
solid line snapshots constitute instance user task 
scenario user issued browse command keyword browse relevant part library catalog file 
issued retrieve command retrieve subset catalog items 
displayed brief information items set display command 
selected item display item item command display full partial information full legislation list sponsors official title built corresponding state transition model 
shows part model relevant trace segment top left corner screen contains id 
labels edges represent models user actions enable transition interface screen 
interaction pattern mining algorithm discover user tasks performed order model subsequently migrate 
provided sufficient number instances task appear recorded traces meet user defined criterion pattern interestingness method discover instances represent candidate interaction pattern instances include insertion errors 
context insertion errors extra snapshots may exist instances pattern due user mistakes existence alternative paths task 
pattern corresponding task instance 
section discuss pattern extracted 
pattern subsequently augmented semantic ip address loc gov project focused mainly legacy systems block mode data transfer protocol ibm 
underlying methods generally applicable 
information necessary forward reengineering phase 
includes specifying information exchange user application screen user inputs system system outputs return 
shows augmented interaction pattern textual description corresponding scenario 

problem statement section provides terminology formulation problem discovering interaction patterns recorded traces interaction legacy user interface 

alphabet legacy screen ids set ids screens legacy system analysis 

sn set sequences 
sequence si ordered set screen ids represents recorded trace interaction user interface legacy system users similar partial trace shown 
episode ordered set screen ids occurring sequence 

pattern ordered set screen ids exist episode set episodes interest user defined criterion say support refer individual ids episode pattern square brackets id number items respectively :10.1.1.40.9892

set episodes supports pattern ids ids episode respectively ids exist order may contain extra ids formally pair positive integers predicate defines class patterns interested patterns preset number insertions :10.1.1.40.9892
example episodes support pattern insertions 

location list pattern written list triplets location episode sequence containing locations respectively 

support pattern written support number episodes support note support length length 

density pattern supported set episodes written density ratio average episode length episodes density support 
qualification criterion simply criterion user defined 
pattern minimum length main menu federal legislation menu welcome rep williams catalog browse retrieve results brief display brief display brief display brief display brief display brief display item item details page item details page item details 
pg 
item details 
pg 
item details page summ item details page item details page item details page item details pg 
part trace example 
means enter key 
threshold 
minimum support threshold support 
maximum error maximum number insertion errors allowed episode implies minimum score threshold scoring function rank discovered patterns 
function score log log support density corresponding portion state transition graph 
means mandatory argument means optional argument 
example trace user interaction library congress information system 
catalog catalog catalog browse browse browse retrieve results item details item brief item details brief item details page brief display page display page display item item details 

details pg 
pg 

pg 
interaction pattern discovered information retrieval task augmented action locations 
means user action occurs screen snapshot unspecified row column 
item details page main menu federal legislation menu welcome catalog browse item details page name retrieving information federal legislation participating actor user entry condition user issues browse command flow events flip catalog pages relevant page 
issue retrieve command construct results set chosen catalog entry 
display results set display command turn pages required item 
issue display item command 
specify display option 
display item details 
repeat steps retrieving needed details exit condition user retrieves required information federal legislation interest 
textual description corresponding usage scenario 
interaction pattern corresponding functionality described usage scenario 
item details 
pg 
brief display retrieve results item item details page experiments showed function suitable sufficient application considers balances pattern length support density 
default values respectively 

maximal pattern pattern sub pattern pattern support 

qualified pattern pattern meets userdefined criterion 
candidate pattern pattern analysis meets conditions 
definitions problem discovery formulated follows alphabet set sequences user criterion find qualified maximal patterns 
related pattern mining sequential pattern mining generic problem instances range domains 
introduced name mining sequential patterns inspired applications retail industry set customers sequences transactions goal discover sequences items patterns occurring transactions customer :10.1.1.40.9892
interaction pattern mining problem different similar problem discovery frequent episodes event sequences 
problem discovered frequent episodes different types ordering full serial episodes parallel episodes partial appear user defined time window 
support pattern measured percentage windows containing 
apriori algorithms developed tackle problem winepi minepi seq ready go 
interaction pattern mining problem similar problem discovering patterns genetic protein sequences 
objective discover probabilistic patterns deterministic patterns noise flexible gaps wild cards don care characters ambiguous characters replaced character subset 
bio sequential data usually large efficient search strategy discover short ambiguous patterns exhaustive search possibly pruning 
patterns support extended form longer ambiguous patterns 
process continues patterns discovered 
elegant examples category pratt teiresias algorithms 
pratt discover patterns quite general prosite format bd flexible gap length flexible gap length bd ambiguous character replaced original teiresias algorithm discovers patterns wild cards pattern constraint density sub patterns containing exactly non wildcards items length example cd ch pattern replaced id algorithms handle patterns insertion errors problem 
interaction pattern discovery problem objective discover fully ordered patterns possibly number insertion errors predefined upper bound 
differs formulation restrict pattern length window length 
introduced restricted version problem discovered exact interaction patterns insertion errors allowed apriori algorithm 
severely limits number type patterns retrieved needed accommodate insertion errors 
problem formulations related algorithms mentioned match mining problem developed algorithm called ipm interaction pattern miner solve 
ipm uses strategy developing longer candidate patterns shorter ones 
web usage mining ipm steps preprocessing input sequences pattern discovery pattern analysis 
apriori algorithms ipm avoids multiple passes database maintaining location lists candidate patterns generate location lists longer composite patterns 
ipm extension earlier algorithm ipm 
ipm uses depth search breadth search ipm 
eliminates need store patterns length time matrix patterns location lists memory exhaustive size alphabet big 
ipm suitable big systems numerous screens 
comes cost generating candidate patterns ipm 
ipm continually extends candidate pattern gluing patterns length support backtracks reports maximal qualified pattern 

interaction pattern mining describe detail ipm algorithm solving problem mining interaction patterns recover legacy system requirements usage scenarios 
preprocessing interaction trace initially represented sequence screen ids integers 
denote representation 
contains repetitions resulting accessing instances screen consecutively browsing pages library catalog 
repetitions may result missing important patterns 
example episode support pattern 
avoid encode run length encoding algorithm replaces immediate repetitions count followed repeated id repetition counts stored separate sequence 
call representation 
shows representations trace segment preprocessing interaction traces 
pattern discovery ipm input ipm algorithm set sequences criterion ipm outputs maximal qualified patterns ipm consists distinct phases 
exhaustively searches input sequences find candidate patterns length meet minimum support maximum error conditions procedure 
pattern location list constructed 
patterns stored vector length pattern lists cells labeled ids cell contains patterns example pattern stored :10.1.1.40.9892
second phase procedure algorithm recursively extends candidate pattern depth approach 
extension candidate pattern pattern produces new candidate pattern extended 
extended patterns patterns length id id 
location lists construct procedure 
locations episodes support insertion errors excluded 
support extended patterns ignored algorithm records qualified backtracks 
backtracking reporting pattern algorithm examines parent pattern 
sub pattern candidate pattern 
qualified support support relative recorded 
trying extend patterns non maximal patterns removed qualified maximal patterns reported 
procedure producing initial candidate pattern set algorithm describes procedure ipm algorithm 
step creates vector pattern lists 
hash table data structure hold list hashed patterns 
steps repeated input sequence trace sk step iterates ids sk sk sk sk 
steps id build pattern consecutive ids 
example sk id tried resulting generation patterns 
steps add new pattern 
location episode supporting pattern added location list step 
steps perform function steps handle ids sk 
steps remove non candidate pattern patterns support 
procedure input alphabet criterion set sequences output candidate patterns length 
steps 

trace 


construct new pattern 

add 
add 


construct new pattern 

add 
add 
id 
pattern id 
length 
remove id procedure pseudo code 
procedure generating longer candidate patterns shorter ones 
algorithm describes second procedure 
step creates pattern list called store discovered patterns 
step iterates cell id 
step iterates pattern id 
pattern step calls extend subprocedure returns qualified extension patterns maximal relative sub pattern support 
step adds discovered extensions 
step removes non maximal pattern final results 
step reports results back 
extend sub procedure works follows 
step creates pattern list hold patterns resulting successful extensions parameter pattern 
step iterates pattern extend pattern id id 
steps construct extended pattern location list 
step tests support procedure input vector pattern lists initialized candidate patterns length location lists criterion output maximal patterns qualified steps 

id 
pattern id 
extend 
merge 
remove non maximal patterns 
report extend 

pattern 
construct new pattern 
construct location list procedure 
support 
extend 
merge 
support support 
score 

add 

score 

add 
return procedure pseudo code 

steps executed case true steps executed case false 
case successful extension step extends new candidate calling extend parameter 
step adds qualified patterns resulting extending 
steps add support successful extension qualified 
case failing extend extension pattern ignored steps add results list qualified 
step reports back qualified maximal relative extension patterns 
procedure constructing location list candidate pattern 
algorithm describes procedure creating location list new candidate pattern 
combines locations lists patterns provide location list 
step iterates locations episodes supporting 
steps retrieves location episode 
step retrieves locations episodes support satisfy conditions 
episode procedure input location lists patterns 
lists sorted 
output location list 
steps 
create empty location list 
length 
loc location 
find set loc loc loc loc loc loc loc loc 
loc loc 
add loc start loc 
remove duplicates 
return procedure pseudo code 
sequence sub episode vise versa 
overlap exactly location 
distance inclusive 
steps construct location list remove duplicates 
step reports results back 
example illustrate operation ipm algorithm simple example 

discover maximal qualified patterns table shows result applying procedure ipm second row corresponds cells 
patterns enclosed curved brackets locations sequences shown parentheses 

candidate patterns shown bold 
patterns insufficient support shown normal font 
removed procedure kept table clarification 
shows partial application procedure extend candidate patterns table 
patterns boxes ones extended resulting extension 
patterns arcs ones id table 
procedure ipm application example 
application procedure candidate patterns resulting procedure example 
table maximal qualified patterns discovered ipm application example 
pattern support density score extension 
location list generated pattern shown box 
qualified patterns reported sub procedure extend bold font 
maximal qualified patterns returned ipm double line boxes 
note pattern qualified reported extend extension support reported reported extend removed procedure non maximal 
table shows discovered maximal qualified patterns support density score 
understanding extracted patterns reviewing discovered patterns criterion modified narrow widen result set patterns retrieved 
furthermore group patterns score support specific range selected compacted removing pattern sub pattern pattern maximal 
interactive step scoping cleaning extracted interaction patterns crucial identifying usage scenarios corresponding functional requirements legacy application 
methodologically longer recorded traces stricter criterion discover true usage scenarios noise patterns gain support evaluated context long term 
ultimately user knowledge application domain organization processes decide discovered patterns correspond usage scenarios corresponding required functionality 
point location list pattern pattern instances retrieved analyzed terms information exchange support order build task models forward engineering phase 

case study evaluation section demonstrative case study recovering usage scenarios legacy application run time traces users interaction 
discuss result applying ipm case study introduced section 
recorded traces user performing repeatedly various information retrieval tasks federal legislation 
user conducted sessions ibm public connection 
session recorded data sequence 
respectively 
part shown reverse engineering tool build state transition model corresponding part model shown nodes corresponds system screen 

screen descriptions shown table 
frequency fr 
screen number times recorded preprocessing ipm applied times discover user interaction patterns model 
different parameters tried criterion limit size results set easy comprehend 
table shows patterns discovered criterion ordered score 
result set compacted removing pattern subset pattern leaving patterns column 
column number means corresponding pattern subset pattern serial number 
table screen ids descriptions frequency 
id screen description fr 
id screen description fr 
main menu select result federal leg 
menu combine result welcome release result browse result comments retrieve result goodbye brief display ready command display item st system message display item pg 
results pg 
display item pg 
expand results help expand results page error expand results pg 
search history results pg 
display list expand results reviewed sample instances pattern see corresponds real user task usage scenario system 
inspection revealed patterns bold table closely correspond repetitive user tasks alternative paths 
actual complete interaction patterns tasks 


note format checking instances pattern original sequences format knew screens consecutively repeated added sign 
task corresponding discovered discussed earlier subsection 
second task user starts browsing part currently open library catalog 
issues select command retrieve records catalog 
select command constructs separate subsets results specified search term different search field records search term title records user issues combine command merge subsets set logical operators 
displays brief information items set selects items display full partial information 
select command creates record sets specified search term 
combine command creates new set records logically combining previously created sets 
release command releases search result sets needed anymore 
views legislative indexing vocabulary thesaurus online 
expand command combines select commands 
table qualified maximal patterns discovered case study 
pattern support score density third task user starts issuing command 
command takes parameter term classified subject index term displays related broader narrower terms available legislative indexing vocabulary thesaurus 
example user likes search legislation related drugs thinks broad term type drugs 
results screen display terms antibiotics aspirin generic drugs user expand displayed terms expand command creating results set catalog entries 
displays needed information tasks 
scenarios legacy system may follow alternative paths results user depending pages details retrieved legislation interest 

formulated problem recovering usage scenarios run time behavior interactive application instance sequential pattern mining problem described algorithm developed address 
usage scenarios specifications application functional requirements 
extracting usage scenarios tantamount recovering application functional requirements documentation obsolete 
crucial problem context reengineering application migrating functionality new platforms goal project 
postulates user tasks patterns frequently occurring similar episodes run time behavior traces 
episodes may match approximately 
users may face exceptional conditions executing tasks result various instances task execution may include spurious extra steps 
ipm algorithm developed address exactly requirement discover fully ordered sequential patterns possible insertion errors 
date evaluated algorithm realistic case study real legacy application 
plan evaluate bigger artificial real data sets interaction traces cover wide range applications interaction styles 
furthermore plan compare effectiveness efficiency relative related algorithms including earlier ipm algorithm 
believe interaction pattern mining approach legacy interface migration interesting variant sequential pattern mining problem compelling application class knowledge discovery algorithms 
initial results indicate deployment context process help provide powerful low risk lightweight solution challenging problem web enabling legacy applications 
supported nserc alberta software engineering research consortium 
agrawal srikant 
mining sequential patterns 
proc 
th int 
conf 
data engineering ieee comp 
soc 
press 
bairoch prosite developments nucleic acids research vol 

frequent sets sequences taxonomies new efficient algorithmic proposals 
report number lsi el departament de inform tics universitat polit cnica de catalunya spain dec 
assisting design virtual processes line reverse engineering 
proc 
th hawaii int 
conf 
system sciences ieee comp 
soc 
press usa 
dimarco finding patterns biological sequences 
unpublished project report cs university waterloo fall 
chikofsky cross ii 
reverse engineering design recovery taxonomy 
ieee software vol 
jan 
cypher 
ed 
watch programming demonstration mit press cambridge ma 
di de recovering case models object oriented code approach 
proc 
th working conf 
reverse eng 
wcre ieee comp 
soc 
press 
el sorenson modeling system user dialog interaction traces 
proc 
th working conf 
reverse eng 
wcre ieee comp 
soc 
press oct 
el sorenson mining system user interaction traces case models 
proc 
th int 
workshop program comprehension iwpc ieee comp 
soc 
press france oct 
el sorenson recovering software requirements system user interaction traces proc 
th int 
conf 
software eng 
knowledge eng 
acm press italy 
holt kerr kontogiannis muller mylopoulos stanley wong software bookshelf 
ibm systems journal vol 

pattern discovery biology theory applications 
ph thesis department computer science new york university jan 
methods finding motifs sets related 
dr thesis dept informatics univ bergen kapoor simultaneous legacy interface migration multiple platforms 
proc 
th int 
conf 
human computer interaction vol 
lawrence erlbaum associates aug 
lehman perry metrics laws software evolution nineties view 
proc 
th int 
software metrics symposium metrics 
mannila toivonen verkamo discovery frequent episodes event sequences 
data mining knowledge discovery vol nov 
asl discovering mining user webpage traversal patterns 
sc 
thesis school computing science simon fraser univ canada 
ller orgun tilley uhl reverse engineering approach subsystem structure identification 
software maintenance research practice vol 
dec 
el kong sorenson reverse engineering legacy interfaces interaction driven approach 
proc 
th working conf 
reverse eng 
wcre ieee comp 
soc 
press 
el sorenson legacy systems migration 
short research demonstration 
proc 
nd int 
conf 
software engineering icse pp 
ireland 
parnas software aging 
proc 
th int 
conf 
software engineering icse 
quilici woods zhang program plan matching experiments constraint approach 
science computer programming vol 

wills automated program recognition feasibility demonstration 
artificial intelligence vol 
sept 
