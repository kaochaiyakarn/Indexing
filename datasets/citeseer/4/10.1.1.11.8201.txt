comparative review robot programming languages gregory hager august comparative review variety intermediate level robot languages emerged years 
describe robot programming language called frob functional robotics 
frob example embedded domain specific language hosted haskell programming language 
basic concepts language discuss ability frob model programming architectures compare capabilities extant languages reviewed 
appropriate languages language structures software architectures developing robot software topic debate discussion earliest computer controlled robot systems 
fact uniform consensus terms universal robot programming system surprising range issues language need address 
set issues relates simple fact autonomous robot inhabit unstructured dynamic changing world able effectively react world sensor information physical effectors 
basic level implies language needs facilitate description sensor control algorithms 
unpredictability implies algorithm interrupted time may suddenly faced inputs inconsistent incomprehensible current control context 
methods prioritization control monitors past deal issues 
ideally robot programming language provide simple clean set abstractions describing combining control behaviors 
second set issues arises nature tasks autonomous robots ideally perform 
tasks easily specified level deliver mail give tour collect objects execution ultimately entails complex interaction sequencing low level behaviors 
led notion layered system logical separation high level planning mid level execution monitoring steps tasks low level execution set behaviors 
ideally robot programming language span layers providing uniform means creating abstractions relating 
third set issues arises due practical problems developing robot system software 
fundamental fact robot system programming highly experimental nature know outset best sensors control actuators set thresholds forth 
long cycle development testing refinement system reaches point operates reliably 
result rapid correct prototyping software reuse paramount importance 
likewise ability combine system components quickly correctly essential 
closely related issue desire develop hardware independent algorithms code may easily transferred application application 
subtle practical problem fact time computation needed allow robot achieve objectives highly dynamic 
precisely time interval may large shift sensors employed algorithms process information control algorithms currently operating surrounding system monitoring may place 
language spare programmer details managing flow computation keeping code execution minimum necessary perform currently active computations 
article introduce new robot programming language called frob functional robotics 
frob motivated part desire create broad spectrum approach robot programming approach readily adapted needs requirements types robot programming problems 
frob achieves goal advantage fact embedded language hosted lazy higher order strongly typed language called haskell 
possible express different programming architectures system 
time frob lazy execution model achieving aims minimizing computation 
remainder article describe frob perform comparative analysis capabilities 
section review programming systems discuss address issues outlined 
describe frob compare capabilities languages set examples 
conclude discussion current directions frob project 
review programming languages term robot programming language encompasses broad disparate collection 
spectrum languages specifically designed joint level cartesian motion 
spectrum languages motivated needs ai planning generally high level goal specification behavior rpl prs 
review generally focus variety intermediate level languages emerged years tdl 
languages attempt strike compromise offering ability program low level behavior detail time providing language abstractions facilitate description higher level system behavior 
review focussed systems discuss variety architectures section 
called sequencer language developers 
part architecture 
architecture integrated sensing control system robotics applications 
complex operations visual tracking humans coordination motor controls planning integrated architecture concepts coordination behavior coherence modeling communication agents 
motion control layer consists fuzzy controller middle execution level motion control layer planning 
programs activities semantics fsas written subset ansi behavior robot controlled activities text term language broadly denote types programming systems fi om embedded languages libraries full blown architectures complete stand programming languages 
sequencing basic actions robot 
monitoring execution basic actions activities 
executing activity subroutines 
checking setting values internal variables 
robot control means defining activities activity schema corresponds finite state automaton 
activity executive interprets statements activity schema associated fsa 
statements schema correspond directly states fsa 
instance conditional looping statements probably represented set nodes 
actions nodes typically primitive robot actions internal state changes 
activity finished transition done new node success failure activity 
implicit wait condition transition nodes overwritten concurrent activities 
action executive updates concurrent activities round robin fashion 
clock cycle executing activity progress state associated fsa 
communication activities possible directly sending signals indirectly accessing modifying global database consisting internal variables 
predefined states activity checked changed activities 
states include initial state activity 
termination states success failure timeout suspend interrupted states resumed state special states enable activities signal activities possibly including spawned parent coordination handling dynamic changes environment 
possible define activity life span depending activities querying predefined states 
summarize activity executed invoke new activities result primitive actions commands send robot 
activities communicate affect 
internal database storing related information coming sensors part responsibility architecture enable activities share information 
shows approach activity example 
simple patrol example robot moves back forth times points meter apart 
fsm corresponding activity activity name patrol referred 
move built primitive robot actions 
approach activity robot specified amount time 
detects object meters moves cm 
object 
subtask patrol spawned additional timeout constraint 
bj part global database 
distance checked loop meters loop restarts checking sub activity patrol checking global error occured 
loop terminates suspends patrol robot moves object 
act patrol int move move act approach int start patrol timeout checking patrol ii fail goto checking suspend patrol move succeed approach activity patrol defines activity robot times may interrupted activities 
case robot waits forward motion finished help stops 
activity resumed robot continues going code point node fsm marked start 
animate agent architecture firby animate agent architecture aims building agent control system integrates reactive plan execution behavioral control active vision single software framework 
basic datatype system raps reactive plans defined lisp syntax 
low level soft real time routines called skills 
skills get information world effect world 
skills communicate raps signals carried global channels 
rap system responsibility get set task goals plan planner top level goal expand goal primitive actions reached 
primitive actions disable enable skills 
rap generate set concurrent skills help reach goal associated rap waits skills success failure signals 
basic clauses methods rap tests condition queries memory 
may predefined conditions determine execute rap place testing success failure 
act int start move move succeed waitfor suspend goto start patrol activity tasks rap called task net ordered sequentially parallel unordered 
life span subtasks defined depending 
monitors synchronize rap execution changes world 
execution suspended state true event happens specific period time monitors 
possible different methods execute depending different contexts state world going tasks 
estimated execution time help rap interpreter satisfy task deadlines 
execution time rap limited adding timeout clause 
internal variables 
mechanism wait clause defining starting time task relative success mechanism handle exceptions 
fact task sends specific signal global channels succeeds just success signal 
specific signal describing exception sent similarly handled responsible rap 
example task net camera wait success tl tl approach target target wait target wait stuck start track target target wait lost target wait camera problem start camera terminate define rap move object container event lost object fail sequence tl pickup object go container drop object define rap pickup object sequence tl start pickup grasp spawn monitor hand task mem add monitoring hand task finish pickup define rap drop object method context monitor hand task task net sequence tl start drop terminate task finish drop method context monitor hand task task net sequence tl start drop finish drop rap example task net defines task target approached simultaneously tracked 
camera turned start task turned task completion error occurs 
firby gives example illustrate different subtasks sequenced result task result different continuations 
wait checks signals carried global channels 
start determines task started 
firby gives example show spawning independent tasks useful give modularity 
note monitor hand task spawned subtask pickup object added memory terminated subtask drop object 
context check condition determine methods activated 
behavior language brooks advocates reactive behavior methods robot programming 
surprisingly subsumption architecture different layers concurrently asynchronously achieve individual goals 
earlier designs behaviors represented augmented finite state machines behavior language includes low level building blocks 
behavior language lisp syntax compilers available programmable array logic circuits 
encapsulates behavioral transformation function input function suppressed output inhibited components system 
possible reset initial state 
layer subsumption architecture specific goal 
higher layers output lower levels affect input output achieve goals generally goals lower layers 
argued kind hierarchical interaction layers prohibits designing higher levels independently 
started waits specified triggering event body executed 
events depend time periodically activate predicate state system message deposited specified internal register components enabled disabled 
body possible perform primitive actions put messages order interact 
behavior language behaviors represented set rules compiled representations compiled target processors 
grouping behaviors possible share registers outputs monitoring actions importantly component 
possible explicitly connect isolated behaviors connect clause 
connect clauses suppress input port inhibit output port 
components plans procedures possible define macros definition behaviors 
prs procedural reasoning system prs general framework designed called situated reasoning system 
systems diagnosing necessary measures handle plant process malfunctions real time 
requires reasoning management tasks includes reasoning criticality urgency tasks potential interactions tasks execution order tasks need resuming suspending tasks depending state system tasks execute reach goals tasks 
argued prs adapted robot control 
plans defined lisp language graphical tool 
basic elements system database containing system current beliefs world 
automatically updated new events appear 
possible compute values demand 
library plans procedures scripts describe particular sequence actions tests may performed achieve goals react certain situations 
plans called knowledge areas application dependent 
task graph dynamical set tasks currently executing 
prs interpreter checks new goals new events triggered outside world active tasks selects appropriate plans handle new goals events database places selected procedures task graph executes step active procedure 
result command real world new goal 
plan generally includes achieve goal statements add new tasks task graph satisfy new subgoal tests condition iterations possible continuations depending tests waiting condition true preserving conditions guarding actions adding constraint task 
constraint fails action suspended maintaining criteria maintain battery level result checking battery level task interrupting goal battery level falls trying reestablish desired level returning interrupted task 
difference prs interpreter adds new procedures depending new goals new events 
goal unifiable procedure tried procedure context test depending state system run 
goal declared fail related procedures fail 
notion event invoked procedures pursue explicit goal monitor 
response event success failure analyzed 
tdl discussed earlier robot control architectures developed interacting layers 
behavior level interacts physical world 
planning layer defining achieve goals 
layer connects layers issuing commands behavior level results plans passing sensory data taken behavior level planning layer enable planning reactive real world 
executive layer responsible expanding goals low level commands executing handling exceptions 
main motivation developing task description language tdl conventional programming languages defining task level control functions results highly non linear code difficult understand debug maintain 
tdl extends syntactic support control 
compiler available translate tdl code code task control management tcm libraries 
basic datatype tdl task tree 
leaves task tree generally commands perform physical action world 
types nodes goals representing higher level tasks monitors exceptions 
action associated nodes perform computations change structure task tree goals add child nodes tree viewed subgoals 
nodes task tree executed sequentially parallel 
possible expand subtree wait synchronization constraints hold executing 
achieved having different modes nodes called state node 
defined semantics expanding executing nodes task tree 
briefly node disabled synchronization constraints satisfied enabled active enabled sufficient resources computational physical completed action related node succeeds fails 
goal int room double room spawn spawn sequential execution previous terminate spawn speak xavier mail sequential execution terminate completed spawn sequential execution goal double double delay expansion int spawn wait spawn move move left spawn move move right spawn disable execution previous execution completed task tree mail delivery goal termination disabling criteria may defined relative time starting finishing time event typically triggered goals termination expansion starting execute 
explicit labels may differentiate multiple spawning task 
monitors structure goals additional implicit constraints max trigger max activations period activity 
exceptions thrown goal fails handled goal body spawning appropriate exception handling tasks 
goal definitions result task tree robot goto specific location deliver mail 
note nodes defined executed sequentially expansion tree execution delayed center recursively spawns robot position center door 
main goal definition terminate center specific amount time seconds 
signal signal language designed safe real time system programming 
semantics defined mathematical modeling multiple clocked flows data events 
relations defined data event signals describe arbitrary dynamical systems constraints may develop real time applications 
operators relate clocks clock calculus values signals 
signal described synchronous data flow language 
signal designed specifically robotics characteristics robot programming signal mentioned functionalities possible active vision robotics systems 
vision data synchronous continuous nature captured signals control functions sensory data control outputs defined 
signal extension signal task sequencing discrete level 
signal enables definition time intervals related signals provides methods specify hierarchical tasks 
combining data flow multitasking paradigms results having advantages automata determinism task sequencing concurrent programming parallelism tasks 
advantages hierarchy parallel automata designed 
planning level robot control counterpart signal task level purpose 
process mouse integer delta event tick click event single double start interval click start relax count interval tick start relax cell event zn click default tick relax tick zn delta double click start default interval click start relax cell relax single relax double click double relax double click event start relax integer zn init logical double click example taken 
output signals single double occurs delta time steps time mouse button pressed 
interval mouse click occurs double signaled single signaled 
equality defines new signal existing ones number ways delaying original zn filtering 
charon charon language modular specification interacting hybrid systems defining robot control strategies 
building blocks system agents modes 
agent communicate environment shared variables communication channels 
language supports operations composition agents concurrency hiding variables information encapsulation instantiation agents reuse 
complex agents built agents define hierarchical architectures 
atomic agent mode represents flow control 
modes contain submodes transitions possible connect modes defined entry exit points 
specific entry exit points 
supporting history retention default entry transitions allowed restore local state exit 
default exit point group transitions apply submodes support exceptions 
anim 
beh 
charon prs signal tdl frob sync async 
async 
async 
sync 
sync 
async 
sync 
sync 
sync 
language rap beh 
charon ext prs signal ext haskell style prog 
spec 
spec 
spec 
imp 
spec 
spec 
imp 
functional values na na na na formalism task net modes activities task data flow task streams fsm fsa graph language trees tasks fsa concurrency scheduling verification unclear suitable unclear suitable suitable signaling language comparison transitions labeled guarded actions allow discrete updates 
discrete round atomic agent executed execution continue long enabled transitions 
mode contain submodes group transitions examined enabled transitions submodes 
update happens variables declared analog 
time called continuous update variables represent continuous flow 
evolution analog variables ways differential constraints algebraic constraints invariants limit allowed durations flows 
agent clock assumed differences local bounded 
time round agent analog variables updated state frozen guards invariants agent depend updated values 
summary table shows different capabilities design choices languages frob introduced section 
languages components larger system dedicated aspect possible compare 
general frameworks robot programming signal charon certain part system tdl task scheduling prs planning execution 
common feature languages mechanisms defining components building blocks correspond notion tasks behaviors 
support modularity hierarchical composition components instantiation 
required nature robot programming form concurrency available multiple tasking single process distributed processes 
behavior language implementing subsumption architecture reactive planning parts 
tdl animate agents prs focused task scheduling 
uses signaling achieve tasks interrupt resume ones names 
special semantics coordinate spawning time tasks 
specify termination criteria time task depending lifespan 
assume languages tasks read write ports channels specific name signalling ability possible change control flow indirectly ports 
robot programming may require kind values specified 
ability encode compute continuous specifications differential equations 
generally depend regularly sampled values probably come world sensors 
datatype asynchronous discrete events generally correspond chaotic nature environment 
denote values respectively 
languages focused task scheduling mainly need include values 
error handling common feature languages 
exceptions error related signals change control flow tasks 
general approaches problem best observed raps 
wait statement check error signal just termination criteria determines continuation 
alternatively tdl exceptions definition task include exception statement exception name related exception handler 
approach handling exception throw ancestor task determine handle 
formal verification robot programs desirable robot control domain 
formal languages charon signal advantage purpose 
need simulation debugging testing formal verification recognized language developers generally includes plans develop visualization analysis tools 
tdl languages described extensions base language imperative style 
languages syntax exception signal charon specification component relations tasks behaviors lisp flavor 
frob frp functional reactive programming frp general framework hybrid systems employs behaviors events basic building blocks 
behaviors continuous sequences vary time events represent discrete asynchronous synchronous event occurences 
frp declarative style enables rapidly developing modular reusable high level programs 
principles underlying current frp framework introduced fran domain specific language programming reactive animations 
host language fran haskell gives frp flavor declarative programming 
frob functional robotics domain specific language embedded haskell frp designed robot control 
frp vision control systems applications 
haskell host language frp higher order polymorphic typed lazy purely functional language 
type systems haskell exploited frp implementation 
behaviors events fundamental data types frp streams 
behavior type defined mapping time type input represented stream stream values type behaviors continuous semantics sense value sampled animation ball rotating point sonar readings robot mouse position velocity robot navigation related task 
contrast events represent discrete time event occurences means values particular points time left button pressed robot bumped obstacle 
events represented streams related event occurences time ordered 
type behavior inp stream inp stream time stream type event inp stream inp stream time stream simplified type declarations show behaviors events time dependent mappings input stream infinite list output stream 
values event stream denoting occurence just means event occured value characteristic captured haskell type 
drop inp type variable types behaviors events sake simplicity possible types example behaviors behavior graphic animation ball behavior image sonar readings point mouse position behavior real velocity 
rich library combinators transformers frob produce new events behaviors existing ones 
basic ones 
event event new event constant value occuring occurs 
event event similar time function argument applied original event value get new value 
till behavior event behavior behavior switch behavior event behavior behavior transform behaviors help events 
bl till behavior values bl occurence behaves 
switch works similarly time occurence behavior changes behavior produced event instance bl switch lbp 
key new behavior starting bl switching left mouse button pressed lbp predefined event returning depending key pressed key predefined event returns key pressed 
note behaviors bl type ensure type resultant behavior 
till switch occurence lbp key final behavior remain depending event ignoring event occurences point 
event event event event event event disjunction events seen previous example 
el occurs el occurs value preserved 
events occur time implementation favors value leftmost event value composed event 
apply merger function get value events occur type 
event behavior event event behavior event capture value behavior event occurs 
disregard event value 
useful define switching behaviors switching time determined event new behavior depends behaviors current value 
color red switch lbp color red yellow yellow green red example red green yellow predefined constant color behaviors 
value behavior color event occurence captured compared red yellow uppercase determine color behavior 
red yellow predefined color values composing constant color streams red yellow 
event behavior event behavior step functions time final behavior values directly determined event 
el behavior starts switches el value time el occurs 
ao step 

case value event function applied current value behavior determine values behavior constant event occurs 
instance counter lbp lbp counter counter left mouse buttons pressed 
behavior bool event ff ttf tf turn boolean behavior event 
event occurs behavior changes false true 
lift lift lift behavior behavior behavior behavior behavior behavior behavior behavior behavior behavior behavior behavior behavior lift operators transforming behaviors fact events help overloading type classes 
lift returns constant behavior value argument 
maps function argument second behavior argument 
lift zips behaviors applying function argument corresponding values behaviors 
operator define family lift functions help lift level 
applies values argument behavior functions second argument get final behavior 
example lift bl lift bl function currying haskell lift return behavior type help applied type behavior return final behavior type behavior clocked events type clock inp clock type clocked event determines occurence pattern event 
events el clock guaranteed synchronous means el occurs occurs 
safely apply lifted functions synchronous events haskell type system prevents events different clocks mixed 
frob frob extension frp robot controlling 
task monad frp define tasks sequence modular programming 
task combines behavior terminating event 
basic type frob defines behavior mapping stimulus control value sense effect 
type constraints restrict input output behavior specific class 
sensor input class defines set behaviors events defining controller 
similarly effector class functions controlling robot 
position heading stuck behavior point behavior angle event behavior length signals related input classes 
input controller constrained having position heading behaviors give current position heading robot directly defining controller 
behavior speed speed behavior speed speed event frequency output type classes functions define robot controller depending behaviors events 
functions viewed commands robot understands 
see example defining controllers point 
position heading behaviors 
define important point independent hardware robot 
robot frob define specific behaviors functions related input output classes 
robots having sensors actuators controllers changing code 
gets behaviors returns behavior pairs composed behaviors 
tasks generate complex robot behavior 
robot task behavior robot controller combined terminating event state type 
denotes type internal state robot 
input robot senses specifies effectors shows type terminating event determines exit value task 
task monad sequence tasks 
example tm tl new task combining tasks tl behavior combination behaviors tl 
tl finishes behavior switched type binding result task stored variable defining 
return results task exits immediately value liftt liftt behavior event behavior basic building block tasks function 
liftt lift behaviors tasks terminate 
fmap behavior behavior fmap change associated behavior event value task respectively 
behavior behavior runs behavior parallel task adds value behavior task exit value 
results task immediately returns current behavior value 
behavior event event adding termination event existing task 
new task terminates old new termination event occurs 
generally adding termination criteria non terminating tasks ones generated liftt 
behavior task define new terminating event 
limiting time task run 
returns normal task exit value terminates time 
new task returns 
returns cases 
run tasks parallel 
current implementation frob parallel tasks try control effectors type system warn programmer 
case tasks controller ignored 
getstate setstate message task internal state getstate access setstate modify 
output task getstate task immediately exits value 
instantaneous task sends message 
comparative analysis section try find strengths weaknesses frp frob 
purpose look common architectures expressed frob framework flexible frob different design choices behavior coordination strategies planner reactor integrations rewrite examples languages previous section 
finite state automata 
false true te timeout fsa representation tasks finite state automata represent sequences aggregations behaviors define complex task 
powerful show behavior encoded fsa diagram intuitively represents transitions behaviors 
robot control language domain node fsa denotes active behavior transition new node means switching new behavior 
frob task abstraction pairs behavior terminating event 
task monad defines bind tasks 
monadic notation pretty straightforward express fsa tl stuck result previous task terminating event value choose different continuations 
loops expressed recursive definitions recursive task functions 
nodes primitive actions complex behaviors 
simple task node final subtask value termination time determine 
transitions subnodes hidden new fsa possible modify behavior result fmap respectively 
add new termination criteria composite node apply subtasks 
example time limit criteria added timeout transition taken time exceeds specified time considering subtask active point 
fact property frob define alternatively tm tl stuck common fsa diagrams frob result task task goto basic weakness fsa diagrams difficulty representing concurrency interactions concurrent tasks 
robot schema rs lyons arbib define robot schemas special model computation appropriate sensory robot controlling 
schemas plan environment represented 
basic schema consists schema name input port list output port list variable list internal variables behavior schema represents 
lyons define robot action plans networks concurrent processes 
process combination operators building networks processes 
frob operators expressed task monad sequential concurrent lq conditional qv qv disabling iq operator different parallel operator defined earlier sense parallel tasks observe behaviors behavior behavior connecting input output ports concurrent behaviors pass behaviors tasks 
limiting current frob behavior encoded robot task type processes share information ports 
examples ports connecting sensors effectors handled frob mechanisms getting sensory data sending commands robot 
composition operators defined ones 
mixed batch problem lyons show compose processes solved frob part case sds sc plan part lyons gives example environment modelled process composition operators 
frp behaviors events combinators useful purpose 
haskell abstraction mechanisms functional programming style kind environment modelling relatively easier intuitive frob 
example cars trac world defined type car behavior point type velocity behavior real datatype avoid hit ignore car velocity car car type vel case type avoid hit ignore time velocity cars behavior car cars switch key snapshot ch vel case ch car avoid vel car hit vel car ignore vel cars lbp cars car hit fast rbp cars car avoid slow function returns velocity behavior depending time 
cars start empty list time key left mouse button right mouse button pressed car added list 
subsumption architectures coordination process subsumption architecture results basic mechanisms inhibition suppression 
inhibition means signal prohibited reaching actuators means signal replaced suppressing message 
similar effect frob adding priorities behaviors coordination behaviors 
type behavior type stimulus stimulus value behavior priority stimulus priority stimulus behavior liftt value behavior stimulus value priority subsumes subsumes ifz basic subsumption combinator subsumes behavior higher priority returned function value 
give example show 
want define robot task robot wander randomly avoiding objects pick objects sees travels home complete 
homing stimulus homing home ifb pickup sonars point behavior stimulus bool pickup pickup ps wandering stimulus wandering avoiding sonars stimulus avoiding system sonars system strips priority output pickup point xy point xy pickup behavior done flag homing subsumes subsumes wandering subsumes avoiding homing behavior takes boolean behavior check done 
true priority behavior active true priority 
wandering behavior constant priority 
homing started inhibited 
pickup behavior priority goal seen 
goal seen raises goal visited 
priority avoiding determined sonar readings 
sonar readings combined force pushes robot 
depending closeness obstacles avoiding navigation tasks obstacle avoided priority avoiding drop previous continue doing 
pickup initialized set points representing goals visit 
result attached boolean behavior specify goals visited 
behavior passed homing determine start going home position 
note system constraints sonars building blocks pickup avoiding sonars robot controllers send commands wheel robot 
assembling behaviors behavior coordination mechanism 
frob embedded functional language easily develop abstractions define coordination mechanism appropriate problem domain 
coordination method making behaviors cast votes different actions 
action receiving votes chosen control behavior 
instance type vote datatype plan avoid goto goal choose plan vote choose votes add foldl add map avoid votes add map goto goal votes avoid goto goal competitive approach couple behaviors situations choose highest priority behavior constraint true 
example control strategy goalkeeper robot soccer team compose kicking ball close retreating goal necessary blocking goal moving goal ball 
type sc behavior bool 
sc sc sc rl cl 
rl ii ifb rl cl goalkeeper vision sc goalkeeper 

distance position goal distance position abs vector angle 
position ball blocker blocker vl 
position 
vec vl vec highest priority 
robot away goal returns immediately 
predicate true closeness ball checked 
near maxk robot goes ball kick 
constraints false robot tries position ball goal 
cooperative coordination methods behavioral fusion vector summation 
frp modules vectorspace geometry purpose 
examples turn angle angle heading angle move dist vel dist dist convert dist meters vector vel 
position dist move turn move patrol express example robot points specified number times frob define function iterate task number times 
defining turn heading angle stored task initiation 
control robot heading giving desired angle turning rate 
robot turns slowly desired heading achieved 
move defined similarly 
approach case error failed due timeout just move stuck error failed due obstacle example robot seconds object detected meters 
object detected distance object returned robot moves cm 
object 
note non terminating patrol task constrained terminating event time limit 
similarly approach task terminated robot point 
example robot times may interrupted actions 
interruption mechanism current frob sending receiving messages implements kind task interaction 
input stream instance type class assume signals events stream purpose 
example designed robot interrupted finish including current resumed 
change patrol definition get hands value 
internal state task accomplish 
patrol res res success return signals resume patrol patrol loop setstate return success loop signals lift interrupt patrol failure rap system look rap example tracking approaching task defined illustrate capabilities different task continuations control flow tasks lifespan tasks depending 
approach camera res lost target camera problem fail stuck stuck camera case res 
stuck 
fail 
success 
example moveto track defined parallel tasks 
terminating events added composite task 
camera shutdown regardless task ends different continuations taken depending result parallel tasks 
firby gives example show success failure task result complex behaviors 
frob task results value existent tasks results modified number ways 
task monad enables sequence tasks flexible way choose different continuations depending results previous tasks 
second example rap system shows handle spawning tasks subtasks 
unfortunately current frob kind spawning tasks subtask terminating subtask possible 
task active move obj ect task move object container pickup object goto container drop obj ect results computational power unnecessarily part subtasks added task monitor example haskell laziness prevents computing 
task monad extended having environment passed task 
may possible carry monitoring task environment 
case code possibly look move object container pickup object goto container drop object pickup object start pickup grasp finish pickup drop object start drop inenv return finish drop tdl tdl example previous section defines task mail robot navigates room tries deliver mail 
task defined frob room speak xavier mail center move move possible frob expand task trees executing previous ones tdl spawning means function call frob functionality tdl example captured 
expanding task trees gain computation time useful building complex plans 
tdl sequential execution default frob task monad tdl spawns tasks parallel default frob 
combinator seen example speaking activity runs parallel 
signal mouse lbp es es just es delta false es clicked es just es clicked double single es es just es true es delta signal example defining signals terms existing signals approach convenient get desired effect going signals checking stream values 
lazy evaluation feature haskell enables deal infinite datatypes streams 
example lbp predefined event stream related left mouse button constructing streams giving head tail stream 
definition depends values lbp event stream 
click detected means just value event stream function called 
input value denotes clock cycles exit interval 
reset decreased call 
second boolean value denotes mouse click occured inside interval 
starts false set true click observed 
input value rest stream head processed call 
input value hits meaning interval ended boolean value checked double single value fired value 
loop ut function called rest stream starts wait click initiate 
example shows haskell functional style incorporated want define frp pattern matching recursion helped lot define mouse intuitive way 
review robot control languages comparing examples frob strengths frob emerge frob embedded language haskell 
power functional language haskell robot programming 
functional paradigm depends part frob definitions intuitive formal definitions tasks directly coded frob 
frob choice rapid prototyping important robot domain experimental program development nature 
frob fixed approach robot 
architecture best suits needs 
example fsm depended task definitions subsumption architecture possible easy frob 
developing abstractions easier haskell programmer flexibility task arbitration method suits best goal task 
similarly languages reviewed gives set possible things done methods 
user languages impossible extend improve languages 
frob basically just haskell code options feels flexible frob point view 
easier adapt frob different type robots language developer 
low level details hidden abstractions program development done independently specific hardware 
frob frp frp rich set operators define events behaviors 
useful behavior robotics defining complex behaviors existing ones straight forward done intuitively 
basic building blocks robotic systems general control strategies robot programming available frob modular reusable way 
examples show monadic definition tasks gives frob scheduling tasks constructing plans building complex tasks simpler ones 
mathematical nature frob haskell easier reason programs program 
systems fvision depend frp easily integrated frob frame 
weaknesses frob functional language drawbacks garbage collection decrease performance real time applications 
fact going frp constructs transforming frp programs languages java 
ideal solution develop programs frob advantages functional programming directly encoding automatically translating low level language 
concurrency frob having tasks control different effectors run simultaneously 
type system haskell allow point detect tasks try effector 
kind concurrency powerful model interactions tasks 
interruptions sending messages tasks generally indirectly expressed current frob impossible cases 
seperate exception abstraction frob termination criteria task modified adding events 
generally adequate cases continuation coded conflict modularity 
similarly having global database shared tasks ability refer tasks names useful languages 
frob functional style results slightly complicated code 
rajeev alur radu grosu hur vijay kumar lee 
modular specification hybrid systems charon 
pages 
rodney brooks 
robust layered control system mobile robot 
ieee journal robotics automation april 
rodney brooks 
integrated systems behaviors 
sigart bulletin 
marchand marchand rutten chaumette 
specifying verifying active vision robotic systems signal environment 
international journal robotics research april 
conal elliott 
modeling interactive multimedia animation embedded language 
proceedings conference domain specific languages pages 
usenix october 
firby 
task networks controlling continuous processes 
proc 
second int 
conf 
ai planning systems chicago il 
firby 
modularity issues reactive planning 
proc 
third int 
conf 
ai planning systems 
le guernic gauthier le le 
programming real time applications signal 
proceedings ieee volume 
hager peterson 
transformational approach design robot software 
robotics research ninth international symposium pages 
springer verlag 
vincent hayward richard paul 
robot manipulator control unix robot control library 
international journal robotics research winter 
hudak fasel 
gentle haskell 
acm sigplan notices may 
hudak gadde 
haskore music notation algebra music 
journal functional programming may 
ingrand chatila alami robert 
prs high level supervision control language autonomous mobile robots 
proc 
ieee international conf 
robotics automation usa 
ingrand rao 
architecture real time reasoning system control 
ieee expert 
kurt konolige 
language reactive control 
technical report sri interna tional june 
kurt konolige karen myers ruspini 
architecture design autonomy 
journal experimental theoretical artificial intelligence 
lyons 
representing analyzing action plans networks concurrent processes 
ieee transactions robotics automation june 
lyons arbib 
formal model computation sensory robotics 
ieee transactions robotics automation june 
peterson hager hudak 
language declarative robotic programming 
proceedings ieee conf 
robotics automation may 
peterson hudak elliott 
lambda motion controlling robots haskell 
proc 
st international conference practical aspects declarative languages padl pages january 
peyton jones ed 
haskell non strict purely functional language 
technical report rr yale university february 
reid peterson hudak hager 
prototyping real time vision systems experiment dsl design 
proc 
st international conference software engineering icse may 
santos jose castro isabel ribeiro 
nested loop architecture mobile robot navigation 
international journal robotics research december 
simmons 
task description language robot control 
proceedings conference intelligent robotics systems 
wan paul hudak 
functional reactive programming principles 

