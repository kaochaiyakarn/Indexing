proportional share resource allocation algorithm real time time shared systems ion stoica hussein abdel kevin jeffay sanjoy baruah johannes gehrke greg plaxton propose analyze proportional share resource allocation algorithm realizing real time performance time shared operating systems 
proportional share system processes assigned weight determines share percentage resource receive 
resource allocated discrete sized time quanta manner process progress precise uniform rate 
proportional share allocation algorithms interest provide natural means seamlessly integrating real non real time processing requirements general purpose operating system easy implement particular easier traditional forms real time support periodic tasks provide simple effective means precisely controlling real time performance process including uniform predictable degradation times system overload provide natural mean policing processes process resource request ill effect behaved processes 
algorithm analysis context idealized system resource assumed granted arbitrarily small intervals time show algorithm guarantees difference service time process receive idealized system service time receives real system bounded size time quantum 
demonstrates algorithm capable guaranteeing real time response times processes 
show bound best obtainable proportion share system algorithm provides optimal performance 
lastly algorithm provides support dynamic operations processes joining leaving competition fractional non uniform time quanta 
proof concept implemented prototype cpu scheduler freebsd operating systems 
experimental results shows implementation perform theoretical bounds supports real time execution general purpose operating system 
modified june 
supported fellowship 
dept cs old dominion univ va stoica cs edu 
supported nsf ccr 
dept cs old dominion univ va cs edu 
supported ibm intel corps nsf ccr 
dpt 
cs univ north carolina chapel hill chapel hill nc jeffay cs unc edu 
supported nsf research initiation award ccr 
dept cs univ vermont vt sanjoy cs uvm edu 
dpt 
cs univ wisconsin madison madison wi johannes cs wisc edu 
supported nsf ccr texas advanced research program 
arp 
dpt 
cs univ texas austin austin tx plaxton cs utexas edu 
currently great interest providing real time execution communication support general purpose operating systems 
applications desktop videoconferencing distributed shared virtual environments collaboration support systems require real time computation communication services effective 
dominant approach providing real time support general purpose operating system embed periodic thread process model existing operating system kernel real time scheduling algorithm rate monotonic scheduling schedule processes 
system aperiodic non real time activities typically scheduled background processes second level scheduler executed quasi periodically server process real time scheduler 
general framework quite effective integrating real time non real time computing 
observe approach embraced larger operating systems community 
believe due part rigid distinctions real time non real time 
real time activities programmed differently non real time ones periodic tasks real time activities receive hard fast guarantees response time admission control performed 
non real time activities real time ones receive performance guarantees 
state affairs entirely acceptable mixes real time non real time activities 
example consider problem supporting real time videoconferencing desktop 
clearly real time application hard fast guarantees real time performance required 
example easy imagine situations explicitly degrade performance videoconference degrade rate video displayed activities searching large mail database particular message complete quicker 
extreme want swap roles processes execute search process real time knowledge number files search precise upper bound completion time search predicted execute video conference background best effort manner 
ideally general purpose operating system supports real time execution priori restrict basic tenor performance guarantees process capable obtaining 
address issue investigating alternate approach realizing real time performance time shared operating systems proportional share resource allocation algorithms processor scheduling 
proportional share allocation system process system guaranteed progress defined uniform rate 
specifically process assigned share processor percentage processor total capacity 
process share processor interval length process guaranteed receive theta sigma ffl units processor time ffl ffi constant ffi proportional share system resource allocation flexible share processor process receives changed dynamically 
manner process real time rate progress explicitly controlled 
proportional share resource allocation algorithms lie traditional general purpose realtime scheduling algorithms 
hand proportional share resource allocation variant pure processor sharing scheduling discipline commonly studied introductory operating systems courses 
pure processor sharing processes system time unit process receives processor capacity 
process appears making uniform progress virtual processor capacity physical processor 
hand traditional real time scheduling disciplines periodic tasks viewed coarse approximations proportional share resource allocation 
example periodic task requires units processor time time units rate monotonic scheduler guarantees interval kp periodic task receive share processor equal specifically intervals process receive pc units processor time 
key distinctions proportional share resource allocation policy develop pure processor sharing discipline discrete approximation generalization pure processor sharing discipline 
pure processor sharing discipline theoretically ideal algorithm allocates arbitrarily fine fractional time units processes proportional share algorithm allocates discrete units shared resource processes 
system process progress perfect uniform rate 
main result time interval deviation service time received process shared resource service time process received making progress uniform rate bounded 
show bounds obtain scheduling algorithm optimal sense possible develop proportional share algorithm provides better bounds 
means analyze real time performance process system 
addition changing scheduling parameters precisely control real time performance process 
proportional share resource allocation policy differs traditional methods integrating non real time processes processes real non real time treated identically 
proportional share system real time non real time processes implemented traditional processes time shared operating system 
terms process model special support required support real time computing type process 
shall see proportional share resource allocation algorithms scheduling algorithms time shared systems allocate resources discrete units quanta easier realize time shared operating systems traditional real time policies typically event driven require ability preempt processes potentially arbitrary points 
addition resources allocated discrete quanta proportional share system better control account overhead scheduling mechanism tune system trade fine grain real time control low scheduling system overhead 
proportional share algorithms provide natural means uniformly degrading system performance overload situations 
proportional share processor scheduling algorithm demonstrate ensure predictable real time response processes 
section presents process model formally introduces concepts share requirement predictable execution respect share 
section discusses related scheduling 
section presents virtual time scheduling algorithm ensure processes receive requested share processor 
section introduces key technical problem solved course applying algorithm dealing dynamic creation destruction processes 
events significant indicate points time share processor received active process real time rate progress potentially changes 
section outlines proof correctness algorithm section presents experimental results proportional share system freebsd operating system 
particular demonstrate traditional real time processes periodic tasks realized proportional share system 
model consider operating system consist set processes real time non real time compete time shared resource cpu communications channel 
avoid confusion terminology experimental section term client refer computational entities processes 
client said active competing resource passive 
assume resource allocated time quanta size time quantum client selected resource 
client acquires resource may entire time quantum may release time quantum expires 
simple model captures basic mechanisms traditionally sharing common resources processor communication bandwidth 
example preemptive operating systems unix windows nt cpu scheduler allocates processing time competing processes fashion process uses cpu time quantum expires process higher priority active may voluntarily release cpu waiting event occur operation complete 
example consider communication switch multiplexes set incoming sessions packet packet basis 
usually transmission packet preempted take time quantum time required send packet output link 
case size time quantum represents time required send packet maximum length 
associate client weight determines relative share resource receive 
denote weight associated client set clients active time define instantaneous share active client time client share remains constant time interval deltat entitled resource deltat time units 
general client share varies time service time client receive perfect fair system active time interval time units 
equation corresponds ideal fluid flow system resource granted arbitrarily small intervals time unfortunately practical situations possible 
reasons overhead introduced scheduling algorithm overhead switching client time quanta order magnitude overheads drastically reduce resource utilization 
reason operations interrupted started complete time quantum 
example communication switch begins send packet session serve session entire packet sent 
example process preempted critical section 
example chose size quantum time required send packet maximum length second example chose maximum duration critical section 
due quantization system resource allocated discrete time quanta possible client receive exactly service time entitled 
difference similar model demers studying fair queuing algorithms communication networks 
service time client receive time service time receives called service time lag simply lag 
time client active service time client receives interval assume client active entire interval 
lag client time lag gamma lag quantifies allocation accuracy main parameter characterizing proportional share algorithm 
particular show proportional share algorithm provides bounded lag clients bound optimal sense possible develop algorithm affords better bounds 
properties indicate algorithm provide real time response guarantees clients respect class proportional share algorithms guarantees best possible 
related formulate analyze proportional share allocation problem 
original problem stated terms selecting union chairman year accumulated number chairmen state union proportional weight 
shown results easily applied solve proportional share allocation problem 
general setting resource allocated fixed time quanta clients shares may change time quantum 
way dynamic operation easily accommodated 
proved clients shares known advance exists schedule lag bound equal gamma gamma represents total number clients 
note lag bound approaches unity 
gives optimal algorithm static case number clients change time give explicit algorithm dynamic case 
furthermore note general setting problem formulation accommodate fractional non uniform quanta 
proportional share allocation problem received great deal attention context various resources communication bandwidth processor time 
algorithm closely related weighted fair queueing algorithms previously developed bandwidth allocation communication networks general purpose proportional share algorithms stride scheduling :10.1.1.138.3502
demers keshav shenker apply notion fairness system models idealized communication switch sessions serviced arbitrarily small increments 
practice packet transmission preempted authors proposed algorithm called packet fair queueing packets serviced order finish corresponding fluid flow system increasing order virtual deadlines 
concept virtual time previously introduced zhang parekh gallager analyzed algorithm input traffic stream conforms leaky bucket constraints 
particular shown packet serviced tmax serviced fluid flow system tmax represents time transmit packet maximum size 
note translates bound positive lag 
shown bound negative lag large represents number active sessions known packet packet generalized processor sharing pgps short 
clients system 
virtual time updated client joins leaves competition ideal system real 
requires maintain additional event queue implementation complex inefficient 
solution golestani proposed new algorithm called self clocked fair queueing virtual time updated client joins leaves competition real system idealized 
scheme efficiently implemented come free lag bounds increase factor ones guaranteed 
note dynamic operations client leaving joining competition implemented log time 
waldspurger weihl developed new proportional share allocation algorithm called stride scheduling viewed cross application fair queueing domain processor scheduling :10.1.1.138.3502
stride scheduling relies concept global pass similar virtual time measure progress system 
client associated stride inversely proportional weight pass measures progress client 
algorithm allocates time quantum client lowest pass similar policy 
grouping clients binary tree recursively applying basic stride scheduling algorithm level lag reduced logn 
stride scheduling provides support uniform non uniform quanta 
goyal guo vin proposed new algorithm called start time fair queueing hierarchically partitioning cpu various application classes 
algorithm supports uniform non uniform quanta delay bound implicitly lag increases linearly number clients 
note number clients small terms delay algorithm superior classical fair queueing algorithms 
contrast algorithms making virtual eligible times virtual deadlines achieves constant lag bounds providing full support dynamic operations 
note similar algorithms independently developed parallel original bennett zhang context allocating bandwidth communication networks baruah gehrke plaxton context processor scheduling fixed time quanta 
addition introducing concept virtual eligible time independently introduced unique key contributions 
best knowledge analyze general case size request decoupled size time quantum 
generalizing previous results analyze easily extended preemptive systems 
example time quanta arbitrarily small derive lag bounds fully preemptive system 
similarly size time quantum maximum duration critical region derive lag bounds preemptive system critical regions 
decoupling request size size time quantum client possibility trade allocation accuracy scheduling overhead 
second address problem client leaving competition entire service time requested 
important extension processor case hard impossible predict exactly service time client request 
note problem occur networking case length message transmission time assumed known arrival 
previous known algorithms viewed direct extension dynamic case 
address problem lottery stride scheduling :10.1.1.138.3502
lag bounds guaranteed stride scheduling large represents number active clients randomized algorithm lottery guarantee tight bounds 
comparison guarantees optimal lag bounds time quantum 
third propose new approximation scheme virtual time updating operations performed events client leaving joining occur real system ideal 
simplifies implementation eliminates need keeping event queue 
worth mention previous approximations maintains tight bounds client lag 
class fair queuing algorithms significant number proportional share algorithms developed :10.1.1.129.159
guarantees constant lag bounds dynamic system note pd algorithm baruah gehrke plaxton achieves constant lag bounds static system system number clients change 
idea apply fair queueing algorithms processor scheduling suggested parekh 
waldspurger weihl develop implement algorithm stride scheduling processor scheduling :10.1.1.138.3502
best knowledge implement test proportional share scheduler guarantees constant lag bounds 
algorithm order obtain access resource client issue request specifies duration service time needs 
client request fulfilled may issue new request passive 
uniformity assume client sole initiator requests flexibility allow requests duration 
note client may request amount service time generating fewer longer requests shorter ones 
example client may ask minute computation time issuing requests duration second issuing requests duration ms 
show section shorter requests guarantee better allocation accuracy longer requests decrease system overhead 
way client trade allocation accuracy scheduling overhead 
clarify ideas briefly point similarities differences model known problem scheduling periodic tasks real time system 
periodic task characterized fixed interval time consecutive events called period denoted maximum service time required process event 
event occurs task simply requests service time units processing event 
central requirement real time systems current event processed event occurs 
notice requirement guarantees task receives service time units period consequently case task receives share resource 
giving share requested service time time event occurs deadline corresponding request note applied stride scheduling shared resources lock access 
practice necessarily true 
example processor case scheduler issue requests behalf client 
case request duration length specified client scheduler assumes default duration 
allows treat continuous media interactive batch activities consistent way 
expressed similarly model giving time request duration obtain time client receive requested service time ideal system solving equation 
share client change interval eq 
follows theta gamma obtain identical expression request deadline case scheduling periodic tasks 
problem scheduling periodic tasks viewed particular case proportional share allocation problem share client fixed client requests duration 
major difference model real time system note real time system request assumed generated result external event packet arrival time model request generated result external event client enters competition result internal event client generates new request current fulfilled 
way model provides integrated support event driven applications continuous media interactive applications conventional batch applications 
formulate scheduling algorithm terms behavior ideal fluid flow system executes clients virtual time time domain 
abstractly virtual fluid flow system executes client real time time units virtual time time unit 
concretely virtual time defined function real time note virtual time increases rate inversely proportional sum weights active clients 
competition increases virtual time slows competition decreases accelerates 
intuitively flow virtual time changes accommodate active clients virtual time time unit 
size virtual time unit modified corresponding fluid flow system active client receives real time units virtual time time unit 
example consider clients weights 
rate virtual time increases virtual time time unit equals real time units 
virtual time time unit clients receive time units 
ideally proportional share algorithm approach behavior virtual fluid flow system 
fluid flow system points time client best characterized service time received current time compare approach ideal able compute service time client receive fluid flow system 
combining eq 
express service time active client receive interval integral equation computed easily determine service time client receive interval simply multiplying client weight integral value 
eq 
follows gamma note waldspurger weihl similar concept denoted global pass stride scheduling :10.1.1.138.3502
better interpret equation consider simpler model number active clients constant sum weights share client model service time client receive interval simply gamma notice replacing real times corresponding virtual times arrive eq 

eq 
viewed generalization computing service time dynamic system clients dynamically joining leaving competition created destroyed 
scheduling algorithms uses measurements virtual time domain scheduling decisions 
client request associate eligible time deadline represent starting finishing time respectively request service corresponding fluid flow system 
time client active time initiates new request 
request eligible time service time client receive corresponding fluid flow system equals service time client received real system 
note time client received service time supposed receive lag case client wait time new request eligible 
way client received service time share slowed giving active clients opportunity catch 
hand time client received service time supposed receive lag positive case new request immediately eligible time eq 
express virtual eligible time similarly deadline request chosen service time client receive eligible time deadline equals service time new request represents length new request 
eq 
derive virtual deadline notice eq 
give virtual eligible time virtual deadline necessarily give values real times see consider case larger current time computed exactly eq 
know slope virtual time mapping vary changes dynamically clients join leave competition 
formulate algorithm terms virtual eligible times deadlines real times 
earliest eligible virtual deadline algorithm simply stated follows algorithm 
new quantum allocated client eligible request earliest virtual deadline 
similar stride scheduling algorithm assume client service time requested :10.1.1.138.3502
important feature differentiates weighted fair queueing algorithms allocating bandwidth communication networks assume length packet service time known packet arrives 
communication networks realistic assumption processor scheduling harder impossible predict exactly amount service time client 
show section compromise fairness 
intuitively results definition virtual eligible time client uses service time requested virtual eligible time request pushed backwards 
way provides direct support non uniform quanta formulated terms virtual times remaining vd denote virtual eligible time virtual deadline respectively corresponding real eligible time deadline 
denote length th request client vd denote virtual eligible time virtual deadline associated request 
client uses time entire service time requested eq 
obtain recurrence computes virtual eligible time virtual deadline request vd vd consider general case client entire service time requested 
client receives service time requested need consider case client uses resource time requested 
denote service time client receives th request 
change eq 
computing eligible time new request 
specifically eq 
replaced example 
fix ideas take simple example see 
consider clients weights issue requests lengths respectively 
assume time quantum unit size client enters competition real time 
eq 
virtual eligible time request client virtual deadline vd 
single client outstanding eligible request client receives quantum 
real time client enters competition 
interval active client system client eq 
value virtual time real time 
virtual time increases half rate real time 
way ideal system virtual time time unit client receives real time units 
second client enters competition rate virtual time slows 
ideal system virtual time time unit client receive real time units 
assume client issues request just second quantum allocated 
real time pending requests usually algorithms take packet arrival time time bit packet received 
notice provides support fractional quanta simply time request equal desired fraction time quantum 
difference fractional non uniform quanta case fraction time quantum client assumed known advance non uniform quanta case fraction known 
client client virtual time time example scheduling involving clients equal weights 
requests generated client length requests generated client length 
client active time virtual time client active time 
vertical arrows represent times requests initiated pair associated arrow represents virtual eligible time virtual deadline corresponding request 
shaded regions background show durations servicing successive requests client fluid flow system note starting finishing times servicing request ideal system corresponds virtual eligible time virtual deadline corresponding request 
client virtual deadline waits time quantum fulfill request client virtual deadline 
situation arbitrarily break tie favor client receives second quantum 
quantum fulfills current request client client issues immediately real time virtual time new request 
eq 
virtual eligible time virtual deadline new request respectively 
real time virtual time single eligible request client receives quantum 
real time virtual time eligible requests client just eligible new request issued client 
virtual deadline second client request earlier client fourth quantum allocated client 
shows quanta allocated 
note uniform progress clients 
uniformity perfect contrived example show fact deviation client progress perfectly uniform rate rate progress ideal fluid flow system bounded bounds best possible 
shows quanta algorithm provides best possible guarantees real time progress 
fairness dynamic systems section address issue fairness dynamic systems 
assume dynamic system provides support operations client joining client leaving competition idealized fluid flow system supporting dynamic operations trivial time lag active client zero 
unfortunately system service time allocated discrete time quanta longer true 
understand problem recall client lag represents see eq 
difference service time client receive service time received 
show appendix lemma important property algorithm time sum lags active clients zero 
means time interval total service time active clients receive equals service time clients received 
client leaves competition negative lag receiving service time supposed remaining clients received service time entitled 
short gain client translates loss active clients 
similarly client positive lag leaves translates gain remaining clients 
question distribute loss gain remaining clients 
question answered distributing proportion clients weights 
remaining section show answer obtained approaching problem different angle 
basic observation problem occur long clients leave competition zero lag distribute 
corresponding fluid flow system lag client zero simple solution consider time client leaves time leaves fluid flow system real system 
unfortunately dynamic system client may leave time entire service time requested approach 
see consider client positive lag leaves competition 
case corresponding time client left ideal system smaller time leaves real system 
may appear possible solution undo modifications occurred system times 
example undo fact client received service time 
solution dynamic system reasonable restrictions hold 
clients join competition assumed zero lag 
lag client leaves preserved eventually rejoins competition 
alternatively restriction interpreted saying client leaves competition considered terminated 

client leave competition soon finished resource client terminates allowed remain system 
consider cases client lag negative positive 
eq 
follows client lag increases long client receive service time decreases 
client negative lag wants leave simply delay client allocating service time lag zero 
simply accomplished generating dummy request zero length 
note request processed eligible virtual eligible time dummy request equal deadline see eq 
request processed earlier deadline 
way reduced case second note having operation changing client weight easily implemented leave followed re join operation 
note system client uses entire service time compute advance time request issued virtual time client leave competition 
fact solution proposed parekh gallager implement generalized processor sharing algorithm 
time virtual time time client client client client client client virtual time clients active time client client positive lags leave competition 
clients allowed leave lags zero clients allowed leave immediately 
shaded regions represents time intervals system allocates service time clients positive lag want leave delaying departure system lags zero 
cases virtual time just client wants leave just left equal 
client leaving competition positive lag 
consider case 
solution simple idea client delayed lag zero 
case client lag positive order achieve need allocate service time client 
clarity consider example clients simultaneously active 
suppose time client decides leave competition having positive lag 
client simply delayed continuing receive service time lag zero time assume slope virtual time respect real time change eq 
obtain gamma gamma 
eq 
fact gamma compute virtual time lag main drawback approach client continues receive service time need finished resource service time wasted unacceptable 
alternative client positive lag leave immediately correctly updating value virtual time account change see 
way virtual times corresponding times client decides leave leaves systems 
precisely consider client leaving competition time positive lag lag 
generalizing eq 
value virtual time updated follows lag tk represents set active clients just client leaves 
example 
fkg represents set active clients just client leaves competition 
note eq 
lag remaining client fkg changes lag lag lag tk lag client proportionally distributed remaining clients consistent interpretation fairness dynamic systems gain loss proportionally distributed remaining clients 
virtual time updated events occur real system opposed occur ideal algorithm easily efficiently implemented 
note system service times known advance packet transmission times communication switches theoretically possible update virtual time ideal system practice hard achieve 
mainly need implement event queue trade timer granularity overhead 
shown basic operation required implement algorithm inserting deleting request finding eligible request earliest deadline implemented log represents number active clients 
note worst case may possible dummy requests occur time 
situation scheduler perform deletions real request serviced 
potential problem case communication switch selection packet serviced assumed done transmission current packet significantly increase complexity processor case 
mainly processor servicing active clients processes executes scheduling algorithm related operating system functions starting new process terminating existing 
consequently complete model need account overheads 
simple solution charge process related overheads 
example time select process receive time quantum charged client 
way processor perspective dummy request longer duration request account scheduling overhead eventually process termination 
obviously raises problem determining actual processing time received client 
point dummy requests complicate problem significant way difference process eventually charged slightly 
current model ignore overheads experimental results suggest see section acceptable approximation practical situations 
plan address aspect 
fairness analysis proportional share scheduling algorithm proposed executes clients precise rate 
determine client desired real time response time property simply computing amount service time receive interval time interest eq 

service time allocated discrete quanta computation client lag difference service time client received ideal system service time receives real system 
order proportional share algorithm real time computing demonstrate lag incurred client bounded times 
done 
problem stated demonstrating algorithm fair sense clients progress weights 
demonstrating lag client bounded times conclude algorithm fair 
sketch argument lags bounded 
complete proof result appendix 
theorem shows request fulfilled time units deadline corresponding fluid flow system represents maximum size time quantum 
theorem gives tight bounds lag client system clients join leave competition zero lags 
similarly theorem gives tight bounds client lag system client positive lag may leave time recall previous section case client negative lag leaving competition easily reduced case client positive lag leaves competition 
corollary show dynamic system client request larger maximum size time quantum lag client bounded result optimal respect proportional share algorithm 
defining formally systems analyzing 
definition steady system system short system lag client joins leaves competition zero 
definition formal characterization system described section see 
definition pseudo steady system ps system short system lag client joins zero lag client leaves positive 
client positive lag leaves value virtual time updated eq 

theorem gives upper bound maximum delay fulfilling request system 
note result similar obtained parekh gallager generalized processor sharing algorithm communication network packet guaranteed deadline time required send packet maximum length 
theorem deadline current request issued client system quantum actual time request fulfilled 
request fulfilled time lag theorem gives tight bounds client lag system 
theorem size current request issued client system quantum lag client time request pending bounded follows gammar lag max bounds asymptotically tight 
notice bounds theorem apply independently client depend length requests 
shorter requests offer better allocation accuracy longer ones reduce system overhead total service time fewer requests need generated 
possible trade accuracy system overhead depending client requirements 
example intensive computation task acceptable take length request order seconds 
hand case multimedia application need take length request greater tens milliseconds due delay constraints 
theorem shows accommodate clients different requirements guaranteeing tight bounds lag client independent clients 
theorem shows true ps systems 
case lag client large maximum request issued client system 
theorem size current request issued client ps system quantum lag client time request pending bounded follows gammar lag max rmax rmax represents maximum duration request issued client system 
bounds asymptotically tight 
corollary follows directly theorems 
corollary request client larger time quantum time lag bounded follows gammaq lag note simple lemma proof bounds corollary optimal hold proportional share algorithm 
lemma system time quanta size proportional share algorithm lag client asymptotically bounded gammaq experimental results proof concept implemented cpu scheduler prototype algorithm freebsd 
experiments run pc compatible mhz pentium mb ram 
scheduler time slice quantum duration client request set ms excepting cpu scheduler alter freebsd kernel 
scheduler original freebsd scheduler 
processes request proportional share reservation services assigned reserved user level priority handled scheduler 
processes scheduled regular freebsd scheduler 
way kernel processes scheduled process proportional share reservation class 
freebsd lacks real time support preemptive kernel page pinning experiments tried avoid possible interaction kernel 
example sure measurements performed entire program loaded memory exception gettimeofday function time measurements system function running experiments data fact perform experiments top largely unmodified general purpose operating system indicates fit proportional share resource allocation scheme advocate general purpose operating system design 
time msec 
client client client time msec 
client client client plots number iterations second period clients weights respectively plots clients lags interval 
recorded memory saved experiment 
addressing issues class manner serve improve results 
applications performs arithmetic computations 
iteration takes close ms experiment run copies program assigning copy client different weight 
experiment run clients processes weights respectively 
clients synchronized start actual computation time 
shows number iterations executed client second 
solid lines depict ideal number iterations client 
seen number iterations performed client closed ideal 
particular note client weight executes number iterations client weight rate client weight 
depicts lag client interval 
note lags ms consistent bounds corollary section 
client executing rate precise afford ability predict performance real time modulo ms interval 
example assume client experiment audio player receives plays audio samples minute remote site 
assume computational cost playing audio sample ms traditional real time system client modeled periodic task period ms cost ms proportional share system client generic process repeatedly requests execution play audio sample request having duration ms client needs execute ms ms needs receive share processor equal processor total capacity 
clients processes system weights respectively ensure client executes properly assign weight share processor case weight ensure client receives appropriate share processor executes appropriate period ms client receives share processor request execution completed time units 
times client guaranteed received ms service time requested 
time msec 
reg 
reg 
reg 
reg 
client client client time msec 
lag msec 
client client client plots number iterations clients weights respectively 
client performs iterations 
clients begins time client delayed ms 
plots clients lags 
quanta example duration client request execution times client guaranteed processed sigma audio samples 
times client real time performance measured terms number audio samples played sample ideal real time execution 
difference ideal real time execution proportional share execution large small desired adjusting quanta shared resource allocated 
example illustrates power proportional share resource allocation system 
proportional share system adjust weight client needed new clients enter leave competition achieve constant real time performance leave client weight constant allow client performance proportionally improve degrade clients come go 
case ensure constant real time performance long set active clients requiring constant performance cumulatively request shares processor greater long clients utilize processor 
case graceful uniform predictable degradation improvement possible system loads 
periodic task scheduling systems allocation done terms discrete quanta client executes long slows 
clients effected 
process may consume greater share processor requested 
client executes longer duration requested preempted current quantum expires scheduling continues normal 
process misbehaves effect rate progress process 
addition benefits proportional resource allocation systems provide natural means policing tasks 
second experiment consider clients weights respectively dynamic scenario 
clients execution time client delayed ms client performs iterations leaves competition 
shown distinct regions 
region ms active clients 
client having weight receives percent cpu client having weight receives cpu 
consequently ms client completes iterations client completes iterations 
ms client joins competition second region ms clients active 
time ms client finishes iterations leaves competition 
region clients remains active 
time ms client finishes client remain active region 
depicts clients lags theoretical bounds ms notice sum lags zero lemma implies see appendix 
mainly elapsed times measured kernel level scheduling equal times measured process level 
reason kernel level elapsed times include context switching various scheduling related overheads 
second reason inaccuracy measurements due system call 
described new proportional share resource allocation scheduler provides flexible control provides strong timeliness guarantees service time received client 
way provide unified approach scheduling firm real time interactive batch applications 
achieve uniformly converting application requirements regardless type sequence requests resource 
algorithm guarantees difference service time client receive idealized system service time receives real system bounded time quantum bound optimal 
best knowledge algorithm achieve bounds dynamic system provides support fractional non uniform quanta 
proof concept implemented prototype cpu scheduler freebsd operating system 
experimental results shows implementation performs theoretical bounds 
baruah gehrke plaxton fast scheduling periodic tasks multiple resources proc 
th international parallel processing symposium april pp 

baruah gehrke plaxton fair line scheduling dynamic set tasks single resource technical report tr department computer science university texas austin 
february 
bennett zhang wf worst case fair queueing infocom san francisco march 
demers keshav analysis simulation fair queueing algorithm journal internetworking research experience october pp 

golestani self clocked fair queueing scheme broadband applications proc 
ieee infocom april pp 

leffler mckusick karels quarterman 
design implementation bsd unix operating system addison wesley 
liu layland scheduling algorithms multiprogramming hard real time environment journal acm vol 
january pp 

maheshwari charged proportional scheduling technical memorandum mit lcs tm laboratory cs mit july 
parekh gallager generalized processor sharing approach flow control integrated services networks single node case acm ieee transactions vol 
pp 

parekh generalized processor sharing approach flow control integrated services networks ph thesis department ee cs mit 
stoica abdel new approach implement proportional share resource allocation technical report tr cs dpt april pp 
available www cs edu stoica pubs html stoica abdel earliest eligible virtual deadline flexible accurate mechanism proportional share resource allocation technical report tr cs dpt november pp 
available www cs edu stoica pubs html assignment problem discrete mathematics vol 
pp 

waldspurger weihl 
lottery scheduling flexible proportional share resource management proc 
symposium operating system design implementation november pp 

waldspurger weihl 
stride scheduling deterministic proportional share resource technical memorandum mit lcs tm laboratory cs mit july 
waldspurger 
lottery stride scheduling flexible proportional share resource management phd thesis technical report mit lcs tr laboratory cs mit september 
zhang new traffic control algorithm packet switched networks acm transactions computer systems vol 
may pp 

appendix appendix prove main results section 
lemma gives eligibility condition client request 
lemma active client positive lag time lag current pending request eligible 
proof 
length request issued client pending time recall active client pending request denote virtual eligible time request 
sake contradiction assume request eligible time 

time request issued 
eq 
gamma request eligible follows client received service time 
eq 
obtain lag gamma gamma gamma gamma gamma gamma contradiction proves lemma 
lemma fact zero sum positive term corollary set active clients time lag eligible request time lemma shows time sum lags active clients zero 
immediate consequence result corollary time active client pending eligible request system 
sense definition algorithm conserving long active clients resource busy 
lemma moment time sum lags active clients zero lag proof 
give outline proof details reader referred 
proof goes induction 
assume time active client eq 
trivially true 
show eq 
remains true events occur client joins competition ii client leaves competition iii client changes weight 
show iv interval events occurs eq 
holds time holds time lemma eligible time request issued client lag proof 
time client issues request 
assume request eligible time client receive service time 
hand request eligible time 
eq 
obtain lag gamma gamma gamma gamma completes proof 
giving theorem note eq 
client active interval lag lag gamma theorem deadline current request issued client system quantum actual time request fulfilled 
request fulfilled time lag proof 
eligible time request deadline issued client assume request fulfilled time theorem trivially true 
latest time greater client deadline greater starts receive time quantum 
time finishes receive quantum 
case exists 
shown consider partition active clients time sets containing clients active time request deadline larger note containing clients deadlines larger note 
show clients negative lags 
contradiction assume client lag 
lemma pending request client eligible time client scheduled time request larger deadline deadline request client contradicts assumption 
lag sum lags active clients zero lemma lag consider facts 
excepting client deadline greater receives service time 
maximum size time quantum service time received client 
clients leave join competition zero lags 

consists clients active time clients join competition issuing request deadline larger client 




client current pending request client eligible time deadline set contains clients active time deadlines larger set contains clients including client active time latest time client receives service time 
follows entire service time received clients eq 
fact lag client increases long receive service time shown lag gammaq 
lemma obtain lag deadlines requests issued clients smaller consequently smaller follows request issued client fulfilled deadline 
recall request fulfilled deadline means received service time supposed lag positive 
time clients positive lags ineq 
lag proves second part theorem 
prove part 
deadline definition recall request client fulfilled deadline lag represents remaining service time fulfill request 
virtual time increases monotonically remaining service time decrease deadline client smaller follows time lag client larger remaining service time required fulfill client request 
consider sub cases sub case eq 
lag client deadline larger receive time quantum requests clients satisfied time units necessary satisfy requests follows time requests including client satisfied 
second sub case note pending request client eligible time larger client scheduled time deadline smaller virtual time eq size request issued client gamma gamma easy show sum outstanding requests issued clients larger gamma consequently requests clients including client fulfilled gamma time gamma proof follows 
case exist 
take assume empty case empty reduces trivially case 
client receives service time lag lag proof proceeds similar previous case difference case show request issued client fulfilled deadline theorem size current request issued client system quantum lag client time request pending bounded follows gammar lag max bounds asymptotically tight 
proof 
eligible time deadline arbitrary request duration issued client client lag increases long client serviced decreases see eq 
request serviced eligible easy see lag minimized client receives entire service time soon request eligible 
words minimum lag occurs time request fulfilled time 
request pending eq 
lag lag lag gamma gammas gammar client positive lag eligible see lemma prove right hand side ineq 
consider times larger equal time request pending consider cases case eq 
lag gamma gamma second case theorem directly lag combining inequality ineq 
obtain 
show bound lag gammar asymptotically tight consider example 
weights active clients suppose clients active time requests lengths respectively 
assume chosen virtual deadline client request smaller virtual deadline second client request client receives entire service time client eq 
lag gamma eq 
obtain approaches zero consequently lag approaches gammar proof lag max similar omit 
theorem size current request issued client ps system quantum lag client time request pending bounded follows gammar lag max rmax rmax represents maximum duration request issued client system 
bounds asymptotically tight 
proof 
basic idea reduce ps system equivalent system intuitively system derived simply stretching time axis client strict positive lag leaves competition system example see figures 
formally system defined follows 

time time delta denotes clients positive lags leave competition system delta represents service time client receives leaving competition lag zero 

client zero lag joins leaves competition time client joins leaves time 
client strict positive lag leaves time leaves time delta lag zero 
note reduction implicitly restriction section restriction client leaves competition holds shared resource 
show lag active client time equal lag client time results easily observing virtual time time system equal virtual time time system service time client active time receives equal service time receives 
note client leaves positive lag receives extra delta service time 
eq 
lags equal 
reduced problem computing lags bounds system computing bounds system consider request virtual eligible time virtual deadline issued client system show request fulfilled time lag rmax proof similar proof second part theorem followings notations theorem 
difference case consider sub case latest client deadline larger receives service time starting client strict positive lag wants leave competition 
notice time larger client scheduled time request client earlier deadline follows smaller deadline client lag rmax lag client decrease lag time zero client leaves competition client receives service time eq 
show lag gammar max lemma lag rmax clients positive lags time obtain eq 

proof similar theorem omit 
eq 
lag 
leaves competition longer belongs session receive service time result lags increase 
yields lag lag 
leave competition time lag lag lag obtain lag lag gamma lag lag lag 

