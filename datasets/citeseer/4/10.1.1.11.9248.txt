binary rewriting defense stack buffer overflow attacks prasad tzi cker chiueh computer science department state university new york stony brook stony brook ny cs sunysb edu buffer overflow attack common arguably dangerous attack method internet security breach incidents reported public literature 
various solutions developed address buffer overflow vulnerability problem research commercial communities 
solutions provide adequate protection buffer overflow attacks implemented compiler extensions require source code programs protected available re compiled 
requirement reasonable cases scenarios feasible legacy applications purchased outside vendor 
reported explores application static binary translation protect internet software buffer overflow attacks 
specifically binary rewriting approach augment existing win intel portable executable pe binary programs return address defense rad mechanism protects integrity return address stack redundant copy 
presents disassembly instrumentation issues involved static binary translation tool achieves satisfactory disassembly precision presence indirect branches position independent code sequences hand crafted assembly code arbitrary code data mixing ensures safe binary instrumentation practical cases 
reports experiences approach results applying resulting prototype rewriting commercial grade windows applications ftp server telnet server dns server dhcp server outlook express ms ms publisher telnet ftp notepad cl compiler ms ms powerpoint ms access experimentation published buffer overflow exploits 
buffer growth stack growth low address high address direction copy local variables local buffer target unbounded copy pushed callee previous frame pointer pushed call inst local variables function parameters pushed caller return address potentially overwritten stack buffer overflow 
typical stack layout function called stack entries including return address corrupted unsafe copy operation 
buffer overflow attacks exploit particular type program weakness lack array buffer bound check compiler applications 
accordingly ideal solution buffer overflow vulnerability problem build bound checking mechanism compiler require applications strictly follow programming guideline checks bound array buffer access 
solution considered practical point 
promising approach transform application form immune buffer overflow attack requiring modification compiler application 
understand buffer overflow attack consider typical stack layout function called shown 
lack bound checking buffer copy operation causes areas adjacent buffer shown overwritten 
generic buffer overflow attack involves exploiting unsafe copy overwrite return address stack address piece malicious code injected attacker reside stack ret instruction pops return address stack victim function executed program control transferred injected malicious code 
common form buffer overflow attack involves corrupting memory pointer variables stack return addresses 
requirements attack occur 
pointer variable physically located stack buffer overflowed 
overflow bug allows overwriting pointer overflowing user specified data source usually address got entry contains address dynamic library function 
copy function str cpy takes destination user specified data source modified overflow copy 
call common library function printf got entry overwritten 
leveraging unsafe copy attacker overflows overwriting address got entry common library function say printf 
providing address exploit code input safe copy destination attacker managed corrupt got entry printf 
subsequent call printf transfer control exploit code 
form buffer overflow attack overwrites old base pointer stack address malicious code caller function returns control transferred exploit code 
seemingly non stream buffer overflow attacks called effective practical solution protect application programs attacks windows platform 
past approaches protecting programs buffer overflow vulnerabilities relied compiler extensions perform array bounds check prevent return address stack overwritten 
fairly successful preventing conventional buffer overflow attacks approaches require access program source code 
known systems take approach require availability protected application source code 
integrating software protection compiler technically desirable approach exhibits practical limitations 
requiring access source code difficult protect legacy applications source code unavailable various reasons 
second modern software applications tend built third party libraries access source code libraries 
program segments written assembly code directly high level language source code amenable compiler analysis simply exist 
goal describe experiences extent success achieved applying combination known disassembly techniques implement binary rewriting solution aims provide level protection compiler counterpart major technical challenges applying binary rewriting buffer overflow attack problem 
determine insert protection instructions boundary function input program needs clearly identified turns requires accurate disassembler correctly decode instruction executable binary 
unfortunately disassembly accuracy difficult problem distinguishing code data embedded code regions fundamentally undecidable 
second function boundaries successfully identified inserting protection code binary disturbing addresses existing instructions non trivial 
main problem cases possible binary spare space hold jump instruction inserted protection code hold protection code 
section surveys related areas static binary translation buffer overflow defense 
section discusses design implementation disassembly engine binary instrumentation issues emphasis approaches employ ensure program safety preserve semantics input programs 
section details software architecture implementation binary rewriting rad prototype 
section presents experimental results prototype resistance attacks ability preserve semantics applications space cost performance overheads 
section summarizes main results charts directions research 
related past efforts binary rewriting atom eel run risc architectures disassembly problem simplified due uniform instruction size 
etch tool rewriting win intel pe executables primarily optimization 
works linux binaries albeit limitations respect control flow analysis presence indirect control transfer instructions arbitrary code data mixing 
uqbt architecture independent static binary translation framework migrating legacy applications processor architectures 
galen hunt detours system run time binary interception win functions 
buffer overflow defense proposals involve compiletime analysis transformation 
stackguard microsoft compiler extension place canary words stack local variables return address function prolog monitors return address stack checking integrity canary word epilog 
vulnerable attacks corrupting old frame pointers stack local pointer vari ables 
rad save copy return address prolog compare return address stack epilog 
binary rewriting implementation model buffer overflow defense 
resilient frame pointer attacks vulnerable memory pointer corruption attacks 
ibm gcc extension local variable reordering placing pointer variables lower addresses buffers addition offering protection memory pointer attacks unsafe copy higher lower indices array 
cash perform array bounds check prevent overflow buffers 
cash achieves significant overhead reduction overhead exploiting intel segmentation hardware compared category typically incur high overhead 
proposed approaches protect programs buffer overflow attacks rely run time interception checking 
lucent bell labs intercepts unsafe library calls run time performs bounds checking arguments strcpy check length source string check upper bound length destination string current frame pointer value 
prevents return address modified possible corrupt local pointer variables 
performs dynamic binary translation perform return address check 
suspect incur high overhead adds checking code performs code instrumentation run time 
example applying optimized run time interpretation security problems program shepherding built top dynamic optimization framework called rio 
apart offering advantages complete transparency achieves significant overhead reduction compared expect interpretation emulation system variety optimization techniques viz 
traces interpreted code caching 
best knowledge binary rewriting rad system described attempt employs static binary translation protect existing binaries buffer overflow attacks requiring access source code 
binary rewriting return address defense successful binary rewriting rad system requires identifying boundary procedure input program inserting protection instruction sequence procedure disturbing input binary internal referencing structure 
subsections discuss detail issues associated solutions 
binary disassembly disassembly challenges accurately locate procedure boundary needs identify instruction binary disassembler 
main classes disassembly algorithms 
linear sweep algorithm starts byte code section proceeds decoding byte including intermediate data byte code illegal instruction encountered 
recursive traversal algorithm starts program main entry point proceeds branch instruction encountered depth breadth manner essentially control flow analysis 
approach precise 
chief impediments accurate disassembly 
data embedded code regions 
variable instruction size 
indirect branch instructions 
functions explicit call sites executable code segment 
position independent code pic sequences 
hand crafted assembly code 
render linear sweep algorithm effective ideal degrade efficacy control flow analysis recursive traversal algorithm 
distinguishing code data binary file fundamentally undecidable problem 
linear sweep algorithm decodes byte code long looks legitimate code byte ends interpreting data bytes instructions 
reason behavior intel instruction set possibilities legitimate starting byte instruction making mistake data instruction 
fact intel instruction set allows variable instruction size aggravates problem code data distinction 
consider example sequence bytes xc 
consider code byte ll disassembly jne offset hand consider data byte code byte get data test eax eax jne offset single disassembly error result subsequent bytes interpreted incorrectly extent error potentially unbounded 
contrast fixed instruction size architecture exhibits self correcting property interpretation error instruction word propagate instruction word 
recursive traversal algorithms obtain accurate disassembly results difficult construct complete control flow input binary presence indirect branch instructions call jmp reg call eax call jmp jmp dword esp xx 
solution problem perform additional data flow analysis inter procedural slicing constant propagation compile time value register memory location indirect control transfer instructions 
apart difficult implement approach tends greatly increase disassembly time guarantee accuracy 
procedures explicit call sites input program identified include exception signal handlers callback functions gui applications procedures calls indirect branch instructions 
identifiable call functions discovered control flow analysis result may misclassified data 
practice signal exception handlers pose problems entry points included program header cases 
addressing position independent code pic rely particular position program address space 
pic code jump table absolute address 
form offsets respect base value known run time value 
example call pop eax gets return addr value eax call dword eax call foo foo case spite having explicit call sites standard control flow analysis discover target location function foo 
hand crafted assembly code difficult identify procedure boundaries necessarily follow code conventions established standard compilers 
conventions provide useful hints resolve potential ambiguities 
example code convention violation assembly code programs jump function function going main entry point 
disassembly engine implementation disassembly engine built instruction set parsing disassembly capabilities existing disassembler 
combination known disassembly techniques viz 
recursive traversal linear sweep described briefly previous subsection complement compiler independent pattern matching heuristics 
assume data expected code section typically dispatch tables address bytes strings compiler alignment bytes 
goal project insert protection code procedure input binary identify code bytes possible transformed binary may security holes 
place maintenance original program semantics higher priority security doubt mark bytes data code avoiding unsafe binary instrumentation 
step step description disassembly process 
identify potential address bytes dispatch table discovery strings 
dispatch tables typically contain code section addresses 
know address range code section mark sequence bytes value lies address range potential address bytes 
sequences printable characters certain minimum length terminated null character marked potential strings 

starting program main entry point obtained input binary pe header perform control flow analysis binary traverse paths program control flow graph 
code bytes identified step marked definitely code associated data bytes marked definitely data identify targets call instructions function entry points targets conditional unconditional jump instructions jump targets 
step distinguish data code accuracy overrides analysis results steps conflict 
example byte sequence identified call instruction result step overrides step 
identified instruction call dword step xff identified potential address step 
identify entry points potential callback functions explicit call sites look instruction sequences push imm mov reg imm typically target address callback function usually passed argument function callback function registered 
argument passed stack immediate value push imm register contains address value mov reg imm push reg 
byte imm identified potential address potential string step looks legitimate instruction starting byte consider function entry point despite legitimate code byte may function entry point proceed disassembling subsequent bytes instructions 

identify types functions explicit call sites look bytes code section identified code data 
time byte located start instruction parsing looks legitimate instruction starting byte 
steps point instruction parsing begins called reset point 
instruction parsing continues unconditional branch instruction ret jmp encountered 
result instruction parsing procedure inconsistent previously identified byte leads illegal instruction byte result reset point revoked bytes reset point current position marked data avoiding potentially unsafe binary rewriting 
unconditional branch look suitable reset point start instruction parsing attempt 

sequence instruction bytes unconditional branch instruction jmp ret look code sequences unconditional branch jmp ret instruction mark code sequences data 
check provides final line defense eliminate potentially incorrectly identified instruction sequences 
example code sequence bytes marked data 
mov eax ebx push eax data byte unconditional branch data byte code byte branch target previous instruction unconditional branch doesn fall 
case byte unconditional branch code byte marked function entry point jump target mark function entry point just targets branch instruction inside function 
motivation identification functions seen steps explained subsection 
binary instrumentation possible derive high level control flow input binary process inserting additional code counter buffer overflow attacks proceed way disturb memory instructions binary program protected 
insert rad code additional code required rad involves saving copy return address stack return address repository rar function prolog checking return address stack saved copy rar function epilog popping rar event match flag exception 
adding function function choose interesting functions functions contain sequence instructions stack frame allocation deallocation local variables 
function local variables vulnerable stack buffer overflow 
insert rad code disturb original binary address space choose create separate new code section original pe binary information regarding pe format appended original binary hold additional prolog epilog code function 
new section mapped non interfering portion address space set read 
rad code corrupted application application corrupted rad code 
redirect control inserted code function prolog epilog need replace instructions function prolog epilog jmp corresponding rad code 
instrumented function invoked jmp instruction replaces prolog transfers control rad prolog code executes original prolog instructions jumps back original function continue execution instruction immediately original function prolog 
epilog instructions replaced similar manner 
execution proceeds jmp epilog code new section executing original epilog instructions ret rad epilog checking code return problems 
size unconditional jmp instruction bytes need bytes worth instruction space accommodate jmp instruction 
instructions target existing branch instructions replaced 
function prolog needs allocate stack space local variables typically comprises instructions 
push ebp save old frame ptr byte instruction 
mov ebp esp set top stack current frame ptr byte inst 
sub esp allocate bytes stack local variables byte instruction add esp alternatively done enter instruction compilers enter stack frame allocation 
interesting function prolog includes bytes worth instructions 
comfortably instrument interesting function prolog redirect control rad prolog code byte jmp instruction 
hand typical stack frame deallocation instruction sequence looks cases 
add esp 
stack space bytes allocated byte inst pop ebp restore caller frame ptr byte ret return byte 
mov esp ebp 
stack space number bytes allocated stack byte instruction pop ebp restore caller frame ptr byte ret return byte 
leave 
stack frame restores old frame ptr byte ret return byte see stack frame deallocation done bytes worth instructions 
need replace instructions addition stack frame deallocation instructions hold jmp instruction 
cases find space way 
possible instruction stack frame deallocation sequence jump target jne leave ret case replace instructions prior leave jump target disturbed 
experiences scenario able find bytes worth instructions function epilog occur practice relatively rare 
situation occur practice conditions need met development environments windows default set certain compilation options generate calls stack checking code prior stack frame deallocation check adherence certain calling conventions basically dictate caller callee duties regards function frame initialization cleanup 
calling convention adherence check desirable functions called function pointers calls library functions 
disable options compiler won generate stack checking calls generate extra bytes prior stack frame deallocation 
rad pe specific component file binary disassembler core binary rewrite engine binary rewriting rad component external input input system control flow 
software architecture rad prototype consists disassembler core binary rewriting engine rad component pe component 
high level code sequence goto label label return rare scenarios experiments show typically functions sec 
table simple expensive approach solve problem 
instructions available replace byte instruction prior ret int breakpoint interrupt instruction corresponds software interrupt install corresponding exception handler 
int instruction executed generates debugger breakpoint exception handler gains control perform return address check 
exception handler executing user space control transfer handler similar intra privilege level far call means stack switching exception handler access return address stack 
details regarding stack evolves execution software interrupt handler please refer 
reason chose debugger breakpoint exception exception normally program debugged 
debugged debugger control transferred debugger int instruction executed exception handler executed 
prototype implementation software architecture binary rewriting rad tool comprises logical components disassembler core binary rewrite engine rad component pe component 
disassembler functions main phases 
phase performs code data branch target identification bytes code section second outputs assembly instructions starting byte code section 
core binary rewrite engine independent binary format hooks disassembler second phase gain control instruction processed look interesting function instrument 
component handles issues involved adding instrumentation code outlined section 
instructions interesting pattern need contiguous component maintains circular window instructions current instruction previous ones flushed branch target encountered don run jump target 
engine attempts identify interesting patterns window time new instruction added 
rad code associated data added new section input binary 
rad component implements return address defense mechanism 
prolog stub saves return address stack rar epilog stub keeps popping rar stack till finds return address currently top stack till rar empty case flags exception 
repeated popping ensures return caller ancestors current call stack generate false positives 
scenario occurs case setjmp longjmp compiler optimizations cause functions return straight caller caller return caller return section 
pe component initializes binary rewrite process adding new section header section header table setting fields appropriately aligns new section called rad section holds rad code loaded run time rounding page boundary previous section stored binary file rounded file alignment boundary previous section 
rar initialization rad section set read write executable 
needs writable rar part section addition rad code 
run time non rar part section needs set read win api call 
create mine zones sides rar prevent attackers overflowing rar 
key issue locate entry point 
cases consider 
possible input program uses purpose loaded address space time pe component takes control 
second possible input program need pe component needs load function address space 
case pe headers interest import address table iat import name table int 
tables reached import directory location turn obtained array pe 
entry iat run time contains address imported function disk binary file 
iat entry corresponding entry int points name corresponding imported function 
load time loader overwrites iat entries virtual addresses corresponding functions mapped 
locate entry point look int name retrieve index associated iat entry match 
imported input program entry point readily available iat entry 
match int corresponding iat entry empty need dynamically resolve entry point calling gets base address dll containing api function question calling gets address desired api function export directory containing dll 
entry points obtained iat containing dll kernel dll 
case api functions imported quite rare pe component needs emulate operation 
emulation idea derived undocumented virus code observation program entry point top stack contains return address points inside function turn belongs dll kernel dll 
address scan memory kernel dll mapped 
base address kernel dll known entry points available dll export table turn entry point api function identified functions 
entry point executable pe header changed new initialization code locates entry point calls protect surrounding pages rar 
limitations security weaknesses due disassembly limitations aspects disassembly relate sources false positives security loopholes functions covered disassembly engine identification functions look aspects evaluate result false positives missed attacks 
tradeoff security program correctness 
effort seal known security holes preserving original program semantics considered important goal achieving perfect security 
missed functions mainly callback functions explicit call code section functions invoked position independent code pic sequences absolute address function code section 
covered pure control flow analysis 
despite typically certain fraction functions get missed 
representative scenarios clear 
functions missed control flow analysis step identified fully code partly fully misidentified data aligned data preceding actual function entry misidentified code 
considering typically unidentified function entry point preceded data unconditional branch instruction previous function cases mark function entry point step disassembly engine sec 

function fully identified data function altogether lead potential security loop hole particular function buffer overflow vulnerability 
considering part misidentification code data say start function misidentified data interesting prologue function identified data interesting epilog cases result unprotected return recipe potential security loophole 
middle part function misidentified data function divided returns function point treated part uninteresting function left uninstrumented attack 
data preceding entry point function aligns properly code bytes form legitimate instruction sequence originally interesting prologue uninteresting exposing attack opportunity 
cases far program semantics 
data misidentified code turns uninteresting function prolog interesting generate false positive epilog happens interesting 
false positive scenario function entry point preceded data identified code byte happens jump target happens inter procedural jumps case functions get merged 
inter procedural jumps occur handcrafted assembly setjmp longjmp cases 
apart functions jump targets reached pic jump tables missed 
affect program correctness targets happen instrumented scenario 
falsely identified functions functions multiple entry points treated separate functions 
targets pic jump tables discovered statically get marked function entry points lie immediately unconditional branch sequence data bytes step disassembly engine sec 

code section addresses appear immediate imm operands mov imm push imm identified function entry points targets indirect jump non pic jump table targets treated specially identified 
function boundary identification helps prevent scenarios prolog instrumented epilog vice versa 
case cause false positives epilog checking code trying find match return address stack saved prolog instrumentation code won find rar flagging false exception want avoid altogether achieved identification functions 
identification result function having instrumented prolog uninstrumented epilog 
function called frequently manner exits uninstrumented epilog rar eventually overflow code pop return address rar 
potential problem due identification missed attacks 
identification causes entry point inserted function body single function gets divided 
second function won interesting prologue subsequent returns function missed 
identification program correctness course entire chunk data misidentified code forms function interesting prolog epilog extremely scenario 
summary pic indirect branches callback functions cause security loopholes input programs unprotected 
empirical results show indirect branches typically branch instructions section table 
fraction possibly result missed attack 
false positives arise due hand crafted assembly code inter procedural jumps entry exit points different functions 
example case observed rewriting application microsoft access fn interesting prolog jne label ret interesting epilog fn interesting prolog label ret interesting epilog case control jumps fn prolog instrumented meaning return address saved rar label fn exit fn epilog instrumented meaning return address check done 
rad epilog fn flag exception find stack return address rar false positive 
solution avoid false positives assign id function keep function id information part rad bookkeeping checking operation 
additional piece information rad epilog check proceeds function id matches function id top stack rar epilog check 
current binary rewriting rad prototype support mechanism 
data misidentified code looks exactly interesting prolog entire chunk data look interesting function 
uncommon scenarios 
potential buffer overflow attacks due limitations rad rad current binary rewriting rad prototype protect applications kind buffer overflow attack corrupts return address stack 
resist conventional stack smashing attacks frame pointer attacks 
prevent memory pointer corruption attacks affect return address way 
simply modify contents import table got iat impossible rad detect 
fortunately actual network security breach incidents type attacks reported 
multithreaded applications current implementation doesn handle multithreaded applications 
idea implement solution multithreaded applications comes 
access thread information block tib structure fs segment register 
code generated compilers set exception handlers allocate storage thread local variables typically reveal fs register 
tib contains array slots thread local storage 
separate rar space thread care rar spaces threads don bump store address rar thread local storage slots rad prolog epilog code rar 
fs register known fact windows world falls category undocumented information 
probably win api functions cost invoking api call rad prolog epilog prohibitive 
self modifying code self modifying code missed functions due indirect branches control flow analysis difficult 
piece code added run time heap way rad add checks 
experimental results validate correctness binary rewriting rad prototype need verify rad code injected appropriate places input binary rad code protect input binary buffer overflow attacks way incur significant space overhead run time performance cost 
subsections results show current binary rewriting rad prototype reasonable job disassembly accuracy low overhead protection buffer overflow attacks 
step size return address repository kbytes exception handler bytes installing exception handler bytes set rad mine zones bytes search bytes total kbytes table 
constant space overhead rad 
row corresponds step searches kernel dll export table entry point 
micro benchmark results establish baseline performance binary rewriting rad prototype apply set synthetic programs measure space performance overhead 
table shows constant space overhead associated binary rewriting rad excludes function prolog epilog rad code 
instrumented function needs prolog epilog checking code take bytes respectively 
measure performance overhead instrumented function due prolog epilog rad code 
depending epilog rad code triggered jump instruction software exception handler measured performance overhead different 
tested different instrumented functions void fn invokes prolog epilog rad code jump instruction void fn invokes prolog rad code jump epilog rad code software exception void fn amount computation incrementing variable times making function calls performance penalty binary rewriting rad prototype defined fn additional cost due rad fn original cost measured pentium performance counter resolution nsec 
test function case overhead rad higher expected considering prolog epilog rad code size just instructions simple instruction push reg pop reg mov reg mem cmp reg mem add mem imm sub reg imm appear costly 
believe performance overhead due additional instruction cache misses arise code region test function separate prolog epilog rad code 
function epilog contain space hold jump instruction epilog rad code test function cycle counts original cycle counts rad relative penalty null function null function epilog incrementing function table 
function performance overhead due rad code injected instrumented function 
null function epilog case null function case epilog invoked software interrupt 
incrementing function case corresponds function increments variable times 
measurements terms pentium cycle counts 
implemented inside exception handler 
additional performance overhead due exception delivery return compared jump instructions shown second test function case table test function doing computation intensive third test function case relative performance overhead rad immediately negligible 
compared original rad system works source code binary rewriting rad performs better cases prolog epilog code implemented assembly efficient 
result somewhat surprising original rad system places function prolog epilog code associated function separate code region incur additional instruction cache penalty 
macro benchmark results experimented wide variety commercial grade windows applications including bind dns server dhcp server third party ftp server microsoft telnet server ms ms publisher ms powerpoint ms access outlook express cl compiler exe visual development environment windows help notepad 
rewriting programs behave exactly ms access generated false positive due hand crafted assembly code described section third party ftp server internal exception handler conflicts debugger exception handler binary rewriting rad installs 
initial experiences collected running binary rewriting rad prototype wide array regular desktop applications internet servers prime targets buffer overflow attacks convinced prototype sufficiently mature preserve program semantics complex applications providing protection buffer overflow attacks 
course exhaustive tests required absolutely sure accuracy disassembly protection strength rad 
disassembly accuracy binary rewriting rad prototype uses control flow analysis set heuristics distinguish code embedded data 
general control flow analysis quite effective identifying code regions non interactive applications usually call back functions 
interactive gui applications microsoft office suite control flow analysis quite effective hidden call back functions 
applications represent challenging test programs disassembler 
table shows disassembly accuracy programs ms powerpoint ms ms publisher 
disassembly accuracy programs 
way measure disassembly accuracy manually inspect resulting assembly code determine instructions look reasonable 
experiences instructions disassembled data tend appear place easily detected 
manual inspection method may rigorous verify disassembly results experimented certain ported unix applications available sources windows compiled gcc profiling options analysed offline gprof 
missed functions unprotected returns interesting functions appear reasonable 
missed functions apache typically functions absolute address code section invoked table function pointers addresses functions assigned statically 
table static array variable located data section function addresses 
static call graph generated gprof shows parents functions unidentified 
results obtained control flow analysis guaranteed correct useful measure percentage instructions identified control flow analysis gives indication useful heuristics identifying instructions especially gui intensive interactive applications 
table shows total number instruction bytes test application percentage control flow analysis successfully detect 
expected non interactive applications rarely call back functions control flow analysis achieve high detection accuracy 
interactive applications percentage 
difference coverage percentages table programs ms powerpoint ms ms publisher represent contribution pattern heuristics binary rewriting rad employs total code region coverage 
control flow analysis plays important role disassembly process instructive investigate deeper detect instructions program 
functions explicit call sites application code section 
incorrectly decoded accuracy size bytes approximation ms powerpoint mb ms publisher mb ms kb table 
disassembly accuracy achieved measured manual inspection resulting assembly code 
higher accuracy means bytes successfully disassembled 
application 
functions 
functions 
returns returns source code disassembly unprotected unprotected gzip wget apache whois openssl table 
evaluation disassembly results comparison original program sources 
numbers parenthesis third column represent number identified functions 
indirect branch instructions main culprit 
measure percentage indirect control branch instructions test applications results shown table 
interactive applications ms powerpoint access tend higher percentage indirect branches reflects event driven programming style applications correspondingly extensive function pointers switch statements 
summary disassembly results appear better previous best reported literature claims precision binaries relocation information experiments smaller programs plain command line programs gui callback functions disassembly tougher 
furthermore presence symbol table information binaries possibly inadvertently eliminates problems regarding function boundary identification 
question symbol table format 
generic symbol table supported pe binary formats compiler specific format vc pdb 
apparently compilers tend favor proprietary formats symbol table generic format 
evident default compilation options generating debug information produce symbol tables generate proprietary symbol tables 
run time overhead important consideration design rad minimization performance overhead due function prolog epilog rad code 
relative performance overhead rad respect test application defined execution time rad execution time rad execution time rad results table shows run time performance overhead binary rewriting rad typical internet applications quite small 
space overhead rad real applications quite reasonable shown table 
highest percentage smaller 
results demonstrate overhead binary rewriting rad quite reasonable practical applications additional protection provides 
cost invoking epilog rad code exception handler times expensive jump instruction important find frequent epilog rad code invoked exception handling mechanism 
occurs frequently sophisticated mechanism needs developed 
table shows percentage functions test applications epilog rad code triggered exception handler 
statistics table show percentage functions instruction space jump instruction fairly low justifies design decision expensive solution infrequent cases 
please note results static analysis 
possible run time functions get invoked times case performance get seriously hit 
possible instrument binaries report functions called run time need int software interrupt clear say day just say functions experiments typically probabilistically functions called run time similar order 
application percentage code section covered control flow analysis percentage indirect branch instructions ftp server bind dns server ms access notepad ms powerpoint windows help ms ms publisher table 
column shows percentage program code section bytes detected purely control flow analysis 
column shows percentage indirect branch instructions branch instructions 
ret instructions included count 
application original execution binary rad execution overhead time msec time msec bind dhcp server powerpoint outlook express table 
program performance overhead due insertion binary rewriting rad code 
bind response time measurement averaged queries issued client program dig exe 
dhcp server measurement startup initialization time averaged runs 
powerpoint measurement time taken render averaged runs 
outlook express measurement startup initialization time averaged runs 
resilience buffer overflow attacks simulated buffer overflow exploit test program buffer overflow vulnerability 
binary rewriting rad successfully detects stops attack 
buffer overflow defense mechanism static binary translation rad model 
best knowledge reported open literature applies static binary translation technology concrete application security problem 
robust binary rewriting infrastructure tools etch exist published papers systems document detail design implementation issues involved solutions adopted address effectiveness quantitative manner 
believe exhaustively covers binary translation issues substantial depth detail presents comprehensive set experimental results demonstrate efficacy design decisions 
resulting rad system achieves qualified success important tool protect legacy applications source code available buffer overflow attacks significantly broadens applicability buffer overflow defense mechanisms developed research literature 
may achieve stated goal providing level protection compiler counterpart cases primarily due fundamental deficiency known works binary translation literature done better far tell 
currently exploring robust foolproof fallback mechanisms deal scenarios incorrect disassembly lack sufficient space place translation 
immediate step intend experiment binary translation engine dynamically linked libraries dlls major chunk windows services implemented dlls 
aim apply lessons exploring static binary translation techniques build copy tamper resistant software 
tzi cker chiueh fu hau hsu rad compile time solution buffer overflow attacks icdcs aleph smashing stack fun profit phrack magazine november david windows nt buffer overruns ras community com application percentage increase size percentage functions need int software interrupt ftp server bind dns server ms access ms powerpoint windows help ms ms publisher table 
column shows space overhead binary rewriting rad different test applications terms percentage increase size executable file rewriting 
column shows percentage functions identified need invoke rad epilog code int handler htm community 
com htm dark win buffer overflows location exploitation defense phrack magazine may srivastava eustace atom system building customized program analysis tools 
proceedings conference programming language design implementation pldi pages june 
james larus eric schnarr eel machine independent executable editing 
sigplan conference programming languages design implementation pages june 
ted romer geoff voelker dennis lee alec wolman wayne wong hank levy brian bershad 
instrumentation optimization win intel executables etch 
usenix windows nt workshop 
www com htm cifuentes van emmerik uqbt adaptable binary translation low cost ieee computer march 
crispin cowan stackguard automatic adaptive detection prevention buffer overflow attacks 
proceedings th usenix security symposium pages san antonio tx january 
microsoft compiler extension buffer overflow defense go microsoft com linkid www com sk win disassembler www com hiroaki 
gcc extension protecting applications stack smashing attacks www trl ibm jp projects security ssp cash checking array bound violation segmentation hardware www cs sunysb edu project html jones kelly backwards compatible bounds checking arrays pointers programs www ala doc ic ac uk html intel architecture software developer manual volume system programmer guide kil 
bypassing stackguard 
phrack may 
phrack magazine may frame pointer overwrite timothy tsai singh transparent run time defense stack smashing attacks proceedings usenix annual technical conference june 
vladimir derek saman amarasinghe secure execution program shepherding th usenix security symposium august san francisco california 
benjamin schwarz saumya debray gregory andrews disassembly executable code revisited working conference reverse engineering oct 
cifuentes van emmerik recovery jump table case statements binary code international workshop program comprehension may galen hunt doug detours binary interception win functions 
proceedings third usenix nt symposium seattle july 
matt depth look win portable executable file format msdn magazine feb matt hood microsoft systems journal may 

