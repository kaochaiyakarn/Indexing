complexity decentralized control markov decision processes daniel bernstein robert givan neil immerman shlomo zilberstein department computer science university massachusetts amherst ma school electrical computer engineering purdue university west lafayette consider decentralized control markov decision processes give complexity bounds worst case running time algorithms find optimal solutions 
generalizations case partially observable case allow decentralized control described 
agents finite horizon problems corresponding models hard nondeterministic exponential time 
complexity results illustrate fundamental di erence centralized decentralized control markov decision processes 
contrast problems involving centralized control problems consider provably admit polynomial time algorithms 
furthermore assuming exp nexp problems require super exponential time solve worst case 
markov decision processes mdps received considerable attention exist known algorithms finding optimal control strategies case process centrally controlled controller agent access complete state information puterman 
understood case process controlled multiple cooperating distributed agents possibly di erent information state 
interested studying hard decentralized control problems relative analogous centralized control problems point view computational complexity 
particular consider di erent models decentralized control mdps 
generalization partially observable markov decision process pomdp call decentralized partially observable markov decision process dec pomdp 
dec pomdp process controlled multiple distributed agents dec mdp pomdp mdp dec pomdp relationships models 
possibly di erent information state 
generalization mdp called decentralized markov decision process dec mdp 
dec mdp dec pomdp restriction time step agents observations uniquely determine state 
mdp pomdp dec mdp viewed special cases dec pomdp 
relationships models shown 
number di erent problems viewed decentralized control markov process 
example consider problems involving control multiple distributed robots robotic soccer coradeschi 
domains necessary develop strategy robot assumption robots limited ability communicate execute strategies 
problem fits naturally framework distributed control power grid schneider 
types networking problems viewed framework altman 
beneficial general purpose algorithms solving decentralized control problems 
algorithm similar problems proposed ooi 

assumption agents share state information time steps authors developed dynamic programming algorithm derive optimal policies 
downside approach state space dynamic programming algorithm grows doubly exponentially known tractable algorithms types problems rely assumptions 
algorithm developed hsu marcus works assumption agents share state information time step take time step information propagate 
approximation algorithms developed problems best give guarantees local optimality 
instance peshkin 
studied algorithms perform gradient descent space parameterized policies 
inherent problems forces add assumptions approximation algorithms 
papadimitriou tsitsiklis results aimed answering question 
authors proved simple decentralized decision making problem np complete just decision makers 
noted implies decentralized control mdps np hard papadimitriou tsitsiklis 
strengthen result showing dec pomdp dec mdp problems nexp hard horizon limited number states nexp complete case 
known classes np pspace distinct known nexp problems consider provably intractable 
furthermore assuming exp nexp problems take super exponential time solve worst case 
result contrast best known bounds mdps hard pomdps papadimitriou tsitsiklis mundhenk goldsmith allender 
gained insight possibility fundamental di erence centralized decentralized control markov decision processes 
section give brief review concepts need complexity theory 
section define mdp pomdp models 
section contains definitions dec mdp models proof short horizon versions problems fall complexity class nexp 
section main complexity result proof decentralized problems nexp hard 
section contains 
computational complexity section give brief theory computational complexity 
detail papadimitriou 
complexity class set problems problem infinite set problem instances answer 
order discuss complexity optimization problems way converting problems 
typical way done set threshold ask optimal solution yields reward threshold 
problem finding optimal solution course easier threshold problem 
complexity class consider set problems solved polynomial time size problem instance sequential computer 
np set problems solved nondeterministically polynomial time 
nondeterministic machine automatically knows correct path take time choice computation proceed 
example problem solved nondeterministically polynomial time deciding sentence propositional logic satisfiable 
machine guess assignment truth values variables evaluate resulting expression polynomial time 
course nondeterministic machines really exist cient known algorithms simulating take exponential time worst case 
fact strongly believed complexity theorists np proven formally 
complexity measured terms amount space computation requires 
class pspace includes problems solved polynomial space 
problem solved polynomial time nondeterministic polynomial time solved polynomial space np pspace pspace seen informally observing polynomially space accessed polynomially time steps 
moving complexity hierarchy exponential time exp nondeterministic exponential time nexp 
exponential time mean time bounded input size constant 
known pspace exp nexp believed exp nexp proven 
proven classes exp distinct 
notion reduction important complexity theory 
say problem reducible problem instance converted instance answer answer 
problem said hard complexity class hard problem ciently reducible complexity class question cient means computed logarithmic space classes cient means computed polynomial time 
problem said complete complexity class complete contained hard instance satisfiability problem mentioned np complete hard 
np satisfiability complete 
centralized models consider discrete time finite sequential decision processes undiscounted optimality criterion 
build problem definitions unusual assumption horizon number states 
note assumption strengthens hardness results general problems hard short horizon counterparts 
unfortunately assumption needed upper bounds 
finding tight upper bounds problems arbitrary horizons remains open problem blondel tsitsiklis section 
describe partially observable markov decision process associated decision problem 
markov decision process viewed restricted version model 
partially observable markov decision process pomdp defined follows 
tuple finite set states distinguished initial state finite action set 
transition probability table 
rational representing probability transitioning action reward function 
rational representing reward obtained action state transitioning state finite set observations 
table observation probabilities 
rational representing probability observing action state transitioning state result 
positive integer representing horizon 
rational representing threshold value 
pomdp fully observable exists mapping nonzero markov decision process mdp defined pomdp fully observable 
policy defined mapping sequences observations actions wish find policy maximizes expected total return finite horizon 
definitions formalize notion 
symbol denote empty observation sequence 
observation sequence oo taken represent sequence definition probability transitioning state state policy agent sees observation sequence written defined recursively follows oo empty sequence 
definition value policy state steps equation observation sequences length 
decision problem corresponding finite horizon pomdp follows pomdp policy equals exceeds 
shown papadimitriou tsitsiklis decision problem pomdps pspace complete decision problem mdps complete 
decentralized models describe extensions aforementioned models allow decentralized control 
models step agent receives local observation subsequently chooses action 
state transitions rewards received depend vector actions agents 
decentralized partially observable markov decision process dec pomdp defined formally follows ease exposition describe agent case 
finite set states distinguished initial state finite action sets 
transition probability table 
rational representing probability transitioning actions reward function 
rational representing reward obtained actions state transitioning state finite sets observations 
table observation probabilities 
rational representing probability observing actions state transitioning state result 
positive integer representing horizon 
rational representing threshold value 
dec pomdp generalizes pomdp allowing control multiple distributed agents may fully observe system state partial observability 
define generalization mdp problems requiring joint observability 
say dec pomdp jointly observable exists mapping nonzero define decentralized markov decision process dec mdp dec pomdp jointly observable 
define local policy agent mapping local histories observations actions joint policy defined pair local policies agent 
wish find joint policy maximizes expected total return finite horizon 
centralized case need definitions notion formal 
definition probability transitioning state state joint policy agent sees observation sequence agent sees length written defined recursively follows empty sequence 
definition value policy state steps equation observation sequences length sequences pair length 
decision problem stated follows dec pomdp joint policy equals exceeds 
dec dec denote decision problems agent dec pomdp agent dec mdp respectively 
conclude section showing straightforward upper bound worst case time complexity dec 
dec mdp trivially dec pomdp upper bound applies dec theorem dec nexp 
proof show nondeterministic machine solve instance dec exponential time 
joint policy guessed written exponential time 
joint policy consists mappings local histories actions histories length 
dec pomdp joint policy viewed pomdp policy observations pomdp correspond observation tuples dec pomdp agent pomdp actions correspond tuples dec pomdp actions agent 
exponential time exponentially possible sequences observations converted belief state probability distribution state set giving probability state seeing observation sequence 
note pomdp kaelbling littman cassandra equivalent belief state mdp state set set reachable belief states pomdp 
transition probabilities expected rewards corresponding exponential sized belief state mdp computed exponential time 
standard mdp solution techniques puterman possible determine guessed policy yields expected reward belief state mdp time polynomial size belief state mdp exponential size original dec pomdp problem 
exists accepting computation path policy achieve reward decentralized control mdps nexp hard turn attention proving upper bound just shown theorem tight specifically show nexp lower bound worst case time complexity decentralized problems consistent tiling example tiling instance 
showing problem class nexp reduced polynomial time dec mdp problem 
follows dec dec nexp complete 
proof lower bound quite involved occupy remainder 
subsection section contains piece development section main theorem asserted 
introducing known nexp complete problem tiling proof 
overview proof major constituents 
reduction tiling formally prove reduction correct 
tiling problem show lower bound reducing nexp complete problem dec mdp polynomialtime algorithm 
reduction nexp complete problem called tiling lewis papadimitriou described follows 
board size represented compactly binary set tile types tile 
tile set binary horizontal vertical compatibility relations ll 
tiling mapping 

tiling consistent tile decision problem determine consistent tiling exists 
example tiling instance corresponding consistent tiling shown 
remainder section assume fixed arbitrarily chosen instance tiling problem fixed 
construct instance dec mdp solvable selected tiling instance solvable 
note dec mdp instance constructible time polynomial size tiling instance particular logarithmic value require dec mdp instance polynomially larger tiling instance 
overview reduction basic idea reduction create agent dec mdp randomly selects tiling locations bit bit informing agent location agent second location 
agents local policies observation history agents base actions tiling locations 
generating locations agents simultaneously queried state reached actions interpreted answers query tile type place location 
design dec mdp problem way agents achieve nonnegative expected reward base answers query single jointly understood tiling meets constraints tiling problem 
design complicated dec mdp state set remember tiling locations selected cause exponential blowup size state set reduction expand problem size polynomially note tiling grid part tiling problem size compactly represented grid size problem specification state contain certain limited information relative locations tile positions 
di culty design increased fact information remembered specified tiling locations shared agents satisfy joint observability requirement 
deal issues designed dec mdp pass phases formal description follows select phase select bit indices values identifying bit position value position location agents 
bits remembered state set locations agents phase location bits generated forgotten process 
bit values remembered called value value indices values correspond called index index 
bit index address agent value value likewise index value agent 
generate phase generate tile locations random revealing agent 
bits selected select phase location bits generated random immediately forgotten dec mdp state set 
query phase query agent tile type place location specified agent 
tile types remembered state 
echo phase require agents echo tile locations received generate phase bit bit 
order enforce accuracy location echoes designed yield negative reward bit remembered original location generation correctly echoed dec mdp designed ensure agent know bit checked echoes 
agents echo bits process computes state information representing locations equal adjacent horizontally vertically agents locations just remember location bits force exponential state set 
echo phase allows compute state information adjacency equality locations tile types chosen agents tile choices depend information 
critical making reduction correct 
test phase check tile types provided query phase come single consistent tiling 
words check agents asked location gave tile types query asked adjacent locations gave types satisfy relevant adjacency constraints agents queried location gave tile type tile 
process gives zero reward tile types selected query phase meet applicable constraints determined echoed location bits 
negative reward obtained 
note designing dec mdp required maintain joint observability observations agents time step su cient reconstruct aspects state time step 
particular bit indices values selected select phase known agents jointly information computed echo phase regarding relative position locations 
achieve joint observability making aspects dec mdp state observable agents indices values selected select phase tile types agents stored process query phase 
agent observe bit index value remembered agent location agent observe stored tile type gave tile type agent 
agent see bit saved agent location say location bit agent location visible agent 
call phases just described select generate query echo test development 
formal presentation dec mdp just sketched follows outline proof approach represents correct reduction 
overview correctness proof give overview argument reduction sketched correct sense exists policy achieves expected total reward zero start state solution tiling problem started 
straightforward show exists consistent tiling exist policy achieving zero reward 
agents need agree consistent tiling ahead time base actions agreed tiling waiting selection generation giving tile type generated location query faithfully echoing generated location echo waiting test point guaranteed zero reward structure problem 
note matter expensive find represent consistent tiling carry policy just described merely arguing existence policy 
outline proof harder direction consistent tiling policy achieving expected reward zero 
note rewards nonpositive chance receiving negative reward forces expected total reward negative 
consider arbitrary policy yields expected reward zero 
argument rests claims proved lemmas section claim 
policy repeat locations correctly echo phase 
claim 
executing policy agents selected actions query phase determine single tiling follows 
define query situation dangerous agent observable bit value agent location observation history agrees bit value index agent location far agent danger knows agent queried location 
dangerous queries tile type selected agent danger depend location queried index value bit observed agent observable information agent selecting tile type 
agents selected actions dangerous queries determine single tiling 
claim 
single tiling claim consistent tiling 
claim directly implies consistent tiling policies negative expected reward desired 
formal presentation reduction give agent dec mdp constructed selected tiling instance 
assume power 
straightforward modify proof deal general case way summarized briefly appendix state set describe state set giving sequence finite domain state variables state set set possible assignments values state variables 
finite state automaton state variables maintained finite state automaton fsa described appendix variable called rel pos maintains record relative position location addresses echoed agents echo phase take values state set fsa 
appendix describes state set defines functions fsa underlying fsa 
functions allow refer critical fsa behaviors reduction deferring details fsa appendix function updates state variable rel pos bit echoed location agent 
function fsa updates state variable rel pos sequence echoed location bits agent fsa defined repeated application function 
appendix describes distinguished subsets fsa state set called apart equal hor ver representing possible relative positions pairs locations adjacent equal equal horizontally adjacent vertically adjacent respectively 
subsets defining transition reward behavior dec mdp appendix defines initial state fsa 
state variables list state variables defining state set list variables groups group observable agents second group agent third group agent 
restrictions observability described section observable agents phase select gen query echo test current phase process index 
log index location bit generated echoed origin eventually true tile locations rel pos relative tile positions echo controlled fsa observable agent index 
log index bit remembered agent value value bit remembered agent pos bit bit transmitting tile position agent tile sel tile type selected agent query observable agent index 
log index bit remembered agent value value bit remembered agent pos bit bit transmitting tile position agent tile sel tile type selected agent query write state enumerating variable values follows gen tile tile semicolons group variables observability properties 
represent sets states writing sets values components tuple just values 
symbol represent set possible values component 
state variable function states domain values variable 
instance matches gen say phase gen initial state follows select tile tile 
action sets table transition probabilities allow wait actions zero actions echoing location address bits tile type actions set tile types answering query phase 
take action sets wait give transition distribution certain action pairs certain source states source state action pair combination covered description action pair taken cause probability self transition back source state 
combinations covered reachable initial state joint policy 
note fsa controlled state component rel pos change initial state echo phase 
select phase 
step process 
step process chooses agent agent bits checking echo phase 
value bit determined step 
transition probabilities phase select follows 
log situations select tile tile gen tile tile 
log 
generate phase 
steps tile positions chosen bit bit 
note check bits selected select phase value bit value chosen selection 
transition probabilities phase generate follows 
second case describes deterministic transition generate phase query phase 
situations gen tile tile log gen tile tile number allowed settings previous lines 
situations gen log tile tile query tile tile 
query phase 
query phase consists just step agent chooses tile type 
transition probabilities phase query follows 
situations query tile tile tile tile echo 
echo phase 
echo phase agents asked repeat back addresses seen generate phase information relative position addresses calculated fsa described appendix recorded state 
fsa accessed function described appendix transition probabilities phase echo follows 
situations echo echo log test log 
test phase 
test phase consists just step terminating process zero reward absorbing state 
situations test test tile tile 
reward function describe reward function reward transitioning state state action pair situation situations matching patterns 
roughly give zero reward waiting select generate answering tile type query echoing bit consistent remembered information echo having tile types satisfying relevant constraints test 
relevant constraints test determined rel pos state component computed fsa echo phase 
holds select phase select wait 
generate phase gen wait 
query phase query echo phase echo 
test phase test equal wait tile 
test phase ii test hor wait test phase iii test ver wait test phase iv test apart wait 
observations threshold horizon component fields state description fully visible agents 
state component fields split groups group visible agent 
take agent observations partial assignments state variables phase index origin rel pos index value pos bit tile sel 
similarly observations partial assignments state variables phase index origin rel pos index value pos bit tile sel 
observation distribution simply reveals indicated portion just reached state agent deterministically 
say observation sequence phase sequence matches pattern stands observation sequence 
gen query echo test 
take horizon log process spends step select query test phases log steps generate phase log steps echo phase 
take threshold value 
completes construction dec mdp polynomial time reduction selected tiling instance 
example zero reward trajectory process shown 
turn correctness 
phase gen index index value index value phase gen index pos bit index value pos bit index value phase gen index pos bit index value pos bit index value phase gen index pos bit index value pos bit index value phase gen index pos bit index value pos bit index value phase query index value index value phase echo index origin rel pos index value tile sel tile index value tile sel tile phase echo index origin rel pos index value tile sel tile index value tile sel tile phase select phase echo index origin rel pos phase echo index origin rel pos phase test origin rel pos hor tile sel tile tile sel tile index value tile sel tile index value tile sel tile index value tile sel tile index value tile sel tile select process chooses indices checked echo phase 
generate process generates address bits 
query agents choose tiles 
echo agents echo address bits 
process checks bit agent keeps track information addresses echoed 
test process checks relevant constraints satisfied 
phase test example zero reward trajectory process constructed tiling example 
total reward zero agents echo checked bits correctly choose tiles violate constraints addresses echoed 
clarity state components shown 
formal correctness argument show reduction correct 
main claim exists policy achieves expected total reward zero start state solution tiling problem started 
notation easier read define abbreviations 
definition observation sequence write loc location value represented bits transmitted agent generate phase process 
note select generate phases value may partially specified bits generated 
precisely loc values chosen match sequence large possible allowing match gen gen 
define loc similarly 
addition define bit 
binary coding possibly partially specified location take bit undefined bit specified location abuse notation treat loc loc tiling location fully specified bit string times 
easier direction correctness stated lemma formally proven appendix lemma exists consistent tiling exist policy achieving zero expected total reward 
discuss di cult reverse direction correctness proof 
subsections prove claims section show policy achieves nonnegative expected reward horizon consistent tiling 
remainder proof focus fixed arbitrary policy achieves zero expected reward 
policy show consistent tiling 
proof claim proving claim need formalize notion faithfulness echo 
definition pair observation sequences respectively said reachable nonzero state observation sequence said reachable exists observation sequence pair observation sequences reachable 
likewise reachable reachable 
definition policy faithful echo satisfies conditions indices log reachable observation sequence pairs 
bit loc echo 

bit loc echo 
say policy lies echo 
conditions listed satisfied indices log say policy faithfully echoes bits 
proof revolves showing reachability pair observation sequences ected making certain changes sequences 
focus loss generality changes observations agent similar results hold agent 
changes particular interest changes randomly selected value index state component component remembers bit agent queried location checked echo 
important show agent determine bit checked bit echoed 
show define way vary observation sequences seen agent preserving reachability changing observations seen agent changed agent address bit checked 
approach formally 
definition say observation sequence superficially consistent values index component value component change sequence value tile sel component tile generate phase query phase observations fixed tile type echo phase test phase observations 
superficially consistent observation sequence write index value denote value indicated component sequence 
addition write tile sel denote fixed tile type echo phase test phase observations take tile sel tile sequence contains echo test phase observations 
corresponding definitions hold observation sequences replacing 
note reachable observation sequence superficially consistent converse necessarily true 
technical definition necessary discuss relationships observation sequences assuming reachability 
definition say superficially consistent observation sequences compatible bit index loc value bit loc defined bit index loc value bit loc defined 
definition index log reachable pair observation sequences observation sequence say index variant relative sequence compatible varies follows 
index set sequence 
value set value sequence 
pos bit vary arbitrarily 
echo test phase observations tile sel set tile type selected query phase prefix tile selects non tile type action query 
pos bit components identical say address index variant note reachable pair observation sequences exists index variant relative log 
remains true allow address index variants 
technical lemma asserts index variation just defined preserves reachability general conditions 
proof deferred appendix lemma suppose faithful echo bits echo phase reachable pair observation sequences kth bit echo observation sequence index greater echo phase observation index variant relative observation sequences echo phase test phase require index variation address variation 
conclude reachable 
ready assert prove claim section 
lemma claim faithful echo 
proof argue induction faithfully echoes log address bits 
inductive hypothesis assume faithfully echoes bits log note equals zero null assumption providing implicit base case induction 
suppose contradiction lies st step echo phase 
agents policies incorrectly echo bit assume loss generality agent reachable observation sequence pair length log policy dictates agent choose action bit loc 
lemma implies observation sequence pair reachable address index variant relative agent observations sequence occurs agent chooses action bit loc sequence reward obtained case bit checked 
expected total reward zero yielding contradiction 
proof claim move prove claim section 
show define particular mapping tile locations tile types dangerous queries 
section defined agent observation sequence dangerous reveals bit agent queried location agrees corresponding bit agent queried location vice versa agent observation sequences 
definition formally 
definition query phase observation sequence dangerous reachable bit index loc value 
likewise query phase sequence dangerous reachable bit index loc value 
dangerous query phase sequences agent observations consistent possibility agent queried location 
note desired query location agent exist dangerous observation sequences loc sequences exist require value index particular desired value number non observing agent 
lemma length query phase observation sequences reachable pair compatible individually reachable 
proof direction theorem follows easily reachability part follows definition reachability compatibility jointly reachable sequences follows simple induction sequence length design direction shown assertions 
generate phase observation sequence agent reachable matches pattern gen tile gen tile established simple induction sequence length design similar pattern applies query phase 
compatible reachable sequences length know definition reachability sequence reachable 
patterns just shown reachable sequences di er choice address agent pos bit component 
follows index variant relative lemma implies pair reachable desired 
lemma claim exists mapping tiling locations tile types loc dangerous queries agents 
proof prove lemma prove dangerous query sequences respectively arbitrary loc loc 
implies take loc construct satisfying lemma 
suppose 
counterexample counterexample form counterexample dangerous query loc consider counterexample dangerous reachable sequences respectively loc loc 
note loc loc fact dangerous implies compatible reachable lemma 
faithfulness echo proven claim lemma ensures extension single extension deterministic echo test phases observation sequences test phase involves faithful echo 
correctness fsa construction appendix ensures rel pos state component extension value equal 
reward structure test phase ensures avoid negative reward tile types query contradicting choice entailing lemma 
proof claim main hardness theorem finish proof main theorem proving claim section 
start showing existence useful class pairs dangerous observation sequences reachable 
lemma locations sharing single bit binary representations dangerous observation sequences loc loc reachable 
proof straightforward show exist dangerous observation sequences loc loc desired 
sequences index index set index single bit shared bit common sequences compatible lemma reachable 
lemma claim mapping defined lemma consistent tiling 
proof prove contrapositive 
mapping consistent tiling particular constraint violated easy show constraint tested test phase loc loc appropriate values 
faithfulness echo claim proven lemma implies origin rel pos components entry test phase correct values comparing locations 
example horizontal constraint fails locations tile types locations share bit fact bits lemma implies dangerous loc loc reachable 
test phase tile sel tile sel state components easily shown definition reward function ensures reachable negative reward 
arguments constraints similar 
claim immediately implies exists consistent tiling exists policy achieving zero expected total reward 
completes proof direction main complexity result 
shown exists policy achieves expected reward zero exists consistent tiling demonstrating dec mdp nexp hard 
theorem dec mdp nexp hard 
corollary dec dec nexp complete 
discussion tools worst case complexity analysis analyzed variants decentralized control markov decision processes 
specifically proved finite horizon agent dec pomdp problem finite horizon agent dec mdp problem nexp hard 
horizon limited number states problems nexp complete 
results theoretical implications 
mdp pomdp problems problems studied provably admit polynomial time algorithms nexp 
second drawn connection markov decision processes body complexity theory deals exponential jump complexity due decentralization peterson reif babai fortnow lund 
direct implications researchers trying solve problems nature 
consider growing body algorithms obtaining exact approximate solutions pomdps jaakkola singh jordan cassandra littman zhang hansen meuleau kim kaelbling cassandra goldsmith li wells zhang :10.1.1.41.7263
finite horizon case stronger evidence way ciently convert dec mdp dec pomdp equivalent pomdp solve established techniques 
knowledge provide direction research development algorithms problems 
consider infinite horizon versions aforementioned problems 
shown infinite horizon pomdp problem undecidable madani hanks condon di erent optimality criteria 
pomdp special case dec pomdp corresponding dec pomdp problems undecidable 
addition possible reduce pomdp agent dec mdp simply add second dummy agent observes state ect state transitions rewards obtained infinite horizon dec mdp problems undecidable 
description finite state automaton describe domain rel pos state component component value evolves echo phase bit pairs chosen agents recall remains fixed phases 
component controlled deterministic finite state automaton fsa state set size polylogarithmic state set assumed include distinguished subsets states apart equal hor ver 
subset corresponds possible relation agents echoed tile positions 
automaton takes input string bit pairs alphabet automaton consists symbols component symbol representing bit produced agent second component representing bit produced agent 
automaton cross product individual automata keeps track di erent piece information tile positions represented sequence bit pairs 
automata described follows 
equal tile positions automaton computes tile positions produced equal 
consider regular expression constant sized fsa corresponding expression inputs length log ends accept state tile position represented sequence bits agent tile position represented sequence bits agent 
horizontally adjacent tile positions automaton computes second tile position horizontally adjacent tile position single increment coordinate 
regular expression follows log log sized fsa corresponding expression inputs length log ends accept state description automaton 
note case regular expression corresponding fsa polynomially bigger 
regular expressions consider property hold 

vertically adjacent tile positions automaton computes second tile position vertically adjacent tile position single increment coordinate 
regular expression follows log log sized fsa corresponding expression inputs length log ends accept state descriptions previous automata 
take cross product automata get new automaton size log 
accept accept accept sets accept states component automata respectively reject reject reject corresponding sets reject states 
sets construct distinguished sets apart equal hor ver cross product automaton states follows 
apart reject reject reject equal accept reject reject hor reject accept reject ver reject reject accept rest automaton states comprise set denote start states component automata 
define start state cross product automaton state 
define functions automaton needed main body proof 
function takes input state automaton bit pair returns state automaton 
second function takes input pair bit strings length returns state automaton starting initial state reading symbols formed corresponding bits strings sequence 
definition resulting state automaton starts state reads input symbol 
definition function fsa defined inductively follows fsa fsa fsa 
note range fsa inputs length log apart equal hor ver 
proof section assumed tiling grid size exact power 
note proof adapted adding components cross product fsa described new components fsas alphabet 
new component accepts string described tiling location represented tiling grid 
second new component behaves similarly 
dec mdp constructed smallest power larger modified new component fsa rejects faithfully echoed bit sequences process gives zero reward regardless tile types returned query 
new component viewed fsa alphabet focuses just agent echoes just agent echoes 
describe fsa checking constructing components straightforward 
suppose log number bits binary representation bits significant suppose di erent bits equal bits indices 
write regular expression detecting input bits significant represents number binary strictly shown regular expression equivalent fsa size log 
proof lemma assume exists consistent tiling select particular mapping describe policy achieves zero expected reward initial state 
mapping sequences observations actions sequences actions reachable part mapping specified unspecified observation sequence maps action wait 
note symmetric 
holds select phase select wait 
generate phase gen wait 
query phase query loc 
echo phase echo bit loc 
test phase test wait 
local policy defined identically loc replaced loc characterize set reachable states policy 
note action prescribed states yields reward zero 

straightforward show induction zero patterns applies select tile tile 
gen tile tile log bit loc bit loc 
query tile tile bit loc bit loc 
echo log bit loc bit loc loc loc item fsa significant bits loc loc respectively 
test loc loc fsa loc loc loc loc 
shown reward action prescribed policy reachable state observation sequence combinations zero consistent tiling 
proof lemma need new notation carry proof 
state state component corresponding value domain define state set written state agrees state components possibly value state component write observations sequence likewise state reachable observing define state show reachable observing follows index index value value tile sel tile sel 
show induction sequence length state nonzero nonzero 
conclude reachable desired 
base case induction take observation sequences involved length generate phase index equal zero 
inspection definition transition probabilities shows changing index value arbitrarily ect reachability 
inductive case suppose state reachable state reachable 

show state nonzero nonzero follows observations phase select generate agent action values index value ect nonzero long index equal pos bit equals value 
condition ensured hold index value components compatibility phase query action equal tile sel state component definitions index variant changes index value components ect nonzero query phase 
phase echo actions faithful echo location address bit indicated index state component assumed part inductive hypothesis faithful echo bits bit value vary observation sequences reach echo phase assumption variants 
echo 
changes index value components ect nonzero echo phase 
acknowledgment authors adler andy barto judy goldsmith dexter kozen victor lesser frank mcsherry ted perkins bob sloan ping xuan helpful discussions 
supported part national science foundation iri iri shlomo zilberstein ccr neil immerman iis robert givan nsf graduate fellowship daniel bernstein 
altman 

applications markov decision processes telecommunications survey 
shwartz 
ed markov decision processes models methods directions open problems 
kluwer new york ny 
babai fortnow lund 

non deterministic exponential time prover interactive protocols 
computational complexity 
blondel tsitsiklis 

survey computational complexity results systems control 
automatica 
cassandra littman zhang 

incremental pruning simple fast exact method partially observable markov decision processes 
proceedings thirteenth annual conference uncertainty artificial intelligence pp 

coradeschi karlsson stone balch asada 

overview robocup 
ai magazine 
hansen 

solving pomdps searching policy space 
proceedings fourteenth annual conference uncertainty artificial intelligence pp 

hsu marcus 

decentralized control finite state markov processes 
ieee transactions automatic control ac 
jaakkola singh jordan 

reinforcement learning algorithm partially observable markov decision problems 
proceedings advances neural information processing systems pp 

kaelbling littman cassandra 

planning acting partially observable stochastic domains 
artificial intelligence 
lewis 

complexity solvable cases decision problem predicate calculus 
proceedings nineteenth symposium foundations computer science pp 

goldsmith li wells 

brain full memory helps 
proceedings fifteenth conference uncertainty artificial intelligence pp 

madani hanks condon 

undecidability probabilistic planning partially observable markov decision problems 
proceedings sixteenth national conference artificial intelligence pp 

meuleau kim kaelbling cassandra 

solving pomdps searching space finite policies 
proceedings fifteenth conference uncertainty artificial intelligence pp 

mundhenk goldsmith allender 

complexity finite horizon markov decision process problems 
journal acm 
ooi wornell 

decentralized control multiple access broadcast channel performance bounds 
proceedings th conference decision control pp 

papadimitriou 

computational complexity 
reading ma addison wesley 
papadimitriou tsitsiklis 

complexity designing distributed protocols 
information control 
papadimitriou tsitsiklis 

intractable problems control theory 
siam journal control optimization 
papadimitriou tsitsiklis 

complexity markov decision processes 
mathematics operations research 
peshkin kim meuleau kaelbling 

learning cooperate policy search 
proceedings sixteenth international conference uncertainty artificial intelligence pp 

peterson reif 

multiple person alternation 
th annual symposium foundations computer science pp 

puterman 

markov decision processes 
new york wiley sons 
schneider wong moore riedmiller 

distributed value functions 
proceedings sixteenth international conference machine learning pp 

zhang 

algorithms partially observable markov decision processes 
phd thesis hong kong university science technology kowloon hong kong 

