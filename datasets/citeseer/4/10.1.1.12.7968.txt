generalized symbolic execution model checking testing khurshid corina willem visser mit laboratory computer science cambridge ma usa khurshid lcs mit edu kestrel technology llc riacs nasa ames research center mo ett field ca usa email arc nasa gov 
modern software systems concurrent manipulate complex data structures extremely reliable 
novel framework symbolic execution automated checking systems 
provide fold generalization traditional symbolic execution approaches 
de ne source source translation instrument program enables standard model checkers perform symbolic execution program 
second give novel symbolic execution algorithm handles dynamically allocated structures lists trees method preconditions acyclicity data integers strings concurrency 
program instrumentation enables model checker automatically explore di erent program heap con gurations manipulate logical formulae program data decision procedure 
illustrate applications framework checking correctness multi threaded programs take inputs unbounded domains complex structure generation non isomorphic test inputs satisfy testing criterion 
implementation java uses java pathfinder model checker 
modern software systems concurrent manipulate complex dynamically allocated data structures linked lists binary trees extremely reliable correct 
commonly techniques checking correctness systems testing model checking 
testing widely usually involves manual test input generation 
furthermore testing nding errors related concurrent behavior 
model checking hand automatic particularly analyzing concurrent reactive systems 
drawback model checking su ers statespace explosion problem typically requires closed system system environment bound input sizes :10.1.1.29.3872:10.1.1.32.5769:10.1.1.32.5769
novel framework symbolic execution automates test case generation allows model checking concurrent programs take inputs unbounded domains complex structure helps combat state space explosion :10.1.1.134.652
symbolic execution known program analysis technique represents values program variables symbolic values concrete initialized data manipulates expressions involving symbolic values 
symbolic execution traditionally arose context checking sequential programs xed number integer variables 
approaches extend traditional notion symbolic execution perform various program analyses approaches require dedicated tools perform analyses handle concurrent systems complex inputs :10.1.1.152.4499
provide fold generalization traditional symbolic execution 
de ne source source translation instrument program enables symbolic execution program performed standard model checker underlying language having build dedicated tool 
instrumented program symbolically executed model checker supports nondeterministic choice 
model checker checks program automatically exploring di erent program heap con gurations manipulating logical formulae program data values decision procedure 
second give novel symbolic execution algorithm handles dynamically allocated structures lists trees method preconditions acyclicity lists data integers strings concurrency 
symbolically execute method algorithm uses lazy initialization initializes components method inputs needed basis requiring priori bound input sizes 
method preconditions initialize elds valid values method postconditions test oracles check method correctness builds previous korat framework speci cation testing :10.1.1.122.9788
support partial correctness properties assertions program temporal speci cations 
main contributions providing fold generalization symbolic execution enable standard model checker perform symbolic execution give symbolic execution algorithm handles advanced programming constructs performing symbolic execution code explicit state model checking address state space explosion problem check behavior code symbolic values represent data large domains enumerating checking small set concrete values achieve modularity checking programs uninitialized variables allows checking compilation unit isolation check strong correctness properties concurrent programs take inputs unbounded domains complex structure exploit model checker built capabilities di erent search strategies heuristic search checking temporal properties partial order symmetry reductions automating non isomorphic test input generation satisfy testing criterion programs complex inputs preconditions series examples prototype implementation java uses java pathfinder model checking omega library decision procedure korat program instrumentation approach extends languages model checkers decision procedures :10.1.1.32.5769:10.1.1.134.652
class node int elem node node null elem elem node return return input list constraint returned list fig 

code sort rst nodes list left analysis code symbolic execution approach right section shows example analysis framework 
section describes traditional symbolic execution 
section gives algorithm generalized symbolic execution 
section describes framework section describes implementation instrumentation 
section illustrates applications implementation 
give related section conclude section 
example section presents example illustrate approach 
check method destructively updates input structure 
java code declares class node implements singly linked lists 
elds elem represent respectively node integer value node 
method destructively updates input list referenced implicit parameter sort rst nodes returns resulting list 
analyze prototype implementation section check unhandled runtime exceptions execution 
analysis automatically veri es property holds 
analysis checks symbolic executions 
executions represent possible actual executions 
symbolic execution analysis produces input structure constraint integer values input output structure 
row actual input list structure integer values satisfy constraint result output list 
execution value elem eld indicates eld accessed cloud indicates eld accessed 
input structure represents isomorphism partition input space row table shows input represents cyclic acyclic int assert false pc pc false 
pc pc pc pc pc pc true fig 

code swaps integers corresponding symbolic execution tree transitions labeled program control points lists nodes rst element greater second element list returned rst elements swapped 
comment check null line analysis reports top input method raises unhandled nullpointerexception 
input output pairs stay 
analysis refutes method correctness providing counterexample 
analysis supports method preconditions 
example add precondition input list acyclic analysis consider executions input cycle 
input structures constraints test input generation 
background symbolic execution main idea symbolic execution symbolic values actual data input values represent values program variables symbolic expressions :10.1.1.134.652
result output values computed program expressed function input symbolic values 
state symbolically executed program includes symbolic values program variables path condition pc program counter 
path condition quanti er free boolean formula symbolic inputs accumulates constraints inputs satisfy order execution follow particular associated path 
program counter de nes statement executed 
symbolic execution tree characterizes execution paths followed symbolic execution program 
nodes represent program states arcs represent transitions states 
consider code fragment swaps values integer variables greater shows corresponding symbolic execution tree 
initially pc true symbolic values respectively 
branch point pc updated assumptions inputs order choose alternative paths 
example execution rst statement alternatives statement possible pc updated accordingly 
path condition false set inputs satisfy means symbolic state reachable symbolic execution continue path 
example statement unreachable 
algorithm section describes algorithm generalizing traditional symbolic execution support advanced constructs modern programming languages java 
focus sequential programs 
section presents treatment multithreaded programs 
lazy initialization heart framework novel algorithm symbolically executing method takes inputs complex data structures unbounded data 
key feature algorithm starts execution method inputs uninitialized elds uses lazy initialization assign values elds initializes elds rst accessed method symbolic execution 
allows symbolic execution methods requiring priori bound number input objects 
explain algorithm symbolically executes method input object implicit input 
methods multiple parameters treated similarly :10.1.1.122.9788
execute method class algorithm rst creates new object class uninitialized elds 
algorithm invokes execution proceeds java semantics operations elds traditional symbolic execution operations primitive elds exception special treatment accesses uninitialized elds 
execution accesses uninitialized eld algorithm nondeterministically initializes eld value null new object uninitialized elds object created prior eld initialization systematically treats aliasing 
execution accesses uninitialized primitive string eld algorithm rst initializes eld new symbolic value appropriate type execution proceeds 
method preconditions ensure elds initialized values permitted precondition eld initialized algorithm checks precondition fail structure path condition currently constrain uninitialized eld type nondeterministically initialize 
null 
new object class uninitialized eld values 
object created prior initialization eld type method precondition violated backtrack primitive string eld initialize new symbolic value appropriate type fig 

lazy initialization execution evaluates branching condition primitive elds algorithm nondeterministically adds condition negation corresponding path condition checks path condition satis ability decision procedure 
path condition infeasible current execution terminates algorithm backtracks execution proceeds 
systematically updates path conditions primitive elds 
input generation generate inputs meet testing criterion algorithm symbolically executes paths speci ed criterion 
path generates input structure path condition primitive input values de ne set inputs execute path 
handle programs perform destructive updates algorithm builds mappings objects uninitialized elds objects created elds initialized mappings construct input structures 
isomorph breaking structure generation nice consequence lazy initialization input elds sequential programs algorithm executes program paths non isomorphic inputs 
systematic generation inputs complex structural constraints symbolically executing predicate checks structural constraints :10.1.1.122.9788
illustration illustrate algorithm running example 
symbolic execution tree illustrates paths algorithm explores symbolically executing 
node execution tree denotes state consists state heap including symbolic values elem elds path condition accumulated branch path tree 
transition execution tree connects tree nodes de nition isomorphism views structures edge node labeled graphs 
stmt initialize stmt initialize elem stmt initialize elem stmt initialize 

pc 
pc fig 

symbolic execution tree excerpts notation described section corresponds execution statement lazy initialization step 
branching tree corresponds nondeterministic choice introduced handle aliasing build path condition 
algorithm creates new node object invokes object 
line accesses uninitialized eld causes initialized 
algorithm explores possibilities eld null eld points new symbolic object eld points previously created object type option 
intuitively means point execution di erent assumptions con guration input list di erent aliasing possibilities 
initialization happens execution statement results possibilities node objects point execution 
condition involving primitive elds symbolically executed statement execution tree branch corresponding possible outcome condition evaluation 
evaluation condition involving elds cause branching uninitialized elds accessed 
precondition input acyclic algorithm explore transitions marked 
input list corresponding output list pointed bottom tree node shown bottom row 
counterexample test suite heap path condition thread scheduling path condition data heap configuration thread scheduling model checking program source instrumentation code program instrumented state procedures decision specification correctness continue backtrack fig 

general methodology framework section describes symbolic execution framework checking correctness software systems 
illustrates basic framework 
enable model checker perform symbolic execution algorithm section instrument original program doing source source translation adds nondeterminism support manipulating formulae represent path conditions 
instrumentation allows model checker supports backtracking nondeterministic choice perform symbolic execution 
essentially model checker explores symbolic execution tree program 
code instrumentation uses correctness speci cation add precondition checking performed eld initialization postcondition checking performed execution completes original program 
describe details instrumentation prototype implementation performs section 
model checker checks instrumented program usual state space exploration techniques 
state includes heap con guration path condition primitive elds thread scheduling 
path condition updated checked satis ability appropriate decision procedure omega library linear integer constraints :10.1.1.134.652
path condition unsatis able model checker backtracks 
correctness speci cations preconditions postconditions assertions general safety properties 
safety properties written logical formalism recognized model checker speci ed code instrumentation :10.1.1.134.652:10.1.1.134.652
framework correctness checking test input generation 
checking correctness model checker reports counterexample violate correctness criterion 
generating test inputs model checker generates paths witnesses testing criterion encoded speci cation 
testing criteria encoded correctness speci cations :10.1.1.12.4134
reported path model checker reports input heap con guration path condition primitive input elds thread scheduling reproduce error 
multi threaded non deterministic systems framework allows standard model checker perform symbolic execution 
model checker systematically analyze thread interleavings forms nondeterminism code 
framework exploits model checker built ability combat state space explosion partial order symmetry reductions 
loops recursion method invocations exploit model checker search abilities handle arbitrary program control ow 
require model checker perform state matching state matching general undecidable states represent path conditions unbounded data 
note performing forward symbolic execution programs loops explore nite execution trees 
systematic state space exploration depth rst search iterative deepening section breadth rst search section framework supports heuristic search :10.1.1.134.652
framework nding counterexamples safety properties prove correctness programs nite execution trees decidable data constraints 
implementation implemented approach java check java programs 
code instrumentation build korat tool :10.1.1.122.9788
java pathfinder jpf model checking instrumented programs :10.1.1.32.5769:10.1.1.134.652
decision procedure java implementation omega library manipulates sets linear constraints integer variables :10.1.1.134.652
section outlines instrumentation brie describes jpf presents critique approach 
instrumentation conceptually instrumentation proceeds steps 
integer elds operations instrumented 
declared type integer elds input objects changed expression library class provide support manipulation symbolic integer expressions 
type analysis determine integer variables declared types changed expression 
operations involving variables replaced method calls implement equivalent operations manipulate objects type expression 
automated type analysis abstraction component bandera toolset performs kind analysis di erent purpose bandera performs source source translation instrument program reduce cardinality data sets associated program variables 
class node expression elem node boolean initialized boolean elem initialized 
node get null expression pc update gt get elem minus get get elem new node get set get set return return class expression static pc expression minus expression 
class 
constraints boolean update gt expression expression boolean result choose boolean result add constraint gt add constraint le satisfiable backtrack return result fig 

instrumented code left library classes right second eld accesses instrumented 
field reads replaced get methods return value eld initialized get methods implement lazy initialization described section 
field updates replaced set methods update eld value 
get set methods eld set ag indicate eld initialized 
illustration instrumentation consider code 
gives part resulting code instrumentation library classes provide 
static eld expression 
pc stores numeric path condition 
method update gt nondeterministic choice call choose boolean add path condition constraint negation constraint invocation expresses returns corresponding boolean 
method satisfiable uses omega library check path condition infeasible case jpf backtrack 
method minus constructs new expression represents di erence input parameters 
subclass expression wraps concrete integer values 
keep track uninitialized input elds add boolean eld class declaration eld original declaration initialized elem initialized set true get set methods 
store input objects created result lazy initialization variable class java util vector class instrumented 
get methods elements vector systematically initialize input elds 
implementation provides library class symbolically manipulate strings 
java pathfinder current prototype uses java pathfinder model checker jpf model checker java programs built top custom java virtual machine jvm 
built jvm handle language features java addition treats nondeterministic choice expressed annotations program analyzed 
features adding nondeterminism implement updating path conditions initialization elds 
jpf supports program annotations cause search backtrack certain condition evaluates true analysis infeasible paths path conditions unsatis able 
lastly jpf supports various heuristics including ones increasing testing related coverage statement branch condition coverage guide model checker search :10.1.1.134.652
discussion preconditions initializing elds 
particular eld initialized value violates precondition 
notice evaluate precondition structure may uninitialized elds require precondition conservative return false initialized elds structure violate constraint precondition 
conservative precondition simply undecidability path conditions may lead analysis explore infeasible program paths 
provided treatment arrays 
systematically initialize array length array eld rst accessed treat array component eld :10.1.1.122.9788
extend analysis treat array length symbolic integer 
algorithm handles subclassing step consider objects created prior initialization eld type type subclass applications section shows applications framework correctness checking distributed algorithm test input generation ight software 
checking multithreaded programs inputs illustrate application symbolic execution framework example incorrectly implements distributed algorithm sorting linked lists integers ascending order sort input list algorithm spawns number threads proportional number nodes list 
thread assigned adjacent list nodes allowed maximum number swaps perform elements nodes 
example illustrates symbolic execution technique context concurrency structured data linked lists integer values method preconditions partial correctness criteria 
correctly sort list algorithm controlling thread scheduler 
class list node header precondition acyclic void header null return header null return int node header null new start class extends java lang thread swap current elem current elem node current int node int current public void run int int current assert current inorder class list boolean acyclic set visited new node current header current null visited add current return false current current return true class node int elem node synchronized boolean synchronized elem elem actual swap int elem elem elem elem return true return false synchronized boolean inorder synchronized elem elem return false return true fig 

distributed sorting method singly linked lists java code declares singly linked list de nes method sorting lists 
method takes input list spawns threads sort list 
adjacent pair nodes list spawns new thread responsible swapping elements nodes 
method precondition input list acyclic speci ed precondition clause 
method returns true false invocation swapped order elements simply op 
note di erent performs destructive updating input list 
synchronization ensure list element accessed thread time 
assert clause declares partial correctness property states thread performs allowed maximum number actual swaps element node current order 
implementation symbolically execute acyclic lists analyze method correctness 
analysis took seconds ghz pentium gb memory produced counterexample input list thread swaps thread swaps resulting list order input list consists symbolic integers thread allowed swap thread allowed swaps 
thread performs swap thread performs swap 
thread performs swap 
resulting list swaps thread allowed swaps possible bring order 
input list thread scheduling give counterexample speci ed correctness property 
note analyze priori bound size list number threads spawn 
test input generation applied framework derive test inputs code coverage speci cally condition coverage altitude switch ight control software lines java code :10.1.1.134.652:10.1.1.134.652
switch receives input sequence time stamped messages indicating current altitude aircraft indication reading considered accurate represented strings 
input sequence messages implemented linked list unde ned length 
program instrumented print input sequence integer string constraints new condition covered executed 
application presents program input data structure manipulates integer string constraints 
breadth rst search model checking generate test inputs cover conditions minutes running time ghz pentium gb memory 
contrast traditional model checking jpf xed input sequence messages range altitude values picked nondeterministically feet model checking nish consequence generate test inputs third conditions memory exhausted 
related previous developed korat constraint solver imperative predicates :10.1.1.122.9788
korat implements novel search algorithm performs source source translation instrument java program systematically handle aliasing subclassing 
korat provides ecient generation non isomorphic inputs generate complex structures preconditions exhaustive black box testing input bound 
additionally provides input generation white box testing supports symbolic manipulation data values decision procedure require bounds input sizes supports checking multi threaded programs adapts korat instrumentation enable model checker perform symbolic execution 
king developed system symbolic execution programs xed number integer variables :10.1.1.134.652
supported various program analyses test case generation earliest systems kind 
pre bug nding tool essentially symbolic execution 
pre successfully large scale commercial applications 
pre analyzes programs written aims detect defects dynamic memory management 
check rich properties invariants data structures 
pre may errors may report false alarms 
projects aim developing static analyses verifying program properties 
extended static checker esc uses theorem prover verify partial correctness classes annotated jml speci cations 
esc verify absence errors null pointer dereferences array bounds violations division zero 
tools esc verify properties complex linked data structures 
research projects attempt address issue 
valued logic analyzer tvla rst static analysis system verify list structure preserved programs perform list reversals destructive updating input list :10.1.1.134.652
tvla performs xed point computations shape graphs represent heap cells shape nodes sets indistinguishable runtime locations summary nodes 
lazy initialization input elds framework related materialization summary nodes tvla 
explore connection 
pointer assertion logic engine pale verify large class data structures represented spanning tree backbone possibly additional pointers add extra information :10.1.1.134.652
data structures include doubly linked lists trees parent pointers threaded trees 
shape analyses tvla pale typically verify properties programs perform operations primitive data values 
alloy constraint analyzer analyzing bounded segments computation sequences manipulating linked structures translating rst order logic :10.1.1.134.652
approach requires bound input sizes treat primitive data symbolically 
lot interest applying model checking software 
java pathfinder verisoft operate directly java respectively program :10.1.1.32.5769:10.1.1.134.652
projects bandera translate java programs input language spin nusmv :10.1.1.134.652
program analysis analyze procedure isolation 
source source translation enables tools perform symbolic execution enables analyze systems complex inputs analyze procedures isolation 
slam tool focuses checking sequential code static data engineered predicate abstraction abstraction re nement tools :10.1.1.134.652:10.1.1.134.652
handle dynamically allocated data structures 
symbolic execution map counterexamples concrete executions re ne abstraction adding new predicates discovered symbolic execution 
composite symbolic library uses symbolic forward xed point operations compute reachable states program 
uses widening help termination analyze programs manipulate lists xed number integer elds program analysis 
novel framework symbolic execution automated checking concurrent software systems manipulate complex data structures 
provided fold generalization traditional symbolic execution approaches 
de ned source source translation instrument program enables standard model checkers perform symbolic execution program 
second gave novel symbolic execution algorithm handles dynamically allocated structures method preconditions primitive data concurrency 
illustrated applications framework checking correctness multi threaded programs take inputs unbounded domains complex structure generation non isomorphic test inputs satisfy testing criterion 
illustrated framework context java programs jpf omega library framework instantiated languages model checkers decision procedures 
plan investigate application widening abstraction techniques context framework 
plan integrate di erent semi decision procedures constraint solvers allow handle non linear constraints 
believe performing symbolic execution model checking powerful approach analyze software 
scales real applications remains seen 
authors doron peled useful discussions viktor darko marinov su anonymous referees useful comments 
rst author done partly visiting nasa ames research center nasa ames riacs summer student research program funded part nsf itr 

ball majumdar millstein rajamani 
automatic predicate abstraction programs 
proc 
acm sigplan conference programming language design implementation pldi volume acm sigplan notices pages 
acm press june 

boyapati khurshid marinov 
korat automated testing java predicates 
proc 
international symposium software testing analysis issta july 

bush pincus static analyzer nding dynamic programming errors 
software practice experience 

cimatti clarke giunchiglia roveri 
nusmv new symbolic model checker 
international journal software tools technology transfer 

coen ghezzi 
symbolic execution verifying safety critical systems 
proc 
th european software engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages 
acm press 

corbett dwyer laubach robby zheng 
bandera extracting nite state models java source code 
ghezzi jazayeri wolf editors proc 
nd international conference software engineering icse pages 
acm 

detlefs leino nelson saxe 
extended static checking 
research report compaq systems research center 

heitmeyer 
model checking generate tests requirements speci cations 
proc 
th european engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages 
springer verlag 

godefroid 
model checking programming languages verisoft 
proc 
th annual acm symposium principles programming languages popl pages paris france jan 

visser 
model checking java programs structural heuristics 
proc 
international symposium software testing analysis issta 
acm press july 

heimdahl choi 
deviation analysis model checking 
proc 
th ieee international conference automated software engineering ase 

holzmann 
model checker spin 
ieee transactions software engineering may 

hong lee ural 
temporal logic theory test coverage generation 
proc 
th international conference tools algorithms construction analysis systems tacas apr 

king 
symbolic execution program testing 
communications acm 

moeller schwartzbach 
pointer assertion logic engine 
proc 
sigplan conference programming languages design implementation pldi snowbird ut june 

pugh 
practical algorithm exact array dependence analysis 
communications acm 

sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm transactions programming languages systems jan 

jackson 
checking properties heap manipulating procedures constraint solver 
proc 
th international conference tools algorithms construction analysis systems tacas poland apr 

visser havelund brat park 
model checking programs 
proc 
th ieee international conference automated software engineering ase grenoble france 


automated veri cation concurrent linked lists counters 
hermenegildo editor proc 
th international static analysis symposium sas volume lecture notes computer science 
springer verlag 
