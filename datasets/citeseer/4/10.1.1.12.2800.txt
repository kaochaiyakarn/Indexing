systematic approach static access control fran cois pottier inria rocquencourt christian university vermont scott smith johns hopkins university java security architecture includes dynamic mechanism enforcing access control checks called stack inspection process 
architecture appealing features access control checks implemented dynamic method calls 
highly non declarative form speci cation hard read leads additional run time overhead 
develops type systems statically guarantee success checks 
systems allow security properties programs clearly expressed types serve static declarations security policy 
develop systems systematic methodology show security passing style translation proposed wallach appel felten dynamic implementation technique gives rise static security aware type systems composition conventional type systems 
de ne general hm framework easily construct constraint uni cation type systems 
categories subject descriptors programming languages language constructs features control structures polymorphism logics meanings programs studies program constructs type structure general terms languages reliability security theory additional key words phrases type systems stack inspection access control 
java security architecture gong java jdk includes mechanisms protect systems operations performed untrusted code 
access control decisions enforced dynamic checks 
goal decisions statically extensions type system 
access control violations caught compile time run time 
furthermore type extensions constitute statically speci ed security policy preferred dynamic 
contact author address christian department computer science university vermont colchester ave burlington vt 
permission digital hard copy part material fee personal classroom provided copies distributed pro commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior speci permission fee 
acm transactions programming languages systems vol 
tbd 
tdb month year pages 

fran cois pottier java security architecture brie review java security architecture gong wallach 
stack inspection algorithm underlying architecture primarily concerned code access control single jvm code loaded di erent code codebase di erent access rights 
instance applets allowed read write arbitrary les applets may allowed read write les tmp 
applets may read write tmp permissions read write les 
stack inspection system di erent modes di erent modes stated clearly literature review 
rst mode command executed critical operation system library low level le write command raise exception execution continues le written 
applet example applet tries write tmp scratch succeed applet privilege describe checking process detail 
second mode may need temporarily raise privileges allow system perform privileged operation untrusted code 
example system may need read font le usr java fonts helvetica fnt applet font cause exception applet read le read usr java fonts helvetica fnt fail 
command designed solve problem system execute reads font executed system applet privileges succeed executed system privileged operation 
access control decisions stack inspection algorithm 
original requestor action le read may far back call stack applet invoked system le method turn invoked system methods nally invoked low level system method read le invoked 
back call stack frame owned applet codebase 
searches back stack making sure frame codebase permission needed 
covers rst case usage 
second case temporary raising privileges needed read font le command adds agged stack frame stack performs privileged operation privilege checked command stack frames searched 
frame encountered appropriate permissions check terminates successfully point applet stack frames may stack applet code induced font load privileges queried 
framework java security architecture basis important principles widely practice signi cant aws 
performance penalty pay due need run time stack inspection 
architecture acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
non declarative undesirable security policies 
particular security properties enforced method calls highly non declarative form speci cation 
access control speci cation dicult read buried code potentially complex control ow structure code 
speci cations dicult read easy get wrong security speci cation thing wants get wrong 
explores solutions problems static type systems 
de ne security typing system statically typechecks statically veri es success run time access control checks 
obviates need stack inspection run time checks proven succeed compile time 
foundational framework developed important issues addressed applied real language java 
employ technical tools streamline results 
reduce security typing problem conventional typing problem translation method inspired pottier 
standard language row types emy describe sets privileges 
re hm framework odersky sulzmann allows wide variety type systems de ned single stroke saves proof ort importantly shows custom type systems arise naturally standard 
develop di erent type systems including constraint uni cation systems 
de ning simpli ed model java security architecture sec calculus equipped non standard operational semantics includes speci cation stack inspection 
order construct static type system sec translate standard calculus called set translation style transformation wallach wallach implements stack inspection passing sets privileges run time 
purpose set equipped built notions set set operations 
de ne type system set set standard calculus able de ne type system simple instance hm framework odersky 
fact framework family type systems may succinctly de ned di erent costs bene ts 
order give precise types set built set operations instance uses set types de ned simpli cation emy record types emy 
lastly show type system set gives rise translation type system sec correctness follows immediately provided translation correct 
quite easy show property involve types 
expands conference papers pottier smith 

source language sec section de nes sec simpli ed model jdk security architecture 
calculus equipped notion code ownership constructs enabling checking privileges 
reader wonder appealing mathematical form sec faithful jdk implementation acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier resources principals values enable check expressions test signed expressions enable evaluation contexts fig 

grammar sec version language de ned clearly re ects jdk implementation details shown embeddable sec ensures con dence correctness sec model java jdk architecture 
assume arbitrary set resources known privileges 
range resources sets thereof respectively 
fournet gordon fournet gordon de ne set principals powerset identify principal set resources access 
range principals sets thereof respectively 
write empty privilege set principal access rights 
grammar sec fig 

abstraction may recursively refer program variable 
con ation binders simpli es treatment recursion 
write appear free signed expression behaves expression endowed authority principal body abstraction required signed expression piece code principal 
construct enable allows authorized principal enable resource expression construct check asserts currently enabled 
enabled evaluated execution fails 
construct test dynamically tests enabled branching holds fails respectively 
stack inspection jdk determines resource enabled literally examining runtime stack name stack inspection 
give simple speci cation process noticing stacks implicitly contained evaluation contexts grammar de ned fig 

context de nes path term root active redex nds exactly security annotations jdk maintain stack code owners enabled resources formalize idea associate evaluation context nite string je principals resources called stack 
right letters string correspond stack frames 
write empty stack acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
fig 

backward stack inspection algorithm frg fig 

forward stack inspection algorithm concatenation stacks je ej je jv je ej je je jp je de ne stack inspection algorithm 
give variants backward fig 
forward fig 

scans stack starting frames moving ancestors 
hand scans stack order built 
furthermore formulation altered internally computes access resource legal set resources may legally accessed current stack 
algorithms referred lazy eager respectively gong gong 
employed current jvm implementations forms basis security passing style wallach translation introduce sect 

theorem states forward backward stack inspection fact equivalent 
subsequently write specifying algorithms 
write je theorem 
assume stack resource stand set principals contain statements equivalent holds rules fig 
holds rules fig 
sux belongs regular language pr proof 
proving rst statement equivalent third 
check auxiliary judgement holds sux belongs pr check holds rules fig 
sux belongs regular language pr checks immediate 
prove second statement equivalent third 
resp 
resp 
set stacks equivalently resp 
resp 

straightforward check rules acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier fig 
solutions recursive equations frg inductive argument shows holds 
rewriting steps bring equations form evident exactly pr give details 
principle check mechanized verifying minimal deterministic nite automaton symbol alphabet frg frg associated regular expression exactly described equations 
remains conclude noticing rst rule fig 
holds operational semantics sec operational semantics sec de ned reduction rules check test test enable evaluation context explicit rule allows looking needing perform security checks 
note case implies 
enclosing new evaluation context enables privileges possibly causing tests form test resolved di erently 
rst rules standard 
rule allows check reduce stack inspection succeeds expressed side condition execution blocked 
rules stack inspection similar way determine reduce test cause execution fail 
rules state security annotations unnecessary expression enclose reduced value 
java virtual machine rules implemented simply popping stack frames security annotations contain executing method 
operational semantics constitutes concise formal description java stack inspection higher order setting 
easy check closed term value reducible form check 
terms third category stuck represent access control violations 
expression said go wrong stuck expression holds 

target calculus set de ne standard calculus set target translation 
calculus equipped number constants provide set operations acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
expressions values evaluation contexts fig 

grammar set jfk je kp je kp je kp kp je kp je kp frg jtest kp je kp je kp jfk jp ek fig 

source target translation fig 

syntactic sugar 
respectively 
constant represents constant privilege set 
construct asserts element set denoted execution fails case 
construct resp 
allows computing union resp 
intersection set denoted constant set lastly expression dynamically tests belongs set denoted accordingly invokes passing 
operational semantics set follows expression said go wrong stuck expression holds 

source target translation de nition translation sec set de ned fig 

distinguished identi ers assumed appear source expressions 
notice may appear free translated expressions 
translating unsigned expression requires specifying current principal wish translate expression minimal hypotheses principal void security context 
de ne acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier jek 
notice appear free closed idea translation simple variable bound times set currently enabled resources 
function accepts extra parameter execute caller security context 
result function call second parameter 
constructs enable cause locally bound new value re ecting new security context speci cally enables disables privileges available constructs check test implemented simply looking current value re bound branch value 
may appear super uous rst sight important impact typing allows di erent precise type branch 
translation viewed generalization security passing style transformation wallach wallach higher order setting 
wallach advocated idea implementation technique eciency mind vehicle proof type systems 
eciency stake sucient translation scheme correct 
section devoted proving 
point correctness proof necessary fact chose de ne semantics sec source level section 
chosen consider security passing style translation de nition sec semantics proof necessary 
banerjee naumann banerjee naumann follow approach giving denotational semantics incorporates security passing style translation 
properties basic property translation appears free translation value 
furthermore translation value depend current principal write purposes proofs need isolate particular sub class target language reductions wish view administrative sense explained 
subset de ned rst lemma expresses fact translation implements forward stack inspection algorithm fig 

states evaluating je context bound leads evaluating jek context bound furthermore purely administrative reduction sequence 
ects security context re ect computational steps apparent original program 
proof lemma presents diculty close similarity de nitions translation function stack inspection algorithm 
acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
lemma 
assume je exist target evaluation context principal source expression je jek proof 
induction structure stand substitutions respectively 
case 
picking trivially satis es requirement 
case je je je furthermore induction hypothesis applied yields je jek 
picking je ts bill 
case case similar previous 
apply induction hypothesis obtain pick 
evaluation context value 
case case similar 
apply induction hypothesis obtain pick je 
case enable je may deduce stands frg 
de ne 
je frg je je applying induction hypothesis yields je jek 
picking meets goal 
case je may deduce stands de ne 
je je je applying induction hypothesis yields je jek 
picking meets goal 
come central lemma stating source expression leads computation step source expression translation reduces modulo administrative reductions translation lemma 
implies proof 
form respectively 
je exists unique clearly resource equivalent de ne 
lemma exist evaluation context principal source expression jek acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier assume time je je holds 
je je desired result 
remains prove je je cases form case 
je vk fk jfk appear free values jfk fk jf straightforward auxiliary lemma je auxiliary lemma mentioned takes advantage fact translation value depend parameter omit proof 
case 
je je free je je je auxiliary lemma je case enable je vk frg je take advantage fact occur free 
case check je je je je case test equals equivalently 
je jtest je je je je je case je jp vk je take advantage fact occur free fact expression depend acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
result easily generalized reduction sequences arbitrary length lemma 
implies proof 
induction length reduction sequence base case result immediate 
inductive case applying lemma hand induction hypothesis hand obtain operational semantics target language deterministic reduction sequences starting sub sequence 
case diagram collapses result 
corollary obtain soundness theorem translation 
essentially states security passing style valid implementation java stack inspection discipline 
theorem 
goes wrong goes wrong 
diverges diverges 
proof 
assume reduces value lemma yields value diagram collapses second assume goes wrong 
stuck holds 
prove goes wrong induction length reduction sequence 
base case stuck 
form check 
je exists unique necessarily lemma may reduced term form 
easy check term stuck 
goes wrong 
inductive case induction hypothesis shows goes wrong 
furthermore lemma shows reduces reduct reduction deterministic go wrong 
result follows 
third assume admits nite reduction sequence 
sequence involve nite number reduction steps semantics sec deprived reduction rule terminating 
slight generalization lemma states reduction involves reduction steps reduces modulo administrative reductions reduction steps 
proof omit hinges fact reduction administrative reduction 
implies admits nite reduction sequence 

types set de ne type system target calculus instance parametric framework hm odersky pottier sulzmann acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier hm var hm const 
hm sub hm intro fv hm elim hm abs hm app hm fig 

system hm 
hm generic type system hindley milner tradition parameterized constraint system sect 
brie recalls de nition 
sect 
de nes speci constraint system called sets yielding type system hm sets 
sect 
extends hm sets entire language set assigning types primitive operations 
sect 
states type safety results discusses choices type system may de ned uni cation constraint system exible respect accuracy initial type bindings 
system hm adopt de nition hm pottier 
framework parameterized constraint system notions types constraints interpretation constraints model 
constraint system type scheme triple set quanti ers constraint type kind type see sect 
written type environment partial mapping program variables type schemes 
judgement quadruple satis able constraint type environment expression type scheme written derivable rules fig 

rules correspond pottier rules relevant stateful features needed presentation 
note hm const rule populating 
initial bindings allows typing new language constants particular instances hm 
case set range primitive operators syntactic type safety theorem style wright felleisen proven pottier 
signi cantly theorem holds respect call value calculus instance hm theorem may easily extended incorporate additional constants proving soundness initial bindings respect semantics functional constants called typability property 
acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
types pre abs presence constructors true constraints fig 

sets grammar type type row 
type pres row frg row pres row pres true type fig 

kinding rules theorem 
holds go wrong 
discuss typability type safety set thoroughly sect 

constraint system sets order give precise types primitive set operations set need speci types constraints 
logical interpretation de nes meaning form constraint system called sets 
syntax types constraints de ned fig 

type language features called presence constructors standard row constructors emy set type constructor 
presence types record resource appears privilege set 
pre means known appear set abs means known appear 
course analysis approximate means known member set 
lastly concerns eciency type inference call fourth presence constructor roughly speaking means irrelevant appears set code requires privilege test unreachable 
addition constants presence type variable 
describe contents set rows presence types 
row nite description nite object possibly partial function resource names presence types 
precisely row describes function maps resources domain nite number type 
rows formed basic building blocks 
row constructor allows forming constant rows presence type row maps resources domain second row constructor 
allows adding entry existing row row maps presence type behaves row lastly row variable 
original presentations rows emy equip row types equational theory particular allows row entries commute 
acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier presentation equations axioms simply happen hold interpretation types 
set described row domain wrapped set type constructor yielding type form determine particular resource appears set queries row yielding presence type 
query carried unifying fresh presence row variables respectively 
instance singleton set frg value type fr pre 
determine resource appears set solve equation pre abs 
distinct leads abs pre abs re ects fact belong frg 
treatment sets inspired wand emy treatment records set fact degenerate record eld unit type 
constraint language ers standard equality subtyping constraints simple form conditional constraints 
illustrated sect 

ensure meaningful types constraints built immediately equip kinds de ned pres type ranges nite subsets kinds allow distinguishing presence types rows regular types 
furthermore kinds keep track row domain row kind row represents function domain nr 
particular complete row total function presence types kind row 
kind assume distinct denumerable set type variables represent type variables 
consider types constraints de ned fig 

purpose rules guarantee constraint de ned interpretation model de nition follows 
kind associate mathematical structure 
set presence constructors 
nite set resources set total constant functions 
free algebra generated constructors signature 
signature 
structures equipped ordering 
choice 
wish allow subtyping merely de ne ordering equality 
proceed follows 
lattice de ned resp 
greatest element 
resp 
abs pre incomparable 
ordering extended point wise covariantly extended inductively viewing constructor 
covariant constructor contravariant resp 
covariant rst resp 
second argument 
gives rise called structural atomic subtyping relation related types may di er presence annotations 
may give interpretation types constraints model 
parameterized kind preserving assignment function kind maps 
interpretation types obtained extending acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
true pres fig 

interpretation constraints map type kind element follows notice interpretation row constructors re ects informal explanation validates expected equational theory 
fig 
de nes constraint satisfaction predicate 
arguments assignment constraint 
notation means coincide possibly de nition standard 
rule speci es conditional constraint components rows interpreted point wise nite conjunction conditional constraints bearing presence types 
entailment de ned usual read entails holds assignment implies refer type constraint logic interpretation sets 
precisely de ned logics interpreted equality non trivial subtype ordering 
refer sets sets respectively 
dealing primitive operations set typing rules hm cover calculus 
extend hm sets language set assign types primitive operations 
de ne initial type environment 
follows fr pre fr pre fr pre fr fr pre fr fr fr 
fr pre 
fr abs range type variables kind type row pres respectively 
abuse notation fr denotes denotes may conditional constraints assign exible type scheme 
initial type environment obtained replacing binding acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier 
fr 
fr pre 
fr abs pre abs pre abs input output branch represented respectively linked input output construct represented conditional constraints 
intuitively means security requirements return type branch may entirely ignored branch liable taken 
background conditional constraints reader referred aiken pottier 
type systems rel sect 
describes constraint systems sets sets sect 
de nes initial typing environments 

choices give rise related type systems refer rel rel range respectively 
ers di erent compromise accuracy readability cost analysis 
case theorem may extended entire language set proving simple typability wright felleisen lemma checking 
correctly describes behavior primitive operations 
subject section 
despite sharing common formalism systems may call vastly di erent implementations 
instance hm come constraint resolution algorithm 
simple extension hindley milner type system rows may implemented uni cation emy 
similar requires conditional delayed uni cation constraints adding complexity implementation 
require maintaining subtyping constraints usually leading complex implementations 
proof typability set rst state basic properties sets set types proofs omitted 
lemma 
closed value 
holds rel set pre abs lemma 
fr pre holds rel lemma 
fr holds rel fr pre fr 
mentioned sect 
extending theorem set requires proving soundness initial bindings primitive operators 
state called typability property style pottier lemma 
rel constant closed value hold de ned holds 
acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
proof 
suppose consider cases rst case obtained hm elim hm sub second case obtained hm elim 
normalization result proved pottier 
rst case hm sub premises form 
properties implies 
assumption hm sub implies 
case proof imply de ned holds 
result follows hm sub 
consider second case 
type scheme form derivation consists single instance hm elim substitution domain 
proceed case analysis case case fr pre lemma set lemma obtain frg result follows 
case case fr fr pre lemma set lemma yields case case fr fr 
lemma set lemma yields case 
case fr fr pre 
fr abs lemma set 
de ned 
assume case analogous 


lemma pre abs 
implies pre abs pre simply rows agree 
fr pre holds hm sub yields fr pre fact easy derive case 
case fr fr pre 
fr abs lemma set 
de ned 
assume case analogous 


lemma pre abs 
implies particular pre simply looked rows 
de nition satisfaction conditional constraints furthermore previous case fr pre facts easy derive 
types sec indirect type systems sect 
de ned type system rel set sect 
de ned translation sec set composing automatically gives rise type system sec called rel simplicity safety direct consequence theorems 
acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier definition 
closed sec expression 
de nition holds holds 
theorem 
holds go wrong 
turning type safety trivial corollary main motivation basing approach translation 
theorem concerns untyped terms proof straightforward 
typability lemma established sect 
involve types straightforward 
direct type safety proof duplicate steps involved proving hm correct 
theorem mentions type safety possible establish subject reduction result sec lemma subject reduction sec follows directly subject reduction set fact administrative expansion preserves types easy check 
reformulation direct type systems de nition simple direct de nition typing sec direct type system desirable reasons 
direct type system unnecessary translate expressions set direct type system succinct intuitive type judgement forms adopted 
understandable type error reporting feasible direct type system 
de ne rules allow typing sec expressions explicitly translating set called direct derived rules obtained systematic way de nition rel de nition translation making direct type safety proof straightforward appeal pre existing result set theorem 
rules symbols range types kind type speci cally represent security context set available resources 
symbols range types kind row pres respectively 
symbol rules indicates irrelevant principal 
source target translation functions additional parameter yielding types form recover familiar appealing notation proposed smith de ne macro def fig 
gives derived rules simplest type systems 
constraints equations 
result type information represented term form constraint form sulzmann provided types identi ed modulo standard equational theory rows 
exploit fact give simple presentation derived rules 
type schemes form judgements form 
rule enable failure naturally arises translation may desirable practice remove 
attempt enable privilege principal result immediate static type error 
gives rules system derived complex element array type systems 
judgements form 
signi cant di erences accuracy test rule re ecting precise binding 
addition subtyping constraints 
system fig 
uni cation ecient easy implement yields readable types 
conjecture acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
var abs app intro fv elim enable failure enable enable success fr pre fr enable check fr pre fr pre check test fr pre fr abs fr test sign fp fp fig 

typing rules sec derived power row polymorphism exible practical uses see sect 

focus system rest 
check system correct prove result section see lemma holds true holds 
theorem lemma show closed sec expression typed rules fig 
initial principal empty security context go wrong 
direct type correctness section prove correctness type system derived prove lemma 
proving soundness derived system respect lemma 
implies true jek 
proof 
structural induction derivation 
stand 
case var 
case variable distinguished variable coincide 
furthermore jxk result follows hm var 
case abs 
case derivable 
induction hypothesis true jfk derivable 
judgement written true jfk true jfk derivable applications hm abs 
de nition jek case goal 
acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier var sub abs app intro fv elim enable failure enable enable success fr pre fr enable check fr pre fr pre check test fr pre fr abs pre abs pre abs fr test sign fp fp fig 

typing rules sec derived case app 
case derivable 
induction hypothesis true je true je derivable 
furthermore true holds hm var 
true je je derivable applications hm app 
de nition jek case goal 
case 
case derivable 
induction hypothesis true je true je hold 
result follows hm de nition jek case 
case intro 
case true fv derivable 
induction hypothesis true jek derivable 
furthermore fv true 
hm intro true jek derivable 
implicitly equivalences true true true true true 
case elim 
case true derivable 
induction hypothesis true jek true derivable 
furthermore true true result follows hm elim 
case enable failure 
case enable frg acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
derivable 
de nition 
hm const hm elim true 
derivable 
furthermore true follows hm var 
hm app yields true 
induction hypothesis yields true je true je result follows hm de nition jek case 
case enable success 
case enable frg frg fr fr pre derivable 
de nition 
hm const hm elim true frg fr fr pre derivable 
furthermore true follows hm var 
hm app yields true frg fr pre induction hypothesis yields true fr pre je true fr pre je result follows hm de nition jek case 
case check 
case check fr pre derivable 
de nition 
hm const hm elim hm var hm app true derivable 
induction hypothesis true je derivable true je variable appear free result follows hm de nition jek case 
case test 
case test fr fr pre fr abs derivable 
induction hypothesis true fr pre je hm abs implies true je fr pre weakening true je fr pre similarly true je fr abs holds 
result follows de nition 
hm const hm elim hm var hm app de nition jek case 
case sign 
case fp derivable fp 
induction hypothesis true je holds true je de nition 
hm const hm elim hm var hm app true holds 
result follows hm de nition jek case 
task prove completeness derived type system respect normalization result analogous proved pottier 
lemma 
holds may derived instance sub judgement follows instance rule instance elim 
may proceed demonstrate completeness 
lemma abbreviate type schemes true judgements true omitting trivial requirement true true instances elim var 
lemma 
jek implies proof 
proof write true amounts identifying types modulo equational theory rows allows ignore instances hm sub derivation jek lemma may assume ends syntax directed rule instance acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier elim 
proof proceeds induction structure analysis derivation 
case jek assumption derivation involve hm var possibly followed hm elim 
result form var elim implies case holds 
case jek jfk lemma may assume ends instances hm abs follows 
jfk jfk jfk allows applying induction hypothesis yielding abs implies case jek je je lemma may assume ends instances hm app follows 
je je je je je je induction hypothesis judgement follows app 
case jek je je ends instance hm je je je je true implies constraint system equations admits general uni er 
case type scheme shown equivalent unconstrained type scheme may assume loss generality fact true 
may assume loss generality left hand premise instance hm intro je fv je induction hypothesis yields fv intro obtain induction hypothesis yields result follows 
case enable jek frg je lemma de nition 
derivation form frg acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
fr fr pre fv je je appears free type variables free free type variables free result type scheme equivalent monotype assume loss generality empty 
induction hypothesis yields result enable derivable enable failure enable success case check jek je lemma de nition 
derivation form fr pre fv je je occur weakening je result induction hypothesis yields check derivable check 
case test jek je je 
lemma de nition 
form fr fr 
fr pre 
fr abs fr fr pre 
fr abs fr pre je je fr pre fr abs je je fr abs je fr abs je je induction hypothesis fr pre fr abs hold 
judgement fr test follows test 
case jek je lemma de nition 
derivation form fp acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier fp fv je je appears free type variables free free type variables free result type scheme equivalent monotype assume loss generality empty 
induction hypothesis yields result derivable sign 
ready demonstrate correctness derived type system 
lemma 
holds true holds 
proof 
suppose hand holds 
lemma true jek de nition 
const true 
substitution lemma hm proved pottier leads true jek jek goal 
suppose hand true holds 
jek true 
simple inverse substitution lemma explicitly establish implies true jek result follows lemma 

examples section give examples illustrate expressivity limitations type system 
examples facilitate discussion di erences variants system yielding insights possible tradeo precision cost 
security wrappers library writer needs surround numerous internal functions boilerplate security code making accessible 
avoid redundancy desirable allow de nition generic security wrappers 
applied function wrapper returns new function computational meaning di erent security requirements 
assume principal fr sg 
wrappers principal enable enable require check system wrappers receive general type schemes 
type variables appear universally quanti ed give quanti er pre explicitly 
acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
enable fr pre 
fr require fr pre 
fr pre types similar may read follows 
wrappers expect function allows enabled pre requires enabled doesn care status 
ml type actual argument may general formal 
return new function identical domain codomain works regardless status enable yields requires enabled require yields pre 
new function retains expectations 
require privileges abs invoked enjoys privileges 
polymorphic types expressive 
main concern privilege mentioned code wrappers appear type 
generally privilege available may show type function written behalf principal may lead verbose types 
appropriate type abbreviation mechanism may able address problem left subject 
types security tests section discuss typical programming idioms involving test 
arguably common simple may typed complex requires take opportunity discuss various problems related interpretation conditional constraints 
imagine operating system kinds processes root processes user processes 
killing user process allowed killing root process requires privilege distinguished principal root privilege 
system functions perform killing implemented root follows kill proc root check kill process proc root kill process user level system functions receive general types kill proc fk pre unit proc fk unit rst function called statically proven privilege enabled 
second hand called time kill root process 
complement functions may desirable de ne function provides best attempt current dynamic security context 
may done dynamically checking privilege enabled calling appropriate function proc root test kill function typed system rst branch test construct statically known privilege enabled acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier sub expression kill typed 
inferred type shows security requirements proc fk unit sensitive action kill performed lexical scope test construct easily seen safe 
move outside scope follows proc root action test kill action dynamic security check yields closure behavior depends check outcome 
passed computations 
programming idiom useful practice allows hoisting security check loop 
instance kill set processes single apply action successively element set 
security check performed regardless number processes set 
typed 
subtle 
rel branches test construct receive type 
function kill requires non trivial security context conservatively assumed action may 
result say general type proc fk pre unit just kill 
typed type restrictive expected 
solve problem need keep track fact behavior type action depends outcome test privilege enabled 
precisely reason moving column array type systems 
column result test construct described conditional constraints encode desired dependency 
general inferred type proc fk abs abs pre abs abs proc fk proc fk unit pre proc fk proc fk pre unit conditional constraints generated test see fig 

course meaning constrained type scheme quite obscure possible simplify follows 
occurrence variable variable quanti ed locally 
rst conditional constraint written abs abs evident constraint tautology equivalent true suppressed 
second constraint suppressed acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
similar way 
third fourth constraints equations terms similar structure decomposed conjunction conditional constraints equations atomic terms 
performing decomposition suppressing tautological constraints obtain proc fk abs unit pre pre pre unit second constraint tautology di erent kind may suppressed 
simpli cation process yields proc fk abs unit pre unit important note simpli cation process automated 
chose show intermediate steps dicult relate nal type scheme code 
see type scheme require privilege enabled analysis smart prove code safe 
reader may wonder simplify type scheme unifying unit pre abs imply unit remain cases unconstrained result conditional constraints logically imply unit apparent problem possibility remove model 
case replacing constraints unit valid simpli cation 
change ectively add disjunction constraint language possible encode disjunction pre abs 
part model encoding impossible side condition fig 
conjecture constraint satisfaction problem exponential time complexity currently quasi linear time complexity 
interesting possibility consists giving di erent interpretation conditional constraints 
notice really wish conditional constraints limited way 
want allow branches test construct receive di erent types 
wish types di er arbitrary ways wish allow security annotations di er 
fact possible enforce restriction 
de ne binary relation uniformly true 
extend straightforwardly kind re de ne interpretation conditional constraints follows acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier interpretation requires types appear conditional constraint equal modulo security annotations 
allows structure types determined rigid rules desirable programming errors detected earlier keeping exibility conditional reasoning security annotations 
interpretation type may simpli ed proc fk unit desired 
practical point view change interpretation conditional constraints requires implementing uni cation algorithms top straightforward 
variant may er compromise precision eciency readability types inferred 
subtyping examples far useful types 
words examples require subtyping 
cases extra precision orded subtyping necessary 
imagine write slightly modi ed version wrapper enable sect 
follows arbitrary condition fx enable fx wrapper may may enable privilege calling general type fr pre 
fr pre exactly require sect 

words type system asserts conservatively necessary requires privilege drawn 
bound hm restricted hindley milner polymorphism uses receive type say second branch statement called enabled 
form fr pre rst branch statement called unmodi ed security context type checker concludes wrapped function fr pre security requirement 
aw really equality constraints 
may called enabled lead require fr pre believe called enabled 
extremely coarse approximation polymorphic type able deal separately call sites 
polymorphism inhibited making problem 
standard solution move system equality replaced subtyping obtain fr 
fr pre acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
type scheme permissive pre allow concluding pre case interpreted equality 
may take value abs wrapped function may called context disabled 
constraint pre requires able accept state privilege experience indicate subtyping useful polymorphism inhibited higher order functions 
java construct 
java rst class objects contain methods reasonable require methods explicit polymorphic types user part class declarations 
considering subtyping substantial cost terms readability eciency may interesting real world system 
needed con rm conjecture 

discussion extensions particular diculty extending ideas advanced language features exceptions state modules 
fact features expect type translation approach prove fruitful layering exceptions encoding top security passing encoding 
features java language environment addressed theoretical study 
particular java views privileges rst class objects making static typing problematic 
model privileges identi ers expressions compute privileges 
case java open question completely static mechanism devised 
may desirable take soft typing approach aiken wright cartwright 
discuss extending model include exceptions 
soft typing 
soft typing system cross type system static optimizer 
context soft typing system allow check operations mark requiring run time checking 
principle problem applying soft typing approach framework may allow ideas applied directly jdk security architecture de ned 
marked check operations treated test operations 
type system provide wealth information enable ecient implementation tests 
constraint conditional type systems particularly appropriate soft typing added expressiveness allow checks statically veri ed 
implementation test 
system statically checks check operations succeed run time need carry privilege information run time support test dynamically branch presence absence privilege 
believe static optimizer may able remove run time overhead test 
implementation issue scope current foundational study subject 
exceptions 
simple language far security violations fatal cause program halt 
java security violation acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier gives rise exception observed dealt direct indirect caller 
static security type system viewed realistic able deal exceptions 
sake simplicity haven included exceptions source language 
easy add second stage little modi cation current proofs 
lack space give outline procedure 
modify current development extending source language target language data constructors inl inr discriminating match construct 
extending translation function proofs straightforward 
de ne new source language featuring exceptions addition security constructs 
exhibit translation new source language old 
known fact exceptions de ned terms sums wadler moggi spivey de ning translation proving appropriate simulation theorem routine 
rel lifted new translation new source language 
type soundness new systems immediate 
construction shows typing encoding approach account exceptions 
shows layers encodings stacked top making proofs somewhat modular 
new type systems look 
naturally include classic ect system resembling usually employed analyze exceptions guzm su aiken ahndrich 
new translation maps normal resp 
exceptional results values pre xed inl resp 
inr 
result expression receives type form 
may choose write call resp 
type resp 
ect expression 
furthermore translation function maps normal values computations receives type form 
may choose write call ect function easily combined security type macro de ned sect 

sum new type systems function type carry security assumption contravariant parameter ect covariant parameter 
interesting notice expressive systems rel annotations linked conditional constraints allowing information privilege disabled function may raise exception encoded types inferred type reconstruction algorithm 
security check throws exception halting program failure de ned new source language combining test raise 
new source language fatal non fatal forms security checks 
interesting notice form advantages 
function yields fatal error privilege disabled type quite concisely encode sentence enabled type checker automatically enforce condition call site 
hand function throws exception type closely encode sentence disabled acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
function may raise exception type checker enforce pre condition calling function 
possible manually assert type annotation call yield exception forcing provably enabled call site 
may preferred legible documents programmer intent precisely 
hand exceptions leads modular programming style telling time particular piece code written security violations handled 
conclude forms security checks may practice 
related analyses stack inspection 
naumann banerjee developed alternate proof type safety programming language equipped stack inspection banerjee naumann 
denotational semantics language fact security passing style transform means correctness transform taken granted 
de ne static analysis stack inspection model checking temporal formul 
propose static analysis expressed point computation 
works assume programs represented call graphs security checks control ow explicit 
theoretical level fournet gordon fournet gordon er depth study semantics stack inspection establish equivalence laws allow compilers optimize away certain security related instructions 
approaches translation 
researchers proposed ways de ning ecient provably correct compilation schemes languages security policy expressed security automaton 
walker walker de nes source language equipped security policy shows compile dependently typed target language type system encoding assertions security states guarantees run time violations occur 
walker rst builds target type system de nes typed translation 
opposite approach consists rst de ning untyped translation letting source type system arise 
thiemann approach security automata thiemann conceptually closer starts untyped security passing translation output feeds standard program specializer order automatically obtain optimizing translation 
shares motivations works aim gain performance eliminating dynamic checks de ne programming discipline 
requires security types available level compiled code walker source code 
connection monads 
encoding exceptions alluded sect 
monadic translation moggi 
security passing style translation described sect 

fact alternate semantics source language de ned successively layering filinski top purely functional core acm transactions programming languages systems vol :10.1.1.46.2016
tbd 
tdb month year 

fran cois pottier 
failure monad de ned representing possibility abrupt program termination security monad de ned represents privilege sets enable check test de ned primitive operations level optionally exception monad de ned exc exc represents exceptions 
choosing semantics source language remove need prove translation sound reducing amount needed prove correctness type system 
choice concise operational semantics possibly brings closer original description java stack inspection 
monadic type systems tool isolate peyton jones wadler analyze wadler thiemann impure language features pure functional languages 
wadler thiemann need create new ect system new ect 
light may viewed systematic construction ect type system adapted particular programming language 
final remarks methodological study emerge type systems improve previous type systems access control 
system infers appear readable types remaining surprisingly expressive implemented eciently emy 
system exible form basis soft typing system current java jdk platform 
systems developed transformational system hm simpli ed proof ort inspired design 
aiken ahndrich 
program analysis mixed term set constraints 
proceedings th international static analysis symposium 
paris france 
url www cs berkeley edu aiken publications papers sas ps 
aiken wimmers lakshman 
soft typing conditional types 
conference record st acm symposium principles programming languages 

url cs berkeley edu aiken ftp popl ps 
banerjee naumann 
simple static analysis java security 
url cs stevens tech edu naumann tr short ps 
degano ferrari 
static analysis stack inspection 
international workshop concurrency coordination volume entcs 
elsevier 
jensen thorn 
model checking security properties control ow graphs 
journal computer security 
filinski 
representing layered monads 
proceedings th acm symposium principles programming languages 
san antonio texas 
url www 
brics dk andrzej papers rlm ps gz 
acm transactions programming languages systems vol 
tbd 
tdb month year 
systematic approach static access control 
fournet gordon 
stack inspection theory variants 
url research microsoft com fournet papers stack inspection theory variants long draft ps 
gong 
java security architecture jdk 
url java sun com products jdk docs guide security spec security spec doc html 
guzm su 
extended type system exceptions 
record acm sigplan workshop ml applications 
number inria research reports 
inria bp le chesnay cedex france 
url www ldc usb papers pdf 
moggi 
computational calculus monads 
proceedings fourth annual symposium logic computer science 
ieee computer society press asilomar paci grove california 
url www disi unige person ftp lics ps 
gz 
odersky sulzmann 
type inference constrained types 
theory practice object systems 
url www cs mu oz au sulzmann publications ps 
peyton jones wadler 
imperative functional programming 
th acm symposium principles programming languages 
charlotte north carolina 
url www research com user wadler papers imperative imperative ps gz 
pottier 
versatile constraint type inference system 
nordic journal computing nov 
url pauillac inria fr ps gz 
pottier 
information ow inference free 
proceedings th acm sigplan international conference functional programming icfp 
acm press montr eal canada 
url pauillac inria fr icfp ps gz 
pottier smith 
systematic approach static access control 
proceedings th european symposium programming esop sands ed 
lecture notes computer science vol 

springer verlag 
url pauillac 
inria fr smith esop ps gz 
emy 
extending ml type system sorted equational theory 
tech 
rep inria rocquencourt bp le chesnay cedex france 
url ftp ftp inria fr inria projects didier remy eq theory types ps gz 
emy 
projective ml 
acm conference lisp functional programming 
acm press new york 
url ftp ftp inria fr inria projects didier 
remy lfp ps gz 
emy 
type inference records natural extension ml 
theoretical aspects object oriented programming 
types semantics language design gunter mitchell eds 
mit press 
url ftp ftp inria fr inria projects didier 
remy ps gz 

types programming language security 
ph thesis johns hopkins university 
url www cs uvm edu pubs phd thesis ps 
pottier 
syntactic type soundness hm 
workshop types programming tip 
dagstuhl germany 
url www cs uvm edu pubs pottier tip ps 
smith 
static enforcement security types 
proceedings th acm sigplan international conference functional programming icfp 
montr eal canada 
url www cs jhu edu ces papers icfp ps 
gz 
spivey 
functional theory exceptions 
science computer programming 
sulzmann uller zenger 
hindley milner style type systems constraint form 
research report university south australia school com acm transactions programming languages systems vol 
tbd 
tdb month year 

fran cois pottier puter information science 
july 
url www ps uni sb de papers hm constraints ps gz 
thiemann 
enforcing security properties type specialization 
proceedings european symposium programming esop sands ed 
lecture notes computer science 
springer verlag 
url www informatik uni freiburg de thiemann papers het ps gz 
wadler thiemann 
marriage ects monads 
appear acm transactions computational logic 
url www research com user wadler papers ps gz 
wadler 
replace failure list successes 
functional programming languages computer architecture 
jouannaud ed 
lecture notes computer science vol 

springer verlag 
walker 
type system expressive security policies 
conference record popl th acm sigplan sigact symposium principles programming languages 
boston massachusetts 
url www cs cornell edu home walker papers sa popl ps gz 
wallach 
new approach mobile code security 
ph thesis princeton university 
url www cs princeton edu sip pub dissertation html 
wallach appel felten 
security mechanism language systems 
acm transactions software engineering methodology oct 
url www cs rice edu pub ps 
wright cartwright 
practical soft type system scheme 
acm transactions programming languages systems jan 
url www cs rice edu cs plt publications toplas wc ps gz 
wright felleisen 
syntactic approach type soundness 
information computation nov 
url www cs rice edu cs plt publications ic wf ps gz 
acm transactions programming languages systems vol 
tbd 
tdb month year 
