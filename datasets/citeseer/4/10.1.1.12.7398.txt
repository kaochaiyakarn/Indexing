typing multi language intermediate code andrew gordon don syme microsoft research microsoft net framework new computing architecture designed support variety distributed applications web services 
net software components typically distributed object oriented intermediate language microsoft il executed microsoft common language runtime 
allow convenient multilanguage working il supports wide variety high level language constructs including class objects inheritance garbage collection security mechanism type safe execution 
precisely describes type system substantial fragment il includes novel features certain objects may allocated heap stack stack may boxed heap heap may unboxed stack methods may receive arguments return results typed pointers stack heap including interiors objects heap 
formal semantics fragment 
typing rules determine typed il instruction sequences assembled executed 
particular interest rules ensure pointer stack outlives target 
main theorem asserts type safety typed programs il fragment lead execution errors 
main theorem directly apply product 
formal system abstraction informal executable speci cations wrote full product development 
informal speci cation basis product team working speci cation type checking 
process writing speci cation deploying executable speci cation test oracle applying theorem proving techniques helped identify security critical bugs development 
acm copyright notice 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed pro commercial advantage copies bear notice full citation rst page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior speci permission fee 
request permissions publications dept acm fax permissions acm org 
describes typing evaluation rules type safety theorem substantial fragment intermediate language il executed microsoft common language runtime 
rules valuable succinctly precisely account unusual subtle features type system 
background il common language runtime new execution environment rich object oriented class library software components written diverse languages may interoperate 
visual studio net development environment net components written new object oriented language hw visual basic visual scripting languages 
furthermore prototype net compilers exist cobol component pascal ei el haskell mercury oberon ocaml standard ml 
type checking net components implemented il proved useful nding code generation bugs 
net security model assumes type safe behaviour type checking useful handling untrusted components 
applications il type system worthy formal speci cation 
background executable speci cations outcome research project evaluate develop formal speci cation techniques describing analyzing general 
speci cally applied techniques study il 
began writing detailed speci cation type checking method bodies 
informal document style language 
eventually document adopted product team basis detailed speci cation type checking 
parallel methodology advocated syme sym wrote formal speci cations various il subsets suitable comparative testing formal proof 
executable part speci cations functional fragment ml rest higher order logic hol 
compile run executable part il type checker 
purely functional code may interpret hol theorem proving declare sym 
principle strategy allows source code serve oracle testing actual implementations model formal validation 
far built ml type checker largely complete subset il type system formally veri ed smaller fragment 
known coh formal proof guarantee absence implementation defects simply details environment writing formal models 
developing test suite formal model oracle important way making model consistent runtime 
suite included automatically generated tests 
experience testing remains viable way relating speci cation software complexity considering 
specify test 
writing formal speci cation generating tests may viable design frozen simply ective design new system 
eventually handed suite test team maintain bugs 
il fragment main part concerns il fragment value pointer types 
core fragment class object oriented language eld update simple imperative control structures 
core comparable imperative object calculus ac various fragments java de 
item type pointer heap allocated object 
fragment includes value pointer types item value type sequence machine words representing elds type 
value types support compilation style structs instance 
value types may stack allocated passed value 
box instruction turns value type heap allocated object copying unbox instruction performs inverse coercion 
convenient value types may treated ordinary heap allocated objects 
item pointer type machine address referring heap allocated object variable call stack interior eld 
main purpose pointer types allow methods receive arguments return results 
selected types new constructs previously described formal typing rules needs carefully limited avoid type loopholes 
particular take care stack pointers outlive targets 
sake clarity presentation semantics di ers ml code executable speci cations signi cant ways adopt standard strategy presenting type system logical inference rules 
rules succinct directly executable better write executable ml initially wrote speci cations order help testing 
typing rules better code presenting type system manual proof 
second adopt new non standard strategy assuming method body parsed tree structured applicative expression 
expression consists il instruction applied subexpressions need evaluated compute instruction arguments 
technique allows concentrate specifying typing conditions instruction suppress algorithmic details type checker compute types arguments instruction 
algorithmic details important implementation largely irrelevant specifying type safety 
spirit writing speci cations support testing applicative expressions standard il assembler syntax 
method body typed typing rules assembled tested running system 
summary principal technical contributions new typing evaluation rules value pointer types type safety result theorem 
idea essence low level intermediate language applicative notation 
challenges discussed project successful demonstration value writing executable formal speci cations product development 
hand main theorem apply full product type safety bugs may discovered 
lled ambition prove soundness typing rules full language mechanized theorem proving 
challenge develop scalable maintainable techniques mechanized reasoning 
soundness proof il impressive achievement 
apply theorem proving product development scalability maintainability proof scripts important 
scripts scalable sense human ort roughly linear size speci cation reasonable constant factor proof construction keep new features added 
scripts maintainable sense robust face minor changes speci cation proof construction keep inevitable revisions design 
challenge develop systematic techniques test case generation 
third challenge integrate executable speci cations ml type checker product 
net framework component models contributes goal support multilanguage working easily allow critical component written ml say rest product 
remainder proceeds follows 
section presents typing evaluation rules il fragment states main theorem 
section explains potentially useful type system 
section summarizes omissions il fragment 
section discusses related 
section concludes 
proofs omitted conference appear technical report gs 
formal analysis bil baby il section main technical contributions 
substantial fragment il includes detail allow formal analysis value pointer types omits features related 
name fragment baby il bil short 
section describes type structure bil 
section specify instructions may appear method bodies bil explain informal semantics 
section specify formal memory model bil formal semantics evaluation method bodies 
section specify formal type system type checking method bodies 
section introduces conformance relations express intermediate states arising evaluation type correct 
section concludes analysis stating type safety theorem 
type structure class hierarchy bil methods run execution environment contains xed set classes 
class speci es types set eld variables signatures set methods 
object belongs class 
memory occupied object consists values eld speci ed class 
methods shared objects class possibly classes 
objects classes may stored boxed heap addressed heap 
objects certain classes known value classes may additionally stored unboxed stack elds embedded objects 
formally assume sets class field meth sets class eld method names respectively set class value class names 
assume distinguished class name system object system object classes fields methods class class name vc class value class name system object class root hierarchy field eld name meth method name types describe objects elds objects arguments results methods intermediate results arising evaluation method bodies 
types type type void bits int bit signed integer class boxed object value class vc unboxed object pointer type void describes absence data bits void results methods parts method bodies return actual result 
type int describes bit integer bil uses integers represent predicates conditionals loops includes primitive arithmetic operations 
il features rich selection numeric types arithmetic operations 
type class describes pointer boxed object heap allocated subject garbage collection 
value type value class vc describes unboxed object sequence words representing elds value class vc akin struct 
associated type describes pointer boxed object heap allocated representation elds 
pointer type describes pointer data type may stored heap stack 
avoid dangling pointers pointers outlive targets type system restricts pointers follows 
important pointers il allow arguments results passed 
su cient conditions type check motivating usage preventing dangling pointers 
necessary conditions explain useful safe section 
bil pointer con nement policy eld may hold pointer 
method may return pointer 
pointer may stored indirectly pointer 
il follows slightly stricter policy pointers pointers altogether 
conditions prevents way creating dangling pointer 
eld hold pointer method store pointer stack frame object boxed heap 
method return pointer method simply return pointer stack frame 
pointer stored indirectly method store pointer stack frame pointer object boxed heap earlier stack frame 
case pointer outlive target soon method returned 
predicate identi es types containing pointers 
type contains pointer method signature refers method named expects vector arguments types 
result type methods class may share signature may share method name 
method signature sig sig method signature assume execution environment organises classes inheritance hierarchy 
write inherits mean inherits induce subtype relation inheritance hierarchy 
type system supports subsumption item type may context expecting item type non trivial subtyping types 
subtype relation satisfy rules 
subtype relation sub re sub class inherits class class assume relation inherits transitive relation il assembler recognises fairly standard notation single inheritance allows class inherit methods elds single superclass 
de ne inheritance relation formalizing syntax typechecking rules 
focus type checking bil instruction set easier concise simply axiomatize intended properties hierarchy 
il syntax disallows multiple inheritance happens axioms allow class inherit superclasses incomparable inheritance relation 
formally assume execution environment consisting components function elds function methods inheritance relation inherits satisfy axioms execution environment elds methods inherits elds class 
field type elds class methods class 
sig body methods class inherits class class class hierarchy inherits hi re inherits inherits inherits hi trans inherits inherits hi inherits system object hi root inherits dom elds dom elds elds elds hi elds inherits dom methods dom methods hi methods inherits vc vc hi val elds elds dom methods methods class elds field type set nite maps eld names types 
elds 
class exactly set elds named 
fn types 
respectively 
notation 
exempli es notation nite maps general 
dom 
ff fng 
assume distinct 

unde ned 
class methods sig body set nite maps method signatures method bodies 
de ne set body method bodies instruction sequences section 
methods sig 
class exactly methods signatures sig 
sig implemented bodies 
bn respectively 
binary relation classes inherits formalizes inheritance hierarchy 
axioms hi re hi trans guarantee re exive transitive 
hi asserts anti symmetric cycles hierarchy 
hi root class inherits system object root hierarchy 
suppose subclass inherits subsumption object subclass may context expecting object superclass accordingly hi elds asserts eld speci ed subclass axiom hi methods asserts method signature implemented implemented subclass necessarily method body 
order implement method invocation object need know class object 
general statically determine class object type subsumption may fact subclass class named type 
boxed object tagged formal memory model name class 
hand sake space eciency unboxed objects include type information 
rely statically determining class unboxed object type 
possible axiom hi val prevents class inheriting value class 
actual class unboxed object class named type 
axioms elds methods implement points pointer con nement policy 
section value pointer types provide possibly ecient alternatives types returning multiple results 
suppose class point elds point 
int 
int class integer elds 
alternative signatures returning point method named mouse boxed object class point mouse 
unboxed object value class point mouse 
pre allocated unboxed object passed void mouse value class point 
syntax method bodies bil deterministic single threaded imperative classbased object oriented language 
sake simplicity omit constructs error exception handling 
section speci es instruction set tree structured applicative expressions represent application instruction sequence argument expressions 
applicative expression post notation read sequence atomic instructions 
chosen syntax carefully subject minor editing sequence atomic instructions parsed il assembler il type checker 
express syntax conditional iteration constructs assembler labels ranged method refers method signature class inspired fj assume simplicity class exactly constructor arguments initial values assumed elds new object 
constructor class takes form void ctor 
constructors called create new object ctor meth method constructor assembler label method void ctor constructor applicative expressions method bodies bit signed integer body method body ldc load integer br conditional br loop sequencing load indirect store indirect load argument address store argument 
newobj create new object 
call boxed object 
call instance call unboxed object load eld address store eld box vc copy value heap unbox vc fetch pointer value conditionals loops primitive instructions il worthwhile primitive bil allow simple format evaluation typing rules 
carefully chosen syntax constructs assembling suitable il branch instructions labels 
assume assembler labels expressions appear subexpressions 
result syntax little cryptic produce il instruction sequences appropriate semantics 
abbreviations readable abbreviations conditionals loops cond br br technique representing assembly language applicative syntax works express operations value pointer types 
express structured control ow conditionals loops style treating assembly il branch instructions primitive bil instruction 
technique may scale express control ow arbitrary branching method exception handling 
il includes primitive instructions load contents object eld argument 
primitives bil derive follows derived instructions evaluating method bodies memory model consists heap objects stack method invocation frames vector arguments 
semantics abstracts away details evaluation stacks registers 
assume collection heap pointing boxed objects heap 
pointer takes forms 
pointer refers boxed object pointer refers argument stack frame pointer ptr refers eld object referred ptr result void integer pointer ptr unboxed object 
nite map consisting sequence results 
un corresponding elds 
fn respectively 
pointers results heap ptr pointer pointer boxed object pointer argument frame ptr pointer eld object ptr result void integer ptr pointer 
value unboxed object formalize memory model 
heap nite map boxed objects form 
class object 
unboxed form 
frame fr vector arguments args un self parameter 
un computed arguments 
stack list frames fr 
fr store heap paired stack 
memory model 
boxed object 
heap fr args un frame vector arguments fr 
fr stack grows left right store example heap 



consists single boxed object 


heap boxed object class consists elds named rst eld contains integer 
second eld contains unboxed object 
consists eld named containing integer 
example stack args args consists frames 
bottom stack frame args consisting arguments boxed object pointer eld eld object 
top stack frame args consisting arguments boxed object pointer refers argument frame pointer rely auxiliary partial functions dereferencing updating pointers store auxiliary functions lookup update lookup ptr lookup ptr store update ptr update store ptr result explain intended meaning store lookup update example 
store heap stack examples introduced 
lookup stored argument frame lookup integer stored eld unboxed object stored eld boxed object outcome update update replacing argument frame 
similarly outcome update update replacing integer eld eld boxed object integer 
little functional programming suces de ne functions give full de nitions appendix 
operational semantics method bodies formal judgment 
meaning initial store body evaluates result leaving nal store 
judgment simply predicate de ned set inference rules 
evaluation judgment 
body returns leaving semantics takes form interpreter 
rest section presents formal rules deriving evaluation judgments interspersed informal explanations 
evaluation rules control flow eval ldc ldc 
eval seq 


eval cond 

cond 
eval 

eval 



expression ldc evaluates integer expression evaluates returning void 
result expression result evaluating expression cond evaluates integer result conditional result evaluating evaluating 
expression evaluates integer evaluation terminates returning void 
body evaluated returning void evaluation repeats 
evaluation rules pointer types eval ptr 
lookup ptr 
eval ptr 


update ptr expression evaluates pointer returns outcome dereferencing pointer 
expression evaluates pointer stores result evaluating heap stack location addressed pointer returns void 
evaluation rules arguments eval fr 
fr 
eval 
fr 
fr 
update expression returns pointer argument current stack frame 
expression evaluates stores result argument current stack frame returns void 
evaluation rules types eval newobj void ctor elds 

dom 


newobj 
eval 


methods hn sn args vn 
fr 

expression 
newobj constructor class allocates boxed object elds contain results evaluating 
returns new 
expression 
refers class evaluates boxed object class expected inherit locates method body class returns result evaluating method body new stack frame argument vector consists boxed object self pointer results 
result evaluation store fr fr nal state new stack frame 
evaluation method complete stack popped leave nal store 
evaluation rules value types eval ptr 
ptr 
eval ptr 


update ptr expression evaluates pointer boxed unboxed object returns pointer eld object 
expression evaluates pointer boxed unboxed object updates eld result evaluating returns void 
evaluation rules value types eval newobj void vc ctor elds vc 


newobj 

eval call vc ptr 

methods vc hn sn args ptr vn 
fr 
call instance 
eval box dom ptr 
lookup ptr 
box vc 

vc 
eval unbox 
unbox vc 
expression 
newobj constructor value class vc returns unboxed object elds contain results evaluating 
expression 
call instance refers signature value class vc evaluates pointer unboxed object expected class vc locates method body class vc returns result evaluating method body new stack frame argument vector consists pointer unboxed object self pointer results 
expression box evaluates pointer unboxed object allocates boxed form heap returns fresh heap 
expression unbox evaluates heap boxed object returns result 
typing method bodies section describes type system method bodies evaluation typed method bodies lead execution error 
interesting implementation pointer con nement policy section 
type frame fr take form args description types results current top stack frame 
typing judgment fr means current stack frame matches fr body evaluates result type type frames typing judgment fr args frame types arguments fr fr body returns type additional assumption execution environment method body conforms signature additional assumptions methods args class ref methods vc methods vc args value class vc val methods give typing rules de ne fr typing rule subsumption body fr fr standard rule allows expression subtype context expecting supertype typing rules control flow body ldc fr ldc int body seq fr void fr fr body cond fr int fr fr fr cond body fr int fr void fr void rule body seq uses type void guarantee rst part sequential composition returns results 
rules body cond body type int guarantee predicate expression returns integer 
typing rules pointer types body fr fr body fr fr fr void rule body implements rule pointer con nement policy condition copy pointer current stack frame back stack 
typing rules arguments body args body args args void rules check argument index exists 
writes current frame safely allow pointer 
typing rules types ref newobj void ctor elds 
fr fr 
newobj class ref dom methods fr class fr fr 
ref elds 
fr class fr ref elds 
fr class fr fr void fairly standard rules operations boxed objects 
recall axiom elds guarantees eld pointer free 
condition rule ref redundant 
redundant variation type system considered section allows value classes include pointers 
typing rules value types val newobj void vc ctor elds vc 
fr fr 
newobj value class vc val call dom methods vc fr value class vc fr fr 
call instance vc val elds vc 
fr value class vc fr vc val elds vc 
fr value class vc fr fr vc void val box value class vc fr value class vc fr box vc class vc val unbox fr class vc fr unbox vc value class vc similar typing rules operations boxed objects refer object pointer type type 
ref rules val val box bear conditions redundant current system system section 
typing memory model section predicates known conformance judgments confer types memory model 
show predicates invariants computation preserved method evaluation 
introducing types components memory model 
heap type 
determines actual class boxed object 
stack type fr 
determines frame types frame stack 
store type determines heap type stack type heap stack store types 
heap type fr 
stack type store type rst conformance judgment means store matching store type result wellformed type de ne means store match store type conformance judgments de ned 
conformance judgment results including pointers result type conformance rules pointers res ref inherits class ptr ref vc value class vc ptr arg fr args fr 
fr ptr field class value class ptr elds 
ptr rule res ref assigns type class heap long superclass actual class object referred rule ptr ref assigns pointer type heap refers value boxed heap 
rules assign type pointer type heap value class 
vc class res ref value class ptr ref 
need res ref type constructed box instruction 
need ptr ref type pointers constructed unbox instruction 
rule ptr arg assigns pointer type stack pointer refers argument frame rule ptr field assigns pointer type pointer referring eld object referred ptr base pointer ptr may type class value class 
rst case needed pointer eld heap object value class 
second case needed pointer eld heap stack object value class 
conformance rules results res void void res int int res value elds vc 

value class vc rules res void res int assign void int types void integer values respectively 
rule res value assigns value type value 
axiom hi val inheritance hierarchy value types 
res value res ref allow vc proper superclass actual class value 
conformance judgments object class heap conforms fr fr frame fr conforms fr store conforms conformance rule objects con object elds 

rule de nes heap object 
typed 
preconditions require elds typed empty stack type 
follows eld contains stack pointer rule ptr arg typing stack pointers assumes non empty stack type 
conformance rule heaps con heap 

rule de nes heap 
conforms heap type 
heap type contains actual class object conformance rule frames con frame args un args rule de nes frame conforms frame type 
conformance rule stores con store fr 
fr fr fr fr 
fr 
fr rule de nes store fr 
fr conforms store type fr 
fr 
asks heap conform heap type stack frame fr conform corresponding frame type fr removing store type higher shorter lived stack frames 
may pointers higher lower stack frame way round 
evaluation respects typing standard proof techniques show consistency bil evaluation semantics type system 
main type safety result 
program satis es restrictions type structure imposed section typing rules method bodies section evaluation rules section lead conformant intermediate states de ned section 
mean dom dom dom 
theorem fr fr 
exists heap type fr fr proof induction derivation 
omit details 
see appendix main lemmas type system needed proof 
usual theorem vacuous 
holds happens computation diverge gets stuck applicable evaluation rule 
stuck states correspond execution errors calling non existent method attempting de integer dangling pointer 
discussed abadi cardelli ac conjecture straightforward adapt proof theorem show stuck state reachable 
variation allowing pointers fields value classes avoid dangling pointers il type system prevents elds objects boxed heap unboxed stack holding pointers 
fact pointed fergus henderson liberal type system allows unboxed objects contain pointers useful compiling nested functions 
compiling language nested functions example pascal ada invocation nested function needs access activation records arguments local variables lexically enclosing functions 
standard technique pass function display asu array pointers activation records 
strategy implement activation record containing arguments local variables referred nested functions value class stack implement display pointers value classes representing activation records 
arguments may passed scheme works allow value classes hold pointers 
need pay cost boxing activation records heap 
allow elds value classes hold pointers liberal policy avoids dangling pointers 
liberal pointer con nement policy eld boxed object may hold pointer 
method may return result containing pointer 
result containing pointer may stored indirectly pointer 
policy helps compile nested functions lose possibly useful fact value class may boxed treated subtype class system object 
formalize policy amend bil follows 
change de nition hold pointer type value class type eld satis es 
change insertion clause 
change axiom elds read elds 
change insertion precondition 
see ect changes recall typing rules mention predicate ref body val val box 
previously value stored body pointer free conditions rules redundant 
rules prevent export values containing pointers heap back stack 
ref prevents pointer stored boxed value class pointer eld 
fact boxed value classes allocated condition val box 
proof theorem outlined appendix fact liberal system 
type safety original system corollary type safety liberal system method body typed original system remains typable 
implementation new scheme remains 
il features omitted bil give full intermediate language brie enumerate main features omitted bil 
il assembly programmer manual mic contains complete informal description il 
omit discussion il metadata classes static data method headers described 
omit discussion disk format speci cation linkage information assemblies unit software deployment 
object model omits null objects global elds methods static elds methods non virtual methods single dimensional multidimensional covariant arrays object interfaces 
instruction set omits local variables arithmetic instructions arbitrary branching jumping tail calls 
tail calls require care type system prevent pointers current stack frame passed arguments 
current il policy prevent passing pointers tail call 
omit delegates built support anonymous method invocation typed pointer packaged type required visual basic attributes native code calling conventions interoperability com remoting object distribution multithreading 
omit exception handling fairly elaborate model permits uni ed view exceptions high level languages 
related principle formalizing type checking logical inference rules long standing topic study progamming languages car 
formal typing rules developed high level languages including sml haskell pw subsets java de 
formal typing rules developed low level languages including tal mwcg subsets jvm sa qia fm 
properties established proof carrying code nec viewed typing derivations native code 
idea formalizing type system executable type checker advocated haskell jon 
executable speci cation oracle instance standard software engineering principle multi version prototyping 
proofs soundness programming language type systems partially mechanised theorem provers van sym vn 
compilers ghc til tmc flint sha marmot fkr typed intermediate language internally 
mwcg particular translates way system polymorphic calculus typed assembly language tal 
idea writing type checker textual assembly format type checker il appears connection tal talx type checker accepts input typed form ia assembly language processed standard assembler 
types heap allocated data structures akin types type system section appear intermediate languages 
new type system inclusion value pointer types 
value types describe unboxed stack allocated form class 
box unbox instructions coerce stack heap forms class 
types boxed unboxed non strict data structures pl automatic type coercions boxed unboxed forms ler studied previously 
approaches include region analysis tt escape analysis pg 
idea formalization types di erentiate unboxed boxed forms class objects appears new 
pointer types describe pointers stack heap allocated items 
risk stack pointer may lifetime exceeds lifetime target 
stack form tal includes type constructor describing pointers stack parameter type constructor stack type ensures target live pointer dereferenced 
pointer con nement policy section avoids dangling pointers various syntactic restrictions 
il pointer types easier integrate high level languages visual basic simple type systems sophisticated solution stack types tal 
innovations microsoft common language runtime support typed stack pointers passing arguments results example 
formal typing rules type safety result substantial fragment common language runtime intermediate language 
treatment value types pointer types appears new 
rules devised writing informal executable speci cations full intermediate language 
ort clari ed design helped nd bugs research needed machine support formal reasoning test case generation 
exploited formal model validate il policy allows object elds contain stack pointers 
outcome collaborative project microsoft research cambridge net common language runtime product team 
common language runtime team especially forbes miller morrison help collaboration 
research hankin matthews pitcher project 
abadi hoare je rey suggested improvements draft 
ac abadi cardelli 
theory objects 
springer verlag 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley 
car cardelli 
type systems 
tucker editor computer science engineering handbook chapter pages 
crc press 
coh cohn 
notion proof hardware veri cation 
journal automated reasoning june 
de drossopoulou eisenbach 
java type safe probably 
proceedings ecoop june 
fkr fitzgerald knoblock ruf steensgaard tarditi 
marmot optimizing compiler java 
software practice experience 
fm freund mitchell 
type system object initialization java bytecode language 
acm transactions programming languages systems 
appear 
gordon hankin lassen 
compilation equivalence imperative objects 
journal functional programming 
gs gordon syme 
typing multilanguage intermediate code 
technical report msr tr microsoft research 
hw 
language 
available msdn microsoft com technology asp 
igarashi pierce wadler 
featherweight java minimal core calculus java gj 
object oriented programming systems languages applications oopsla october 
jon jones 
typing haskell haskell 
proceedings haskell workshop paris 
available www cse ogi edu mpj 
ler leroy 
unboxed objects polymorphic typing 
th acm sigplan sigact symposium principles programming languages pages 
acm press 
morrisett crary glew walker 
stack typed assembly language 
workshop types compilation volume lecture notes computer science pages 
springer verlag 
mic microsoft 
microsoft il assembly programmer manual july 
part net framework software development kit distributed cd microsoft professional developers conference orlando florida july 
milner tofte harper macqueen 
de nition standard ml revised mit press 
mwcg morrisett walker crary glew 
system typed assembly language 
acm transactions programming languages systems 
nec necula 
proof carrying code 
th acm sigplan sigact symposium principles programming languages pages 
acm press 

formalised hol 
phd thesis university cambridge 
pg park goldberg 
escape analysis lists 
acm sigplan conference programming language design implementation pages 
acm press 
peyton jones hall hammond partain wadler 
glasgow haskell compiler technical overview 
proceedings uk joint framework information technology technical conference pages 

pl peyton jones launchbury 
unboxed values rst class citizens 
functional programming languages computer architecture volume lecture notes computer science pages 
springer verlag 
pw peyton jones wadler 
static semantics haskell 
unpublished draft department computing science university glasgow 
available research microsoft com users simonpj 
qia qian 
formal speci cation java tm virtual machine instructions objects methods subroutines 
alves foss editor formal syntax semantics java volume lecture notes computer science pages 
springer verlag 
sa stata abadi 
type system java bytecode subroutines 
proceedings popl pages 
acm press 
sha shao 
overview flint ml compiler 
proc 
acm sigplan workshop types compilation tic amsterdam netherlands june 
sym syme 
declarative theorem proving operational semantics 
phd thesis university cambridge 
sym syme 
proving java type soundness 
alves foss editor formal syntax semantics java volume lecture notes computer science pages 
springer verlag 
tmc tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
proc 
pldi pages 
tt tofte 
talpin 
region memory management 
information computation 
van 
machine assisted proof programming language properties 
phd thesis department computer information science university pennsylvania may 
vn von oheimb nipkow 
java speci cation proving 
alves foss editor formal syntax semantics java volume lecture notes computer science pages 
springer verlag 

compositional account java tm virtual machine 
th acm sigplan sigact symposium principles programming languages pages 
acm press 
facts needed proof theorem appendix encompasses main lemmas needed proof main type safety theorem 
proofs de nitions elds described section 
proofs trivially adapted original de nitions section 
appendix covers basic lemmas subtype conformance relations 
appendix presents alternative characterisation pointer conformance judgement ptr 
appendix presents de nitions typing properties store lookup update functions 
basic lemmas lemmas subtype relation 
subtyping trivial types types 
types supertypes types 
lemma assume class lemma class exists class inherits subsumption rule part de nition result conformance relation derivable 
lemma lemmas concern varying size stack ects conformance 
lemma states pointer free result formed store type formed store type 
justi es moving pointer free results current frame heap 
lemma states result formed store type formed store type fr 
justi es passing results current frame frame called method 
lemma states pointer free result formed store type fr formed store type 
justi es returning pointer free results called frame previous frame 
lemmas apply pointer results result pointer top stack frame formed smaller stack 
lemma lemma fr lemma fr lemmas concerned method call return 
lemma says frame formed store sfr formed store 
justi es passing argument frame called method 
lemma says store conforms store type store fr conforms store type fr 
justi es returning method 
proof lemma depends showing pointer nal store refers frame fr lemma fr fr fr fr lemma fr fr 
recall state theorem terms relation de ned mean dom dom dom 
may call heap extension relation 
heap extension partial order 
lemma relation re exive transitive 
lemmas state heap extension preserves conformance relations results objects frames 
lemma lemma lemma fr fr fr fr nal lemma section justi es boxing results 
heap object conform heap type fresh extended heap obtained allocating formed 
lemma dom 

formulation pointer conformance section recursive de nitions lookup update functions pointers 
show properties functions convenient section reformulation pointer conformance relation ptr 
essentially show formed pointer takes form pointer argument frame followed possibly empty path eld selections boxed object value class followed possibly empty path eld selections boxed object necessarily value class followed non empty path eld selections 
reformulation begins notion path possibly empty sequence eld names 
path object 
fn sequence elds written de ne relation mean sequence empty value class selecting elds series order yields type de ned terms auxiliary single step relation 
actions fields types value class vc elds vc 

fn 
notations reformulate pointer conformance follows 
lemma judgment ptr holds exist ptr exist vc ptr value class vc value class vc exist ptr class elds 
lemma prove typing properties store lookup update functions stated section 
facts lookup update omitted de nitions functions store lookup lookup ptr store update update ptr main body 
store lookup function de ned terms auxiliary function result lookup lookup 
fn result returns outcome applying eld selections 
fn turn 
de nition auxiliary function followed typing lemma 
result lookup lookup 
fn lookup lookup 
lookup lemma lookup de nition store lookup followed typing lemma 
store lookup pointer lookup ptr lookup lookup 

lookup lookup fr 
fr 
fr fr args vn lemma ptr lookup ptr store update function de ned terms auxiliary function result update update 
fn result returns outcome updating eld indicated eld selections 
fn result de nition typing lemma 
result update update 
fn update update 

update 
fjg lemma update previous auxiliary function de nition store update 
store update pointer update ptr update 
update 

update fr 
args update vn 
fr fr 
fr 
fr fr args vn state typing lemmas store update 
essential facts proof type safety bil proof theorem uses lemma lemma show evaluations respectively type safe 
lemma ptr update ptr 
lemma fr 
fr update 

