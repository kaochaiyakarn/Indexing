sintl strongly typed generic intermediate language scheme mark may describes sintl strongly typed generic intermediate language scheme 
begins outlining motivation developing sophisticated intermediate language new scheme compiler 
consider novel aspects sintl intermediate language scheme declarative type system type inference algorithm register stack machine conversion algorithm 
demonstrate ectiveness techniques discussing jvm sintl backend fully functional backend java virtual machine 
discussion representational choices compilation techniques jvm sintl compare performance jvm sintl backend relative popular scheme compilers 
ultimately thesis demonstrates sophisticated compiler selected analyses optimizations generate high quality code running jvm performance order magnitude better current scheme compilers jvm 
contents motivation features target machine 
support diverse targets machines 
completely generic runtime system 
design sintl instruction set 
declarative type system 
assembler phases 
type inference sintl instruction types 
block level type inference 
instruction level type inference 
reg stack instruction selection algorithm dag value dependency analysis 
local variable assignment 
stack machine instruction selection 
jvm backend jvm 
extended compilation example front compilation 
initial sintl phases 
type inference 
reg stack instruction selection 
jvm source code 
performance results jvm sintl motivation sintl scheme intermediate language strongly typed linear instruction stream register transfer language assembler backend pm compiler designed minimum instruction set instructions de ned simple semantics 
instruction set machine language remaining intermediate scheme machine assembly code 
similar avor scheme virtual machine instruction set machine code 
principal goals pm compiler expanded scope project grew 
prototype compilers implemented diculties identi ed settled major goals features target machine principle goal pm compiler features target machine directly implement features scheme 
systems backend target machine speci cally designed source language jvm instance compiler writers choose drastically simulate runtime system target machine 
instance implementing call current continuation scheme notoriously dicult call cc lifetime stack frame frame returns caller 
languages call cc choose standard implementation options 
option taken scheme mzscheme standard ml new jersey heap allocate stack frame garbage collect stack 
attractive option able design implement compiler virtual machine gives reasonable performance implementation call cc extremely easy ecient 
option discussed dybvig traditional stack call frames implement call cc copying current stack heap 
approach gives excellent performance scheme programs heavily penalizes call cc 
unfortunately approaches viable systems top jvm 
jvm similar systems designed languages call cc strict call stack discipline provide functionality copying call stack heap 
approach problem similar taken kawa supporting upward single return continuations 
continuations semantically throw catch exceptions java supported systems jvm 
choosing support upward continuations optionally full tail calls implement scheme features immediately machinery provided pm compiler scheme front compiler development northwestern autonomous mobile robotics group 
pm temporary name compiler formed names principal designers surana mark 
jvm 
means target machine argument passing return value local variable mechanisms 
cases underlying machine simply support semantics scheme lexical scoping cases chose implement feature intrusive way possible 
odd goal substantial bene ts 
systems jvm just time compiled portable virtual machine instruction set native instructions 
compilers reasonably ective nature fast sophisticated program analysis 
compiling scheme code conventions target machine jit ectively translate code native machine code 
second eases inter operability source language languages target machine 
compiler generates code follows conventions target machine easier systems language access features target machine programs languages call scheme programs 
support diverse targets machines experience initial prototype compilers features intended target phases compiler 
assumptions target machine embedded compiler changing part system invariably lead violated assumptions 
unsure eciently implement scheme jvm ability experiment representations analyses optimizations critical 
completely generic runtime system writing large runtime system target machines extremely tedious errorprone 
simply hands available write ecient runtime systems minimalist language scheme 
chose write single completely generic runtime system scheme minimal set primitive operations 
pushed implementing rts eciently target system compiler concentrated orts improving quality compiler 
additionally rts proved single backend substantially easier port compiler platforms 
especially important retargeting compiler targets development helps isolates failures relatively small instruction selector backend speci runtime system 
design sintl clear building compiler genericity portability required strong division labor front scheme compiler backend code generator 
sintl designed encapsulate information needed compile sequence instructions target language 
sintl instructions comprise register transfer language instructions 
instruction stream strongly typed simple scheme speci type system described section 
deciding write entire runtime system scheme posed host dicult design questions sintl system 
time average scheme program spent runtime system essential ectively compile runtime system 
writing rts clean scheme code moved optimizing rts rts programmer compiler writer 
anticipated improving compiler pro table long run general compiler optimizations applicable scheme code bene cial writers rts users scheme programmers 
writing generic rts compiled target language ease burden person porting compiler new backend 
writing large dicult debug backend rts retargeting sintl new backend involves describing way access low level primitives writing simple instruction selector sintl code target language 
instruction set instruction set provided sintl shown table 
argument speci cation contains descriptors reg register containing value 
name symbolic name 
label conditional instruction name correspond label template 
primitive instruction name name primitive known sintl particular backend 
lit literal object type permissible rs scheme 
type sintl type currently selected backend 
global symbolic name global variable 
instructions form result register arguments 
instructions elaboration 
literal reg lit load literal global ref reg global load global variable global set 
global val set global variable global de ne 
global val de ne global variable closure reg env template create closure env template closure reg load current closure closure env reg closure load closure environment env reg parent length env parent env length env parent reg env load env parent env ref reg env index load env index env set 
env index val env index val set 
dst src copy src dst call reg proc arg 
call proc arguments tail call reg proc arg 
tail call proc arguments return reg return result label label label instruction stream branch label branch label branch false 
test label conditional branch test label false 
reg val value scheme false 
type cast reg val type cast value type ensure type reg type ensure value type primitive reg name arg 
invoke primitive routine table sintl instruction set type cast reg reg type type cast instruction accepts register reg type produces value reg converting value reg new value type placing reg 
value reg say type type relation type 
instance reg contains unboxed integer type cast reg reg convert box unboxed integer place boxed equivalent reg 
hand instruction type cast reg reg cast unboxed integer reg unboxed real equivalent 
ensure type reg type ensure type instruction performs type check operation reg ensuring control passed instruction reg contains value type assignment 
type type subtype boxed type values runtime type information 
primitive reg res name reg 
primitive instruction access low level resources provided current sintl backend 
primitive instruction acts function call known procedure explicitly typed arguments return type 
rs runtime system implemented small set primitives easily mapped target machine 
primitives provided backend sintl conform rigorous syntax easily entered simple macro 
primitives sintl de ned define primitive syntax 
primitive name sintl type signature calling convention implementation optional type implication 
type signature primitive de ned type signature spec spec function type spec type sintl type 
number previous ignore type type 
states primitive accepts arbitrary number arguments type type 
instance primitive integer addition java de ned int inline iadd means int primitive type unboxed integer unboxed integer unboxed integer implemented inline jvm instruction iadd 
primitives provided backend model primitives sophisticated semantics requires expressive de nitional language 
sintl accepts schema primitives similar axiom schemas rst order logic 
primitive schema ectively describes nite number primitives regular form 
schema language expresses primitive terms uni cation variables allowing scheme generalized arguments 
instance type testing predicates sintl expressed simple schema schema result type 
type arg reg type 
type reg type inline lambda result type arg stack instructions arg instanceof type implies arg type declaration means primitives instructions form primitive result type 
arg primitives ignored argument implemented inserting inline jvm instructions produced call lambda form 
lambda uses jvm instanceof instruction test value produced arg instanceof class type 
implies arg type expression informs type inference engine register arg type type true branch branch false 
instruction result register type 
primitive 
simple primitive form primitive schema sucient describe low level operations needed implement rs runtime system 
primitive system nicely describes procedures provided target language easily adapted foreign function interface 
expanding type system include standard types jvm including simple scheme interface declare types implementation java libraries easily inter operate native procedures libraries available jvm 
fundamental assemble object sintl template 
template named sequence sintl instructions potentially empty list typed arguments 
example sequence instructions recursive version fibonacci de ne fib fib fib rst result compiling vanilla scheme second standard binding define template fib global ref lt call lt branch false 
recur return label recur global ref minus call minus global ref fib call call minus call global ref plus call plus return define template fib primitive int branch false 
recur return label recur primitive int global ref fib call primitive int call primitive int return declarative type system sintl language strongly typed meaning register assigned type sintl type system 
scheme dynamically typed language sintl type system exible express need runtime type checking 
target machines typically distinguish boxed values contain information recover type value runtime unboxed values raw representation value runtime type information sintl includes boxed unboxed types 
particular details type system system dependent sintl uses completely declarative type system describe domain values particular backend 
sintl backend required support core set types needed compile scheme code may extend specialize way sintl assembler handles instructions types values 
sintl type system set disjoint discrete types represented symbols simple relations elements set 
sintl currently understands kinds relationships types subtyping subtype values type permissible values type required 
conversely value type required register reg known type register reg may fact contain value type ensure register reg contains value ensure type reg instruction inserted reg 
typical subtype relation occurs supertype boxed types sintl 
boxing boxed relation unboxed version possible convert values type values type typical backend target machine directly operate unboxed values critical represent reason transformations boxed unboxed values 
convert instruction 
reg contains value type instruction type cast reg reg places unboxed version reg 
typical boxed relation occurs boolean values transformed values di erent type method qualitatively di erent boxing 
types values relation related possible convert value type necessarily equivalent value type relations lossy sintl resorts relations converting relationship convert sintl requires declared relations types satisfy requirements 
types mutual subtypes 
second type subtype multiple types sintl supports single inheritance types 
versions sintl permit multiple supertypes type essential feature current project 
current sintl type system java backend uses set types described table 
type type closure environment type instruction sequence type closure type boxed boolean value scheme type unboxed boolean target language type scheme symbols type inexact numbers unboxed type inexact numbers boxed type exact integer numbers unboxed type exact integer numbers superclass boxed numbers type cons cell type boxed character type unboxed character type scheme strings type scheme vectors supertype boxed types table sintl types sintl type system suciently simple determine properties types easily eciently 
view types system directed graph types vertices relations types labeled edges 
determine properties type system standard graph algorithms corresponding type graph 
determining value type converted value type performed running dijkstra type graph selecting best path exists 
best path nodes shortest path containing minimum casts box unbox edges 
assembler phases current version sintl active development accepts list templates assembles jvm instructions procedures 
phases sintl assembler mutual independent actual phases ordering controlled current sintl backend 
common phases required backends order phase parsing templates scheme data structure 
templates represented directed graph basic blocks holding sintl instruction register data structures 
phase unreachable blocks eliminated 
instruction sequences cleaned adding labels start block unconditional branches blocks simple transformations 
trivial blocks copied back incident blocks 
instance blocks containing unconditional branches blocks propagated incident blocks eliminated 
blocks containing return instructions copied back incident blocks improves type inference code generation backends permitting multiple return sites 
phase alias analysis elimination 
unnecessary set 
instructions eliminated instruction stream 
removal unnecessary register aliases cleans instruction stream improving optimizations analyses 
phase intra block optimizations 
xed point interaction constant propagation dead code elimination 
phase type inference ensure instruction stream type safety 
see section 
phase boxed literal collection 
literals boxed unboxed representation sintl assumed unboxed type inference 
literals immediately boxed type inference algorithm satisfy type constraints imposed instructions 
phase determines literals immediate type cast 
boxed equivalents 
literals replaced boxed literal equivalents type cast instruction replaced boxed literal instruction 
phase round intra block optimization eliminating temporaries literals introduced type inference longer needed 
phase dag value dependency analysis 
see section phase backend code generation 
control passes backend speci generation algorithm converts optimized sintl instruction stream backend target language 
block tracing instruction selection occur stage 
type inference sintl type inference sintl ensure type safety template instruction stream 
essence sintl accepts type unsafe templates type inference inserts ensure type type cast instructions template type safe 
principal goals sintl type inference insert minimum number type checks template guarantee instruction type signature satis ed transform values boxed types needed calls tail calls primitive calls 
insight sintl type inference algorithm easier insert type checks ensure safety unsafe template remove unnecessary type checks safe template 
scheme systems type inference improve performance generated code type inference prove type checks scheme procedures unnecessary 
sintl type inference algorithm compatible scheme level inference system fact improve performance sintl provides access partially unchecked primitives 
versions sintl expanded accept type annotation registers call instructions produced soft typing polyvariant analysis include set analysis current singleton analysis 
current type inference algorithm provides respectable performance ease especially coupled aggressive inlining front 
instruction types literal literal signature global ref name global set name global define name closure name closure closure env env index env parent env ref index env set index set set signature call 
tail call 
return label name branch name branch false name false type cast type cast signature ensure type ensure type signature primitive primitive signature special cases de ned ensure type type ensure type instruction type signature 
handled specially instruction inference system 
ensure type instruction encountered type register current tenv checked type 
type processing continues type bound type 
type error occurred user signaled 
type cast type typeof tenv type type cast type signature type current tenv type cast type 
literal lit 
typeof lit literal instruction type signature ignored argument type literal 
set 

typeof tenv type set 
ignored type argument type current type environment 
primitive res prim args 
typeof prim args 
type primitive operation type primitive respect arguments 
primitives simple type signature int sintl supports schema primitives type signature potentially function arguments 
block level type inference type inference algorithm divided separate modules basic blocks inference instruction inference 
basic block inference algorithm uses instruction level type inference algorithm 
algorithm uses queue blocks need inference maintains input output type environment block template 
algorithm begins initializing entry block template type environment formal arguments template bound declared types 
algorithm loops queue empty 
head block queue tenv tenv 
input tenv tenv appropriate output predecessors uni ed 
output tenv block depends relationship unconditional branch output tenv simply conditional branch type implications output tenv processed copy output tenv 
type implications notes attached bindings tenv state behavior bindings control moves conditional branch 
uni cation attempts unify bindings tenv bindings returning uni ed type environment exists 
blocks uni ed type error algorithm halts 
uni cation succeeds uni ed tenv assigned tenv trivially equivalent uni cation produce new tenv chooses tenv block visited algorithm processed tenv tenv visited input tenv trivially equivalent uni ed type environments predecessor output tenv change inferred tenv words block achieved quiescence xed point abort processing move block queue 
assuming block needs processed valid tenv placed tenv set input tenv tenv process instructions copy tenv instruction level infer done left new type environment re ecting type behavior instructions record new tenv output tenv enqueue successor blocks queue 
repeat loop 
instruction level type inference algorithm currently sintl xed point block algorithm 
unique entry block template initialized type environment tenv mapping register type populated types template formal arguments 
block instructions processed order type registers recorded tenv instruction 
instruction type signature instruction current tenv calculated instruction argument checked desired type type signature 
required type uni es current type tenv argument type safe instruction 
argument unify potential problems required type unboxed type current type boxed type 
type path current type required unboxed type instruction sequence inserted current instruction converting argument unboxed equivalent 
unboxed equivalent placed register argument instruction replaced register type inference restarts inserted instructions 
example occurs type type arg produces sequence ensure type type cast 

required type boxed type current type unboxed type 
previous case current type converted boxed equivalent possible 
occurs type type arg producing sequence type cast 
required type unboxed type current type di erent unboxed type 
exists sequence casts required current types sequence casts inserted stream 
required type boxed type current type di erent boxed type 
required type subtype current type ensure type inserted 
type error occurred value possible type required type 
rst case occurs type type arg sequence ensure type 
second case occurs type type arg type error value contain value type depending current mode sintl may attempt assignments register non uni able types 
stage optional assignments viewed type errors strict point view strongly typed languages implicit casts general uni able type 
sintl attempting types assigned registers extra step occurs instruction argument type inference ensured type safety instruction application 
return type instruction checked previous type assigned result register 
cases return type instruction unify previous type type inference simply proceeds instruction 
case return instruction unify sintl assumes type result register boxed uni es instruction return type type 
cases consider depending return type return type subtype current instruction type safe previous assignments register xed 
case occurs previous assignment unboxed type return type boxed type 
appropriate action take boxed previously unboxed assignment 
example consider instruction stream literal 
call proc arg rst instruction loads unboxed integer second instruction loads situation common translating procedures expression foo 
correct sequence literal type cast 
call proc arg ecient methods available nd instructions assigning register sintl simply restarts type inference rst instruction entry block template 
eventually instruction reached appropriate action taken 
return type subtype best path convert value return type value subtype case temporary register created current instruction result register replaced sequence instructions inserted converting boxed value result occurs previous assignment boxed type current assignment unboxed type 
return type subtype path return type subtype case type inference detected unrecoverable type error signal user 
enumerated case detail process converting register type type arg type type register implemented running dijkstra type graph running recursive conversion procedure edges path 
case naturally falls edge type successive edges type graph 
sintl type graph small routine easily precomputed memorized vastly improve performance 
current version sintl computes path requested conversion algorithm contributes little runtime assembler 
algorithm completely implemented daily pm compiler 
implementation type inference algorithm type environments requires lines scheme code including comments 
reg stack instruction selection algorithm may strange sintl register transfer language intermediate language scheme stack machine jvm 
traditionally compilers targeting register machines native assembly register intermediate language targeting stack machines jvm scheme vm stack language 
intend sintl register stack targets needed instruction representation compatible machine types 
simple code generation stack representations clearly better 
stack representation arguments instructions implicit unnamed take arguments operand stack instruction results pushed operand stack 
scheme code generation accomplished simple walk scheme expression 
arguments results unnamed stack code generator need worry mapping expression results names 
substantial drawbacks stack machine representation optimizing code generator 
stack machine instruction viewed instruction implicitly named arguments name argument depth operand stack 
optimizing assembler frequently wants compute result dependencies instructions instruction depends instruction value depth generated unfortunately diculty recovering information stack machine instruction ranges dicult computational impossible stack machine permits variable depth stacks blocks 
information assembler ham strung incapable popular optimizations 
choosing stack machine representation intermediate language particularly idea rst phase serious optimization algorithms compute dependencies instructions ectively converting stack machine code register transfer code 
trade mind sintl instruction set speci cally designed register transfer language 
advantages rtl representation sintl 
easy adapt compiler analyses optimizations sintl instruction set analyses typically designed rtls quad instruction form 
second code generation languages performed simple translation linear instruction stream 
need simulate operand stack attempt eliminate instruction stream 
major problem posed choosing rtl sintl designing algorithm converts rtl near optimal stack machine code targets jvm 
sections novel linear time analysis instruction selection algorithm automatically converts sintl rtl instruction stream stack machine code 
algorithms assume target stack machine provides arbitrary number local variables stored loaded instructions local reg set local 
reg values duplicated dup 
local variables assumed strongly typed implies values unrelated types assigned local variable 
explicit conversion algorithm register architecture stack machine allows sintl support targets jvm targets ectively 
sintl backend treat sintl rtl language similar execution model directly 
time jvm sintl backend view sintl stack machine language map instruction set naturally jvm stack machine code 
algorithm operates basic block graph template 
conversion occurs phases dag value dependency analysis local variable assignment stack machine instruction selection 
dag value dependency analysis dag value dependency analysis uses technique similar dag code generation described value numbering 
basic block basic block graph walk instruction stream forward backward building graph instruction return result exists register arguments create node labeled value hi ii position instruction stream 
argument look node labeled node exists add edge labeled node exists register produced outside block create new node labeled value add edge node label walk instructions basic block template complete graph gb describing computational dependency instructions block 
example dags depicted gures 
local variable assignment local variable assignment occurs linear walk basic block dag produces value dependency analysis 
formal arguments template marked local variables 
basic block dag gb walk nodes graph tagging registers local node 
node value hi ri register represents register 
inter block register register value computed block value block 
mark register local 

degree value multiple times block avoid computing value label register marked local 

node values hi set 
src node produced set 
instruction result register set 
marked local 
stack machine instruction selection instruction selection operates basic block dag produced value dependency analysis local variables assigned 
instruction selection algorithm basic block dag gb begins computing dominating nodes gb conversion process node dominator gb degree value produced basic block 
compute set dominating nodes gb order dominators index stored node value hi vi 
dominator node call algorithm main routine instructions instructions examines value hi vi label visited implying multiple node register invoke inst select function argument local 
load value stored local variable associated agged actual instruction needs generated 
invoke inst select 
label register marked local register append dup set local 
instructions value returned inst select 
inst select inst function provided instruction selection algorithm accepts sintl instruction extended instructions dup local set local 
returns sequence instructions target stack machine language inst 
function instructions reentrant generated occurs inst select inst recursively instruction arguments inst compute stack instructions argument 
stack instructions argument instruction selector returns sequence instructions inst 
words instructions inst select mutually recursive routines functions calling select stack instructions instructions basic block ultimately algorithms operate number instructions template 
aspects algorithms important point 
algorithms right respect evaluation order described scheme program 
scheme snippet de ne proc foo bar call foo executes call bar 
possible reg stack conversion algorithm depending instruction selection function inst select compute bar foo 
words algorithm enforce scheme order evaluation 
rs scheme specify order evaluation nested applications de ne proc bar foo reg stack algorithm select evaluation order expressions 
unfortunately sintl instruction set expressive describe order dependency expressions 
approach mark call tail call instructions marker locking evaluation order relative expressions 
conversion algorithm works quite successful capable compiling entire rs minus full continuations correctly 
jvm backend sintl current includes backends java virtual machine currently virtual machine additional backends development planning python vm 
jvm backend described detail sections fully functional includes novel representation choices 
section concluded performance measurements comparison scheme compilers 
jvm compilers high level programming languages target java jvm see achieved reasonable performance 
jvm attractive target high level programming languages reasons 
jvm highly portable running modern operating systems machine architectures 
virtual machines jvm achieves acceptable performance interpreted publicly available just time compilers vastly improve performance executing jvm code 
jvm includes garbage collector high level language targeting jvm receives reasonably high quality garbage collector free 
signi cantly high level language jvm gain easy access multitude standard java libraries 
ideally compiling scheme jvm immediately able cross platform windowing system secure network communications applet capabilities 
senses language sum libraries targeting jvm high level languages attractive real programmers business accomplish speci tasks 
serious issues arise compiling high level language scheme jvm 
scheme provides capabilities call current continuation lexical scoping rst class closures require facilities immediately jvm 
consequently signi cant challenge scheme compiler targeting jvm selecting appropriate representations scheme constructs permit inter operability scheme jvm libraries sacri cing performance 
approach jvm backend capabilities jvm implement scheme functionality possible avoid representations hinder inter 
design decisions lead immediately support shot upward continuations jvm exception mechanism representing frames heap allocated records prohibitively slow 
worse representation interact badly jits optimizing produce native code standard representations java constructs 
ultimate choose representations 
closures 
closure represented class environments stored vectors private class elds 
support full continuations jvm stack computation local variables hold scheme variables 
variables front compiler puts environment vectors shared lexically scoped closures 
instructions implementing closure represented apply methods subclass closure superclass 
arguments procedure passed jvm argument passing system arguments 
number arguments procedure exceeds extra arguments passed list apply method closure class 
similar argument passing mechanism bigloo number argument dispatching resides virtual table lookup jvm 
variable number argument procedures implemented apply routine accepting xed arguments list remaining arguments 
closure class procedure includes apply methods forward calls zero apply method 

applications 
application virtual call apply method closure object 
arguments passed directly remaining arguments passed list apply method 

remaining types 
unboxed booleans integers reals characters implemented jvm int real types 
boxed integers reals java lang integer java lang float objects 
pairs represented scheme speci classes scheme represented jvm null object 
symbols java lang strings strings java lang ers vectors jvm object arrays 
interesting extensions scheme directly supported jvm backend 
restricted form case lambda syntax 
supported jvm backend 
templates produced case lambda form reach jvm backend translated apply methods closure class 
instance consider realistic implementation scheme operator simpli ed integers 
de ne case lambda primitive int rest loop val car cdr rest pair 
necessary jvm support variable number argument procedures 
loop val car cdr val uses case lambda implement fast paths common zero argument cases 
pm compiler jvm sintl translate de nition jvm equivalent closure public proc plus extends closure public apply return box integer public apply object return public apply object object integer integer integer integer int unbox integer unbox integer return box integer public apply object object object return var apply cons cons cons nil public apply object object object object return var apply cons cons cons cons nil public apply object object object object list return var apply cons cons cons cons public var apply list rest object val car rest object cdr rest instanceof pair val apply val car cdr return val supporting case lambda scheme level radically improves performance rs runtime system 
case lambda syntax write ecient procedures arithmetic operations list operations standard invocations uses arguments rs de nes procedures accepting variable numbers arguments 
additionally procedures accepting optional arguments routines optimized de ne display case lambda obj display obj current input port obj port 
scheme implementations de ne sorts procedures procedures explicitly check optional argument dispatch fast path body code 
check relatively fast de nition forces memory allocation call routine list drastically hurt performance 
rs scheme procedures standard procedures cdr car rede nable 
cases scheme compiler statically determine mappings identi ers values 
consequently critically important global variables resolved ecient preferably constant time respect accesses variable 
jvm backend resolves global variables class construction time placing global variable lookup class static constructor 
performance gains optimization enormous relative doing variable lookup class construction time 
behavior understandable common procedures allocate escaping lambdas de ne lambda global variable look occurs closure construction time call allocate closure lookup binding 
costs variable lookup call site expensive consider viable implementation option 
encountered unexpected diculties compiling jvm 
type inference algorithm removes type checks runtime system code 
unfortunately jvm veri er handle type safe operations sintl proves possible remove 
consequently compiler produces di erent code sequences jvm veri able version unnecessary checks satisfy veri er non veri able checks 
performance results versions section 
extended compilation example section includes extended compilation example demonstrate phases compiler utility phase sintl assembler 
consider compilations classic recursive fibonacci procedure front compilation de ne fib fib fib front macro expansion normalization function inlining produce procedure code generation sintl de ne fib lambda primitive int primitive int primitive int fib fib primitive int output front code generator normal form sintl templates produces define template fib primitive int branch false 
case front compiler inline arithmetic operations 
code segment includes inlined arithmetic operations clarity 
benchmarks section inlined arithmetic operations 
primitive int primitive int global ref fib call global ref fib call primitive retval int branch ret label case set 
retval branch ret label ret return retval initial sintl phases see code sequence suboptimal retval register assigned dissimilar types unboxed integer unit primitives called arguments incorrect types required type checks operations 
rst phases sintl parsing intra basic block optimizations code expansions branch optimizations occurred template looks define template fib label entry literal lit primitive int lit branch false 
case label label literal lit primitive int lit literal lit primitive int lit global ref fib call global ref fib call primitive retval int return retval label case literal lit return lit return instruction propagated back incident blocks 
type inference type inference begins rst instruction entry block type environment 
literal lit type environment contains binding lit 
instruction primitive int type signature 
type need instruction stream follows ensure type type cast primitive int lit checked contains integer unboxed value type requirements int primitive 
branch false 
case instruction passes type inference problem 
entry block processed left type environment lit processing block label 
known type need unbox result need check type 
type inference left type safe template define template fib label entry literal lit ensure type type cast primitive int lit branch false 
case label label literal lit type cast primitive int lit literal lit type cast primitive int lit global ref fib type cast call global ref fib type cast call ensure type type cast ensure type type cast primitive retval int type cast retval return label case literal return point see optimizations possible 
common subexpression elimination intra inter block eliminate redundant unbox operations 
current version sintl perform cse expect add cse near 
reg stack instruction selection dag dependency analysis run basic block producing dags entry block gure label block gure case block gure 
point control enters jvm backend 
reg stack instruction selection algorithm run jvm instructions peephole optimized producing sequence jvm instructions syntax jvm source code method public apply ljava lang object ljava lang object limit locals limit stack var ljava lang object dag entry block dag label block dag case block entry aload checkcast java lang integer invokevirtual java lang integer intvalue iconst lbl fib lit ljava lang integer areturn lbl fib fib location getfield scheme location val ljava lang object checkcast scheme closure aload invokevirtual java lang integer intvalue iconst isub invokestatic scheme system box integer ljava lang integer invokevirtual scheme closure apply ljava lang object ljava lang object checkcast java lang integer invokevirtual java lang integer intvalue fib fib location getfield scheme location val ljava lang object checkcast scheme closure aload invokevirtual java lang integer intvalue iconst isub invokestatic scheme system box integer ljava lang integer invokevirtual scheme closure apply ljava lang object ljava lang object checkcast java lang integer invokevirtual java lang integer intvalue iadd invokestatic scheme system box integer ljava lang integer areturn method static class variable lit contains static class eld holding boxed object representation literal 
performance results jvm sintl benchmarked pm compiler sintl jvm backend scheme compilers 
benchmarks gabriel scheme benchmarks port classic gabriel benchmarks lisp compilers william clinger 
current compiler capable running gabriel benchmarks 
benchmarks including short description follows tak vanilla implementation recursive takeuchi function 
tak benchmark measures performance arithmetic operations integers recursive tail recursive calls 
takeuchi function lists counters 
variant list length created argument takeuchi function 
tak function implements tail recursive shorter 
predicate lists 
subtraction implemented cdr counter list 
counter lists preallocated measures performance list processing operations consing 
deriv simple symbolic derivative function lists symbols represent arithmetic expressions 
deriv uses cond car expression list compute derivative expression 
deriv function cons answer list deriv benchmark primarily measures performance branches cons list 
destruct benchmark measuring performance destructive list operations simple large function internally de ned loops 
cps tak continuation passing style variant tak benchmark 
measures performance rse class procedures tail recursion 
variant deriv benchmark lisp style property lists perform expression dispatch 
property lists implemented doubly nest global association list 
measures performance cons list 
div iter iterative division benchmark lists counters 
div iter cons measures performance list operations 
iteration accomplished internally de ned procedure 
div rec recursive variant div iter benchmark 
choose compilers compare performance jvm backend 
obviously compare scheme compilers jvm 
publicly available scheme system jvm kawa 
jvm backend running virtual machine jit compiler important consider performance backend relative scheme virtual machines 
reason selected scheme byte coded virtual machine speci scheme language 
comparison compiler drscheme system plt group rice 
consider byte compiled native compiled performance 
estimate performance relative optimizing native code compiler selected bigloo compiler inria 
detailed information compiler provided jvm sintl benchmark results producing sun microsystems java distribution linux native green threads just time compiler borland 
java heap set initial words benchmark run heap 
benchmark numbers non veri able version jvm sintl backend 
front compiler sintl inlined standard bindings scheme procedures 
kawa current stable version kawa version 
benchmarks compiled kawa compiler class les standard bindings primitives 
compiled les loaded kawa repl run timed 
scheme vanilla scheme distribution build 
benchmarks compiled scheme bench mode allows scheme compiler inline primitive operations 
front compiler currently transform internal non escaping tail recursive procedures loops 
optimization performed bigloo kawa vastly improve performance destruct div iter benchmarks 
version analysis currently development 
clear kawa compiler slow compile benchmarks 
am current contacting kawa developers uncover reasons 
stable versions compiler signi cantly faster 
tak deriv destruct cps tak div iter div rec total pm kawa scheme mzscheme bigloo sintl kawa table scheme systems performance gabriel scheme benchmarks 
numbers running time seconds 
dash indicates benchmark compile ran incorrectly 
mzscheme mzscheme benchmarked byte code native code compiler 
byte code results collected loading benchmark code interpreter performs byte code compilation running benchmark 
mzscheme version 
benchmark results collected native code compiler version prim lite options perform primitive inlining lightweight closure conversion 
bigloo bigloo compiler optimizing scheme compiler producing native code executables ansi standard bigloo benchmarks collected compiling benchmarks single stand application version bigloo version 
optimization level highest available includes heap stack optimizations method inlining loop unrolling inlining macro optimizations 
performance measurements conducted mhz intel pentium ii processing running redhat linux 
benchmark result represents sum cost running benchmark times 
benchmark numbers table 
gure depicts total runtime entire gabriel benchmark suite compiler tested 
numbers taken grain salt details compiler concealed summation 
caution data important note benchmark gabriel suite calibrated require xed amount time 
summation gure consequently weights performance benchmark di erently performance results examined scheme compilers gabriel benchmark suite 
performance results examined scheme compilers gabriel benchmark suite bar graph format 
performance results examined scheme compilers gabriel benchmark suite minus kawa 
performance results examined scheme compilers gabriel benchmark suite minus kawa bar graph format 
total performance results examined scheme compilers gabriel benchmark suite 
number summed total seconds required run benchmarks gabriel benchmark suite 
consequently poor performance single benchmark may uence total time consumed compiler 
said large di erences total performance interesting 
comparisons worth considering detail 
performance relative kawa kawa extremely useful judge quality pm compiler 
minimum requirement jvm sintl produce better ecient code closest competitor compilers 
figures depict performance jvm sintl relative kawa respectively 
useful comparison jvm sintl scheme 
comparison gives indication performance bene ts compiling scheme speci virtual machine relative supported machine jvm 
shows performance jvm sintl scheme di er radically benchmark 
toto jvm sintl scheme consume amount time benchmarks 
logic sintl backend considered relative scheme compilers bigloo 
direct comparison displayed gure 
notice sintl beats bigloo compiler remains little twice fast sintl 
performance jvm sintl vs kawa gabriel benchmark suite 
performance jvm sintl vs kawa gabriel benchmark suite 
performance jvm sintl vs scheme gabriel benchmark suite 
performance sintl bigloo gabriel benchmark suite 
tak deriv destruct cps tak div iter div rec total veri able able veri able inline able inline table sintl jvm backend performance di erent backend con gurations 
tak deriv destruct cps tak div iter div rec total veri able able veri able inline able inline table relative sintl jvm backend performance di erent backend con gurations 
values percent relative baseline code inlining veri able output 
interesting aspect sintl jvm backend ability produce veri able able jvm output 
due limitations jvm veri er discussed veri er rejects compiled code type inference proves type checks unnecessary 
tables shows runtimes gabriel benchmarks di erent compiler veri cation options 
graphical representations information available document 
sintl pm compiler order magnitude performance improvement existing scheme compilers jvm intelligent powerful program analyses 
separating front compiler sintl assembler pm compiler easily support diverse set backend targets 
declarative type system strongly typed instructions primitives sintl ensure type safety instruction type constraints imposed sintl language primitives 
reg stack algorithm ectively convert sintl register transfer language stack machine language implemented jvm sintl backend java virtual machine 
backend uses natural jvm representations scheme data types natively supports case lambda syntax clever performance results di erent pm compiler con gurations jvm sintl backend 
relative performance results di erent pm compiler con gurations jvm sintl backend 
performance results veri able able jvm byte codes backend 
jvm virtual table dispatch 
runtime system written entirely scheme lines handwritten scheme speci java code jvm backend order magnitude performance improvement existing scheme java compilers comparable performance scheme speci virtual machines 
ullman aho sethi 
compilers principles techniques tools 
addison wesley 

kawa compiling dynamic languages java vm 
usenix conference new orleans june 

kawa compiling scheme java 
lisp users conference berkeley ca november 
kent dybvig 
implementation models scheme 
phd thesis university north carolina chapel hill april 
robert bruce findler cormac flanagan matthew flatt shriram krishnamurthi matthias felleisen 
drscheme pedagogic programming environment scheme 
hugh glaser pieter hartel herbert editors programming languages implementations logics programs volume lncs pages southampton uk september 
springer 
richard gabriel 
performance evaluation lisp systems 

internet pages association advancement george 
customizable reusable code generators 
jagannathan weeks wright 
type directed ow analysis typed intermediate languages 
simon peyton jones norman ramsey 
portable assembly language supports garbage collection 
david walsh kevin hammond 
implementing evaluation strategies java 
milner tofte harper 
de nition standard ml 
mit press cambridge massachussetts 
russell benton kennedy 
compiling standard ml java bytecodes 
icfp baltimore md september 
rees kelsey 
tractable scheme implementation 
serrano weis 
bigloo portable optimizing compiler strict functional languages 
sas pages 
andrew wright robert cartwright 
practical soft type system scheme 
technical report rice university december 
revised version proc 
acm conference lisp functional programming 

