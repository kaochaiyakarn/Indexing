composable compilable macros macro systems especially lisp scheme allow macro transformers perform general computation 
language implementing compile time macro transformers usually language implementing run time functions 
side effect sharing implementations tend allow compile time values run time values values separate compilations 
breaks programming tools parse code executing 
macro implementors avoid harmful obeying certain protocols inserting phase distinguishing annotations code 
annotations fragile protocols enforced programmers reason result terms compiler implementation 
mzscheme language plt scheme tool suite addresses problem macro system separates compilation sacrificing expressiveness macros 
categories subject descriptors software programming languages language constructs features scheme software processors parsing preprocessors software engineering interoperability general terms languages design keywords macros modules language tower macro systems provide convenient interface extending compiler support new language constructs 
expressive macro systems macro transformers constrained mere permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp october pittsburgh pennsylvania usa 
copyright acm want 
matthew flatt university utah pattern matching transformations may perform arbitrary computation expansion 
addition macros may manipulate syntax enriched lexical information manipulating raw source text means macro defined constructs assigned meaning independent details macro expansion macro introduces local variable named temp happens call car function :10.1.1.18.3867
lisp scheme tradition macros defined macro extensible language extensions stacked language tower extension language implementing extension 
trouble expressive macro systems 
typical scheme system language towers cause trouble 
advances macro technology simplified creation individual blocks tower delivered reliable mortar assembling blocks 
example suppose scm implemented extension scheme implemented scm directly scheme 
typical load sequence load scm load scm statements placed file scm submitted scheme interpreter execute scm successfully 
problem starts programmer tries compile program execution 
supplying scm compiler useless result simply compiled form load statements 
full compiler needed run time scm loaded 
problem compile time code scm distinguished way run time code scm andthe run time load operation abused configuration time operation 
conventional solution decorate scm similar files eval annotations designate intended phase expression eval compile load scm load scm solution major weaknesses 
resulting annotations fragile small changes program organization render set annotations incorrect 
example suppose scm initially contains macro definitions run time support function added 
eval annotation augmented load properly load run time parts scm 
second large examples tall language towers library code written different extensions scheme correct eval annotations difficult discern 
annotating load scm probably right strategy scm defines mixture macros run time functions 
third incorrect set annotations appear correctly time due accidental implementation compile time functionality run time code happens loaded 
general static checking ensure variable bindings satisfied code right phase 
macros serve reliable compiler extensions programming model clearly separate compile time run time phases code times 
phases may interleaved interactive evaluation compiling new code affect execution previously compiled code 
similarly amount interleaving matter code execute compiled advance compiled interleaved execution half code compiled today rest compiled different machine tomorrow 
complete application compiled programming environment able strip compile time code final deliverable 
reliable macros mzscheme 
new macro module system mzscheme implementation language plt scheme suite supports compilable macros sense 
concretely system ensures program works correctly loaded interactively read eval print loop works correctly run compiler run debugger parsed syntax checker expanded static analysis vice versa 
implemented system backed formal model 
model explains module compilation demonstrates computational effects including variable bindings confined single phase 
module system avoids problems eval making module dependencies explicit relying sideeffects load distinguishing compile time dependencies run time dependencies 
macro system enforces separation different phases compile time variables resolved run time values happen loaded 
illustrates module macro programming mzscheme 
module imports variables syntax require 
imports implementing run time expressions right hand side definition addition imports require syntax 
ther imports implementing compile time expressions suchas right hand side macro definition module imports require 
enforcing separation compile time run time means instantiating twice compiling running furthermore separating different compilations means instantiating compile 
proper module instantiation part solution indispensable features scheme macros complicate enforcing phase separation macro generating macros macro expansion generate expression run phase generator 
macro generating macros critically important implement language extensions bind compile time information 
example class definition form bind compile time information class methods 
lexical scope context macros lexical scope means free identifier introduced macro expansion refers binding macro definition context macro context free identifier macro refers binding macro context programmer explicitly breaks hygiene 
free variables bound may refer run time values macro transformers potentially generate transformer expressions 
terms complications affect striped box implementation contain expressions output macro 
code turn compile time code bound striped imports code turn runtime code bound polka dotted imports separating different parts statically decidable 
tracking dependencies requires extension previously known macro expansion techniques 
extension tracks phase phase specific binding transformed identifier resolve bindings correctly defined time 
users initial experience new macro module system overwhelmingly positive 
previously developing program interactively programmer embark lengthy process adding eval annotations program carefully tuning calls load proper sequence command line flags push code compiler analyzer 
libraries frequently failed load incorporated program previously untried order 
loading compilation failed users loss explain failure 
experiences typical users scheme lisp implementations longer mzscheme 
implementation mzscheme relies syntactic extension language towers greater extent 
result substantially improved code base easier experimentation new language constructs 
require require syntax define define syntax require require 
example modules require roadmap 
section provides overview mzscheme macros modules 
section presents example syntactic extension illustrates key problems compiling macro code mzscheme macros modules solve problems 
section provides pragmatic details concerning macros modules mzscheme 
section sketches formal model results 
section summarizes related 
macros modules primer module mzscheme program code resides module code implements run time function compile time macro 
syntax module declaration module module name language name body element 
language name usually mzscheme 
language body element definition expression executed effect syntax definition import export body element define id expr expr define syntax id expr require req spec 
require syntax req spec 
provide prov spec 
superscript expr indicates expression evaluated run time phase superscript expr define syntax indicates expression evaluated compile time 
require form imports bindings exported module 
bindings imported require apply run time expressions expr module body 
require syntax form similar require imported bindings apply compile time expressions expr provide form exports subset module macro variable bindings 
exported binding defined module define define syntax imported module require 
modules zoo module provides functions creating manipulating zebra lizard records module zoo mzscheme provide zebra zebra 
zebra weight zebra stripes lizard creates zebra record weight stripes define zebra weight stripes list zebra weight stripes recognizes zebra define zebra 
list 
length eq 
zebra car extracts zebra weight define zebra weight list ref define lizard weight length color list lizard weight length color represents elided code 
separate metrics module implement animal weight function functions zoo module metrics mzscheme require zoo provide animal weight define animal weight cond zebra 
zebra weight lizard 
lizard weight invoke metrics module zoo module automatically executed executed metrics 
generally define invoke module mean executing module expr executing expr sof required module 
require execution rule applies chain modules module directly indirectly invoked module executed 
unused modules ignored modules multiple require paths executed 
macros addition exporting values zebra function module export macros 
example zoo module provide zoo switch macro conveniently dispatching animal records implement animal weight compactly follows define animal weight zoo switch zebra lizard metrics module compiled loading macro definitions zoo implies zoo compiled earlier 
words just executing module causes imports executed compiling module requires imports compiled 
addition compiling module executes compiletime portions imported modules obtain macro transformers 
zoo module defines zoo switch macro define syntax module zoo mzscheme provide zebra lizard zoo switch define syntax zoo switch stx macro implemented transformer syntax objects 
input syntax object stx zoo switch corresponds macro output syntax object represents expansion 
syntax object similar expression encapsulates source location lexical information parts 
case zoo switch macro clauses zebra lizard clause variables second clause variables 
stx argument syntax object matching particular shape 
input syntax pattern matching syntax case form module import relation acyclic 
mzscheme provides separate mechanism defining units mutually recursive units implemented macros 
define syntax zoo switch stx syntax case stx zebra lizard zoo switch expr zebra name name body 
lizard name lt name name body zoo switch pattern zebra lizard literals listed pattern expr name name body pattern variables 
pattern ellipses 
match sequence source sub expressions preceding subpattern variable sub pattern bound list successively matching source parts 
pattern zoo switch generates list matches corresponding sequence body expressions zebra clause 
zoo switch transformer produce cond expression clauses bind variables provided macro 
deconstructing syntax syntax case resulting syntax object constructed quote form 
quote content refer pattern variables bound syntax case 
pattern variable replaced matched subexpression define syntax zoo switch stx syntax case stx zebra lizard zoo switch expr zebra name name body 
lizard name lt name name body val expr cond zebra 
val name zebra weight val name zebra stripes val body quoted template ellipses duplicate preceding duplication sub template variable sub template source part variable list matching parts 
output expression zoo switch lists sequence matched input pattern 
free variables inside template bound pattern variables obtain bindings environment template environment macro 
zebra weight expansion zoo switch refers definition zoo context zoo switch different binding zebra weight 
compilation phases result expression syntax case clause need immediate expression 
result expression may perform arbitrary computation compile time 
common compile time computation error checking 
example improve zoo switch macro detecting multiple bindings identifier clause expression zoo switch zebra multiple bindings lizard implement duplicate variable check result part syntax case clause zoo switch consists sequence expressions check duplicate bindings clauses generate macro expansion 
define syntax zoo switch stx syntax case stx zebra lizard zoo switch expr zebra name name body 
lizard name lt name name body check dups name name check dups name lt name name val expr macros check duplicate variables implement check dups function check module module check mzscheme provide check dups define check dups variables check dups available implementation zoo switch zoo import check 
function needed compile time run time zoo imports check require syntax module zoo mzscheme require syntax check define syntax zoo switch stx compile time portion zoo executed compile metrics run time portion check executed due require syntax import 
check dups function available transformer zoo switch applied 
run time portion zoo executed check ignored 
check dups bound run time expressions zoo accidentally run time 
similarly check imported require require syntax dups bound implementation zoo switch 
modules contain free variables incorrectly importing check require require syntax lead syntax error free occurrences check dups 
general define visit module mean executing expr invoking require module 
see section visiting module visits module required modules 
execution phases module invoked need invoke required modules obvious expression module evaluated imported variables initialized 
furthermore chain initialization dependencies form chain function calls forces chain invocations require 
example module import metrics call animal weight turn calls zebra 
zoo 
obvious visiting module visit required modules case macro uses chained 
example metrics export zoo weight switch macro expands zoo switch exposes weight field clause define syntax zoo weight switch stx syntax case stx zebra lizard zoo weight switch expr zebra name body 
lizard name body zoo switch expr zebra name hide body 
lizard name hide hide body module uses zoo weight switch macro transformer metrics applied result zoo switch expression 
continue expanding zoo switch transformer zoo called 
compile time portion zoo executed compile time portion metrics executed 
putting macros modules define animal specific zoo switch form works hand rolled data structures certainly prefer general define record form corresponding record switch dispatching form 
extensions scheme implemented implementations rarely provide compile time checking record switch clauses 
way zoo match reports syntax error clause wrong number variables record switch trigger syntax error clause mentions undefined datatype lists wrong number fields datatype 
section introduce define record form cooperating record switch form detects ill formed switch clauses rejects compile time 
syntax checking forces level communication implementations define record record switch characteristic sophisticated syntactic extensions 
time implementation communication channel exposes common problems compiling sophisticated syntactic extensions 
record definition dispatch typical record declaration form scheme generates constructor procedure creating instances record predicate procedure recognizing instances record field selector procedure field record 
purposes choose simple syntax define record constructor name predicate name field selector name 
ellipses indicate sequence field selector names number field selector names determines number fields record number arguments constructor procedure 
implement define record record module reimplement zoo module zoo mzscheme require record provide zebra lizard define record zebra zebra 
zebra weight zebra stripes define record lizard lizard 
lizard weight lizard length lizard color compile time run time require syntax require zoo require record metrics require require 
modules defined section record predicate field accessor procedures programmer define animal weight function original version section 
cases patternmatching form record dispatch especially convenient 
implement additional form record switch record switch expr constructor name local field var 
body expr 
initial expr produces value match constructor name name record constructor definition scope local field var provided field corresponding record type 
local field var bound field value case body expr 
implement record switch alongside define record record revise metrics follows module metrics mzscheme require record zoo provide animal weight define animal weight record switch zebra lizard key constraint record switch concerns error handling 
programmer writes define bad animal weight record switch zebra fields lizard definition rejected illegal syntax 
generally record switch expression mentions record constructor name defined number field variables match number fields definition constructor name switch report error precise diagnosis mismatch 
furthermore require error reported compile time record switch expression evaluated 
implementing records main part record module defines syntactic transformers define syntax module record mzscheme provide define record record switch define syntax define record stx define syntax record switch stx sketch shows pattern matching parts define record record switch module record mzscheme define syntax define record stx syntax case stx define record name name name 
define values name name name 
define syntax record switch stx syntax case stx record switch expr name local name 
body 
val expr val instance name 
evaluate body 
local name 
body try cases 
record switch val record switch expr error matching pattern expr ellipses pattern define record generates list names matches multiple definition output lists sequence names 
pattern record switch similarly matches number local field names switch clause plus number additional clauses extra clauses processed recursive macro 
eventually record switch clauses matching second pattern generated expression reports failed pattern match reached run time 
implementation define record record switch requires computation compile time run time 
compile time define record store record definitions field information record switch consult stored information generate uses predicate field selectors compute appropriate error message 
run time define record form generate record type constructor predicate selector procedures record switch form pattern match records 
separation especially clear place compile time functions compile time module run time support run time module 
compile time module defines table hold record definition information module compile time mzscheme provide defined export 
define table null define register def name name names set 
table cons list name name names table define check constructor name names find name table raise syntax error field count differs 
define constructor predicate name find name table name 
define constructor field accessors name find name table names 
alternative design put set record definitions named datatype missing clauses reported compile time ml 
run time module defines tag procedure generators module run time mzscheme provide defined define counter define generate unique tag set 
counter counter counter define record procs tag names return multiple procedure values 
record module brings require require syntax module record mzscheme require syntax compile time require run time provide define record record switch define syntax define record stx define syntax record switch stx implementing rest compile time run time straightforward concentrate completing record module 
attempt failure naively define record register def register constructor name mapping generating expanded expression define syntax define record stx syntax case stx define record name name name 
register def name name name define values name name name 
see strategy fails consider compiling zoo metrics modules separate scheme sessions 
metrics imports zoo zoo compiled 
compiling zoo zebra lizard added table record definitions compiled uses define record mention register def 
compile time table registrations disappear compilation zoo complete 
metrics compiled new scheme session table record registrations created afresh zebra lizard registered 
key feature mzscheme module system compiling metrics fail modules compiled session 
implementor define record macro alerted problem immediately point separate compilation separate syntax checking important 
second attempt success mzscheme module system define record permanently attach record registrations zoo compile time information 
registrations attached executing compile time portion zoo compiling metrics metrics imports zoo require reinstate zebra lizard registrations 
macro generating macros provide define record mechanism attach compile time information zoo 
define record macro expansion new macro definition new macro definition attached zoo compiletime expression 
technically define record generate dummy macro definition calls register def producing transformer procedure 
readability syntax form define syntax define record stx syntax case stx define record name name name 
syntax register record compilation register def name name name define values name name name 
tag generate unique tag record procs tag name body syntax expression executed compile time just right hand side define syntax 
consequently expansion define record compiled form zoo contain compile time registration zebra 
metrics compiled import zoo triggers execution zoo compile time expressions registering zebra 
individual time metrics compiled compile time portions zoo record executed afresh 
compile time portion record imports compile time compile time executed afresh metrics compiled 
fresh execution compile time explains attempt implementing define record triggers predictable compile time error 
zoo metrics compiled scheme session compiled different executions compile time different record tables 
phase separation losing phase specific calculation early attempt implementing define record programmer inadvertently compile time run time operations macro 
example programmer forget syntax wrapper register def define syntax define record stx syntax case stx define record name name name 
register def name name name define values name name name 
tag generate unique tag record procs tag name case macro result sense register def run time position binding register def refers compile time function 
mzscheme flags syntax error resulting expression register def variable free run time portion record 
syntax check important 
register def function exist compile time compilation interleaved run time typical read eval print loop 
case register def disallowed interleaved compilation produces result separate compilation 
detection identifier phase occurs relatively late macro expansion process 
example output cor rect define record phase register def identifier determined output generated syntax 
general phase identifier determined statically quoted template 
example define syntax macro syntax define syntax define record stx syntax case stx define record name name name 
syntax register def name name name define values name name name 
tag generate unique tag record procs tag name case syntax expression expanded discover register def compile time 
perverse implementation syntax dynamically choose put body compile time context run time context 
permit identifier resolution proper phase identifier carry versions lexical information phase 
new twist lexically scoped macros key supporting simple reliable compilation 
separating phases begs question phase contains scheme implementation kernel procedures 
functions cons needed compile time run time 
answer module including core scheme exist multiple phases phase contains distinct execution module 
particular mzscheme language declaration record effectively imports core scheme forms require require syntax instantiations core scheme separate compile time cons principle unrelated run time cons 
generally mzscheme module system allows module import single identifier different modules different phases 
mzscheme details pragmatics practice module mzscheme placed file modules refer relative file paths library paths 
example zoo placed zoo scm file metrics import require zoo scm 
library paths rely mechanism similar classpath environment variable java implementations find libraries 
module declaration module module name language name body element 
language name refers module built module mzscheme possible choice 
syntax semantics body elements determined language name 
words module body starts syntax variable bindings language name initial import introduce bindings module body including bindings define provide require 
definitions imports exports indicated section body element mzscheme language definition expression syntax definition import export body element define id expr expr define syntax id expr require req spec 
require syntax req spec 
provide prov spec 
grammar expr extends standard scheme grammar including syntax introduces local macro expr id lambda id 
expr expr 
syntax case expr template syntax id expr 
expr syntax superscript binding expression indicates expression evaluated phase earlier syntax body 
require form imports bindings module prefixed versions subset prefixed subset renamed bindings req spec module name prefix pfx id module name module name identifier 
prefix pfx id module name id 
rename module name local id export id provide form export bindings individually optionally renaming bindings originating particular module exported group prov spec id rename local id export id module name module name id 
defined defined id 
module definitions private module 
module contain number require provide require syntax declarations order 
macro expand require require syntax declarations definitions expressions 
scope imported defined name covers entire module body 
name multiply defined free variables disallowed 
local imported macros expand additional definitions imports module body partially expanded discover definitions 
consequence disallowing multiple definitions identifier successful partial expansion leads unambiguous expansion 
variables module bound runtime position compile time position 
run time modules import export variables opposed values means assignments variable set 
visible outside module 
imported variables mutated set variable mutated defining module immutable 
restriction enforced compilation allows compiler perform optimizations immutable bindings 
kent dybvig recommending restriction 
compilation invocation module compiled module visited righthand expr define syntax declaration module evaluated immediately 
require syntax form triggers invocation syntax invocation require syntax forces certain amount interleaving compilation execution 
furthermore due phase shifting nature syntax macro expansion involve concurrent phases compilation arbitrarily tall tower expanders 
state phase kept separate lexical scoping phase specific binding imports 
value expr variable accessed expr code viceversa 
furthermore invocation compiled module require syntax invocations 
particular main module program compiled compiler strip compile time code program expr including entire modules require syntax 
syntax primitives syntax object class value syntax objects exist run time compile time primarily compile time 
built operations support deconstruction syntax object composition new syntax objects old ones comparison binding properties identifier syntax objects determining refer lexical binding 
syntax case form mzscheme expands expression uses built operations pattern match syntax objects 
quote syntax primitive form similar quote generates syntax object constants lists symbols 
template form expands expression uses quote syntax portions template refer pattern variables 
syntax case communicates pattern variable bindings roughly way define record communicates record switch 
model compilation formal model mzscheme macro module system builds dybvig model 
provide sketch model key results demonstrate various separation properties 
model simplification mzscheme ways 
module implemented fixed base language 
second modules export definitions renaming allowed export import 
third order declarations module body fixed require syntax declarations macro applications expand imports definitions 
despite simplifications model includes require syntax syntax model covers phase sensitive lexical scope macro defining macros interleaved execution phases 
source grammar 
source program consists sequence module declarations followed single invoke mod id 
final invoke declaration triggers execution module mod extracts computed value module id variable 
prog decl 
invoke mod id decl module mod require syntax mod 
require mod 
define syntax id exp 
define id exp 
exp stx prim exp 
stx identifier lexical info see prim primitive value operator id identifier mod module name module declaration contains sequence syntax imports sequence normal imports sequence syntax definitions sequence normal definitions 
expressions definitions arbitrary syntax objects represented exp non terminal parsed 
core language expressions 
parsing macro expansion intertwined exp write true grammar source expression 
absence macros ignoring shadowing core grammar expressions follows base exp app base exp base exp 
lambda id base exp syntax id base exp base exp macro app id base exp 
quote syntax exp prim id core source language consists function applications written explicit app functions local macro definitions macro uses written explicit macro app quoted literals primitives variable 
app lambda names keywords merely bound initial environment mean primitive application form primitive function form respectively 
executable grammar 
parsing compiling input exp produces executable exp compiling sequence source module declarations produces sequence compiled declarations cdecl 
invoke mod id cdecl mod require syntax mod 
require mod 
define syntax id exp 
define id exp 
exp app exp exp 
id mod id val val lambda id exp lit exp target language consists functions function applications lexical variable module variable mod id certain module variable phase literal constants 
constants encapsulate lexical context information useful constant macro implementation 
evaluation exps defined usual manner rules primitives app lit car lit exp exp expn lit exp store 
primitives consult extend modify store 
invoking visiting module extends store 
ing variable mod id accesses module installed 
module compilation 
compile module function compiles entire source module sequence previously compiled modules available import compile module decl cdecl list cdecl module compilation function consume produce store 
starts empty store reflecting separate compilation separate modules separation compiletime state run time state 
fresh store compile module visits required modules updates store imported bindings 
compile module function invokes require modules 
visiting invoking imported modules compile module annotates exps body module record imports definitions module 
annotation includes appropriate phase local definitions require imports require syntax imports 
expressions compiled right hand side define syntax declarations compile expr defined phase macro uses state modifying primitives store updated process 
store updated resulting syntax transformer bindings expressions right hand side define declarations compiled compile expr phase 
sets compiled expressions collected compiled module 
expression compilation 
expression parsed expanded compiled recursive compile expr function compile expr exp exp function compiles source expression exp execution phase environment maps identifiers locally bound syntax transformers store contains compile time state bindings invoked visited modules bindings imported syntax 
result compilation pair consisting compiled expression updated store 
defines exp shorthand applying compile expr exp ands 
result expression store pair exp process parsing exp adds mark subst annotations maintain lexical scope 
mark annotation effectively records binding introduced macro accidentally capture variables macro site 
subst annotation effectively renames identifier variables introduced macro accidentally captured macro site 
original source annotations 
information mark subst see dybvig 
parsing add new annotations 
function defined records module bindings annotations passing body expressions compile expr 
main step compiling expression stx exp expn determine meaning stx lexical information environment store current phase 
example stx resolves free symbol lambda expression compiled function 
stx resolves identifier bound macro transformer transformer function applied lit stx exp expn produce new exp updated syntax objects stx id mark stx mrk subst stx stx id stx mod id mrk phase number compile expr function stx exp exp expn app exp expn sn resolve stx app free expi si expi si stx stx exp lambda id exp resolve stx lambda free exp subst exp stx id exp exp id fresh stx stx exp exp exp id val resolve stx syntax free exp exp val eval exp exp subst exp stx id id fresh stx stx exp exp resolve stx macro app free resolve stx id id val resolve exp mark exp mrk lit exp stx mod id module mod id val macro eval app val lit exp exp mark exp mrk mrk fresh stx exp lit exp resolve stx quote syntax free stx id resolve stx id lexical id dom stx mod id resolve stx mod id module mod id val macro prim recording substitutions marks lit prim subst stx stx id subst prim stx id subst stx stx id subst stx stx id prim stx stx stx subst stx id fori mark stx mrk mark stx mrk 
identifier resolution resolve id resolve id free mark stx mrk resolve stx resolve subst stx stx id resolve stx mod id id lexical resolve stx stx stx resolve stx resolve stx mod id module resolve stx id free resolve stx id mark stx mrk mrk stx exclusive union subst stx stx id stx stx mod id stx 
expression parsing expansion compilation store new exp store sent back compile expr function 
stx resolves free symbol syntax thena sub expression sent compile expr phase result bound body sub expression compiled new environment phase module invocation 
modules compiled invoked phase phase shows literals require module invoked phase require module require module invoked phase 
invocation requires phase shifting operation compiled expressions exp shifts exp phases 
visit function augments store executing syntax portion module phase collection compiled modules far visit mod cdecl list require import mod triggers recursive visit phase require syntax import mode triggers invoke phase recursive visit phase 
phase expression mod shifted evaluated store updated syntax bindings name module defined identifier phase invoke function performs corresponding action runtime part module invoke mod cdecl list require import mod triggers recursive invoke phase phase expression mod shifted evaluated store updated variable bindings name module defined identifier phase invoke require syntax imports ignored visit 
program execution 
executing program means compiling program modules compile module 
compilation modules compiled available imports 
compiling modules main module designated invoke mod id executed invoke fresh initial store 
result program value mod id store 
formal results 
formal model certain separation properties immediately apparent 
state modifications module compilations affect final execution module compilation consumes produces store 

phase code stripped execution designated main module effect result applying invoke phase executes phase code 
related lexically scoped macros 
kohlbecker definition hygienic macros initiated chain research scheme macros leading syntax case system dybvig 
notable points way include bawden rees syntactic closures clinger rees lexically scoped pattern matching macros 
builds directly syntax case model 
original model local phase separation exists syntax model explain phase errors detected reported 
model fills small gap generalizing model cover module phases 
lexical macro systems restricted lisp dialects 
example maya extends java support lexically scoped syntax transformers 
maya transformers implemented maya means perform arbitrary computation implemented extended variant maya 
macros limited separation transformer definition normal java class transformer clause names compiled class achieve phase separation 
module systems 
curtis module system scheme allows modules export variables syntax syntax transformers implemented plain scheme 
syntax transformers may keep state restrictions state terms guaranteed match curtis provide information enforce restrictions 
scheme module system supports compile time import variables macro transformers wrapping import declaration syntax compile time imports bind compile time code module 
identifiers macros appear statically assigned run time status causes problems macro defining macros defined module 
furthermore module instantiated session multiple phases compiling multiple modules session means state preserved accidentally module compilations 
dybvig waddell integrate lexically scoped macros module construct chez scheme distinguish phases module imports programmers manage difference compilation interactive evaluation load visit 
mzscheme module form chez module form works definition position 
implemented macro mzscheme import form hides lexical bindings 
dylan provides pattern matching macros respect module scope macros perform arbitrary computation 
organizing language towers 
queinnec defines protocol macro expansion supports tower languages 
protocol independent macro definition language expansion function 
mzscheme essentially automates protocol module language integrating lexically scoped macros tower 

staged evaluation languages metaml support programs generate combine program fragments macro transformer 
programs serve different purpose macros extend syntax language processed compilers programming tools 
staged evaluation platform constructing macro systems exemplified compilation metaml 
languages support dynamic compilation similar staged evaluation languages phase distinction 
dynamically generated compiled code meant executed program manipulating host code 
language allows macro transformers perform arbitrary computation enforce separation computations run time versus compile time compile time module versus compile time 
enforced separation meaning code fragment depend order code compiled executed 
best programmers hard manage dependencies 
worst commonly dependencies subtle programmers manage correctly expect predictable results combining libraries new ways new programming tools 
mzscheme macro system enforces separation run time compile time computations 
enforcement restrict kinds macros implemented 
mzscheme enables implementation sophisticated cooperating syntactic extensions defined channels communication 
demonstrated expressiveness small define record record case example techniques apply implementing constructs classes object oriented programming component definition linking constructs lex yacc forms forms static typing 
scheme programmer perspective mzscheme modules macros obvious way tasks 
users report short learning curve putting module 
complex tasks require careful reasoning remains providing precise clear feedback phase violations 
important phase violations pass undetected 
practical terms means extension producers confident extensions extension consumers spend time command line flags configuration parameters 
acknowledgments robby findler matthias felleisen rest plt discussions launched refined 
mike sperber module related discussions 
wilson hsieh eric eide alastair reid jason baker feedback 
baker hsieh 
maya multiple dispatch syntax extension java 
proc 
acm conference programming language design implementation pages june 
bawden rees 
syntactic closures 
proc 
acm conference lisp functional programming pages july 
bromley 
lisp lore guide programming lisp machine 
kluwer academic publishers 
clinger rees 
macros 
proc 
acm symposium principles programming languages pages jan 
curtis 
module system scheme 
proc 
acm conference lisp functional programming pages 
davies pfenning 
modal analysis staged computation 
proc 
acm symposium principles programming languages pages jan 
dybvig 
chez scheme user guide 
cadence research systems 
dybvig hieb bruggeman 
syntactic abstraction scheme 
lisp symbolic computation 
flatt felleisen 
units cool modules hot languages 
proc 
acm conference programming language design implementation pages june 
friedman wand haynes 
essentials programming languages 
mit press cambridge massachusetts 
ganz sabry taha 
macros multi stage computations type safe generative binding macros 
proc 
acm international conference functional programming pages sept 
hart evans 
notes implementing lisp computer 
berkeley editors programming language lisp operation applications pages 
mit press 
kelsey 
defining record types 
org 
kelsey clinger rees eds 
revised report algorithmic language scheme 
acm sigplan notices sept 
kohlbecker friedman felleisen duba 
hygienic macro expansion 
proc 
acm conference lisp functional programming pages aug 
moggi taha el benaissa sheard 
idealized metaml simpler expressive 
proc 
european symposium programming volume lecture notes computer science pages 
springer verlag apr 
moon 
maclisp manual 
mit press 
poletto hsieh engler kaashoek 
tcc language compiler dynamic code generation 
acm transactions computing systems mar 
queinnec 
reflective tower 
proc 
reflections conference pages apr 
rees 
module system scheme 
scheme documentation 
serrano 
bigloo practical scheme compiler 

dylan manual 
addison wesley 
steele jr common lisp language 
digital press second edition 
steele jr sussman 
revised report scheme dialect lisp 
technical report mit jan 
waddell dybvig 
extending scope syntactic abstraction 
proc 
acm symposium principles programming languages pages jan 
weise crew 
programmable syntax macros 
proc 
acm conference programming language design implementation pages june 
wright 
pattern matching scheme mar 
