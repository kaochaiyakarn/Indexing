portable sampling profiler java virtual machines john whaley ibm tokyo research laboratory network computing platform yamato shi ken japan mit edu describes portable ecient sampling online measurement system production level java virtual machines 
system designed provide continuous real time system performance measurements dynamic compiler measurements target frequently executed time consuming code optimization informed optimization decisions 
system low overhead run continuously providing feedback mechanism dynamic compiler 
system utilizes novel data structure partial calling context tree pcct allows ecient encoding approximate context sensitive pro le information 
pcct organized incremental updates extracting important information ecient operations 
online measurement system implemented cross platform industry leading java just time compiler 
detailed performance results variety platforms show system ecient continuously production environment slowdown applications surprisingly accurate data collects typically accurate 

java just time compiler walk delicate line 
compilation occurs run time selective decides compile decides compile 
dynamic compiler spend extra time analyzing compiling piece code reasonable chance extra time spent compilation run time 
dynamic compiler timid decision making may opportunities optimization lead slow performance 
tradeo compilation cost run time bene central issue dynamic compilers 
useful metric dynamic compilation systems compilation cost versus run time bene equation 
see 
topt compilation cost versus run time bene equation 
equation 
refers change total run time refers amount time takes compile maintain new version refers number times new version executed refers average execution time code compilation topt refers average execution time newly compiled version 

negative execution time program reduced decision compile 

positive time increased better attempted compilation rst place 
dynamic compiler attempt compile methods possible considerably reduce absolute total run time 
focus methods total run time signi cant longrunning large frequently executed large methods slight speedup methods lead substantial speedup 
dynamic compiler online pro le information help guide decisions compile compile 
information aggressive dynamic compiler ability beat best static compilers information actual run time performance system available specialize code data suit situation 
tractability dynamic pro le information depends greatly eciently pro le data collected organized 
dynamic pro le information equation turns 
topt measurement compilation cost versus run time bene equation 
refers time spent collecting organizing analyzing pro le data 
dynamic pro le information expensive collect static compilation policy heuristic appropriate 
online pro le directed dynamic compiler feasible possible collect organize analyze online pro le information eciently 
describes portable ecient online measurement system production level java virtual machines 
system provides continuous real time system performance measurements dynamic compiler making compilation policy decisions optimizing code suit actual run time program characteristics 
unique feature online measurement system sampling instrumentation 
instrumentation pro give exact pro le information number times method executed branch taken 
number problems ill suited online java virtual machine including high overhead diculty adjusting precision unintended ects target code problems multithreaded contexts 
pro ler avoid problems cost exactness pro le information 
pro le information simply inputs compiler policy decision heuristics approximate pro le information su cient 
furthermore sampling surprisingly accurate show section 
describes data structure partial calling context tree pcct eciently encode approximate context sensitive pro le information 
contributions contributions data structures presents partial calling context tree pcct data structure eciently encoding approximate context sensitive pro le information 
presents algorithms update traverse data structure 
pro ling techniques presents pro le sampling technique estimates time spent method context occurred 
technique able distinguish new old stack frames discover edges code instrumentation 
able correctly identify complete calling context traversing entire stack 
evaluation overhead accuracy sample pro ling presents detailed performance evaluation overhead accuracy pro ler variety benchmarks systems 
remainder organized follows 
section compares system prior related systems 
section gives overview dynamic compilation system 
section describes sampling pro ler 
section describe partial calling context tree pcct data structure 
section presents detailed performance results 
conclude section 
related section discusses prior pro ling systems related 
profiling systems prior pro ling systems roughly broken categories collect data instrumentation code majority systems collect data sampling system 
discuss category turn 
instrumentation profiling systems existing pro ling systems insert instrumentation code program 
instrumentation code executes records pro le data example incrementing counter recording time 
fundamental problem instrumentation pro ling overhead accuracy determined dynamic run time program pro le 
controlling tradeo accuracy eciency dicult frequency code executes determined entirely dynamic pro le program 
furthermore may feasible transform code collect pro le data desired rate 
example placing instrumentation code inside tight loop may cause execute far high frequency alternative breaking iterations loop destroys loop structure 
adjusting pro le frequency requires recompiling rewriting code process time consuming complicated multithreading 
hand sampling pro ler tradeo controlled easily precisely varying frequency sampling data collected sample 
ability precisely control tradeo accuracy eciency essential adaptive dynamic compiler 
problem instrumentation pro ling heavyweight general 
example optimized system collects context sensitive pro le information overhead signi cant static analysis performed entire program minimize pro ling overhead luxury possible dynamic compiler 
precise recording method basic block level sampling pro ler tell precisely instructions time 
performing timing measurements problematic correctly factoring run time overhead instrumentation code di cult impossible 
issues instrumentation update pro le data structure correctly context multiple threads synchronization thread local copies 
operations data structure dicult nding frequently executed methods 
arnold sweeney described unique hybrid pro le technique building approximate calling context information 
instrument method entries increment check global counter 
counter ows call routine sample current thread stack 
lower overhead instrumentation techniques allows amount control rate pro ling occurs 
sampling profiling systems digital continuous pro ling infrastructure infrastructure sampling pro ling system 
uses hardware performance counters attain high frequency sampling samples sec fairly low overhead slowdown applications 
hardware performance counters obtain precise cache branch prediction information granularity 
rely hardware performance counters perform high frequency sampling number reasons 
system designed portable multiple operating systems microprocessors hardware performance counters requires operating system modi cations special chip features 
second sampling interrupts occur highest possible priority time spent interrupt routine short 
building data structure pcct intractable digital system simply records program counter 
third smp machine hardware performance counters processor requires synchronization processor versions data structure 
reasons di erent approach generate timer events necessary sampling see section 
pro ler pro ling tool sun java development kit jdk 
uses variety techniques pro le aspects running virtual machine including sample cpu time pro ling 
supports full context sensitivity 
pro ler ine cient scale due fact suspend threads sampling walk entire stack sample 
single thread overhead implementation sampling ms far higher 
sampling pro hardware performance counters require special hardware modi cations 
hall goldberg process sampling record context sensitive metrics unix processes 
method walk entire stack sample size data structure unbounded stores copy entire call stack sample 
sampling pro record calling context record single level context 
context sensitive data representations partial calling context tree originally introduced slightly di erent form primary data structure organize pro le data dynamic compilation system automatically identi es exploits opportunities dynamic specialization 
extends previous published precisely de ning data structure algorithms traverse update providing experimental results accuracy performance 
pcct earlier representation called calling context tree cct 
cct di ers pcct cct assumes complete calling context information 
algorithms build original version called weighted calling context graph wccg 
allowed back edges recursive methods construction algorithm time limited depth limited 
cct involve instrumenting procedure entries exits calls program update tree structure 
instrumentation su er problems discussed previous section 
pcct hand supports incomplete information operate context periodic sampling incomplete stack traversals 
structural di erence treatment recursive methods 
bound size cct combines nodes recursive methods losing context keep full context recursive methods di erent size restrictions 
pcct contain complete call graph information smaller keep information entire program run pcct occupies order kilobytes cct take megabytes 
arnold dynamic call graph edge weights dcg explore ectiveness various inlining decision heuristics 
dcg basis graph weighted edges essence single level calling context 
construction algorithm uses post mortem traces method entries exits 
arnold sweeney approximate calling context graph 
pcct contains weighted edges edge incremented sample new edges pcct 
pcct construction algorithm algorithm able avoid walking entire stack marking stack frames 
jerding stasko ball describe way encode dynamic call tree information compacted dynamic call tree 
construction algorithm uses complete traces calls execution program generate dag structure bottom fashion 
hash consing pattern recognition algorithm combine subtrees pcct multiple nodes correspond single context 

overview dynamic compilation system give brief overview dynamic compilation system java virtual machine 
see 
online controller subsystem brain system 
decisions methods compile compile sends just intime compiler form compile commands 
controls online measurement subsystem pro le commands 
just time compiler outputs machine code java threads execute 
online measurement subsystem consists pro le data repository stored form partial calling context tree pcct sampling pro ler periodically samples running java threads updates pcct 
information pcct just time compiler better optimization decisions feedback mechanism online controller compilation pro le decisions 
focuses online measurement subsystem contained dashed box 
publications cover subsystems detail 
online measurement system consists sampling pro ler described section partial calling context tree described section 
data just time compiler compiled code thread java online measurement system sampling profiler pcct update online controller sample compile command command profile output compiler feedback profile overview dynamic compilation system java virtual machine 
focuses online measurement system dashed box 

sampling profiler primary concerns online measurement subsystem eciency 
performance gains garnered having pro le data outweighed cost collecting data collecting pro le data pointless 
furthermore existence pro ler adversely ect peak performance executable code 
reasons opted sampling pro ler gather pro le data 
purpose sampling pro ler periodically sample running threads update data pro le repository 
pseudocode sampling pro ler 
suspend exit command received timer tick received thread local thread queue get program counter stack pointer cpu time update profile data repository smp signal profiler thread processor basic operation sampling pro ler 
sampling pro ler rst waits time period elapse 
busy wait timer described section 
timer expires sampling pro ler traverses local thread queue active java thread retrieves register state program counter stack pointer cpu time 
uses update pro le data repository typically pcct representations possible see section smp systems multiple thread queues perform threading signals pro ler thread processor pro ling 
note systems multiple os threads virtual machine lock associated active thread queue insures thread safety adding removing threads queue 
case sampling pro ler acquiring releasing lock sample time consuming 
possible race condition sampling threads added removed queue 
making slight modi cation thread queue code insured race condition worst cause threads skipped counted multiple times 
chance race condition occurs low pro le data inexact anyway acceptable behavior 
complications os thread scheduling virtual machines target platforms threads package explicit control thread scheduling 
systems java thread corresponds os thread os handles thread scheduling 
fact java threads run sampled complicates matters somewhat 
os thread remove thread current thread queue termination stealing suspends pro ler making modi cation 
threads rarely removed queue acceptable 
problem threading case sampling pro ler inspects threads run processor pro ler suspended threads dynamic call tree hot nodes circled corresponding dynamic call graph corresponding calling context tree 
mapping java threads os threads system call retrieve thread register state 
call returns error named thread currently executing 
smp system failed calls computationally intensive threads exactly threads want record 
furthermore os threads stacks sampled threads may change inspected 
case pcct stack traversal algorithm writes marker bit stack frames visits see section ects thread running 
os thread scheduling non method pro le data acquisition sampling pro ler suspends thread getting register state 

partial calling context tree section describes data structure store organize pro le information partial calling context tree pcct 
pcct compact way represent context sensitive pro le information 
give example pcct compare representations algorithm constructing pcct sampling pro ler 
overview example partial calling context tree partial senses 
partial sense constructed data sampling pro ler includes call paths active time sample 
second contexts stores may partially accurate excessively deep stacks 
pcct predecessor cct ers ef cient intermediate point spectrum run time call graph representations 
spectrum dynamic call tree dct 
dct records full context method invocations occur life program see example 
node tree represents single method activation edge tree corresponds single method invocation 
sample gure annotated pro le information circled nodes time consuming 
migrate processors 
thread safe implementation pcct stack traversal algorithm mark stack frames distinguish new old activations identical methods 
covered 
ease comparison uses example cct 
sequence call stack samples corresponding dynamic call graph node edge weights corresponding partial calling context tree 
dct precisely distinguish full calling context distinguish successive calls method 
example dct tell rst call time consuming second isn 
spectrum dynamic call graph dcg compactly represents method calls occur program 
see 
dcg single node invoked method represents activations method 
edge exists nodes call nodes 
compact representation imprecise information methods multiple calling contexts 
example information path executed lost 
encoded edge weight information example dcg 
bold edges hot edges refer method calls target method time consuming 
dynamic compiler dcg graph inlining decisions inline path executed 
furthermore probably potentially pro table inlining decision 
de ning edge weights number calls methods doesn better table inlining decision highest edge weight 
calling context tree cct intermediate point dct dcg 
represents calling contexts occur dct combines nodes calling context 
cct example contained 
notice successfully represents di erent calling contexts associated 
point mentioned exact dynamic call graph representations constructed instrumentation pro ler 
consider context sensitive data sampling pro ler encoded 
straightforward representation record copy call stack sample 
similar representation hall goldberg 
example see 
hypothetical table dynamic compiler calls time consuming 
samples call stack program dct 
obvious problem representation space representation takes space proportional depth stack times number samples 
problem representation fact salient information readily available nd hot methods candidates inlining requires traversing data structure keeping track large number sums 
information calls new sample encoded example impossible tell samples came seperate invocations invocation distinguish time consuming method frequently invoked method 
possible representation pro le data single node set invoked activations method la dcg annotate nodes pro le counters 
see example dcg 
notice dcg fact path executed lost 
partial calling context tree pcct attempt stack trace samples discover important nodes edges dct combining nodes context cct keeping important pro le information readily available 
example pcct contained 
pcct constructed assuming samples occurred times samples 
numbers pcct weights explained section notice dcg multiple calls share single edge distinct nodes called called notice node tree appeared sample doesn appear tree 
construction algorithm pcct distinguishes calls existed sample calls newly created sample 
gives pcct ability distinguish method occurs sample time consuming frequency executed 
construction algorithm pcct constructed periodically sampling call stacks cpu times running java threads incrementally updating data structure algorithm code syntax 
algorithm proceeds phases 
upward phase begins looking method corresponding program counter address 
system information stored binary search tree 
stores method bu er reads word current stack frame containing return address 
bit return address marker 
pro ler sets marker bits stack frames visited 
new stack frame constructed return address word overwritten systems support obtaining cpu times thread thread basis assumption threads take approximately amount cpu time 
approximations possible 
word addressed systems low order bit ignored 
byte addressed systems high order bit high memory mapped aliased low memory 
void update pcct void pc void sp int method buffer lookup pc int ind node upward phase ind buffer ind word rt sp lookup rt rt visited bit get node rt break sp rt visited bit sp sp allocate node downward phase ind buffer ind node edge get edge allocate node allocate edge time update sorted pos time update sorted pos code update pcct new sample encountered 
bit reset 
distinguish new old stack frames change code zero runtime cost 
stack frame visited set visited bit continue stack frame 
traversal continues reaches visited stack frame bu er ows 
traversal ends visited stack frame obtain node stack frame method create new node method 
enter downward phase algorithm 
downward phase retrieves method stack frame bu er searches edge current node node marked named method 
exists edge weight incremented target node current node new edge node created 
process continues methods bu er 
method reached weight nal node incremented sample complete 
actual implementation di ers slightly code 
distinguishes di erent call sites method 
second stops searching edges nodes new edge created 
clarity include code 
data structure definitions data structure de nition contained 
nodes represented pcct node structure 
contain pointer method identi er node cpu time pointer incoming edge pointer list outgoing struct pcct node method method method identifier pcct edge parent incoming edge pcct edge children list edges pcct node prev sorted node list short time cpu time struct pcct edge pcct node edge source target pcct edge edge source pcct edge prev sorted edge list short offset call site location short weight edge weight data structure de nitions pcct node pcct edge types 
dynamic call tree containing recursive calls corresponding calling context tree lost context corresponding partial calling context tree full context 
edges previous pointers sorted list nodes 
edges represented pcct edge structure contains location call site source target nodes weight link edge source links sorted edge list 
pcct node pcct edge objects allocated single memory bu er reduce allocation overhead 
purge pro le data simply clear bu er 
periodically purge pro le bu er bu er small giving spacial locality nodes edges 
recursion worth noting recursion handled slightly di erently pcct compared cct 
recursive methods cct combines nodes separate contexts single node creating cycle backedge tree 
loses valuable context information recursive methods necessary order bound depth cct presence recursion 
see example 
pcct hand mechanisms bound size data structure example traversing certain number stack frames periodically purging data 
pcct program shown 


dynamic call tree deep sequence calls 
case rst sample left branch second sample right branch long string correctly attached calling context 
imprecision due limited number stack frames visited backward pass construction algorithm limits number stack frames visit sample 
insure sampling pro ler complete quickly presence deep stacks 
means deep sequence calls occurs samples algorithm may able identify place new pro le data point 
case pro le point attached original tree shown 

results section presents experimental results showing accuracy eciency pro ling system 
implemented pro ler various platforms supported ibm developer kit java tm technology edition industry leading java virtual machine justin time compiler 
current version pro ler written portable code pro ler code base shared di erent platforms 
benchmarking methodology due variability benchmarking especially case timer pro ler times may vary ran test multiple times establish con dence intervals 
distribution approximately normal number samples small student distribution calculation establish con dence intervals 
ran warmup run repeated tests con dence interval converged run time value 
tests collect pro led data attempt simulate pro le data dynamic compiler 
dynamic compiler operates collecting pro le data threshold reached time performs recompilations old pro le data 
modeled behavior pro le data set seconds 
worth noting cct construction algorithm pay attention stack depth searching stack edge cct 
measured specjvm intel benchmarks 
name processor memory operating system pentium iii mhz mb windows nt sp dual pentium iii mhz mb windows nt sp pentium mhz mb windows sp dual powerpc mhz mb aix dual power mhz mb aix benchmark machine descriptions include information precision sample pro ling 
pro ler accurately measure correct program pro le introducing instrumentation code disrupts program pro le 
measured accuracy measurements sampling pro ler running benchmark multiple times evaluating correlation successive runs 
assumed successive benchmark runs identical program pro les 
measured correlation sets correlation coecients covariances divided product standard deviations 
numbers range 
correlation means identical distributed means correlation means opposite correlation 
measured correlation second pro le data set independently benchmark length ect correlation coecient 
precision numbers geometric means correlation coecients 
benchmark machines total di erent benchmark machines 
see 
systems running internal build ibm developer kit java tm technology edition version java os thread mapping 
benchmark applications industry standard benchmarks test performance sampling pro ler 
spec set specjvm benchmarks run noninteractive mode default large input size 
cm set ca benchmarks version 
pbob portable bob version multithreaded business transaction benchmark java 
ran auto mode mb heap 
note cm single threaded spec contains threads pbob contains extensive multithreading 
timer interrupt mechanism number di erent mechanisms obtaining periodic timer interrupts ranging process level interrupts processor hardware performance counters 
evaluating simple busy loop call operating system sleep function acceptable precision minimal overhead 
results busy wait timer 
hot method counters evaluated performance sampling pro ler infrastructure collecting context insensitive pro le information implementing hot method count pro ler 
see code 
operation pro ler straightforward simply takes program counter threads nds method contains address increments counter associated method 
counters kept sorted linked list quickly extract hottest methods 
thought equivalent pcct construction algorithm maximum depth zero single node method 
void update hm void pc int method lookup pc time update pos sorted node list code update hot method counters 
performance pro ler di erent machines benchmarks sampling frequencies 
machine benchmark frequency combination measured increase run time enabling pro ler 
measured precision pro le measuring correlation sets method hits successive benchmark runs 
see fastest level sampling ms overhead typically windows machines unix machines 
cm special case see 
shown correlation scores sampling signi cantly slower losing accuracy 
sampling ms obtain accurate results 
general multiprocessor machines slightly overhead worse precision single processor machines especially complex multithreaded benchmarks pbob 
cm benchmark shows dramatic slowdown high sample frequencies 
set small microbenchmarks code pentium cache 
activating pro ler causes memory touched microbenchmark code cast memory increasing stalls due instruction cache misses 
pentium iii larger cache exhibit behavior 
note case pathological worst case pro ler code rare outside microbenchmarks 
note instrumentation pro ler larger performance degradation microbenchmarks overhead instrumentation code iteration tight loop instruction cache misses occur iteration sample sampling pro ler 
machine benchmark ms ms ms overhead precision overhead precision overhead precision spec cm pbob spec cm pbob spec cm pbob spec cm pbob spec cm pbob performance hot method counting sampling pro ler various machines benchmarks pro le frequencies 
overhead benchmark performance versus running pro ling 
precision correlation sets method hits corresponding second segments di erent benchmark runs value means exact correlation 
pcct performance pcct 
slightly optimized version construction algorithm 
method bu er size 
see results 
measured precision similar technique hot methods algorithm case data set combination set node counts edge counts 
nodes edges pccts considered equivalent correlation purposes contexts textual identical paths node edge root nodes method names order 
see results pcct slightly expensive build simply keeping track hot methods costs reasonable applications 
furthermore inclusion context information precision stays high level 
accuracy pro le benchmark dependent 
may bene cial controller dynamically adjust pro le period depending application pro le 

portable ecient sampling online measurement system implemented cross platform industry leading java just time compiler 
online measurement system provide real time pro le direction feedback dynamic compiler 
new sample pro ling technique able correctly identify calling context walking entire stack able distinguish frequently executed longrunning methods 
new data structure pcct ecient storage context sensitive pro le information 
experimental results extremely encouraging 
despite fact current implementation written portable wide variety machines able attain full context pro ling minimal performance cost slowdown applications nearly measurable levels 
surprisingly pro le data extremely accurate 
observed typical correlations separate pro le segments 
results show accurate context sensitive pro le data obtained cheaply ectively highly optimized production level system 
opens door wide variety new exciting uses dynamic pro le data areas compilation strategies dynamic optimizations 
ideas online measurement pcct came discussions peter sweeney 
acknowledge people worked ibm java virtual machine just time compiler providing structure online measurement system 
ammons bell larus 
exploiting hardware performance counters ow context sensitive pro ling 
proceedings acm sigplan conference programming language design implementation pages 
arnold 
real time call stack sampling 
presentation ibm watson research center june 
arnold fink sarkar sweeney 
comparative study static dynamic heuristics inlining 
dynamo workshop held conjunction popl th acm sigplan sigact symposium principles programming languages 
barton whaley 
real time performance visualizer java 
dr dobb journal software tools mar 
machine benchmark ms ms ms overhead precision overhead precision overhead precision spec cm pbob spec cm pbob spec cm pbob spec cm pbob spec cm pbob performance partial calling context tree various machines benchmarks pro le frequencies 
bentley 
software pride pro 
unix review oct 
business object benchmark java 
www ibm com developer performance bob pdf 

spec jvm benchmarks 
www spec org osg jvm 
dean hicks waldspurger weihl 
pro hardware support instruction level pro ling order processors 
proceedings th annual ieee acm international symposium microarchitecture micro pages 
graham kessler mckusick 
gprof call graph execution pro ler 
acm sigplan notices june 
mock philipose chambers eggers 
expressive annotation directed dynamic compiler technical report tr university washington mar 
hall goldberg 
call path pro ling monotonic program resources unix 
proceedings summer usenix conference pages 
international business machines 
ibm developer kit java tm technology edition 
www ibm com java jdk index html 
jerding stasko ball 
visualizing interactions program executions 
proceedings th international conference software engineering icse pages may 
liang viswanathan 
comprehensive pro ling support java virtual machine 
proceedings fifth usenix conference object oriented technologies systems pages may 
poletto engler kaashoek 
tcc system fast exible high level dynamic code generation 
proceedings acm sigplan conference programming language design implementation pldi pages 
ponder fateman 
inaccuracies program pro 
software practice experience may 
software 
ca benchmark 
www com cm 
continuous pro ling cycles gone 
acm transactions computer systems nov 
design implementation evaluation optimizations just time compiler 
proceedings acm sigplan java grande conference pages june 
jalape dynamic optimizing compiler java 
proceedings acm sigplan java grande conference june 
overview ibm java just time compiler 
ibm systems journal java performance issue 
llc 
report 
www com report html 
white 
instruction sampling instrumentation 
patent assigned ibm sept 
whaley 
dynamic optimization automatic runtime specialization 
master thesis massachusetts institute technology may 
