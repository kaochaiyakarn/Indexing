software tools technology transfer manuscript 
inserted editor program model checking new trend klaus havelund willem visser kestrel technology nasa ames research center moffett field ca usa mail 
arc nasa 
gov riacs nasa ames research center moffett field ca usa mail 
arc nasa 
gov date receipt acceptance inserted editor 
introduces special section journal containing selection papers th international spin workshop stanford august september 
workshop named spin model checking software verification emphasis model checking programs 
outlines motivation stressing software verification design model verification presenting done automated software engineering group nasa ames research center years 
includes software model checking testing technologies static analysis 
special section contains selection papers papers invited talks tutorials th international spin workshop arranged stanford university california usa august september 
original proceedings published lecture notes computer science volume springer titled spin model checking software verification 
model checking technique exploring possible execution sequences system interacting concurrent components 
systems may interact unexpected ways due unpredictable speeds various components extremely difficult test traditional testing techniques 
ways components interact usually leads large search space model checkers typically incorporate various techniques complexity 
spin model checker gerard holzmann received acm software system award large user community spin workshop forum community generally researchers interest automata explicit state model checking technologies analysis verification asynchronous concurrent distributed systems 
spin workshop held october montreal 
subsequent workshops held new brunswick august enschede april paris november trento july toulouse september 
traditionally spin workshops papers extensions uses spin 
experiment spin broadened slightly wider focus previous workshops papers software verification encouraged reflected name workshop spin model checking software verification 
shall try explain background emphasizing software verification 
outlining sections research taken place verification research group nasa ames research center years start thoughts 
verification group part automated software engineering ase group purpose develop software technology supporting software development nasa 
selected papers introduced related special subsections presentation 
software verification mean model checking source code corresponding object code compiled 
contrast analysis designs models software usually 
suggest focus attention real beast complexity 
view time writing caught popular research topic time leading workshop subject investigated research groups including 
domain time fact klaus havelund willem visser program model checking new trend known started 
spin inter face model check programs tools exist elaborated sections 
targeting source code may appear just worsening problem state space explosion usually associated model checking believe benefits approach shall outline 
note suggest design model verification uninteresting far 
experience experiments nasa danish au dio video lead folklore programmers write code writing detailed design 
concluded formal methods adopted nasa shorter time frame provide technology analyze real programs 
argue programmers urged write formalized designs analyzed 
point view may order design contain information useful formal analysis design may approach final system complexity case programmers avoid extra just write code directly 
fact may reason software developers create detailed designs engineers disciplines 
distance example design bridge bridge enormous design motivated 
case code generated design design code left code analysis anyway 
mainly graphical design language uml raises issue program verification uml designs contain code fragments evolve fully fledged programs 
new trend brings new challenges focus dealing object oriented dynamic memory allocation garbage collection program libraries increased state space explore 
problems require new approaches challenging deal really big state spaces 
techniques deal include example static analysis abstraction guided search intelligent testing techniques complete state space exploration model checking hand partial search simulation 
believe interesting research direction formal methods community reasons 
tools handle real programs user community increase dramatically 
second programming languages offer quite convenient notations expressing solutions problems compared modelling languages 
third trying handle real programs issue pressing spawn new research develop scalable solutions help design verification 
fourth researchers different groups develop model checkers programming language able exchange examples compare technologies easily 
sections proceed follows 
section describe case study spin applied analysis space craft controller successfully identifying errors 
previous case studies lead development java pathfinder system translator java promela language spin described section 
system allows model check programs written non trivial subset java 
section describes case study spin applied analyze real time operating system 
java pathfinder limited sense handle java libraries 
ing libraries give large promela models writing stubs require enormous amount 
decided model check java byte code java vir tual machine 
effort described section 
sec tion identifies technologies regarded essential model checking software 
includes topics abstraction search heuristics 
research topics runtime verification described section scalability achieved just examining single execution traces 
lastly final thoughts section 
remote agent example description remote agent verification case study performed newly created automated software engineering group nasa ames application spin model checker analyze part remote agent space craft controller 
remote agent software sys tem artificial intelligence techniques planning scheduling 
meant execute board space craft purpose take part operations normally carried ground operation space craft relieving ground personal micro managing space craft focus higher level goal management 
remote agent tested board deep space space craft may 
space craft launched october 
demonstration complete take space craft artificial intelligence software system nasa history 
remote agent consists essentially modules planner executive diagnosis module 
standard operation space craft system may proceed follows goal created ground personal example move comet take picture linked space craft 
planner board goal generate plan set sophisticated search algorithms klaus havelund willem visser program model checking new trend static predefined model possible transitions relative current state 
result plan specifying sequence tasks relevant component board spacecraft performed succession order achieve goal 
tasks different components may run parallel certain time constraints generated part plan 
plan sent executive executes plan operating space craft 
diagnosis module constantly monitors behavior craft compares observed behavior expected signaling executive worst case planner goes wrong proper action taken repair situation 
executive selected verification case study particular language named esl executive support language implemented extension multi threaded common lisp supporting execution tasks 
esl essentially api multi task programming similar posix threads extra domain specific functionality 
cause executing thread execute condition new events case evaluated true decide go sleep 
new event oc condition actual call goto sleep thread new event just go sleep 
programmer system impressed results documented 
interest ing remote agent activated may anomaly occurred thrusting turn requested 
experiment immediately terminated ground put stand mode hours reason error detected 
turned missing critical section piece code similar different part system analyzed spin 
thread block missing event system eventually deadlock 
demonstrated nasa model checking successfully find errors damage mission 
lessons learned model checking esl module consisted approximately lines code 
initially choice various possible verification tools mainly theorem provers model checkers 
quickly decided theorem proving time consuming experiment limited couple months duration goal find errors prove complete correctness 
decided spin programming language syntax allowed dynamic process creation features system 
lines lisp code extracted approximately lines promela code representing abstraction original system 
abstraction informal reasoning focusing attention lock table threads access ing 
asking engineers properties lated spin linear temporal logic ltl ver ified model 
properties turned satisfied model total classical concurrency errors revealed counterpart original code confirmed programmer 
classical concurrency errors sense occur due totally unexpected interleavings tasks interleavings detected traditional testing 
example violations caused missing critical section piece code form new events goto sleep experiment regarded successful involved parties 
errors hard find normal testing demonstrated major design flaw system 
furthermore errors reintroduced sibling module causing deadlock flight put space craft stand mode hours 
observing verification process re sult encouraging 
twelve man weeks researchers weeks spent creating line promela model lines lisp code 
lisp code undocumented layers macros difficult read 
just understanding code order proper translation definitely problems 
second problem define mapping powerful lisp language powerful promela language 
third problem decide parts translate parts translation toone abstraction 
clear problems understanding translation hardest abstraction problem strangely problem 
gave hope translation automated verification performed programmer kind semi automated abstraction support tool experiment potentially done single day 
important source experience supporting construction software model checker ap plication uppaal real time model checker analyze audio video systems developed danish audio video bang 
klaus havelund willem visser program model checking new trend verification effort successful occasion year old known unexplained bug explained 
case remote agent study time spent manually creating model program case lines assembler code 
result experiences decided create translator programming language promela described section 
idea developing java model checker fact conceived uppaal 
java pathfinder rationale outlined previous section series experiments applying existing model checkers modelling analysis software systems lead observation extremely useful model checkers analyze programs written traditional programming languages 
decided develop model checker chosen programming language choice fell java 
objective reasons choosing java 
viewed important chosen language object oriented current trend programming language design 
second language popular order gain broader user community 
criteria ruled object oriented lisp popular 
regarded complicated formal analysis due rich syntax capabilities operating pointers java obvious choice reasons 
nasa currently operates cases 
lisp remote agent experiment abandoned missions 
gave burden arguing going java 
response java prototyping ideas potentially java language 
turns experiments currently undertaken nasa evaluate java possible replacement 
occurrence real time java may important role play decision 
development model checker java take number avenues 
write model checker scratch java write translator java modelling language existing model checker 
spin model checker early regarded target translation example write new model checker programming language 
promela language high resemblance programming language 
salient features promela capability dynamic process creation 
early imagined model dynamic thread creation existing java 
decided write translator java promela modelling language spin potentially require writing model checker scratch 
project named java pathfinder jpf named java pathfinder jpf mars pathfinder rover explored mars 
goal produce prototype relatively fast order evaluate potential model checking real programs 
time source source code translation considered 
java source code compiled byte code compiler alternative approach translate byte code promela 
approach hardly considered time possibly reflecting belief byte code verification inefficient detailed interleavings single byte code instructions 
turned described section concluded lessons learned jpf project byte code verification turned viable solution 
design implementation jpf translates java program promela model 
java program contain assertions calls assert method translated calls promela assert statement 
resulting promela model checked assertion violations deadlocks 
possibility course check general ltl formulae resulting promela model requires minimal knowledge generated promela code 
error traces produced spin visualized spin message sequence charts assuming special print statements inserted code 
jpf apply analysis reduce state space generated model 
java program finite tractable state space 
translator developed lisp comprises lines code 
existing parser front written moscow ml peter ses royal veterinary agricultural university denmark ported standard ml version written olivier brunet gordon university california berkeley usa 
parser handles java early version java 
result translator translates subset java 
significant subset java supported jpf 
includes class definitions class variables fields methods simple data types integers booleans object arrays types class inheritance dynamic object creation threads synchronization primitives synchronized statements wait notify methods exceptions thread interrupts klaus havelund willem visser program model checking new trend standard programming language constructs assignment statements conditional statements loops 
features translated packages parser read package overloading method overriding recursion method calls translated inlining strings floating point numbers thread operations suspend resume control constructs continue statement 
furthermore arrays objects java modelled promela arrays obtain efficient verification 
importantly translator translate pre defined class library including example numerous container classes 
spite omissions jpf time translated java known similar tool 
key design issue translate dynamic object creation 
dynamic object creation handled class define array fixed size entry corresponds data area class 
example class variables array records containing variables generated 
size array sets limit objects class generated re defined user default value satisfactory 
index variable points free object 
object pair consisting name class index variable pointing corresponding array 
key issue translation dynamic thread creation various thread synchronization constructs 
threads naturally mapped promela processes 
key synchronization constructs synchronized methods synchronized statement wait notify handled introducing extra variables data area object array corresponding class 
example locking object modelled introducing lock variable default contains null assigned thread id thread locking object 
thread access object case variable differs null 
similarly promela zero capacity synchronous channel vari able introduced model wait notify operations waiting corresponds executing operation channel notification corresponds executing 
major feature translator handle exceptions construct 
exceptions translated construct promela special variable exn introduced thread object holding default null value 
exception object java thrown stor ing exception object variable triggers surrounding constructs form exn null 
gerard holzmann introduced special java option spin interpret inside order useful translation 
lessons learned jpf considered successful tool achieving attention various research groups 
tool applied game server consisting lines java code classes 
example big non trivial written formal verification mind 
suspicion deadlock system confirmed jpf 
tool applied analyze remote agent deadlocked space described 
case space craft engineers jpl los angeles informed deadlock occurred challenged find error model checking 
find error discovering code review seen described section 
jpf confirm error 
clearly felt smaller java programs lines code handled kind technology 
mean tech nology suited unit testing testing larger systems abstraction application tool 
tool drawbacks concerning applicability 
described earlier considerable subset java translated translated particular pre defined java library 
regarded impractical translate library jpf sources 
program modified order fit formedness criteria translator library java programs 
translation omissions recursion hard capture considering existing translation framework 
general perception closer got cover java harder extend translator 
turned working byte code level solve problems costing big loss efficiency 
deos case study honeywell technology center approached ase group request investigate techniques able uncover errors testing suited catch 
generation avionics plat forms shift federated system architectures integrated modular avionics ima soft ware runs single computer operating system ensuring time space partitioning different processes 
certification critical flight software faa requires software testing achieves coverage structural coverage measure called evidently complexity program purely mea terms lines code consider amount interleaving possible threads klaus havelund willem visser program model checking new trend modified condition decision coverage mc dc 
honeywell concerned structural coverage able ensure behavioral properties time partitioning satisfied 
particular developed real time operating system called deos error time partitioning uncovered testing 
experiment ase group undertook challenge finding error model checker knowing check 
kick meeting honeywell visited ase group discussed basic functionality deos subsequently produced slice contained code required show error 
code analyzed lines code full deos lines code 
didn model checker take input forced translate code suitable model checker input notation 
remote agent decided methodical mapping code model checker input avoid understanding program 
chose spin model checker promela language closest model checker input real programming language 
translation scheme java pathfinder approach dealing object oriented programs see section 
error man months divided man month translating code promela man months finding error 
remote agent case took man months translate code man weeks analysis 
difference easily explained differences systems system nearing design cycle written certified tested thoroughly contained subtle error deos middle development cycle written semi research environment tested developers contained number errors remote agent 
analysis deos system received honeywell subsequently deos system focus number research efforts :10.1.1.26.3201
honeywell proceeded creating model checking team analyze deos enhancements applications run top deos 
hon continuing extend deos promela model support verification complex versions deos 
lessons learned research perspective deos validated hypothesis real programs analyzed directly deos showed prob lems model checking programs directly shifts burden translation code model checker input analysis code 
typically translation code model checker involves ad hoc abstraction slicing code model checking efficient 
translation done means clever encoding previously done human translator needs done clever tools minimal human input 
creating environment program execute model checking challenging model checkers analyze closed systems system analyzed supplied environment drive 
analogous creating test driver selecting test cases support testing 
creating environment deos show error occurring took time deos model checking man months 
related special section traditionally spin workshop strong focus spin real world case studies similar deos case study described 
keeping tradition brinksma entitled verification optimization plc con trol schedule describes spin uppaal analysis programmable logic con system 
contribution novel firstly plc controller real time system spin doesn support real time directly describes comparison study uppaal support real time secondly correct ness properties controller considered optimization issues controller 
contributions variable time advance handling real time spin adopted approach analysis deos 
java pathfinder rationale pointed section java pathfinder jpf model checker highly successful num ber drawbacks limited effectiveness 
essen tially main reason translation approach adopted spin powerful model checker promela language expressive mapping java promela straight forward 
java pathfinder henceforth jpf developed address shortcomings jpf see section klaus havelund willem visser program model checking new trend 
handle language features java 
handle java libraries 
allow flexible approaches model checking java programs major design decision jpf base custom java virtual machine jvm execute java bytecodes 
addressed issues java model checked java libraries 
addressed third issue designing jpf modular fashion order allow different search strategies easily integrated model checker 
number different research groups worked java model checkers translation approach jpf 
date jpf model checker handle language features java 
model checkers address real programming lan guages dspin extension spin handle dynamic memory creation functions new version spin handle subset slam model checker checks reachability prop erties sequential programs 
design implementation jpf written java development custom jvm quite easy exploit fact doing java java allowing underlying jvm handle implementation tricky bytecodes floating point division 
believe wrote jpf java contributed fact prototype system similar functionality jpf completed man months 
jpf explicit state model checker means enumerates reachable system state ini tial state order redo terminate required store reached state 
analyzing java program state large require memory store reducing size systems handled model checking 
fundamental problem solved jpf 
considered problem hard developed called state model checkers don store states partial state space search 
jpf problem solved novel state compression tech niques reduce memory requirements model checker order magnitude :10.1.1.20.6719
novel feature jpf symmetry reduction techniques allow states modulo object stored memory considered equal :10.1.1.20.6719
object oriented programs typically objects symmetry reduction allows order magnitude states analyzed typical program 
jpf uses bandera toolset specifying properties analyzed display exists certain forms abstractions slicing 
bandera supports specification predicates comments check linear temporal logic ltl behavioral proper ties pre postconditions methods 
handle ltl properties jpf front translator ltl automata highly opti mized produce succinct automata 
jpf model checking algorithm checks program behaviors comply behaviors described automata highly optimized algorithm 
jpf supports distributed memory model checking memory required model checking distributed number workstations :10.1.1.20.6719
technique requires additional time overhead due sending messages network allows examples analyzed previously fit memory workstation 
crucial factor success distributed model checking fashion partition memory different workstations investigated number par schemes dynamic partitioning partitions evolve model checking statically fixed initialization worked best :10.1.1.20.6719
lessons learned jpf successfully number projects notably deos error section covered java translation original code 
lines code mars rover successfully analyzed 
jpf system available user community web download february organizations registered tool 
importantly jpf desired effect vehicle research analyzing programs model checking close collaborations bandera group kansas state university groups cmu stony brook minnesota freiburg liverpool univer 
development jpf culmination years research application model checking software ase group 
ways stepping stone worrying encode program model checking notation think behavioral properties check parts program model checking tractable improve model checking specific classes programs 
issues discussed section 
klaus havelund willem visser program model checking new trend related papers special section mentioned section jpf supports ltl model checking bandera toolset describe properties checked java programs 
special section language describing properties bandera specification language bsl outlined detail corbett dwyer hatcliff robby entitled expressing checkable properties dynamic systems bandera specification language 
bsl language fully integrated jpf 
important component explicit state model checking check temporal properties efficiently 
jpf spin uses called automata theoretical approach ltl linear time temporal logic formula translated automaton model checking commences 
translation ltl automata focus research number tools doing translation exist including jpf 
doing translation efficiently non trivial error prone 
second heikki entitled testing ltl formula translation automata deals somewhat overlooked area correctness ltl translators 
soon relying technique test ltl translator jpf 
technologies software model checking model checking impact quality programs produced amount human effort operating tools kept minimum 
jpf reduced amount effort considerably translation phase longer required 
automated translation preserves details software implementation model checking difficult 
reason manual translation typically involves significant optimization abstraction system 
truly reduce amount manual effort place model checking development loop need tools support typical optimizations abstractions previously done translation 
general goal reduce statespace system model checker needs analyze providing responsiveness 
abstraction abstraction techniques reduce number states system remove behav iors original system approximations introduce new behaviors original approximation 
approximations approximation behaviors far common form manual abstraction model check ing 
approximation doesn preserve correctness system satisfies behavioral property doesn follow original system 
approximation finding errors error system implies error original :10.1.1.26.3201
jpf built view cover spectrum analysis techniques testing execution program analyzed model checking paths analyzed jpf supports number techniques doing approximations model checking highlight 
race guided race analysis done program race violation model checker focuses threads involved see race violation lead 
technique find error java translation remote agent error occurred flight 
heuristic search techniques ai apply general program specific heuristics guide search errors 
example find deadlocks heuristic tries maximize blocked threads heuristic remote agent deadlock seconds exhaustive mode model checker fail due memory limitations 
developed heuristic finding problems due thread interleaving lastly trying increase structural testing coverage approximations technique represents group states concrete original program small finite set states program lead huge state space reductions 
form abstraction inspired interpretation static program analysis data domain type variable replaced type concrete operations interpreted 
note type abstraction causes behaviors program original program 
fact behaviors possible program means behavioral property expressed ltl holds holds concrete ltl property fails fail concrete fail due behavior concrete 
popular form approximations called predicate abstraction replaces predicate program boolean variable updates variables klaus havelund willem visser program model checking new trend predicate changed updates boolean variable 
jpf supports predicate bandera supports type abstraction :10.1.1.26.3201
order handle approximations program behaviors extended java special method calls signals nondeterministic choice random return values inclusive return true false model checker en counters methods nondeterministically try possible results call 
predicate selection problem encounters application approximations practice select parts program typically requires human intervention 
bandera type abstraction done automatically doing backward dependency analysis program points directly influence temporal property checked determine set variables influence program behavior respect property checked variables candidates abstraction 
predicate abstraction applied automatically selecting predicates program property practice leads spurious counter examples behav iors original lead property violations 
program creation predicate type abstraction applied model checking 
practice calculations required determine state program slow done model checking program creation model checking jpf bandera 
order calculate operation abstraction mapping type predicate concrete operation requires automated theorem prover set decision procedures domain 
predicate abstraction stanford validity checker svc calculate statements type abstraction bandera uses pvs 
abstraction calculations done model checking object oriented programs particularly challenging predicate abstraction predicates may relate variables different classes exe cution number instantiations 
predicate abstraction typically done static setting object oriented programs predicates created dynamically execution new objects instantiated 
jpf supports mechanism allow predicates created fly model checking predicates specified different classes 
result interpretation biggest drawback approximation abstractions errors spurious original 
aggressive abstraction bigger statespace reduction achieves spurious error occur 
known fact users systems spurious errors reported complain spurious errors reported errors supported data microsoft static analysis tool prefix discovering run time errors 
program model checker abstraction practical vitally important spurious errors eliminated 
jpf supports novel technique achieving goal pass abstraction searches parts program statespace knows contains behaviors part concrete program 
view doing fly approximation state space generated doing approximation original program 
technique remarkably successful remote agent deos examples bugs abstraction search technique 
abstraction refinement abstraction coarse certain situations spurious error removed abstraction refined 
jpf supports practical approach determining refinement necessary path reported jpf counter example program exe concrete path diverges doesn diverge course path spurious predicates point candi dates refine abstraction 
refinement proceeds adding predicates predicate abstraction repeating program creation 
ap proach demonstrated invest tool 
slicing slicing technique yields precise abstraction approximation program behavior respect property analyzed 
sliced program yields smaller state space original un sliced program slicing allows model checker handle larger programs 
important aspects selecting statements eliminated 
statements appear dependence graphs statements containing variables terms property checked 
second sliced program executable jpf explicit state model checker 
slicing jpf provided slicing capability bandera toolset 
bandera slicing performed types dependencies intra thread dependencies usually sequential programs data control divergence dependencies types dependencies interference synchronization ready dependencies cap ture concurrency issues 
klaus havelund willem visser program model checking new trend partial order reduction goal partial order reduction exploit commutativity concurrent transitions reduce state space needs explored model checker 
technique described relies concept independent transitions 
transitions independent execution disable vice versa enabledness condition result state regardless execution der commutativity condition 
jpf relies stronger concept safe transitions 
essence tran sition safe independent transition thread 
partial order reduction scheme selects safe transitions exist exploration guaranteed yield correct results 
static analysis point view identifying safe statements reduced problem identifying objects escape thread created 
identify objects identify objects shared different threads 
unsafe statements access shared objects correspond entering monitor lava ones easily identifiable syntactically safe statement analysis essentially aliasing analysis 
phase build program call graphs associated thread 
build graphs identify escaping objects passed arguments class constructor thread 
easy realize escaping ob jects aliased escaping objects identified phase 
second phase consists aliasing analysis 
note compute aliases created considering interleavings quite costly 
escaping objects identified computing intra thread aliases 
means complexity analysis similar complexity aliasing analysis sequential programs 

environment generation explicit state model checker jpf requires closed system analyze system environment needs operate provided model checking 
environment available needs created testing analogous problem exists test harness created subtle important differences exist 
model checking important relevant environment behavior testing subset possible test cases tested 
knowing environment actions relevant possible domain knowledge possible domain experts involved model checking case research environment 
common approach favored model checking systems known environment create aggressive environment perform legal action possible time referred universal environment 
property holds system composed aggressive environment system correct environment 
similar case approximation done abstraction 
unfortunately problem approximation abstraction spurious errors may result universal environment allows behaviors system designed 
novel approach remove spurious behaviors filtering unwanted behaviors environment ltl properties augmented filter properties 
technique successfully create deos system environment days months creating environment manually 

related papers special section papers special section related jpf state space reduction techniques de scribed section 
scott stoller entitled modelchecking multi threaded distributed java programs exploits specific thread synchronization facilities java optimize model checking improving partial order reductions see section 
illustrated context doing state model checking see section implemented jpf 
omnipresent state explosion problem fruitful line research spin com model checking field general 
popular technique combating state explosion problem highlighted section exploit symmetry reductions system analyzed 
dams entitled symmetric spin introduces symmetry reduction package spin 
significance lies theoretical contributions fact research ideas implemented spin supported empirical data 
mentioned section jpf supports symmetry reductions objects instantiated lava program handles symmetries process structure 
java rationale java pathfinder attempts explore entire state space lava program storing states klaus havelund willem visser program model checking new trend explicitly naturally suffers classical state space explosion problem 
large applications may want apply complementary techniques closely related traditional testing 
testing characterized execute program different test cases observe execution comparing expected behavior 
believe area automated test case generation great potential think maturity years 
providing general application independent framework automated test case generation obvious 
engineers jpl addition expressed scepticism automation done suggesting requires engi sit think test case 
goal develop technology chance adopted space craft designers relatively short time horizon couple years 
interest turned observation part equation 
question information extracted program observing single execution trace 
intention develop technology applied automatically large full size applications minimal modification code 
spin workshop hosted invited talks com tools category temporal rover visual threads 
temporal rover monitors exe cution program checks behavior collection temporal logic formulae written temporal logic 
formulae written code comments translated formula checking code executed assertions 
visual threads performs various concurrency error analysis deadlock data race analysis 
particular implements eraser gorithm detecting data races :10.1.1.161.222
decided build tool lava aa combined functionality tools addition added new functionality 
lava analyzes explores single executions traces 
visual threads tightly coupled compaq alpha microprocessors addition properly lava programs 
goal port technology lava 
temporal rover required manual instrumentation code 
decided automated instrumentation desired focused providing capability 
temporal rover example state property set program variables 
insert property update variables manually 
automated instrumentation capability property checks inserted automatically updates 
inspired mac tool performs automated instrumentation 
design implementation kinds event analysis currently implemented 
logic monitoring consists runtime checking formal requirement specifications written high level logics users system 
logics currently imple mented maude high performance system sup porting rewriting logic membership equational logic 
naturally easily define new logics maude example temporal logics gether finite trace operational semantics 
currently supports built logics time past time linear temporal logic 
error pattern analysis consists analyzing execution trace various error detection algorithms identify error prone programming practices may potentially lead errors executions 
algorithms focusing concurrency errors implemented deadlocks data races eraser algorithm :10.1.1.161.222
important note deadlock data race potential need occur order potential detected algorithms 
useful practice 
example deadlock algorithm works building graph locks acquired execution building edge lock lock thread holds acquiring 
lock graph accumulates updates warning issued eventually cyclic 
instrumentation module performs script driven automated instrumentation program observed 
instrumented program run emit relevant events observer potentially running different computer case events transmitted socket 
lava byte code instrumentation performed powerful lava byte code engineering tool compaq 
possible easily read lava class files byte code files traverse syntax trees examining contents insert new code 
lessons learned time writing applied couple case studies nasa ames far promising results 
deadlocks data races example located 
deadlock data race analysis limited evidently kind errors 
technology powerful covers smaller fraction errors usually contained software 
temporal logic monitoring check broader class errors case error occur order detected 
runtime monitoring potentially combined model checking example described spin proceedings 
deadlock data race analysis klaus havelund willem visser program model checking new trend integrated java pathfinder tool way run tool simulation mode deadlock data race potentials detected scalable manner model checker started focus threads involved warnings 
major issue current case studies demonstrate difficult software engineers generate requirements software system satisfy english 
interesting formalizing properties provided informally main problem 
summary previous sections tried give flavor research automated software engineering group nasa ames led decision focus th spin workshop model checking software 
sections related different research activities de scribed roughly chronological order started 
concept workshop formulated late place early stages jpf section java section development 
projects supplementary gies model checking section ongoing 
number projects ase group general field software verification validation started spin workshop directly related workshop briefly mention verifier check run time errors space flight software errors mars pathfinder code code run biological experiments international space station 
commercially available tool uses static analysis techniques discover errors 
joint project university minnesota jpf test case generation 
context currently extending jpf capability symbolic execution 
emphasize regard program analysis complementary technique design analysis hopefully approaches eventually coexist unified framework 

ball podelski rajamani 
boolean cartesian abstractions model checking programs 
proceedings tools algorithms construction analysis systems lncs genova italy april 

barrett dill levitt 
validity checking combinations theories equality 
formal methods computer aided design volume lncs pages november 

bensalem sam owre 
vest tool verification invariants 
alan hu moshe vardi editors cav th international conference computer aided verification volume lncs pages 


modeling verification sc applications 
proceedings tacas tools algorithms construction analysis systems volume lecture notes computer science pages lisbon portugal april 
springer 

clarke peled 
model checking 
mit press 

manuel clavel francisco duran steven eker patrick lincoln narciso oliet jos meseguer jos quesada 
maude system 
narendran rusinowitch editors proceedings loth international conference rewriting techniques applications rta volume lecture notes computer science pages trento italy july 
springer verlag 
system description 
darren eric nicholas john penix willem visser 
model checking verification partitioning properties integrated modular 
proceedings digital avionics systems conference 

seth cohen 

compaq www 
compaq 
com ava oad trek 

james corbett matthew dwyer john hatcliff corina pasareanu robby shawn laubach zheng 
bandera extracting finite state models java source code 
proceedings nd international conference software engineering ireland june 
acm press 

cousot cousot 
interpretation frameworks 
journal logic computation august 

iosif 
deadlock detection tool concurrent java programs 
software practice experience july 

iosif 
dspin dynamic extension spin 
proceedings th spin workshop volume lncs 

doron 
temporal rover atg rover 
klaus havelund john willem visser editors spin model checking software verification volume lecture notes computer science pages 
springer 

dwyer hatcliff 
slicing software model construction 
olivier danvy editor proceedings cm workshop partial evaluation program manipulation pepm january 
brics notes series ns 

dwyer 
filter model checking partial systems 
proceedings sixth cm symposium foundations software engineering november 

dwyer 
model checking generic container implementations 
lncs 
klaus havelund willem visser program model checking new trend generic dagstuhl seminar 

matthew dwyer john hatcliff shawn laubach corina pasareanu robby willem visser hongjun zheng 
tool supported program abstraction finite state verification 
proceedings rd international conference software engineering appear toronto may 
acm press 

giannakopoulou klaus havelund 
automata verification temporal properties running programs 
proceedings international con ference automated software engineering ase pages 
institute electrical electronics engineers 
island california 


states transitions improving translation ltl formulae automata 
proceedings nd ifip wc international conference formal tech niques networked distributed systems forte lecture notes computer science houston texas 
springer 

godefroid 
model checking programming languages verisoft 
proceedings jth acm symposium principles programming languages pages paris january 

graf saidi 
construction state graphs pvs 
cav th international conference computer aided verification volume lncs 

alex willem visser 
model checking java programs structural heuristics 
proceedings international symposium software testing analysis issta 
acm press july 

jerry 
runtime checking multithreaded applications visual threads 
klaus havelund john willem visser editors spin model checking software verification volume lecture notes computer science pages 
springer 

hatcliff corbett dwyer sokolowski zheng 
formal study slicing multi threaded programs jvm concurrency primitives 
proc 
int 
symposium static analysis 

havelund larsen skou 
formal ver ification audio video power controller real time model checker uppaal 
th int 
amast workshop real time probabilistic systems number lecture notes computer science 
springerverlag may 
bamberg germany 

havelund skou larsen lund 
mal modeling analysis audio video protocol industrial case study uppaal 
proceedings th ieee real time systems symposium pages dec 
san francisco california usa 

klaus havelund 
runtime analysis guide model checking java programs 
klaus havelund john penix willem visser editors spin model checking software verification volume lecture notes computer science pages 
springer 

klaus havelund michael lowry park charles john penix willem visser john white 
formal analysis remote agent flight 
proceedings th nasa langley formal methods workshop june 

klaus havelund michael lowry john 
formal analysis space craft controller spin 
ieee transactions software engineering august 
earlier version occurred proceedings th spin workshop paris france 

klaus havelund thomas 
model checking java programs java pathfinder 
international journal software tools technology trans fer april 
special issue con taining selected submissions th spin workshop paris france 

klaus havelund os monitoring java programs java 
klaus havelund os editors proceedings interna tional workshop runtime verification rv vol ume electronic notes theoretical computer science pages paris france july 
elsevier science 

klaus havelund ros monitoring programs rewriting 
proceedings international con ference automated software engineering ase pages 
institute electrical electronics engineers 
island california 

klaus havelund ros synthesizing monitors safety properties 
tools algorithms construction analysis systems ta cas vol ume lecture notes computer science pages 
springer 
best award etaps 

klaus havelund jens 
applying model checking java verification 
proceedings th spin workshop 
connection fm toulouse 

heimdahl visser 
specification centered testing 
proceedings second international workshop automated program analysis testing verification toronto canada may 

gerard holzmann 
model checker spin 
ieee transactions software engineering may 
special issue formal methods software practice 

gerard holzmann margaret smith 
practical method verifying event driven software 
proceedings icse international conference software engineering los angeles california usa may 
ieee acm 

holzmann peled 
improvement formal verification 
proc 
forte berne switzerland october 

kim larsen paul pettersson wang yi 
uppaal nutshell 
int 
journal software tools tech nology transfer october 

lee kannan kim oleg mahesh viswanathan 
runtime assurance formal specifications 
proceedings international conference parallel distributed processing techniques applications 

willem visser 
addressing dynamic issues program model checking 
proc 
th international spin workshop volume lncs 
springer verlag may 
klaus havelund willem visser program model checking new trend 
owre rushby shankar 
pvs prototype verification system 
proceedings lth ternational conference automated deduction lncs 

penix visser larson 
verification time partitioning deos scheduler kernel 
proceedings nd international conference software engineering ireland june 
acm press 

amir pnueli 
temporal logic programs 
proceedings th ieee symposium foundations computer science pages 


www 
cora 

pasareanu 
deos kernel environment modeling ltl assumptions 
technical report nasa nasa ames july 

pasareanu dwyer visser 
finding feasible counter examples model checking abstracted java programs 
proceedings th international conference tools algorithms construction analysis systems volume lncs 

stefan savage michael burrows greg nelson patrik sobalvarro thomas anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems november 

microsoft spec check workshop 
research 

cora spe ck 

visser park 
predicate abstraction reduce object oriented programs model checking 
proceedings rd acm workshop formal methods software practice august 

visser 
efficient ctl model checking automata 
phd thesis manchester university june 

willem visser klaus havelund guillaume brat seung park 
model checking programs 
proc 
th ieee international conference automated software engineering grenoble france ber 
