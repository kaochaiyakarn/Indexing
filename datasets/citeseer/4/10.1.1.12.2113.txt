foundational typed assembly language karl crary carnegie mellon university design typed assembly language called talt supports heterogeneous tuples disjoint sums general account addressing modes 
talt implements von neumann model programs stored memory supports relative addressing 
type safety execution garbage collection shown machine checkable proofs 
talt formalized typed assembly language provide features 
categories subject descriptors programming languages language constructs features logics meanings programs specifying verifying reasoning programs 
general terms languages security verification keywords typed assembly language proof carrying code proliferation low cost computing hardware ubiquity internet created situation huge amount computing power idle principle accessible developers 
goal exploiting idle computational resources existed years seti home handful projects successfully profitable idle computational resources internet 
paradigm called grid computing elicited serious interest academics industry general means conducting low cost supercomputing 
material supported part nsf ccr ccr 
opinions findings recommendations publication authors reflect views agency 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january new orleans louisiana usa 
copyright acm despite increasing interest grid computing remaining obstacle growth understandable reluctance computer owners download execute software developers know trust may heard 
limited practical grid computing small number potential users able obtain trust thousands computer owners know 
concert project cmu seeking overcome obstacle developing system dissemination software 
concert framework machine owner installs steward program ensures safety downloaded software 
new grid application obtained execution parts concert framework determine takes place application expressed form certified code executable code accompanied certificate proving code safe 
steward verifies certificate valid permitting code executed 
form certified code prototype concert system typed assembly language tal implemented talx system developed primarily cornell :10.1.1.12.4086
talx specializes tal intel ia architecture enhances number constructs supported theoretical system 
certified code eliminates need trust developers grid applications remains need trust soundness steward 
talx production quality certified code systems java vm proof carrying code pcc similar need trust stems issues 
talx safety justified informally analogy tal rigorous proof 

safety tal talx analogy terms machine 
machine low level type system ways somewhat high level compared concrete architecture obscures important issues thereof 

safety proofs exist written form consequently checking veracity error prone done experts 

trust talx type checking software correctly implements type system 
certain extent need trust steward conditions serious obstacle 
machine owners routinely trust safety great variety applications popularly known architecture 
far formal basis doing 
certain amount trust required case participants personally inspect components system 
minimizing system trusted computing base goal 
grid computing desire minimize trust steward goes general considerations 
key issue extensibility 
aim enable establishment decentralized grid computing fabric available wide array participants 
purpose implausible imagine single type system suffice potential grid applications 
furthermore implausible undesirable single trusted agent check soundness proposed new type systems 
necessary basic steward safely extended new type systems untrusted sources 
natural way achieve foundational certified code entire safety argument safety policy expressed terms concrete architecture machine checkable form 
incarnation foundational pcc binary accompanied complete proof safety 
proposed foundational tal program safety argument broken parts portion self certified type system specification type system machine checkable proof satisfies established safety policy 
portion generally independent particular application 
second portion application typing derivation certified type system 
model grid application developer devise type system su cient certify applications 
steward encountered certified application referring unknown type system steward automatically download type system verify safety proof accept applications valid typing derivations type system 
model addresses issues demanding trust new type system 
issues clearly dealt complete machine checkable proofs 
packaging applications typing derivations opposed type annotations fourth issue addressed single proof checker check derivations type system new checker need employed 
aim implement example foundational typed assembly language intel ia architecture build flexible foundation variety type systems may built 
accordingly broken development system stages model hamid development featherweight tal stage develops general typed assembly language specific architecture 
general language operational semantics safety established proofs type preservation progress 
safety garbage collection established level section 
second stage shows operational semantics maps correctly concrete architecture 
general type system designed account issues pertain type system including nearly central issues second stage type free simulation argument 
topic stage ort 
second currently underway 
talt presents new typed assembly language called talt tal 
aims talt threefold talt intended provide su cient expressive power serve target language certifying compilers expressive high level languages particular standard ml popcorn safe dialect 
second talt operational semantics intended account greatest extent possible central issues execution actual hardware second stage foundational safety proof discussed simple albeit lengthy tedious simulation argument 
third talt intended fully formalized enjoy machine checkable type safety proof 
discussion overview talt accomplishes aims expressiveness order provide expressive power necessary compile practical high level programming languages talt follows talx adding support heterogeneous tuples tuples fields size recursive types disjoint sums arrays 
due space considerations discussion arrays omitted appears companion technical report 
talx talt supports constructs formalized type theory specialized code type checker 
talt provides expressive power original published talx exception tal initialization flags replaced slightly general mechanism section 
enhancements talx supported talt added di culty 
completeness operational semantics tal specified terms low level machine including explicit register file memory stack tal stack :10.1.1.12.4086
brings tal nearly low level possible committing details architecture 
tal machine model include program counter included stream input instructions served surrogate program counter 
branch instruction machine discard current stream instructions copy instructions branch address 
talt hand includes explicit program counter 
program counter part model address important issues concrete architecture possible principle write code just ahead program counter 
rarely permitted practice course programs fact stored memory essential part foundational safety proof explicitly address issue 
requisite argument di cult talt follows standard practice code read machine model include explicit program counter argument 
explicit program counter necessary account notion relative addressing particularly important ia control transfers including conditional jumps relative 
explicit program counter precisely fact instruction individually addressable allows true call instruction return address taken program counter 
system includes conservative garbage collector part trusted computing base 
garbage collector ectively part architecture 
accordingly need prove collector safe necessary show programs adhere invariants collector requires 
talt type system accounts invariants invariants prove type safety disrupted garbage collection section 
interest simplicity version talt provides representative arithmetic operations add subtract compare 
omit discussion floating point ia implementation floating point register stacks idiosyncratic 
foresee fundamental di culties extending talt direction 
talt follows stack tal viewing stack separate unbounded resource just designated area memory 
dramatically simplifies type system requires second stage foundational safety proof show talt stack mapped concrete stack :10.1.1.12.4086
principal issue doing stack overflow address section 
machine checkable proofs talt formalized lf mechanized twelf system :10.1.1.21.5854
accordance usual lf methodology talt typing judgements correspond lf types typing rules correspond lf constants talt typing derivations correspond lf terms 
validity typing derivation verified type checking 
central importance ort type safety meta theorems progress type preservation gc safety 
expressed twelf relational form logic programs 
support twelf provides totality checker ensures relations represent total functions valid meta proofs 
discussed detail section 
important note decidable checking typability aim talt 
tal talx talt type assignment curry style system values contain type annotations carry explicitly typed church style systems tal 
means checking typability talt programs requires type inference talt type system polymorphic means typability checking certainly undecidable 
consequently safety certificate talt program entire typing derivation talx collection type annotations reconstruct typing derivation 
largely just matter presentation talt typing derivation contains little information appear type annotations conjecture overhead remains eliminated necula rahul technique 
unit values junk values 
un addresses cond 
codes cc cf bit zf bit memories 
vn register files 
rn vn fl cc states untyped talt syntax organized follows section presenting basic talt language section extensions supporting disjoint sums relative addressing 
section give formalization gc safety 
section discusses pragmatics proofs 
concluding remarks follow section 
basic talt presentation basic talt language presenting untyped fragment parts structure values second machine model third discuss instruction set fourth give operational semantics 
type system 
section di erences talt tal benefit readers familiar readers unfamiliar tal may skip remarks 
adopt notational conventions stands size machine word measured bytes ia range nonnegative integers bit ranges ranges bytes integers modulo ranges words integers modulo 
usual consider alpha equivalent expressions identical 
section identifiers registers considered variables alpha vary variables appearing talt type constructor variables 
untyped talt values tal separated collection values syntactic classes called heap word values 
syntactic distinction determined fit register 
talt combine single syntactic class values may vary size types syntax determine may 
syntax type free talt appears 
values simply sequences zero unit values exactly byte size 
construct values unit values ensure byte including bytes middle atomic object may addressed easy compute size value 
note merely cosmetic change eliminate word values add unit values tal word values unit values tal included third class called small values 
truly values renamed operands called :10.1.1.12.4086
objects interest construct values 
convenient abuse notation write values form 
vn representing appending values 
forms value may consider atomic literal bytes junk values addresses bytes length instruction encodings metavariable ranges byte instruction encodings 
level abstraction appropriate specify possible values assume existence decoding function takes instruction encodings instructions discuss bit 
note need injective single instruction multiple encodings need surjective 
literals junk values byte size represented directly unit value constructs 
addresses usually instruction encodings size greater byte 
forms unit value represents bytes taken larger atomic values represents ith byte address represents ith byte instruction encoding appropriate range constructs considered junk values 
rarely need deal subcomponents addresses instructions purposes viewed value forms abbreviations def 
def 
write encoding bytes architecture ia bw 

bw machine model tal talt machine model contains memory register file replaces tal stream input instructions explicit program counter 
augment state collection condition codes indicating carry zero flags di cult add convenient consider part register file contained flag fl register 
talt register file fixed collection general purpose registers rn 
tal hand assumed infinite supply registers 
talt memory broken sections identified section identifiers 
section represents area memory known contiguous 
distinct sections appear unknown order memory possibly intervening gaps 
view talt memory mapping section identifiers values values simply sequences bytes 
byte memory addressed subject limitations garbage collector combining section identifier numeric set section produce address consider garbage collection section necessary distinguish heap collector manages remainder memory 
refer portions heap code segments 
anticipation development remarks 
view segment section resides intrinsic property section may determined ia stack pointer treated specially section 
registers rn operands im rco mco destinations conditions eq neq lt lte gt gte instructions add cmp jmp malloc mov sub code instructions identifier 
formalized predicates holds resides heap segment conversely 
heap segment traced collector read write code segment traced read 
newly allocated sections appear heap segment 
instruction set basic talt instruction set 
exception malloc implemented run time system architecture instructions familiar programmer ia 
note instructions intel style destination notation 
note load store instructions tal omitted replaced mov instruction appropriate addressing modes 
code sequences talt operational semantics arise type checking rules 
notation operands destinations novel 
operand im indicates immediate operand operand rco indicates operand contents register contents memory obtained operand mco providing address indicates fixed set address read indicates size operand read typically 
similarly indicates destination instruction register indicates destination size memory address indicated operand plus set order talt elegant general possible ort limit available operands operand instruction combinations supported ia architecture 
example real architecture permits arbitrary chaining indirection nesting memory operands talt sizes memory reads permitted 
elegant include variety unsupported possibilities note unsupported instructions simply range decoding function 
operational semantics operational semantics 
main judgement indicating machine state steps machine state provided add fl cc cc cmp fl cc cc fl fl jmp malloc fresh junk mov sub fl cc cc operand resolution im rco mco destination propagation condition satisfaction cc eq cc zf cc neq cc zf cc lt cc cf cc gte cc cf cc lte cc cf cc zf cc gt cc cf cc zf definitions 
un def def def def 
times operational semantics kinds types ti types size types type variable null value bytes tuples box pointers mbox mutable pointers code code values code pointers universal quant 
existential quant 
intersection type union type ns top nonsense type void bottom empty type recursive type types 
rn mem 
types 
contexts 
kn type syntax main auxiliary judgements discuss established auxiliary definition operational semantics entirely unsurprising 
resolution operands formalized judgement indicates machine state operand resolves value propagation computed results destinations formalized judgement indicates machine state destination assigned value resulting memory register file conditions conditional jump handled proposition cc true condition codes cc satisfy condition 
points notation merit comment 
note arithmetic equations semantics specify condition code result numeric result 
condition code results determined usual manner carry flag cf set operation generates carry borrow formally denormalized result lies outside allowable range zero flag zf set result zero 
map update written memories similarly register files 
map extension memories written fresh 
type system types talt appear 
base types type zero length value type byte literals 
important type constructor product space contains values consisting adjacent values having types appending values associative unit products associative left right unit equivalences realized collection subtyping rules 
def def int def nsw def ns type abbreviations note tal product space contain pointers tuples talt pointer explicit type constructor box 
factor necessary combine tal heap word values tuples pointers tuples di erent types need distinguished syntactic class tal 
di erent types provided pointers box type ordinary pointers mbox type mutable pointers type code pointers 
pointer type provides di erent privileges box covariant immutable mbox mutable invariant code pointers may jumped 
subtyping rule provided promoting mutable pointers covariant ones 
series instructions type code executable provided register file type 
function space contains executable code pointers box code pointer point code segment 
universal existential quantifiers intersection types union types recursive types standard system 
top type ns contains value size 
wider top types may defined exponents ns 
bottom type void empty 
useful abbreviations including word sized top nsw defined 
kinds talt types kind contains types sized kind ti contains types elements size example belongs belongs belongs ti tj various pointer types belong tw types may vacuously belong sized kind belongs void vacuously belongs ti inhabited type sized kind 
register file types give type register fl 
formed register file type register type kind tw register included width subtyping rules need included 
register value irrelevant may type nsw promotion nsw done depth subtyping 
heap types give type section 
static semantics collection judgements talt static semantics 
thirteen total judgements 
due space considerations complete set rules appears companion technical report 
judgements type formation rules unsurprising appendix 
judgements subtyping ordinary types register file types simply applies pointwise register type 

kn def 
kn ns code tn mbox tn box code tn 
vn 
tw 
rn vn fl cc 
rn im rco box tn tm mco tw mbox tn tm typing rules instructions judgement interpretation formed kind formed formed subtype subtype value type operand type propagation value having type destination results register file type code executable register file type inits mbox discussed section formed type formed type formed static judgements remaining judgements typing 
typing values operands destinations typing code second auxiliary judgement typing tuple initialization code final judgements typing machine states top level components 
pointers may appear type pointer depends type value points typing judgement state typing includes memory type part context 
operands destinations code refer registers typing judgements include register file type context 
talt typing rules appear figures discussed 
machine states typing rules machine states essentially tal 
state formed exists memory type register file type respect memory register file pro state typing judgement omits memory type full machine state closed 
full memory closed memory typing judgement includes memory type part context occasionally necessary type check memory weakened assumptions 
gram counter may consistently typed 
type check program counter current code looked memory program counter address type checked 
memory series bytes converted code sequence function lifts instruction decode function single instructions series instructions 
aspects change developments 
add second state typing rule typing intermediate states tuple initialization section 
second decode function generalized account relative addressing section 
values value typing rules self explanatory rules pointers merit discussion 
pointer set may type box section points type elements size skipped set 
pointers heap segment may stronger type mbox provided subtype supertype ensures written back heap object object type heap type unchanged 
value typing rules tell far entire story 
flexibility talt type system provided subtyping rules 
subtyping provides facility existential union recursive types elimination facility universal intersection recursive types associativity identity rules products distributivity rules intersection union types void 
subtyping rules listed appendix interest brevity discuss individual rules arise 
operands destinations operand may drawn register operand typing judgement includes register file type context 
similarly destination may register propagation value destination change register file type destination typing judgement includes register file types 
typing rules memory operands destinations novel 
associativity identity subtyping rules products casts pointer type form box operand type types left right residual values 
sizes checked kinds kind tn match set kind tm match operand size 
note register destinations memory destinations forbidden change data type allowing changes unsound due possibility aliasing 
instructions type system moved rules operands destinations typing rules instructions largely expected 
final rules merit comment 
subtyping rule code states type checks assumptions type checks stronger assumptions 
second rule elimination rule existential types 
register contains value existential type allows value unpacked place 
mbox invariant respect symmetric subtyping mbox mbox associativity identity products applied beneath mbox 
int int int add int int cmp jmp mov int int int sub instruction typing rules allocation tal instruction unpack obtained combining mov instruction rule 
allocation initialization complicated talt typing rule malloc 
newly allocated tuple begins filled junk initialized field field 
tuple initialized type change reflect new components 
means initialization incompatible usual rule memory writes 
tal provided elegant way handle initialization flags newly allocated tuple essentially stamped ultimate type initialization move ultimate type 
addressed aliasing problem aliases weaker views tuple incompatible ones 
tal conflates mechanisms pointers tuples tal track initialization tuple field field basis 
tal permits interleaving initialization computation 
unfortunately field field initialization flags incompatible talt talt decoupling pointers tuples 
flexibility orded initialization flags appears rarely practice 
expedient alternative talt requires newly allocated object fully initialized computation takes place 
uninterrupted initialization easy maintain invariant aliases new object exist 
powerful account initialization alias types explored extension 
nsw inits mbox ns malloc tn tm tm inits mbox mov rco inits mbox mbox inits mbox allocation initialization typing rules rules implementing mechanism appear 
rule provides object allocated pointer placed register type checking moves special mode type updated purpose enforced giving type nsw 
series initializing moves final rule ordinary pointer shift back ordinary type checking mode 
additional ugly rule type checking machine states midst initialization appears technical report expresses invariants initialization type preservation property established 
stacks talt supports stacks type mechanism essentially identical stack tal variety special instructions folded talt operand destination mechanism :10.1.1.12.4086
full details appear technical report 
reasons brevity omit discussion stacks body remarks 
talt notions null object concatenation objects memory need introduce special types nil tal 
need special kind stack type determine size talt types require kind types size determined possibly unknown variables kind td 
kind called td rarely useful aside stacks practical purposes serves kind stack types 
multiple entry points facility provided talt may immediately obvious ability jump middle block code impossible tal 
operationally clear jump valid address 
obvious jumps typed 
suppose code simplicity code executable register file type suppose code wish assign type types set set set set set set set int set int set int set set void set set void set set void set set set set set set set set integer ranges type 
possible giving type code ns code possible structure talt code desired forward backward jumps needing insert arbitrary breaks typing purposes 
importantly executable address type manner talt support true call instruction return address obtained program counter 
details call instruction appear technical report 
extensions disjoint sums standard implementation disjoint sum type say int int int pointer tuple leading field tag identifying arm sum 
talx idiom supported directly special type disjoint sums 
talt decompose primitive components add notion singleton type written set containing integer easily construct type faithfully characterizes encoding box set int box set int int element type pointer int zero tag pointer int int tag 
gives typing rules pertinent subtyping rules set upper lower subrange types set set useful shortly 
rules su cient type accurately expressed members disjoint sum immediately useful 
problem absence elimination rule union types 
may load tag word set instructions eq sat neq unsat set neq sat eq unsat set set lt sat gte unsat set lte sat gt unsat set set gt sat lte unsat set gte sat lt unsat set set int set rco tw unsat void sat void union elimination disjoint union box set int box set int int distributing box box set int set int int distributing box set set int int int promotion set int box int int int int comparing tag zero may determine dynamically arm disjoint union object belongs 
rules discussed far way take advantage information static typing way access variant constituents disjoint union 
possible eliminate union types add new instruction 
operationally identical instruction sequence special pseudo instruction typing rule 
suppose comparison 
example type comparison mco rco im condition eq 
idea rule eliminate union type providing static proof type branch taken type branch skipped 
follows type branch non branch 
consider typing rule 
clauses ensure comparison permissible indicate value compared number event branch taken type sat unsat 
clause identifies union type interest follows type type clause re types operand hypothetical circumstance 
type type branch skipped type unsat clause proves simultaneously true 
branch skipped may conclude type clause 
similar argument shows branch taken may conclude type clause 
example suppose type wish jump tag zero mco rco im eq clauses easily established argument clause set set 
remains show set set set void set set void easy obtain distributivity contradiction subtyping rules set set void set set void 
second observe set set result follows contradiction subtyping rule 
may continue type checking refined type branch 
general case ary sums may wish case analyze sum binary search execute log comparisons 
done rule choosing inequality comparison equality 
set rule necessary associativity union types cast ary sum form single union type arm incompatible branching branching 
relative addressing talt machine model pc relative addressing di cult add operationally 
simply add new operand form operand resolution rules type system matters trickier 
relative addressing creates situation code values general may certain type resides particular location viewed naively 
situation undesirable reasons making typing rules aware locations values reside require wide scale changes type system lessen elegance 
second resulting type system conventional type systems value type depend written 
preserve type system current form introduce technical device call 
employ function convert relative addresses absolute ones 
example im im im im rco rco mco mco code type checked delocalized form typing rule need provided relative operands 
consequently typing rules instruction preserved change 
burden assumed code typing rule values converted code sequences type checking 
recall rule code old modify decode function account second typing rule know memory lies permitted assume address just may assume register file type records assumption type code new type code read code may executed register file type provided resides address 
obligation discharged typing rule code pointers admits properly delocalized pointers code pointers code tn new note code block delocalized address resides address code pointer type 
change type system top level state typing rule modified obvious manner account gc safety principal safety results talt usual progress type preservation theorem progress theorem type preservation progress proof induction typing derivation 
type preservation proof case analysis evaluation derivation outer induction typing derivation handle register file subsumption existential unpacking rules 
im 
vn 
dom modified rules gc safety additionally talt operational semantics account garbage collection prove additional result showing garbage collection disrupt typability 
talx talt designed weiser conservative garbage collector 
need maintain tagging invariants order assist collector distinguishing pointers integers 
gc safety condition maintained collector function properly live heap object reachable chain pointers root set 
pointer permitted reach object pointing object 
root set collection values register file stack 
condition maintained consequence live objects may garbage collected 
purposes define live object presence required state typed 
main gc result proof garbage collecting unreachable objects break typability state 
order satisfy gc safety condition impose invariants typed talt code 
code segment contains non accidental pointers heap segment 

immediate operands contain non accidental pointers heap segment 
invariant necessary code segment part collector root set 
invariant speaking necessary burdensome operand part instruction code segment invariant follows invariant instruction useless anyway 
invariant imposed dramatically simplifies development follow means need formalize look pointers code values 
invariants achieved replacing typing rules immediate operands memories rules strip heap sections memory type typing code sections immediate operands 
formalize gc safety theorem need definition unreachability interior pointers permitted boehm chase specification permitted collector implementation 
definition suppose set heap section identifiers 
reachable written form 
section unreachable memory section reach untraced code segment unreachable definition suppose set heap section identifiers 
unreachable dom reachable 
definition suppose set heap section identifiers 
unreachable unreachable reachable reachable sp 
note definition unreachability deterministic 
unreachable small empty set 
definition crafted manner predict objects collected conservative collector 
prove result unreachable sets covering collector turns 
theorem gc safety suppose unreachable suppose 
dom 
proof induction typing derivation 
machine checked proofs results formalized machine checked proofs twelf system 
step formalization encode talt syntax type system operational semantics lf signature judgements types derivations terms :10.1.1.21.5854
process standard 
language formalized state prove principal meta theorems progress type preservation gc safety 
meta theorem statement encoded relation derivations 
example principal meta theorem statements progress type 
mode progress 
preservation type 
mode preservation 
collect ok collect type 
mode collect ok 
instance progress theorem relation derivations derivations forth 
mode declaration statement indicates input output arguments relation 
proof components lines purpose properties canonical forms properties conditions properties memory lookup update extension instruction decode lemmas size lemmas properties register file lookup update properties values equality lemmas properties natural number arithmetic validity behavedness derivations canonical forms lemma lemmas regarding type formation progress weakening strengthening memory types operand destination lemmas type preservation gc safety properties binary arithmetic table safety proof breakdown cases argument mode sole output argument 
proof meta theorem encoded logic program type relational encoding theorem 
program principle derivations input arguments unification variables output arguments executed obtain resulting derivations 
logic program represents valid meta proof execution runs successful 
twelf totality checker verifies logic program fact total assistance programmer identifying induction variable 
consists checking facts 
mode checking output arguments input arguments fully determined 

termination checking induction variable decrease recursive calls 

totality checking case analysis cases covered 
details reader referred pfenning 
specification talt lf consists lines twelf code complete proof theorems consists lines twelf code including comments breakdown proof code interested reader table 
full proof takes approximately minutes check twelf pentium ram 
talt provides elegant expressive fully formalized type system assembly language 
machine checkable safety theorems section provide complete safety argument talt programs terms safety policy expressed operational semantics assembly language level 
complete foundational tal system combined proof talt operational semantics maps correctly concrete architecture 
talt designed stage proof implementation type free simulation argument 
talt designed easily adaptable architectures 
general architectural constants vs little endian number registers size machine word parameters language easily changed 
new instructions easily added fact generality talt operand destination mechanism new instructions may 
means primary burden specializing talt architecture accounting idiosyncrasies ia treatment floating point delay slots jumps risc architectures 
issue addressed talt issue processor exceptions faults division zero stack overflow various floating point exceptions 
prohibitively expensive prevent dynamically di cult prevent statically 
fortunately purposes safely ignored assuming occurrence exception aborts program program longer running certainly safe 
issue stack overflow little bit involved ensure stack overflows cause stack overflow exception 
standard practice preceding stack memory typically unmapped memory pages 
push instruction overflows stack hit unmapped page cause exception 
instruction increases stack size arbitrary amount bit trickier skip unmapped pages land accessible memory 
prevent limiting page time forcing touch top stack push 
ensures overflowing hit unmapped page 
assist development talt programs designed explicitly typed variant talt called enjoys decidable type checking 
adds type annotations sections replaces talt subtyping explicit coercions 
implementing assembler typechecks programs generates corresponding talt derivations compresses necula rahul technique 
development popcorn compiler 
tools combined standard ml popcorn compiler rml mlton provide complete certifying compiler standard ml talt 
direct standard ml talt compiler underway 
andrew appel amy felty 
semantic model types machine instructions code 
seventh acm symposium principles programming languages pages boston january 
hans 
boehm 
simple garbage collector safety 
sigplan conference programming language assuming downward growing stack design implementation pages philadelphia pennsylvania may 
hans 
boehm david chase 
proposal garbage collector safe compilation 
journal language translation december 
hans 
boehm mark weiser 
garbage collection uncooperative environment 
software practice experience september 
rajkumar buyya mark baker editors 
international workshop grid computing volume lecture notes computer science bangalore india december 
springer verlag 
henry suresh jagannathan stephen weeks 
flow directed closure conversion typed languages 
european symposium programming march 
bor evan chang karl crary margaret robert harper jason tom murphy vii frank pfenning 
grid computing concert 
technical report cmu cs carnegie mellon university school computer science june 
christopher colby peter lee george necula fred blau 
certifying compiler java 
sigplan conference programming language design implementation pages vancouver british columbia june 
concert 
www cs cmu edu concert september 
karl crary 
foundational typed assembly language 
technical report cmu cs carnegie mellon university school computer science december 
karl crary greg morrisett 
type structure low level programming 
sixth international colloquium automata languages programming volume lecture notes computer science pages prague czech republic july 
springer verlag 
joshua 
personal communication 
hamid zhong shao trifonov stefan ni 
syntactic approach foundational proof carrying code 
seventeenth ieee symposium logic computer science copenhagen denmark july 
robert harper furio honsell gordon plotkin :10.1.1.21.5854
framework defining logics 
journal acm january 
intel 
ia intel architecture software developer manual 
order numbers 
craig lee editor 
second international workshop grid computing volume lecture notes computer science denver colorado november 
springer verlag 
tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
talx realistic typed assembly language 
second workshop compiler support system software atlanta may 
greg morrisett karl crary neal glew david walker :10.1.1.12.4086
stack typed assembly language 
journal functional programming january 
earlier version appeared workshop types compilation volume lecture notes computer science 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
acm transactions programming languages systems may 
earlier version appeared symposium principles programming languages 
george necula rahul 
oracle checking untrusted software 
eighth acm symposium principles programming languages pages london january 
frank pfenning 
logic programming lf logical framework 
gerard huet gordon plotkin editors logical frameworks pages 
cambridge university press 
frank pfenning 
implementing meta theory deductive systems 
eleventh international conference automated deduction volume lecture notes computer science pages saratoga springs new york june 
springer verlag 
frank pfenning carsten 
system description twelf meta logic framework deductive systems 
sixteenth international conference automated deduction volume lecture notes computer science pages trento italy july 
springer verlag 
frank pfenning carsten 
twelf user guide version 
available electronically www cs cmu edu twelf 
frank pfenning 
mode termination checking higher order logic programs 
european symposium programming volume lecture notes computer science pages linkoping sweden april 
springer verlag 
carsten 
automating meta theory deductive systems 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania october 
seti home 
ssl berkeley edu november 
frederick smith david walker greg morrisett 
alias types 
european symposium programming berlin germany march 
andrew tolmach dino oliva 
ml ada strongly typed language interoperability source translation 
journal functional programming july 
wells 
typability type checking system equivalent undecidable 
annals pure applied logic 
type formation subtyping rules num td td td ti tj box tw mbox tw td sptr tw code tw num set tw num set tw num set tw td ti ti ti ns void ti td ti td td td td ti ti ti ti ti ti ti td ti td code code box box mbox mbox td td sptr sptr ti ns void ti ti void void void void mbox box set int set int set int set set void set set void set set void int num set set set set set set set set set 
rn sp 
rn sp 
