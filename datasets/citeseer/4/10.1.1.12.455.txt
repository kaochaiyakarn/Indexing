generic agent architecture multiagent systems jos vidal swearingen engineering center university south carolina columbia sc vidal sc edu ece sc edu introduce generic agent architecture gaa biter implementation gaa robocup domain 
gaa incorporates elegant object oriented design meant handle type activities typical agent multiagent system 
activities include reactive responses long term behaviors conversations agents 
show small modifications gaa implementation lead subsumption agent bdi agent 
biter implementation proof concept illustrate added functionality user gaa implement specific domain order utilize gaa 

building agent part multiagent system faced challenging set obstacles 
agent able initiate carry conversations agents carry long term behaviors take immediate actions necessary handle error conditions missing messages noisy input 
furthermore agent implementation follow standard software engineering practices data abstraction specification 
design allows easily distribute implementation responsibilities developers quickly add new functionalities date 
example imagine building team software agents participate simulated soccer tournament robocup challenge 
decide implement coordination protocol require players send receive messages row maintaining conversation 
players implement long term behaviors dribbling ball finding open teammate consist atomic actions 
want implementation easy add new functionality learn problem domain 
set requirements common usc tr paul buhler college charleston computer science dept george street charleston sc cs edu multiagent domains 
faced set requirements clear agent architecture needed structure programming task 
choose number agent architectures 
subsumption architecture belief desires intentions bdi architecture popular 
subsumption architecture reactive architecture implemented faithfully follow original design completely reactive 
maintain state 
supports behaviors provides way specify behaviors inhibit 
inhibition relationships determine behavior executed time 
bdi architecture provides complex control mechanism 
bdi agent set desires set plans associated desire 
agent set beliefs include knows state world agents agent internal state 
bdi control mechanism chooses plans intend finding current desires set plans satisfy desires choosing 
plan intended bdi control mechanism rules determine long stay intended 
bdi implementations include procedural reasoning system prs university michigan prs um prs system dmars 
implements different ways choosing plan execute fixed priorities meta reasoning methods 
architectures provide solid foundation building agent 
major stumbling blocks faces trying implement agent multiagent system object oriented language 

need way easily implement conversations long term behaviors 
bdi plans provide support explicit 

need detailed object oriented design guide implementation 
subsumption implementations usually hardware bdi implementations usually logic rule programming implement new language interpreter done um prs 
general hard novices translate subsumption bdi descriptions textbooks coherent object oriented implementation 

need structured way dealing error conditions lost messages lost sensor readings 

wish deal complexities bdi control system purely reactive system needs 
agent matures requirements change 
need architecture modified act purely reactive purely goal driven 
article generic agent architecture gaa provides support conversations long term behaviors reactive behaviors modular way separates behavior knowledge control knowledge 
separates code tells agent code tells apply behavior 
gaa meant general design new agent oriented software engineering wish implement system scratch 
want build system existing agent systems see section 
section gives summary architecture 
section shows gaa implement subsumption architecture section shows implement bdi architecture 
section introduces biter implementation gaa robocup domain describes typical gaa specific problem 
section presents related section summarizes contribution 

generic agent architecture gaa provides general design building agents object oriented language participate multiagent system 
specifically agents assumed receive input environment discrete intervals take discrete actions 
envision agent receives readings sensors takes actions effectors 
common way model autonomous agents chapter captures agent applications 
assume environment non deterministic agent near real time requirements 
example agent required take action certain time window 
gaa provides mechanism scheduling activities time agent receives form input 
various input types described section 
activity described section defined set actions performed time 
action chosen particular time depend state world agent internal state 
types activities defined conversations behaviors 
conversations series messages exchanged agents 
behaviors actions taken set time steps 
section determines activity called handle new input 
input agent propelled act receiving form input 
activity manager receives new object input class 
class sub classes message event 
relationships shown uml class diagram 
set inputs come directly agent sensor 
generally assume exists parsing function transforms input original format object class 
implementations class hierarchy created class order differentiate various types sensor inputs 
message class represents message agent 
assume agent explicit communications channel agents messages receives distinguished sensor input 
possible domains cases trivial distinguish message just feature environment example agents communicate moving objects landscape 
cases messages consequence conversations recommended 
event class special form input represents event agent created 
events alarms set go certain time 
important provide way implement timeouts 
timeouts waiting reply message waiting input arrive repeatedly action hope generating effect 
activities activity class represents basic building block 
gaa agent defined creating number activities letting activity manager schedule needed 
activity class main member functions handle inhibits 
relationships activities activity manager shown uml class diagram 
member function receives input object argument returns true activity handle input execute consequence receiving input 
function consider contents input consider agent current internal state agent world model generic framework constrain function access certain subset available data 
decision left software engineer wants refine architecture 
requirement function speedy need called new input arrived 
handle member function called activity chosen handle input 
gets called activity manager wants execute input 
function usually generates atomic actions sets member variables returns 
call handle function executes step activity step corresponds received input 
function set member variables way maintain state successive invocations 
state allows activity implement multi step plans complex long term behaviors 
handle function return true activity done point deleted 
expect agents set persistent activities done 
inhibits member function receives activity object parameter returns true activity inhibited current 
function implements control knowledge activity manager determine activity execute 
function mirrors subsuming behaviors subsumption architecture 
function consult state variables order calculate value extending functionality 
activities organized hierarchy function able easily inhibit subtrees hierarchy 
allow add new activities having modify existing ones 
significant advantage representing activity class required member functions enforce clear separation behavior knowledge control knowledge 
handle function implements knowledge accomplish certain tasks goals 
function tells conditions activity represents suitable solution 
inhibits function incorporates control knowledge tells activity executed 
separation necessary requirement modular easy expand agent architecture 
behavior behavior class class groups long term behaviors agent 
define behaviors series atomic actions 
example robotic behavior avoid obstacles software agent gather data sources behavior 
behaviors activities create new activities add set activities 
expect users define behavior hierarchy class starting general class defining progressively specialized behaviors 
general behavior class typically include utility functions proven useful particular problem domain 
subclasses class serve way grouping similar behaviors 
example robotic soccer domain general soccer behavior followed uml class diagram input hierarchy 
dribble behavior followed dribble near opponent behavior 
soccer behavior implement utility functions dribble behavior implement actual physical behavior dribble near opponent specializes 
conversation conversation class class serves base class agent conversations 
define conversation set messages sent agent agents purpose achieving goal purchase item delegation task gaa implementation defines set conversations classes inherit general conversation class 
example agent wanted contract net protocol implement contract net class inherits conversation 
conversations implement protocols 
protocols represented finite state machine states represent current status conversation edges represent messages sent agents see specific proposal extends uml cover agent conversations 
protocols agent play available roles 
example contract net protocol agents play role contractor contractee 
conversations implement finite state machine 
multiple conversations handled having existing conversation add new set activities 
example message starts new conversation request bids received agent function appropriate conversation return true conversation busy starting state 
handle function called new message conversation recognize uml class diagram activities activity manager 
busy create new conversation add action manager call new conversation handle method new input return 
way new conversation object created handle new message 
behaviors method initialize conversation 
example move point behavior realize agent blocking path start conversation agent effort convince move way 
allowing activities create new activities lead unfortunate situations 
example agent generate contract net conversations compromising agent tasks time 
type problem arises various activities assuming resource agent time available 
standard solution problem activities reserve lock resource 
way control number type conversations active time conversation factory factory method 
method conversation asks factory create new conversation giving needed parameters role initial message factory decide type conversation create proposed new conversation interfere ongoing conversation 
problem factory refuse create new instance 
agent conversations need fault tolerant 
need function presence errors 
errors take forms message lost transmission medium agent stops functioning malicious malfunctioning agent sends messages fails reply message takes long arrive agent implements conversations want implement error handling logic 
proposed solution problem creation exception handling agents monitor network agents conversations 
solution provide agents simple exception handling code conversations 
specifically errors mentioned manifest failure receive message receipt messages 
gaa conversation sends message expects reply agent creates special event adds priority queue 
reply arrives agent removes event 
reply takes longer time specified event conversation receive event reply 
receipt event indicates conversation timed waiting reply 
received timeout event signifies number problems reply message lost transit agent died agent refusing answer 
depending particular system possible differentiate situations 
example networked environment keep track network load deduce probability packet lost closed system inquire particular agent active certified member system 
course want conversation re implement error handling verification code 
define function conversation class place error handling code 
conversation times reply simply calls function instruct re sending message aborting conversation 
arrival unexpected messages consid pq new event loop pq top time current time handle input get data sensors handle input loop run ered error 
example rogue agent sending lot messages hopes overwhelming agent situation specifically relevant open systems 
suggest creation new conversations monitored calls error handling function 
activities spawn new conversations call determines safe 
hand factory produces new conversations factory responsibility call error handling function 
case error handling function keep list agents requested new conversations block agents abusing system 
activity manager picks activities execute input agent receives 
implements agent control loop 
manager runs thread receives input sensors dispatches appropriate activity 
run method manager shown 
done handle function shown determine activities handle input 
algorithm implements echoes type control mechanism implemented subsumption bdi architectures 
function finds activities handle input group chooses inhibited group asks handle input 
inhibition function arbitrarily defined activity ordering flexible 
user gaa options ranging organization activity inhibits activity static organization activities inhibit fixed type activities dynamic organization activities inhibit factors 
agent matures user choose increase organizational complexity re implementing architecture 
multi step activities sure implement functions enable selected successive time steps 
agent implements gaa needs instantiate copy activity manager object 
agent adds desired activities object 
activities define behavior 
calls run method activity manager order start running 
point manager takes complete control enter infinite loop choosing behavior execute time 
user gaa architecture need modify manager 
control knowledge stored inhibits methods activities user define 
input new input activities set activities matches new vector activities input matches addelement new vector matches inhibited false matches inhibits inhibited true inhibited addelement chosen pick randomly chosen handle chosen handle input input 
gaa subsumption archi tecture gaa object oriented modular function pure subsumption architecture changes design requiring user careful defining activities 
gaa implements subsumption mechanism inhibits function need sure agent maintain state 
architecture responsible implementation actual activities user responsibility sure activities maintains state variables keep values successive invocations 
inhibits function decisions solely type activity 
way arrive function equivalent subsumption architectures 

gaa bdi architecture gaa function bdi architecture simple extensions basic architecture 
specifically desires container class needed hold set active desires agent 
class implement access functions carry basic tasks adding new desire removing desire determining desire active 
agent class 
desire container implemented user gaa sure method activity returns true goal activity achieves part set active desires 
activity achieves desire responsible removing returning 
activity associated desire activity responsible firing desire active removing desire achieved 
gaa architecture impose intention semantics 
exist bdi logics various intention semantics exist bdi systems implements different methods determining intention dropped new intention take priority 
gaa claim implement method 
user decide method best application implement 
example user decide associate priority number desire goal modify inhibits methods activities activities inhibit priority goal achieve 
example activity inhibit activities achieve goals lower priority 

biter implementation gaa robocup goal robocup initiative spur fundamental research areas ai intelligent robotics providing standard problem sufficient complexity near universal familiarity 
goal met game soccer played worldwide 
success robocup achieving goal inferred growing participation robocup world championship competition 
robocup competitions partitioned leagues 
leagues include legged medium small robots software simulation 
biter framework designed gaa implementation soccer player simulation league part graduate university course multiagent systems 
robocup simulation league allows teams composed software agents compete head head competition 
architecture simulation league consists centralized server monitor application individual agents players game 
server manages game play provides sensory input players messaging service built udp communications 
sensory input consists messages contain visual information auditory information information referee 
response sensory stimulus simulated field play player takes action message set effectors notify server player activity 
player indicate kicking ball field information players 
detailed description robocup simulation league architecture messaging protocol manual 
field multiagent systems traces historical roots broad array specialties disciplines fields ai logics cognitive social sciences 
academic setting pedagogical approaches needed provide opportunities students perform meaningful experimentation learn guiding principles multiagent systems development 
biter framework designed enable project curricular component facilitates robocup classroom setting 
biter instantiation gaa allows students explore strong weak notions agency 
biter provides number low level ball handling skills higherlevel skill behaviors 
additionally functional utility methods provided allow students focus directly planning activities 
biter written java 
primary features language leveraged biter code native support multiple threads builtin network communications capability dimensional graphics library 
biter world model implementation gaa need way represent objects agent world 
type objects vary greatly domain domain gaa specify represented 
robocup domain example clear agents need build world model 
world model contain slots static dynamic objects 
static objects field placement change course game 
static objects include flags lines goals 
contrast dynamic objects move field game 
represent players ball 
player receives sensory input relative current position consisting vectors point static dynamic objects field view 
static objects fixed locations important calculating player absolute position field play 
player knows absolute location relative positions dynamic objects sensory input transformed absolute locations 
biter framework provides world model contains static dynamic objects 
static objects held hashmap data structure dynamic objects stored arraylist 
hashmap arraylist provided part java collection classes 
sections describe implementation biter world model 
world model update previously mentioned biter designed provide framework student exploration theory techniques multiagent systems 
due consideration biter world model needs support state stateless agent architectures 
blush difficult resolve conflicting goals unified framework realizes stateless agent simply implies maintains state history straightforward implementation obvious 
sensory information dynamic objects placed biter world model time stamped 
biter implements command line argument indicates maximum age world model data 
world model information allowed age discarded player memory update cycle 
additionally timestamp allows easy detection stale data world model 
stale data defined world model element reported time past updated subsequent cycles 
stale world model elements surpass age threshold removed 
allowing specification threshold run time students experiment parameter see impacts behavior player 
world model access access world model data simple approaching extraction problem simplistically leads undesirable cluttering code 
code obfuscation occurs access strategies loop test logic routine accesses world model 
biter utilizes decorator pattern augment capabilities java arraylist iterator 
underlying technique filtering iterator 
filtering iterator traverses iterator returning objects satisfy criteria pp 

biter utilizes regular expressions selection criteria 
example depending proximity soccer ball identity reported ball times ball 
processing algorithm calls retrieval soccer ball world model initialize filtering iterator criteria bb reliably locate object 
filtering criterion regular expression able construct powerful extraction routines incurring complexity coding error prone compound conditionals 
example algorithm computing player absolute field position requires access flag goal objects sensory input 
specifying filtering criteria ff lag gg oal creates iterator returns desired elements 
accessing world model elements aid filtering iterator helped reduce complexity student authored code 
simplification interface student code world model allows students focus directly building behavior selection planning algorithms 
world model display access world model streamlined creating concise algorithm revealing code remains difficult fully understand behavior players 
times way understand moments behavior access players world model 
dumping contents world model file interpretation unnecessarily complex unwieldy 
attack problem biter provides runtime visual display player internal view environment 
java language having built windowing routines dimensional graphics primitives simplified development display capability 
biter agent started command line parameter enable graphical display world model 
display served independent thread utilizes double buffering smooth animation 
overhead view field shows static objects dynamic objects currently player world model 
stale elements encountered algorithm run merges display color background color field 
visually effect having stale elements fade away age 
graphical display player world model compared soccer monitor display purposes independent verification validation player world model contents 
powerful debugging feature saved students countless hours fruitless troubleshooting helps focus multiagent system implementation issues 
experiences biter university taught graduate level course multiagent systems years 
robocup soccer simulation problem domain adopted instructional project past 
semester students spent majority time writ ing support code act scaffolding build team player agents 
multiagent systems theory practice took back seat required foundational software construction 
semester teams competed majority reactive agents due part complexity creating maintaining world model 
biter framework outgrowth experience 
biter available student focus team development behavior selection planning 
gaa allows students hands experience reactive bdi architectures 
students longer focused development low level skills behaviors applying breadth depth newly acquired multiagent systems knowledge 
biter provides platform flexible experimentation various agent architectures 
software full uml diagrams javadoc api available download 
interested receiving feedback choose biter academic setting 

related agent architectures literature implement specific agent system 
user systems expected download provided software build agents extensions system 
architectures take form software libraries user link times provide graphical user interfaces user expected building agents zeus 
agent architectures provide finished product commits user specific structure specific language specific set limitations 
gaa contrast meant general design implemented user object oriented language desires 
course gaa borrows best ideas existing agent systems tries user simplest form 
jade agent framework example implements fipa compliant agent system 
fipa standards jade focuses providing inter agent communication services agent management system directory facilitator required fipa code necessary interfacing services 
communication services orthogonal functionality provide gaa 
feasible gaa agent 
jade goes provides scheduler akin schedules behaviors 
jade scheduler carries round robin non preemptive policy behaviors available ready queue allow behaviors inhibit provide support complex dynamic behavior selection 
jade system provide explicit support conversations 
systems just sampling available agent architectures systems include cognitive agent architecture open agent architecture zeus agent building toolkit madkit platform 
commercial systems available implementation agent systems analyzed 
systems provide complete solutions necessity commit user particular way implementing communications cases implementing internal control flow agents 
useful users desire quick solution needs closely match features software 
gaa hand wish implement complete agent find existing software solutions satisfactory sure type control mechanism best suited domain want flexible architecture accommodate changes requirements 

summary introduced generic agent architecture biter implementation gaa robocup domain 
gaa incorporates elegant object oriented design meant handle type interactions agent multiagent system expect 
type interactions include reactive responses long term behaviors conversations agents 
shown gaa generic small modifications implementation lead purely reactive agent bdi agent 
gaa meant designers researchers want implement complete agent want flexibility changing control semantics project progresses maintaining clean separation behavior control knowledge 
useful didactic tool teaching multiagent systems design 
biter implementation serves proof concept illustrates added functionality user gaa implement specific domain 

biter robocup client 
cse sc edu biter 
agent architecture 
www org 
bailey 
java structures data structures java principled programmer 
mcgraw hill 
poggi 
developing multi agent systems jade 
proceedings seventh international workshop agent theories architectures languages 
booch rumbaugh jacobson 
unified modeling language user guide 
addison wesley 
bratman israel pollack 
plans resource bounded practical reasoning 
computational intelligence 
brooks 
intelligence representation 
artificial intelligence 

java agent framework multiagent systems development implementation 
phd thesis university cincinnati 
dellarocas klein 
experimental evaluation domain independent fault handling services open multi agent systems 
proceeding fourth international conference multiagent systems pages 
inverno kinny luck wooldridge 
formal specification dmars 
singh rao wooldridge editors intelligent agents iv proceedings fourth international workshop agent theories architectures languages lecture notes artificial intelligence pages 
springer verlag 
heintz noda riley stone 
manual 
fisher 
survey concurrent metatem language applications 
proceeding international conference temporal logic pages 
springer 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
georgeff ingrand 
monitoring control spacecraft systems procedural reasoning 
technical report australian artificial intelligence institute melbourne australia 
gutknecht michel ferber 
madkit generic multi agent platform 
proceedings fourth international conference autonomous agents pages 
petrie cutkosky 
java agent infrastructure message routing 
ieee internet computing mar apr 
lee huber kenny durfee 
um prs implementation procedural reasoning system multirobot applications 
conference intelligent robotics field factory service space pages houston texas march 
martin cheyer moran 
open agent architecture framework building distributed software systems 
applied artificial intelligence january march 
nwana ndumu lee 
zeus tool kit building distributed multi agent systems 
applied artifical intelligence journal 
brien nicol 
fipa standard software agents 
bt technology journal 
odell parunak bauer 
representing agent interaction protocols uml 
proceedings fourth international conference autonomous agents 

demazeau 
analysis deployment multi agent platform survey 
proceedings workshop engineering societies agents world 
springer verlag 
stone 
layered learning multiagent systems winning approach robotic soccer 
mit press 
vidal buhler huhns 
inside agent 
ieee internet computing january february 
wei editor 
multiagent systems modern approach distributed artificial intelligence 
mit press 
wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 
