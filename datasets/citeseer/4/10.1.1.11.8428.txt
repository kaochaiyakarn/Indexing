programming reasoning planning agents flux michael thielscher department computer science dresden university technology dresden germany mit 
tu dre 
de high level programming method flux allows design cognitive agents reason actions plan 
established general action representation formalism fluent calculus flux agents maintain explicit partial world model control behavior 
exten sive reasoning facilities provided underlying calculus flux allows implement complex strategies concise modular agent programs 
systematic experiments problems require reason performance thousands actions shown flux exhibits excellent computational behavior scales particularly long term control 
challenging promising goals artificial intelligence research design autonomous agents including robots explore partially known environments able act sensibly incomplete information 
autonomy solving complex tasks requires high level cognitive capabilities reasoning planning exploring environment agents reason interpret sensor information memorize draw inferences combined sensor data 
acting incomplete information agents employ reasoning facilities ensure acting cautiously plan ahead actions specific goal mind 
parts reported carried author visiting researcher university new south wales sydney australia 
agents intelligence goes simple reactions stimuli reason plan basis mental model state environment 
move agents constantly update model reflect changes effected sensor information acquired 
having agents maintain internal world model necessary want choose actions basis current status sensors account previously observed done 
ability reason sensor information necessary properties environment indirectly observed require agent combine observations different stages 
cognitive capability planning allows agent calculate effect different action sequences order help choosing appropriate current circumstances 
standard programming languages agents java require programmers write special purpose modules intend endow agents cognitive capabilities reasoning planning domain hand 
formal theories reasoning actions change hand expressive power provide capabilities 
examples existing agent programming methods deriving general action theories golog levesque reiter situation calculus robot control language developed shanahan event calculus 
nei ther systems underlying calculi provides crucial concept explicit state representation 
execution program state knowledge indirectly represented initial conditions actions agent performed far 
consequence evaluating conditions agent program necessitates trace back entire history actions requires increasing computational effort agent pro 
studies reported accompanying shown concept fails scale long term agent control thielscher 
explicit state representation fundamental concept fluent calculus thielscher established versatile action representation formal ism thielscher offers alternative theory formal underpinnings high level agent programming method 
actions specified fluent calculus called state update axioms knowledge update axioms respectively readily agent programs maintaining internal world model accordance performed actions acquired sensor information 
fluent calculus equipped formal concept action histories called situations agents solve planning tasks way 
high level programming method flux fluent executor allows design intelligent agents reason plan basis fluent calculus 
paradigm constraint logic programming flux comprises method encoding incomplete states technique updating states declarative specification elementary actions sensing capabilities agent 
powerful constraint solver underlying flux kernel provides general reasoning facilities agent programmer focus designing high level behavior 
allowing concise programs supporting modularity method promises eminently suitable programming complex strategies artificial agents 
systematic experiments shown flux exhibits excellent computational behavior scales particularly long term control 
rest organized follows 
illustrating section key features programming methodology example non trivial agent program 
section semantics flux terms fluent calculus 
section contains description flux kernel detailed account constraint solver proof correctness accompanying pa thielscher 
section show fluent calculus allows define prove soundness flux programs 
section give overview studies showing computational merits flux 
brief outlook section 
flux system example agent program accompanying papers available download web site 
org 
example scenario wumpus world cave features pits wum pus cell gold cell 
right hand side depicted corresponding perceptions breeze location 
programming agents flux example agent program set artificial environment wumpus world follow ing specification laid russell norvig see agent moves grid cells contain initially unknown agent pits gold square houses hostile wumpus 
sensing capa bilities allow agent perceive breeze respectively adjacent cell containing pit wumpus respectively agent notices cell containing gold hears scream wumpus gets killed 
elementary actions agent enter exit cave cell turning clockwise going forward square direction faces grabbing gold shooting arrow direction faces 
task agent find bring home gold falling pit encountering wumpus 
toy environment wumpus world requires crucial capabilities intelligent agents particular acting cautiously incomplete information interpreting logically combining sensor data planning 
develop complete agent program wumpus world illustrating various features programming methodology 
flux states flux agents states internal model world 
convention action theories atomic components states called 
program wumpus world agent ex ample uses facing representing agent cell faces direction north east south west gold pit wumpus representing square houses respectively gold pit wumpus dead representing wum pus dead representing agent gold arrow 
state identified fluents true agents hardly complete information environment 
reflect incomplete states encoded flux open lists lists variable tail fluents possibly containing variables 
lists accompanied constraints negated disjunctive state knowledge variable range restrictions 
constraints form indicating fluent holds state indicating instance holds indicating holds state furthermore flux employs standard constraint solver finite domains includes arithmetic constraints rational numbers equality order ing predicates standard func tions range constraints written hi logical combinations conjunction disjunction respectively 
consider example initial state wumpus world agent arrow knows wumpus dead square cave pits outside bound aries cave initially agent inside cave facing direc tion init zo zo wx wy lz wx wy holds zo holds wumpus holds dead holds pit holds pit boundary holds pit holds pit holds pit holds agent holds facing duplicate free zo 
reader may notice difference specifying location wumpus pits unique unknown cell housing pits 
stipulating pits may lie outside boundaries cave simplify specification means sense breeze 
auxiliary constraint stipulates list contain multiple occurrences 
update specifications agents move need update internal world model perform action order reflect changes effected sensor information acquired 
maintenance state specification elementary actions agent 
solution fundamental frame problem fluent calculus thielscher flux uses called state update axioms action defining positive negative effects meaning sensing results 
flux kernel pro vides predicate update encoding state result updating state positive negative effects respectively 
finite possibly empty lists 
auxiliary predicate holds ing fluent holds state provided kernel state update axioms 
basis update axioms encoded defining predicate defining state result performing action state perceiving sensor information update axioms program wumpus world agent example follows 
entering cave effect agent cell facing north 
furthermore sensors tell perceives breeze 
auxiliary predicates defined state update zl enter update zl facing breeze perception perception perception 
exiting cave reverse effect state update zl exit holds facing zl update zi facing 
turning effect facing direction clockwise compass state update zl turn holds facing zi ds ds dis update zi facing di facing 
going forward effect adjacent cell acquiring new sensor inputs state update zl go holds zl holds facing zl adjacent update zl xl breeze perception xl perception perception yl 
grabbing gold positive effect having gold negative effect clearing cell state update zl grab holds zl update zi gold gold 
shooting conditional effect depending wumpus hit arrow indicated perception scream 
case agent looses arrow state update zl shoot true update zl dead arrow false update zl arrow 
enter action go action aux predicates defining meaning perceiving breeze new location breeze perception percept xes percept false holds pit xe holds pit xw holds pit yn holds pit ys percept true pit xe pit yn pit xw pit ys 
clause sensing identical pit replaced wumpus perceiving indicates presence gold cell perception percept percept false holds gold percept true holds gold 
update axiom go uses auxiliary predicate defining notion adjacent cells wrt 
different directions adjacent xl ds north south east 
west agent programs agent programs written flux fundamental command execute 
resolving predicate triggers actual performance action furthermore update current state state inferred basis state update axiom expressive power high level agent programming apparent internal world model control continuation program 
conditioning flux tional predicates knows representing agent knows fluent holds respectively hold state exist ground instances variables fluent known true state implement simple strategy wumpus world agent allowing systematically cautiously explore cave 
program maintains parameters list list cells visited current path agent taken backtracking 
agent enters cave sets cell north east lists visited cells backtrack path initialized accordingly main init execute enter cpts vis btr main loop cpts vis btr 
main loop agent systematically selects direction explore current location 
step successful agent tries hunt wumpus checks gold known current square grabs gold goes home created new location list visited nodes backtrack path extended 
hand selected safely explored removed left current location agent backtracks main loop choices cpts vis btr choices dir exists explore dir vis zl successful knows val zl hunt yl zl knows gold xl execute grab go home left backtrack cpts vis btr 
xl yl cpts xl vis btr main loop unsuccessful main loop cpts vis btr consider procedure exploring certain direction agent visited adjacent square new location safe 
acting cautiously agent shall enter cell known free pit wumpus known known dead explore zl adjacent xl member xl pit xl dead turn execute go 
turn facing execute turn turn 
consider procedure backtracking simply means go back square list backtracking points 
list happens empty agent reached home square exits cave backtrack 
execute exit 
backtrack cpts vis btr go back main loop cpts vis btr 
go back holds adjacent turn execute go 
simple strategy hunting wumpus alive check cell known hides agent happens row column 
agent turns direction wumpus shoots action performed state change hunt wumpus zl knows dead zl knows val wx wy wumpus wx wy zl direction wx wy turn execute shoot 
direction xl xl xl yi north xi yi south xi yi east xi yl 
west just procedure remaining defined flux program illustrates high level strategies intelligent agents encoded concise modular fashion 
particular reader may appreciate need program inference capabilities fully provided underlying flux kernel 
allows agent programmer focus specifying complex behaviors basis elementary actions agent 
applied scenario depicted program runs follows entering cave agent exploring cave depicted agent eventually reaches cell gold having shot wumpus way inferred locations pits 
northwest corner cave unknown territory 
goes north 
senses breeze decide pit matter agent backtracks goes 
sensing breeze agent concludes house pit breeze come 
sensing having experienced agent infers wumpus 
agent shoots arrow direc tion making possible step dead wumpus continues explore cave 
ally agent arrives senses grabs gold 
stage current backtracking path depicted 
furthermore agent acquired knowledge contents cells 
planning ability devise plans adds second dimension high level agent programming 
useful application planning example domain agent find direct route home claiming gold agent just follow backtracking path usually involves considerable detour situation illustrates 
unrestricted planning incomplete states notoriously hard problem flux allows define compound actions specify domain dependent search trees planning problems 
instance plan short safe route home wumpus world agent uses compound action going adjacent cell postponing execution time task finding right number turn actions 
virtual action going square effect changing agent location state update zl go holds xl zl update xl 
search trees planning problems specified flux defining predicate denotes planning task describes search space 
adopting key notions notations golog levesque concept search space flux defined follows 
elementary action compound action test search spaces search spaces ee nondeterministic choice sequencing 
search space exam ple planning problem specified follows 
auxiliary tests defined plan proc find path vis home poss go vis go find path 
put words successful plan home go adjacent cell possible followed plan go home 
planning procedure employs list visited nodes avoid running loop 
tests occurring specification search space need accompanied definitions hold current situation performing current sequence actions initial state planning problem 
clause head needs defined test 
flux kernel provides definitions standard predicates knows zo zo knows val zo carry additional situation argument 
basis tests needed example planning prob lem defined follows home knows 
poss go xl vis knows val adjacent member xl vis knows pit knows dead knows xl true vis iris 
reader may notice agent plans safe locations searched known free pit alive wumpus 
sake efficiency tests refer initial state planning problem affected planned actions 
remains done define cost plan planning problem stan dard flux predicate 
furthermore execution virtual action leading state state defined standard flux predicate 
cost plan go home simply length execution requires find right number turns prior going adjacent cell plan cost find path length 
execute compound action go holds xl adjacent xl turn execute go 
employing flux predicates plan execute agents programmed find plan problem state execute plan updating state 
example go home plan find path plan execute plan execute exit 
applied state depicted agent finds executes plan go straight turn walk straight 
fluent calculus semantics flux fluents states fluent calculus sorted predicate logic language standard sorts fluent state action sit situations 
states composed atomic states standard function state state state constant state denoting empty state 
order capture intuition identifying state fluents hold special connection function fluent calculus obey certain properties resemble union operation sets definition foundational axioms state fluent calculus 
associativity commutativity idempotence free variables formulas assumed universally quantified 
variables sorts fluent state action sit shall denoted letters respectively 
function written infix notation 
unit element oz oz zo 
empty state axiom holds 
irreducibility decomposition holds fx fx holds zx holds zx holds 
state equality state existence holds zx holds zx vp sz vf holds second order predicate variable sort fluent macro holds means fluent holds state holds de second order axiom stipulates existence state possible combinations fluents 
basis semantics state specification flux form equational axiom fk sort state fi sort fluent 
meaning flux atom holds macro semantics constraints ax holds holds holds fi free variables example initial state wumpus world suitably de scribed fluent calculus axiom section sx state arrow wumpus ly holds wumpus vx holds wumpus holds dead holds pit vx holds pit holds pit vy holds pit holds pit vx holds holds aeg axiomatization states fluent calculus foundational axioms paves way ex definition addition removal finitely states turn lays dation effective solution fundamental frame problem presence incomplete states 
definition introduces macro equation intended meaning state state minus finite state compound macro means state state minus plus de zl holds finitely fluent terms connected 
crucial item second defines removal single fluent case distinction equals applies case holds plus equals applies case holds 
basis semantics flux predicate update equation 
actions situations adopted situation calculus stan dard sorts action sit axiomatize sequences actions 
standard function action sit sit denotes situation reached performing action situation constant sit denotes initial situation 
standard function state sit state features uniquely fluent calculus serves denotation state environment situation 
generalizing previous approaches bibel tal frame problem solved fluent calculus specify difference states action thielscher 
poss action state denote action possible state precondition axiom action form poss ll order formula free vari able general form state update axiom possibly nondeterministic action possibly conditional effects poss state state state state order formulas ai specify conditions state positive neg ative effects respectively 
state terms consisting fluents ll 
regarding wumpus world agent consider precondition axioms poss nter vx holds poss xit holds poss urn sx holds poss go sd holds holds facing adjacent holds pit holds wumpus holds dead poss ab sx holds holds old poss shoot holds adjacent shall defined section 
state update axioms straightforward description section 
example effect go state axiomatized follows poss go holds state holds facing state adjacent state state reader may notice sensor information incorporated state update axioms sensing affect state 
poss poss state 
knowledge sensing basic fluent calculus extended thielscher foundational predicate sit state allow representing state knowledge reasoning actions sensing 
instance means knowledge agent possible state situation example initial knowledge wumpus world agent specified axiom state formula state replaced variable 
say states satisfy initial specification considered possible agent 
particular agent prior knowledge cave 
notion knowledge state fluent known hold situation hold respectively just case true false respectively possible states state holds state value fluent known just case particular holds possible states stt example initial knowledge entails agent knows wumpus nota bu gen know frame problem knowledge solved axioms determine relation possible states action 
formally effect action sensing knowl edge agent specified called knowledge update axiom poss state macro knows poss stands vz poss 
specifies physical state update ii restricts possible states agree actual state state sensed properties 
example knowledge update axiom action go wumpus world agent knows poss go vo go sd holds holds facing adjacent breeze breeze state state state breeze holds pit holds pit holds pit holds pit likewise holds gold knowledge update axioms axe straightforward correspond encoding section 
flux kernel gives overview architecture flux programs basic statements agent programs axe testing knowledge predicate knows performing actions predicate execute defined flux kernel 
maintaining state performing action relies specification update axioms turn basic flux predicate update 
flux appeals paradigm constraint logic programming enhances logic programs mechanisms solving constraints 
particular called constraint handling rules fr chrs support specifications rules processing flux constraints express negative disjunctive state knowledge 
turn rules finite domain constraints handling variable arguments natural rational numbers user defined finite domain 
states update fi holds zl 
holds 
holds zp fi holds zp 
minus 
minus fs zp knows zi holds minus fs zp 
plus 
plus fs zp knows zl holds zi plus zl fs zp 
update minus plus 
accompanying thielscher contains proof correctness clauses wrt 
foundational axioms state fluent calculus axiomatic characterization fluent removal addi tion 
knowledge flux identified logical entailment wrt 
incomplete state specifications employing principle negation failure knows holds 
knows holds 
knows val holds nonground 
refer thielscher formal correctness definition wrt 
theory knowledge fluent calculus outlined section 
action execution defined follows predicate perform assumed trigger actual performance action sensing values returned execute zl zl aip execute execute elementary action perform state update execute compound action 
flux constraint solver consists small set progression evaluation chrs dealing constraints negative disjunctive state knowledge 
rules constraints axe constantly simplified combined course program order draw new inferences detect 
see thielscher complete set chrs 
nature correctness rules easily verified foundational axioms fluent calculus 
basic definitions states update flux kernel axe follows planning holds 
holds planning flux situation represented list actions matches agent program update axioms flux kernel execute knows update perform sv flux chrs physical agent lib fd architecture flux program 
actual performance action triggered perform connects program effectors sensors physical agent 
specification search space section 
predicate zo defines situation plus action sequence solution planning problem state 
definition follows closely corresponding clauses golog levesque zo ei el sl zo sl zo ei plan proc 
pred args append args 
pred call elementary action compound action 
planning time outcome sensing actions predicted possibilities need taken account 
flux uses predicate res zo denoting incomplete state possible result performing state actions situation way property situation known just case possible result property false res 
res ais zo res zo state update 
knows zo res zo holds 
knows zo res zo holds 
specification cost plan search optimal plan done standard search procedure uses backtracking lution plan proc plan zo assert plan search best void plan search proc zo plan search best plan retract plan search best plan plan void 
plan search proc zo proc plan zo plan cost proc plan cost plan search best bestcost void cost true retract plan search best bestcost assert plan search best plan cost fail true 
programs section give brief overview properties flux programs formally established help underlying fluent calculus se mantics 
assume reader familiar basic notions notations logic programming negation constraints 
particular consider standard left right selection rule called sldnf derivation trees consist main tree number subsidiary trees negated literals apt bol 
notion situation provides semantics execution flux agent program 
definition derivation tree flux program query 
exe cution node node selected atom init execute 
case term called executed action 
node situation associated 
iff path leading satisfies 
execution node form init 
execution node form init 
ordered sequence executed actions 
action exit executed agent returned square unrolling backtrack path planned executed route square 
cases action possible 

action turn executed enter prior exit 
action go executed adjacent cell known free pit wumpus known dead 
path contain execution node situation associated case associated situation undefined 
notion soundness describes generally desirable property flux agent programs 
informally speaking executed actions possible backtracking executed actions 
definition flux program query sound wrt 
fluent calculus axiomatization iff execution node execute computation tree satisfies 
action grab executed agent square known contain gold 
action shoot executed agent arrow 
negated literal depends atoms init execute program execution nodes main tree 
program ends success backtracking execution nodes 
computational behavior 
ground action term 
situation associated defined satisfies poss 
main tree 
lies branch fail 
agent program section wumpus world proved sound sense wrt 
fluent cal axiomatization section 
theorem wumpus world agent program query main sound 
proof sketch 
occurrence execution node form init atom body clause main 

executed actions constants sort action 

action enter executed action possible dition axioms 
studies shown flux exhibits excellent com putational behavior problems toy size 
accompanying thielscher re port experiments special variant flux complete states applied robot control program combinatorial mail delivery problem 
results show flux compute effects hundreds actions second 
notably average time selecting action inferring effects remains essentially constant program progresses shows flux scales effortlessly arbitrarily long sequences actions 
result compared golog levesque curve computation cost suggests polynomial increase time 
analysis shows paradigm state representation necessary programs scale control agents robots extended periods time maintaining explicit state term execution program directly evaluated flux programs implicit state repre sentation levesque shanahan leads increasing compu tational effort program proceeds 
computational behavior flux presence incomplete states analyzed thielscher combinatorial problem involves ex partially known environment acting cautiously incomplete information wumpus world 
incomplete states pose harder problem flux proves scale impressively phase agent enhances knowledge environment wandering mere linear increase computation cost knowledge base grows 
result particularly remarkable agent needs constantly perform theorem proving tasks conditioning behavior knows environment 
linear performance achieved due careful design state constraints supported flux restricted expressiveness theorem proving computationally feasible 
second phase aforementioned program agent acts incomplete knowledge average time making decisions inferring effects actions remains constant 
shows general flux scales effortlessly long sequences actions 
planning incomplete states hand notoriously hard problem flux 
domain dependent search space contains just linear number nondeterministic choices exponentially plans searched planning scale 
argument ready put forward giacomo levesque consequence agent programmer planning facilities bounded sub problems order spoil computational merits flux 
crucial aspects acting real world environments tackled fact actions may fail unexpectedly 
approach problem thielscher default assumptions regarding exe added theory fluent calculus 
incorporating technique agent programs important aspect modeling dynamic environments constantly evolve agents 
apt bol apt bol 
logic pro gramming negation survey 
journal logic programming 
bibel bibel 
deductive solution plan generation 
new gener 
comp 

theory practice constraint handling rules 
journal logic pro gramming 
giacomo levesque de giacomo levesque 
incremental interpreter high level programs sensing 
levesque pirri editors logical foundations cognitive agents pages 
springer 

new deductive approach planning 
new gener 
comp 
levesque levesque reiter les lin scherl 
golog logic programming language dynamic domains 
jour nal logic programming 
reiter reiter 
logic action 
mit press 
russell norvig russell norvig 
artificial intelligence modern approach 
prentice hall 
shanahan shanahan 
high level robot control logic 
proceedings atal volume lncs pages 
springer 
thielscher thielscher 
situation cal fluent calculus state update axioms solution inferential frame problem 
artificial intelligence 
thielscher thielscher 
modeling actions ramifications nondeterministic concurrent continuous domains case study 
proceedings aaai pages 
mit press 
thielscher thielscher 
representing knowledge robot 
proceedings kr pages 
morgan kaufmann 
thielscher thielscher 
qualification problem solution problem anomalous models 
artificial intelligence 
thielscher thielscher 
pushing envelope programming reasoning agents 

submitted thielscher thielscher 
reasoning actions chrs finite domain constraints 

submitted 
