
practical earley parsing john aycock nigel horspool british computer society department computer science university calgary university drive nw calgary alberta canada department computer science university victoria victoria bc canada email aycock cpsc ucalgary ca earley parsing algorithm general algorithm able handle context free grammar 
parsing algorithms presence grammar rules having empty right hand sides complicates matters 
analyzing earley algorithm grammar rules devised simple solution problem 
empty rule solution leads new type finite automaton expressly suited earley parsers new statement earley algorithm 
show new form earley parser time efficient practice original 
earley parsing algorithm general algorithm capable parsing context free grammar 
comparison lalr parsing algorithm yacc limited subset unambiguous contextfree grammars 
general parsing algorithms earley parsing allow expression ambiguous grammar constructs software reengineering graham code generation natural language processing 
parsing algorithms earley parsers suffer additional complications handling grammars containing rules rules form crop frequently grammars practical interest 
published solutions problem arises earley parser substantial drawbacks 
discuss solution wastes effort repeatedly iterating queue items involves extra run time overhead couples logically distinct parts earley algorithm 
led study nature interaction earley parsing rules closely arrive straightforward remedy problem 
result create new type automaton customized earley parser leading new efficient form earley algorithm 
organized follows 
introduce earley parsing section describe problem rules cause section 
section presents solution rule problem followed proof correctness section 
sections show construct new automaton earley algorithm restated take advantage new automaton 
section discusses derivations input may reconstructed 
empirical results section demonstrate efficacy approach earley parsing practical 
received november revised april computer journal vol 

earley parsing assume familiarity standard grammar notation 
earley parsers operate constructing sequence sets called earley sets 
input xn parser builds sets initial set set si input symbol xi 
elements sets referred earley items consist parts grammar rule position right hand side rule indicating rule seen pointer earlier earley set 
typically earley items written position rule right hand side denoted dot andj pointer set sj earley set si computed initial set earley items si initialized applying steps items si added 
scanner 
si xi add si 
predictor 
si add si rules 
completer 
si add si items sj item added set set 
initial set contains item assume grammar augmented final set contain input accepted 
shows example earley parser operation 
lookahead description earley parsing reasons 
easier reason earley algorithm lookahead 
second clear role lookahead play earley algorithm 

earley sets grammar input items bold ones correspond input derivation 
earley recommended lookahead completer step shown better approach lookahead predictor step shown prediction lookahead questionable value earley parser uses finite automata :10.1.1.17.7812
terms implementation earley sets built increasing order input read 
set typically represented list items suggested earley 
list representation set particularly convenient list items acts queue building set items examined order applying scanner predictor completer necessary items added set appended list 

problem point parse sets 
scanner may add items si si may items added predictor completer 
possibility adding items si representing sets lists causes grief rules 
completer processes item corresponds rule look sj items dot unfortunately rule items equal completer looking partially constructed set si 
implementations process items si order item added si completer processed completer add si 
turn items resulting directly indirectly omitted 
effectively prunes potential derivation paths cause correct input rejected 
gives example happening 
rule items added earley set predictor added items parent pointer practical earley parsing aaaa aaa computer journal vol 
aaaa aaa aa aa aaa 
earley parser representing sets lists rejects valid input missing items sound death parse 
methods handling problem proposed 
jacobs aptly summarize approach easiest way handle mare nest stay calm keep running predictor completer turn add aho ullman specify method presentation earley parsing accent compiler compiler generates earley parsers 
approach suggested earley 
proposed having completer note dot needed moved looking items added si 
efficiency sake collection non terminals watch stored data structure allows fast access 
method initially earley parser spark toolkit 
opinion approach satisfactory 
repeatedly processing si parts thereof involves lot activity little gain earley solution requires extra dynamically updated data structure unnatural mating completer addition items 
ideally want solution retains elegance earley algorithm processes items si runtime overhead updating data structure 

ideal solution solution involves simple modification predictor idea 
non terminal said nullable terminal symbols course nullable 
non terminals grammar may easily precomputed known techniques 
notion predictor stated follows modification bold si add si rules 
nullable add si 
aycock horspool aaaa aaa aa aa aaa aaaa aaa aa aa aaa aaaa 
earley parser accepts input 
words eagerly move dot nonterminal non terminal derive effectively disappear 
grammar ill demonstrates modified predictor fixes problem 

proof correctness solution correct sense produces exactly items earley set si earley original algorithm described section earley set may iterated new items added si si 
proof write si denote contents earley set si computed earley method method respectively 
earley scanner predictor completer steps denoted es ep ec denoted ande results 
lemma 
earley item 
si 
proof 
cases depending length 
case 

lemma trivially true 
case 

key observation parent pointer earley item indicates earley set item appeared 
words item si si means recognized consuming terminal symbols 

lemma 
si si proof 
assume earley item si added si 
case 
added initially 
case 
obviously 
case 
added es applied item si 
es si soi case 
added ep 
say 
exist si 
ifi adds items ep adds 
case 
added ec operating si 
say 
assume ifi ec referring back earley set sj assume lemma 
item si 
ifi added si contradiction chosen si lemma 
si si proof 
take tack posit existence earley item si 
added case 
added initially 
situation case lemma 
case 
added case proof directly analogous lemma case omit 
case 
added case analogous case lemma omit 

definition ifi si si earley algorithm failed recognize 
case 
added case analogous lemma case proof omitted 
chosen si proving si contradiction 
state main theorem 
theorem 
si proof 
proof follows previous lemmas induction 
basis induction assuming sk si lemmas 
solution produces item sets earley algorithm 

birth new automaton computer journal vol 
earley items added modified predictor precomputed 
precomputation take place way produce new variant lr deterministic finite automata dfa 
description earley parsing mentioned automata 
idea efficient deterministic automata earley algorithm recognizes derives empty string series predictor completer steps 
practical earley parsing aaaa aaa aa aa aaa aaaa 
lr automaton grammar 
shading indicates start state 
aaaa aaa aa aa aaa aaaa aaa aa aa aa aa aaa aaa aaaa aaaa 
lr dfa 
computer journal vol 
aaaa aaa aaaa aycock horspool basis general parsing algorithms dates back early 
traditional types deterministic parsing automata lr lalr applied great success earley parsers earley parsers 
conceptually effect precomputing groups earley items appear earley set reducing amount earley algorithm perform parse time 
note parsing algorithm described related earley parser employs precomputation 
shows lr automaton grammar 
construction lr automata treated compiler texts especially pertinent discussion 
lr automaton state consists lr items exactly earley item parent pointer 
assume earley parser uses lr automaton 
discuss detail sufficient think precomputing groups items appear described 
observe lr states appear earley set 
idea captured theorem 
function goto returns lr state reached transition lr state lr item earley set si si iff earley item si 
lr state write si mean si lemma 
added performing modified predictor step 
proof 
look length 
case 

true 
case 


xm 
constituent symbols terminals 
furthermore xl processing xm add xm processing add xm xm known added theorem 
lr item contained lr state si goto si 
proof 
part earley item parent pointer dot item 
lemma earley item added si 
result completer processing parent pointer look back current set si transitions attempted lr state si 
goto si 
treat theorem basis closure algorithm combining lr states appear iterating state mergers possible 
results new type parsing automaton aaa aa aa aaa aaaa nk aaa aa aa aaa aaaa 
splitting lr dfa state kernel non kernel states joined edge 
call lr dfa 
lr automaton lr dfa states lr dfa drawn 
original problem empty rules recur dfa earley parser 
happily 
recall problem began addition earley item si completer processed dot got moved 
dfa say state contains troublesome item 
items 
nullable value dot moved state theorem 
practical dfa computer journal vol 
elaborated finite automata earley parsers vexing implementation issue parser keep track parent pointers lr items belong 
leads complex inelegant implementations earley item represented tuple containing lists inside lists 
previously shown solve problem splitting states lr dfa slightly nondeterministic lr automaton :10.1.1.17.7812
exploits fact earley parser effectively simulating nondeterminism 
state splitting idea may extended dfa 
state dfa divided new states 

snk non kernel state 
contains lr items dot righthand side lr items derived 
exception start lr item non kernel state 
aaaa aaa aa aa aaa aaaa practical earley parsing aaa aa aa aaa aaaa 
earley parser accepts input split dfa 
sk kernel state 
lr items snk contained sk 
possible kernel state corresponding non kernel state vice versa 
shows state dfa split 
clearly information represented 
outgoing edges retained accordingly lr items new states 
state nk transition contains item state transition original state 
incoming edges go kernel state original edge coming state go state 
having transition kernel non kernel states gives slightly non deterministic automaton call split dfa 
earley parser simulates non determinism actions performed split dfa occurring original dfa 
advantage splitting states way maintaining parent pointers correct lr items easy 
items non kernel state parent pointer items kernel state 
case dot lr item state derived item dot case kernel state arrived state possessed parent pointer property 
applying result possible represent earley item simply split dfa state number parent pointer 
pair aa aa aaa aaaa 
split lr dfa 
aaaa aaa aaaa foreach state parent si goto state xi add parent si nk goto nk add nk si parent continue computer journal vol 
foreach completed state foreach pstate goto pstate add si nk goto nk add nk si 
pseudocode processing earley set si split dfa 
represents original earley items 
shows earley sets recoded split dfa 
earley parser split dfa 
pseudocode 
code assumes earley items si si implemented worklists items state parent pairs 
goto function returns state transition split dfa state grammar symbol 
absence transition denoted value 
single transition case goto may implemented simple table lookup 
completed function supplies list grammar rules completed state 
recall earley item added earley set 
goto completed computed advance 
earley item divides parts 
add earley items si resulting moving dot terminal symbol scanner 
second ascertain grammar rules complete attempt move dot corresponding non terminal parent earley sets completer 
special aycock horspool case exists unnecessary complete items current set si 
split dfa precomputed predictor 
split dfa earley parsing efficient practice show section changed underlying time complexity earley algorithm 
worst case split dfa state contain single item effectively reducing earley original algorithm 
having said aware practical example occurs 

reconstructing derivations point described efficient recognition practical earley algorithm demands able reconstruct derivations input 
finding method harder problem 
level argument new earley items consisting split dfa state parent pointer contain information standard earley parser just compressed form 
retaining information lr items dfa state reconstruct derivations standard earley parser 
course method unsatisfying extreme 
silly sift contents state parse time retain internal information state place 
method operates granularity states 
compounding problem lot activity occur single dfa state due rules 
consider running example grammar split lr dfa shown legal input derivation steps reconstructed earley set containing items 
solution parts 
follow earley add links earley items track information item pedigree 
contents earley items different standard earley parser worth elaborating 
earley items types links 

predecessor links 
item added result state machine transition sp part item sp pp add predecessor link sp pp 

causal links 
transition sp occur 
reasons 
transition terminal symbol 
record causal link absent 
transition state machine 
need store causal link predecessor link case 
transition non terminal symbol 
case added result rule completion state sc add causal link sc pc 
types links easy compute parse time 
table 
rule increase practical grammars due nnf conversion 
rules rules nnf rules ada algol delphi java modula pascal pilot second create split dfa original grammar equivalent grammar explicitly encodes missing information crucial reconstructing derivations 
deals non existence call normal form nnf grammar 
nnf grammar straightforward produce 
non terminal nullable create new non terminal symbol 
rule appears right hand side create rules account example rule rules 
event multiple nullable non terminals rule right hand side possible combinations enumerated 
rule right hand side empty right hand side populated non terminals replace left hand side corresponding non terminal 
instance 
new grammar running example aaaa aaaa aaa aaa aa aa aa aa aa aa computer journal vol 
aaa aaa aa aa aa aa size nnf grammar expected dependent rules original grammar 
took programming language grammars repositories see effect practice 
results shown table 
conversion nnf grammar double number grammar rules increases quite modest 
grammar comp compilers archive www com museum www org retro 
aaaa aaaa aaa aaa aa aa aa aa aa aa aaa aaa aa aa aa aa practical earley parsing aaa aaa aa aa aa aa aa aa aa aa aa aa aa aa aa conversion state machine construction usually occur compiler build time execution speed critical issue 
results section show convert grammar construct state machine lazily run time method substantially faster faster standard earley parser 
constructing split dfa nonterminals right hand side grammar rule act symbols dot moved immediately 
treated start symbols important note symbols treated distinct 
shows new split dfa 
states lr items states absent 
missing states items extraneous inferred 
explicit parser modified attach predecessor causal links items earley set new pseudocode processing earley set shown 
pseudocode assumes item associated set links set organized set predecessor link causal link pairs notation denote link item pseudocode constructing rightmost derivation 
ambiguous grammar may multiple derivations input shaded lines mark places choice alternatives may need 
choices may aa aa aa aa aaa aaa aa aa aa aa aa aaa aa aa 
new split lr dfa 
foreach item si state parent item goto state xi add parent si add link item parent si nk goto nk add nk si parent continue computer journal vol 
aaaa aaa aaa aa aa aaa aaaa foreach completed state foreach pstate goto pstate add si add link item si nk goto nk add nk si 
pseudocode processing earley set si creation predecessor causal links line continuation symbol 
heuristics user defined routines disambiguating rules elaborate means 
assuming disambiguation mechanism causal function returns item pointed causal link predecessor function returns predecessor item aycock horspool def item state parent item choose xn completed state output xn sym xn xn sym non terminal derive sym sym terminal item predecessor item causal item sym item predecessor item 
pseudocode constructing rightmost derivation 
aaaa derive derive 
trace alternative aa aa chosen 
associated causal item possibly 
initially invoked depends input input 
second argument earley item final earley set containing lr item appropriate 
tacit assumption identifies single earley item earley set combination case implementation pointers 
purpose derive output rightmost derivation non terminal 
way derive empty string may precomputed derive need output derivation sequence 
rules output fashion mapped back rules original grammar trivial operation 
traces operation earley items links 
nnf approach systematically remove rules original grammar apply earley algorithm resulting free grammar 
running example corresponding free grammar aaaa aaa aa equivalent grammar nnf formal sense substantial amount information lost 
example rule aaa recognized free grammar clear ways arriving original grammar ambiguity original grammar 
earley sets items input aa 
predecessor links represented solid arrows causal links dotted arrows 
earley items set reordered aesthetic reasons 
table 
spark timings 
time earley pep lazy pep precomputed encountered semantic actions associated original grammar rules invoked 
clearly having equivalent grammar imply honoring structure original grammar approach 
matter practical import users parser expect parser behave grammar user specified 
area try find better ways reconstruct derivations 

experimental results computer journal vol 
independently written implementations recognition reconstruction algorithms sections refer pep 
timings taken mhz pentium iii mb ram running red hat linux represent combined user system times 
implementation pep spark toolkit 
scanned parsed files python source code tokens total results shown table 
standard earley parser course versions pep split lr dfa lazily constructs state machine similar approach taken glr parsing 
timings reported section include time recognize input time construct rightmost derivation 
precomputed version pep runs twice fast standard earley algorithm lazy version faster 
pep time seconds bison time seconds 
pep versus bison timings java source files jdk 
darker circles indicate points plotted spot 
pep time seconds bison time seconds practical earley parsing 
pep versus bison timings faster machine memory 
implementation pep written allowing comparison lalr parsers generated bison yacc compatible parser generator 
lexical analyzer compiled gcc 
shows parsers compared parsing java source files jdk plotting sum user system times parser 
due clock granularity data points appear intervals points fell spot indicate point density darker color means points 
pep times 
looking cumulative time entire test suite pep times slower specialized lalr parser bison 
look pep affected computing environment repeated java test run time ghz pentium iv xeon gb ram running red hat linux 
results show individual pep times drop noticeably worst case computer journal vol 
measured 
cumulative time remained roughly pep times slower bison 
generality earley parsing compared lalr parsing considering pep worst time noticeable user excellent result 

implementations earley parsing algorithm easily handle rules simple modification predictor outlined 
precomputation leads new variant lr state machine tailored earley parsers finite automata 
timings show new algorithm twice fast standard earley parser fares compared specialized parsing algorithms 
supported part national science engineering research council canada 
greatly improved comments referees angelo 
earley 
efficient context free parsing algorithm 
phd thesis carnegie mellon university 
earley 
efficient context free parsing algorithm 
commun 
acm 
johnson 
yacc compiler compiler 
unix programmer manual th edn vol 

bell laboratories murray hill nj 

resolution parsing difficulties 
meta compilation 
phd thesis university surrey section pp 

van den brand sellink verhoef 
current parsing techniques software renovation considered harmful 
proc 
th int 
workshop program comprehension italy june pp 

ieee computer society press los alamitos ca 
graham 
new method compiler code generation 
proc 
fifth ann 
acm symp 
principles programming languages tucson az january pp 

acm press new york 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
bouckaert 
efficient parsing algorithms general context free parsers 
inform 
sci 
aycock horspool :10.1.1.17.7812
directly executable earley parsing 
cc th international conference compiler construction genova italy april 
lecture notes computer science 
springer berlin 
jacobs 
parsing techniques practical guide 
ellis horwood new york 
aho ullman 
theory parsing translation compiling volume parsing 
prentice hall englewood cliffs nj 
aycock horspool schr er 
accent compiler compiler 
gmd report german national research center information technology 
aycock 
compiling little languages python 
proc 
th int 
python conf houston tx november pp 

seminars reston va appel 
modern compiler implementation java 
cambridge university press cambridge uk 
fischer leblanc jr 
crafting compiler 
benjamin cummings menlo park ca 
graham harrison ruzzo 
improved context free recognizer 
acm trans 
program 
languages syst 
lang 
deterministic techniques efficient non deterministic parsers 
automata languages programming saarbr cken july august 
lecture notes computer science 
springer berlin 
mclean horspool 
faster earley parser 
proc 
th int 
conf 
compiler construction link ping sweden april 
lecture notes computer science 
springer berlin 
lang 
structure shared forests ambiguous parsing 
proc 
th ann 
meeting association computational linguistics vancouver computer journal vol 
canada june pp 

association computational linguistics morristown nj 
ferro dion 
efficient incremental parsing context free languages 
proc 
th ieee int 
conf 
computer languages toulouse france may pp 

ieee computer society press los alamitos ca 
alonso 
construction efficient generalized lr parsers 
proc 
nd int 
workshop implementing automata london canada september 
lecture notes computer science 
springer berlin 
aho johnson ullman 
deterministic parsing ambiguous grammars 
commun 
acm 
klint visser 
filters disambiguation context free grammars 
proc 
workshop parsing theory milano italy october pp 

technical report dipartimento di scienze dell informazione universit degli studi di milano 
heering klint rekers 
incremental generation parsers 
proc 
sigplan conf 
programming language design implementation portland june pp 

acm press new york 
