denali lightweight virtual machines distributed networked applications andrew whitaker marianne shaw steven gribble university washington andrew mar gribble cs washington edu goal denali safely execute independent untrusted server applications single physical machine 
enable developer inject new service third party internet infrastructure example dynamic content generation code introduced content delivery networks caching systems 
believe virtual machine monitors vmms ideally suited application domain 
vmm provides strong isolation default virtual machine directly name resource 
addition vmms defer implementation high level abstractions guest oss greatly simplifies kernel avoids layer attacks 
main challenge vmm application domain scaling number concurrent virtual machines simultaneously execute 
distinction denali existing vmms aggressive para virtualization techniques 
para virtualization entails selectively modifying virtual architecture enhance scalability performance simplicity 
para virtualization believe denali able scale order virtual machines existing vmms 
implemented prototype virtual machine monitor runs ring bare hardware 
addition built simple guest os tailored writing internet services 
improvements networking computing technology pushing application functionality wide area infrastructure 
computing model advantages services immediately available clients cumbersome software distribution services available accessed device services administered centrally administration maintenance sourced infrastructure service provider handled house 
today services maintained large organizations hotmail 
benefits infrastructure computing apply just small services 
popular vision share individual able inject new service internet infrastructure small fee 
example group game players deploy server connected point internet duration multi player game session 
example owners web service includes dynamically generated content inject static dynamic portions site content delivery network 
scenarios significant trust implications infrastructure providers trust consumers services services generally trust 
correspondingly mechanism exist enforce strong isolation services infrastructure security sense preventing service corrupting performance sense fairly multiplexing physical resources cpu memory network bandwidth simplest approach providing isolation run service physical machine 
addition isolating services allow service choose operating system software 
dedicating physical machines services wasteful eliminates possibility statistically multiplexing machine services 
cost ective believe services require ord cost entire physical machine 
statistically multiplexing services benefits statistically multiplexing services re enforced zipf law states frequency event proportional rank event compared events 
studies web servers documents web caches network services shown popularity driven zipfian distributions 
expect popularity distribution infrastructure services driven zipf law 
zipfian distributions significant implications 
requests go small number popular services 
second zipfian service popularity distribution shows cdf requests hypothetical services driven zipfian probability distribution 
services relatively unpopular non trivial fraction requests go unpopular services 
amount resources service requires typically proportional workload supports popular services require significant computational networking resources 
contrast large number services require scarcely resources motivating desire multiplex single computer reasons manageability 
fortunately moore law resulted commodity components enormous processing power storage network bandwidth 
single modern computer support large amount service tra specweb results show single cpu servers serve requests second requests day 
correspondingly believe isolation enforced introducing prohibitive overhead single computer host large number concurrent services hundreds thousands supporting aggregate throughput comparable single service computer 
denali supporting lightweight protection domains denali project seeks implement lightweight protection domains allow untrusted services execute inside network infrastructure 
particular denali protection domains properties strong isolation arbitrary code executing protection domain prevented perturbing code executing domain terms security performance 
scales protection domains application domain need execute hundreds thousands protection domains simultaneously single physical computer 
rapid swapping support workload consisting requests unpopular services act swapping service hasn executed long time fast 
believe services relatively independent sharing protection domains infrequent 
mechanism obtains properties cost increased sharing overhead acceptable 
argue virtual machine monitors vmms practical mechanisms provide strong isolation desired application domains 
research agenda includes mechanisms design techniques enhance ability vmm scale number concurrently executing virtual machines vms 
represents initial exploration agenda prototype implementation lightweight vmm system described section explore design possibilities 
section provides performance measurements micro macro benchmarks 
discuss section related section conclude 
argument vmms virtual machine monitor software layer virtualizes resources physical machine defining supporting execution multiple virtual machines vms 
interface exported vmm virtualized hardware software interface including cpu physical memory devices 
vmm typically executes directly physical hardware specifically level operating systems 
vm guest operating system provides customary set high level abstractions files network sockets 
believe vmms capable providing strong isolation virtual machines security performance sense 
vmms application domain demonstrate adequate performance number concurrently executing vms scales 
remainder section discuss isolation properties vmms introduce issues scale arise executing vms 
security isolation isolation objectives sandbox untrusted code prevent services directly reading modifying state services underlying protection system 
requirements pursuing stronger properties monitoring information flow eliminating covert channels 
oss compared vmms os shares protects high level abstractions built low level physical resources 
vmm protection abstraction 
exposing virtualized protected low level resources vm run os define high level abstractions applications 
application domain fundamentally di erent guided design protection conventional desktop time sharing operating systems 
denali unit protection service user little need share data services protection domains 
virtual machine monitors suited application domain directly address problems plague conventional oss simple static sharing policy 
vmms impose simple sharing policy data private virtual machine wishes share data network 
advantage approach obviates task constructing appropriate protection policy 
disadvantage increased cost sharing data applications 
believe trade justified application domain demands little sharing applications 
contrast principals conventional os users share data protected abstractions results complicated sharing policies allow jim read file allow sally programs network 
complexity expressing appropriate policy grows number principals protected abstractions 
os flexible allow policies expressed complexity implies practice di cult verify policy behaves author intentions 
removing protected sharing vmms avoid issue expressing complex policy 
protection abstractions 
vmms defer implementation high level abstractions file systems network stacks guest operating systems 
greatly simplifies implementation vmm positive security implications eliminates layer vulnerabilities conventional operating systems susceptible 
conventional os policy expressed terms high level abstractions files lowlevel resources disk blocks 
unfortunately expressing protection policy terms abstractions gives rise layer phenomena attacker accesses resources tunneling abstraction layer 
example attacker read raw disk blocks bypass file system monitor packet sni er capture password local account force core dump access protected memory data 
private namespaces 
exception network addresses names exposed vmm private vm 
result vm construct name refers resource vm 
vm compromised attacker access machine data assuming vmm mapping virtual physical resources implemented correctly 
global shared namespace vmm exposes set mac addresses virtual ethernet subnet 
security vulnerabilities exploited network scope project point network enabled application prepared handle malicious tra arrives network vm desires complete isolation need drop network tra comparison operating system typically exposes global namespaces set file names users share data 
global namespaces jeopardize security misconfigured poorly protected example attackers aliases symbolic links gain illicit access resources 
global namespaces access attacker gained supervisor privileges 
performance isolation term isolation typically refers security equally important aspect service isolation performance isolation evidenced denial service attacks 
goal provide approximate resource fairness services presence malicious services heavy network load 
aim provide precise guarantees sort required real time applications 
need support high level abstractions prevents oss providing strong performance isolation 
high level abstractions create contention points applications compete resources synchronization primitives 
leads effect resource cross talk applications resource management decisions interfere 
additional problem posed high level abstractions precise resource accounting di cult resources tied implementation abstractions 
example file bu er cache tcp ip socket bu ers consume memory resources aren charged particular application 
likewise network protocol processing performed context running process receiving process lead unfairness receiver live lock 
deferring implementation abstractions guest oss vmms need su er deficiencies 
show section virtual hardware devices vmm act queues vms resource accesses making possible vmm implement policies fair queuing stride scheduling 
vmm exposes hardware level resources fewer unaccounted resources conventional operating systems 
challenge scaling vmm goal denali support large number protection domains ciently 
vmms known introduce virtualization overhead confirm section performance degradation overhead modest today machines 
importantly issues scale arise increase number concurrently executing virtual machines 
example architectural level vms concurrently execute physical interrupt arrives vm associated running 
issues scale ect operating system design running hundreds vms implies executing hundreds tcp ip stacks physical processor implications timer design 
section describe exploit notion para virtualization address issues scale 
para virtualization exposes virtual architecture slightly di erent physical architecture 
di erences architecture driven improvements scalability reductions system complexity 
modifying architecture breaks backwards compatibility existing os code major disadvantage 
enables design virtual architecture operating system gives considerable latitude exploring issues scale 
para virtualization previous vmms including vm disco 
systems added combination instructions registers devices virtual architecture improve performance 
goal systems run legacy oss para virtualization minimized 
contribution explore architectural modifications regard backwards compatibility os code 
potential criticism para virtualization blurs line vmm conventional os 
true chose term virtual machine monitor find virtualized hardware useful metaphor implementing isolating properties discussed shared abstractions simple sharing model global namespaces 
discuss relationship denali previous systems section 
design implementation section describe denali architecture 
addition describe prototype vmm guest os utilize architecture 
para virtualization denali denali architecture instruction set allows virtual instructions execute directly physical processor 
denali architecture di ers underlying architecture number ways improve scalability reduce implementation complexity increase performance 
introduced purely virtual instructions counterpart physical architecture conceptually similar os system calls non blocking operate architectural level level os abstractions 
modified existing instructions semantics remove instructions physical architecture classify certain rarely instructions deprecated having undefined semantics 
added virtual registers lightweight mechanism passing data vmm vms registers mapped known region vm address space 
virtual devices export simplified architectural interface designed part minimize vm vmm boundary crossings 
describe architecture features heavily modified interrupt delivery eliminated virtual memory 
para virtualization scalability simple barrier scaling hundreds vms os execute idle loop useful 
vmm system loops waste cpu cycles degrading performance system 
denali introduces idle instruction allows vm yield control processor 
invoking vm remains unscheduled new virtual interrupt arrives 
invoking instruction vm promotes higher cpu utilization increases performance longer charged cycles 
idle instruction similar halt instruction puts physical machine sleep awaiting interrupt 
denali idle instruction enhances functionality timeout parameter allows vm bound sleep time 
effectively introduces yield primitive allows fine grained sharing processor vm waiting tcp timeout expire 
second scalability obstacle relates virtual interrupt dispatching physical interrupt arrives vmm raises virtual interrupt appropriate vm 
number vms grows increasingly physical interrupt destined currently running vm handling physical interrupts destined inactive vm common case 
possible policy context switch destination vm immediately physical interrupt arrival 
synchronous dispatch model preserves timely delivery interrupts unfortunately incurs large cost context switches result context switch thrashing number vms grow 
additionally synchronous interrupt delivery fails provide performance isolation presence denial service attack 
denali exposes asynchronous interrupt dispatch mechanism physical interrupts queued target vm runs 
multiple interrupts destined vm batched reducing vmm vm boundary crossings allowing guest os handle virtual interrupts order choosing 
importance batching grows number vms number queued interrupts increases 
modified semantics interrupts improve scalability 
physical hardware interrupts generally imply just happened 
denali virtual interrupt implies happened past possibly context switched 
semantic shift particularly useful implementation virtual timers 
os typically maintains ticks variable incremented hardware timer tick mimicking behavior vm requires raising virtual interrupt timer tick occurs vm isn running 
denali raises time passed virtual interrupt exposes number physical timer ticks system start virtual register 
eliminates additional vmm vm crossings determine elapsed physical time 
para virtualization simplicity hardware architectures complex 
precisely replicating physical machine requires vmm emulate hardware constructs privileged machine instructions virtual memory bios devices 
features necessary application domain 
provides opportunity remove modify features vastly simplifying vmm 
example architectural complexity presence non instructions instruction set 
instructions behave differently user mode kernel mode virtual machines execute physical processor user mode breaks backwards compatibility legacy code 
result vmms vmware plex require elaborate virtual memory protection techniques prevent instructions directly executed 
concerned backwards compatibility content instructions 
ects instructions undefined confined issuing vm 
radical architectural simplification denali expose virtual memory hardware 
denali virtual machines constrained single address spaces implying library oss similar exokernel :10.1.1.100.6047
believe change warranted denali targets small applications require internal protection mechanisms 
multiple protection domains application required language techniques employed pilot 
eliminated components virtual architecture 
bios primarily bootstrap conventional os determine system specific parameters 
replaced bios bootstrap functionality simply having vmm load vm image memory process loaded os 
system parameters cpu speed size virtual physical memory accessible read virtual registers 
final set architectural simplifications relate devices 
denali exports small number generic devices large number heterogeneous devices systems currently support network interface card serial de commonly popl enable disable interrupts 
replaced functionality virtual register serves interrupt enabled flag 
eliminates vmm vm crossing virtual interrupts enabled disabled 
bios contains power management functions denali expose power management vms 
virtual machine monitor arrows represent control data flow 
components virtual keyboard shown 
vice timer generic keyboard console 
device interfaces streamlined minimize number vmm vm crossings 
example transmitting number ethernet frames requires single virtual instruction 
contrast existing physical nics require dozen instructions implement functionality 
additionally denali virtual devices require initialization startup simplifying guest os device driver implementation reducing os boot time 
vmm implementation prototype vmm implementation called runs ring bare hardware 
event driven non blocking thread owned vmm idle thread 
currently runs uniprocessors designed extensible smps 
illustrates major components 
lowest layer system support libraries flux oskit 
oskit hardware abstraction layer simplify interactions devices page tables interrupt vectors bios 
small portion oskit libc library dynamic memory management interacting console 
oskit larger libraries processes network stacks similar abstractions 
physical resources exports denali architecture vm 
core simple round robin cpu scheduler coupled timer prevent vm stealing cpu improving scheduling policy topic 
scheduler idle table contains list idle machines invoked idle instruction described section 
wakes idling vm virtual interrupt arrives idle timeout value exceeded 
instruction emulator implements instructions directly executed vm including instructions halt instruction terminates vm 
instruction emulator implements virtual instructions counterpart architecture 
denali virtual instructions mapped illegal opcodes traps emulates 
moment virtual instruction idle instruction 
emulates ethernet subnet machine mac address indistinguishable physical machine 
maintains receive transmit fifos behalf vm emulate fifos exist real nics 
lower layer packet scheduler virtual ethernet switch perform network multiplexing demultiplexing respectively 
currently packet scheduler uses simple round robin scheduling policy 
plan explore sophisticated fair queuing policies 
approach memory management statically allocate physical pages active virtual machine 
static allocation ine cient simple implement avoids worstcase thrashing behavior 
date static memory allocation proven reasonable application domain web server vm requires megabytes memory allows concurrently active vms physical machine gigabyte physical memory 
protection virtual machine physical address space works fashion conventional os 
maintains page tables virtual machine address space visible vm contains vm accessible region second region accessible vmm 
includes support supervisor virtual machine responsible bootstrapping vmm 
supervisor vm access privileged vmm calls create destroy vms 
currently user physical access machine issue supervisor calls 
sophisticated security policies desired straightforward replace enhance supervisor vm additional functionality 
example guest os developed simple guest os named provides high level abstractions applications shields applications details appears violate namespace isolation advocated section argue isolation ected protection statically mapped page table entries 
entries reside vmm address space mapped vm protected vm access irrelevant 
exposing vmm address space vm eliminates tlb flushes vmm vm crossings vastly reducing virtualization overhead 
denali virtual architecture 
abstractions provided tcp ip stack threads package subset libc library bsd sockets interface 
tcp ip stack port alpine user level tcp ip infrastructure 
alpine consists freebsd stack support library emulates bsd kernel environment 
modified support library denali interrupt timer models linked stack device driver denali virtual nic 
contains threads package includes basic primitives fork kill locks condition variables 
threads non preemptive simplified development bsd tcp ip stack assumes non preemptive thread environment 
thread performs timed sleep operation thread scheduler adds sleep duration priority queue 
runnable threads scheduler passes smallest sleep duration denali virtual idle instruction 
supported subset libc enables basic console printf scanf string manipulation random number generation memory management 
majority functions ported oskit libraries 
functions modified interact denali virtual hardware example malloc reads size virtual physical memory virtual register 
progress denali progress pieces functionality implemented 
highest priority implementation stable storage functionality 
despite lack disk system supports non trivial web server vm describe section 
resource management policies prototype vmm overly simplistic 
packet cpu schedulers simple round robin scheduling policies 
scheduler accounts amount resources round robin iteration packet size network tra quantum cpu scheduling 
schemes su cient prevent starvation suitable enforcing robust performance isolation 
working incorporate existing scheduling algorithms fair queuing stride scheduling 
vmm execute vms fit physical memory implemented swapping idle vm disk 
addition supporting large number inactive virtual machines require changes guest os 
example tcp stack registers timers fire milliseconds milliseconds 
left unmodified force inactive virtual machine swapped times second regardless pending connections 
elements conventional os modified improve scalability system 
measurements section describe set microbenchmarks application level benchmarks designed show performance prototype vmm applications executing example guest operating system 
experiments described ran vmm vms mhz pentium kb cache gb ram intel pro pci gigabit ethernet cards connected intel ethernet switches 
ported version intel pro device driver flux oskit linux driver glue substrate 
byte mtus ethernet packets 
generate workloads server benchmarks mixture mhz pentium mhz pentium iii machines ensuring workload generation clients bottleneck system 
micro benchmarks set measurements attempt characterize performance vmm independent application level behavior 
context switch time measured time context switch virtual machines 
quantify ect cache pollution considered workloads worstcase test cycles large memory bu er context switch best case test touch memory context switches 
preemption disabled tests 
describes context switch time function number virtual machines 
worst case workload context switch time starts microseconds single virtual machine increases microseconds multiple vms 
best case workload context switch time starts microseconds single virtual machine exhibits small peaks exhaust capacity caches 
taken numbers suggest denali context switch time manageable 
worst case time microseconds small relative thousands microseconds required context switch time worstcase context switch time memory intensive workload tops microseconds 
best case context switch time workload touch memory tops microseconds 
tcp ip protocol processing refer 
addition context switch time devoted simply entering exiting kernel suggests conventional os demonstrate similar performance 
control flow vm vmm vm vmm control flow transfers happen situations 
supervisor vm invoke privileged system call vmm executing int instruction 
second vmm trap emulate privileged instructions happens vm issues programmed inb outb instructions 
result control vectored kernel address specified interrupt descriptor table measured transfer time vms null system call generic programmed instruction 
null system call slightly cheaper programmed instruction cycles system call versus cycles pio 
retrospect int instruction control transfers inb outb provide slightly better performance 
fortunately performance di erence noticeable practice 
packet processing overhead shows cost packet processing application level udp packet transmission reception byte packets 
transmitted packet traverses tcp stack processed guest os device driver 
driver signals virtual nic pio resulting trap vmm 
inside vmm virtual nic implementation copies packet guest os tx fifo 
pio instructions raise general protection fault executed user mode 
vmm decided transmit packet physical device driver invoked 
packet reception essentially follows path reverse 
physical nic receives packet raises interrupt causing device driver execute 
driver hands packet vmm appropriate virtual nic rx fifo 
virtual nic ready hand packet vm vmm copies packet guest os raises virtual interrupt 
guest os device driver processes packet gives tcp stack eventually resulting packet handed application 
indicated physical device driver tcp stack incur significantly cost vmm 
handling received packet physical device driver represents total packet processing costs small large packets respectively 
non trivial portion cost due flux oskit interaction pic plan modifying oskit cient apic 
tcp stack represents small large received packet processing time respectively 
course possible optimize stack guest os reduce overhead 
transmit path currently incurs packet copies vm vmm boundary crossing may possible eliminate copies virtual memory copy write techniques 
receive path incurs cost packet copy mbuf deallocation flux oskit vmm vm crossing 
mbuf deallocation attempts coalesce mbuf memory back global pool fairly costly 
additional optimization believe lower cost 
application level benchmarks second set measurements gathered measurements network applications running top guest os 
measurements show things 
absolute performance numbers obtain comparable conventional operating system linux overhead virtualization prohibitive 
second performance scale number virtual machines running single system 
scaling numbers start plan exploring scaling issues detail scale device driver appears expensive transmit path cost interacting nic included numbers interaction asynchronous largely driven nic 
packet processing overhead timelines illustrate cost cycles processing packet broken various functional stages packet reception packet transmission 
pair numbers represents number cycles executed stage byte byte packets respectively 
far roughly vms 
tcp ip performance measure tcp ip throughput latency wrote simple application opens tcp connection remote server sends data quickly possible 
remote server calculates aggregate tcp ip throughput measured vms 
measure latency ping supervisor machine throughput test progress 
results tests shown 
tcp ip throughput reaches peak value mb virtual machines 
low value single vm due part tcp dynamics tcp ip stack runs vm system cross vmm vm boundary sending data response ack 
overhead optimized pushing knowledge tcp vmm 
fortunately ects masked multiple vms vmm maintains outbound transmit fifo virtual machine means vmm overlap packet transmission vm computation 
bandwidth drop vms due cache contention size tcp socket bu ers exactly half cache 
supervisor vm running baseline ping time microseconds 
additional tcp intensive virtual machine caused ping time increase roughly milliseconds 
suggests latency may prove problematic bandwidth running large number concurrent vms additional techniques reducing vm compute time may required 
eliminating unnecessary memory copies prove beneficial respect 
explicitly consider fairness vms test 
informally observed low variation bandwidth vms 
tcp throughput latency vs vms top graph shows average tcp throughput set virtual machines 
throughput reaches peak value mb vms bottom graph shows latency increases roughly milliseconds virtual machine 
web server performance final set benchmarks test performance web server running top 
implemented simple multi threaded server dispatches incoming requests pre allocated thread pool 
web server serves static content file system perl script embed document tree unix file system set source files statically compiled application 
httperf tool running linux generate workloads benchmarks 
tool subjected web server di erent workloads varying rate generated requests measuring throughput latency error rate server dif web server performance function ered load number concurrent vms graphs illustrate throughput connections megabits web server download latency web server error rate web server 
small document workload average document length bytes large document workload average document length bytes 
ferent loads 
varied number simultaneously running web server vms reported numbers represent aggregate load summed vms 
small document workload consists repeated requests set small html files averaging bytes including headers 
large document workload consists repeated requests single byte pdf file 
illustrates results 
small document workload single vm achieved peak sustained response rate documents second 
rate greatly surpasses saturation point popular web servers including apache fair comparison apache fully featured server 
large document workload single vm achieved peak sustained data throughput mb commensurate peak aggregate tcp throughput observed section 
scaled number vms noticed aggregate bandwidth served entire system dropped observed bandwidth fairly split vms 
small document workload aggregate throughput vms mb compared mb single vm case 
large document workload vm aggregate throughput mb compared mb single vm case 
believe drop performance due combination context switching overhead perturbations tcp dynamics context switching machines proving hypothesis subject 
comparison reran benchmarks web server running linux 
compiled server linux library implementing system call api 
small document workload observed peak response rate documents second large document workload measured sustained throughput mb fact linux achieves slightly higher tcp ip throughput demonstrates overhead virtualization introduced relatively small 
directions discussed section short term directions pursuing including adding disk support swapping idle vms exploration sophisticated resource management algorithms exploring issues scale depth 
longer term research agenda 
believe lightweight virtual machines tool enables powerful new applications plan explore 
inserting services os vmms provide layer indirection guest os hardware facilitates insertion new system services transparently os 
services interest checkpointing migration vms uniquely suited provide os application state accessible vmm 
os state file descriptors socket bu ers captured vmm memory disk footprint vm 
additional state captured virtual hardware state requests queued virtual disk fifos 
vmms provide opportunity hot swap virtual devices transparently vm 
example generic virtual block device interface mapped conventional hard disk raid array distributed disk petal 
potential services include numa memory management fault tolerance secure logging 
virtual machines content distribution significant challenge internet services dealing client load vary order magnitudes 
problem flash crowds web motivated replication mechanisms content delivery networks proxy caches unfortunately systems handle static data date 
study wolman web documents dynamically generated amenable systems 
propose vmms inside cdn generate dynamic content edge network 
addition providing improved availability replication cdns mitigate wide area network failures significant cause service outages 
vmms enforce security performance isolation allowing service providers provide guaranteed service levels clients 
lightweight vms cdn host large volume dynamic content vm migration enable demand loading active content cdns 
virtual clusters vmms introduce possibility emulating virtual clusters top physical cluster workstations 
system service author provide collection processes execute collection virtual cluster nodes 
cooperating vmms executing physical node cluster map service virtual machines physical resources cluster 
enable better multiplexing large set services bursty request streams 
relative load virtual cluster increases system increase virtual cluster relative share physical resources 
anticipate having vmms interact load balancing switches order map externally visible ip addresses virtual clusters 
ability migrate vms loadbalancing mechanism virtual clusters 
popular virtual clusters map physical machines virtual machines moved take advantage idle resources 
migration enable utilized machines switched positive repercussions power conservation 
related operating system improvements projects sought improve os monitor isolate untrusted code 
privilege subsetting defines restricted rights untrusted code distinct normal user privileges 
provides mechanism isolate untrusted code problem expressing appropriate policy specifically addressed 
proposals typically address layer attacks vulnerabilities due global namespaces 
address file system global namespace vulnerabilities oss provide system call contain process subtree global file system 
theory additional os extensions provide similar containment shared namespaces pids network addresses 
eliminate layer vulnerabilities os retain significant complexity associated high level abstractions 
example shown possible cached file descriptors break ed namespace 
systems propose mechanisms supplement os monitor 
janus allows user level server intercept systems calls untrusted processes 
software wrappers provide better performance pushing interception layer kernel 
systems provide mechanisms address problem appropriate policy 
unfortunately oss hundreds system calls implying policy complex 
additionally systems require knowledge application behavior virtual machines 
promising approach isolation inferring application behavior system call traces machine learning techniques 
approach confines applications typical patterns behavior doesn respond non malicious changes application behavior 
virtual machines provide ability isolate untrusted code knowledge application semantics 
seeks isolate untrusted code virtual desktop inside windows 
implemented inside conventional operating system security limited high level abstractions global namespaces 
virtualizing layer operating system abstractions vmms secure 
fluke proposes recursive vm model parent re implement os functionality behalf child processes 
denali virtualize layer os abstractions fluke virtual architecture includes high level ipc calls 
virtualizing level hardware avoid imposing fixed set protection abstractions layer vulnerabilities 
server multimedia systems led os improvements performance isolation 
resource containers demonstrates os abstractions resource management processes threads poorly suited applications needs 
differs resource management os abstractions precise resource accounting tractable accurate 
limitation vms resource principals span multiple protection domains making di cult common service dns resolver shared vms 
virtual services notable tracking resource usage server boundaries 
su ers significant implementation complexity relies intercepting system calls subject caveats janus 
proposals fair resource allocation policies exist fair queueing network bandwidth stride scheduling cpu allocation cello framework disk bandwidth allocation 
complementary denali plan incorporating policies vmm 
software virtual machines software virtual architectures java microsoft common language runtime proposed isolate untrusted code 
running multiple applications single vm problems running multiple applications os 
libraries java class library provide shared abstractions subverted layer attacks 
trend extensible security architectures means security policy expressed places host os software virtual machine 
resource management single vm complicated ability share resources pointers 
alternatively application isolated software vm similar hardware vm architecture 
software vms require complex software runtimes case java led numerous security vulnerabilities 
believe vmm nearly identical underlying hardware simpler build robust 
intrigued possibility transparent instruction set mapping done transmeta crusoe processor 
small kernel architectures vmms served foundation security kernels 
initiative sought create secure virtual workstations running vmware 
di ers orts aim provide scalability isolation 
assumes weaker threat model concerned covert channels vms 
denali similar respects microkernel operating systems 
denali virtual machines viewed single threaded applications low level microkernel 
main focus microkernel research pushing os functionality shared servers susceptible security vulnerabilities discussed section 
may possible remove shared servers microkernel system addresses issues related scaling large number untrusted applications 
hand fast ipc major focus research data sharing requirement applications domain 
eliminate high level abstractions enable os extensibility 
enables optimizations physical names discourages isolation resources exist inside single globally visible namespace 
necessitates complex mechanisms download protection policy high level abstractions low level exokernel protection mechanisms 
virtual name spaces exposed vmm facilitate rapid swapping virtual physical name bindings transparently modified vmm 
swapping applications di cult exokernel system way transparently remap library os address translations 
nemesis shares goal eliminating application resource crosstalk 
nemesis adopts similar approach pushing kernel functionality including protocol processing device drivers application space 
systems differ nemesis designed sandbox untrusted code nemesis applications share global file systems single virtual address space 
virtual hosting platforms numerous commercial open source products provide support virtual hosting including apache virtual hosts solaris resource manager 
conventional operating system application provide degree isolation vmm 
commercial vmms provide virtual hosting services vmware esx server ibm vm system 
allowing change virtual architecture design os believe denali scale vms similar hardware products 
addresses resource management face large number concurrent vms aware publications subject related products 
argued virtual machine monitors suited task hosting untrusted applications single physical machine 
vmms defer implementation high level abstractions sophisticated protection policies guest operating systems 
monitor simpler facilitates strong security performance isolation cost increased sharing overhead 
scale large number virtual machines denali utilizes para virtualization entails selectively modifying virtual architecture 
para virtualization techniques designed vmm guest operating system capable supporting non trivial web server application serve requests second 
denali progress far demonstrates possible achieve strong isolation reasonable performance virtual machine monitor 
demonstrated issues impact scaling number concurrent virtual machines demand reconsideration virtualized architecture design virtual architecture guest operating systems 
acharya 
parameterized behavior classes confine untrusted applications 
proceedings ninth usenix security symposium august 
adl tabatabai lucco wahbe 
cient language independent mobile programs 
proceedings symposium programming language design implementation may 
anderson culler patterson 
case networks workstations 
ieee micro february 
balfanz simon 
simple security model connected desktop 
proceedings th usenix windows systems symposium august 
banga druschel mogul 
resource containers new facility resource management server systems 
proceedings rd usenix symposium operating system design implementation february 
berman selberg 
process specific file protection unix operating system 
proceedings winter usenix conference 
breslau cao fan phillips shenker 
web caching zipf distributions evidence implications mar 
thomas bressoud fred schneider 
hypervisor fault tolerance 
acm transactions computer systems 
bugnion devine rosenblum 
disco running commodity operating systems scalable multiprocessors 
proceedings sixteenth acm symposium operating system principles october 
chandra dahlin gao 
wan service availability 
proceedings third usenix symposium internet technologies systems usits san francisco ca usa march 
peter chen brian noble 
virtual better real 
proceedings workshop hot topics operating systems schloss germany may 
cowan beattie hartman pu wagle gligor 
subdomain parsimonious server security 
proceedings systems administration conference december 

origin vm time sharing system 
ibm journal research development 
demers keshav shenker 
analysis simulation fair queueing algorithm 
proceedings acm sigcomm conference austin tx september 
peter druschel gaurav banga 
lazy receiver processing network subsystem architecture server systems 
proceedings second symposium operating systems design implementation seattle wa usa october 
ely savage wetherall 
alpine user level infrastructure network protocol development 
proceedings third usenix symposium internet technologies systems usits march 
engler kaashoek toole :10.1.1.100.6047
exokernel operating system architecture application level resource managment 
proceedings fifteenth acm symposium operating system principles december 
redell pilot operating system personal computer 
proceedings th acm symposium operating systems principles sosp pages 
leslie design implementation operating system support distributed multimedia applications 
ieee journal selected areas communications 
accetta mach new kernel foundation unix development 
proceedings usenix summer conference 
kaashoek application performance flexibility exokernel systems 
proceedings sixteenth acm symposium operating system principles october 
ford back benson lepreau lin shivers 
flux oskit substrate kernel language research 
proceedings th acm symposium operating systems principles st malo france october 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
proceedings second symposium operating systems design implementation october 
fraser badger feldman 
hardening cots software generic software wrappers 
proceedings ieee symposium security privacy 
ghosh 
learning program behavior profiles intrusion detection 
proceedings workshop detection network monitoring 
gold linde schaefer ward 
security retrofit vm 
proceedings national computer conference 
afips press june 
goldberg wagner thomas brewer 
secure environment untrusted helper applications 
proceedings sixth usenix security symposium july 
goldberg 
architectural principles virtual computer systems 
phd thesis harvard university 
goldberg 
survey virtual machine research 
ieee computer magazine june 
ioannidis bellovin 
sub operating systems new approach application security 
university pennsylvania technical report ms cis 
karger mason kahn 
retrospective vax vmm security kernel 
november 
lawton 
running multiple operating systems concurrently ia pc virtualization techniques 
www plex org research txt 
lee thekkath 
petal distributed virtual disks 
proceedings seventh international conference architectural support programming languages operating systems october 
mosberger jin 
httperf tool measuring web server performance 
proceedings workshop internet server performance madison wi june 
popek kline 
verifiable secure operating system software 
afips conference proceedings june 
shin kandlur 
virtual services new abstraction server consolidation 
proceedings usenix annual technical conference san diego ca usa june 
robin irvine 
analysis intel pentium ability support secure virtual machine monitor 
proceedings th usenix security symposium denver august 
shenoy vin 
cello disk scheduling framework generation operating systems 
proceedings joint international conference measurement modeling computer systems sigmetrics madison wisconsin usa june 
lim 
virtualizing devices vmware workstation hosted virtual machine monitor 
proceedings annual usenix technical conference boston ma usa june 
vmware vmware virtual machine technology 
www vmware com 
waldspurger weihl 
stride scheduling deterministic proportional share resource management 
technical memorandum mit lcs tm june 
wallach balfanz dean felten 
extensible security architectures java 
proceedings sixteenth acm symposium operating system principles october 
wolman voelker sharma cardwell brown karlin levy 
organization analysis web object sharing caching 
proceedings nd usenix conference internet technologies systems usits boulder oct 
