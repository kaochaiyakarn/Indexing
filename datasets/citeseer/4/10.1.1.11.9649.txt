quantifying energy consumption pocket computer java virtual machine keith farkas jason flinn back dirk grunwald jennifer anderson western research lab compaq computer university ave palo alto ca 
keith farkas compaq com examine energy consumption state art pocket computer 
data acquisition sys tem measure energy consumption itsy pocket computer developed compaq computer palo alto research labs 
showing energy usage characteristics itsy differ markedly notebook computer 
expect flexible software environments increasingly pre valent pocket computers consider applications run ning java environment 
particular explain java design tradeoffs applicable pocket computers quantify energy costs 
design options considered workloads studied find maximum change energy 

advances battery technology low power circuit de sign meet energy demands mo bile computers 
critical software running devices designed minimize energy consumption 
designing energy efficient software requires software developer understand energy usage characteristics computer software run energy impact software design de 
seek software com understanding issues ing energy usage high performance pocket computer examining energy impact options jason graduate student carnegie mellon university nn cs cmu edu graduate student utah cs utah edu dirk sab university colorado boulder wald cs colorado edu jennifer vmware 
vmware com 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial age copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigmetrics santa clara california usa acm design java run time environment 
developers understand energy usage character pocket computer developing software significant energy costs may incurred result software system resources 
example speed system run affects energy consumption developers may want judiciously choose system speed execute applications 
decision take account nature ap plications low power modes offered system energy cost system idle 
addition en ergy power usage pocket computers differ markedly notebook computers 
developers may need re evaluate decisions notebooks port ing applications pocket computers 
java similar programming environments essen tial enablers mobile computing owing platform neutrality flexibility 
personal mobile computers people carry run small set core applications web browser mail client potentially larger set applications downloaded wireless connection specific purpose virtual tour guide 
core applications stored native binary format computer far simpler distribute single copy mobile application require distribu tion point maintain copy application compiled platform existence 
platform neutral ity task migrating applications new generations platforms easier 
reasons discuss tradeoffs design java runtime en vironment quantify energy costs tradeoffs 
evaluate design kaffe java virtual ma chine jvm quantitatively measuring energy cost important design options 
discussed energy meas itsy pocket computer state art pocket computer developed compaq computer ation palo alto research labs 
reviewing important energy concepts describing itsy pocket computer explaining methodology 
examine energy usage characteristics itsy pocket computer section energy impact java design options section 
itsy pocket computer version 
background section background material de scribe methodology 
energy background normal usage pocket computers run batteries provide finite amount energy 
energy measured joules consumed device seconds equal ftp instantaneous power measured watts 
sequence instantaneous power meas taken seconds apart energy consumed may estimated pi 
average power sequence approximately pi 
considering instantaneous power note components pocket computers today memories microprocessors implemented cmos 
components instantaneous power con sume proportional voltage sup component frequency clock driving component 
itsy pocket computer itsy pocket computer flexible research platform developed enable hardware software research pocket computing 
small low power high performance hand held device highly flexible interface designed en courage development innovative research projects novel user interfaces new applications power man agement techniques hardware extensions 
versions itsy pocket computer developed differences versions small changes hardware 
changes little impact results report 
versions low power strongarm sa microprocessor 
fur ther versions small high resolution display offers pixels mm pixel pitch levels gray 
versions include touchscreen micro phone speaker serial irda communication ports newest version study integrated usb port 
itsy architecture support mbytes dram mbytes flash memory 
flash memory provides persistent storage operating system root file system file sys tems data 
itsy provides daughter card interface allows base hardware easily extended 
version unit basis mbytes dram mbytes flash memory 
mother daughter itsy system architecture version 
powered size aaa batteries supply watts maximum demanded itsy 
shows picture version unit shows block diagram itsy architecture 
system software includes monitor port linux operating system version 
monitor allows user adjust certain system parameters run applications directly top hardware download boot operating system 
linux provides support networking file systems multi user management 
applications developed number programming environments including windows java 
applications take advantage available speech synthesis speech recognition libraries 
conventional pair alkaline aaa batteries itsy computer run hour high power mode playing mpeg video popular action game doom 
system idle processor clock set mhz fastest speed integrated power management modes stall processor batteries hours 
time increases hours processor idle mhz slowest speed week system sleep mode 
capabilities itsy stark contrast existing pocket computers palm pilot 
processing capability itsy supports speech synthesis speech re cognition high quality mpeg video playback audio codecs advanced audio processing 
large dynamic memory allows applications developed rapid pro environments enable mobile applications application reuse 
flash file systems allow complex systems developed configured 
measuring power total energy measure instantaneous power consumed itsy measure voltage drop precision res located power circuit 
power drawn current flows battery external voltage supply sense resistor computer 
current induces differential voltage resistor current may calculated 
vs 
power consumed may calculated multiplying current voltage supplied computer 
measure voltages differential amp data acquisition daq system itsy powered external voltage supply 
block diagram differential amp itsy 
itsy data components lcd acquisition processor system jl 
computer differential amp collection data block diagram showing infrastructure measure power consumed itsy 
showing components itsy 
amplifiers minimize error introduced meas electro magnetic noise limited precision daq system call output amplifiers vo amp re spectively 
output amplifier connected analog inputs daq system 
instructed daq system reads voltage specified analog input con bit binary value forwards host computer 
host computer stores readings sub sequent analysis 
instructing daq system read voltage input channel regular time intervals determine voltage varies time 
exper iments sampling rate times second 
time profiles voltages compute time profile power application runs itsy total energy consumed time 
examine power number micro benchmarks applications written java workloads described sections respect 
determine power profile workload measure time required execute workload select relevant set voltage measurements data collected daq system 
micro benchmarks sa cycle counter count number clock cycles execute benchmark java applications time function built csh command shell 
synchronize collection voltages start execution workload workload begins executing toggles general purpose input output pins 
pin connected external trigger daq system toggled causes daq system recording meas 
connection labeled gpio 
daq system voltage meas time measurement accuracy decreased quickly switching inputs fol lowing strategy 
workload itsy measure supply voltage seconds re cord average value 
configure daq system measure voltage drop sense resistor en run workload 
application completes predetermined average supply voltage compute instantaneous power time step dur ing execution workload 
strategy increased error measurements compared existed able measure voltages simultaneously 
estimate error supply voltage measurement measured vari ation supply voltage du ng replay workloads considered 
resulting range values varied mv mean value 
second source error corresponds error induced measurement equipment noise 
estimate error measured variation seconds itsy executing benchmark constant load 
measurement gave mv variation mean 
net effect errors error watts experiments yields error joules 
values represent maximum error see smaller variation measurements 

component characterization section examine energy usage ics itsy pocket computer system important subsystems 
system characterization methodology described previous section obtained power profiles shown fig ure 
profile shows power consumption itsy workload comprised booting operating system java virtual machine times running java applications single virtual machine 
application lowered raised clock speed processor system 
note ad clock speed produces clear power reduction running calculator application drawing package produces clear power usage patterns 
system left idle period time short power spike occurs probably due garbage collection 
pro file workload shows considerable variability power demands itsy characteristic shared large number profiles gathered 
itsy dynamic range power demand larger reported previous studies notebook computers discuss reasons difference section 
subsystem characterization understand power consumption processor display memory subsystems itsy pocket com puter measured power energy consumption number micro benchmarks 
micro benchmark dis powered unused hardware components possible 
ran directly top hardware eliminate operating system effects 
due space constraints discuss subset results complete discussion 
power energy consumed benchmarks table 
column lists benchmarks columns power energy consumed benchmarks run itsy 
benchmark report power energy consumption clock speeds slowest possible speed mhz columns mid point speed mhz columns fastest possible speed mhz columns 
report energy benchmarks perform task rebooting itsy having java boot times ii tl el varying clock speed drawing garbage drawing collector calculator drawing app user input time seconds power profile itsy pocket computer boots jvm runs applications 
specific completion condition say executing fixed number additions 
applications specific com condition power meaningful 
table provides data corresponding powering processor volts normal voltage volts reduced voltage voltage level indicated column 
note data operation lower supply voltage illustrate benefits voltage scaling strongarm processor rated operation lower voltage level 
point comparison column lists power consumed subset benchmarks run ibm thinkpad notebook computer 
notebook mhz pentium processor mbytes memory 
measured power consumption technique similar itsy 
processor display subsystems consider sleep micro benchmark row 
benchmark puts system mode dram refreshed constant rate clock speed itsy impact power 
compar ison idle mode benchmark row power consumed itsy lower clock frequencies higher ones 
relationship exists idle mode processor pipeline stopped chip aux components clocked 
components turn consume power proportional clock frequency 
consider busy wait micro benchmark processor executes busy wait loop seconds addition benchmark processor executes iterations compute intensive loop 
observe difference power consumption benchmarks compare rows 
cases difference due differences instruction types executed benchmarks 
expect busy wait addition benchmarks high power test processor execution itsy thinkpad processors stall memory 
table note maximum power consumption thinkpad row mw mw itsy row benchmarks 
comparing values idle power consumption row see thinkpad consumes power high power test itsy consumes power test 
large percentages itsy suggest processor exhibits wider dynamic range power consumption 
fact helps account itsy dynamic power demand greater notebook 
consider execution busy wait benchmark time lcd computer turned row 
thinkpad computer observe turning lcd consumes depending brightness backlight itsy lcd consumes average mw 
relative high power tests turning lcd increases power consumption thinkpad doing increases itsy power consumption 
version itsy backlight similar version itsy pocket computer estimate maximum power consumption lcd mw mw 
backlight increase high power test power 
expect backlight pocket computer infrequently notebook continuously 
power consumption issue pocket computer 
addition micro benchmark show power energy performs task specific completion condition 
note higher clock rates itsy consumes power consumes energy 
trend suggested benchmarks energy reported 
lowering clock frequency reduces power usage task takes longer complete 
energy remains increases slightly lower clock frequencies 
voltage reduced clock frequency drop power consumption dominates corresponding increase execution time 
illustrate effect consider addition benchmark 
note processor voltage reduced row row frequency kept constant energy consumption drops sl energy savings achieved benchmark practice achieve reliable operation processor clock speed usually reduced supply voltage reduced 
practical illustration energy savings brought voltage scaling energy sav micro benchmark sleep mode idle mode idle mode lcd enabled busy wait busy wait lcd enabled processor itsy power watts specified mhz voltage normal normal normal normal reduced normal reduced normal reduced energy joules specified mhz addition loop memory test instruction cache mmu write buffer data cache enabled cache read test normal cache read test normal cache write test normal cache write test normal memory test instruction cache enabled cache read test normal cache read test normal cache write test normal cache write test normal thinkpad power watts table average power energy consumption select micro benchmarks running ibm thinkpad notebook computer itsy pocket computer 
voltage supply itsy processor normal reduced 
ings obtained operating volts mhz volts mhz 
case energy consumed 
comparable energy savings occur busy benchmark compare row row case strongarm failed operate low voltage level highest clock speed lcd turned 
memory subsystem set benchmarks measure memory system demands 
divided subsets 
subset rows enables aspects memory system second subset rows enables instruction cache 
measurements itsy show disabling components memory system disabling mmu little impact power demands 
memory benchmark reads writes mbytes data 
tests designed working set fit chip cache explicitly fit cache 
itsy fold difference energy read test data caching enabled row disabled row demonstrates benefits data caches additional energy proportional additional time needed run benchmark 
interesting note takes energy conduct read tests cache disabled compare row row 
benchmarks cache provides benefit disabling execution time reduced significantly power consumption increased small amount 
comparing power consumption itsy executing memory benchmarks note itsy power con sumed thinkpad memory system little impact power consumption 
expressed fraction power consumed high power tests power variance memory benchmarks thinkpad itsy variance depending clock frequency 
differences fractions computers due ratio power consumed processor consumed memory system ing larger thinkpad itsy 
variations power consumed memory system greater impact power consumption itsy 
consequently memory behavior applications varies execution applications run ning pocket computers itsy exhibit wider range power demands run notebook computer thinkpad 
discussion summary itsy pocket computer exhibits wider range dynamic power demand think pad computer 
wider range due effects processor itsy exhibits wider range power demand power consumption memory system accounts greater fraction power tion itsy 
best clock frequency run applica tion depends main factors number idle peri ods system ability scale voltage clock frequency 
compute intensive applications little idle time running sys tems voltage switching applications run fast clock frequency possible completed java applications applets java class libraries base ii java virtual machine native libraries operating system java platform system placed low powered idle mode 
voltage switching available best clock frequency slowest speed ap plication meet deadline 
applications inherent idle time best clock frequency depend power cost idling power saved clock frequency reduced 
note reducing clock speed extends lifetime battery capacity batteries reduced increased power con sumption 
importance battery capacity clock speed tradeoff function type battery peak average power consumption 

java energy consumption section discuss energy impact decisions designing java virtual machine 
presenting overview java environment 
enumerate design tradeoffs consider sec tion evaluate energy impact section workloads described section 
java background java language provides features mod ern programming languages including object orientation strong typing automatic memory management multi threading 
importantly offers features highly desirable mobile applications 
particular java source code directly compiled native code architectural neutral intermediate form called java bytecode 
intermediate representation facilitates cross platform development deployment allows easy migration applications system generations evolve 
java language offers security model helps guard malicious applications 
key components required run java applica tion system set class java virtual machine jvm 
components represented shaded boxes 
class library comprises number classes collection data methods operate data 
taken contents class lib offer software components provide standard functionality required applications 
important set class files provided java window toolkit awt 
class files provided toolkit im common graphical user interface components displaying windows receiving input user 
jvm run time system executes java byte code instructions 
execution done interpret ing instruction compiling bytecode just time native instructions executing instruc tions directly 
execution application class previously accessed jvm suspends application loads needed referenced class 
task involves steps jvm reads parses file containing missing class 
file contains symbolic type inform ation actual bytecode instructions class 
cause class file may stored compressed format jvm may decompress file 
second jvm verifies bytecode violate safety guar demanded java language 
third jvm performs necessary linking steps resolve symbolic ref erences class 
task may involve loading linking referenced classes 
jvm resumes execution application 
interpreters usually execute bytecode orders magnitude slower translated compiled code 
just time compilation takes time may beneficial frequently invoked code 
ary ahead time compilation languages available 
ahead time compilation sacrifices portability ity verify safety untrusted code mobile code contained applets loaded network 
java wide spread pocket com difficult extrapolate java virtual ma chines systems 
conventional sys tems virtual machine modes 
line mode applications downloaded run short periods time initialization transla tion time may significant fraction execution time 
similar behavior exhibited users devices palm pilot information stored loaded persistent memory user switches application 
contrast server mode applications java server beans execute considerable period time 
applications typically run individual virtual ma chines may share virtual machine 
time unclear java application programmers design decisions wrote applic ations mode consider modes 
design options consider sets jvm design options startup op tions runtime options 
startup options affect costs execution application required method 
startup time typically execution time application energy cost startup smaller ex application 
depending usage pattern startup costs may incurred frequently 
run time options affect cost running application startup process completed 
second set energy consumed interest 
consider startup options run time options 
startup single jvm versus multiple jvms ra java application runs vir tual machine 
solutions emerged allow multiple applications run virtual machine 
compressed versus uncompressed class files persistent storage space portable devices premium 
reason class files containing bytecode tbr supporting java run time libraries stored compressed form 
consider compressing class files jvm loads itsy pocket computer boots linux 
case say compressed class files say uncompressed class files 
class loading just time compilation typ ically classes loaded demand needed methods just time compiled invoked 
startup delay reduced prefetch ing classes loaded 
cache flushing code generation code just time compiled data cache certain cases instruction cache invalidated 
consider various options flush invalidate caches 
run time interpreting byte code versus just time compilation jvm configured interpret just time compile bytecode 
polling frequency user input devices buttons touchscreen polled regular inter vals 
higher polling frequencies improve responsive ness energy 
workload evaluate impact energy consumption design options mentioned previous section imple mented java run time environment runs itsy pocket computer 
environment port kaffe jvm 
measured power consumed benchmarks executed itsy pocket computer 
workload designed capture modes pocket computer 
mode corresponds single application extended peri ods time game web browser 
second mode corresponds applications short periods time re invoking application repeatedly switching applications 
example mode mall application read mail messages embedded attachments 
view attachment may necessary start helper applic ations mpeg player switch repeatedly applications 
workload comprised activities human browsing web pages stored itsy web activity human playing chess game itsy pocket computer chess activity human play ing chess game browsing web page calculator composite activity 
modified java platform allow user generated events button presses touchscreen activations recorded file replayed time 
en sure subsequent replays mimicked possible original human interaction itsy time stamped events 
recorded trace files activities workload 
took power measurements replaying traces different jvm design options close original inter event timing possible 
discussion quantification section describe tradeoffs involved design decisions issues arising imple mentation impact energy consumption 
analyze design option relation baseline system employs multiple jvms uncompressed class files loaded demand just ln time compilation class methods awt polling frequency seconds balances energy cost polling response time 
collected power profiles traces described sec tion baseline system variation 
re experiment times trial com puted time required execute trace average power consumed total energy consumed 
report time average power total energy reporting average trials 
note trials experiments standard ation time average power total energy seconds watts joules respectively 
discussing design decisions impact startup costs follow sections impact execution costs 
single jvm versus multiple jvms number tradeoffs regarding single jvm multiple jvms run multiple applications 
tradeoffs affect time energy startup costs consumption resources memory 
running multiple applications single jvm reduces startup costs applications share java classes contained java run time libraries 
classes processed applic ations 
data structures shared internal table loaded classes symbol table 
due java late binding jvm run time tinker needs maintain large amount symbolic formation shared avoid having store multiple copies symbol string 
applications need ate direct method invocation 
evaluate energy costs single jvm versus multiple jvms gathered power profiles exe cution composite trace 
average power total energy computed profiles shown graphically 
set bars java design option set giving average power second giving total energy 
axis design options left hand axis plots average power watts right hand axis plots total energy joules 
graph follow baseline configuration noted appending asterisk power 
energy jvm jvm jvm jvm uj energy consumption composite trace single jvm multiple jvms 
axis label 
error bars represent error watts joules see section 
execution time average power total energy data experiment table appendix 
composite trace single jvm resulted reduction average power reduc tion total energy 
time execution time decreased clue time spent repeatedly loading virtual machines 
clearly single jvm energy efficient trace 
sharing re sources required single jvm drawbacks resources shared application misuse re source may affect applications 
instance memory allocator garbage collector shared excess ive allocations application reduce amount memory available applications 
applic ations may delayed garbage collection applications 
application fails bug run time libraries jvm jvm continue execute resulting applications ing aborted 
assume applications implementation need address issues 
current research tries address challenges enabling jvm run multiple applications safely allowing application impact jvm complex tra single application jvm model increase resource efficiency outweighs increased implementation efficiency 
compressed versus class files jar java archive files store class files required execute ap plication 
approaches form jar file compress class files individually combine form jar file combine class files compress resulting jar file 
approaches impact class files archive accessed run time resulting size jar file 
approach compress aggregate application requires method run time section jar file contains associated class file read memory class file decompressed method tn loo startup chess web energy consumption traces compressed jar files uncompressed jar files 
interpreted compiled 
jvm accesses class files compressed format say compressed class files 
hand second approach aggregate compress class files decompressed ram itsy boots 
jvms started access archives directly having uncompress 
application requires method class file decompressed 
jvm accesses class files uncompressed format say uncompressed class files 
advantage aggregate compress approach resulting jar file tends smaller persistent storage required store 
example jar file containing basic class files standard java libraries kbytes aggregate compress kbytes compress aggregate 
uncompressed size basic class files kbytes 
clearly run time memory cost decompressing entire jar file portion required 
approaches differ static dy namic memory footprints result different energy time costs method required 
presents energy power costs jvm accessed un compressed jar files aggregate compress com pressed jar files compress aggregate plot power energy different graphs 
com chess traces uncompressed jar files save power energy web trace saving average power total energy 
lack energy saving traces due competing effects 
uncompressed jar files reduces startup time applications re energy time required perform tasks specified traces 
events traces time stamped replayed correct inter event time spacing occured execution times traces change see table execution times 
energy consumed processes idle energy saving uncompressed jar files occur time stamping events 
idle power cost watts shown period time user input drawing application 
comparison web trace keeps system busy 
dem ii wen ene rg min com dem min com energy consumption composite trace class preloading variants minimal min com plete com demand dem class load ing 
greater proportion time idle time effects important 
class loading just time compilation java provides late dynamic 
linking required code application statically big binary java classes loaded virtual machine needed 
dynamic class loading allows programming techniques require late binding techniques implement mobile code great deal done execution time compile time 
just time compilation translation java byte code native instructions done lazily 
method translated methods filled trampolines 
trampolines small pieces code invoked translate method invoke 
method invoked time trampoline destroyed 
subsequent invocations dir reach translated method 
loading linking process takes time 
aside energy costs increases time users wait applications start 
hid startup latency low priority thread runs jvm idle set prede classes mad translates associated methods 
preloading successful number preloaded classes turn needed minimized 
unnecessary memory time energy costs incurred 
class occur amount done energy consumed roughly equal preloading 
startup time reduced 
illustrate effects choosing preload set poorly assembled preload sets minimal set cludes classes required load executing composite trace complete set includes large number classes applications exercised composite trace 
shows average power total energy con sumed composite trace demand loading replaced preloading variants 
cases single jvm configuration 
observe difference energy consumption variants 
uj startup onn chess web energy consumption traces baseline cache flushing algorithm base replaced variants complete data cache flush com plete data cache flush combined instruction cache validate 
cache flushing code generation translation java bytecode native code may incur additional costs depending support provided computer system memory coherence 
particular new native instructions written sequence memory locations locations return new instructions 
processors designed separate instruction data caches sa processor requirement met flushing data cache code generated new sequence referenced 
addition processor keep instruction cache coherent main memory may necessary flush instruction cache 
flushing instruction cache necessary regions memory reused code stored regions replaced 
cases jvm bookkeeping information memory allocator determine instruction cache flushed 
sa processor provides mechanism flushing specific lines data cache entire data cache need flushed code generated 
baseline design takes advantage feature sa 
jvm keeps track memory regions may contain stale code reuse flush instruction cache 
obtain estimate expensive memory system induced penalties startup process considered energy impact worst cases flushing complete data cache method translation invalidating complete instruction cache trans lation addition flushing data cache 
energy consequences worse case scenarios traces 
observe traces cache flushing little energy impact result sa having fairly small caches kbyte instruc tion kbyte data ability enter low power mode resolution cache interpreting just time compilation turn run time options 
noted section just time compilation reduces execution time energy consumption method jit interp 
power energy jit interp 
ku energy consumption chess trace interpreter just time compilation 
time saved translating method exceeds time spent translating 
infrequently invoked methods interpret ation may better option 
kaffe jvm support choosing run time interpret compile method experiments compared cost just time compiler interpreter 
presents average power total en ergy consumed chess trace bytecode translation options 
trace interpretation results increase average power total energy 
cases total execu tion time nearly amount time processor idle just time compiler greater 
results show pronounced benefits just time compiler note expect large differences occur jvms dif ferent interpreters 
kaffe interpreter simple include optimizations production interpreters 
optimizations include special routines written assembly interpret fre quently bytecode instructions 
second modern jvms capable choosing interpret com pile method method basis run time 
comparison provides insight amount energy saved system able support larger memory footprint just time compiler 
awt polling frequency awt implementation itsy relies periodic polling attached input devices 
default polling interval seconds 
sequence related input events sequence drag events resulting stroke delay affect initiating events 
awt designed poll events expected drag events event tight loop 
polling interval short time energy spent polling events 
polling interval long time spent polling users may device sluggish response especially polling interval chosen bc larger seconds 
choosing extremely large polling interval effect task takes longer execute time spent idling event pending dispatched 
depending cost chess web energy consumption web chess traces awt polling interval varied milliseconds milliseconds 
idling delay may increase energy costs 
effect awt polling interval average power total energy consumption shown 
polling interval increased seconds seconds energy consumption decreases 
chess trace uses energy polling interval seconds seconds 
total execution times tend increase polling interval increased see table drop average power due larger fraction idle time accounts decrease energy 
polling interval increased seconds energy usage increases slightly 
believe increase due artifact replay events traces property jvm 

related believe characterize energy usage high performance pocket computer measure energy impact running java 
ellis characterized power usage palm pilot pocket computer offering significantly lower performance itsy provided coarse estimates en ergy cost various tasks 
martin measured effect battery life running itsy pocket computer different clock frequencies 
number studies profiled energy consumption notebook computers 
li report power consumed notebook display consumes disk consumes cpu memory consume 
studies provided detailed charac power consumption notebooks 
energy profiler maps energy usage ap plication structure reporting energy consumption processes procedures 
tool provide detailed profiles energy usage applications running laptop computers 
arc currently ing methodology described combined produce similar profiles applications running itsy pocket computer 
broader scope considerable low power energy conscious computer system design 
includes circuit level design issues cad tools op memory subsystem reducing waste execution instruction level software optimizations cpu scheduling voltage scal ing 

pocket computers operate battery power ex tended periods time 
application design treat energy power usage primary concerns 
level characterization energy consumption itsy pocket computer aim furthering software community understanding designing software en ergy efficient 
began characterizing energy con sumption itsy hardware important tems 
evaluated energy power impact tradeoffs design java virtual machine environment 
key messages study 
en ergy power usage pocket computers differ markedly notebook computers 
compared think pad notebook computer itsy exhibited wider dynamic range power consumption result factors processor itsy exhibited wider range power demand power consumption memory system accounted greater fraction power con sumption itsy 
believe factors true general pocket notebook computers result variation power usage typical application scenarios higher notebook computers 
second single jvm run multiple applications considerable energy benefit 
executing com trace single jvm reduced energy usage demonstrating current research efforts safely execute multiple applications single jvm significant benefit extending battery life pocket computers 
third preloading java classes reduce startup time impacting energy consumption predict classes 
measures reduce delay user observes starting applications undertaken additional energy costs additional avoided 
instance preloading java classes re duces startup time affecting energy costs misprediction 
fourth techniques reduce execution time pri just time compilation provide signi energy savings pocket computers 
savings outweigh costs associated believe mainly increased memory consumption added implementation complexity 
acknowledgments members compaq western research lab systems research center created itsy pocket computer built infrastructure possible 
anonymous referees comments 
appendix table presents execution time power energy jvm design option 
ao ellis 
case higher level power management 
proceedings th ieee workshop hot topics operating systems pages march 
board army science technology national re search council washington dc 
energy efficient tech soldier 
technologies kaffe java virtual ma chine www 
com 

itsy pocket computer version user manual 
technical report tn western re search lab compaq computer july 
anne bell cheney eno joe kaye meyer patton pham reis snyder 
mhz sw cmos risc microprocessor 
ieee ternational solid state circuits conference digest technical papers pages february 
weiser welch demers shenker 
scheduling reduced cpu energy 
sym operating systems design implement ation pages november 
chan wasserman 
compar ing algorithms dynamic speed setting low power cpu 
proceedings acm interna tional conference mobile computing network ing pages november 
farkas anderson 
power en ergy characterization itsy pocket computer ver sion 
technical report tn western research lab compaq computer february 
martin siewiorek 
impact bat capacity memory bandwidth cpu speed setting case study 
proceedings ternational symposium low power electronics design pages august 
gosling joy steele jr java lan guage specification 
java series 
addison wesley september 
romer lee voelker wolman wong 
boer bershad levy 
structure performance interpreters 
proceed ings seventh international conference archi support programming languages op erating systems pages october 
back hsieh 
drawing red line java 
proceedings seventh workshop hot topics operating systems pages march 
li horton anderson 
quant analysis disk drive power management portable computers 
proceedings winter usenix conference pages january 
ii time seconds composite trace power watts energy joules baseline single jvm compressed jar files lo preload class files minimal set preload class files complete set data cache flush ol data cache flush instruction invalidate chess trace baseline compressed jar files data cache flush ol lo ol data cache flush instruction invalidate ol ol interpreted oo awt polling frequency ms oo awt po frequency ms oo awt polling frequency ms ol web trace baseline compressed jar files data cache flush data cache flush instruction invalidate awt polling frequency ms awt polling frequency ms awt polling frequency ms table execution time power energy jvm design option 
numbers parenthesis ratios baseline exception preload experiments ratio single jvm case 
values table average trials 
measurement error watts power data joules energy data 
lorch 
complete picture energy consumption portable computer 
master thesis university california berkeley 
lorch smith 
energy consumption apple macintosh computers 
ieee micro nov dec 
ikeda 
thinkpad low power evolution 
ieee international symposium low power electronics pages october 
flinn satyanarayanan 
tool profiling energy usage mobile applications 
proceedings second ebb workshop mo bile computing systems applications pages february 
flinn satyanarayanan 
energy aware adapt ation mobile applications 
proceedings th cm symposium bn operating systems principles pages december 
nebel eds 
low power design deep electronics 
kluwer 

analytical energy ation models low power caches 
proceedings international symposium low power electron ics design pages august 
cardwell patterson anderson yelick 
energy efficiency iram architectures 
proceedings rd annual international sym computer architecture pages june 
kin gupta mangione smith 
filter cache energy efficient memory structure 
proceedings th annual international sym microarchitecture pages december 
manne 
pipeline gating speculation control energy reduction 
proceedings th annual international symposium computer architecture pages june 
tiwari malik 
instruction level power analysis optimization software 
journal vlsi signal processing 
weiser 
computer science issues ous computing 
communications acm july 
brodersen 
processor design portable systems 
journal ov vlsi signal processing august 
