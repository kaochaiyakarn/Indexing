compositional pointer escape analysis java programs john whaley martin rinard laboratory computer science massachusetts institute technology cambridge ma lcs mit edu presents combined pointer escape analysis algorithm java programs 
algorithm abstraction points escape graphs characterize local variables elds objects refer objects 
points escape graph contains escape information characterizes objects allocated region program escape accessed region 
algorithm designed analyze arbitrary regions complete incomplete programs obtaining complete information objects escape analyzed regions 
developed implementation uses escape information eliminate synchronization objects accessed thread allocate objects stack heap 
experimental results encouraging 
able analyze programs tens thousands lines long 
benchmark programs algorithms enable elimination synchronization operations 
enable stack allocation objects 
presents combined pointer escape analysis algorithm java programs programs written similar object oriented languages 
algorithm abstraction points escape graphs characterize local variables elds objects refer objects 
points escape graph contains escape information characterizes objects allocated region program escape accessed region 
key concept underlying abstraction goal representing interactions analyzed unanalyzed regions program 
points escape graphs clean distinction objects created analyzed region created rest program 
enable exible analysis capable analyzing arbitrary parts program analysis result precise program analyzed 
stage analysis algorithm distinguish complete information 
analysis uses java presents clean simple memory model conceptually objects allocated garbage collected heap 
useful programmer model comes cost 
cases ecient allocate objects stack eliminating dynamic memory management overhead object 
similar situation holds java synchronization model 
conceptually java object comes lock 
synchronized method ensures executes atomically acquiring releasing lock receiver object 
lock overhead wasted thread accesses object locks required possibility multiple threads may attempt access object simultaneously 
discuss analysis results eliminate unnecessary synchronization enable stack allocation objects 
basic idea analysis information determine objects escape threads methods 
object escape allocating thread thread compiler transform program eliminate synchronization operations object 
object escape method compiler transform program allocate method activation record heap 
experimental results show algorithms eliminate signi cant number heap allocations synchronization operations 
analysis properties analysis important properties interprocedural analysis 
designed combine analysis results multiple methods obtain precise points escape information 
compositional analysis 
designed analyze method produce single parameterized analysis result specialized call sites may invoke method 
recursive methods require iterative algorithm may analyze methods multiple times reach xed point 
partial program analysis senses 
designed analyze method independently callers 
second capable analyzing method analyzing methods invokes analysis result precise invoked methods analyzed 
analysis compositional analyze pieces program independently callers callees especially appropriate dynamically loaded programs 
current implementation runs dynamic compiler analyzes libraries independently applications 
compiler loads application retrieves previously computed analysis results libraries uses results analysis application 
basic approach analysis abstraction call points escape graphs 
nodes abstraction represent objects edges represent objects 
abstraction contains information objects escape methods threads 
example object escapes returned unanalyzed region program passed parameter unanalyzed method 
method analysis produces points escape graph characterizes points relationships created method interaction method points relationships created rest program 
analysis represents interactions part maintaining distinction kinds edges inside edges represent created inside currently analyzed region outside edges represent created outside currently analyzed region 
similarly kinds nodes inside nodes represent objects created inside currently analyzed region accessed inside edges outside nodes represent objects created outside currently analyzed region accessed outside edges 
outside edges represent interactions analyzed region reads created unanalyzed region 
inside edges outside nodes nodes reachable outside nodes represent interactions analyzed region creates unanalyzed region may read 
edges inside nodes represent created currently analyzed region 
inside nodes escape interaction rest program edges points escape graph completely characterize points relationships objects represented nodes 
points escape graphs record interactions methods callers analysis recover complete information objects escape currently analyzed method caller 
analysis compositional analyzes method independently callers 
pointer escape analysis algorithms know algorithm capable analyzing method independently methods may invoke 
algorithm skips analysis potentially invoked method records objects passed parameters invoked analyzed method escape scope analysis 
escape information allows algorithm clearly identify objects complete points information objects points relationships may ected unanalyzed regions program 
algorithm designed analyze arbitrary regions complete incomplete programs obtaining complete information objects escape analyzed regions 
contributions contributions analysis algorithms presents new combined pointer escape analysis algorithm 
algorithm compositional designed deliver useful information analyzing entire program 
analysis approach presents analysis approach explicitly di objects analyzed unanalyzed regions program 
approach allows algorithm capture interactions regions clearly identify complete information extracted relationships 
analysis uses presents optimizations enabled extracted points escape information synchronization elimination stack allocation 
experimental results presents experimental results prototype implementation algorithms 
results show algorithms eliminate signi cant amount synchronization operations heap allocations 
remainder organized follows 
section presents examples illustrate analysis works 
section describes analysis represents program analysis objects algorithm uses 
section presents intraprocedural analysis section presents interprocedural analysis 
section abstraction relation characterizes correspondence points escape graphs objects program creates runs 
section presents synchronization elimination stack allocation transformations 
section presents experimental results implementation 
section discusses related conclude section 
example section examples illustrate analysis works 
return values presents complex number arithmetic example 
add method adds complex numbers storing result newly allocated complex number object returning new object 
multiply method operates similarly multiplies numbers adding 
method returns new object new object escapes method 
method multiplies arguments returns sum product receiver 
case add result escapes temporary result multiply inaccessible outside method 
possible generate specialized version multiply method expects storage result object allocated stack caller 
generate result stack allocated class complex double complex double double complex multiply complex complex product new complex return product complex add complex complex sum new complex return sum complex complex complex complex product multiply complex sum add product return sum complex number example analysis result object dynamically allocating new complex object hold result 
presents analysis result method 
nodes graph represent variables objects edges represent 
parameter variables point nodes represent parameter objects variable points node represents receiver 
objects created outside method corresponding nodes outside nodes 
note analysis assumes parameters aliased 
analysis result method invocation site parameters aliased mapping algorithm section merges parameter nodes uses analysis result 
mechanism ensures algorithm analyze program assumption di erent parameters object elds aliased analysis results contexts containing aliases 
product sum variables point nodes represent new complex number objects allocated respectively multiply add methods 
algorithm represents objects allocated analyzed region public class server extends thread int server public void run try vector new vector true socket accept new start addr addr addelement addr catch ioexception server example program nodes correspond object creation site 
example product points node represents objects created object creation site inside multiply 
node represents objects created inside analyzed region inside node 
node product points accessible local variable product 
say node captured 
soon method returns objects node represents inaccessible 
legal tie lifetime object lifetime method invocation allocate object activation record method 
method returns object sum points 
object escapes method may method call chain 
analysis maintains information recognize situations 
thread private objects example illustrates analysis detect thread private objects objects accessed thread 
goal eliminate synchronization operations thread private objects 
code implements simple server 
server waits incoming connection requests 
gets request creates new thread service new connection 
server counts number duplicate connections number times connects client previously connected 
correctly compute count server maintains list internet addresses clients connected 
receives new request server checks list determine previously connected client 
increments count number duplicate connections server established 
inserts internet address client list detect duplicate connections client 
example server uses vector hold list internet addresses 
class thread safe methods guaranteed execute atomically concurrently invoked di erent threads 
thread safety important property 
multithreaded programs fail subtle ways data races unanticipated interactions threads concurrently access object 
problem atomic operations overhead synchronization operations methods execute atomically 
example standard implementations addelement acquire release lock receiver object 
overhead especially example vector object 
analysis run method example proceeds follows 
algorithm rst analyzes invoked methods obtain points escape graph method 
graph summarizes method ects points relationships objects objects creates accesses escape threads caller 
example new object escapes thread 
addelement methods may change objects receiver points change escape status receiver 
information analysis run method analysis determines object captured run method accessible run method thread 
synchronization addelement methods redundant 
compiler generate specialized synchronization free versions methods 
generated code run method invokes specialized versions computation executes synchronization overhead vector object 
possible address problem synchronization overhead thread private objects providing programmer implementations class thread safe implementation synchronization objects shared threads thread unsafe implementation synchronization thread private objects 
jdk collections api takes approach 
problem approach complicates api burdens programmer responsibility determining objects thread safe 
problem especially severe programmers maintaining multithreaded programs 
change previously thread private object accessible multiple threads programmer search program manually replace thread unsafe version version 
recursive data structures example illustrates algorithm deals recursive data structures 
assume previous example server count number connections client simply counting number duplicate connections 
case server multiset class implements multiset list elements 
element count number times multiset 
server multiset vector class object element int count object count element synchronized boolean check object element equals count return true return false synchronized insert object null check return return new class multiset elements multiset elements null synchronized void addelement object elements null elements new null elements elements insert multiset example analysis result insert analysis run method recognize multiset object thread private 
section focus treatment recursive data structures analysis insert method 
presents analysis result insert method 
variable points receiver node represents receiver object points parameter node represents parameter object 
nodes outside nodes 
nodes represent objects created accessed execution insert 
edge receiver node points node represents objects referenced eld load statement loads eld back edge outside edge points node represents object allocated outside scope analysis insert points outside node 
particular points load node nodes load statement program 
outside edge load node back 
loop insert method walks list traverses elds nodes 
loaded statement outside edges represent point outside node cycle graph 
mechanism ensures analysis terminates programs manipulate recursive data structures 
remaining node represents new object insert may allocate hold new multiset entry 
node inside edge eld receiver node inside edge element eld parameter node 
edges represent nodes created execution insert 
analysis algorithm algorithm analyzes program granularity methods 
analysis method incorporates information method subset methods invokes 
combination currently analyzed method analyzed methods invokes called current analysis scope 
program representation algorithm represents program analysis objects 
set local variables set formal parameter variables 
formal parameter variable formal parameter method program 
local formal parameter variables set variables 
set cl cl classes set op op methods 
method receiver class cl formal parameter list adopt convention parameter points receiver object method 
set object elds 
object elds accessed syntax form static class variables accessed syntax form cl algorithm represents computation method control ow graph 
nodes control ow graphs statements st st algorithm analyzes statements ect points escape information 
assume program preprocessed statements relevant analysis forms copy statement load statement store statement global load statement cl global store statement cl return statement return identi es return value method 
object creation site form new cl kinds object creation sites cl inherits class thread object creation site thread creation site 
cl inherit class thread object creation site thread creation site 
method invocation site form op lk 
method invocation site corresponds method invocation site control ow graph method op starts enter statement ends exit statement analysis represents control ow relationships statements follows pred st set statements may execute immediately st succ st set statements may execute immediately st program points statement st program point st immediately st executes program point st immediately st executes 
interprocedural analysis uses call graph information compute sets methods may invoked method invocation sites 
method invocation site callees set methods may invoke 
method op callers op set method invocation sites may invoke op 
current implementation obtains call graph information variant class hierarchy analysis algorithm conservative approximation actual call graph generated program runs 
object representation analysis represents objects program manipulates set nodes 
kinds nodes set ni inside nodes represent objects created current analysis scope accessed created current analysis scope 
inside node object creation site inside node represents objects created current analysis scope site 
nt set thread nodes inside nodes correspond thread creation sites 
thread corresponds object inherits class thread thread creation sites object creation sites nt ni set outside nodes represent objects created outside current analysis scope accessed created outside current analysis scope 
set cl class nodes 
conceptually class node represents statically allocated object elds static class variables corresponding class 
set outside nodes divided kinds nodes set np parameter nodes 
parameter node formal parameter program 
parameter node represents object parameter points execution analyzed method 
analysis starts method formal parameter variables points corresponding parameter node 
receiver object treated rst parameter method 
set ng global nodes 
global node static class variable cl program 
global node represents objects static class variable may point execution current method 
analysis current method starts accessed static class variable points global node 
set nl load nodes 
load node load statement program 
load statement executes loads value eld object 
loaded value analysis represent object points 
load node represents objects loaded corresponding load statement 
set nr return nodes 
return node method invocation site program 
return nodes represent return values invocations unanalyzed methods 
analysis represents array single node 
node eld elements represents elements array 
points information array elements merged eld analysis distinction di erent elements array 
points escape graphs points escape graph quadruple form ho ri nl ng set outside edges 
outside edges represent created outside current analysis scope caller thread running parallel current thread unanalyzed invoked method 
set inside edges 
inside edges represent created inside current analysis scope 
escape function records set unanalyzed method invocation sites node escapes 
return set represents set objects may returned currently analyzed method 
graphs edges labeled eld de ne operations nodes graphs fhn ni og fi ni og fhn og fi og edges fn hn og fn hhn fi og operation removes set nodes points escape graph 
ho remove ho ri sg sg reachability escaped nodes identify di erent kinds escape information distinction object accessible outside current method 
object created outside current analysis scope accessed created outside current analysis scope object accessible parts program 
case say object escaped escaped 
object escaped returned method caller say object escape 
object directly escaped current method situations object passed parameter current method 
object written static class variable 
object passed parameter invoked method information invoked method object 
object thread object 
object escaped reachable sequence object directly escaped object 
object captured escaped 
abstraction points escape graphs formalize concepts reachability escaped nodes follows 
node directly reachable node graph hn hhn fi node reachable node exists sequence 
nk nk directly reachable node reachable set nodes exists node reachable de ne reachable reachable points escape graph ho ri node directly escapes np nr nt cl 
de ne escaped ho ri reachable node directly escapes captured ho ri escaped ho ri 
intraprocedural analysis algorithm uses data ow analysis generate pointsto escape graph point method 
analysis method starts construction pointsto escape graph ho rst statement method 
method op formal parameter list accessed static class variables cl cl initial points escape graph ho de ned follows 
parameter points corresponding parameter node np formal parameter points receiver object method node np represents receiver object analysis method 
fhp np kg accessed static class variable cl points corresponding global node cl cl jg 

note algorithm analyzes method assumption parameters accessed static class variables point di erent objects 
method may invoked calling context pointers point object object represented multiple nodes analysis method 
case mapping operation described section merge corresponding outside objects maps nal analysis result method calling context method invocation site 
mapping retains edges merged objects conservatively models actual ect method 
nished constructing initial points escape graph analysis continues propagating pointsto escape graphs statements method control ow graph 
transfer function ho st ho ri de nes ect statement st current points escape graph 
statements rst kill set inside edges generate additional inside outside edges 
case transfer function general form geni graphically presents rules determine sets generated edges di erent kinds statements 
row gure contains items statement graphical representation existing edges graphical representation existing edges plus new edges statement generates set side conditions 
interpretation row points escape graph contains existing edges side conditions satis ed transfer function statement generates new edges 
copy statements copy statement form point object points 
transfer function updates re ect change killing current set edges generating additional inside edges nodes points 
edges geni flg geni load statements load statement form point object points 
analysis models change constructing set nodes represent objects may point generating additional inside edges node set 
nodes accessible inside edges clearly points escaped node parts program caller threads executing parallel current thread access referenced object store values elds 
particular value may written caller thread running parallel current thread words may contain created outside current analysis scope 
analysis uses outside edge model 
outside edge points load node load statement outside node represents objects may point 
analysis consider cases case point escaped node case point escaped node 
algorithm determines case applies computing se set escaped nodes points 
si set nodes accessible inside edges se fn escaped ho ri si fi se point escaped node si transfer function simply kills edges generates inside edges nodes edges geni fl geni se points escaped node si fng load node load statement 
addition killing edges generating inside edges nodes transfer function generates outside edges escaped nodes edges geni fl geni se ffg fng store statements store statement form nds object points eld object point object analysis models ect assignment nding set nodes points generating inside edges nodes nodes points 
geni ffg geni generated edges basic statements global load statements global load statement form cl point object cl points 
analysis models change killing edges generating inside edges nodes cl points 
edges geni flg cl geni global store statements global store statement form cl static class variable cl point object analysis models change generating inside edges cl nodes points 
geni fig geni object creation sites object creation site form new cl allocates new object point object 
analysis represents objects allocated speci creation site creation site inside node transfer function models ect statement killing edges generating inside edge edges geni nig geni return statements return statement return speci es return value method 
immediate successor return statement exit statement method 
analysis models ect return statement updating include nodes points 
exit statements transfer function exit statement produces nal analysis result method 
result call sites may invoke method compute ect method analysis caller 
primary activity transfer function remove information points escape graph visible caller 
algorithm rst computes set nodes reachable static class variables parameters return values 
removes nodes points escape graph 
fn reachable cl ho remove ho ri analysis uses reachability information method exit points bound object lifetimes 
inside node reachable static class variables parameters return values thread object objects represents objects allocated corresponding object allocation site current analysis scope inaccessible method caller threads 
method returns objects inaccessible rest computation 
legal allocate objects activation record method access objects synchronization 
control flow join points analyze statement algorithm rst computes join points escape graphs owing statement predecessors 
applies transfer function obtain new points escape graph point statement 
join operation de ned follows 
ho ho ri corresponding partial order points escape graphs ho ho bottom points escape graph 

analysis method produces analysis results st st statement st method control ow graph 
analysis result satis es equations ho st tf st st pred st st st st nal analysis result method op analysis result program point exit node 
described section analysis solves equations standard worklist algorithm 
strong updates analysis models execution statements update memory locations adding edges nodes represent updated locations 
possible kinds updates weak updates leave existing edges place strong updates remove existing edges 
strong updates leave fewer edges points escape graph may produce precise analysis results 
analysis far updates local variables strong updates weak 
analysis legally perform strong update updated node captured represents exactly updated memory location program runs 
store statement form condition satis ed points single captured node represents single object represents single location object 
condition satis ed elements special eld identi er array elements discussed section 
strong updates singular nodes fields node singular represents object 
case example inside node corresponds statement executed current analysis scope 
eld singular represents single location object 
de nitions provide de nition transfer function store statement de nition transfer function store statements performs strong updates 
fng singular captured hi ri geni ffg geni summary nodes possible extend object representation inside node represent object allocated corresponding allocation site 
nodes allocated site represented summary node 
approach analysis perform strong updates inside nodes weak updates summary nodes 
similar approaches proposed intraprocedural shape analysis algorithms :10.1.1.152.1240
optimization static class variables absence information parallel threads access static class variables extracted analysis information imposes limit lifetimes points relationships objects reachable variables 
implemented compiler adopts compact representation points relationships involving nodes represent objects 
recording speci set static class variables may point node analysis simply records 
representation reduces size points escape graph reducing amount useful information 
interprocedural analysis method invocation site analysis option skipping site analyzing site 
analyzes site collects nal analysis results potentially invoked methods maps analysis result points escape graph program point method invocation site merges mapped results derive points escape graph point method invocation site 
analysis skips method invocation site marks parameters escaping site 
skipped method invocation sites transfer function skipped method invocation site de ned follows 
skipped method invocation site form op lk return node nr current points escape graph ho ri pointsto escape graph ho ho ri site de ned follows edges nr ig fmg return node nr outside node represent return value invoked method 
analyzed method invocation sites analyzed method invocation site form op lk current points escape graph ho ri new points escape graph ho ho ri site de ned follows ho ho ri op op callees mapping algorithm method invocation sites 
assume method invocation site form op lk invoked method op formal parameter list accessed static class variables cl cl points escape graphs involved algorithm old graph points escape graph ho ri point method invocation site 
incoming graph nal analysis result hor ir er invoked method 
mapping algorithm produces new graph hom im em rm map ho ri op 
overview conceptually algorithm rst builds initial mapping nodes incoming graph nodes old graph 
outside node incoming graph set nodes old graph represents analysis invoked method op 
initial value maps global nodes parameter nodes load nodes corresponding nodes new graph 
builds mapping load nodes tracing correlated paths old graph incoming graph 
path old graph consists sequence inside edges corresponding path incoming graph consists sequence outside edges represent corresponding inside edges analysis method 
algorithm builds new points escape graph hom im em rm map ho ri op 
algorithm starts initializing new graph old graph ho ri 
uses mapping map nodes edges incoming graph new graph 
mapped nodes represent objects allocated accessed invoked method 
mapped edges represent invoked method created read 
mapping process edges mapped pairs nodes incoming graph corresponding pairs nodes new graph 
case say nodes new graph acquire edges nodes incoming graph 
part mapping process algorithm extends algorithm maps node incoming graph new graph 
case say new graph 
describe roles di erent kinds nodes incoming graph play analysis discuss roles ect node presence new graph ect mapping edges mapped new graph 
np parameter node represents nodes corresponding actual parameter points 
nodes acquire edges new graph 
set nodes current graph corresponding actual parameter points 
ng global node represents objects corresponding static class variable points 
nodes acquire edges new graph 
note escaped new graph 
set nodes current graph corresponding static class variable points 
note 
nl load node nodes represents acquire edges 
may represent object created outside analysis scope caller object accessed created outside scope edges mapped new graph 
basic idea new graph escaped node point outside edges captured nodes 
analysis determines examining nodes incoming graph point cases nodes say escaped new graph outside edge new graph nodes mapped escaped node say old graph outside edge new graph cases escaped new graph 
includes set nodes old graph represented analysis method 
new graph 
ni inside node inside edges new graph objects represents reachable caller 
analysis determines examining nodes incoming graph point 
load nodes cases nodes say new graph edge new graph nodes represents node say old graph edge new graph primary di erence load nodes inside nodes load nodes new graph escaped graph 
inside nodes reachable escaped captured new graph 
inside node new graph fng 

nr return node nodes represent return values invoked unanalyzed methods conditions inside nodes 
constraints mapping algorithm figures formal speci cation constraints mapping new points escape graph hom im em rm satisfy 
constraints speci ed set inference rules nal mapping points escape graph satisfy 
conceptually inference rules start existing mapping set edges generate additional inference rule written standard form imposes constraint true true 
mappings edges 
graphically presents generated mappings edges crucial rules 
row gure contains items inference rule graphical representation existing edges mappings graphical representation existing edges mappings plus new edges mappings rule generates set side conditions 
nodes bottom row graphical representation incoming graph nodes top row new graph 
interpretation row existing edges mappings incoming graph new graph side conditions true inference rule generates new edges mappings 
np cl cl hhn fi hhn fi ni initial rules om edges im em rm hhn fi ir ffg im hhn fi ir ni nr hhn fi escaped hom im em rm hhn fi om rr ni nr er em rrg im rules hom im em rm initial rules initial set contraints rules set initial mapping outside nodes incoming graph mapped nodes old graph represent analysis invoked method op 
rule maps parameter node np nodes old graph represents analysis method 
rule rule ensures accessed global node mapped nodes old graph recall method invocation site actual parameters lk method formal parameters np parameter node generated edges mappings inference rules represents analysis method 
rule maps outside nodes nodes represent analysis method matching outside edges incoming graph corresponding inside edges old graph 
constraint starts node incoming graph maps node old graph 
matches edges nodes nd load node incoming graph represents node new graph analysis method 
constraint maps rules map outside nodes 
rule may map inside node new graph 
important rule match outside edges inside nodes inside edges old graph 
reason restriction inside nodes represent objects allocated inside current analysis scope 
objects exist analyzed method invoked 
outside edges inside nodes represent created threads running parallel current analysis scope unanalyzed methods invoked current analysis scope 
case exist method invoked 
inside edges old graph existed analyzed method invoked outside edge incoming graph represent edges 
remaining rules rule initializes new graph include old graph 
rule maps inside edges incoming graph new graph 
inside edge nodes new graph inside edge corresponding nodes incoming graph 
rules map nodes incoming graph new graph 
rule maps inside return node new graph reachable node mapped new graph 
rule maps load node new graph reachable escaped node mapped new graph 
rule maps inside return node new graph returned method 
rule ensures nodes passed unanalyzed methods marked appropriately escape function 
rule local variable assigned value method returns point nodes represent return value method 
constraint solution algorithm figures algorithm solving constraint system figures 
algorithm directly re ects structure inference rules 
step detects inference rule antecedent true takes action ensure consequent true 
procedure invoked algorithm maps node incoming graph node new graph 
rst updates escape function em re ect new escape information 
maps new inside edges re ect corresponding inside edges incoming graph 
rule constraint maps inside edges incoming graph new graph 
insertions recall method accesses static class variables cl cl cl global node cl inside edges new graph take place inside responsible ensuring new graph contains right inside edges 
control structure algorithm worklists 
worklist corresponds rules map nodes incoming graph new graph 
worklist entry contains node new graph edge hhn fi incoming graph 
worklist entries property 
algorithm processes worklist entry checks see update mapping details check depend speci worklist 
worklist corresponds rule matches outside edges incoming graph inside edges old graph 
edges worklist outside edges 
process entry worklist algorithm matches edge hhn fi worklist corresponding inside edges hhn fi old graph 
corresponding edge maps worklist wi corresponds rule maps inside nodes new graph 
edges worklist inside edges 
process entry worklist algorithm extracts node worklist edge points maps new graph 
worklist wo corresponds rule maps outside nodes new graph 
edges worklist outside edges 
process entry worklist algorithm inserts corresponding outside edge hhn fi new graph maps new graph 
slight complication algorithm 
algorithm executes periodically maps inside edges incoming graph new graph 
node mapped algorithm maps inside edge hhn fi incoming graph new graph 
mapping process inserts corresponding inside edge node maps node 
algorithm ensure completes edge node nal set nodes 
algorithm rst maps hhn fi new graph may complete 
case algorithm eventually map nodes increasing set nodes 
edges nodes nal just node algorithm mapped hhn fi new graph 
algorithm ensures edges nal graph building set delayed actions 
delayed action consists node new graph eld node 
node mapped new node algorithm sets fn algorithm establishes new inside edge delayed action 
new edge goes node action newly mapped node edges ensure nal set inside edges satis es constraints 
global fixed point analysis algorithm presents global xed point algorithm compiler uses solve combined intraprocedural interprocedural data ow equations 
maintains worklist pending statements 
step removes statement hn ni fng fhn nig update em satisfy rule er em em fmg update im satisfy rule im im fng hhn fi ir im im fhn fig fhn fig update worklists rules fng wi wi fng ir wo wo fng procedure mapping node initialize worklists wi wo initialize new graph satisfy rule hom im em rm ho edges ri map parameter nodes satisfy rule np map classes satisfy rule cl cl map return values satisfy rule rr ni nr done false done done true choose hn hhn fi ii ni fhn hhn fi iig map nodes satisfy rule hhn fi done false choose hn hhn fi ii wi ni nr wi wi fhn hhn fi iig map inside node satisfy rule done false choose hn hhn fi ii escaped hom im em rm wo wo fhn hhn fi iig map outside edge outside node satisfy rule om om fi ig done false update im satisfy rule im rrg constraint solution algorithm hom im em rm initialize analysis results st st st st 
op op ho initialize worklist op remove statement worklist process statement st tf st st pred st st st st st changed put potentially ected statements worklist succ st st callers op fixed point analysis algorithm updates analysis results statement 
analysis result statement changed inserts successors exit nodes callers method worklist 
order algorithm analyzes methods signi cant impact analysis 
non recursive methods bottom analysis program yields full result analysis method 
recursive methods analysis results iteratively recomputed strongly connected component call graph current best result analysis reaches xed point 
possible extend algorithm initially skips analysis method invocation sites 
analysis result precise incrementally increase precision analyzing method invocation sites originally skipped 
algorithm propagate new precise result update analysis results ected program points 
abstraction relation section characterize correspondence points escape graphs objects created execution program 
key property correspondence single concrete object execution program may represented multiple nodes points escape graph 
state properties characterize correspondence abstraction relation relates object nodes represent 
program executes creates set concrete objects set cl objects 
point execution program possible de ne sets objects rc set created current execution current method analyzed methods invokes 
rr set read current execution current method analyzed methods invokes 
cr set objects reachable local variables static class variables parameters rc rr ri rc cr cr set inside 
represented set inside edges analysis 
ro rr cr cr ri set outside 
represented set outside edges analysis 
possible construct abstraction relation objects nodes pointsto escape graph ho ri current program point 
relation relates object nodes points escape graph represent object analysis method 
abstraction relation properties described 
reachable objects represented allocation sites 
created object creation site current execution current method analyzed methods invokes reachable cr object creation site inside node 
object represented inside node ni implies outside corresponding outside edge points escape graph hv oi ro implies fi oi ro implies cl fi ro implies ffg inside corresponding inside edge points escape graph hv oi ri implies fi oi ri implies cl fi ri implies ffg object represented captured node represented node captured ho ri implies fng property de ne object captured represented captured node 
captured objects local variables captured objects captured ho ri hv oi implies captured ho ri fi implies fn captured ho ri properties ensure captured objects reachable paths start local variables 
object captured method exit point inaccessible soon method returns 
points information points escape graph completely characterizes objects represented captured nodes captured ho ri captured ho ri hhn fi implies fi optimizations optimization purposes important properties absence edges captured nodes guarantees absence represented objects captured objects inaccessible method returns 
section discuss transformations stack allocation objects synchronization elimination escape information enables 
synchronization elimination object escape thread legal remove lock acquire release operations synchronized methods execute object 
bene transformation elimination synchronization overhead apply transformation compiler generates specialized synchronization free version synchronized method may execute captured object 
call site invokes method captured objects compiler generates code invokes version 
issue compiler deal distance call graph method captures object synchronized method 
addition removing synchronization operations synchronized method compiler generate specialized versions methods call chain capturing method method containing call site invokes synchronization free version 
specialization policy imposes limit number specialized methods applies transformation possible 
nal problem nding paths call graph go captured objects synchronized methods 
compiler solves problem augmenting analysis record node points escape graph paths call graph lead synchronized operations objects represented node 
captured objects compiler information trace path captured object call sites invoke synchronized methods object 
stack allocation objects object escape method allocated stack heap 
bene transformation elimination garbage collection overhead 
processed collector object preserve semantics java memory model machines implement weak memory consistency models compiler may need insert memory barriers original lock acquire release sites removes acquire release constructs 
implicitly collected method returns stack rolls back 
bene better memory locality stack frame tend resident cache 
compiler precisely compute location object stack generate code accesses object elds directly stack frame 
largest potential drawback stack allocation may increase memory consumption extending lifetime objects allocated stack 
problem may especially acute allocation sites create statically unbounded number objects stack implementation allocates objects stack allocation site executed invocation allocating method method contains object allocation site 
simplest case captured object escape allocating method 
case compiler simply replace normal object allocation instruction special instruction allocates object heap 
object escapes allocating method caller direct indirect may possible allocate object stack method captures object 
addition requiring objects come allocation sites executed invocation allocating method compiler requires allocating method invoked call site captured method leads allocating method 
allocation site satis es restriction compiler generates specialized version allocating method 
allocating object specialized version takes parameter pointer preallocated space capturing method activation record 
allocation site transformed initialize object location allocate heap 
synchronization elimination transformation described compiler generate specialized versions methods call chain capturing method allocating method 
transformation interoperate correctly rest system garbage collector recognize stack allocated objects 
recognition mechanism simple examines address object determine allocated stack heap 
collection collector scans stack allocated objects normally 
attempt move collect objects 
experimental results implemented combined pointer escape analysis algorithm described sections 
implemented analysis compiler jalape jvm java virtual machine written java unsafe extensions performing low level system operations explicit memory management pointer manipulation 
compiler structure analysis implemented separate phase jalape dynamic compiler operates jalape intermediate representation 
analyze class algorithm loads class converts methods intermediate representation analyzes methods 
nal analysis results methods written le 
approach provides excellent support dynamically loaded programs 
allows compiler analyze large commonly package java class libraries reuse analyze results time program loaded uses package 
supports delivery packages 
requiring analysis performed package rst loaded customer virtual machine vendor perform analysis part release process ship analysis results code 
jalape compiler generates code dynamically loaded class uses information analysis le apply stack allocation synchronization elimination optimizations described 
unusual feature system analysis applied compiler virtual machine bootstrap process 
entire system including dynamic compiler virtual machine applications executes optimizations applied 
benchmark set benchmark set includes programs 
javac standard java compiler 
javacup yacc parser generator java 
lexical analyzer generator java 
pbob transaction processing benchmark designed quantify performance simple transactional server workloads written java 
chose applications part complete programs regular 
expect exhibit realistic object creation access patterns 
chosen test scalability analysis 
associated analyzed class libraries programs order tens thousands lines code existing pointer analysis algorithms impractical programs size 
presents number lines code total sizes class les applications 
jvm jalape virtual machine 
lines class file benchmark code size bytes javac javacup pbob jvm benchmark characteristics staged analysis applications follows 
rst analyzed virtual machine standard libraries writing analysis results appropriate les 
analyzed application code reusing analysis results standard libraries 
number number synchronization synchronization operations operations benchmark optimization optimization javac javacup pbob number synchronization operations optimization javac javacup pbob percentage eliminated synchronization operations synchronization elimination presents dynamic number synchronization operations applications synchronization elimination optimization 
plots percentage eliminated synchronization operations 
analysis achieves reasonable results eliminating synchronization operations 
stack allocation presents dynamic number heap allocated objects applications stack allocation optimization 
plots percentage objects allocated stack 
analysis achieves reasonable results allocating objects stack 
presents total size heap allocated objects applications stack allocation optimization 
plots percentage memory allocated stack heap 
relative amount object memory allocated stack closely correlated number objects allocated stack 
current version jalape jvm support stack allocation 
objects allocated heap 
compiler generate specialized methods necessary support stack allocation 
compiler fully implements synchronization elimination optimization 
see package sun tools javac standard java distribution 
available www cs princeton edu appel modern java cup available www cs princeton edu appel modern java jlex number number heap allocated heap allocated objects objects benchmark optimization optimization javac javacup pbob number heap allocated objects optimization javac javacup pbob percentage objects allocated stack size size heap allocated heap allocated objects objects benchmark optimization optimization javac javacup pbob total size heap allocated objects optimization bytes javac javacup pbob percentage object memory allocated stack related section discuss areas related pointer analysis escape analysis synchronization optimizations 
pointer analysis pointer analysis sequential programs relatively mature eld 
flow insensitive analyses name suggests take statement ordering account typically form constraint analysis produce single points graph valid entire program 
flow insensitive analyses extend trivially sequential programs multithreaded programs 
insensitive statement order trivially model interleavings parallel executions 
flow sensitive analyses flow sensitive analyses take statement ordering account typically data ow analysis produce pointsto graph set alias pairs program point :10.1.1.25.6013:10.1.1.22.4648
approach analyzes program topdown fashion starting main procedure potentially invoked procedure new calling context 
approach exposes compiler possibility spending signi cant amounts time procedures 
commits compiler analysis entire program impractical situations entire program available 
approach analyzes program bottom fashion extracting single analysis result procedure 
analysis reuses result call site may invoke procedure 
lam algorithm programs non recursive pointer data types 
algorithm supports strong updates extracts information obtain fully context sensitive results compositional way 
chatterjee ryder landi describe approach extracts multiple analysis results result indexed calling context valid 
approach extracts single analysis result calling contexts aliases merges nodes calling contexts aliases 
disadvantage approach may produce precise results approaches maintain information multiple calling contexts 
advantage leads simpler algorithm smaller analysis results 
pointer shape analysis algorithms abstraction points graphs 
nodes graphs typically represent memory locations objects variables edges represent represented entities 
standard technique invisible variables parameterize analysis result di erent call sites 
outside objects invisible variables represent entities outside analysis context 
relationships invisible variables typically determined aliasing relationships calling context type system 
approach relationships outside objects determined structure analyzed method load statement corresponds single outside object 
approach leads simple ecient treatment recursive data structures 
di erence approach previously approaches explicit distinction inside outside edges 
pointer analysis multithreaded programs rinard developed ow sensitive pointer analysis algorithm multithreaded programs 
key complication algorithm characterizing interaction multiple threads interaction affects points relationship 
analysis simply issue 
generates precise results objects escape 
object escapes thread algorithm designed maintain precise information points relationships 
important realize key design decision allows obtain escape analysis results essentially local analysis 
corbett describes shape analysis algorithm multithreaded java programs 
algorithm nd objects accessible single thread objects accessed thread time 
goal information reduce size state space explored model checker 
algorithm intraprocedural address problem analyzing programs multiple procedures 
escape analysis fair amount escape analysis context functional languages 
implementations functional languages create objects example cons cells closures implicitly 
objects usually allocated heap reclaimed garbage collector 
possible lifetime escape analysis deduce bounds lifetimes dynamically created objects perform optimizations improve memory management 
deutsch describes lifetime sharing analysis higher order functional languages 
analysis rst translates higher order functional program sequence operations low level operational model performs analysis translated program determine lifetimes dynamically created objects 
analysis program analysis 
park goldberg describe escape analysis higher order functional languages 
analysis precise deutsch 
conceptually simpler ecient 
main contribution extend escape analysis include lists 
deutsch analysis extracts information runs linear time 
blanchet extended algorithm presence imperative features polymorphism 
provides correctness proof experimental results 
baker describes novel approach higher order escape analysis functional languages type inference uni cation technique 
analysis provides escape information lists 
hannan describes type analysis 
uses annotated types describe escape information 
gives inference rules algorithm compute annotated types 
synchronization optimizations rinard describe algorithms performing synchronization optimizations parallel programs 
basic idea drive locking overhead coalescing multiple critical sections acquire release lock multiple times single critical section acquires releases lock 
possible algorithm lock granularity locks enclosing objects synchronize operations nested objects 
plevyak chien describe similar algorithms reducing synchronization overhead sequential executions concurrent object oriented programs 
research groups developed synchronization optimization techniques java programs 
aldrich chambers sirer eggers describe techniques reducing synchronization overhead including synchronization elimination thread private objects optimizations eliminate synchronization nested monitor calls 
blanchet describes pure escape analysis abstraction type analysis 
implementation uses results eliminate synchronization thread private objects allocate captured objects stack 
describe ow insensitive escape analysis global set inclusion constraints 
implementation uses results eliminate synchronization thread private objects 
limitation analysis designed nd captured objects reachable paths 
choi gupta serrano sreedhar compositional data ow analysis computing reachability information 
analysis results synchronization elimination stack allocation objects 
analysis uses extension points graphs nodes may represent multiple objects 
distinguish inside outside edges contain optimization deferred edges designed improve eciency analysis 
approach classi es objects globally escaping escaping argument escaping 
primary goal compute escape information analysis collapses globally escaping subgraphs single node maintaining extracted points information 
analysis retains information part anticipate thread interaction analyses example extensions existing pointer analysis algorithms multithreaded programs information 
presents new combined pointer escape analysis algorithm object oriented programs 
algorithm designed analyze arbitrary parts complete incomplete programs obtaining complete information objects escape analyzed parts 
implemented algorithm ibm jalape virtual machine applied analysis information optimization problems synchronization elimination stack allocation objects 
benchmark programs algorithms enable stack allocation objects 
enable elimination synchronization operations 
long run believe important concept research may turn designing analysis algorithms perspective extracting representing interactions analyzed unanalyzed regions program 
concept leads representations points escape graphs clean distinction information created locally analyzed region information created rest program outside analyzed region 
representations support exible analyses capable analyzing arbitrary parts program analysis result precise program analyzed 
stage analysis algorithm distinguish complete information 
developers continue move model dynamically loaded component software believe general approach increasingly relevant compelling 
authors acknowledge discussions radu darko marinov regarding pointer escape analysis 
second author acknowledge discussions mooly sagiv regarding pointer escape shape analysis 
rst author acknowledge jong deok choi introducing concept escape information synchronization elimination ibm employee summer 
authors developers ibm jalape virtual machine mit flex project providing compiler infrastructure research implemented anonymous reviewers comments 
aldrich chambers sirer eggers 
static analyses eliminating unnecessary synchronization java programs 
proceedings th international static analysis symposium september 
lars ole andersen 
program analysis specialization programming language 
phd thesis diku university copenhagen may 
goldberg park 
escape analysis lists 
proceedings sigplan conference program language design implementation pages july 
baker 
unifying conquer garbage updating aliasing 
functional languages 
proceedings acm conference lisp functional programming pages 
blanchet 
escape analysis correctness proof implementation experimental results 
proceedings th annual acm symposium principles programming languages paris france january 
acm acm new york 
blanchet 
escape analysis object oriented languages 
application java 
proceedings th annual conference object oriented programming systems languages applications denver november 

removing unnecessary synchronization java 
proceedings th annual conference object oriented programming systems languages applications denver november 
burke choi fink grove hind sarkar serrano sreedhar srinivasan whaley 
jalape dynamic optimizing compiler java 
proceedings acm sigplan java grande conference june 
chatterjee ryder landi 
relevant context inference 
proceedings th annual acm symposium principles programming languages san antonio tx january 
choi burke carini 
ecient ow sensitive interprocedural computation aliases side ects 
conference record twentieth annual symposium principles programming languages charleston sc january 
acm 
choi gupta serrano sreedhar escape analysis java 
proceedings th annual conference object oriented programming systems languages applications denver november 
corbett 
shape analysis reduce nite state models concurrent java programs 
proceedings international symposium software testing analysis march 
dean grove chambers 
optimization object oriented programs static class hierarchy analysis 
proceedings th european conference object oriented programming aarhus denmark august 
deutsch 
determining lifetime aliasing dynamically allocated data higher order functional speci cations 
proceedings th annual acm symposium principles programming languages pages san francisco ca january 
acm acm new york 
deutsch 
complexity escape analysis 
proceedings th annual acm symposium principles programming languages paris france january 
acm acm new york 
rinard 
lock coarsening eliminating lock overhead automatically parallelized objectbased programs 
proceedings ninth workshop languages compilers parallel computing pages san jose ca august 
springerverlag 
rinard 
synchronization transformations parallel computing 
proceedings th annual acm symposium principles programming languages pages paris france january 
acm new york 
emami ghiya hendren 
contextsensitive interprocedural points analysis presence function pointers 
proceedings sigplan conference program language design implementation pages orlando fl june 
acm new york 
hannan 
type analysis block allocation functional languages 
proceedings second international static analysis symposium 
acm acm new york september 
landi ryder 
safe approximation algorithm interprocedural pointer aliasing 
proceedings sigplan conference program language design implementation san francisco ca june 
plevyak zhang chien 
obtaining sequential eciency concurrent object oriented languages 
proceedings nd annual acm symposium principles programming languages san francisco ca january 
acm new york 
ruf 
context insensitive alias analysis reconsidered 
proceedings sigplan conference program language design implementation la jolla ca june 
rinard 
pointer analysis multithreaded programs 
proceedings sigplan conference program language design implementation atlanta ga may 
sagiv reps wilhelm 
solving problems languages destructive updating 
acm transactions programming languages systems january 
lam 
context sensitive interprocedural pointer analysis presence dynamic aliasing 
proceedings ninth workshop languages compilers parallel computing san jose ca august 
springer verlag 
shapiro horwitz 
fast accurate points analysis 
proceedings th annual acm symposium principles programming languages paris france january 
bjarne steensgaard 
points analysis linear time 
proceedings rd annual acm symposium principles programming languages st petersburg beach fl january 
wilson lam 
ecient context sensitive pointer analysis programs 
proceedings sigplan conference program language design implementation la jolla ca june 
acm new york 
tang jouvelot 
control ow ects escape analysis 
workshop static analysis pages september 
