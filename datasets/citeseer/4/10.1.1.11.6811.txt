distributed query processing catalogs peer peer systems vassilis david maier kristin tufte peer peer architectures commonly file sharing applications 
reasons popularity file sharing fault tolerance scalability ease deployment model distributed data management 
introduce scalable framework distributed data management applications mutant query plans xml serializations algebraic query plan graphs include verbatim xml data resource locations urls resource names urns 
show build distributed catalogs namespaces efficiently handle content indexing query routing 
discuss peers convey currency coverage data queries information manage inherent tradeoffs answer completeness timeliness latency 

file sharing systems today peer peer architectures participants simultaneously serve receive files 
systems handle file sharing decentralized fashion 
systems fall back client server architecture indexing searching 
main approaches name popular systems implemented napster called hybrid yg approach centralized group servers indexes permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment proceedings cidr conference ogi school science engineering oregon health science university maier tufte cse ogi edu filenames queries go 
gnutella pure approach central indices maintained queries broadcast node neighbors broadcast neighbors fixed number steps called horizon 
systems successful reasons including ease deployment user installs single package encompasses client server code initial configuration depends knowing fixed index server single installation servers need continuously active 
ease server code bundled user interface application publish search retrieve content 
fault tolerance failure unavailability single server central index disable system 
render content unavailable content ends heavily replicated 
scalability number users amount content increase number servers protocols require communication coordination 
limitations come advantages 
schema queries searching content typically hardwired application bottlenecks centralized index mechanisms combining manipulating content 
interest adapting model distributed data management scenarios 
see major issues current approaches weak query capabilities limitations index scalability result quality 
current systems offer limited querying functionality simple selection predefined set index attributes ir style string matching containment manipulation content 
limitations acceptable file sharing applications people find ways encode metadata file filename general applications require richer query model 
want enable content publishers export cell type connective bone muscle skeletal cardiac smooth neural neurons sensory motor association drosophila organism mus primates homo sapiens mice men 
hierarchies describe query repositories gene expression data 
query mammalian heart cells partially covers database connective muscle rodent cells database human cells 
structured semi structured views data example xml allow users query full featured query language 
terms index scalability result quality napster gnutella approaches serious limitations 
centralized index servers don scale number clients 
query broadcasting wastes network bandwidth hurts result quality limiting availability rare content 
file sharing networks thrive despite limitations finding available copies file usually generalpurpose query systems better 
assumption usually file sharing implementations file potentially replicated node system 
reasonable assumption file sharing systems necessarily true applications general database style applications particular 
content provider want content replicated bulk natural unit retrieval record small level granularity file approach effective evaluation query conditions may require having certain content aggregated lowest price closest location 
describe peer peer architecture distributed querying works application domains content providers specific affinities storing replicating indexing different subsets global data namespace 
peers express preferences data serving looking name space multiple hierarchical categories 
queries routed efficiently depending centralized index servers query broadcasting peers intelligent choices query latency data completeness currency tradeoffs 
example consider different biomedical research groups hosting line repositories gene expression data obtained microarray experiments 
emerging data interchange standards allow groups exchange replicate expression data 
groups choose data host generally research interests 
approach groups indicate interest areas relative organism cell type hierarchies 
see interest areas groups neural cells fruit flies second connective muscle cell rodents third cell types humans 
coverage information site processing query related cardiac muscle cells mammals route query second third site find relevant data ignore site surely 
generally interest areas describe indexing coverage groups data groups data index interest areas 
note defines metadata attributes expression data anatomical location developmental stage 
just categories easy depict graphically 
terms client server participants system 
activities participants act peers notably query submission processing clearly client server 
important distinction model client server model roles exist fixed preassigned query client may query server 
overview rest 
section introduce running example garage sale application mutant query plans coordinator distributed query execution framework 
section multi hierarchic namespaces explain indexing querying 
section discusses peers reason answer completeness redundancy currency answers tradeoffs versus query latency 
section covers issues extensions framework 
section presents related section concludes 

mutant queries garage sale distributed garage sale running example 
garage sale real world situation closely resembles network 
people sell buy things middlemen predetermined seller buyer server client roles 
xml server mqp parser catalog optimizer urn urn urn url mutated qp sub plans cost estimates xml fragments garage sale data items garage sales second hand stores auctions come online 
system simply brings people want sell buy items actual transactions happen outside system 
posit collection local shops handle actual storage sales delivery goods commission operate transfer items closer potential buyer inspection purchase 
participants post information system registered sell particular shop prevents selling directly say garage 
sale item associated data bundle various information item name seller location description condition images quantity price assume sellers export data bundles xml 
notice data structured varied typical file description support meaningful queries query language powerful typical ir string matching interfaces systems 
seller run server publish items sale post server run shop 
queries combine data residing multiple peers 
transferring relevant data central location wastes time bandwidth 
sale data locality terms geographic location category merchandise shop server specializes clothing 
need distributed query execution mechanism run queries closer relevant data 
remainder section briefly describe mutant query plans framework coordination free distributed query execution 
find additional information pm pm 
implemented mqp prototype basic features described section niagara system xml query engine 
mutant query plan algebraic query plan graph encoded xml may include verbatim data resource locations urls query engine subplans evaluate mutant query processing 
policy manager resource names urns 
mqp tagged target network address send result mqp fully evaluated 
ability mutant query plans package query operators data means represent stages evaluation distributed query 
mqp starts regular query operator tree client passed server server accumulating partial results fully evaluated constant piece xml data returned client 
server choose mutate incoming mqp ways 
resolve urn urls url corresponding data 
server reduce mqp evaluating sub graph plan contains data leaves substituting results place sub plan 
plan completely evaluated reduced constant piece xml encoded data server sends target routes plan server continue processing 
shows process detail 
mqp arrives server encoded xml 
server parses plan memory graph determines urns resolve 
optimizer finds locally evaluable sub plans sub plan locally evaluable leaves verbatim xml data urls resolvable urns optimizes estimates costs 
policy manager component decides subplans evaluate forwards execution query engine 
server substitutes resulting xml fragments verbatim xml data place evaluated sub plans serializes mutated plan xml sends server continue plan evaluation 
example suppose looking cds portland area 
sellers publish lists include cd titles 
client list favorite songs online track listing service cdb fdb connect resources 
shows mutant query plan request 
plan includes regular query operators select join display pseudo operator specifies query plan target constant piece xml songs looking urns urn portland cds urn cd 
reduction steps perform mqp resolve resources urns specific urls raw data 
shows steps process 
server resolves urn union seller urls pushes select operator union forwards plan seller servers 
server substitutes cd data url evaluates select reduces part plan constant piece xml data 
series urn url data resolutions sub plan reductions continue plan evaluated forwarded target 
resolution drives query evaluation process 
resolving urls straightforward connect specified server fetch data forward mqp 
current implementation resolve urns consulting catalog maintain locally peer 
catalog contains mappings urns sets urls urns servers know resolve 
traditional distributed query processing depends coordinators servers know data replication statistics optimize query 
mutant query plans need omniscient coordinators allow query optimization source discovery information available locally proceed parallel query execution 
compared traditional distributed query processing mutant query plans trade away pipelining parallelism robustness autonomous optimization peer reduced deployment costs 
preliminary performance comparison ideas hedge bet get parallelism back described pm 
favorite songs display target join song urn cd join cd title select price union select price favorite songs display target join song urn cd join cd title select price urn portland cds mutant query plan 
interesting new optimization issues pm 
example 
server materialize partial results ship mutated query plan server 
transfer partial results network size matters 
come query rewritings help mqp optimization regular query optimizers normally consider 
suppose resources available locally 
know reduce network traffic rewriting evaluating left branch 
depending number tuples join may opt evaluate right outer join locally rewriting plan mutant query execution server turn optimizes plan executes materializes temporary results reminiscent ingres style query evaluation swk wy query decomposition interleaves sub query execution optimization 
favorite songs display target join song urn cd join cd title seller cd titles union select price steps evaluation mutant query resolution rewriting reduction 

distributed catalogs previous section glossed important issue mutant query plans systems general peers find resources available peers 
example know resolve urn union urls 
matter user formulating query know portland cd resource query 
want network maintain distributed catalogs efficiently route queries peers relevant data 
index structure scale distributed partitioned peers 
believe main obstacle building distributed catalogs file sharing systems flat filename namespace peer potentially serve file 
applications garage sale richer structured metadata content 
section describe peers namespaces categorize data data providers multi hierarchic namespaces describe kind data serve data consumers formulate queries 
detail different roles peers play system resource resolution process 

multi hierarchic namespaces ways data attributes organize data 
example location place items garage sale categories seller country state city 
categorization means possible choose various categorization schemes find online auction sites define categories price weight color categorization schemes flat categorizing price items costing vs items costing hierarchical categories specified different granularities levels 
usa portland items located portland city level category france country level category 
call multi level categorizations categorization hierarchies 
categorization hierarchy item belongs category called specific category parents 
example item usa portland category belongs usa usa categories 
main idea distributed catalogs applications distribution underlying data servers random 
case data stored grouped replicated queried categorization hierarchies natural application 
items sold seller garage sale usually address 
address usa portland prospective buyers come portland locations close portland location hierarchy 
people collect things baseball cards cds books am trading baseball cards chances 
assumption holds natural categorization hierarchies build distributed indices query routing 
call set categorization hierarchies relevant application domain namespace 
borrow olap terminology call hierarchy multi hierarchic namespace dimension 
assume dimension inclusive top category called 
simplicity example focus just dimensions merchandise location 
merchandise typical categorization scheme see online auction sites ebay 
armchair example classified furniture chairs 
location level country state city hierarchy 
visualize dimensions axes coordinate system 
see parts multi hierarchic namespace 
coordinates item system expressed tuples usa portland furniture tables 
see interest areas subsets cross product dimensions 
interest area interest cells 
interest cell cross product category location dimension category merchandise dimension 
interest cells expressed tuples 
example usa furniture cell includes pieces furniture united states 
interest area covers furniture vancouver usa wa vancouver furniture portland usa portland furniture area covers item sale portland usa portland 
say interest cell covers interest cell dimension namespace category dimension parent corresponding category interest area covers interest area interest cell covered interest cell interest areas overlap exists cell cover 
data providers interest areas describe kind data serve 
data consumers interest areas form queries 
suppose looking second hand portland area 
interest area usa portland furniture chairs contact servers interest areas overlap find pertinent items 

peer roles point defined terminology describe various roles peers perform system 
peers choose perform roles base server maintains replicates named collections data interest area 
seller example interest area usa portland music cds 
index server keeps track base servers index servers interest areas overlapping 
index server garage sale index example servers overlapping usa 
index servers maintain indices data attributes categorization price 
meta index server index server maintains multi hierarchic namespace indices keeping track base index meta index servers interest areas overlapping 
category server answer queries dimensions immediate subcategories furniture 

index server entry base data item includes url containing host name port number base server xpath cd expression base server identifier collection 
example index server usa include golf clubs available seller site data id 
note server interest area completely describes data guarantee server stores indexes data interest area way statement system allow relative statements server contains server data interest area see section 
tradeoff server index area detail indices maintains reason having index server meta index server role 
richer extra indices better route query 
hand extra indices resources updated base data change limiting scalability 
meta index servers afford cover larger interest areas index servers maintain multi hierarchic namespace indices 
peers maintain caches index meta index servers past 
peer joins network time discover category servers meta index servers serve top level categories example meta index server covers france obviously network 
peer software include hardwired locations servers preferably discover band example doing search web search engine 

authoritative servers authoritative server strives know base servers area interest 
routing plan furniture electronics tables chairs tv vcr france authoritative index meta index server allow find known base servers particular interest area 
realistic scenario group servers chooses stay authoritative area guaranteeing union answers includes paths relevant base servers 
base server joining network needs register index meta index servers intersect interest area data available peers 
ideally servers registers include authoritative servers union covers interest area 
servers specific interest areas push data existence authoritative server covers 
complementary pull process index servers query base servers data build detailed indices 
index meta index server wishes authoritative interest area find detailed authoritative server group covers 
point server register servers group start receiving registrations updates servers interest area start receiving queries 
update propagation pull pull process 

resource resolution wa ca seattle vancouver portland eugene multi hierarchic namespace categorization dimensions highlighted interest areas vancouver portland furniture items portland 
form queries encode interest areas namespace specific string part urns treat structured entities opaque strings 
example encode interest area urn usa portland usa wa vancouver furniture encoding purely lexical process interest area notation urn syntax 
server trying resolve urn seek authoritative index meta index server covers recursively follow index finds relevant base servers data items finds data items case user asked top type query 
example query urn trying resolve interest area usa portland music cds 
client may know authoritative meta index server usa sends query plan 
server may forward query plan server usa music may forward server knows usa music reach index server replace urn combination urls 
avoid flooding high level servers plans peers maintain caches index meta index servers interest areas route plans efficiently 
guarantee find authoritative server query 
may find servers part query interest area get complete answer may contact multiple servers collectively cover interest area 
usually data provider best interest register data authoritative servers sellers garage sale example reach widest possible audience 
restricted context corporate intranet data providers compelled provide absolute service guarantees 
fortunately internet services users learned expect 

category servers category servers maintain data categorization hierarchies 
categorization hierarchies administered independently imagine location hierarchy managed post office 
system uses categories index construction query formulation important relatively stable consistent 
fortunately expect hierarchy nodes higher levels stable countries state names change frequently zip codes road names 
nodes hierarchy properly contain descendents approximate hierarchy node don know ancestors 
example rewrite usa portland usa possible loss precision loss recall 
index meta index servers category servers cooperate manage namespaces 
category servers delegate portions namespace manage category servers way dns servers delegate sub domains servers 

completeness redundancy currency latency section discuss index meta index servers convey relationships data cover mutant queries information intelligent choices completeness currency latency tradeoffs 
simplify formulas specify coordinates detailed levels example write portland usa portland meaning clear context 
res denote result evaluating query expression completeness redundancy distributed catalog architecture described previous section meta index servers map interest areas collections urls index base servers possibly meta index servers 
implicit semantics interest area covered union urls 
simple interpretation problematic reasons 
servers may wholly partially redundant 
example index server portland sporting goods server oregon golf clubs redundant query involving portland golf clubs 
second problem know sure consulted meta index servers 
reveal previously unknown index base servers interest area just previously discovered ones 
catalog scheme benefit servers announce policies replicate index information servers 
simplest intensional statement server say exactly duplicate contents server meta index index base 
useful intension replicate area interest 
example server replicate server portland category location hierarchy 
express intensional statement base portland base portland 
statement instance coordination formula defined bernstein bgk simplified syntax 
complicated relationship base oregon sporting goods base portland golf clubs base eugene golf clubs see oregon sporting goods information holds portland eugene golf clubs note intensional statement equivalent pair base portland golf clubs base portland golf clubs base eugene golf clubs base eugene golf clubs statements contain data items oregon sporting goods portland eugene golf clubs 
replication occur meta index index levels example index portland index portland capture connections different levels different servers 
example indicate index oregon golf clubs covers exactly base records write index oregon golf clubs base oregon golf clubs index base servers 
example covers base data servers intensional statement index oregon golf clubs base oregon golf clubs base oregon golf clubs base oregon golf clubs general exact replication strict 
may wants replicate portland possibly keep additional data portland 
case intensional statement base portland base portland knows portland possibly 
utilizing intensional statements intensional statements processing 
server registers interest area meta index server provide intensional statements meta index server retain 
servers information binding routing 
incorporate information intensional statements mqp allow new operator plans 
written viewed union saying expression connects holds necessary data index information 
essential semantics captured pair rewrite rules example assume meta index server knows servers interest areas portland recreation oregon sporting goods respectively 
suppose receives mqp contains resource name portland golf clubs 
basic catalog structure described section name bound base portland golf clubs base portland golf clubs addition knows intensional statement base portland sporting goods base portland sporting goods bind base portland golf clubs base portland golf clubs mqp routed need go 
example consider intensional statement index coverage index oregon golf clubs base oregon golf clubs base oregon golf clubs base oregon golf clubs mqp resource name portland bound index oregon golf clubs base oregon golf clubs base oregon golf clubs base oregon golf clubs mqp routed needed directly order 
example consider containment statements 
assume meta index server knows servers intensional statement base portland base portland suppose receives mqp resource name portland cds 
possible binding name base portland cds base portland cds base portland cds base portland cds correct 
second binding particularly useful glance 
conditions sense 
mqp passes server reasons evaluation reduce intermediate result size 
consider mqp contains partially evaluated sub expression res base portland cds base portland cds 
expression transformed res base portland cds base portland cds difference evaluated may smaller res 
reasons prefer second binding may unavailable point partial answer query replicates delay see section want current answer 

currency latency loosely coupled internet setting impossible guarantee queries run instantly complete latest information 
compromises latency completeness currency 
query issuer control tradeoffs 
example user may willing sacrifice completeness fast answer prefer completeness currency query fixed time budget 
recognize replication servers scalable instantaneous 
servers periodically contact servers update content 
extend intensional statements include possible delay factor 
example suppose server polls minutes update data replicates express intension base portland base portland saying replicates portland minutes date 
referring back example binding resource portland cds base portland cds base portland cds base portland cds 
binding indicates get answer quickly just routing mqp answer minutes date 
alternatively routing mqp complete current answer modulo delay finish evaluating mqp routing back client 
latency query evaluation longer second case need visit sites 
imagine quite rich schemes expressing user preferences latency completeness currency query processing strategies meet preferences 
initial inclination start simple query carries target evaluation time seconds plus binary preference complete versus current answers 
simple expression tradeoffs expect develop non trivial methods binding evaluation routing 

issues extensions section discuss possible extensions framework issues security privacy 

carrying additional information described process mqp evaluation terms binding urns urls indexes data data replacing evaluable subexpressions results 
initial implementation works manner 
see reasons support annotation urns urls retain copy original query plan mqp gets evaluated 
describe uses information 
accumulating catalog statistics information 
mqp passes server server may information portions query chooses evaluate may useful processing steps 
example consider server gets mqp evaluate suppose elements 
may decline evaluate point size res 
forwarding intact server annotate cardinality unique cardinality join column histogram 
servers avoid sending back server additional data give smaller result maintaining original query partially evaluated query allows server improve enhance bindings undo 
example server add possible urls urn knows 
server improve catalog information examining urn original query set urls partially evaluated query 
maintaining provenance 
mqp carry history servers visited provided bindings provided data mqp evaluated sub expression merely forwarded mqp current information 
provenance final destination intermediate servers variety purposes judging quality answer knowing processing history query allow judgment currency completeness result 
rewards system server observes queries getting data indexes maintained server reward way 
example devote larger percentage index space data return 
meta index updating server getting lot forwarded server just ends forwarding server able send entry allow route queries directly observe declines bind source holds copy decide route needing 
detection spoofing point assuming mqp servers behave correctly certainly maliciously 
server tried tinker queries detriment competitor server 
example server may get mqp expression data records records bind actual value bind empty set making appear qualifying items 
provenance recorded resulting mqp show visited site 
provenance appear participated possible construct verification query count send check result provenance trustworthy addition digitally signed server adds encrypted public key destination site 
provenance complete solution misbehaving server 
example hard detect lying contents 

security privacy distributed application issues security privacy arise soon data sent site 
transit security difficult difficult distributed query approaches 
security privacy mqp servers raise new issues 
coordinator subordinate model distributed query processing queries data sent subordinate servers 
assumption hold semi joins bc distributed processing 
data form partial results possibly unknown servers may undesirable 
example query submitter want music preferences known track list server 
intermediate server want data exposed competitor server line 
need incorporate ordering transfer policies bind preferences playlist bound mqp pass servers list obviously restrictions challenging support general loosely coupled environment 
alternative cases encrypt data data elements public key result recipient encrypted data limit evaluation options en route 
point allow query submitter obtain answers obtainable server security policies conventional distributed query processing 
may servers allow data pass directly divulge third party 
example suppose law enforcement agency wants know employees charitable contributions organizations believed fronts illegal activities 
irs tax returns showing deductions contributions state department list front organizations 
irs may disclosing contributions employees state department may want reveal list suspect organizations 
irs willing pass data state department knowing query mqp query executed manner 
mqp goes irs names people forms charity names charitable deductions schedule 
information bound mqp travels state department 
results irs joined front organization list projected person name 
fully evaluated mqp routed back law enforcement agency 
irs state department disclose excessive sensitive information agency 

related find general mutant query plans prototype implementation preliminary performance comparison traditional pipelined distributed query execution previous pm pm 
query optimization issues mutant query plans include consolidation rewriting plan locally evaluable sub plans come absorption plan rewritings sense pipelined query execution reduce size partial result avoiding local execution operators increase partial result size 
categorizing things hierarchies course new idea humans doing 
dns ldap hs examples widely deployed systems hierarchical namespaces 
dns particular managed scale exponential growth amount data indexes serves mappings human readable machine names ip addresses 
dns server covers defined address space new branches domains added accommodate growth 
dns queries hostname resolutions served caches clients system contact servers resolve host name 
contribution system combined categorization data multiple hierarchies accommodate different types users different viewpoints ways group data 
gribble ghi benefits established data management techniques stronger semantics theoretical underpinnings databases networks 
bernstein bgk introduce local relational model lrm data model database applications 
lrm peers declarative coordination formulas describe relationships constraints schemas 
intensional statements describe relationships index meta index servers expressed coordination formulas 
distributed hash table dht algorithms active research area 
systems chord pastry rd tapestry offer scalable hashtable interface extremely fast lookups usually logarithmic number hosts 
fast key lookups provide data manipulation capabilities regularly expect database range queries joins 
harren hhh analyze issues describe missing pieces including hierarchical namespace need order build query processor top dhts 
assumption frequently dhts system decides nodes route index store cache data benefit 
assume loosely federated system decisions left peers depend application 
gene expression data scenario expect laboratories serve authoritative sources data volunteer index cache data related areas 
government agencies nih provide meta index services fund development controlled vocabularies ontologies 
interesting alternative mariposa microeconomic paradigm sal peers buy sell data objects place bids execute subqueries 
describing server holdings interest areas instance summarization idea widely olap community 
walker analyzed conditions query summarized database gives correct answers proposed succinctness ordering comparing quality inexact answers 
lakshmanan lnw generalization minimum description length principle summarization lead fewer summary regions allowing regions contain don care cells 
ideas intelligent routing query plans intensional statements server coverage completeness redundancy form semantic query optimization 
chakravarthy cgm order logic formalize framework deductive relational databases 
levy sagiv ls studied effects allowing recursive rules order constraints negated subgoals rules integrity constraints deductive database 
applied techniques object databases 
hsu knoblock hk optimize distributed queries local level eliminating redundant joins global level minimizing data transmission 
yang garcia molina yg compared performance hybrid architectures filesharing networks analytical models experimental data 
hybrid architectures peers transfer data autonomously depend central servers indexing querying 
compared performance various search strategies pure architectures yg data gnutella network 
crespo garcia molina cg proposed routing indices ri direct queries pure networks 
ris distributed indices maintained node guide query promising neighbors node terms number relevant documents network distance 
ris record promising directions addresses reasonable storage requirements 
presents system running containment queries documents network 
system maintains peer inverted indices pis node 
pis map keywords number usually smaller number documents peers documents contain 
bayardo bag implemented system called hosting web content peers collaborate host replicas web sites 
uses dynamic dns map urls replicas currently serving 
major difference proposal file sharing systems granularity file sharing system peers store replicate index query data file chunks hand allow peers deal semi structured data level 

framework distributed data management mutant query plans namespaces 
mutant query plans enable peers independently optimize partially evaluate queries global knowledge minimum coordination overhead 
main assumption data query result distributions mapped naturally multi hierarchic namespaces allowing build decentralized indices efficient query routing 
believe assumption reasonable just garage sale example wide range data management applications 
freire lois delcambre pete tucker suggestions ideas 
funding provided darpa navy contract nsf itr award iis 
liu 
dns bind 
th ed 
reilly associates 
bag bayardo jr agrawal gruhl 
web hosting content sharing tool masses 
proc 
www 
bc bernstein 
chiu 
semi joins solve relational queries 
jacm 
minimum information microarray experiment standards microarray data 
nature genetics dec 
bgk bernstein giunchiglia kementsietsidis mylopoulos serafini 
data management peer peer computing vision 
proc 
webdb pages 
cd clark derose editors 
xml path language xpath version november 
available www org tr rec xpath cdb com music cg crespo garcia molina 
routing indices peer peer systems 
proc 
int 
conf 
distributed computing systems 
july 
cgm chakravarthy minker 
logic approach semantic query optimization 
acm tods june 
fdb org ghi gribble halevy ives suciu 
databases peer peer 
proc 
webdb 
minker raschid 
semantic query optimization object databases 
proc 
icde pages 
wang jeffery dewitt 
processing xml containment queries large peer peer system 
available cs wisc edu niagara papers pdf hhh harren hellerstein huebsch loo shenker stoica 
complex queries dht peer peer networks 
iptps pages 
hk 
hsu knoblock 
semantic query optimization query plans heterogeneous multidatabase systems 
ieee transactions knowledge data engineering pp 

hs howes smith 
ldap programming directory enabled applications lightweight directory access protocol 
macmillan 
lnw lakshmanan ng xing wang zhou johnson 
generalized mdl approach summarization 
proc vldb 
ls levy sagiv 
semantic query optimization datalog programs 
proc 
pods pages 
naughton dewitt maier chen kang krishnamurthy luo prakash shanmugasundaram tian tufte wang zhang jackson gupta chen 
niagara internet query system 
ieee data eng 
bulletin 
pm maier 
mutant query plans 
information software technology april 
pm maier 
distributed queries distributed state 
proc 
webdb pages 
rd rowstron druschel 
pastry scalable distributed object location routing large scale peer peer systems 
proc 
ifip acm middleware 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proc 
acm sigcomm pages 
sal stonebraker aoki litwin pfeffer sah staelin yu 
mariposa wide area distributed database system 
vldb journal 
stoica morris karger kaashoek balakrishnan 
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm pages 
swk stonebraker wong kreps held 
design implementation ingres 
acm tods 
walker 
retrieval small version large data base 
proc 
vldb 
wy wong 
decomposition strategy query processing 
acm tods 
yg yang garcia molina 
comparing hybrid peer peer systems 
proc 
vldb 
yg yang garcia molina 
improving search peer peer networks 
proc 
international conference distributed computing systems pages 
zhao kubiatowicz joseph 
tapestry infrastructure fault tolerant wide area location routing 
tech 
report ucb csd berkeley 
