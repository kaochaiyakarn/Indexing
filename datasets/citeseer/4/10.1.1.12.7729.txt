submitted ieee int 
symp 
code generation optimization distribute widely dynamic binary translation accumulator oriented architectures ho kim james smith department electrical computer engineering university wisconsin madison jes ece wisc edu dynamic binary translation system designed virtual machine described evaluated 
underlying hardware directly executes accumulator oriented instruction set exposes instruction dependence chains strands distributed microarchitecture containing simple instruction pipeline issue logic 
support conventional program binaries source instruction set compaq alpha study dynamically translated target accumulator instruction set 
binary translator identifies chains inter instruction dependences assigns dependence carrying accumulators 
underlying superscalar microarchitecture capable dynamic instruction scheduling binary translation system perform aggressive optimizations re schedule code significantly reduces binary translation overhead 
part study evaluate instruction set modification simplifies precise trap implementation 
approach significantly reduces number instructions required register state copying improving performance 
observe translation chaining methods substantial impact performance evaluate number chaining methods 
detailed timing simulation binary translation system way distributed microarchitecture cycle inter cluster communication latency shows system capable achieving similar performance ideal way order superscalar processor ignoring significant clock frequency advantages 
translation overhead proposed mechanism shown quarter previous vliw dynamic binary translator 
promising paradigm processor development design instruction set architecture isa microarchitecture dynamic binary translation system cooperatively support existing virtual isa 
research targeted designed virtual machine vm provides high performance simple distributed superscalar processor tolerates increasing chip wire delays amenable high clock frequency 
key element designed vms dynamic binary translation dbt visible virtual isa isa implementation isa isa 
studies aspects evolving designed vm emphasis dynamic binary translation system 
research compaq alpha instruction set isa accumulator oriented instruction set isa 
fig 
illustrates designed vm studying 
subsections provide overview 
translated code main memory virtual machine monitor includes dbt subsystem legends isa instructions isa instructions data value communication performance feedback isa program processor front includ ing cache instruction level distributed processing distributed processing element incl 
cache pe 
dynamic binary translation system running processor pe microarchitecture trend distributed modular designs containing partitioned issue buffers clusters functional units 
distributed microarchitectures tolerant intra processor wiring delays contain smaller faster logic subsystems 
research focused isas supporting implementations naturally fit distributed design style instruction level distributed processing 
isa proposed hierarchical register architecture small number accumulators top larger general purpose register gpr file 
accumulators naturally partitions instruction stream chains dependent instructions strands intra strand register values passed accumulators 
inter strand communication gprs 
microarchitecture consists multiple distributed processing elements pes 
pe contains instruction issue fifo local register accumulator local copy gprs 
communication pes assumed take small number clock cycles explicitly accounted 
collectively hierarchical value communication parallel order issue units distributed implementation provide simplicity yield high clock speed moderate pipeline depth supporting complexity effective form superscalar order issue 
dynamic binary translation dynamic binary translation dbt converts instructions source isa target isa 
designed vm paradigm isa isa isa existing instruction set conventional software exists compaq alpha research 
dbt system profile program run time behavior dynamically optimize frequently executed program codes dynamic optimizers 
key consideration design dbt system overhead resulting translation time time spent translating time spent executing source program 
dbt design focus simplicity underlying hardware dynamic superscalar relied provide code scheduling 
optimization provide code straightening basic blocks statically located accordance common dynamic execution order branch directions changed accordingly 
known optimization similar static code layout techniques captures low hanging fruit dynamic optimization improving instruction cache locality branch prediction behavior 
related 
designed virtual machines studied ibm daisy boa projects implemented transmeta crusoe targeted vliw implementations 
research targeted dynamic superscalar implementations 
believe approach better balances strengths hardware software results lower overhead binary translation 
trying maximize instruction level parallelism static vliw microarchitecture aggressive optimization scheduling techniques dbt system simply identifies inter instruction dependences encodes information accumulator assignments changing original program order 
area targeted dynamic binary translation existing instruction set code portability primary goal 
typically code optimizations implemented isa specific performance goal reducing losses come reasonably close native isa execution 
furthermore focused abi translation full isa translation case designed vms 
dynamic optimization translation studied 
primary objective performance improvement techniques code straightening software code caching related dbt 
accumulator oriented isa basic isa simplest way describe accumulator oriented isa example taken 
denote accumulators ai gprs rj 
accumulator isa code third column fig 
accumulators link chains dependent instructions 
feature isa instruction contains gpr source destination register 
form instructions encoded bits reducing code footprint 
addressing modes perform address computation done separate instructions 
crc tab int xff source code alpha assembly code equivalent register transfer notation isa code mem mem subl lda xor xor xor srl xff xff xff addq ldq mem mem xor xor xor bne alpha assembly code equivalent register transfer notation corresponding accumulator isa code 
example program segment spec benchmark gzip initial study consider implementation precise traps dbt 
goal research consider performance impact implementing precise traps evaluate isa modified simplify precise trap implementation 
section describes precise trap problem initially proposed accumulator isa subsection describes modified isa 
effect trap recovery mechanisms accumulator isas trap recovery mechanism fundamental aspect designed vm provide exactly trap behavior isa semantics define 
accumulator isa problematic mapping gpr value accumulator lossy transformation 
trap condition occurs middle accumulator sequence previous values accumulator overwritten lost making impossible restore corresponding isa gpr values 
solution insert additional instructions copy key accumulator values gprs maintain sufficient state 
example done employing translation group boundaries software checkpoints similar hardware supported transmeta crusoe checkpoints 
approach dbt system inserts copy gpr instructions instructions produce live translation group boundary values 
exception happen virtual machine monitor vmm takes restores previous checkpoint values re interprets current translation group current translation group faulting instruction 
isa program isa translation condition true translation time temporary true translation time translation interpret 
problem isa state maintained conditional branch boundaries additional problem conditional branches register indirect jumps may result loss isa state 
consider example fig 

suppose translation generated condition true 
result direction followed part converted unconditional branch different translation 
control flow translation time value considered dead translation boundary assigned accumulator 
run time control flow changes condition hold true value lost translation boundary 
prevent problem conditional branches require extra copy gpr instructions checkpoint accumulator values back gprs 
similarly boa maintains isa state translation exit boundaries 
modified isa alternative explicit copy instructions suggested previous subsection embed gpr updates instruction set 
modified isa instructions need bits designate result gprs bit instructions bits 
small footprint benefit having bit instructions lost 
copy gpr instructions necessary advantages accumulator instruction set remain 
translation condition branch translation strand checkpoint translation boundary translation 
modified isa instruction producing result specifies destination gpr maintain architected state 
means strictly speaking architected accumulators longer needed 
accumulator identifiers strand identifiers accumulators remain implementation 
effect strand identifiers dual independence bits ia instruction set 
typically refer strand identifiers 
maintain implementation simplicity processor core studying microarchitecture separate register file critical path maintained solely keep architected gpr state precise traps 
values needed computation written operational gprs critical path 
effectively writes implementation described 
detail scope 
fig 
shows example code segment fig 
translated basic modified isas 
modified instruction set result registers explicitly accumulators strand identifiers parentheses 
note basic isa translation slightly different original accumulator code fig 
value produced mem saved copy instruction live translation exit 
note conditional branch translated combination conditional branch unconditional branch code chaining reasons chaining explained section detail 
rtl notation basic isa modified isa mem mem mem xor xor xor xff xff xff mem mem mem xor xor xor 
example code segment translated basic modified isas dbt accumulator isa section discuss dbt proposed accumulator isa 
subsections discuss dbt process including fragment formation chaining 
fragment formation dbt mechanism follows common phase interpret profile translate optimize model existing dynamic optimizers binary translators 
basic unit translation superblock code sequence single entry point multiple exit points 
translated superblocks placed translation cache referred fragments 
fragment formation algorithm slightly modified version dynamo executed tail heuristic 
dbt system starts interpreting isa program 
course interpretation execution frequency counters maintained possible trace start candidate instructions 
trace starting candidates targets register indirect jumps jmp jsr ret alpha isa targets backward conditional branches exit targets existing fragments counter execution frequency reaches predefined threshold interpreted path followed generate fragment 
heuristic form simple software speculation observation instruction hot statistically sequence executed instructions hot 
fragment conditions register indirect jumps trap instructions backward taken conditional branches collected instructions cycle predefined maximum number instructions reached newly translated fragment placed translation cache 
program control flow reaches existing fragment translated instructions fragment executed directly hardware 
important byproduct hot trace optimizations translations dynamic code straightening automatically performed basic blocks commonly occur sequence dynamically placed statically 
fact reports half performance improvement moderately optimized binaries comes dynamic code straightening 
fragment chaining translated fragment executed fragment exists 
simple implementation fragment jumps dbt system determine fragment translated find location translation cache hash table 
limit number expensive translation cache lookups chaining mechanism essential 
furthermore supplement conventional chaining designed vm provides ability implement special instructions isa reduce fragment transition overhead 
direct branches conditional unconditional relatively easy handle taken target addresses change program execution 
unconditional direct branches simply removed code straightening save return addresses changed special save isa return address instructions save return addresses 
conditional branch taken translation time condition reversed allow continuous fetching 
superblock exit target path followed translation time translation cache special call translator condition met instruction generated branch 
target instruction hot translated dbt system replaces call translator condition met instruction normal conditional branch instruction 
employing special instructions necessary generate stub code conditional branches exit translated superblocks 
register indirect jumps jmp jsr ret alpha isa pose challenge target addresses change program execution 
save lookup overhead dynamic optimizers translators implement form software jump target prediction 
short optimized sequence instructions accesses hash table fragment start addresses 
target hash table control transferred dbt system 
sequence instructions compares indirect target address held register embedded translation time target address 
match indicates correct prediction embedded translation address code branches stub code fragment 
software jump target prediction correct adds overhead additional compare branch code 
worse prediction fails stub code needs executed anyway 
return instructions pose serious problem target addresses change frequently indirect jumps 
daisy system cuts performance losses allowing multiple compare branch codes single return instruction 
modern processors contain hardware return address stack mechanism predict return instruction target address accurately 
dbt conventional hardware return address stack utilized track source isa return addresses 
improve performance propose designed hardware return address stack mechanism contains pairs isa return addresses corresponding isa return addresses 
return instruction executes register value checked isa return address popped stack 
match prediction successful 
don control redirected stub code 
additional details scope similar idea proposed 
section evaluate fragment chaining implementations 
dbt algorithm major function translation process identifying strands re mapping intra strand temporary values accumulators 
nature dynamically constructed superblock translation need graph traversing dependence analysis usually register allocation algorithm static compilers 
high level outline translation algorithm 
algorithm appears contain multiple passes sequential scans combined single pass 
memory instructions non zero address offset requiring address computation instructions input registers decomposed sub instructions 
dependence usage identification hot code sequence interpretation instruction dependences previous instructions superblock identified 
addition usage input output registers examined determine values 
global values placed globally visible general purpose register file 
important usage categories 
note determined usage superblock 
user output register value overwritten 
instruction output value naturally ends strand 
local output register value overwritten superblock 
candidates assignment accumulators 
temp values passed decomposed instructions load stores effective address computations conditional moves 
assigned accumulators 
live global input register values live superblock entry assigned gprs 
live global output register values live superblock exit assigned gprs 
communication global register values overwritten superblock assigned gprs 
spill global instruction local input registers spill global isa allow different accumulators instruction 
strand terminated free accumulator see local value converted spill global 
strand formation dependence input register usage patterns instructions scanned strand number assigned instruction 
translator uses unlimited number strands assigned finite number accumulators 
temp usage treated way local 
instruction zero local input registers strand started new strand number assigned 
furthermore instructions global input registers broken target instructions copy gpr accumulator instruction translated source instruction uses local result copy input 
copy instruction initiates strand source instruction local input register handled accordingly 
local input register assigned strand number instruction producing local value 
local input registers heuristic needed decide strand number assign 
input registers temp temp producer strand number assigned 
number assigned corresponds longer strand point length determined instruction count 
accumulator assignment strand numbers converted finite accumulator numbers 
traditional graph coloring heuristic assign accumulator numbers strands simple sequential scan heuristic 
translator runs accumulators live strand chosen termination accumulator freed 
done inserting copy gpr accumulator instruction strand termination point copy gpr accumulator instruction prior resumption point 
determining adequate number logical accumulators important program characteristics evaluated section 
evaluation methodology aim evaluate performance impact proposed dbt algorithm microarchitecture 
real designed vm dbt vm software execute implementation isa 
current simulation environment impractical 
consequently dbt system written compiled execute simulation platform simplescalar running intel clusters 
simulated dbt system perform interpretation binary translation sequence designed vm 
simulation constraint benchmarks run relatively short executions times compared real applications 
consequently interpretation translation overheads small disproportionately large benchmarks 
systems interpretation translation optimizations overhead reasonable 
respect interpretation special 
techniques suffice interpretation overhead 
instruction interpreted times threshold value interpretation takes instructions total target instructions source instruction 
typically binary translation overhead order magnitude higher interpretation thousands instructions translated source instruction 
pointed earlier translation overhead proposed system relatively low evaluate overhead section 
evaluate performance focus detailed simulation translated code including chaining code 
simulation system switch interpretation translation execution modes 
simulated program control flow reaches previously translated fragment simulator begins detailed timing simulation 
timing simulation starts initially empty pipeline 
similarly exit condition timing simulator met target fragment translation cache indicated call translator instruction mode changed interpretation translation instruction pipeline committed 
performance measured instructions cycle ipc execution translated chained instructions 
noted translation overhead evaluated separately manner described 
evaluate performance dbt simulators 
perform translation alpha accumulator instruction sets basic modified sections third converts alpha binary code straightened version alpha isolate effects code straightening fragment chaining dbt performance effects 
referred code straightening simulator subsections 
collect statistics spec integer benchmarks compiled alpha ev isa base optimization level arch ev non shared fast 
compiler flags reported compaq alphaserver es spec benchmark results 
dec eon rest compilers digital unix 
test input set benchmarks perlbmk train input set lib pl 
benchmarks run completion instructions 
skipping initialization phase simulating part program ref input sets frequently done microarchitecture research exaggerated benefits dbt 
translation maximum superblock size threshold 
logical accumulators opposed 
accumulators generally sufficient strands prematurely terminated free accumulator 
study unlimited number tail counters 
programs size spec benchmarks number tail counters relatively small 
static code size spec benchmarks mbytes gcc mbytes means comfortably fit reasonably sized translation cache 
translation cache management required research indicates overhead generally negligible 
fact may performance cost occasionally flushing translation cache entries 
fragments may sub optimal fragment constructed second chance forming different fragment starting address 
dynamo example fragment cache flushed change program phase indicated abrupt increase fragment generation rate evicting infrequent fragments cache allowing new fragment formation 
translation overhead measure translation overhead compiled dbt simulator tool alpha isa built instrumented version atom tools alpha system running tru 
instrumented version run spec benchmarks 
number dynamic instructions alpha reported procedure 
averaging total number instructions executed translation related procedures number translated instructions gives average number dbt instructions required translate single instruction 
average alpha instructions executed translate single alpha instruction table section contains benchmark results gap mcf profiled runs complete due technical difficulties 
number quarter powerpc instructions needed translate powerpc instruction reported 
note dbt code current form written translation speed flexibility simulation example average instructions spent copying high level data structures represent translated instructions translation cache structure 
feel optimizations translation speed reduce number instructions translated instruction 
evaluation fragment chaining methods code straightening simulator evaluate effect fragment chaining 
chained fragments show different branch jump prediction behavior original source binary 
example single register indirect jump source replaced compare branch sequence plus optional stub code containing jump 
number type control transfer instructions changed 
estimate performance effect different fragment chaining options tested different implementations 
results fig 

predictor performance measured relative increase total branch jump mispredictions compared original alpha code 

branch target address ic io ns ip ty eon gap implementation pred shared software prediction branch shared stub code generated 
stub code performs translation cache lookup find fragment 
single indirect jump shared stub code uses fragment start points targets address prediction rate extremely low compared original program 
ip parser second implementation pred private employs private stub fragment predictable indirect jumps stub ends 
implementation shows perlbmk tw lf te 
relative number branch target address mispredictions pred red pred riva re red re riva re red ra improved performance shared stub code twice address mispredictions original alpha code 
third fourth implementations software prediction shared stub code pred shared private stub code pred private 
software prediction code helps shared stub case significantly reducing number executions stub code 
interestingly prediction private stubs reduce number branch address mispredictions fact slight increase versus software prediction 
shows inherent limit simple translation time prediction 
final implementation pred shared hw ras uses specialized hardware return address stack ras described section 
method achieves nearly number branch address mispredictions original alpha code 
individual benchmarks fewer happen unconditional indirect branches moved inside straightened fragments reducing pressure branch target buffer 
note shared stub code preferred reduces cache pressure compared private stub code 
implementation baseline simulations 
ip ip ty ip fig 
code straightening performance compared original program performance 
straightened version ras performs level original program ras 
benefit code straightening offset branch address mispredictions increased number instructions executed speculation stub code 
hand baseline model plus ras performs better original lb 
performance impact code straightening return address stack tw lf te hm rig inal ra rig inal hw ra tra ras tra ras program ras 
example special hardware features specifically designed designed system 
performance improvement code straightening suggests 
important factor dynamic optimizer dynamo choose bail performance improvement dbt system 
believe large mb cache dynamo pa processor reason discrepancy 
large cache increased code footprint relatively little performance impact 
pa hardware return address stack 
dbt characteristics consider characteristics translated code 
nop instructions removed translation counted original alpha program characteristics 
benchmark relative number dynamic instructions basic isa isa table 
translated instruction statistics copy instructions basic isa isa relative number static instruction bytes basic isa modified isa indirect jump related instruction indirect jump code expansion rate number alpha inst translate alpha inst bzip crafty eon gap gcc gzip mcf parser perlbmk twolf vortex vpr average second third columns table shows increase dynamic instructions compared alpha code 
basic isa shows increase average modified accumulator instruction set half increase 
modified isa significantly fewer translated instructions generate copy gpr instructions maintain isa architected state 
shown columns instructions copy gpr instructions modified isa compared percent basic isa 
hand fragment chaining overhead substantial 
column seen benchmarks significant number instructions generated indirect jump hardware ras translation time target address prediction code generated jsr jmp instructions 
average indirect jump results translated instructions executed 
benchmarks high percentage instructions translated indirect jumps gap perlbmk 
benchmarks indirect jump code expansion rate small procedure calls done unconditional direct branches 
software speculation overhead tends affect dbt system dynamic optimizers translators perform aggressive optimizations reduce number executed instructions 
specialized hardware features example jump target translation look aside buffer provides isa target address isa target address help reduce overheads 
hand isas relatively code expansion rate 
bit instructions special branch instructions helps 
code expansion rates basic isa modified isa 
output register value type important program characteristic affects number extra copy instructions 
statistics output register value usage fig 
show dynamic instructions global output value 
notation local global represents values needs saved gpr conditional branch boundary basic isa format 
notation user global similar 
values representing extra copy gpr instructions basic isa format included total percentage instructions global output values rises 
statistics contrast earlier results oracle program trace limited superblock boundaries instructions produce global output values 
re gis te ipc performance evaluation timing simulations microarchitecture parameters 
branch prediction table 
microarchitecture parameters microarchitecture order superscalar entry bit global history share predictor perfect ras cycle fetch redirection latencies misprediction cache byte line size direct mapped kb size lru replacement cache byte line size way set assoc kb size cycle latency random replacement byte line size way set assoc kb size cycle latency random replacement cache byte line size way set assoc mb size cycle latency random replacement memory cycle latency bit wide cycle burst reorder buffer size instructions alpha instructions decode retire bandwidth ip ty instructions alpha instructions issue window size fifo heads rob issue bandwidth execution resources fully symmetric functional units misc 
cycle global communication latency ip communication latency oldest issue note keeping philosophy smaller faster memory structures cache microarchitecture quarter size superscalar counterpart 
latency difference cycle results isa having address addition lb tw lf te 
output register usage liv global mm 
global lo global user global lo te user output reg memory instruction loads require add latency effectively cycles effectively superscalar processor 
note study processing elements physical accumulators 
contrast earlier results pes 
smaller execution backend reduce performance shown 
goal research reported achieve ipc rates close native alpha performance 
eventual objective research achieve performance gains due simple high clock frequency microarchitecture provided accumulator isa 
fig 
compares performance processor running dynamically translated accumulator isa code code straightening counterpart conventional superscalar processor measured isa program instructions cycle ipc 
ip ip ty eon gap difference performance code straightened alpha translated modified isa measure ipc cost simple accumulator isa 
factors contribute ipc performance loss 
important increased number instructions higher native isa ipc clearly offset extra instructions 
pointed earlier sections adequate hardware support suppress unnecessary extra instructions essential 
ip mc parser perlbmk tw lf rte 
ipc comparison hm ig inal tr basic isa mo ied isa mo ied isa tiv ipc quarter size data cache reduced instruction issue opportunities fifo heads vs entry order issue window contribute loss effects relatively small compared extra instructions 
ip ip ra ty fig 
sensitivity number processing elements global wire latency zero shown 
seen functional units sufficient general 
mainly stages pipeline including decoding retire stages limited way 
importantly ipc loss observed adding cycle communication latencies 
clearly seen dependence strand identification help tolerate inter pe communication effectively 
ip mc dynamic binary translation system designed virtual machine 
accumulator oriented implementation instruction set designed accommodate simple high clock frequency microarchitectures tolerant increasing global wire latencies 
translation overhead dramatically reduced compared previous dbt systems vliw processors 
aggressive optimization techniques underlying hardware capable form dynamic instruction rescheduling simple order fifos 
dictating hardware achieve higher instruction level parallelism dbt simply helps underlying microarchitecture tolerate increasing global wire latencies better providing benefits dynamic code straightening efficient lb mk tw lf te 
ipc variation machine width communication latencies hm pes le pes le pes le pes le dynamic performance enhancement techniques 
belief combination simple distributed microarchitecture capable dynamic instruction scheduling low overhead dynamic binary translation provide best design tradeoff point 
studied isa forms modified format destination register specifier provides simpler exception recovery model higher performance compared basic format 
identify fragment chaining overhead biggest performance limiting factor offsets benefits code straightening effect dbt 
fragment chaining overhead exacerbated dbt aggressive optimizations performed reduce number executed instructions 
proper hardware support allowed designed virtual machine paradigm system potential achieve higher performance conventional processor designs 
supported src hj nsf eia ccr intel ibm 
erik altman boa architecture binary translation processor ibm research report rc matthew arnold adaptive optimization jalapeno jvm proc 
acm sigplan conf 
object oriented programming systems languages applications oct 
bala transparent dynamic optimization design implementation dynamo hewlett packard laboratories technical report hpl jun 
bala dynamo transparent dynamic optimization system proc 
acm sigplan conf 
programming language design implementation 
wen ke chen mojo dynamic optimization system proc 
rd acm workshop feedback directed dynamic optimization 
dean wiggins online program specializer proc 
th symp jun 
kemal ebcioglu dynamic binary translation optimization ieee transactions computers vol 
jun 
brian performance characterization hardware mechanism dynamic optimization proc 
th int 
symp 
microarchitecture dec 
keith farkas multicluster architecture reducing cycle time partitioning proc 
th int 
symp 
microarchitecture dec 
michael dynamic transparent binary translation ieee computer mar 
kim michael smith code cache management schemes dynamic optimizers proc 
th workshop interaction compilers computer architectures 
raymond mark digital fx combining emulation binary translation digital technical journal jan 
wen mei hwu superblock effective technique vliw superscalar compilation journal supercomputing kluwer academic publishing 
intel itanium architecture software developer manual vol 
rev instruction set intel 
glenn hinton microarchitecture pentium processor intel technology journal 
ho kim james smith instruction set microarchitecture instruction level distributed processing proc 
th int 
symp 
computer architecture 
richard kessler alpha microprocessor ieee micro vol 
mar apr 
thomas kistler michael franz continuous program optimization design evaluation ieee transactions computers june 
alexander technology crusoe processors transmeta technical brief 
steve java hotspot performance engine depth look technical whitepaper sun microsystems 
matthew architectural framework run time optimization ieee transactions computers june 
erik nystrom code reordering speculation support dynamic optimization systems proc 
int 
conf 
parallel architectures compilation techniques sep 
palacharla complexity effective superscalar processors proc 
th int 
symp 
computer architecture jun 
karl pettis robert hansen profile guided code positioning proc 
acm sigplan conf 
programming language design implementation jun 
doug burger evaluating microprocessors simplescalar toolset technical report cs tr university wisconsin madison 
smith instruction level distributed processing ieee computer apr 
michael smith overcoming challenges feedback directed optimization proc 
acm sigplan workshop dynamic adaptive compilation optimization 
joel power system microarchitecture ibm technical white 
david ung cristina cifuentes optimizing hot paths dynamic binary translator proc 
nd workshop binary translation oct 
cindy zheng carol thompson pa risc ia transparent execution recompilation ieee computer mar 

