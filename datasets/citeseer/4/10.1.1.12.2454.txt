incremental generation lr parsers nigel horspool department computer science university victoria december implementation new compiler usually requires making frequent adjustments grammar de nitions 
incremental technique updating parser tables minor change grammar potentially save computational ort 
importantly debugging grammar easier grammar re checked correctness small change grammar 
basic design philosophy incremental parser generator incremental algorithms lr slr lalr parser generation discussed 
algorithms incorporated implementation incremental lalr parser generator 
index terms compilers compiler tools program development environments lr parsing lalr slr incremental algorithms grammar debugging 
compiler represents major software development ort 
simple non optimizing compilers relatively small languages pascal may consist lines source code 
production compilers large languages ada perform sophisticated optimization may consist hundreds thousands lines code 
conventional compiler normally organized phases 
simple compiler phases lexical analysis syntactic analysis semantic analysis code generation 
tools exist help compiler writer develop lexical semantic analysis phases 
tools attribute grammar formalisms construct semantic analysis code generation phases 
automatic techniques developing code generator phase description target architecture compiler subject current research 
collection tools form rudimentary compiler writer workbench 
word rudimentary compiler modules create easily unifying idea human interfaces may leave tobe desired 
concerns addressed project goal develop set interactive compiler development tools standard compiler phases listed 
date tool project completed interactive lexical analyzer generator 
second tool series called interactive syntactic analyzer generator 
remainder concerned design implementation lalr parse table generation algorithms 
main approaches parsing top parsing bottom parsing 
topdown parsing usually implemented method known recursive descent uses collection mutually recursive procedures 
method successfully compilers example original compiler pascal 
recursive descent criticized various reasons 

class grammars smaller bottom methods accept lalr lr grammars 
second recursion implemented ciently parsing speed may ected 
third recovery syntactic errors easy recursive descent compiler 
fourth semantic analysis code generation actions included inside recursive descent procedures tends spoil modularity compiler 
discussion pros cons approaches appears section 
forced choose approach picked bottom approach capable larger class grammars 
existing tool creating syntactic analyzer user rst create grammar language compiled 
grammar processed tool call parser generator outputs parser suitable inclusion compiler equivalently outputs tables drive standard parsing procedure 
form grammar constrained class grammars parser generator accept need associate semantic actions production rules 
parser generators exist various classes grammars including operator precedence ll slr lalr lr 
compiler writer rarely grammar provided part formal language description 
published grammars usually designed people read implementer 
implementer nd grammar belong class grammars accepted parser generator 
transformations grammar need performed careful change language accepts 
grammar changed satisfy requirements parser generator changes required implementer attempts attach semantic actions production rules 
term grammar debugging applied activity transforming grammar way 
inexperienced compiler implementers tend nd grammar debugging frustrating experience 
time implementer wishes change edit le containing grammar rules save le execute parser generator 
frequently case parser generator reports problem grammar implementer receive cryptic message describing problem 
widely available yacc parser generator example simply tells user con icts parse tables :10.1.1.111.230
information required compiler implementer read listing lr states generated 
parser generators usually helpful provide example string cause parser enter state con ict occurs 
message problem grammar clear trivial task formulate correction 
sophisticated compiler implementers resort trial error process patch grammar implying edit grammar le repeat parser generation process 
cycles debugging process may required grammar acceptable 
approach reminiscent edit compile debug cycle conventional program development 
programmer usually bene sophisticated interactive debugger nding logic errors program 
corresponding debugging tools available assist development grammar 
parser generator available interactive program frustration developing grammar greatly reduced 
bene tting instant feedback erroneous input interactive system capable providing information user 
experienced compiler implementors may wish see lr sets items displayed 
experienced users may wish ability sample sentence see trace parsing actions 
facilities ability select parts large grammar browsing asking see uses particular non terminal symbol provided editing process simpler 
reason consider interactive parser generator traditional grammar debugging wasteful computational ort 
small change grammar parser generator process entire grammar repeat performed previous stage debugging cycle 
reduce wastage computational ort reduce user frustration propose new compiler development tool 
tool incremental parser generator ipg 
tool interactive program allows user develop grammar 
change grammar re checked acceptability 
instant user feedback report problems grammar eliminate frustration help user see production rules cause di culties 
incremental parser generator retains tables creates part grammar analysis update re build tables change grammar possible eliminate wasted computational ort 
idea building parser generator accepts incremental changes grammar entirely new 
publications area widely distributed 
rst appears phd dissertation incremental generation ll parsers dated 
book year concerned top parsing 
rst publication incremental generation lr parsers fischer phd dissertation university dortmund 
implemented pl program starts reading grammar lr parsing tables 
reads list changes grammar new productions added productions deleted incrementally updates tables 
fischer implementation strong competitor reported 
consequently additional comments appear 
years fischer diploma thesis university saarbrucken appeared 
thesis describes algorithms updating lalr parse tables mention implementation 
algorithms form basis practical implementation unclear 
group mathematics centre amsterdam attacked problem principle lazy evaluation basis 
entries lr parse table created run time needed 
amsterdam system limited lr class grammars accepts context free grammar 
parser uses tables encounters lr con ict creates separate tasks explore con icting possibilities parallel 
approach ideal exploring new language designs 
directly help compiler developer complete parse table necessarily created system report lr parser con icts 
amsterdam system capable determining grammar belongs particular subclass context free grammars 
compiler developer certainly requires grammar falls grammar classes accepted standard parser generator amsterdam system suitable grammar debugging 
designing incremental parser generator main design issues decided discuss algorithms needed implement ipg 
quantum change grammar input tool grammar re checked 
extreme user adds deletes single characters grammar speci cations 
extreme wait user typed desired changes re checking 
second grammar class tool accept 
choosing small class class regular grammars implementation tool easy tool useful compiler writers 
choosing large class lr update algorithms complicated implement easily 
complicated update algorithms may slow able provide user su ciently fast responses 
decided unit change single production rule 
addition new rule deletion rule grammar re checked acceptability 
change rule considered deletion original rule followed insertion corrected rule 
unit change smaller faced problem handling incomplete production rules 
larger units change simply delay reporting possible problems user 
permit user add delete rules order prepared temporarily accept incomplete grammars 
symptom incomplete grammar production rules non terminal symbols may inaccessible 
example rules statement list assignment variable expression second rule derivation starts apparently goal symbol second symptom may non terminals generate sentential forms consist terminal symbols 
non terminals called useless 
example add just rule statement list statement list statement grammar 
temporarily consider statement terminal symbol grammar incapable deriving sentential forms free non terminal symbol statement list 
wish allow rules entered order check grammar addition clear relaxed form checking employed 
ignoring rules inaccessible useless non terminals unsatisfactory approach 
user choose enter rules order entire grammar may remain inaccessible useless rule de ned 
convenience user ipg course include interactive command ask symbols currently inaccessible useless 
current generators bottom parsers usually accept lr grammar classes 
chose implement lalr class grammars power contains ll lr slr classes 
smaller class lr class generated parser usually far fewer states requires memory implementation 
appears case lr parsing tables require update small change grammar 
conversely parsers lr slr classes grammars require computational ort create lalr 
parser generator smaller grammar classes may suitable situations computational cost important 
handling incomplete grammars possible analyze grammars completely speci ed 
start symbol grammar may aspect grammar remains unde ned late speci cation process 
appropriate add goal symbol invent extra rules form non terminal symbol partial grammar 
symbol delimiter symbol type invented symbol represents input input delimiter 
purpose provide unique context appear goal symbol 
unique delimiter symbols provided support multiple goal symbols cause lr con icts parser construction process 
addition extra rules requires know symbols non terminals 
reasonable strategy assume symbol encountered grammar far terminal symbol symbol appears left hand side rule 
alternative approach require user declare symbols terminal non terminal 
just declarations variables usually mandatory interactive programming languages prefer terminal non terminal de nitions optional 
addition extra rules eliminates problem unreachable non terminal symbols rules 
grammar reachable goal symbol course user speci ed actual start symbol claims completed grammar perform checks unreachable useless rules symbols 
standard algorithms exist performing checks 
grammar development natural parts grammar incomplete 
complain useless productions user claims completed grammar 
example user may rule left hand side 
clear non terminal symbol useless 
circumvent di culty assuming grammar incomplete state grammar sentential forms grammar sentences language 
example rule language includes sentential forms automatically generated context delimiter symbol 
user explicit request check grammar completeness requests lalr parse tables output algorithm check grammar applied 
suitable algorithm 
rules missing grammar impossible know certain symbols nullable produce empty sentence derivation sequence 
symbol may appear non nullable addition rule 
rule symbols right hand side nullable immediately change status best assume symbols non nullable derivation empty string possible rules grammar 
avoid generation premature error messages ambiguities grammar 
incremental lr parser construction algorithms grammar class restricted lr slr lalr classes computation parsing actions particular grammar separated stages 
rst stage construction lr sets items grammar 
second stage computes lookahead sets associated lr items 
computing lookahead sets trivial lr parser generator expensive lalr 
terminology context free grammar de ned tuple vt vn vt set terminal symbols vn set non terminal symbols designated start symbol set production rules 
explained grammar algorithms process grammar entered user 
augmented additional productions additional symbols 
name refer augmented grammar 
standard conventions discussing grammar formalisms 
symbol represents empty string grammar symbols 
relation represents re exive transitive closure conventions follows 
vn vt vn vt relation pronounced directly produces de ned 
relation pronounced produces represents transitive closure 
augmenting grammar user adds new production rule rn vt vn new grammar created 
new grammar related old grammar rules vn flg vt rn rn ctitious symbol described earlier 
note ri new occurrence symbol identical symbol considered terminal 
course ri subsequently occurs left hand side rule class changed terminal non terminal rules 
initially empty grammar augmented grammar sequence rule additions completely determined 
incremental update lr sets items construction lr sets items covered texts compiler construction 
reader unfamiliar methods concepts lr parser construction nd formal de nitions notation di cult read 
informal 
informal lr concepts lr construction method concept item 
item simply production rule marker frequently called dot inserted right hand side rule 
marker indicates symbols right hand side recognized point parse 
symbols left marker recognized symbols right 
lr parser implemented nite state automaton states corresponds set items 
set items represents parsing possibilities showing rules eligible matched appropriate symbols read parser 
sets items give rise lr recognizer constructed process closure 
initial items formed inserting marker beginnings righthand sides goal rules grammar 
closure operations call item closure state closure 
set items item closure operation adds extra items set extra items usually called completion items 
item set marker immediately left non terminal symbol item generates completion items 
completion items formed rule left hand side placing marker right hand side 
completion items may require addition completion items closure process required 
kernel operation applied grammar symbol set items completed item closure yield new set items 
new set items plus completion items added item closure operation corresponds state lr recognizer reached grammar symbol 
items new state item closure applied called kernel items new states 
texts call core items 
lr collection sets items formed process applying item closure initial items applying state closure set yield remaining sets items 
state closure implemented iterative algorithm list 
algorithm sketched 
algorithm start set items start state recognizer list 
termination set contains recognizer states 
state closure start initial items fg empty remove state fsg grammar symbol compute kernel items kernel new state fs states uniquely determined sets kernel items test see new state require item closure function applied rst 
operation item closure implemented iterative algorithm list 
case list holds individual items 
algorithm similar structure omit giving details 
formal lr concepts de nitions notation lr recognizers derived notation 
major di erences 
introduced mapping function performs mapping states lr automaton sets items inverse function opposite mapping 
dropped distinction states sets items 
second di erence reduce function replaced function la explicitly associates lookahead sets lr items 
lr automaton lra start nextstate la set sets lr items equivalently set states vn vt start start state automaton nextstate transition function states la function associates lookahead sets lr items computed state 
la function de ned section 
correspondence states lr automaton sets lr items lr item de ned follows 
lr item triple 
conventionally written 
sets items start state successor states reached nextstate function created follows 
start vng nextstate kernel smallest set cs cs item form cs 

pg cs kernel function yields result adding completion items kernel set items function kernel yields kernel items state reached transition symbol state operation implemented iterative algorithm list items mentioned previously 
way considering problem constructing lr recognizer kind closure closure set states 
say start ss smallest set states cs ss cs st st cs nextstate st cs operation conveniently implemented iterative algorithm list states outlined previously 
minor detail point operation create empty set items lr recognizer states 
state error state entered lr parser applied invalid sequence terminal symbols 
practice explicit error state usually omitted lr recognizers 
incremental update lr sets items user added new production rn grammar need construct corresponding lr automaton lra 
usually case sets items states new automaton correspond closely sets items states old automaton 
sets items unchanged sets increased size due addition new members 
unfortunately possible determine items need added item set inspection current members set grammar rules 
example illustrate di culty 
suppose user entered incomplete grammar 
df aab aec ec state ab ec ec state state ab ec ec ec state ae state lr states rule addition state ae ae state lr states rule addition aec state state aec ec aec state construction lr recognizer generate sets items sets related shown 
add extra rule corresponding states new lr automaton sets items shown 
states rst lr recognizer split pairs states second recognizer 
unfortunately appear simple test determining state splitting required determining extra elements added set items 
adopt heuristic approach problem 
assume states original lr recognizer lra exist new recognizer lra kernel items 
easy add extra completion items states lra convert plausible states lra 
conversion accomplished map function de ned 
new rule added grammar rn 
map set items start state follows map start start vn start ll map item sets states follows map rn form modify sets items way wemay creating states certainly created states occur lra 
assumption states lra occur kernel items lra reasonably accurate practice heuristic basis incremental algorithm 
experimental data experience section indicate assumption valid 
implement heuristic need map item sets explained function add missing states nally remove super uous states 
principle approach captured equation creates new set lr states previous set reachable map st st reachable acts garbage collection algorithm yielding states reachable start state 
may de ned reachable ss smallest set states rs rs ss start rs st st rs nextstate st rs correctness procedure easy see 
long set items start state updated correctly function guaranteed construct necessary states true map function states 
process creating lra states implemented little ciently suggested procedure 
possible states contained set passed argument tothe function 
closure operation unnecessary states may give rise unreachable states creating additional reachable function 
cient approach combine reachability analysis state closure operation tracing transitions states determined reachable start state 
way improving ciency method implementation leave unreachable states recognizer 
long unreachable states cause lr parsing con icts numerous interfere algorithms 
implementation defers performing proper reachability analysis states lr parsing con ict encountered user requests parser output le 
incremental update lookahead sets lr automaton recognize language generated recognizing particular string language performs shift reduce actions determined current state automaton current input symbol 
shift action state transition side ect causing new input symbol read 
shift actions correspond nextstate function de ned 
reduce action corresponds successful recognition right hand side production rule 
action causes recognizer halted restarted di erent state 
new state state reached transition symbol followed transitions followed symbols detailed descriptions operation lr parser may texts compiler construction 
reduce actions may performed state determined set items lookahead function la set states recognizer represents domain items constructed grammar la maps item state lookahead set 
item symbols appear right marker dot called reduce item 
item non reduce item called shift item 
di erent methods constructing la function depending wish restrict class grammars lr slr lalr class 
construction methods described 
reduce item member state reduce action rule 
performed state input symbol member set la 
requirement parsing methods lr family parsing actions uniquely de ned 
said state shift reduce con ict symbol nextstate contains reduce item la 
similarly state reduce reduce con ict symbol reduce items la la 
parser generator unable construct deterministic parsing tables lr recognizer con icts 
possible approaches handling con ict 
rst simplest approach detect report con ict error 
user friendly parser generator include example sequence symbols illustrates parsing con ict error report 
second approach parser generator assumption con icting actions desired user 
yacc parser generator adopts approach resolves con icts order production rules entered 
third sophisticated approach attempt analyze con ict tracing paths parser states discover origin con ict 
con ict occurs grammar lr lalr possible split states remove con ict 
approach basis lr parser generation methods 
lr lookahead sets lookahead sets trivially constructed lr case 
item state simply la vt checking con icts simpli ed extend domain la include shift items 
item de ne la fxg state containing reduce items necessarily reduce reduce con ict 
state containing reduce item non reduce item shift reduce con ict la la 
slr lookahead sets slr method uses slightly sophisticated de nition lookahead sets 
sets computed function called follow 
computation follow facilitated set nullable symbols null function called start computed 
set nullable symbols formally de ned null null determine form 
set nullable symbols rule addition closely related set 
continuing convention primes refer grammar relationship null null lg ri null null rule rn added grammar create simple iterative algorithm worklist non terminal symbols need re checked obtain null null ciently 
start function yields set starter symbols grammar symbol 
formally de ned st art follow function yields set symbols may legally follow grammar symbol sentential form 
de ned xy methods computing start follow functions books compiler construction 
approach 
start function constructing immediate starters relation grammar forming transitive closure relation 
choose represent relation matrix true means symbol immediate starters matrix de ned follows 
entry value true grammar contains rule ky zi null 
entries value false 
transitive closure written de ned yn yn known algorithms computing transitive closure relation 
cient incremental algorithms transitive closure exist particularly suitable 
form transitive closure standard methods st art true vt similarly follow function computed rst constructing immediate followers relation transitive closure 
de ne matrix value true grammar contains rule 
kw zi null st art grammar contains rule 
zi null 
transitive closure computed standard techniques 
obtain follow follows 
true vt formulation start follow terms demonstrates monotonic nature problem 
new rule rn added grammar change entries false true matrices 
changes reverse direction occur 
example entry set true 
turn implies changing entries false true transitive closure computed st art having computed st art update 
example add rule rn entries st art set true 
algorithm works update suggested iterative worklist approach updating transitive closures 
computed relation follow function determine lookahead sets 
slr approach la de ne la non reduce items way lr parsers con ict checking performed way 
lalr lookahead sets methods computing lalr lookahead sets published 
iterative algorithm due aho ullman described algorithm gure appears best suited conversion incremental setting 
give modi ed version algorithm 
existence item state implies existence item state addition completion items state state completion process lookahead function applied yields set may contain symbols determined 
called spontaneous generation lookahead symbols 
addition possible set lookahead symbols include entire set lookahead symbols 
case symbols said propagate 
rules spontaneous generation symbols propagation symbols possible settings follows 
case completion items suppose state contains item marker appears left nonterminal symbol 
form 
state contain completion items form 
item 
symbols follow righthand side include symbols follow item symbols follow item include de ned 
words implies la 
terminology symbol generated appear lookahead set 
addition la la hold 
case symbol propagating 
case kernel items suppose state contains item form 
necessarily state reached transition symbol contains kernel item form 
case la la 
example propagation symbol propagates 
function simple extension start domain sentential forms 
vt alternative de nition shows derive start st art xk null st art simple algorithm determine lookahead sets start initializing lookahead sets empty 
repeated passes items states adding spontaneously generated symbols propagated symbols sets 
iterative procedure halt pass fails add new symbols set 
faster version method worklist items lookahead sets changed participate pass 
entries worklist consist state item pairs 
algorithm appealing appears incrementally 
updating lr recognizer may added items states created states containing new items 
subsequently initialize lookahead sets new items empty leave lookahead sets 
execute aho ullman algorithm determine lookahead sets new items propagate lookahead symbols new items items 
process converge quickly performing full re computation lookahead sets 
incremental approach correct lookahead sets lose symbols new rule added grammar 
correct lookahead sets grow monotonically 
unfortunately example figures provides demonstration lalr lookahead sets necessarily grow monotonically 
picture addition new rule lookahead set sole item state obtained propagating lookahead symbols relevant items states 
lookahead set item aec fg symbols context delimiter symbols introduced incremental algorithms 
picture rule addition lookahead sets separated 
correct lookahead set item state lookahead set item state dg 
direct method augmenting lookahead sets ways correct problem 
way takes advantage fact iterative algorithm yield correct results lookahead sets initially assigned values subsets nal values 
achieved assign empty lookahead sets new items created incremental computation lr sets items reset lookahead sets items states split empty 
alternative strategy approach ignore problem long con icts detected 
assign empty lookahead sets new items created incremental update lr sets items simply apply iterative algorithm lr recognizer lookahead sets contain symbols 
note lookahead sets computed approach contain symbols appear slr lookahead sets 
occasionally large sets cause spurious con icts 
con ict detected simply clear lookahead sets empty re compute correct values iterative algorithm 
con ict exists re computation reported user lalr con ict 
con ict longer exists just carry normal 
approach sensible spurious con icts frequency occurrence 
fortunately experience indicates spurious con icts rare practice 
proved method computing lookahead sets potential con icts 
proof observation lookahead set computation satis es requirements monotone data ow framework 
particular lr collection states particular vocabulary terminal symbols vt element inthe lattice corresponds ordered collection lookahead sets associated lr items 
bottom element lattice corresponds case lookahead set empty top element case lookahead set equal vt lattice relation corresponds pairwise conjunction tests lookahead sets corresponding lr items 
assume iterative algorithm aho ullman known correct 
lattice element corresponding correct lalr collection lookahead sets denoted write fla 
fla function represents ect applying iterative algorithm initial situation lookahead set empty 
establish fla monotonic function 
implies fla fla 
property proved steps 
rst step observe iterative algorithm adds elements lookahead sets 
second step show element added lookahead set application fla element added application fla monotonicity established see starting con guration lookahead sets follows fact fla 
fla fla 
words guaranteed applying iterative algorithm yields lookahead sets identical supersets correct lalr lookahead sets 
impossible con ict 
worst happen discover con ict true lalr lookahead sets 
strategy recomputing correct lookahead sets con ict detected necessary correct 
argument shows lookahead sets incorrect able detect con icts correctly 
argument taken account feature implementation lalr recognizer may contain extra unreachable states 
necessary argue extra states cause additional elements lookahead sets correspond items reachable states 
words monotonicity property hold 
consequence spurious con icts may discovered con icts missed 
con ict necessary remove unreachable states recompute lookahead sets 
decremental algorithms finding reasonably cient practical algorithms handle deletion production rule remains area research 
incremental parser generator implemented support rule deletion operation usually takes little time corresponding rule addition 
implementation oriented optimizing addition rules 
new element added set set items lr state record element added retained 
wish undo considerable amount re computation needed decide element removed 
user decides delete rule grammar change consequences 
symbols may removed null 
second items removed item sets lr construction lr recognizer lose states 
third lookahead sets lose members 
brie review needs done 
start updating augmented grammar remove production rule relatively easy 
rule deleted rn rule rule appears left hand side remove production rule change status non terminal terminal 
updating lr recognizer technique similar employed adding rule grammar 
involves nding items deleted production rule removing sets items 
items may caused completion items included completion items removed 
rn rule deleted precompute set items deleted rule fl rj rj rn ng precompute closure second set includes items removed item sets plus items removed 
de ne mapping function item sets form denotes set di erence 
removing items set may remove completion items return completion items set 
mapping process general mapping normally reduce number states lr recognizer 
spite mapping reducing number states may leave unreachable states recognizer 
removed applying reachability analysis technique described earlier 
addition may delete states kernel items rule construction lookahead sets best accomplished performing total recomputation 
lookahead sets cleared empty sets iterative algorithm applied 
complete recomputation safely deferred apparent con ict nal version parse tables output 
correctness arguments preceding section apply prove con icts missed approach 
worst case complexity natural question ask long take update parser tables addition deletion production rule algorithms described 
demonstrate problem exponential worst case time complexity algorithm cient worst case exist 
demonstration grammar contains productions 
bs cs bs bs bs sn asn sn lr construction algorithm applied grammar generates recognizer states 
suppose production rule added grammar 
extra rule causes number states lr recognizer increased states 
unfortunate implication algorithm incrementally updating lr parse tables prepared create exponential number states processing single rule addition 
time space cost exponential size grammar 
amended grammar illustrates non incremental lr parser generator exponential worst case time space complexity 
example grammar constructed way illustrates interesting property 
suppose add production bs surprisingly addition causes number states lr recognizer reduced 
consider happens rule deleted 
observe number lr states increase 
words example demonstrates incremental algorithm rule deletion exponential time space complexity 
grammar constructed alan demers 
grammar pl pascal oberon ada total cpu time average time rule maximum time rule total cpu time yacc note times seconds measured sun sparcstation workstation 
practical experience table timing measurements techniques described experimental implementation called 
fully interactive incremental generator lalr parsers 
human interface main focus research ort input commands simple line oriented structure 
designed create parsers link lexical analyzers generated interactive tool lex 
little di culty interfacing lexical analyzers sources 
timing measurements table show speed execution appears adequate interactive 
example grammar language containing production rules requires seconds cpu time process sun sparcstation workstation average cpu seconds production 
comparison yacc parser generator requires little cpu seconds identical grammar :10.1.1.111.230
considering creates di erent lalr recognizers course execution checks free con icts speed ratio surprisingly 
performance ratio sample grammars 
event implementation easily keeps rate new production rules entered human 
alternative approach re running non incremental parser generator yacc rule addition competitive 
actual amount processing time needed processing rule addition varies quite widely 
third row table shows worst case grammar actual time rule required processing 
maximum times depend strongly order production rules 
case grammar maximum time observed rule group rules describe structure expressions 
expression operators corresponding production rules organized precedence levels 
changes grammar expressions lowest precedence level cause avalanche changes recognizer states lookahead sets precedence levels 
considerable variation processing time requirements successive rule additions general trend increased times grammar grows larger 
shows growth trend largest grammar collection ada grammar 
data easier read times reported bar graph column represents average processing time cpu seconds consecutive rule additions 
rst secs secs secs note times measured sun sparcstation workstation 
time rule addition versus grammar size grammar number pl pascal oberon ada productions accessible states inaccessible states lr states states optimization table statistics sample grammars column corresponds average time productions second column productions 
heuristics improve speed implementation 
heuristic avoid running garbage collection algorithm absolutely necessary 
fact executed possibly spurious con ict detected immediately prior construction nal form parser tables 
heuristic lose cpu time gains proportion unreachable states high 
data table indicate proportion unreachable states grows largest grammar tested 
complete description numbers appearing table 
alternative strategy performing garbage collection rule addition causes approximate doubling cpu time requirements grammars 
second heuristic reduce computational expense computing lalr lookahead sets 
normally computes sets may contain extra symbols performing proper computation con ict discovered state immediately grammar percentage pl pascal oberon ada modi ed states missing states super uous states table cacy state updating heuristic constructing nal form parser tables 
frequency spurious con icts high heuristic cause net loss cpu time 
turns sample grammars causes spurious con ict grammars slr 
fact able trigger spurious con ict concomitant recomputation lookahead sets specially constructed grammars 
table shows di erent numbers number states generated lr recognizer 
rst number total number reachable states recognizer augmented grammar start symbol super goal 
second number total number unreachable states created result approximate algorithm determining set lr states 
third number number states lalr parser output user speci ed true start symbol 
fourth number number states optimized lr parser output 
simple optimization eliminating states contain unique reduce action combining reduce action shift action predecessor state performed 
optimization easy perform eliminates high proportion states parse table compaction techniques reduce execution ciency generated parser 
algorithm updating lr sets items addition new production heuristic 
heuristic performs simple mapping process change set original lr recognizer new set needed new lr recognizer 
data support cacy heuristic appears table 
rst row shows percentage states sets items modi ed mapping process 
second row shows percentage new states added subsequent state closure process 
third row shows percentage super uous states mapping process states created mapping algorithm needed 
proportion super uous states ranges depending grammar 
way looking statistic compare third row table rst row 
shows states modi ed mapping process needed 
practical algorithms incremental analysis grammars incremental generation lr slr lalr recognizers 
compiler construction tools algorithms help compiler writers develop suitable grammars permit incremental construction compilers 
worst case execution times algorithms poor practical experience shows 
possibility reduce expected execution time requirements incorporate cient incremental transitive closure algorithm 
course hope algorithm improving worst case time complexity problem 
transitive closure algorithms cient case single edge added deleted graph 
section demonstrates number edges added deleted state graph lr recognizer exponential size grammar 
nice give proper comparison speeds implementation fischer implementation meaningless comparison possible 
implementation time needed process productions grammar cpu seconds sun sparcstation workstation average cpu seconds production 
fischer implementation applied grammar average cpu seconds production siemens computer describes nearly half fast ibm 
conclude algorithms techniques faster data 
person uses incremental parser generator help design new grammar notice major di erence tool fischer 
tool automatically performs maximum possible checking maximum possible table generation incomplete grammar 
fischer techniques production rules usable derivation starts goal symbol 
grammar contains ambiguities tool report fact earliest possible moment true fischer parser generator 
note incremental generation ll parsing tables performed relatively easily tables constructed follow functions 
incremental construction functions described slr parsing method 
remains done interactive parser generator included compiler writer workbench 
importantly current line oriented interface replaced sophisticated full screen interface 
nal product called facilities exchange information automatically compiler development tools 
exchanges information help eliminate interfacing errors compiler phases help eliminate need user re enter information 
students csc course compiler construction university victoria deserve acting guinea pigs 
comments unpredictable inputs gave proved helpful improving error diagnostic messages nding obscure errors 
funding research gratefully received natural sciences engineering research council canada 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 
aho johnson lr parsing 
acm computing surveys vol 
pp 

aho sethi ullman compilers principles techniques tools 
addison wesley reading ma 
aho ullman theory parsing translation compiling vol 
parsing 
prentice hall englewood cli nj 
optimization parser tables portable compilers 
acm trans 
prog 
lang 
sys 
cient computation lalr look ahead sets 
acm trans 
prog 
lang 
sys 
die eines multiple entry parsers und ein lalr 
diploma thesis department mathematics computer science university saarbrucken federal republic germany 
fischer leblanc jr crafting compiler 
benjamin cummings menlo park ca 
fischer incremental lr parser construction aid syntactical extensibility 
phd dissertation tech 
report department computer science university dortmund federal republic germany 
gri ths ll grammars analysers compiler construction advanced course second edition lecture notes computer science vol 
bauer eds springer verlag berlin 
heering klint rekers incremental generation parsers 
report cs centre mathematics computer science amsterdam 
heering klint rekers incremental generation parsers 
proceedings sigplan conference programming language design implementation 
acm sigplan notices 
roberto interactive language design system 
american elsevier new york ny 
horspool levy interactive scanner generator 
software pract 
exper 

johnson yacc compiler compiler :10.1.1.111.230
bell laboratories murray hill nj rep cstr 
kam ullman monotone data flow analysis frameworks 
acta informatica 
lesk schmidt lex lexical analyzer generator 
bell laboratories murray hill nj rep cstr 
pager practical general method constructing lr parsers 
acta informatica 
spector cient full lr parser generation 
acm sigplan notices 
tremblay sorenson theory practice compiler writing 
mcgraw hill new york ny 
extensions dans une ll 
doctoral dissertation university grenoble 
warshall theorem boolean matrices 
acm 
yellin dynamic transitive closure algorithm 
ibm watson research center yorktown heights ny report rc 
summary incremental generation lr parsers nigel horspool developers software systems support tools allow system ciently rebuilt addition change system source code 
analogous tools compiler developers exist 
tool compiler development environment need incremental generator parsers 
small change grammar speci cation tool incrementally re build parser tables report problems modi ed grammar 
tool process changes su ciently fast usable interactive program debugging developing grammars 
existing non incremental parser generators slow permit interactive editing grammar speci cation 
worst case time complexity processing change grammar poor possible develop algorithms practice 
algorithms described basic techniques 
worklists drive iterative algorithms 
application lazy evaluation deferring necessary 
interactive incremental lalr parser generator uses algorithms developed shown give highly acceptable performance 

