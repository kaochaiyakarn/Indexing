journal functional programming volume number 
dynamics ml xavier leroy ecole normale sup erieure michel mauny inria rocquencourt objects dynamic types allow integration operations essentially require runtime type checking statically typed languages 
article presents extensions ml language dynamics caml implementation ml discusses usefulness 
main novelty combination dynamics polymorphism 
static typing compile time enforcement typing rules programming language generally preferred dynamic typing production run time tests check rules static typing reports type violations earlier allows generation ecient code 
revert dynamic typing programs recognized type safe compiletime 
situation reveals weaknesses type system 
dynamic typing avoided employing advanced type systems 
instance long believed generic functions functions applied arguments di erent types supported dynamically typed languages lisp advent polymorphic type disciplines ml permit static typing functions 
contrast programming situations require dynamic typing essential way 
rst example eval function similar meta level operations takes character string evaluates expression language returns value 
type returned value known compile time depends expression argument 
example structured input output 
runtime systems provide extern primitive takes object type eciently outputs low level representation object persistent storage 
object read back possibly process intern primitive 
extern function easily typed polymorphic type system case intern function type result depends contents le read 
order guarantee type safety clear values returned eval intern carry type information run time type information dynamically checked type expected context 
demonstrated dynamic typing avoided highly speci functions 
retain static typing huge majority functions typechecked compile time 
need way embed dynamic typechecking statically typed language 
concept objects dynamic types dynamics short introduced cardelli elegant answer need 
dynamic pair value type expression type standpoint static typing dynamics belong built type dyn 
type dyn represents values self described far types concerned values run time type checking performed 
continuing examples function eval naturally returns dynamics static type string dyn 
similarly intern type io channel dyn extern function accept arguments type dyn external representation object include type 
constructs provided communicate type dyn types language 
construct creates dynamics object type pairing static type 
construct checks internal type dynamic static type case success gives access internal value dynamic type consider integration dynamics described ml language 
main novelty combination dynamics polymorphic type discipline 
combination raises interesting issues addressed 
main published dynamics considered rst order types rst order types subtyping 
abadi mention problems involved polymorphism brie informally :10.1.1.47.1059
draft mycroft said consider extension ml dynamics article published get copy :10.1.1.47.1059
abadi proposed extension earlier allows polymorphism subtyping :10.1.1.39.8178
compare proposals section 
extensions ml dynamics mere proposals 
simpler fully integrated caml system ml implementation developed inria years :10.1.1.47.1059
grown point stability dynamics inside caml system 
second ambitious extension extensively prototyped caml 
practical experience enables discuss main implementation issues involved dynamics 
gives hints practical usefulness dynamics ml system user level programming system level programming 
remainder organized follows 
section presents rst extension ml dynamics :10.1.1.47.1059
informal presentation formalize typing evaluation rules dynamics signi cant subset ml show soundness typing respect evaluation discuss type inference compilation issues 
section extends system previously described ability dynamics type part value part rebuild dynamics components structure 
adapt typing evaluation rules section extension :10.1.1.47.1059
section discusses practical usefulness systems signi cant uses dynamics caml environment 
mention related section give concluding remarks section 
simple dynamics section describes dynamics implemented caml release ch :10.1.1.47.1059

elimination constructs new construct dynamic provided create dynamics :10.1.1.47.1059
construct evaluates pairs representation type inferred instance dynamic evaluates int dynamic true true bool 
case expression dynamic type dyn mention internal type dynamic 
useful dynamic gain access internal value bringing back statically typed world 
run time type check needed point guarantee type safety 
check ensure internal type dynamic match type expected context 
operation called coercion dynamic 
coercion traditionally special syntactic construct typecase construct :10.1.1.47.1059
construct binds internal value dynamic variable 
handles case run time type check fails coercion attempted exception raised 
ml mechanisms binding failure handling provided patternmatching machinery 
providing separate coercion construct integrate dynamic coercion pattern matching 
introduce new kind pattern dynamic patterns written dynamic 
pattern selects dynamics internal value matches pattern internal type agrees type expression instance function takes dynamic attempts print print function dynamic int print int dynamic string print string dynamic int int print string print int print string print int print string print string creation polymorphic dynamics dynamics polymorphic type system raises issues appear case monomorphic type system :10.1.1.47.1059
section show restrictions put dynamic creation section deals semantics type matching dynamic coercion 
allowed create dynamic object polymorphic type provided type closed type variables free type free current typing environment 
instance dynamic function perfectly legal identity function type fresh type variable appear case principal typing 
possible internal value dynamic type instances hand function dynamic rejected dynamic typed environment closed type 
case impossible determine compile time exact type object put dynamic static typing says instance type 
correctly evaluate function actual type instantiated passed run time 
polymorphic functions nested examples article written caml dialect ml :10.1.1.38.9875
arbitrarily means polymorphic functions build dynamics directly take type expressions extra parameters propagate types polymorphic functions call 
complicating compilation raising eciency issues passing type information runtime essentially incompatible ml semantics implies name semantics polymorphism ml value semantics polymorphism terminology 
terms extra abstractions inserted generalization points pass type information cause evaluation polymorphic expressions delayed instantiation time side ects occur di erent times ml 
assume instance expression rejected function 
print hi function dynamic true correctly propagate type information compiler insert extra abstractions type representations corresponding applications follows function function function 
print hi function dynamic function int int bool true placement abstractions applications possible abstractions applications correspond points generalization instantiation take place 
program prints hi twice core ml 
change semantics construct allowing dynamics created non closed types destroys parametricity properties ml type system 
wellknown polymorphic functions operate uniformly objects type type variable functions polymorphic type obey algebraic laws depend type :10.1.1.38.9875:10.1.1.38.9875:10.1.1.47.1059
instance functions type list list functions lists map map captures fact function type reorder duplicate remove elements list regardless actual value elements get results apply arbitrary transformation element list applying 
longer true add dynamics typing restrictions function de ned function match dynamic dynamic int list reverse type list list map string int map string int closedness condition dynamic creation rules function :10.1.1.47.1059
generally conjectured closedness condition suces guarantee similar parametricity results hold ml plus dynamic core ml 
coercion polymorphic dynamics type matching presence polymorphic types behaviors considered :10.1.1.47.1059
rst require internal type dynamic exactly expected type renaming type variables 
behavior accept dynamic internal type general expected type 
instance dynamic internal type list matches pattern dynamic int list behavior 
retained behavior coherent statically typed part ml language empty list context expects list integers 
type patterns allowed require polymorphic type dynamic 
pattern matches dynamic internal type general general type pattern 
consequence semantics identi er safely di erent instances type right hand side pattern matching function dynamic type matching semantics guarantee bound run time value belongs instances type scheme 
case ml variable bound function construct types inside function body 
example type variable regular pattern variable implicitly quanti ed universally dynamic pattern instantiated matching process 
instance pattern dynamic list matches dynamic polymorphic empty list dynamic list 
consequence type pattern general type pattern match fewer dynamics contrast regular ml patterns 
means dynamic matching general type patterns come rst 
catch polymorphic lists integer lists write function dynamic list dynamic int list intuitive de nition function dynamic int list dynamic list de nition second case selected rst case matches dynamics internal type list 
syntax formalize ideas context core ml language enriched patternmatching dynamics :10.1.1.47.1059
syntax language follows type expressions int base type type variable function type product type dyn type dynamics patterns pattern variable constant pattern pair pattern dynamic dynamic pattern expressions variable integer constant function function pattern matching function application pair construction binding dynamic dynamic construction precisely de ne semantics dynamic expressions need keep track type arguments typechecking :10.1.1.47.1059
purpose introduce annotated expressions typical element syntax raw expressions dynamic expressions contain type argument 
precisely dynamic expressions annotated type scheme type expression variables universally quanti ed 
type schemes annotated expressions function dynamic type schemes identi ed permutation renaming bound variables 
trivial type schemes written identi ed type expressions 
typechecking typing rules calculus gure :10.1.1.47.1059
rules just core ml language revised take pattern matching account function de nitions 
additional rules creation coercion dynamics 
rules de ne predicate meaning expression type typing environment 
component viewed typed completion input expression annotated expression structure records types int function function :10.1.1.47.1059
clos fv fv fv dynamic dyn dynamic clos :10.1.1.47.1059
int dynamic dyn clos typing rules arguments dynamic expressions 
rules auxiliary predicate meaning pattern type enriches type environment 
stands nite mapping variable names type schemes 
notations maps 
empty map written 
map associates unde ned variables written 
asymmetric join maps written asymmetric sense belongs domain domain take ignore :10.1.1.47.1059
symmetric join written unde ned domains disjoint :10.1.1.47.1059
write fv set type variables appear type expression type schemes take fv type variables free fv fv nf similarly fv union free variables type schemes codomain write express type instance type scheme writing types clos stands closure type respect type variables set de ned clos fv clos operator extended pointwise type environments 
rules signi cantly di er core ml language rule deals dynamic creation rule deals dynamic coercion 
rule says expression dynamic type dyn provided type closed free variables free current typing environment completion dynamic dynamic completion type scheme obtained generalizing variables free clos 
rule says pattern dynamic matches values type dyn provided matches values type assume binds variables values types dynamic binds variables values 
described type variables free generalized 
take dynamic binds values types clos clos 
surprised fact types generalized independently 
instance pattern dynamic results environment renaming second type scheme information types share lost 
di erence type schemes isomorphic terms belonging type scheme belong 
isomorphisms polymorphic product types justify independent generalization components rule 
important property ml type system stability typing judgements substitutions 
typing predicate de ned enjoys property 
proposition substitutions 
proof check 
easy inductive argument case dynamic pattern follows fact clos clos clos free variables 
proposition follows known inductive argument section :10.1.1.47.1059
give new case dynamic case typing derivation fv fv dynamic dyn dynamic clos renaming necessary assume free variables domain free :10.1.1.47.1059
renaming modify fv fv 
applying induction hypothesis get proof hypothesis fv fv hypothesis :10.1.1.47.1059
conclude dynamic dyn dynamic clos expected result 
evaluation give call value operational semantics calculus :10.1.1.47.1059
annotated expressions mapped responses ranged 
responses values constant wrong denotes run time type violations 
values terms syntax values cst integer value pair value pair dynamic dynamic value clos function closure evaluation environments 
evaluation responses normal response value wrong type error response pattern matching responses normal response environment wrong type error response type schemes dynamic values required closed variables universally quanti ed 
evaluation rules gure :10.1.1.47.1059
closely follow structure typing rules 
rst sets rules de ne predicate meaning environment expression evaluates response 
sets rules de ne auxiliary predicate meaning matching value pattern results 
evaluation environment describing bindings performed variables case successful matching constant wrong run time type violation occurred 
rules similar ml detail rules dealing dynamics 
rule expresses evaluating dynamic amounts evaluating pairing value static type rule de nes semantics pattern matching dynamics :10.1.1.47.1059
internal type scheme dynamic required general type expected pattern type instance type scheme sense cst function clos clos minimal pair :10.1.1.47.1059
dynamic dynamic clos wrong wrong wrong clos wrong wrong wrong wrong wrong wrong wrong wrong wrong dynamic wrong :10.1.1.47.1059
cst pair dynamic dynamic cst wrong pair wrong wrong pair wrong wrong pair wrong dynamic dynamic wrong wrong dynamic dynamic wrong evaluation rules relation typing rules :10.1.1.47.1059
internal value dynamic recursively matched value part dynamic pattern 
soundness section show typing rules sound respect evaluation rules evaluation typed program stops run time type error trying apply integer function :10.1.1.47.1059
situation evaluation rules associate wrong program 
show occur typed program 
proposition program closed expression :10.1.1.47.1059
type derive wrong 
prove result rst de ne semantic typing relation saying value semantically belongs type relation de ned structural induction follows 
cst int pair clos exists typing environment raw expressions function function dynamic dyn :10.1.1.47.1059
typing relation de ne functional values taken :10.1.1.47.1059
semantic typing relation extends type schemes environments types domain domain 
property shows semantic typing stable substitution type generalization semantically correct 
proposition assume substitutions 
variables proof induction case closure settled proposition 
remaining cases obvious 
claims inductive steps establish proposition :10.1.1.47.1059
proposition assume wrong evaluation environment proof induction cases obvious 
rule applied typing derivation hypothesis pair rule evaluation derivation :10.1.1.47.1059
rule apply pair 
rule requires wrong contradicts induction hypothesis applied rule similarly excluded :10.1.1.47.1059
evaluation rule pair applying induction hypothesis matching matching get expected result :10.1.1.47.1059
case dynamic rule applied typing derivation dynamic dyn clos dyn clos 
de nition dynamic 
evaluation possibilities 
rule apply dynamic 
rule assumes wrong 
contradicts induction hypothesis implies de nition type schemes 
evaluation rule dynamic dynamic follows applying induction hypothesis matching get proposition implies clos 
expected result 
proposition assume wrong value proof induction length evaluation case analysis show base case inductive cases cases similar :10.1.1.47.1059
rule typing derivation possible evaluation :10.1.1.47.1059
wrong 
hypothesis 
implies expected result 
typing rule :10.1.1.47.1059
clos fv evaluation rules lead rst wrong wrong induction hypothesis derive wrong evaluation step :10.1.1.47.1059
applying induction hypothesis evaluation get proposition implies clos fv :10.1.1.47.1059


clos fv apply induction hypothesis evaluation leads expected result wrong dynamic typing rule fv fv dynamic dyn dynamic clos evaluation possibilities :10.1.1.47.1059
rst rule concludes wrong wrong contradicts induction hypothesis :10.1.1.47.1059
evaluation step dynamic clos dynamic clos applying induction hypothesis evaluation get proposition implies clos 
dynamic clos dyn expected 
type reconstruction ml type system type system possess principal type property :10.1.1.47.1059
fact due closedness condition rule dynamic expressions 
consider expression function dynamic types int dyn dyn dyn generally dyn closed types lower bound types dyn valid type function corresponds construction dynamic statically unknown type 
programs statically detected rejected ambiguous de ned semantics 
programmer put type constraints unambiguously state program 
int 
fresh type variable dynamic int id :10.1.1.47.1059

id fresh variables function mgu mgu :10.1.1.47.1059
mgu fresh variable :10.1.1.47.1059
fv fv fv dynamic dyn fv fv type reconstruction algorithm slight technical diculty detecting ambiguous programs :10.1.1.47.1059
dynamic construct correct infer general type fail immediately variables free current typing environment variables may instantiated closed types 
consider expression function dynamic 
assuming function part application typed argument function type dyn dynamic appears build dynamic non closed type application typed instantiated int know dynamic created internal type int 
closedness check delayed type inference 
idea follows typing dynamic record type variables free inferred type current typing environment 
typechecking type variables set instantiated closed types 
process formalized simple extension damas milner algorithm 
algorithm shown gure 
takes input expression initial typing environment outputs type type inferred substitution recording instantiations performed set type expressions keeps track ambiguous dynamic constructions 
time dynamic expression typed type variables free inferred type current typing environment added expressions kinds simply carried instantiations performed performed variables free prevented generalized :10.1.1.47.1059
algorithm fails program typed 
algorithm succeeds containing closed types general type program 
algorithm succeeds contains non closed types program ambiguous type substitutions contains closed types 
dynamic patterns dynamic expected type explicitly pattern infer 
just check pattern type record polymorphic types variables bound considered inferring pattern right hand side pattern matching quite dicult variables bound di erent types compilation current caml implementation internal types dynamics represented term structure type int int list type constructors identi ed unique stamps names correctly handle type rede nition :10.1.1.47.1059
type variables encoded integers 
type variables assumed universally quanti ed 
code generated dynamic simply pairs value structured constant representing trivial instance 
pattern matching caml provides library function ge takes types tests rst general second 
code generated pattern matching dynamics simply calls ge internal type dynamic expected type structured constant type algorithm produce annotated expression extra result omitted sake simplicity :10.1.1.47.1059
easy reconstruct principal typing derivation built algorithm 

sequence tests matching internal value pattern entered ge returns true 
tests compiled assuming value tested belongs expected type dynamic incorrect match internal value rst internal type 
speed run time type tests switch representation internal types dynamics type option ref int list representation possible perform instantiations physical modi cations type ecient recording separately substitution :10.1.1.38.9875
physical modi cations reversed matching 
dynamic coercions faster perform partial evaluation ge predicate second argument known compile time 
conventional patternmatching compilation techniques apply directly consist specializing term matching predicates rst argument general term second general term :10.1.1.47.1059
specializing matching predicate ge second argument just dicult general problem specializing uni cation predicate arguments 
problem extensively studied context prolog compilation 
popular solution warren machine compilation scheme :10.1.1.47.1059
techniques developed apply problem 
shall detail issue section non closed types dynamic patterns section presents extension system possible match dynamic values dynamic patterns incomplete type information 
enables destructuring dynamics specifying exact type 
presentation previous system internal value dynamic extracted xed type 
turns insucient cases 
continue print example section :10.1.1.47.1059
product types single case matches dynamics pairs prints parentheses comma recursively calls print function print components pair 
done system pattern dynamic match dynamics internal type general de nitely dynamics internal type pair type 
need type variables dynamic patterns universally quanti ed existentially quanti ed bound corresponding parts internal type dynamic 
give complete version print function explicit universal existential quanti cation type variables dynamic patterns 
running example section 
type fun arg arg string rec print function dynamic int 
print int dynamic string 
print string print string print string dynamic :10.1.1.47.1059
print string print dynamic print string print dynamic print string dynamic list 
print string dynamic list 
print dynamic print string print dynamic dynamic 
print string function dynamic 
print string function dynamic 
gensym print string function print string print string print dynamic arg dynamic arg fun arg 
print string dynamic 
print string function 
print string typing existential quanti cation rst show existentially quanti ed type variables behave typing right hand side pattern matching 
existentially quanti ed variable bound actual type run time 
compile time assumptions type treat type 
type match type escape scope pattern matching binds allowed free type returned value 
consequence functions rejected function dynamic function dynamic perfectly legal function dynamic int applied dynamic succ dynamic int string :10.1.1.47.1059
important di erence existentially bound type variables types actual type bound type variable available run time 
object static type contains variable existentially bound possible build dynamic object 
internal type dynamic true type static type binding performed 
cases print function illustrate feature matching dynamic list succeeds dynamics created dynamic internal type type bound dynamic internal type list 
transforms dynamic non empty list dynamic head dynamic tail allowing recursion list 
mixed quanti cations existentially quanti ed variables freely mixed universally quanti ed variables inside type patterns 
semantics matching depends relative order variables quanti ed 
illustrated cases print example modest attempts printing functional values 
case pattern dynamic 
bound variable matches type expressions depend instance dynamic internal type rejected 
functions selected pattern exactly returning value type value exists ml selected functions terminate normally printed function 
case pattern dynamic 
bound instantiated type expressions containing instance pattern matches dynamic type list binding list 
pattern catches class functions operate uniformly arguments type :10.1.1.38.9875:10.1.1.47.1059
functions test arguments put data structures closures 
apply function symbolic name recursively print result get representation function body standing function parameter 
exactly printed function extensionally equivalent original function assuming side ects 
presence mixed quanti cation rules typing right hand side outlined strengthened correct treat existentially quanti ed type variable new atomic type 
consider function dynamic true assuming expression true typechecks applications type applying function dynamic function matching succeeds evaluates true evaluates true comparing true run time type violation 
actual value allowed depend static typechecking assume depend treat occurrences corresponding di erent instantiations incompatible 
achieved considering right hand side matching type constructor parameterized 
transformation known logic skolemization 
avoid confusion shall write type constructor associated type variable avoid confusion formal parameter constants mentioned function body formal parameters represented local type fun arg arg string 
ensures function create terms type fun arg print function 
fortunately self application print dynamic print selects case de nition 
assume typing true leads static type error sides equal sign incompatible types int bool 
typed sides type int :10.1.1.47.1059
general rule purpose typing right hand side pattern matching existentially quanti ed type variable replaced type expression list type variables universally quanti ed pattern 
multiple dynamic matching type variables quanti ed case pattern matching inside dynamic pattern 
di erence universally quanti ed variables type isomorphisms 
existentially quanti ed variables shared dynamic patterns expressing sharing constraints internal types dynamics 
instance dynamic function application example written function dynamic dynamic dynamic function takes pair dynamics applies rst contain function second returns result dynamic :10.1.1.47.1059
ensures type argument compatible domain type function 
type variables shared dynamic patterns matching shall prohibit sharing patterns belonging di erent matchings curried dynamic matching 
terms cases pattern matching required closed type variables contained dynamic patterns quanti ed corresponding matching 
instance possible write dynamic apply function appears function dynamic function dynamic dynamic violates requirement bound outermost matching mentioned innermost :10.1.1.47.1059
reasons restriction pragmatic curried dynamic matching conjunction polymorphic dynamics lead ambiguities bindings types existentially quanti ed type variables 
consider function dynamic dynamic function dynamic dynamic dynamic rst type matching succeeds bound list second matching requires narrowed int list 
unclear dynamic created matchings internal type list int list 
problem arise require actual type bound determined matching 
ensured closedness condition pattern matching signi cantly reducing expressive power language curried dynamic application written function df function dx match df dx cost error detection df dynamic function 
int fsc bv function function :10.1.1.47.1059
clos fv fv fv dynamic dyn dynamic clos :10.1.1.47.1059
int fv bv dynamic dyn clos typing rules mixed quanti cation type patterns syntax syntactic change sequence quanti ers front case pattern matchings :10.1.1.47.1059
expressions function annotated expressions function quanti er pre xes assume variables renamed quanti er pre xes bind variable twice 
write bv set variables bound pre typechecking introduce skolem constants level types 
type variable associate type constructor variable arity :10.1.1.47.1059
skolem constants appear inside inferred types appear type part dynamic patterns internal type dynamic values 
shall write types contain skolem constants 
de ne fsc free skolem constants type set variables type constructor appears new typing rules functions patterns shown gure 
case function de nition pattern typed account 
proposition takes extra argument pre carried unchanged rules rule dynamic patterns 
types identi ers bound pattern replace existentially quanti ed type variables corresponding skolem functions 
performed substitution de ned inductively follows id 
typing action proceeds previously 
simply check type contain skolem constants corresponding variables bound ensured side condition fsc bv rule 
evaluation existential type variables dynamic patterns signi cantly complicates semantics language dynamic creation dynamic matching 
modi ed evaluation rules shown gure 
value space values cst integer value pair value pair dynamic dynamics value clos function closure evaluation environments 

responses normal response wrong type error response pattern matching responses normal response wrong type error response type schemes appearing dynamic values required closed contain skolem constant 
cst function clos clos :10.1.1.47.1059
solve minimal pair :10.1.1.47.1059
dynamic dynamic :10.1.1.47.1059


:10.1.1.47.1059
:10.1.1.47.1059
:10.1.1.47.1059
bv dynamic dynamic 
evaluation rules mixed quanti cation type patterns error rules similar rules omitted dynamic creation evaluation dynamic transform static type inferred pairing value rule :10.1.1.47.1059
skolem constants representing existentially bound type variables replaced actual types bound variables properly instantiated 
bindings type variables recorded evaluation environment existential type variables may depend universal variables existential variable bound type context type expression holes simple type expression 
write type contexts type variables names holes function de ned evaluation function types 
maps type expression type expression containing skolem constants interpreting skolem constants environment int int dyn dyn function straightforwardly extends type schemes dom dynamic matching function application rule longer possible perform dynamic type matching separately dynamic pattern patterns may share existentially quanti ed variables :10.1.1.47.1059
dynamic type constraints collected rst set equations internal type dynamic type pattern :10.1.1.47.1059
response returned pattern matching predicate wrong pair set bindings set equations types 
addition pattern matching predicate parameterized quanti er pre matching rules 
pre rule select trivial instance internal type dynamic free variables clash variables bound second phase function solve called resolve set equations types pre account 
section precisely de nes solve 
type matching succeeds solve returns correct bindings existentially quanti ed type variables 
evaluation right hand side matching proceeds usual 
uni cation run time matching type patterns internal types dynamics amounts certain kind uni cation problem called uni cation pre problem studied extensively general setting higher order uni cation deal rstorder terms 
rst order problem appears 
case problem consists checking validity propositions format universal existential quanti ers rst order terms free algebra :10.1.1.47.1059
uni cation mixed pre generalizes known matching problem terms nd substitution uni cation problem terms nd substitution writing variables variables matching problem equivalent uni cation problem purpose dynamic matching want know proposition holds quanti er pre nd minimal assignments variables existentially quanti ed satisfy proposition 
shall treat variables universally bound constants 
add variables term constructors arity zero initial signature int dyn arity zero arity 
de nition substitution substitution variables constants contained term bound pre de nition substitution uni er substitution :10.1.1.47.1059
substitution exists said uni able 
clearly formula valid uni able 
proposition gives simple way check terms uni able 
proposition terms uni able uni able general uni er substitution 
proof part obvious 
part uni er terms uni able 
general uni er 
exists substitution 
variables constants contained subset contained 
substitution constants bound follows substitution 
proposition shows terms uni able possess general uni er :10.1.1.47.1059
immediately get algorithm compute general uni er compute general uni er robinson algorithm check substitution 
de ne function solve evaluation rule 
takes pre set equations types trivial instances internal types dynamic values 
types type parts dynamic patterns 
pre binds variables rst complete bind variables 
variables free take existential quanti cation means variables freely instantiated type matching universally quanti ed internal types dynamic values 
renaming constraint rule variables bound general uni er substitution transformed evaluation environment adding bindings variables existentially quanti ed precisely take solve de ned follows :10.1.1.47.1059
transformation run time counterpart skolemization function static typing section 
turns substitution evaluation environment re ects instantiations performed existentially quanti ed variables type matching process 
compilation semantics quite complicated surprise implementation turns delicate 
main diculty uni cation pre ecient algorithms available regular uni cation phase 
remains quickly check resulting substitution substitution 
check integrated occur check little extra cost 
idea re ect dependencies associating ranks integers type variables 
variables bound statically ranks left right 
variables internal types dynamics considered bound rank 
identifying variables resulting variable rank min rank rank 
binding existential variable constructed type legal 
occur check occur :10.1.1.47.1059
rank check contain universal type variable rank greater rank case simple dynamics section easiest way implement type matching call run time uni cation primitive type pattern annotated rank information constant argument :10.1.1.47.1059
partial evaluation uni cation primitive type pattern desirable speed type matching provide cleaner handling runtime type environments specialization bindings existential type variables recorded stack registers regular variables specialization uni cation primitive returns data structure containing bindings ecient code generated access bindings 
specializing uni cation arguments harder specializing matching second argument section :10.1.1.47.1059
techniques developed warren machine directly apply exception extra rank check :10.1.1.47.1059
instance wam perform occur check initial binding existential variable check ranks case 
di erence backtracking shallow wam terminology ml pattern matching deterministic 
simpli es handling trail 
ideas rst author integrated prototype uni cation compiler caml system 
caml pattern matching compiler modi ed implement uni cation semantics matching semantics depending ags put patterns :10.1.1.47.1059
low level mechanism allows performing uni cation parts data structure regular patternmatching parts 
dynamic patterns dynamic simply expanded type inference product patterns repr repr pattern matches internal representations types matching pattern repr marked uni cation semantics 
missing feature described rank check 
time considered dynamic patterns universal type variables come rst followed existential variables 
rank check added little modi cations 
dynamic matching bene ted optimizations performed pattern matching compiler including factorization tests cases utilization typing informations 
consequence dynamic matching quite ecient 
agreed eciency worth extra complication compiler prototype merged caml release 
assessment section discusses practical usefulness propositions drawing experience caml system 
structured input output caml system provides library functions extern extern channel dyn unit intern intern channel dyn eciently write read data structures persistent storage preserving sharing inside structure 
typical separate compiler communicate relocation information linker save reload symbol tables representing compiled module interfaces 
ml type system uses name equivalence concrete data types 
causes diculties dynamics written persistent storage program reading dynamic de ne data types di erent names program wrote dynamic de ne data types name di erent structures 
solutions problem 
rst revert structural equivalence dynamic type matching 
data type de nitions expanded dynamic values dynamic type patterns structural equivalence matching 
caml implementation intern extern takes approach writing dynamic persistent storage extern writes de nitions concrete data types names appear type part dynamic 
object read back intern checks reader program de nes data types names structurally similar de nitions raises exception case 
implementation allows faster dynamic coercion requires information data type de nitions available run time 
current implementation extern handle functional values caml compiler generates position dependent machine code 
position independent code persistent objects produced portable architectures 
problem de ning extern functions byte coded implementation 
conjunction character communication channels unix sockets intern extern primitives provide simple implementation remote procedure calls rpc :10.1.1.47.1059
sample rpc server monomorphic function true accept connection match intern dynamic arg extern dynamic arg done corresponding client stub function arg establish connection extern dynamic arg match intern dynamic res res rst proposed system supports remote calls monomorphic function 
existential variables second system required provide remote interface polymorphic function 
instance rpc server sorting function true accept connection match intern dynamic order arg bool list extern dynamic sort order arg done interfacing system functions dynamics possible provide interface number system functions static type ml :10.1.1.47.1059
dynamics functions available user type safe way 
caml system functions include eval syntax ml dyn typecheck compile evaluate piece ml syntax type ml 
easy provide caml embedded language inside program 
instance coq system proof development environment calculus constructions provides ability interactively de ne proof tactics written caml apply caml macro facility chapter eval syntax macro body arbitrary caml expression evaluation leads substituted text :10.1.1.47.1059
dyn ml constructors data type representing syntax trees 
constructor embeds constants arbitrary types inside syntax trees 
constants produced compile time evaluations macro expansion constant folding 
print dyn unit print dynamic value ml syntax :10.1.1.47.1059
caml provide polymorphic printing function type unit due optimizations data representation algorithm impossible decipher representation data knowing type 
examples returned dynamics generally coerced fully known types usually monomorphic 
see need existential type variables simpler dynamic system section largely sucient :10.1.1.47.1059
practice restriction encountered rst dynamics coerced closed types dynamics created closed types 
prevents print function called polymorphic function print polymorphic argument instance 
needed debugging purposes 
ad hoc polymorphism ml polymorphism uniform polymorphic functions operate way arguments types 
contrast ad hoc polymorphism consists having generic functions accept arguments types operate di erently objects di erent types 
prime examples print function equal predicate di erent algorithms print compare integers strings lists 
extensions functional languages proposed support de nition generic functions including type classes run time overloading :10.1.1.47.1059:10.1.1.47.1059
dynamics provide naive easy understand way de ne generic functions 
demonstrated print example dynamics permit joining prede ned functions atomic types print int print string functions data structures pairs lists recurse components structures main operation de ning generic functions 
important aspect generic functions extensibility new data type de ned functions extended deal objects new type 
supported dynamic implementation keeping list functions type dyn unit applied succeeds standard cases apply 
exception print printers ref dyn unit list type fun arg arg string rec print function dynamic int print int rec try print function rest try print try print rest print string try print printers new printer printers printers instance assuming type foo foo de ned add printer type foo follows new printer function dynamic foo print string dynamic foo print string print dynamic print string print dynamic print string raise print pointed implementation ad hoc generic functions dynamics major drawbacks :10.1.1.47.1059
restrictions dynamic creation polymorphic functions need call print take dynamics 
serious print prohibitive heavily functions equal functions sets association lists operate dynamics dramatically reducing accuracy static typing eciency compiled code 
statically check print applied objects printing method de ned 
important class type errors detected run time 
implementation generic functions inecient dynamics built coerced recursive call 
type classes run time overloading techniques realistic respects 
statically guarantee generic functions applied objects de ned 
perform type matching compile time possible 
run time type information usually arranged dictionaries methods allowing faster method selection dynamic type matching 
related number studies considered languages dynamic types 
studies deal automatic insertion dynamic creations coercions turn ambivalent programs programs recognized type safe type erroneous compile time equivalent programs run time type checks :10.1.1.47.1059
motivation integrate transparently dynamically typed statically typed objects motivation ecient compilation programs written dynamically typed languages scheme 
proposal insist keeping coercions dynamics explicit source code programmer responsibility serious programming errors go unnoticed compile time run time type checks automatically inserted reducing robustness programs 
dynamics closely related abadi cardelli pierce plotkin emy 
rst studies simply typed calculus enriched objects dynamic type :10.1.1.47.1059
dynamics coerced partially unknown types type patterns dynamic coercion construct contain pattern variables correspond second system ed variables 
polymorphism type matching straightforward 
abadi extended system polymorphic types :10.1.1.39.8178
main di erence latest system second system format type patterns dynamic coercions 
approach polymorphic type matching allow higher order pattern variables type patterns variables range type contexts 
instance type pattern second system corresponds system pattern pattern variable ranging operators types types 
algebra type patterns strictly expressive mixed quanti cation introduces linear ordering dependencies existential universal variables pattern variables express arbitrary dependencies patterns select polymorphic functions functions applied integer lists boolean lists patterns equivalent second system :10.1.1.47.1059
hand mixed quanti cation simple interpretation rst order logic possesses simple ecient type matching algorithm ad hoc restrictions put pattern variables keep type matching manageable 
extensions ml dynamic objects 
simpler proved quite successful interfacing user code important system functions type safe way 
implementation cost remains moderate 
extension generalizes dynamic patterns include universal existential variables type part possible dynamics coercing xed types 
semantics delicate considerably harder implement 
promising application extension dynamics data persistence interprocess communication 
rst proposed system allow operate persistent data generic way perform remote calls polymorphic functions second system supports operations 
practical experience needed determine expressive polymorphic type system dynamics needs order correctly support applications 
mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
th symposium principles programming languages 
acm press 
mart abadi luca cardelli benjamin pierce gordon plotkin :10.1.1.47.1059
dynamic typing statically typed language 
acm transactions programming languages systems :10.1.1.47.1059
mart abadi luca cardelli benjamin pierce didier emy :10.1.1.39.8178
dynamic typing polymorphic languages 
proceedings workshop ml applications :10.1.1.47.1059
hassan kaci 
wam real tutorial 
research report dec paris research lab 
luca cardelli 
amber 
combinators functional programming languages volume lecture notes computer science :10.1.1.47.1059
springer verlag 
luca cardelli :10.1.1.38.9875
basic polymorphic typechecking 
science computer programming :10.1.1.47.1059
luca cardelli jim donahue mick jordan bill kalsow greg nelson 
modula type system 
th symposium principles programming languages pages :10.1.1.47.1059
acm press 
guy cousineau erard huet 
caml primer 
technical report inria :10.1.1.47.1059
luis damas robin milner 
principal type schemes functional programs 
th symposium principles programming languages pages :10.1.1.47.1059
acm press :10.1.1.47.1059
roberto di cosmo 
type isomorphisms type assignment framework 
th symposium principles programming languages pages :10.1.1.47.1059
acm press :10.1.1.47.1059
gilles dowek amy felty hugo herbelin erard huet christine paulin mohring benjamin werner 
coq proof assistant user guide version 
technical report inria 
fritz henglein :10.1.1.47.1059
dynamic typing 
european symposium programming volume lecture notes computer science :10.1.1.47.1059
springer verlag :10.1.1.47.1059
xavier leroy 
polymorphism name continuations 
th symposium principles programming languages pages :10.1.1.47.1059
acm press 
david maier david warren 
computing logic logic programming prolog 
benjamin cummings 
harry mairson 
outline proof theory parametricity 
functional programming languages computer architecture volume lecture notes computer science pages :10.1.1.47.1059
michel mauny :10.1.1.38.9875
functional programming caml 
technical report inria :10.1.1.47.1059
dale miller 
lexical scoping universal quanti cation 
proceedings sixth international conference logic programming 
dale miller 
uni cation mixed pre technical report ms cis computer science department university pennsylvania 
appear journal symbolic computation 
robin milner mads tofte robert harper 
de nition standard ml 
mit press 
john mitchell :10.1.1.47.1059
type systems programming languages 
jan van leeuwen editor handbook theoretical computer science volume pages 
mit press elsevier 
alan mycroft :10.1.1.47.1059
dynamic types ml 
draft 
simon peyton jones :10.1.1.47.1059
implementation functional programming languages 
prentice hall 
fran cois :10.1.1.47.1059
safe run time overloading 
th symposium principles programming languages 
acm press 
satish thatte :10.1.1.47.1059
quasi static typing 
th symposium principles programming languages pages 
acm press 
mads tofte :10.1.1.47.1059
type inference polymorphic 
information computation 
philip wadler :10.1.1.38.9875:10.1.1.47.1059
theorems free 
functional programming languages computer architecture 
acm press 
philip wadler stephen blott :10.1.1.47.1059:10.1.1.47.1059
ad hoc polymorphism ad hoc 
th symposium principles programming languages 
acm press 
david warren :10.1.1.47.1059
prolog instruction set 
technical note sri international 
pierre weis caml manual version :10.1.1.47.1059
technical report inria :10.1.1.47.1059
:10.1.1.47.1059
