brics rs sassone jeeg temporal constraints synchronization concurrent objects brics basic research computer science jeeg temporal constraints synchronization concurrent objects giuseppe sassone brics report series rs issn february copyright giuseppe sassone 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics report series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document jeeg temporal constraints synchronization concurrent objects giuseppe sassone brics dk vs cogs susx ac uk brics aarhus university introduce jeeg dialect java declarative replacement synchronization mechanisms java results complete decoupling business synchronization code classes 
synchronization constraints jeeg expressed linear temporal logic allows effectively limit occurrence inheritance anomaly commonly affects concurrent object oriented languages 
jeeg inspired current trend aspect oriented languages 
jeeg program sequential concurrent aspects object behaviors decoupled specified separately programmer weaved jeeg compiler 
late eighties experiments mixing object oriented programming languages concurrency serious difficulties merging concepts 
typically code concurrency control interwoven business code classes represented obstacle code inheritance making essentially impossible simple common situations 
term inheritance anomaly coined refer issue 
problems arising interaction inheritance concurrency considered severe suggest removing inheritance concurrent object oriented languages entirely 
commonly object oriented code set messages accepted object uniform time 
depending object state methods unavailable pop empty stack put full buffer 
sequential situations conceivable clients keep track methods enabled 
instance required stack user know point time stack empty 
concurrent scenario clearly option 
clients way knowing clients cooperation respect requires non trivial specific protocols 
option stack code code controls access clients 
concurrent objects take direct control synchronization code phenomenon inheritance anomaly sets forcing programmers override inherited code order refine synchronization code 
situation exemplified simple case idealized pseudo code buffer 
class buffer void put object el buffer full 
object get buffer empty 
suppose enhance buffer wish add instance method freeze read 
original chunks code buffer chances totally rewritten take account new enabling condition 
generally speaking inheritance anomaly classified broad varieties 
partitioning states 
inspired example may disentangle code synchronization conditions describing methods enabling partition object states 
describe behavior class buffer instance state partitioned sets empty partial containing states buffer empty get inhibited full put disallowed 
specify put requires full get requires empty refine code get put specify state transitions 
instance get declare conditions buffer empty partial object get buffer empty empty partial inheritance anomaly surfaces derived classes may force refinement state partition 
example consider adding method get retrieves elements 
alongside empty full itis necessary distinguish states buffer contains exactly element 
clearly state transitions specified get put accordingly 
history acceptable states 
method enabling depending object state depends past history different form inheritance anomaly occurs 
suppose instance want refine buffer method works get executed immediately get 
clearly achieved java adding code get keep track invocations 
rewrite entire class 
revisit problem 
modification acceptable states 
third kind anomaly happens mix classes classes created mixed classes add behavior 
typical situation arises wishes enrich class method influences acceptance states original class methods 
previous example method freeze belongs essentially category anomaly 
similarly reasonable expect able design class lock void lock void unlock add lock capabilities clients classes means standard inheritance mechanism 
clearly multiple inheritance lock buffer creating buffer completely recode get put keep account state lock component object 
modern programming languages provide concurrency inheritance inheritance anomaly commonly ignored 
java mainstream concurrent object oriented languages synchronization primitives exclusively non declarative locks monitors 
generally accepted solution emerged far approaches appeared literature mitigate inheritance anomaly 
proposal jeeg focuses java 
jeeg dialect java method guards particularity address history sensitive inheritance anomaly 
guard languages methods labeled formulae describe enabling condition 
novelty approach version linear temporal logic ltl allow expressing properties history computation 
exploiting expressiveness ltl jeeg able single situations described examples language corresponding anomalies 
due nature problem course impossible claim formally language avoids inheritance anomaly solves 
matter depends synchronization primitives language choice new practice object oriented programming may time shortcomings unnoticed leading new kinds anomalies 
expressive power ltl clearly understood pleasant features jeeg come equipped precise characterization situations address 
precisely see anomalies depending sensitivity object histories expressible star free regular languages principle avoided jeeg 
current implementation jeeg relies large body theoretical ltl provides powerful model checking algorithms techniques 
currently method invocation incurs overhead linear size guards appearing method class 
evaluation guards runtime requires mutual exclusion guarantees marginal computational cost 
compared benefit substantially increased applicability inheritance feel mild price pay especially common practical situations code overriding infeasible cost ineffective 
time working alternative ways implement ideas jeeg aiming lower computational overhead expressive logics 
jeeg aspect oriented language 
synchronization constraints expressed declaratively totally decoupled body method enhance separation concerns 
structure follows presents language classical inheritance anomalies treats expressive power jeeg 
details language current implementation provided respectively 
discuss performance overhead brought forth jeeg methodology 
discuss related 
appendices provide optional material notably example jeeg java translation 
jeeg jeeg differs java new synchronization primitives replace wait notify constructs 
jeeg synchronization code class inlined methods specified separately 
done sync section class definition xml file associated class 
case jeeg class structure public class myclass sync 
standard java class definition 
sync section consists sequence declarations form method identifier language described shortly 
methods associated guard said guarded 
intuitively means point time method invocation executed guard evaluated object yields true 
execution blocked true 
resumption follows familiar rules java notifyall primitive 
guarded methods executed mutual exclusion level objects 
java perspective guarded method implicitly synchronized 
synchronization constraints jeeg exclusively method level synchronized keyword possible define guarded regions 
xml description synchronization complies dtd appendix described 
expressive power model synchronization depends course choice constraint language 
limit java boolean expressions obtain declarative version standard synchronization mechanism java 
constraint language choosing constraint logic trade expressiveness efficiency truth formulae verified method invocation 
need logic expressive java boolean expressions substantially worsen computational cost formula evaluation computational overhead overcome expressiveness benefits 
logic suits purpose linear temporal logic ltl 
shall see variation ltl context jeeg gives substantial improvement expressiveness java boolean expressions allowing particular vanishing history sensitive inheritance anomaly time keeps overhead evaluation time linear scale 
ltl introduces time propositional order logic 
possible reason dynamic evolving systems expressing properties referring happened past happen 
example write previous holds system states preceding state validates proposition greater true point time subsequent instants positive 
syntax constraint language choice cl follows 
ap previous cl defined starting atomic formulas ap denoted java boolean expressions 
consider exclusively pure boolean expressions side effects method invocations objects implicit self refer private protected fields class belongs 
note allow particular methods assumed side effects object equal ad hoc manner 
cl obvious conjunction disjunction negation connectives 
addition provides temporal past operators previous informal meaning described 
logic variation ltl known past tense ltl 
combining basic operators possible define interesting self explanatory auxiliary ones 
formally true 
user convenience operators predefined jeeg implementation 
helpful attempt tackle anomaly way refer history object method invocation 
notion event introduced serves purpose 
definition event 
event object execution methods 
basic notion define history object concurrent computation 
informally sequence events order occur states connect 
order precise observe assumption guarded public class counter private int public void public void dec simple counter methods run mutual exclusion computation unambiguously defines sequence method invocations object involved 
loss generality far concerned generic computation shape mi activations guarded methods hi ji sequences java heaps 
sequences arises assignments public variables method invocations unguarded objects methods 
formally defined induction thenumber guarded methods jk subcomputation terminating just invocation mk 
notice definition perfect sense hypothesis 
guards may refer private protected variables value affected invocation methods sensible choice assume sequence states evaluation temporal guards 
notice part hk containing values jk non private protected variables say needed 
represent object histories sequences computation remain implicit 
exemplify definition consider simple counter class 
execute history counter new counter dec dec dec extracting history obtain history 
interwoven executions presence concurrent objects easily get way complex 
notion history single object remains relatively simple 
instance illustrates histories case concurrent threads executing code distinct counters 
practical convenience think event mi special identifier event write understanding binds identifier event value representing method mi 
event undefined example third state event yields cl way history information finds way constraint language 
give formal semantics cl defining relation expressing property holds object computation 
denote 
indexes define thatis holds time structural induction follows 
iff true iff iff previous iff iff iff 
inheritance anomaly striking example inheritance anomaly borrowed mentioned applies class buffer implementation bounded buffer java 
consider defining subclass buffer provides additional method removes element buffer operation performed buffer get 
class historybuffer possible solution 
illustrates characteristic occurrence inheritance anomaly 
ideally expect method independent methods defined parent class 
deeper analysis shows implemented inherited redefined resulting loss code reuse inheritance provided 
example follows closely original presentation seen 
possible minimize amount code rewriting relying implementation methods get put superclass 
write public class historybuffer extends buffer boolean false public historybuffer int max super max public class buffer protected object buf protected int max protected int current buffer int max max max buf new object max public synchronized object get throws exception current wait current object ret buf current notifyall return ret public synchronized void put object throws exception current max wait buf current current notifyall concurrent bounded buffer java public synchronized object throws exception current wait false return super get public synchronized object get throws exception object super get true return public synchronized void put object throws exception super put false comes price redundant synchronization 
problem remains 
addition method forces revise implementation seemingly unrelated inherited methods 
kind anomaly arises fact history sensitive method 
generally speaking inheritance anomaly depends synchronization primitives language different primitives result different varieties anomaly 
particular languages method guards cousin technologies run risk suffering history acceptable states 
case jeeg synchronization mechanisms variation method guards 
test expressiveness jeeg handling subclassing history sensitive methods 
come surprise additional expressive power added method guards temporal aspects cl suffices solve occurrences inheritance anomaly 
section exemplify expressiveness try quantify formally 
consider jeeg version class buffer defined 
define class historybuffer jeeg 
example shows temporal operator previous avoided occurrence inheritance anomaly 
longer need introduce instance variable keep track operation performed 
cl gives expressive power 
discussed different kind inheritance public class historybuffer extends buffer boolean false public historybuffer int max super max public synchronized object throws exception current wait current object ret buf current false notifyall return ret public synchronized object get throws exception current wait current object ret buf current true notifyall return ret public synchronized void put object throws exception current max wait buf current current false notifyall class historybuffer java public class buffer sync put current max get current protected object buf protected int max protected int current buffer int max max max buf new object max public object get throws exception current object ret buf current return ret public void put object throws exception buf current current buffer class jeeg public class historybuffer extends buffer sync previous event get current public historybuffer int max super max public object throws exception current object ret buf current return ret historybuffer class jeeg anomaly plagues guard languages arises case mix classes 
authors multiple inheritance show variant inheritance anomaly 
java jeeg provide multiple inheritance interfaces results similar problems 
consider class 
subclass class buffer implements lock interface resulting buffer 
locked buffer accept message unlock 
expect newly introduced methods orthogonal inherited ones natural inherited multiple inheritance 
naturally java simply implement lock interface buffer methods put get need redefined account new locked unlocked states possibly introducing new boolean variable locked distinguish states buffer 
jeeg solves problem elegantly seen exploiting temporal operators constraint language 
lock unlock history sensitive methods 
note synchronization constraints inherited methods overridden method definitions 
explained jeeg method definitions synchronization constraints orthogonal overridden inherited separately 
expected syntax super allows refer synchronization constraint method get case defined super class 
general constraint attached method super class write super 
public interface lock public void lock public void unlock public class extends buffer implements lock sync get super 
previous event lock put super 
previous event lock lock 
previous event lock unlock true public int max super max public void lock public void unlock expressiveness jeeg buffer introducing new synchronization primitive concurrent object oriented language difficult assess impact inheritance anomaly quantitative manner 
building large body results ltl analysis possible jeeg 
particular adapt context characterization ltl expressiveness term star free regular languages 
thorough ltl reader referred 
question interested degree jeeg solve inheritance anomaly 
language java anomaly arises observable behavior object complex ascertained internal state 
instance internal state buffer object account information method executed get 
order define need refine internal state object comes heavy price 
constraint language jeeg allows describe sequences events ascertain behaviors state 
long cl describe certain sequence write constraint avoids need state refinement 
measure inheritance anomaly disappears jeeg obtained measuring sequences states definable cl purpose section assume ap finite 
definition general regular expressions 
finite alphabet regular expressions special symbol defined grammar 
re re re re re re denotes empty word denotes language consisting single string represent respectively language concatenation union negation respect kleene closure 
star free regular expressions regular expressions occurrence 
classical result ltl says sets state sequences definable ltl formulae atomic propositions ap coincide star free regular languages alphabet ap powerset ap 
spelling set state sequences set satisfy star free regular language 
reader referred forthe details 
applied framework result gives answer question cl define sets sequences states star free regular languages finite subsets ap 
refine statement observe identify certain state object better part expressible cl boolean formula private protected field values 
ac set boolean expressions 
follows certain sequence states identified set formulae ac 
note general denote set sequences states sequences meaning pi 
context theorem formalizes correspondence point view class sequences states denoted cl formulae sequences states corresponding star free regular expressions ac 
theorem characterizing cl 
class set state sequences 
cl formula exists star free regular expression re ac iff re 
interesting specialize result ap restricted cl expresses properties sequences events states distinguishable respect captures precisely sets sequences events star free regular languages alphabet method identifiers 
characterization terms regular languages provides intuition expressed cl result occurrence inheritance anomalies 
show admittedly contrived example 
example 
consider class representing simple shared resource simultaneously held multiple clients public class sync request true release true public void request public void release 
resource clients supposed call method request 
client need resource anymore call method release 
keep example simple assume clients respect protocol 
suppose want define class allows clients gain exclusive access shared resource 
accomplished providing additional method 
clearly method allowed execute client resource 
accomplish sure call method request followed call method release 
unfortunately constraint expressed ltl 
language point view want know history object word language request release mm dots stand method identifier class 
known language language balanced parentheses star free regular 
consequence possible write synchronization constraint method cl thatis find formula describes states enabled 
need keep track manually resource public class extends sync request previous event previous event count int count public void request count public void release count public void 
derived class uses counter count ascertain resource currently client 
accomplish book keeping necessary redefine base class methods request release 
example typical 
constraint expressed ltl involve form recurrent counting 
depth discussion issues refer 
example 
classic historybuffer example solved jeeg 
interesting analyze simple temporal constraint example terms star free regular expressions 
constraint relative method previous event get current simplicity restrict temporal component previous event get light previous discussion equivalence past ltl formulae star free regular expressions shall give constraint regular expression form 
intuitively language formula describes words trace alphabet symbol get 
define 
abuse notation shall denote formula event get simply get 
manner occurrences event get history object recorded simply get 
corresponding star free regular expression get formalizes intuitive set words symbol get 
digging deeper jeeg section look deeper interaction jeeg synchronization primitives available language features 
synchronized unsynchronized methods jeeg methods synchronization constraint specified executed mutual exclusion 
java terms synchronized 
hand methods synchronization constraint specified mutual exclusion guarantee 
clearly unsynchronized methods may lead mutual exclusion problems 
particularly relevant setting evaluation guard atomic order meaningful 
unsynchronized method attempts modify attribute object guard evaluated may inconsistent result 
trivial example clarify situation 
public class counter sync process count protected count public count 
public process 
example method executed mutual exclusion consequence modify value count call method process evaluation guard 
naturally call change value guard process evaluation leave method process executed inconsistent state 
similar situation occur guards allowed public attributes 
avoid situations attributes occurring guard accesses mutual exclusion evaluation guard 
jeeg attributes guards modified synchronized methods 
java consequently jeeg allow methods attributes declared static 
static fields methods common class instances 
access static attribute lock certain object instance 
lock guarantee mutually exclusive access static attributes 
lock needed obtain access class object 
consequence static fields modified static synchronized methods 
conversely static synchronized methods lock class specific object instance 
reason methods forbidden modify non static object fields 
issue related unsynchronized methods step wise history object defined regards execution order 
methods active time 
force ordering unsynchronized methods adopt policy accounting methods history moment execution finishes 
notice multiprocessor system notion defined 
bad programming practice systems rely guards truth values depend relative ordering unsynchronized methods 
method overloading synchronization point view jeeg distinguish different versions overloaded method 
synchronization granularity stops method identifier level 
example synchronization constraint applies definitions overloaded method choice motivated fact synchronization constraints relate essential behavior method feel changed overloading 
certainly define overloaded method definitions access shared attributes object completely different manner 
difficult support situations basing synchronization constraints method signatures identifiers 
inheritance method overriding consider subclass buffer defined 
assume existence support class couple wraps values object 
new class override method base class public class int sync event public void object public void int 
method overloading methods inherited synchronization constraints 
additional constraint new method independent existing ones 
jeeg method definitions synchronization constraints completely decoupled 
scales method overriding possible selectively override method definition synchronization constraint 
show example class override bodies get put methods overrides synchronization constraints making stricter 
case say synchronization constraint super class covariantly redefined 
author favors manner synchronization overriding 
general agreement issue 
example language making synchronization constraints strict derived classes authors argue favor choice 
jeeg manners synchronization overriding possible believe techniques different situations 
example derived class synchronization constraints parent stringent consider simple class representing resource 
base class resource allows acquire method called resource taken 
derived class adopt stringent policy models read resource consequence shared mutual exclusion problems 
reason sense allow multiple clients share resource accomplish synchro public class extends buffer sync get current public couple get current object ret buf current current object ret buf current return new couple ret ret inheriting synchronization constraints constraint method acquire stringent parent class 
see extreme class overrides method override synchronization constraint remains inherited 
semantics straightforward method get returns object stored buffer chunk bytes 
clearly affect concurrent behavior safe keep synchronization constraint unchanged 
jeeg exceptions method execution stopped occurrence unhandled exception 
respect object history possibilities arise 
choose keep method history ignore 
possible provide examples favoring approach 
solutions pose implementation challenges 
current implementation chose put history methods completed execution 
xml constraints order favor separation method definitions synchronization code jeeg allows synchronization constraints specified separately xml file 
jeeg compiler processes source file classname looks xml file named classname xml 
finds file validates relevant document type definition dtd public class resource int boolean busy sync acquire busy release true public void acquire int id id busy true public void release busy false public class extend resource sync acquire true resource hierarchy appendix validation successful synchronization constraints describes weaved resulting class file 
sync section class definition overridden external constraints xml file 
give quick taste define synchronization constraints xml file consider bounded buffer example 
sync section equivalent xml description xml version doctype jeeg system jeeg dtd jeeg class name historybuffer super buffer version method name arg public class extends buffer public object get current byte representation buf current byte return class jeeg serializing buffer previous event get previous arg arg current arg method implementation current jeeg implementation pre processor jeeg source file generates equivalent java file compiles byte code 
resulting class files rely runtime system classpath java virtual machine jvm 
requirement jvm java compliant 
purpose runtime system implement run time evaluator cl formulae program 
available www brics dk jeeg run time evaluation cl expressions cl language essentially variation ltl past tense temporal operators 
time guarded method called execution depends truth value certain temporal formula synchronization constraint 
constraint evaluates true method executed blocked condition true 
run time evaluation ltl formulae recurrent problem 
wider context problem stated follows finite trace 
problem appears frequently trying apply model checking techniques verification java programs 
traditionally ltl model checking accomplished translating ltl formula chi automata proving properties 
authors discuss solution ideal runtime verification finite traces approach runtime analysis tool 
dealing past tense operators gives advantage 
dynamic programming algorithm requires input trace program evaluate certain formula traverses program trace backwards 
implies algorithm online executed time program refers 
duality algorithm online past fragment 
algorithm complexity size ltl formula 
alternative approach rely modifying automata algorithm proposed adapt past tense operators 
implementation choices available 
current jeeg implementation relies variation dynamic programming algorithm 
choice natural 
algorithm efficient weakening logic result faster algorithm 
intuitively jeeg program set synchronization constraints compiler generates run time evaluation algorithm weaves business code program 
step object history method execution evaluator updates truth values synchronization constraints 
evaluation algorithm consists repeated visits syntax tree formula 
focus ideas consider example temporal formula corresponding tree previous previous node tree represents subformula original temporal formula labeled attributes respectively hold truth value corresponding sub formula current time step 
task algorithm visit tree update values attributes node 
adopted strong semantics temporal operators assumed previous applied times greater zero 
consequence initial instant attribute sub formula set false 
truth value attribute initialized object created depends initial state object 
node notation refer left wise child second child node represents binary operator 
attributes children denoted 
algorithm performs simple depth visit tree node updates value fields 
perform assignment depending node type updated field rules previous ap eval clarify working algorithm consider simple formula previous trivial counter class 
suppose execute code previous false false false false previous false false true false counter new counter dec history previous true false false true dec previous false true true false shows attributes formula tree evolve respect history object easy see complexity run time evaluation algorithm linear size formula tree 
run time overhead involved linear size synchronization constraints 
synchronization manager evaluation algorithm sound formulae evaluated step program history method execution 
accomplished synchronization manager mechanism method call interception mci typical implementation aspect oriented languages 
synchronization manager takes control method call 
checks synchronization constraint method verified 
note constraint evaluated stage truth value available 
case truth value synchronization constraints updated execution method 
constraint true control goes back method code synchronization manager performs wait put method hold 
execution method accomplished control shifts back synchronization manager 
point synchronization constraints evaluated 
execution method may change state object updating value synchronization constraints manager issues notifyall statement 
blocked methods may attempt proceed 
perform tasks synchronization manager access private protected fields object 
accomplish chose synchronization manager inner class object manages 
complete example showing java code generated jeeg source file appendix time ms benchmarks constraint size object creation overhead machine machine machine machine assess feasibility approach performed targeted benchmarking current prototype implementation jeeg compiler 
section outline results 
general setting benchmarking code running jvm care taken avoid interference garbage collector 
furthermore single measurement valid indication actual time spent operation 
multiple measurement experiment performed 
take average fair result experiment 
java designed platform independent different implementations virtual machine different operating systems perform differently 
chose perform tests popular operating systems linux windows 
chose run virtual machine optimizations particular just time compiler turned 
manner run tests number times speedups 
benchmarks measure worst case scenario code executed gain expected just time compilation 
programs compiled run se option 
better feel performance impact realistic setting performed tests low high machines 
list machines machine amd xp mb windows jdk machine amd xp mb linux redhat jdk machine celeron mhz mb windows jdk machine pentium ghz mb linux jdk code benchmarks available web www brics dk jeeg 
benchmark results overhead introduced methodology felt time object creation call synchronized method performed 
showing test results situations conclude evaluation performance impact jeeg methodology 
object creation object creation time structures representing temporal formulae synchronization constraints built 
results creation objects logic operators formulae 
consequence expect object creation slower synchronization constraints grow complex 
quantify overhead timed creation objects increasing complex synchronization constraints size formulae involved 
constructor object empty 
results tests 
time ms method call constraint size method call overhead machine machine machine machine time synchronized method called algorithm described performed 
results evaluation synchronization constraints 
overhead face proportional sum sizes logic formulae describing constraints 
clearly method call incur overhead regardless size synchronization constraint 
measure overhead involved technique tested method calls objects increasing complex synchronization constraints 
sure avoid biased result constraints evaluate true 
method calls performed function way sure measured unavoidable overhead brought technique 
results tests seen 
different performance problem result fact synchronization constraints evaluated mutual exclusion 
object locked evaluation 
number threads actively accessing object slow method calls sensibly 
evaluate issue performed test increasing number threads 
results 
constraints threads actively objects face sensible time ms threads machine machine constraint size time ms threads method call overhead constraint size slow 
wish jeeg takes care synchronization constraints object 
equivalent java program accomplish results different fashion example boolean variables keep track state 
interesting experiment comparison semantically equivalent jeeg java programs 
test bed historybuffer example 
compares execution time method call java implementation class historybuffer seen jeeg counterpart seen 
high machines feel performance loss hand threads active time low machine suffers sever performance losses 
low machine performs presence active threads shows 
evaluation tests show low load threads complex synchronization constraints yield little performance overhead 
low machines face worse scalability problems due additional time object kept locked 
machine perform evaluation algorithm fast number threads kept waiting 
experience shows synchronization constraints object seldom reach length logical connectives 
benchmarks show objects performance loss negligible case high load active threads 
time ms time ms threads historybuffer performances threads historybuffer performances details machine machine java java machine currently evaluating possible optimization strategies formulae evaluation algorithm 
related idea specifying synchronization constraints programming opposed verifying temporal logic best knowledge explored 
problem run time evaluation ltl formulae come attention research community 
idea complete separation definition method synchronization constraints known helpful avoiding inheritance anomaly 
concept making synchronization code method definitions totally independent degree need specified file 
regard jeeg inspired current trends component aspect oriented programming 
fr lund proposed methodology selective inheritance synchronization constraints 
proposal method guards favors covariant redefinition synchronization constraints derived classes 
pointed manner synchronization redefinition universally accepted 
languages take opposite view allow derived class synchronization constraints stringent contravariant 
examples exist favor approaches consequence decided allow manners overriding 
point view inheritance anomaly fr lund methodology subject usual problems related method guards history dependent variants anomaly 
meseguer analyzed problem inheritance anomaly context rewriting logic language maude 
meseguer aimed removing need synchronization code place 
technique rewriting logic closely tied maude system aware adaption imperative object oriented languages java 
different lines taken matsuoka yonezawa notion reflection second aiming reducing amount synchronization code minimum 
approach line aspect oriented programming 
communication types act provide way tackle history sensitive anomaly modular fashion ad hoc coding 
instance anomaly requires programmer write specific act solve 
problem moved object act solved 
similar results obtained synchronization patterns rings methodologies 
introduced jeeg dialect java synchronization constraints written linear temporal logic specified declarative manner 
showed examples additional expressive power synchronization language cl helpful treating inheritance anomaly 
provided characterization expressiveness cl terms regular languages yields precise description sequences events express 
described current implementation jeeg 
propositional linear temporal logic offer excellent balance expressiveness computational overhead 
interesting base jeeg quantified linear temporal logic monadic second order logic msol second order variations ltl greater expressiveness 
particular msol stay regular languages ltl stays star free regular languages 
giving power express synchronization policies complex regular languages options increased computational cost currently investigating 
regards jeeg compiler exploring possibility optimizing ltl evaluation procedure ad hoc static analysis techniques 
current implementation jeeg compiler available online www brics dk jeeg 
oliver extensively reviewed early version answered questions ltl model checking 
luigi early discussions object traces 
number people read original manuscript grateful feedback 
america 
pool design experience 
oops messenger apr 
bergmans 
composing concurrent objects 
phd thesis university twente 

briot yonezawa 
inheritance synchronization concurrent oop 
european conference object oriented programming ecoop volume lecture notes computer science pages 
springer verlag 
clarke grumberg peled 
model checking 
mit press 

temporal rover atg rover 
spin model checking software verification volume lecture notes computer science pages 
springer verlag 
emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume pages amsterdam 
elsevier science publishers 
fr lund 
inheritance synchronization constraints concurrent object oriented programming languages 
ecoop european conference object oriented programming volume lecture notes computer science pages 
springer verlag 
giannakopoulou havelund 
automata verification temporal properties running programs 
automated software engineering ase san diego california november 
ieee computer society 
havelund rosu 
monitoring java programs java 
workshop runtime verification rv volume electronic notes theoretical computer science july 
havelund rosu 
monitoring programs rewriting 
automated software engineering ase san diego california november 
ieee computer society 
havelund rosu 
testing linear temporal logic formulae finite execution traces 
technical report tr riacs may 
holmes 
synchronization rings composable synchronization object oriented systems 
phd thesis macquarie university 
holzmann 
model checker spin 
ieee transactions software engineering may 
special issue formal methods software practice 
kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
ecoop object oriented programming volume lecture notes computer science pages 
springer 
lee kannan kim viswanathan 
runtime assurance formal specifications 
proceedings international conference parallel distributed processing techniques applications 
lichtenstein pnueli zuck 
glory past 
parikh editor proceedings rd workshop logics programs brooklyn ny usa june volume lecture notes computer science pages 
springer verlag berlin 
lopes lieberherr 
abstracting process function relations concurrent object oriented applications 
lecture notes computer science 
matsuoka yonezawa 
synchronization constraints inheritance possible technical report tr department information science university tokyo 
matsuoka yonezawa 
analysis inheritance anomaly objectoriented concurrent programming language 
gul peter akinori editors research directions concurrent object oriented programming pages 
mit press 
meseguer 
solving inheritance anomaly concurrent object oriented programming 
proceedings ecoop european conference object oriented programming lncs pages 
springer verlag july 
meseguer 
parallel programming maude 
proceedings research directions high level parallel programming languages volume lecture notes computer science pages berlin germany june 
springer 
nierstrasz papathomas 
viewing objects patterns communicating agents 
proceedings oopsla ecoop conference object oriented programming systems languages applications pages oct 
published acm sigplan notices volume number 
nierstrasz papathomas 
type theory active objects 
acm oops messenger proceedings oopsla ecoop workshop object concurrent systems apr 
pnueli 
temporal logic programs 
proceedings th ieee symposium foundations computer science focs pages 
ieee computer society press oct nov 
rosu havelund 
synthesizing dynamic programming algorithms linear temporal logic formulae 
technical report tr riacs may 
tomlinson singh 
inheritance synchronization enabled sets 
proceedings oopsla conference objectoriented programming systems languages applications 
wolfgang thomas 
languages automata logic 
van leeuwen editor handbook theoretical computer science volume amsterdam 
elsevier science publishers 
zuck 
past temporal logic 
phd thesis weizmann institute 
jeeg document type definition dtd element jeeg class element class method attlist class name cdata required super cdata implied version cdata element method previous implies attlist method name cdata required element constraint pcdata element pcdata element previous previous implies element previous implies element previous implies element arg arg element arg arg element arg arg element implies arg arg element arg previous implies java code generated buffer example section show code generated jeeg compiler buffer example 
interface class names referring jeeg runtime system normally fully qualified 
keep names short write instance fully qualified org brics gm jeeg formulae 
import org brics gm jeeg formulae import org brics gm jeeg events public class buffer protected sync null protected void sync protected class public protected class implements public boolean eval return current max protected class implements public boolean eval return current protected new new protected new new protected include statements refer jeeg run time system 
jeeg class requires synchronization manager described 
object creation time specify synchronization manager take care class 
synchronization manager inserted inner class 
propositional formulae ap wrapped classes 
observe java inner class mechanism synchronization manager full access private protected attributes surrounding class 
appropriate temporal formulae representing synchronization constraints object instantiated 
classes taken jeeg run time system 
protected protected int unknown protected int get protected int put protected event event new event unknown public void eval eval public boolean return public void throws exception 
buffer wait event new event get system public void throws exception event system buffer notifyall public boolean return public void throws exception 
buffer wait event new event put system unique identifier generated method 
identify events 
object creation time history object empty event variable takes unknown value 
method evaluates synchronization constraints 
done algorithm described method execution 
method synchronization manager methods called execution actual code called execution completed 
synchronization constraints wrapped functions name method constraint refers 
conditions evaluated method 
public void throws exception event system buffer notifyall protected object buf protected int max protected int current buffer int max max max buf new object max new public synchronized object get throws exception sync current object ret buf current sync return ret public synchronized void put object throws exception sync buf current current sync method takes care issuing notifyall wake thread waiting 
call method takes care evolving object history 
object created new synchronization manager registered 
call take care initializing history object 
calls acquire release methods inserted respectively code 
implements simple mechanism method call interception 
brics report series publications rs giuseppe sassone 
jeeg temporal constraints synchronization concurrent objects 
february 
pp 
short version appears fox editors joint acm conference java grande proceedings pages 
rs simon christensen anders ller michael schwartzbach 
precise analysis string expressions 
february 
pp 
rs marco mogens nielsen 
formal model trust 
january 
rs claude cr paul dumais dominic louis 
computational collapse quantum information 
january 
pp 
rs olivier danvy pablo mart nez pez 
tagging encoding jones optimality 
january 
appear degano editor programming languages systems twelfth european symposium programming esop proceedings lncs 
rs sassone 
deriving bisimulation congruences categories vs precategories 
january 
appear gordon editor foundations software science computation structures fossacs proceedings lncs 
rs olivier danvy 
new pass transformation monadic normal form 
december 
pp 
appear editor compiler construction th international conference cc proceedings lncs 
rs gerth st rolf anna christian pedersen rao 
computing refined buneman trees cubic time 
december 
pp 
rs nygaard glynn winskel 
hopla higher order process language 
december 
pp 
appears jan ar ret editors concurrency theory th international conference concur proceedings lncs pages 
