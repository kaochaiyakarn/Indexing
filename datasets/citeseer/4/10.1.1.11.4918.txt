reconfigurable computing systems viktor prasanna reconfigurable computing emerging new paradigm satisfying simultaneous demand application performance flexibility 
ability customize architecture match computation dataflow application demonstrated significant performance benefits compared general purpose architectures 
computer vision applications class applications significant heterogeneity computation communication structures 
low level vision algorithms regular repetitive computations operating large sets image data predictable data dependencies 
higher level computations irregular dependencies 
computer vision application characteristics significant overlap advantages reconfigurable architectures 
main focus outlining methodologies required realize potential reconfigurable architectures vision applications 
giving broad reconfigurable computing advantages utilizing reconfigurable architectures vision applications outlined illustrated example computations 
discusses development fundamental configurable computing models underlying hardware high level application mapping 
hybrid system architecture model algorithms utilizing model illustrated demonstrate formal framework 
outlines ongoing research provides comprehensive list reading 
keywords reconfigurable architectures computer vision modeling algorithms computer vision wide range applications focused compute intensive military processing general consumer electronics 
applications range automatic target recognition atr automated object tracking terrain modeling analysis image compression desktop cameras finger print verification postal address analysis 
vision tasks high computational requirements real time throughput constraints 
addition large number fine grain computations vision tasks complex data flow varies significantly single application different applications 
general purpose architectures microprocessors digital signal processors usually sustain required computational data flow throughput 
processors microprocessors digital signal processors heart current high performance computing platforms 
provide flexible computing platform capable executing large class applications 
functionality component supported part darpa adaptive computing systems program contract dabt monitored fort part national science foundation ccr 
dept ee systems university southern california los angeles ca 
usc edu microprocessor fixed 
applications executed decoding stream instructions software operating data stored memory hierarchy 
result fixed hardware general purpose applications 
sequential instruction decoding execution memory access bottleneck fixed control architecture limit performance achieved processors 
application specific integrated circuits asics provide alternate solution addresses performance issues general purpose processors 
asics designed specific application asic fixed functionality superior performance highly restricted set applications 
commercial military vision applications evolving algorithms need support emerging standards 
asics restrict flexibility architecture exclude post design optimizations upgrades features algorithms 
new computing paradigm reconfigurable computing promises intermediate trade flexibility performance 
reconfigurable computing utilizes hardware adapted run time facilitate greater flexibility compromising performance 
reconfigurable architectures exploit fine grain coarse grain parallelism available application adaptability 
exploiting parallelism provides significant performance advantages compared conventional microprocessors 
reconfigurability hardware permits adaptation hardware specific computations application achieve higher performance compared software 
complex functions mapped architecture achieving higher silicon utilization reducing instruction fetch execute bottleneck 
give overview reconfigurable computing emerging architectures space 
characteristics reconfigurable computing differentiate traditional computing paradigms identified classify various architectures space 
brief outline specific reconfigurable architectures provided illustrate salient features architectures 
identify features reconfigurable architectures appropriate target mapping vision applications 
impressive results achieved researchers mapping vision applications reconfigurable platforms outlined 
emergence new computing paradigm necessitated need new algorithmic techniques facilitate mapping applications architectures 
adaptability underlying hardware results new challenges developing computation models mapping techniques reconfigurable architectures 
identify challenges developing models mapping techniques reconfigurable computing 
parameterized hybrid system architecture model described detail solution challenge 
illustrate utility model outlining algorithm mapping image processing task reconfigurable architecture 
approach aggressive dynamic reconfiguration hardware exploit variation algorithmic requirements image processing task 
section ii provides overview reconfigurable computing example architectures 
section iii outlines vision tasks correspondence vision applications advantages reconfigurable architectures 
section iv outlines challenges reconfigurable computing 
hybrid system architecture model section example dynamic precision variation algorithm described 
section vi provides concluding remarks provides study 
ii 
reconfigurable computing reconfigurable architectures evolved field programmable gate arrays fpgas 
fpgas consist matrix logic blocks interconnection network 
functionality logic blocks connections interconnection network modified downloading bits configuration data hardware 
currently hybrid architectures integrate programmable logic interconnect microprocessor chip developed 
chip integration reconfigurable logic reduces memory access costs reconfiguration costs 
availability increasingly larger number transistors see facilitates integration reconfigurable logic components system chip soc architectures 
year technology roadmap semiconductors fig 

international technology roadmap semiconductors refer reader surveys explore large number research commercial reconfigurable architectures developed investigated 
characteristics reconfigurable logic reconfigurable logic defined consist matrix programmable computational units programmable interconnection network superimposed computational matrix 
fundamental differences reconfigurable logic traditional processing architectures include ffl spatial computation data processed spatially distributing computations temporally sequencing shared computational unit 
ffl configurable datapath functionality computational units interconnection network adapted run time configuration mechanism 
ffl distributed control computational units process data local configuration instruction broadcast functional units 
ffl distributed resources required resources computation computational units memory distributed device localized single location 
spatial distribution computations distributed control resources result higher computational power efficiency reconfigurable computing compared microprocessors dsps asics 
computational power efficiency defined number number gates actively working clock cycle solve problem total number gates device 
traditional architectures microprocessors dsps large portion chip utilized support active computation smaller portion chip 
reconfigurable computing achieve significantly higher computational power efficiency compared conventional microprocessors asics 
classification large number reconfigurable architectures developed years researchers industry 
reconfigurable architectures classified different parameters 
section list distinguishing architectural parameters classify reconfigurable architectures 
examples type architectures discussed detail sections 
ffl granularity granularity reconfigurable logic size smallest functional unit addressed mapping tools 
lower granularity provides flexibility adapting hardware computation structure 
lower granularity performance penalty due larger delays constructing computation modules larger size distinction configurable reconfigurable logic fuzzy best 
definitions configurable restrict logic programmed time computation 
devices non recurring engineering costs associated asics 
reconfigurable logic defined device reprogrammed run time computations field 
adaptive configurable reconfigurable mean reconfigurable run time 
smaller functional units 
architectures implement features specifically targeted reducing overheads 
example fpgas implement fast carry chains permit construction larger arithmetic modules small functional units 
typically fpgas smaller granularity input input functional units 
reconfigurable architectures chameleon implement coarse grain arithmetic units larger size bits 
ffl host coupling large fraction reconfigurable logic utilized processing fabric attached host processor 
host processor performs control functions configure logic schedule data input output external interfacing things 
type coupling host system dictates overheads utilizing reconfigurable logic speed computations 
degree coupling affects reconfiguration data access costs 
degree coupling roughly partitioned classes loose system level coupling includes architectures reconfigurable logic communicating host interface similar disk drive peripherals 
large number initial fpga boards architected degree coupling 
architectures include splash 
loose chip level coupling systems reduce overheads communicating host direct communication host reconfigurable logic 
example architecture prism 
large number existing embedded architectures reconfigurable logic architected technique 
tight chip coupling availability large number transistors resulted integration reconfigurable logic chip host processor significantly reducing communication overheads different components architecture 
architectures include garp chameleon 
ffl reconfiguration methodology typically reconfigurable device configured downloading sequence bits known bitstream device 
speed methodology download depend interface supported device 
possible interfaces bit serial bit parallel interface 
time configuration directly proportional size bit stream 
fine grain coarse grain devices differences configuration time coarse grain devices typically need smaller configuration bitstreams 
flexibility reconfiguration achieved cost reconfiguration cost 
reconfigurable logic computation initiating new configuration 
reconfiguration time significant especially finegrain multi gate fpgas 
architectures support partial dynamic reconfiguration 
partial reconfiguration permits reconfiguration functionality portion device remaining portion retains functionality 
dynamic reconfiguration permits reconfiguration portion device portions device performing computations 
architectures address problem utilizing multiple contexts reconfiguration cache 
concepts similar principle 
configurations device stored buffers possibly chip memory 
run time expensive switch configurations memory buffers compared loading new configuration external memory 
organization cache varies architectures 
architectures implement cache external memory architectures distributed context memories 
example chameleon rcp cache holding configuration chip permits single cycle reconfiguration 
ffl memory organization computation performed reconfigurable logic needs access data memory 
intermediate results computations need stored logic reconfigured perform computation 
organization memory affects data access cost significant fraction actual execution time 
currently reconfigurable architectures include large memory reconfigurable logic device 
memory implemented large blocks memory virtex distributed memory blocks chameleon lsms 
reconfigurable architectures reconfigurable architectures evolved field programmable gate arrays fpgas 
currently large class fpgas available commercially 
various computing systems constructed integrating multiple fpgas dedicated memory 
systems couple general purpose microprocessor asic digital signal processor dsp fpgas 
alleviate communication memory access bottleneck configuration data systems integrating configurable logic chip microprocessor 
hybrid architectures distribute computations different components system 
give brief overview different classes architectures section 
field programmable gate array systems field programmable gate array consists array combinational logic blocks overlaid interconnection network wires see 
logic blocks interconnection network configurable 
configurability achieved anti fuse elements sram memory bits control configurations transistors 
anti fuse technology utilizes strong electric currents create connection terminals typically re programmable 
sram configuration reprogrammed fly downloading different configuration bits sram memory cells 
configuration sram interconnect fpga fpga fpga fpga memory memory memory memory multi fpga board logic block ff fpga lut fig 

typical fpga board device logic block architecture typical logic block architectures contain look table flip flop additional combinational logic sram memory cells control configuration logic block see 
logic blocks periphery device perform operations 
interconnection network reconfigured changing connections logic blocks wires configuring switch boxes connect different wires 
switch boxes interconnection network controlled sram memory cells 
functions computed logic block interconnection network blocks configured external data 
fpgas typically permit unlimited reconfiguration 
versatile devices build processors coprocessors internal architecture interconnections configured match needs application 
detailed architectural survey fpgas related systems see 
typically application requirements increase rate faster increase size logic resources fpga devices 
fpga architectures limits capability due limitation number pins device 
map large applications configurable logic various systems designed fpgas board 
architectures provide local memory dedicated programmable interconnect fpgas 
board level architectures usually designed function external controller board fpgas controller 
examples systems include experimental board splash commercial wild series annapolis microsystems 
software tools exist automatically partition design multiple fpgas board higher level abstractions 
detailed overview fpga devices multi fpga architectures see 
splash splash splash successor conceptually viewed system linear array processing elements 
architecture splash candidate systolic applications limited neighbor interconnect 
applications linear systolic possible utilizing crossbar interconnecting fpgas 
system consists board xilinx chips plus control arranged linear systolic array crossbar switch allows establishment limited number non linear communication channels 
chip bit connection nearest neighbors 
xilinx connected kb memory bit word size 
memory handle back back reads back back writes requires dead cycle changing write read 
boards daisy chained provide large linear systolic array elements 
system connected sparc processor system bus interface 
sparc processor acts host controls initialization configuration system 
splash extensively utilized system developing applications shown enormous speed traditional microprocessors supercomputers 
application domain usually restricted systolic array style computation applications satisfy criteria 
splash image processing motion detection dna sequence matching 
dna sequence matching splash achieved performance cray ii performance processor cm 
xilinx virtex virtex latest series high performance fpgas xilinx 
different versions capacities ranging system gates 
virtex architecture comprises array configurable logic blocks clbs encircled programmable blocks dedicated block memories bits 
interconnection network hierarchical routing matrix local routing varying number global routes different lengths 
single length routes routes length long lines spanning chip 
additional routing resources periphery logic blocks 
clbs contain logic cells 
logic cell input function generator look table lut flip flop carry logic 
luts operate function generators distributed rams 
additional multiplexors wires clb provide flexible combination different logic cell outputs routing input signals clb output 
high speed arithmetic facilitated providing additional carry logic logic cells 
dedicated gate logic cell improves multiplier implementations 
chip local memories realized virtex architecture different ways 
logic cells combined configured memory cells obtain ram required sized 
virtex large block memories 
organized vertical edges fpga 
memory block clbs high number blocks large size virtex chips clbs height 
memory cell fully synchronous dual ported bit ram independent control signals port independent data widths 
hybrid architectures configurable platforms shown impressive results typically configurable logic attached host system interface system bus channels 
systems shown significant speedups specific applications 
limiting factor case achieving higher performance applications delay communicating configurable logic 
delay results higher data transfer reconfiguration overheads 
currently systems try alleviate problem moving configurable logic processor die designed 
term architectures hybrid architectures 
various terms architectures including systems onchip soc configurable system chip reconfigurable systems chip systems programmable chip 
convergence hybrid architectures consider hybrid architectures concept chip containing multiple components defined actual chip 
fpga integrates multiple architectural components considered hybrid architecture chip reconfigurable logic programmable user 
discuss features hybrid architectures sections 
vary conceptual research architectures industrial implementations startup companies 
list architectures described supposed exhaustive just sampling large space hybrid architectures 
methodology implementing hybrid architectures experienced convergence 
commercial devices integrate programmable logic die processor 
fpga vendors aggressively approaching design space providing customized processor ip cores devices 
include platform fpga initiative xilinx powerpc cores altera excalibur offering 
xilinx platform fpga xilinx platform fpga evolution high capacity virtex series fpgas 
generations fpgas integrate embedded processors dsp functions high speed communication interfaces 
integration hard soft intellectual property ip cores permits hardware upgrades fly 
enabling technology platform fpgas virtex ii architecture 
expected scale system gates internal system clocks mhz 
virtex ii expected higher capacity configurable logic blocks larger size block ram distributed ram 
memory block sizes increased provide higher memory logic ratio facilitate memory rich data intensive application 
hybrid reconfigurable architecture platform fpga integrate hard cores addition available soft cores 
xilinx announced embedded powerpc microprocessor core ibm available hard core platform fpga 
powerpc core expected operate mhz communicate reconfigurable logic gb sec 
platform fpga integrates multiple bit multipliers virtex ii platform enable theoretical performance mac multiply accumulates second 
ability platform fpga integrate multiple aspects different architecture paradigms conventional processor dsp cores embedded memory peripheral interfaces bit memory bus bit pci bus reconfigurable processing fabric configuration subsystem dma subsystem arc processor memory controller pci controller pin programmable roadrunner bus fig 

chameleon processor rcp architecture virtex ii fpga provides flexible platform design development 
platform fpga design tools combine aspects embedded processor compilation electronic design automation eda real time operating systems rtos digital signal processing dsp 
chameleon systems reconfigurable communications processor chameleon reconfigurable communications processor rcp architecture consists bit embedded processor core bit reconfigurable processing fabric highspeed system bus programmable system 
processor interface memory processing systems pci controller memory dma controllers addition programmable different components linked bit split transaction high performance roadrunner bus provides gbyte sec chip communication bandwidth 
overview architecture 
rcp bit arc processor delivers mips mhz 
processor stage pipeline general purpose bit registers large set instructions 
instruction cache kbyte data cache 
reconfigurable processing fabric divided slices 
slice consists tiles independently reconfigured 
tile consists bit datapath units bit multipliers local store memories lsms control logic unit clu 
bit implements standard arithmetic operations specialized operations 
control logic unit clu store user specified instructions tile instruction represents complete configuration 
rcp background configuration plane loaded active plane executing 
rcp switch active background configuration just clock cycle nanoseconds facilitating single cycle context switch 
iii 
reconfigurable computing vision computations computer vision applications high performance requirements due processing large data sets heterogeneity application 
typically vision applications associated real time response requirements necessitate significant computation resources 
processing performed stages includes complex operations communication different tasks 
briefly outline application characteristics existing architectural approaches address performance requirements 
vision algorithms stages processing 
earlier stages focus manipulation images represented array pixels 
computations involved lowest level typically perform simple arithmetic pixel values 
operations composed diverse ways application 
operations performed pixels typically localized neighborhood pixels image 
operations performed pixels local neighborhood 
characteristic results applicability fine grain parallel processing application 
examples computations level include filtering edge detection edge segmentation 
stages vision processing data locality regularity described absent 
operations consist identifying processing symbolic information pixels related values locality 
pixels grouped data sets value pixel index array representation image 
computations stage pixel values possibly large number data sets 
reconfigurable computing exploit irregular parallelism level traditional fixed parallel architectures 
examples computations nature include object recognition tracking 
high performance requirements vision applications necessitated exploring options utilization general purpose microprocessors 
microprocessors sustain processing requirements vision applications due serial computation exploit nature vision computations 
efforts exploit parallel nature vision applications categorized high performance parallel computers cray cm ii parallel dataflow architectures systolic arrays iii vision vlsi processors 
large body literature covering different architectural approaches refer reader additional information 
reconfigurable computing demonstrated viable alternative approaches significant performance advantages 
applications mapped reconfigurable architectures 
applications include image filtering object recognition finger print matching stereo vision image compression automatic target recognition atr 
applications demonstrated superior performance reconfigurable architectures compared existing architecture paradigms 
facets vision computations excellent match mapping reconfigurable architectures 
highlight aspects vision computations corresponding features reconfigurable architectures contribute making reconfigurable architectures excellent choice mapping vision applications 
regular computations fine grain parallelism processing pixel locations image parallel mapped large number distributed functional units configurable architectures 
reconfigurable architectures including fpgas provide large number arithmetic functional units adequate registers 
parallelism pipelining vision tasks spatially mapped functional units registers reconfigurable architectures 
mapping provide superior performance compared mapping general purpose processors digital signal processors widely distributed computing units parallel machines 
fpgas implement bit serial circuits image processing area 
ffl example image filtering filtering operations neighborhood set pixels utilized adapt value pixel 
window neighborhood pixels applied pixels image 
large number pixels image local data dependency excellent match exploiting fine grain parallelism 
image divided value processed independently parallel 
mentioned contain examples orders magnitude speedup achieved reconfigurable computing 
irregular computations customized datapath absence regular repetitive computations vision applications operate image dataset subset dataset 
results finegrain arithmetic operations combined myriad ways generate required results vision tasks 
rich dynamic interconnect resources reconfigurable architectures permit construction customized datapath enables complex data flow vision applications 
distributed memory blocks reconfigurable architectures exploited synchronizing data flow mapping fifo memories intermediate storage memory 
ffl example model recognition model object recognition image searched set objects represented geometric features points lines 
innovative techniques geometric hashing significantly enhance detection objects image 
application inherently irregular due nature object representation 
illustration irregular application mapped reconfigurable architecture 
illustrative mapping applications reconfigurable hardware 
data size adaptive precision precision mapping image processing tasks precisely chosen reconfigurable architectures 
ability construct modules required precision key advantages reconfigurable hardware 
variable precision computations implemented static approach 
static approach precision operands operation fixed compile time different standard precision bit bit bit microprocessors 
reconfigurable architectures support dynamic precision ability hardware change precision run time response variant precision demands algorithm 
section describe dynamic precision variation technique detail discuss algorithmic optimization techniques 
ffl examples image compression automatic target recognition vision applications operating images large degree variation data size pixel values 
addition operations performed pixels require different size operands depending number pixel values process 
precision filtering operation processes window typically lower template matching algorithm accumulates set pixel values 
prior research explored range error image compression variation precision reconfigurable architecture compression 
section illustrate variable precision exploited algorithmically achieve high performance example computation template target recognition algorithm 
precision computations specified statically changed dynamically architectures support dynamic reconfiguration 
complete approach detailed 
potential performance benefits illustrate order magnitude performance benefits achieved reconfigurable architectures compared traditional architectures outline application mappings reconfigurable architectures ffl image processing image processing tasks filters histogram hough transform convolution image compression mapped system splash multi fpga board 
speedups ranging reported contemporary workstations 
ffl fft implementations fft years various architectures ranging board hybrid architectures 
complex datapath fft computation constructed interconnection resources reconfigurable architectures 
chameleon systems rcp implements point complex ffts twice fast state art ti dsps 
generation xilinx platform fpga expected run number ffts 
ffl fingerprint analysis analyzing fingerprints match database known fingerprint images presents consists complex control processing addition simple image arithmetic 
parallel algorithm implements fingerprint analysis splash architecture achieved speedup contemporary workstation implementation 
ffl video processing video processing tasks video compression stereo imaging motion estimation object tracking implemented reconfigurable architectures 
dec pam pamette reconfigurable systems achieve speedups tasks compared contemporary workstations parallel machines 
iv 
design challenges applications mapped reconfigurable architectures analyzing computations performed tasks 
computations speeded reconfigurable hardware identified mapped reconfigurable hardware 
presence microprocessor computations complex control data structures executed microprocessor 
partitioning computations application microprocessor reconfigurable hardware performed manually automatic semi automatic tools 
partitioned computations compiled executable code microprocessor hardware configurations reconfigurable hardware 
reconfigurable hardware needs configured configuration information actual execution performed 
configuration updated run time execute different set computations application 
development systematic scheduling mapping techniques computing architectures requires high level abstractions 
computing models high level abstractions architectures utilized develop algorithmic techniques mapping applications architectures 
reconfigurable computing different von neumann paradigm computing requires computational models different conventional models 
gives rise design crisis tools mapping applications reconfigurable architectures 
predicts changing paradigm wave illustrating technology trends semiconductors see 
outline challenges mapping vision applications reconfigurable architectures sections 
standardized customized standard diodes 
customized calculator tv memory microprocessor customized logic asic assp 
dynamic reconfiguration transistors clock procedural programming structural programming st design crisis nd design crisis year fig 

wave logic configure execute execute design configurations design configurations fig 

static configurable computing static vs dynamic reconfiguration utilizing fpgas speeding applications limited developing configurations optimize computation time task 
optimized configuration execute task 
process illustrated 
computational task analyzed optimized configuration developed computational task 
configurable logic device configured usually control host optimized configuration 
configuration executed initiating computation communicating data device 
programmability device exploited logic resources reused computation 
execute design configurations design logic configure configurations execute fig 

dynamic configurable computing conventional approach static hardware configured just followed execution 
concept dynamic configurable computing illustrated 
configurable resources reused reconfiguring hardware computation completed 
configuration logic interconnection network adapted fly execution 
run time reconfiguration intermediate results generated computations 
approach enormous opportunities achieve higher performance conventional approach closely adapting hardware nature computation 
design methodologies achieve high performance configurable architectures effective configuration design techniques need developed 
existing design methodologies asic design tools fail realize full potential configurable logic 
logic synthesis tools geared compiling hardware oblivious algorithm 
behavioral description algorithm mapped logic synthesis tools phases 
process structure algorithm utilized resulting sub optimal designs respect area delay performance 
design methodology incorporate input data knowledge configuration 
algorithm specific instance aware configurations key achieving large speed ups configurable architectures 
current design compilation times long preclude run time dynamic modification configurations 
existing designs lack modularity scalability low performance clock rates optimized hand 
major problem reconfigurable logic speed computation design process 
standard cad approach digital design typically employed 
required functionality specified high level abstraction hdl schematic 
logic libraries specific device xilinx fpga altera fpga chameleon component library time consuming placement routing steps required perform logic mapping 
approach logic synthesis opposed algorithm synthesis allows user specify design behavioral model 
abstraction achieved expense performance 
semantics nature algorithm lost mapping phases 
multi dimensional optimization configurable architectures possess multi dimensional characteristics diverse systems microprocessors digital signal processors integrated multi component architectures 
constraint space dictates optimization process illustrated 
addition traditional dimensional space architectural application constraints reconfigurable architectures dynamic adaptation constraints 
application constraints deal type applications tasks dependency tasks 
example loop computations constraints include structure loops dependencies inside loop loop carried dependencies 
architectural constraints include granularity functional units structure functional units performance characteristics 
reconfigurable architectures additional factor adaptation constraints affects optimization process 
method reconfiguration partial reconfiguration reconfiguration caches reconfiguration overheads need incorporated optimization process 
algorithmic mapping techniques developed include variables costs multiple dimensions 
application constraints architecture constraints adaptation constraints conventional optimization space fig 

constraint space optimization reconfigurable architectures design tools complex systems chip evolved due various technological application market forces 
design methodologies developed reaction evolution hybrid architectures 
design tools developed evolution hybrid architectures evolved architectures 
current design processes independent design flow architectural component 
programming models design tools individual components utilized map application 
integration performed stage 
standard interface different components hybrid architecture integration exists design phase 
independently developed hdl code compiled synthesized linked late compilation phase 
development activities aspect separate fixed application programmer interface api 
tools need developed formal framework lies foundation design efforts stage development 
reconfigurable computing model mapping algorithms efficient mapping vision applications reconfigurable hardware requires algorithmic techniques exploit unique features reconfigurable hardware 
complexity low level reconfigurable hardware features applications infeasible explore direct mapping application actual hardware 
semantic gap application description hardware architecture abilities 
abstraction application hardware architecture needed bridge semantic gap 
chapter develop hybrid system architecture model mathematical design processes methodologies tools refer aspects developing applications hybrid architecture designing architecture 
abstraction applications tasks reconfigurable hardware features 
high level model reconfigurable hardware needed low level details 
existing models supplied cad tools multiple abstraction layers device specific 
parameterized model configurable computing system consists configurable logic attached traditional microprocessor 
model utilized developing actual mapping scheduling tasks configurable system 
model clearly partitions capabilities hardware implementations 
model consists complementary aspects 
declarative aspect generative aspect 
similar automata declarative aspect model specifies parameterized model hybrid architecture 
forms foundation algorithmic analysis 
generative aspect specifies declarative aspect evolve set generative functions 
evolution model defines rule transformation parameters model generative function 
describe model configurable architectures discuss components model actual features configurable architectures 
generative aspect model elaborated 
hybrid system architecture model hybrid system architecture model general model consisting von neumann style processor cpu microprocessor embedded processor additional configurable logic unit clu 
shows architecture model 
architecture consists traditional processor standard memory configurable logic configuration memory communicating interconnection network 
model consists complementary aspects 
declarative aspect generative aspect 
declarative aspect model specifies parameterized model hybrid architecture 
forms foundation algorithmic analysis 
generative aspect specifies ways declarative aspect evolve set generative functions 
evolution model rule transformation parameters model generative function 
model partitions capabilities hardware implementations presents formal interface algorithmic optimization 
model abstracts actual implementation choices components model 
interconnection network implementing wide variety choices 
bus architecture dedicated connection various modules 
example realization model shown 
configurable logic consists matrix size theta logic units 
granularity logic granularity individual functional unit 
example fpgas chameleon rcp datapath 
configurations executing function composed configurations individual functional units active configuration 
functional unit configured perform operation set basic operations 
functions configurations input system application executed hybrid system architecture 
input application partitioned tasks executed cpu configurable logic unit 
applications tasks executed decomposed sequence clu functions 
configuration denotes specific structure arrangement configurable logic functionality 
configuration describes state basic functional units architecture 
uninitialized state clu denoted execution function cpu represented execution special configuration cpu functions configurations relationship 
configuration potentially contain function example configuration contain addition logical 
execution cost function configuration specified attributes set ij function executed configuration subset configurations 
different configurations potentially generated different tools libraries algorithms 
configurations different area time reconfiguration precision power characteristics 
example possible design multipliers various area time characteristics choosing various degrees pipelining carry look ahead techniques 
multiplier implementation different values area pipeline stages cycle time number cycles finishing computation 
similarly fixed point operation configurations designed various degrees precision 
configuration required executing specific function generated compile time fly runtime 
compile time configurations generated schematic techniques cad mapping tools dynamic pipeline generation component libraries 
runtime configurations generated runtime parameterized circuits dynamic modification configuration information loading configuration 
attributes model associates parameters function configuration pair called attributes 
attributes define relationships function configuration contain parameters computation costs data access costs terms amount data accessed 
costs translated actual timing costs register memory bus access costs 
attributes extended include interconnection network logic unit configurable configuration cache cpu memory cpu memory logic configuration cache unit bus configurable chip fig 

hybrid system architecture model example architecture table model parameters definitions parameter definition set functions fn capabilities set possible configurations cm clu implementations ij set attributes function configuration ij reconfiguration cost set generators transform configurations bandwidth interconnection network bytes cycle size configuration cache gamma access cost configuration data cache memory respectively gamma access cost data chip external memory respectively amount chip data memory granularity configurable logic functional unit width depth units clu additional variables reflect optimization criteria power area 
define attributes utilized algorithms thesis 
attributes matrix ffl execution latency execution time function configuration ffl ae execution throughput data rate function configuration ffl precision operands 
depending context precision sum bit widths operands vector representing individual bit widths input output operands 
ffl fi fi input output data bandwidth required 
overhead required data communication absorbed parameter 
precision number samples required determines fi fi parameters conjunction data access costs gamma define total input output data access cost executing function configuration reconfiguration configuration cache execute different task logic needs reconfigured execute different configuration 
assume denotes null configuration configurable logic initialized 
denotes time configure logic configuration initial state 
ij denotes cost changing configuration possible reduce reconfiguration overhead exploiting partial dynamic reconfiguration cost 
configuration cache capacity hold configurations 
cost accessing cached configuration data cycles byte cost accessing configuration data cache gamma cycles byte 
generative aspect generator composition function theta abstracts process composition configurations generate configurations 
physical process constructing reconfigurable computing solutions abstracted generators 
generators class functions define various forms composition 
range generator function superset potentially includes new configurations generated transformation 
generator defines composition function describes attributes transformed composition 
fg definition function fg depends specific generator utilized composition 
composition functions evaluated feasibility constraints imposed parameters available resources logic area time memory 
generators utilized recursively compose larger configurations 
exhaustively describe possible set generator functions give examples fundamental compositions illustrate concept 
transformation functions attributes generated configurations defined 
ffl parallel par generator abstracts execution configuration parallel clu 
resulting configuration execute multiple functions concurrently 
generator compose multiple versions configurations achieve parallelization compose different configurations 
mapping function attributes specified par max ae ae ae fi fi fi fi fi fi ffl serial ser generator simply composes larger configurations different configurations connecting 
computation configuration data communicated subsequent configurations 
delay configurations accumulated 
ser ae ae ae fi fi fi fi ffl pipelining pipe process constructing design pipelining data set configurations abstracted generator 
configurations executing concurrently operating data items configurations set 
configuration clu receives input external source memory processor configuration communicates data external source 
data stored configurations clocked memory elements registers 
pipe ae min ae ae fi fi fi fi algorithmic mapping techniques fig 

execution model basic generators define fundamental compositions 
recursive application generators utilized generate large class configurations applications basic configurations 
reconfiguration cost reconfiguration cost matrix additional configurations specified generator functions 
composition functions define arithmetic reconfiguration cost 
general expression approximate reconfiguration cost computation generators min gamma different terms min pertain cases reconfiguration costs different pairs partial reconfiguration 
additional factor third term considers fact terms expression contribute twice configuration cost specific reconfiguration cost different configurations generated recursive application generators computed equation defined reconfiguration cost 
execution model input system application executed reconfigurable hybrid system architecture 
input application partitioned tasks executed cpu configurable logic unit 
applications tasks executed decomposed sequence clu functions 
representation complete application task graph functions nodes edges representing precedence constraints 
task dependent control data dependency indicated edge labeled input output bandwidth fi fi tasks related edge 
maxq lt maxq maxq maxq scale fig 

example code pseudo fortran sequence tasks mapped sequence configurations oe oe oe oe oe 
note possible configuration repeat sequence possibly sequential tasks oe oe 
algorithmic optimization techniques utilized arrive optimal sequence configurations 
tasks executed cpu clu 
execution function clu involves loading configuration clu communicating required data clu 
executing configuration execute different configuration clu reconfigured takes ij time 
total execution time time spent executing configuration time spent reconfiguration executions 
example mapping algorithm section illustrate model utilized develop algorithmic techniques map applications reconfigurable architectures 
shows segment image processing code computes sum pixel values 
input pixel values diff bit precision 
execution progresses pixel sums accumulated precision required storing sum increases 
increasing precision affects precision required computations utilize code 
reconfigurable architectures computation structure dynamically adapted match precision required accurate computations 
section outline dynamic precision variation computation exploited model algorithmic approach map applications optimally reconfigurable architectures 
outline problem definition dynamic programming solution problem 
detailed proofs assumptions refer 
precision variation curve required precision computations loop expressed variation precision iterations loop progress 
introduce concept precision variation curve represent variation 
precision variation curve operations operands loop identified theoretical analysis 
definition precision variation curve operation operand loop computation represented sequence oe 
denotes iteration number change precision takes place iteration number precision variation curve theoretical fig 

precision variation curves due computation 
total number iterations 
oe denotes precision required performing iterations gamma oe denotes precision required performing iterations example precision variation curve shown 
theoretically determine precision variation curve operations computation 
precision computed variables loop determined precision variables iteration number iterations operations performed variable 
precision variation curve loop need determine mapping iterations set configurations execute operations loop 
iteration precision corresponding configuration executes iteration equal greater required precision iteration 
reconfiguring hardware required precision changes result significant reconfiguration overheads 
architectures reconfiguration times higher execution times reconfiguration overhead prohibitive 
necessary identify optimal set configurations result minimization execution cost including reconfiguration cost 
set configurations available executing operation encompass possible precision values required 
operations executed precision necessary absence configurations exact precision 
precision management problem pmp input operation loop iterations loop body precision variation curve operation 
precision variation curve operation operand loop computation sequence oe 
denotes iteration number change precision takes place due computation 
total number iterations 
oe denotes precision required performing iterations gamma oe denotes precision required performing iterations output optimal schedule configurations oe oe 
oe con figuration iterations gamma oe configuration iterations schedule oe said valid satisfies precision requirement iterations loop oe oe optimal schedule minimum total execution cost includes reconfiguration cost valid schedules 
cost schedule gamma theta oe gamma oe time executing iteration loop configuration oe gamma reconfiguration cost configurations oe gamma oe minimize total execution cost execution cost reconfiguration cost examined 
set configurations schedule reconfigurations need determined 
show points reconfiguration subset points required precision changes fj lemma definitions pmp problem schedule oe configurations satisfies property determine choice configuration greedy approach best configuration required precision chosen best configuration oe oe cm configuration lowest execution cost oe greedy algorithm provide optimal solution illustrated results 
dynamic precision management algorithm precision management problem lemma dynamic programming solve problem 
configuration optimal schedule changes required precision changes lemma 
define task executing iterations gamma 
task definitions set configurations different precisions dynamic programming compute optimal schedule 
dynamic programming compute ij values schedule oe 
computing ij value takes time configurations 
total number values computed total time complexity algorithm 
theorem optimal schedule oe pmp problem computed time number points precision variation curve number configurations set table ii model parameters xc multiplier configurations configuration precision time 
ns ns theta theta theta theta theta theta experimental results abstracted xilinx xc series device model 
parameters specified model evaluated xc documentation 
footprint precision equation theta row theta col row col precisions inputs 
configurations relevant mapping operation row 
reconfiguration times bit data bus running mhz 
possible design modular configurations reconfigured lesser time partial reconfiguration 
mapping assumed complete reconfiguration needed configuration 
parameters various multiplier configurations different precisions listed table ii 
measured total execution time loop computations different approaches 
approaches exploit dynamic precision varying precision operation run time 
different approaches schedule configurations oe approach described 
ffl raw approach uses static configuration bit theta bit precision iterations loop 
schedule ffl static utilize theoretical analysis determine highest precision required iterations bit theta bit 
configuration static iterations 
schedule ffl greedy greedy algorithm compute schedule configurations utilized computations 
precision operation varied dynamically greedy choice lowest execution time configuration 
schedule ffl dynamic precision management algorithm utilized compute optimal schedule precision variation curve 
approach uses higher execution cost configurations computations reduces execution cost performing lesser number reconfigurations 
schedule execution times including reconfiguration times summarized table iii 
approaches dy table iii execution times different approaches algorithm execution reconfiguration total time ns time ns ns raw static greedy namic precision achieve significantly lower execution times compared raw static approaches 
noticed algorithm executed iterations loop minimum time theoretical precision variation curves 
vi 
reading reconfigurable computing new paradigm promises higher performance superior flexibility compared traditional computing 
vision applications computation characteristics match advantages reconfigurable computing 
provided broad different facets reconfigurable computing 
distinguishing characteristics reconfigurable computing outlined classification example architectures 
characteristics vision applications exploited reconfigurable architectures deliver superior performance compared traditional architectures outlined 
challenges efficiently exploiting architectures deliver high performance described 
algorithmic mapping applications architecture independent fashion provide framework automatic compilation applications 
provide model reconfigurable architectures serve abstraction underlying hardware 
abstraction utilized develop architecture independent algorithmic mapping techniques 
algorithms general hybrid system architecture model 
parameterized model captures wide range configurable systems 
precision variation customizations provided configurable hardware loop computations 
develop framework dynamic precision management loop computations image processing applications reconfigurable architectures 
similar algorithmic techniques model mapping approach provide significant directions overcoming challenges mapping vision applications reconfigurable architectures 
topics highlight different aspects reconfigurable computing research addressing past years 
list cites resources exploring different research directions intended exhaustive definitive list 
ffl architectures device system architectures developed propose various ways organizing interfacing configurable logic 
architectures coarse grain functional units configured fly execute operation set operations 
commercial architectures exploring integration reconfigurable logic microprocessors chip 
ffl theoretical models various theoretical models proposed including reconfigurable mesh mentioned article 
ffl applications specialized configurable architectures utilized speeding specific applications replacing asics 
applications exploit optimization specific input instance computation 
ffl algorithmic synthesis dynamically reconfigurable architectures give rise new classes problems mapping computations architectures 
new algorithmic techniques needed schedule computations 
existing algorithmic mapping techniques focus primarily loops general purpose programs 
loop structures provide repetitive computations scope pipelining parallelization candidates mapping reconfigurable hardware 
ffl software tools current software tools rely cad mapping techniques 
tools developed address run time reconfiguration compilation high level languages simulation dynamically reconfigurable logic software complete operating system dynamically reconfigurable platforms 
rose el gamal sangiovanni vincentelli architecture field programmable gate arrays proceedings ieee july 
semiconductor industry association www org modeling mapping dynamically reconfigurable hybrid architectures ph thesis university southern california may 
prasanna reconfigurable computing architectures models algorithms current science vol 
pp 
april 
hauck roles fpgas programmable systems proceedings ieee vol 
april 
quick safari reconfiguration jungle th design automation conference june 
master lane powering mpeg video communication systems design january 
buell arnold splash fpgas custom computing machine ieee computer society press 
athanas silverman processor reconfiguration instruction set metamorphosis ieee computer vol 
pp 
march 
hauser wawrzynek garp mips processor reconfigurable coprocessor ieee symposium fpgas custom computing machines april pp 

chameleon systems www com dehon reconfigurable architectures general purpose computing ph thesis mit ai lab september 
design implementation context switching fpga ieee symposium custom computing machines april 
mei prasanna genetic programming self reconfigurable fpgas international workshop field programmable logic applications september 
xilinx xc field programmable gate arrays 
xilinx www xilinx com virtex series fpgas 
brown rose fpga architectures tutorial ieee design test computers summer 
vuillemin bertin shand touati programmable active memories reconfigurable systems come age ieee transactions vlsi systems vol 
pp 
march 
carter snider configurable custom computing ieee symposium fpgas custom computing machines april pp 

annapolis microsystems www com tessier babb agarwal virtual wires overcoming pin limitations fpga logic emulators ieee workshop fpgas custom computing machines april 
www com xilinx www xilinx com xilinx platform fpgas 
altera soft core embedded processor www altera com html products html wang bhat prasanna high performance computing vision proceedings ieee july 
prasanna kumar ed parallel algorithms architectures image understanding academic press 
vision chips www caltech edu athanas abbott real time image processing custom computing platform ieee computer pp 
february 
choi prasanna configurable hardware symbolic search operations international conference parallel distributed systems dec 
prasanna fast parallel implementation dft configurable devices th international workshop field programmable logic applications sept 
petersen hutchings assessment suitability fpga systems digital signal processing th international workshop field programmable logic applications 
rashid leonard mangione smith dynamic circuit generation solving specific problem instances boolean satisfiability ieee symposium fpgas custom computing machines april 
shirazi athanas abbott implementation fast fourier transform fpga custom computing machine international workshop logic applications 
woodfill von herzen real time stereo vision parts reconfigurable computer ieee symposium fpgas custom computing machines april 
parallelization dsp nested loops reconfigurable architectures data context switching design automation conference dac june 
chung choi prasanna parallel object recognition fpga configurable platform international workshop computer aided machine perception oct 
bins draper bohm precision vs error jpeg compression parallel distributed methods image processing iii spie july 
prasanna dynamic precision management loop computations reconfigurable architectures ieee symposium fpgas custom computing machines april 
xilinx dsp application notes fastest fft west www xilinx com apps htm levi run time parameterizable cores acm international symposium field programmable gate arrays february 
xilinx application notes fast constant coefficient multiplier xc bittner athanas wormhole run time reconfiguration acm international symposium field programmable gate arrays february pp 

goldstein schmit thomas managing pipeline reconfigurable fpgas proceedings acm sigda sixth international symposium field programmable gate arrays february 
ebeling franklin rapid reconfigurable pipelined datapath th international workshop field programmable logic applications 
kress hartenstein operating system custom computing machines paradigm th international workshop logic applications sept pp 

taylor sarkar lee lee kim frank finch barua babb amarasinghe agarwal software raw machines ieee computer pp 
september 
virtual hardware operating system xilinx xc international workshop logic applications september 
miller prasanna kumar stout parallel computations reconfigurable meshes ieee trans 
computers july 
homepage usc edu homepage usc edu zhong martonosi sharad malik solving boolean satisfiability dynamic hardware configurations international workshop field programmable logic september 
babb frank agarwal solving graph problems dynamic computation structures spie photonics east reconfigurable technology rapid product development computing november 
prasanna mapping loops reconfigurable architectures th international workshop field programmable logic applications september 
prasanna loop pipelining optimization reconfigurable architectures reconfigurable architectures workshop raw may 
callahan wawrzynek instruction level parallelism reconfigurable computing international workshop field programmable logic september 
chang marek partitioning sequential circuits dynamically reconfigurable fpgas ieee transactions computers june 
mei prasanna domain specific mapping solving graph problems reconfigurable devices reconfigurable architectures workshop april 
lawrence kay luk page reconfigurable hardware speed product development performance th international workshop logic applications 
luk shirazi guo cheung pipeline morphing virtual pipelines th international workshop field programmable logic applications sept 
payne run time parameterised circuits xilinx xc th international workshop logic applications sept pp 

bhatia temporal partitioning scheduling data flow graphs reconfigurable computers ieee transactions computers june 
subramanian pande automatic analysis loops exploit operator parallelism reconfigurable systems languages compilers parallel computing august 
compilation pipeline synthesis reconfigurable architectures reconfigurable architectures workshop raw 
april verlag 
hutchings improving functional density run time constant propagation acm international symposium field programmable gate arrays february pp 

hutchings hdl reconfigurable systems ieee symposium field programmable custom computing machines april 
duncan hall jain ziegler defacto design environment adaptive computing technology reconfigurable architectures workshop raw april 
prasanna drive interpretive simulation visualization environment dynamically reconfigurable systems international workshop logic applications september 
programmable logic synthesis strive get sync computer design august 
gokhale marks automatic synthesis parallel programs targeted dynamically reconfigurable logic arrays proceedings international workshop field programmable logic applications oxford england september 
simulation tool dynamically reconfigurable fpgas ieee transactions vlsi systems sept 
received tech 
computer science engineering indian institute technology delhi ph computer university southern california 
research interests include reconfigurable computing computer architecture systems engineering 
member eta kappa nu upsilon pi epsilon 
currently senior design engineer advanced micro devices viktor prasanna prasanna kumar received bs electronics engineering bangalore university ms school automation indian institute science 
obtained ph computer science pennsylvania state university 
currently professor department electrical engineering department computer science university southern california los angeles 
associate member center applied mathematical sciences usc 
served division director computer 
research interests include parallel computation computer architecture vlsi computations high performance computing signal image processing vision 
dr prasanna published extensively consulted industries areas 
served organizing committees international meetings vlsi computations parallel computation high performance computing 
steering chair international parallel distributed processing symposium merged ieee international parallel processing symposium ipps symposium parallel distributed processing spdp steering chair international conference high performance computing 
serves editorial boards journal parallel distributed computing ieee transactions parallel distributed systems proceedings ieee 
founding chair ieee computer society technical committee parallel processing 
fellow ieee 
