electronic notes theoretical computer science url www elsevier nl locate entcs volume html pages programmable type systems domain speci languages peter thiemann institut ur informatik universit freiburg georges freiburg germany language programmable type system vital construction embedded domain speci language 
driven requirements posed implementation server side web scripting examine major extensions type system host language haskell 
show component ensures generation correct html documents take advantage type level functions implemented functional logic overloading 
show function ensures consistency data submitted web script data expected script awkward presence lambda expressions type language 
cases assess guarantees obtained typing explore alternative solutions 
domain speci languages dsls addressing programming needs particular domains 
intended address solve problems domain terms concepts domain 
improve productivity domain experts need programming experts 
dsls limited user community time spent development implementation carefully weighted productivity gain users 
reason popular way implementing dsl embed general purpose programming language host language 
particular functional programming languages proven host languages orthogonal abstraction facilities email thiemann informatik uni freiburg de completed stay oregon health science university supported 
published elsevier science thiemann advanced type systems 
advantage embedding approach dsl easily extensible customizable particular problem instances 
turns type system asset drawback time 
possible express number domain concepts type language resulting typings far natural typing requirements force particular programming style 
programming conventions hard motivate users host language particular lead incomprehensible error messages type checker 
point domain expert needs programming languages expert decipher compiler utterances 
striving identify better ways integrate domain concepts type language context functional programming language haskell 
develop motivating example drawn dsl web scripting 
guided example show viable way extending type languages installing rst order functional logic programming language type level 
idea term rewriting system type level captures domain speci concepts execution machinery functional logic programming narrowing residuation foundation type inference procedure 
ideally semantics term rewriting system type level coincides semantics programming language value level allowing lift value level functions type level changing semantics 
underlying theory builds hm type inference framework 
step addition lambda expressions type level 
step driven practical needs application domain express problems simplest natural possible way 
exhibit problem haskell solution leads programs hard explain understand 
discuss solution lambda abstractions type language 
leads fairly natural programs 
explore alternative api motivating example show requires facilities generic programming 
assess properties achieve typing re ne rank types 
assume familiarity functional programming language haskell 
wash wash web application services haskell collection domain speci languages designing implementing web services 
language embedded haskell available form haskell library 
idea languages may mixed matched needs application development 
thiemann important parts wash wash html wash cgi 
rst part wash html deals generation html xml documents wash cgi provides convenient api web scripting 
distinctive feature wash html fact document generators programmed wash html guaranteed generate formed large extent valid html pages subject condition generator program type correct 
wash cgi provides simple callback programming model server side web scripting hiding tedious details communication browser server 
employs type system guarantee consistency forms submitted browser program processes forms 
type checking html generators section consider problem guaranteeing program generates correct xhtml just type checking program 
discussing design released version wash html consider easily adaptable solution relies heavily computation place type checker compile time 
web pages generated scripts running web servers 
widely recognized problem pages violate standard xhtml 
standard requires documents formed valid respect xhtml document type de nition dtd 
formed document opening closing tags properly nested document really rendition labeled attributed tree 
main kind node tree called element label element provides name re ected opening closing tag 
validity states restrictions imposed dtd met 
dtd basically associates element name regular expression element names 
formed document valid element named sequence names subelements accepted regular expression associated dtd 
example dtd xhtml states element named dl may non empty sequence elements named dt dd subelements 
guaranteeing formedness main reason generated web pages formed inadequate programming interface generation 
quite pages generated sequences print statements 
programmer easily looses track stack open tags 
consequence thiemann close elements open obscured elements opened closed 
approach avoid problems build internal tree representation document rst 
entire document tree constructed single traversal document serializes xhtml syntax 
generator library provide operations build internal tree 
wash html provides element combinator haskell function name element 
combinator simply build new element 
transforms existing parent element attaching new element sequence subelements 
likewise just accept sequence subelements takes argument transformer function may add subelements attributes 
example show preliminary typing element combinator 
dt element element element element argument function transforms dt element attaching subelements attributes resulting function transformer adds dt element parent 
approach attractive number reasons 
kinds nodes elements attributes treated uniformly 
second obtain notion sequence elements attributes free composing transformation functions 
guaranteeing validity guarantee validity propose enhance typing element combinators 
need keep track element names checking validity rst step element names available type level 
library provides element name data type name subject name syntactical restrictions imposed haskell 
example type dt tag dt de nition follows 
data dt dt data type observable value dt 
call types singleton types types called type theory 
idea parameterize element type phantom type ranges singleton types 
yields potential typing dt combinator dt element dt element dt element parent element parent identi er dt name type left side name data constant right side 
thiemann typing place things remain done 
type parent arbitrary 
dtd allows dt elements subelements dl elements want replace parent dl 
approach general may number di erent admissible parent elements 
fortunately kind restriction modeled standard haskell type class 
element name introduce type class encompasses exactly set element types admit child elements named example dt element gives rise class class parent dt element dt element dt element parent element parent instance dl example instance element name admits dt element child general may element names admissible parents 
perfect sense point typing api partial validity guarantee 
typing rules majority errors regular expressions xhtml dtd form jn exactly type classes achieve 
strengthening typing constraints library signi cantly harder 
second sequence subelements arbitrary 
shifting focus attention back dl element subelements form non empty sequence dd dt elements typing prevent attempt add empty dl element parent 
library implemented take approach 
xhtml element name construct nite automaton compiling associated regular expression dtd standard techniques 
element type receives phantom type parameter ranges states nite automaton 
type dt combinator re ned class parent dt state parent pstate pstate element dt state element dt state element parent pstate element parent pstate type haskell type class characterizes set nal states automaton associated dt 
parent pstate pstate implements transition function automaton simpli earlier version wash html required parameter type class purpose 
thiemann application parameter type class widely implemented haskell extension parent name parent element pstate state parent element automaton reading dt pstate state automaton reading dt 
type state stands initial state automaton associated element dt 
avoid problems ambiguity advantageous haskell extension functional dependencies 
brie put declaring functional dependency parent pstate pstate allows type checker treat function maps parent pstate pstate 
approach viable exhibits number drawbacks 
particular dtd compiled library classes transition functions hard extend library solution exible 
point relation place functional formulation easier understand 
validity functional logic overloading propose encode transition function functional logic overloading 
main idea framework allow functions types type inference engine deal evaluation functions compile time 
variables types type inference logical variables places type inference engine setting functional logic programming 
turn enables known established implementation techniques programming languages implementation type checker 
approach proceed follows 
regular expressions nite automata type structure take idea derivatives regular expressions avoid explicit construction nite automaton 
brzozowski shows starting regular expression input symbol possible compute regular expression derivative fw aw iterating construction yields nite set regular expressions closed derivatives 
set regarded set states nite automaton transition function 
nal states regular expressions recognize empty word 
straightforward exercise code function function checking regular expression recognizes empty word haskell 
quite involved task lift implementation type level functions particular just multi parameter type classes functional dependencies hand 
example simple line de nition equals function input symbols surprisingly awkward transcription type level 
functional logic overloading code need rewritten line de nition reused type level 
thiemann execution engine guarantees semantics code type level semantics value level 
example look respective version typing dl involves regular expression dt dd 
encoded plus union atom dt atom dd plus type constructor corresponding operator union corresponds operator atom maps element alphabet regular expression 
class parent dl state element dl plus union atom dt atom dd element dl state element parent pstate element parent delta pstate dl due shift relational point view functional spurious pstate variable disappears functionality delta immediately obvious 
furthermore delta depend parent anymore regular expression pstate contains necessary information 
type checking web scripts developer web application faced number problems 
due stateless nature underlying protocol application split scripts script corresponds states interaction user 
developer ensure dangling interactions means user submits answer called form web server script installed server ready process answer 
property quite fragile ected accidental renaming deletion script improper installation 
addition submitted form contain information script wishes process script asks particular eld form eld 
wash cgi library ensures requirements 
entire interaction programmed single program installed 
wash cgi library automatically keeps track state interaction requiring attention programmer 
programmer just attaches callback actions submit buttons form specify ow control inside application 
problem dangling interactions completely avoided 
second elds form referred name wash cgi script 
wash cgi script creates input eld obtains typed handle eld 
initially handle invalid possible extract value 
fair dependency removed relational case incorporating name parent state 
thiemann handle passed submission mechanism callback actions 
submission mechanism typechecks handle rejects improper malformed form submissions user repeat submission error detected 
checking handle submission mechanism passes validated handle callback action 
callback action extract handle value fully type safe way 
course handles processed manner 
take deeper look mechanism validate submissions 
discuss standard haskell solution implemented wash cgi 
second show alternative solution improves haskell solution avoiding inconvenience 
third consider possible typings submission functions discuss merits 
assess entire validation mechanism 
submission validation haskell creation new widget text input eld button selection box returns handle value widget 
initially handle invalid value accessed 
example function creates text input eld typing inputfield string invalid inputfield string invalid type widget handle 
phantom type invalid indicates handle validated function extracts value handle applied handle value inputfield valid invalid valid instance singleton type 
validation input handle takes place submission form 
re ected type submission action submit inputhandle invalid valid cgi function submit overloaded type widget 
takes invalid widget type invalid rst argument callback action type valid cgi second argument produce 
callback action parameterized validated widget type valid 
change type widget requires overloading simply performed type widget type constructor abstracts widget type valid invalid type argument 
typing value simpli ed 
implementation value overloaded di erent types handles just inputfield 
thiemann unfortunately arrangement catch 
suppose form contains input widgets callback action process 
situation handles widgets type inputfield string invalid easy pass handles callback straightforward pass 
simply pairing yields value type inputfield string invalid inputfield string invalid type form invalid 
course problem reappears arbitrary tuples handles lists handles 
case resulting type form required type submit 
turns newly introduced data types save day 
data constructor handles lifted version de ned 
example data de nes datatype lifted pairs data fl fl de nes datatype fl lifted lists 
applying lifted pairing constructor input handles yields value type inputfield string inputfield string invalid form invalid inputfield string inputfield string suitable rst argument submit 
fl acceptable input handles need members class inputhandle instance inputhandle inputhandle fl instance inputhandle inputhandle inputhandle 
case want submit data notorious continue button needs lifted data clearly invalid required form invalid instance instance inputhandle 
thiemann alternative approach higher order uni cation problem haskell solution outlined subsection precisely spurious data constructors fl 
quite hard explain non expert haskell programmers simply build arbitrary data structure containing handles 
fact fl really artifacts caused weakness type system natural just standard pair list type constructors 
reason sought ways get rid artifacts 
getting back type pair input handles inputfield string invalid inputfield string invalid see type uni ed invalid considering higher order uni cation problem 
limiting substituting constructor terms uni cation allow certain lambda terms 
example substitution maps inputfield string inputfield string job 
known higher order uni cation undecidable problem high degree non determinism full blown higher order uni cation type inferencer advisable 
particular analysis shows examples constructed huet higher order uni cation procedure yields di erent solutions solution sense example 
unfortunately standard procedure extended pick acceptable solution automatically information derived uni cation problem information 
reason restricted higher order uni cation guided higher order uni cation set lambda terms restricted substitution selected uni cation procedure guided set substitutions supplied separately 
particular substitutions generated huet higher order uni cation procedure general substitutions form 
xm xm xm free variable substituted newly introduced free variables constant bound variable xm 
substitutions generated equations kind ex rigid head symbol side free variable head symbol side constant 
guided higher order uni cation general substitutions rely substitutions supplied programmer 
interested applying presence overloading tie speci cation substitution instance declaration particular type class 
example case inputhandle class considered context submit function supply instance declaration thiemann instance inputhandle inputhandle inputhandle ect declaration attempting unify inputhandle invalid inputfield string invalid inputfield string invalid know inputhandle hold typical situation type checking application submit pair handles type checker applies substitution obtain inputhandle inputhandle invalid invalid inputfield string invalid inputfield string invalid easily reduced standard decomposition steps rst order uni cation solution inputfield string inputfield string satis es constraints 
alternative api submission validation step back consider api validated form submission changed ways simplify problems implementor user library 
clear callback actions see widget handlers 
submit function extract values handlers validation just pass directly callback 
simplify somewhat looking type handle hdl 
hdl cgi typing works case handle problems pairs lists handles aggravate 
review types submit cases case handle continue button cgi hdl hdl cgi hdl cgi comparing types looks type argument callback action function type handle 
function sh just strips away handles 
resulting type sh cgi sh satisfy equations sh hdl thiemann sh sh sh sh sh sh concisely de ne sh sh sh sh sh stands hdl constant arbitrary kind constructor variables 
furthermore restrict range polynomial data constructors contain function types 
restriction simplify development required application 
point validation function perform duty place invoked 
data structure contained functions processed returned handles validation function best coerce functions functions perform required checks 
potential delay intent validation 
remains determine transformation sh induces values type simplicity rst construct function type sh consider actual validation function 
fortunately recursive de nition sh type level follows pattern polytypic programming de ned hinze 
just need de ne function hdl set remaining cases fall back de nition generic identity function 
remaining base types ix ix case inl inl ix inl inl ix reality function validate typing validate hdl string returns value error message takes form list strings 
clearly string monad particulars error handling mechanism assuming thiemann expressed monad 
remains de ne function propagates function type process monad hdl value contain hdls 
generic de nition ph process handles ph monad sh process return return remaining base types ix ix return case inl ix return inl inl ix return inr beauty hinze approach de nition extends automatically kinds programming 
unfortunately theory allow overloading base case required de nition 
alternatively version limited rst order kinds readily implemented functional logic overloading 
task considerably tedious specialize cases sum product type manually data type wrapped handles 
restricting scope widget handles return investment typing submission primitive 
course gain lot programming convenience input widgets explicit names problems inconsistencies due widget names disappear communication browser script typed errors due invalid entries input elds caught system programmer intervention 
pressing concern remains 
caused mismatch lexical scope widget handle handle actual lifetime 
handle actual lifetime starts creation handle context thiemann ask submit empty ask submit action empty fig 

skeleton erroneous wash cgi script particular web page ends callback action associated web page starts construct response page 
corresponds interaction cycle delivering form browser processing answer constructing form 
checkpoints easily program looking combinator ask starts construction new form 
actual lifetime corresponds part program text 
understand importance actual lifetime need bit information implementation widgets 
input eld form widget constructor executed multiple times di erent modes 
initially constructor function builds internal representation widget html element 
form input data submitted constructor function executes time picks input corresponding widget stores handle 
time builds part error page case submission validated 
submit function activated tries validate handles passed 
process successful passes control callback action 
handles validated sends error page containing form back browser user reenter data 
convenience form widgets validate marked visually widgets initialized values previously entered 
problem follows 
suppose action keeps invalid handle free variable passes submit function subsequent interaction 
entry validates problem program continues intended 
submit form 
form erroneous entry error corrected back button guesswork 
gives example behavior 
rst web page rst lines input eld text associated handle 
page contains submit button validate indicated thiemann 
callback action contains invalid handle 
action produces new web page submits eld button page 
extreme case second page input elds just presents text example terms conditions accept button 
user types invalid name rst page get error message clicking accept button second page see terms conditions 
certainly puzzling situation 
news tackle programming error type system 
solution relies rank type 
inspired launchbury peyton jones solution problem local state 
trick index underlying cgi monad phantom type variable 
phantom type variable appears extra type parameter type input handles 
creation input widget revised typing inputfield string invalid type withhtml cgi withhtml cgi consequently submission function type revised accept input handles match type index currently executing thread cgi monad submit inputhandle invalid valid forall cgi parameter valid matter value function polymorphic parameter value inputfield valid fl need revised take type parameter just pass arguments data data data fl fl approach ectively rules scope mismatch error 
example function call submit empty program fig 
typecheck 
course part callback argument submit 
happens starting assumption inputfield string invalid submit accept empty type withhtml cgi type invalid thiemann type forall cgi note universally quanti ed occurs expression assumption type variable occur environment assume type forall valid cgi expected type generic instance rst type inference fails point 
reported error type variable generalized 
turns situations typing restrictive 
example consider web page di erent input elds set buttons selection box determines input elds considered 
widget handles validated depend value input elds 
selected randomly 
obvious extension current programming model requires rst validate submit selector elds validate set elds required particular choice 
done submission function typing inputhandle invalid valid forall inputhandle invalid string valid forall string cgi idea parameter function takes validated input handle uses value select input handles validation 
second parameter validation function 
type polymorphic kind type input handle process type specialized handles created thread indexed validation fail function directly return action wraps error monad string 
related thiemann uses multi parameter type classes functional dependencies generate correct html 
simpli ed basic approach employed parameter type class addto relate element parents pure haskell approach relying number specialized parameter type classes 
re expressed multi parameter thiemann classes implemented transition function functional logic overloading 
wash cgi provided motivation exploration submit function 
extends introducing number typings submit guarantee mismatch data posted browser data server side script expects 
technical side sulzmann introduced programmable type system employs constraint handling rules 
system express features supported functional logic overloading relies constraint logic programming foundation 
generic programming example hinze approach generic functional programming relies heavily powerful means transform types 
demonstrated fairly small extension hinze framework amenable express type suitably altered submit function 
fact functions framework smoothly integrated haskell consider required extension fundamental problem 
development wash family dsls lead number interesting typing problems 
developed solutions typing problems encoding haskell relying extensions language functional logic overloading anonymous type functions rank polymorphism hinze framework generic programming 
solutions guarantee high level properties wash scripts correctness generated html documents consistency data submitted browser data expected web browser 
matthias neubauer careful reading draft 
aho sethi ullman 
compilers principles techniques tools 
addison wesley 
brzozowski 
derivatives regular expressions 
journal acm 
dowek 
higher order uni cation matching 
robinson voronkov editors handbook automated reasoning volume chapter pages 
north holland 
thiemann neubauer sperber thiemann 
functional logic overloading 
mitchell editor proc 
th annual acm symposium principles programming languages pages portland usa jan 
acm press 
glynn stuckey sulzmann 
type classes constraint handling rules 
workshop rule constraint reasoning programming july 
hanus 
integration functions logic programming theory practice 
journal logic programming 
hanus 
uni ed computation model functional logic programming 
jones editor proc 
th annual acm symposium principles programming languages pages paris france jan 
acm press 
haskell non strict purely functional language 
www haskell org definition dec 
hinze 
polytypic values possess types 
science computer programming june 
hinze peyton jones 
derivable type classes 
hutton editor proceedings acm sigplan haskell workshop volume electronic notes theoretical computer science montreal canada sept 
elsevier science 
jones 
type classes functional dependencies 
smolka editor proc 
th european symposium programming number lecture notes computer science pages berlin germany mar 
springerverlag 
launchbury peyton jones 
state haskell 
lisp symbolic computation dec 
neubauer thiemann 
type classes higher order polymorphism 
peyton jones editor proc 
international conference functional programming pittsburgh pa usa oct 
acm press new york 
neubauer thiemann sperber 
functional notation functional dependencies 
hinze editor proceedings haskell workshop 
appear 
odersky sulzmann 
type inference constrained types 
theory practice object systems 
thiemann 
typed representation html xml haskell 
journal functional programming july 
thiemann 
wash cgi server side web scripting sessions typed compositional forms 
practical aspects declarative languages proceedings thiemann fourth international workshop padl number lecture notes computer science pages portland usa jan 
springerverlag 
web authoring system haskell wash 
www informatik uni freiburg de thiemann haskell wash mar 
xhtml extensible hypertext markup language 
www org tr xhtml jan 

