quant ph dec quantum computation aharonov departments physics computer science hebrew university jerusalem israel december years theoretical study quantum systems serving computational devices achieved tremendous progress 
strong theoretical evidence quantum computers built dramatically powerful computational tool capable performing tasks intractable classical computers 
review tell story theoretical quantum computation 
left developing topic experimental realizations model neglected closely related topics quantum information quantum communication 
result narrowing scope hope gained benefit self contained exciting field quantum computation 
review begins background theoretical computer science turing machines boolean circuits 
light models define quantum computers discuss issue universal quantum gates 
quantum algorithms including shor factorization algorithm grover algorithm searching databases explained 
devote attention understanding origins quantum computational power limits power 
describe theoretical results show quantum computers maintain complexity power presence noise inaccuracies finite precision 
question separated quantum complexity realistic model inevitably subject inaccuracies 
tried put results context asking implications issues computer science physics 
review connections explicit discussing possible implications quantum computation fundamental physical questions transition quantum classical physics 
overview ancient times humanity seeking tools help perform tasks involve calculations 
computing area land computing stresses appear annual reviews computational physics vi edited dietrich stauffer world scientific rods bridges finding shortest route place 
common feature tasks structure input 
computation 
output computation part process inevitably performed dynamical physical system evolving time 
sense question computed intermingled physical question systems physically realized 
wants perform certain computation task seek appropriate physical system evolution time system corresponds desired computation process 
system initialized input final state correspond desired output 
nice example invented great spanish architect lived turn century 
design holy family church la barcelona art process building years 
church resembles sand tremendous complexity delicate thin tall towers arcs 
plan church complicated towers arcs emerging unexpected places leaning arcs towers practically impossible solve set equations corresponds requirement equilibrium complex 
solving impossible task thought ingenious idea arc desired complex took rope length proportional length arc tied edges rope middle rope arcs supposed lean 
just tied edges ropes corresponding lowest arcs ceiling 
computation instantaneously done gravity 
set arcs arranged complex equilibrium upside 
angles different arcs radii arcs 
putting mirror thing simply see design church 

examples analog computers exist invented solve complicated task 
differential analyzer invented lord kelvin uses friction wheels pressure draw solution input differential equations 
spaghetti sort example 
systems computers 
want construct build completely different machine task compute 
general purpose machine universal 
mathematical model universal computer defined long invention computers called turing machine 
describe model briefly 
turing machine consists infinite tape head reads writes tape machine finitely possible states transition function ffi head reads time machine state time ffi determines head write direction move new machine state time 
turing machine model capture entire concept computability thesis church turing thesis turing machine compute function computable reasonable physical device reasonable physical device mean 
thesis physical statement proven 
knows physically unreasonable device sees 
till candidates counterexamples thesis see ref 

physical systems including quantum systems simulation turing machine 
astonishing fact families functions computed 
fact functions computed 
trivial reasons functions ways compute 
reason set turing machines countable set families functions 
spite simplicity argument formalized diagonal argument observation came complete surprise discovered 
subject computability functions cornerstone computational complexity 
theory computation interested question functions computed mainly cost computing functions 
cost computational complexity measured naturally physical resources invested order solve problem time space energy fundamental question computation complexity cost function behaves function input size particular exponential polynomial computer science problems solved exponential cost regarded intractable readers tried perform exponentially slow simulation appreciate characterization 
class tractable problems constitutes problems polynomial solutions 
worthwhile reconsider means solve problem 
important conceptual breakthroughs modern mathematics understanding advantageous relax requirements solution correct allow negligible probability error 
gave rise rapid solutions different problems random coin flips miller rabin randomized algorithm test integer prime 
simple example advantage probabilistic algorithms access database bits told equal constant half half balanced 
asked distinguish cases 
deterministic algorithm observe bits order give correct answer 
solve problem probabilistically toss random observe th bit repeat experiment times 
different bits answer balanced bits equal answer constant 
course chance wrong declaring constant chance arbitrarily small 
probability error equals chance tossing fair coin times getting decreases exponentially example order error probability gamma suffices 
general desired confidence constant 
helpful shortcut large 
allow negligible probability error better 
class tractable problems considered problems solvable negligible probability error polynomial time 
solutions computed probabilistic turing machine defined exactly deterministic turing machine transition function change configuration possible ways randomly 
modern church thesis refines church thesis asserts probabilistic turing machine captures entire concept computational complexity modern church thesis probabilistic turing machine simulate reasonable physical device polynomial cost 
worthwhile considering models contradict thesis sight 
model dna computer enables solution np complete problems hard problems defined polynomial time 
cost solution exponential number molecules system grows exponentially size computation 
suggested machine able solve instantaneously np complete problem construction rods balls designed structure moves solution problem 
careful consideration reveals tend think rigid rods transferring motion instantaneously time delay rods accumulate cause exponential delay 
shamir showed factorize integer polynomial time space physical resource exponentially precision 
fact simon showed extremely hard problems class problems called polynomial space harder np problems solved polynomial cost time space exponential precision 
suggestions computational models provide counterexamples modern church thesis require exponential physical resources 
note suggestions mentioned rely classical physics 
early feynman started discuss question computation done scale quantum physics 
classical computers elementary information unit bit value 
quantum analog bit state particle called quantum bit qubit 
state quantum system described unit vector hilbert space complex numbers 
states denoted corresponds vector 
state orthogonal denoted 
states constitute orthogonal basis hilbert space 
build computer need compose large number state particles 
qubits composed system hilbert space tensor product spaces omega omega delta delta delta omega understand space better best think space spanned basis 
natural basis space take basis consisting vectors called computational basis omega omega delta delta delta omega omega omega delta delta delta omega 
omega omega delta delta delta omega naturally classical strings bits correspond quantum states 
ji omega ji omega delta delta delta omega ji ji perform computation qubits 
suppose want compute function gamma 
bits bits 
system evolve time evolution operator ji gamma 
ji jf find hamiltonian generates evolution schrodinger equation ih dt psi hj psi means solve desired psi exp gamma psi psi solution exists long linear operator unitary 
important pay attention unitarity restriction 
note quantum analog classical operation unitary reversible 
reversible classical function implemented physical hamiltonian 
researchers investigated question reversible classical functions connection completely different problems problem computation done generating heat inevitable irreversible operations solution maxwell demon paradox 
turns classical function represented reversible function bits computation reversible losing efficiency 
computed classically polynomially elementary reversible steps corresponding decomposable sequence polynomially elementary unitary operations 
see quantum systems imitate computations done classical systems lose efficiency 
quantum computation interesting imitate classical computation probably 
seminal feynman pointed fact quantum systems particles exponentially hard simulate classical devices 
words quantum systems obey modern church thesis polynomially equivalent classical systems 
quantum systems hard simulate quantum systems harnessed computational devices dramatically powerful computational devices 
particles 
described quantum systems imitate classical computation quantum particles state 
quantum theory asserts quantum system schrodinger cat need basis states linear superposition 
superposition written complex numbers jc jc 
wave function superposition quantum bits superposition possible basis states 
consider example state particles known ghz state superposition describing qubit 
answer superposition 
qubits state state system tensor product states particle superposition describes quantum correlations particles 
particles said entangled 
einstein rosen paradox bell inequalities correspond puzzling quantum feature quantum particle state 
entanglement quantum correlations quantum particles state system specified simply describing state particles 
state quantum bits complicated superposition basis states complex coefficients needed order describe 
hilbert space crucial ingredient quantum computation 
gain understanding advantages space consider superposition quantum bits 
ji uniform superposition possible basis states qubits 
apply unitary operation computes equation state get simply linearity quantum mechanics ji gamma 
jf applying computes simultaneously possible inputs enormous power parallelism 
tempting think exponential parallelism immediately implies exponential computational power case 
fact classical computations viewed having exponential parallelism devote attention 
problem lies question extract exponential information system 
quantum computation order extract quantum information observe system 
measurement process causes famous collapse wave function 
nutshell means measurement state projected exponentially possible states exponential amount information computed completely lost 
order gain advantage exponential parallelism needs combine quantum feature known interference 
interference allows exponentially computations done parallel cancel just destructive interference waves light 
goal arrange cancelation computations interested remain rest cancel 
combination exponential parallelism interference quantum computation powerful plays important role quantum algorithms 
quantum algorithm sequence elementary unitary steps manipulate initial quantum state jii input measurement final state system yields correct output 
quantum algorithm combines interference solve problem faster classical computers discovered deutsch jozsa 
algorithm addresses problem encountered connection probabilistic algorithms distinguish constant balanced databases 
quantum algorithm solves problem exactly polynomial cost 
seen classical computers release restriction exactness 
deutsch jozsa powerful tool quantum algorithms fourier transform manifests interference 
simon algorithm uses similar techniques seed important quantum algorithm known today shor algorithm 
shor algorithm polynomial quantum algorithm factoring integers finding logarithm finite field :10.1.1.144.6148
problems best known classical algorithms exponential 
proof classical efficient algorithms exist 
shor result regarded extremely important theoretically practically mainly due fact assumption factorization hard lies heart rsa cryptographic system 
cryptosystem supposed secure way transform information eavesdropper able learn reasonable time significant information message sent 
rsa cryptosystem heavily cia uses security embedded netscape explorer web browsers rsa banks rsa internal security securing external connections 
rsa cracked efficient algorithm factoring 
understandable publication factorization algorithm caused rush excitement world 
important quantum computation power rely unreasonable precision polynomial amount precision computational elements :10.1.1.144.7852
means new model requires physically reasonable resources terms time space precision possibly exponentially stronger ordinary model probabilistic turing machine 
model really threatens modern church thesis 
major developing directions research area quantum computation 
grover discovered algorithm searches unsorted database items finds specific item time steps 
result surprising intuitively search database going items 
grover solution quadratically better possible classical algorithms followed numerous extensions applications achieving polynomial advantage classical algorithms 
promising new branch quantum complexity theory study class problems quantum analog complexity class np 
interesting direction quantum computation concerned quantum computers simulating efficiently physical systems body fermi systems 
direction pursues original suggestion feynman noticed quantum systems hard simulate classical devices 
important direction investigation search different stronger quantum computation model 
example consider slight non linearities quantum mechanics 
completely hypothetical experiments verify linearity quantum mechanics 
slight non linearities imply extremely strong quantum algorithms 
interesting quantum computation model uses non local features quantum mechanics suggested kitaev 
possibly stronger model quantum field theory sketched freedman rigorously defined 
direction oracle results quantum complexity 
direction compares quantum complexity power classical complexity power models allowed access oracle black box compute certain possibly difficult function step :10.1.1.144.7852
fact result bernstein vazirani demonstrating superpolynomial gap quantum classical computational access certain oracle initialized sequence results leading shor algorithm :10.1.1.144.7852
important result quantum complexity shows quantum computers polynomial advantage terms number accesses inputs 
far understanding computational power quantum systems 
particular known quantum systems efficiently solve np complete problems 
quantum information theory subject intermingled quantum computation provides bunch quantum magic tricks construct powerful quantum algorithms 
probably quantum pearl encounters quantum mechanics einstein podolsky rosen paradox best explained bell inequalities establishes existence correlations quantum particles stronger classical model explain 
quantum pearl builds quantum entanglement teleportation 
amazing quantum recipe enables parties alice bob far apart transfer unknown quantum state particle alice hands particle bob hand sending actual particle 
done alice bob share pair particles interacted past entangled 
quantum effects serve ingredients different computation communication tasks 
entanglement example order gain advantage communication 
parties alice bob want communicate save bits communication share entangled pairs qubits 
teleportation viewed quantum computation beautiful connections drawn teleportation quantum algorithms correct quantum noise 
uses quantum effects quantum computation 
believe full potential quantum mechanics context complexity algorithmic problems revealed 
despite impressive progress quantum computation question remained 
quantum information extremely fragile due inevitable interactions system environment 
interactions cause system lose part quantum nature process called decoherence 
addition quantum elementary operations called gates inevitably suffer inaccuracies 
physical realizations model quantum computation powerful ideal model 
classical computation shown von neumann compute elements computation faulty redundant information 
nowadays error corrections seldom computers extremely high reliability elements quantum elements fragile certain quantum error corrections necessary quantum computers 
shown errors corrected quantum computation soon accumulate ruin entire computation 
method correct effect quantum noise necessary 
physicists pessimistic question correction method exists 
reason quantum information general cloned information simply protected redundancy done classically 
problem contrast discreteness digital computers quantum system superposition continuous coefficients 
range allowed coefficients continuous impossible distinguish bona fide information information contaminated 
opposed physical intuition turns clever techniques enable quantum information protected 
conceptual breakthrough quantum error corrections understanding quantum errors continuous viewed discrete process quantum operations occurs 
errors viewed classical errors called bit flips quantum errors called phase flips 
bit flip errors corrected classical error correction techniques 
fortunately phase flips transform bit flips familiar fourier transform 
understanding allowed classical error correction codes techniques quantum setting 
shor scheme reduces affect noise inaccuracies building discretization errors 
classical error correcting codes quantum states qubits encoded states qubits 
spreading state qubits qubits allows correction information part contaminated 
ideas extended show quantum state qubits encoded qubits qubits sent noisy channel original state qubits recovered 
tends asymptotically constant transmission rate non zero 
analogous shannon result noisy classical communication 
different examples quantum error correcting codes followed group theoretical framework quantum codes established 
resilient quantum computation complicated simply protecting quantum information sent noisy quantum channel 
naturally protect information compute encoded states 
problems noisy computation encoded states 
error correction done faulty gates cause errors 
careful error correction cause harm helps 
second problem computing encoded states qubits interact gates way errors propagate gates qubit 
error spread way entire set qubits quickly 
order deal problems idea perform computation error correction distributed manner qubit effect small number qubits 
kitaev showed perform computation error correction faulty gates 
shor discovered perform general computation presence noise assumption noise decreases slowly size computation 
physically reasonable assumption devices laboratory constant amount noise independent size computation 
achieve fault tolerance noise apply concatenation shor scheme 
encode state encode encoded state levels 
technique enabled proof threshold theorem asserts possible perform resilient quantum computation long wish noise smaller certain threshold 
decoherence imprecision longer considered insurmountable obstacles realizing quantum computation 
accord theoretical optimistic results attempts implementations quantum circuits carried world 
unfortunately progress direction slower impressive pace theoretical quantum computation progressed 
reason handling quantum systems experimentally extremely difficult 
entanglement necessary ingredient quantum computers experimentally fragile property difficult create preserve 
far entangled pairs photons created successfully entanglement features violation bell inequalities demonstrated 
entangled pairs atoms created 
quantum computation advantageous particles entangled task impossible 
promising experimental developments come closely related subject quantum cryptography 
quantum communication successfully tested 
reported experimental realization quantum teleportation suggestions implementations quantum computation include quantum dots cold trapped ions nuclear magnetic resonance suggestions implemented 
unfortunately implementations far limited qubits 
qubits possible perform partial error correction successful implementation error correction phases nmr reported 
nuclear magnetic resonance techniques quantum algorithm implemented achieves proven advantage classical algorithms 
noted suggestions implementation suffer severe problems 
nuclear magnetic resonance signal noise ratio decays exponentially number qubits theoretical solution problem 
implementations allow parallel operations necessary error resilience 
systems controlling thousands qubits hopeless 
experimental successes encourage hope ambitious task realizing quantum computation possible 
exciting developments quantum computation give rise deep new open questions fields computer science physics 
particular computational complexity questions shed new light old questions fundamental quantum physics transition quantum classical physics measurement process 
shall discuss interesting topics 
start survey important concepts connected computation section 
model quantum computation defined section 
section discusses elementary quantum operations 
section describes basic quantum algorithms deutsch jozsa simon 
shor factorization algorithm section fourier transforms discussed separately section alternative factorization algorithm kitaev 
grover database search variants explained section 
section discusses origins power quantum computation section discusses weaknesses quantum computers 
sections devoted noise error correction fault tolerant computation 
section conclude remarks philosophical flavor 
computer 
discuss basic notions computational complexity theory turing machines boolean circuits computability computational complexity 
important complexity classes np defined section 
background consult 
definition turing machine definition turing machine tm triplet sigma ffi 

sigma ft finite set symbols call alphabet 
special symbol called blank symbol 

finite set machine states special states initial state final state 

transition function ffi theta sigma gamma 
theta sigma theta gamma machine works follows tape head read write tape computation 
tape working space memory 
computation starts input symbols written positions tape symbols symbols blank head initially position state initially time step machine evolves transition function ffi way 
current state machine symbol current place tape oe ffi oe oe ffl machine state changed symbol head replaced oe tape head moves step direction ffl 
ffl head doesn move 
schematic description turing machine note operation turing machine local depends current state machine symbol written current position tape 
operation machine sequence elementary steps require constant amount effort 
machine gets final state say machine halted 
written time tape contain output 
typically output form 
easily construct examples machine halts input example entering infinite loop 
definition possible turing machines designed compute specific task transition function 
exists turing machine input interprets input description turing machine concatenated description input call simulate efficiently behavior input write 
called universal turing machine 
precisely description fixed notation 
loss generality symbols states numbers jkj sigmaj 
description contain jkj sigmaj transition function described set rules finite form oe oe ffl 
set symbols contain symbols apart 
contain machine states reading input looking appropriate rule apply 
go details convincing finite set states simulate operation input entire set rules transition function written tape 
existence universal turing machine leads naturally deep beautiful subject non computability 
function non computable computed turing machine turing machine input halts outputs correct answer 
famous example halting problem 
problem description turing machine input halt 
theorem turing machine solves halting problem inputs 
proof proof theorem conceptually puzzling 
uses called diagonal argument 
assume turing machine halts 
modify obtain gamma 
enters infinite loop gamma 
modification done easily replacing rules transition function rule writes tape causes halt replaced rule takes machine infinite loop 
rule writes tape causes halt replaced rule writes tape halts way twisted version halt 
obtain contradiction ways 
suppose halt 
means halt 
halt means halt 
beautiful proof shows functions computed 
turing machine define functions computable 
convenient universal model polynomially equivalent turing machines called boolean circuit model 
quantum analog model review 
boolean circuit directed acyclic graph nodes associated boolean functions 
nodes called logical gates 
node input wires output wires associated function gamma 
simple example string bits input wires carry values bits node reached 
node computes logical function bits function output wires node carry output bits node computation ends output wires 
input wires carry constants vary different inputs circuit part hardware circuit 
turing machine transition function local operation sequence elementary steps 
circuit model requirement translates fact gates local number wires node operates bounded constant 
measure cost computation different parameters number gates circuit time depth circuit 
review mainly considered number gates 
interested behavior cost function size input number wires input circuit usually denote find cost function look function family functions ff computed family circuits fc operating input bits size circuit important distinction model turing machines circuits 
lot information get circuit hardware 
specify long takes design hardware circuits compute non computable functions 
easily seen example 
define circuit simple circuit outputs constant bit regardless input bits 
constant bit th turing machine ordered numerical description turing machines halts input 
family circuits fc computes non computable halting problem circuits having gate 
unreasonable computational power circuits due fact haven specified constructs hardware circuit 
want avoid absurdity concentrate interesting realistic cases 
require hardware circuits compute ff designed polynomial cost turing machine 
turing machine input integer outputs specification circuit model called uniform circuit model opposed non uniform strong 
models uniform boolean circuits turing machines polynomially equivalent 
means turing machine computes polynomial time family polynomial circuits fc specified polynomial turing machine computes correspondence true reverse order family circuits turing machine simulates 
complexity computation depend polynomial factors model 
uniform circuit model 
main questions review cost computation grows polynomial exponential distinction arbitrary better understood context complexity classes np complexity class essentially class easy problems solved polynomial cost definition complexity class ff exists uniform family circuits fc poly size computes function class non deterministic polynomial time short np class harder problems 
problem np require exists polynomial algorithm solves 
merely require exists algorithm verify solution correct polynomial time 
way view algorithm provided input problem hint hint may misleading 
algorithm solve problem polynomial time hint mislead bad hints 
formal definition follows plays role hint 
definition complexity class np ff np exists uniform family circuits fc poly size satisfies gamma 
exists string poly size satisfies understand formal definition better consider example np problem called satisfiability input formula boolean variables form xm logical poly clauses clause logical poly variables negation 
output exists satisfying assignment variables true 

see satisfiability np define circuit get input specification formula possible assignment circuit output 
easy see circuits satisfy requirements definition np problems 
knows build polynomial circuit gets input finds satisfying assignment exists 
impossible find satisfying assignment literally checking possibilities 
satisfiability known satisfiability belongs important subclass np np complete problems 
hardest problems np sense know solve np complete problem efficiently solve problem np polynomial slowdown 
words problem np complete np problem reduced polynomial time 
garey johnson give hundreds examples np complete problems reducible polynomial slowdown equivalently hard 
best known algorithm np complete problem exponential widely believed conjecture polynomial algorithm np important open question complexity theory today proving conjecture 
interesting class consists problems solvable negligible probability error polynomial time probabilistic turing machine 
machine defined exactly deterministic tm transition function change configuration possible ways randomly 
equivalently define randomized circuits boolean circuits advantage apart input bits get input random bits random coin flips 
class problems solvable uniform polynomial randomized circuits bounded error probability called bpp bounded probability polynomial definition ff bpp exists family uniform randomized circuits fc poly size probability probability measured respect uniformly random appearance quantum computers modern church thesis asserts probabilistic turing machine equivalently randomized uniform circuits simulate reasonable physical device polynomial time held counterexamples 
quantum model define chapter model qualitatively different 
define quantum complexity classes definition complexity classes qp bqp defined bpp respectively quantum circuits 
known qp bpp bqp see soon 
model quantum computation deutsch define rigorous model quantum computation quantum turing machines quantum circuits 
describe model quantum circuits simpler 
chapter model quantum turing machines completeness 
background basic quantum mechanics hilbert spaces schrodinger equation measurements recommend consult books sakurai cohen 
advanced material book peres 
give necessary definitions 
quantum circuit system built state quantum particles called qubits 
qubits state unit vector complex hilbert space omega omega delta delta delta omega natural basis space take basis consisting vectors omega omega delta delta delta omega omega omega delta delta delta omega 
omega omega delta delta delta omega brevity omit tensor product denote ji omega ji omega delta delta delta omega ji ji jii binary representation integer number gamma 
important step representation allows quantum system encode integers 
quantum system starts computer 
general state describes system complex unit vector hilbert space called superposition gamma jii jc 
initial state correspond input computation 
agree input string initial state system jii gamma 
jii perform elementary operations system 
operations correspond computational steps computation just logical gates elementary steps classical computers 
assume operations performed isolated system evolution described unitary matrix operating state system 
recall unitary matrix satisfies uu transposed complex conjugate definition quantum gate qubits unitary matrix dimensions theta example simple quantum gate operating qubit 
recalling notation 
gate flips bit justified call gate gate 
gate operate superpositions 
linearity operation linearity responsible quantum parallelism see margolus encounter powerful quantum algorithms 
gate operates qubit system qubits state ji state transforms ji ji formally time evolution system described unitary matrix tensor product gate operating qubit identity matrix operating rest qubits 
important quantum gate controlled gate acting qubits computes classical function gamma 
phi phi mod 
function represented matrix operating configurations bits cnot matrix matrices review written computational basis lexicographic order 
gate called exclusive xor gate importance see 
xor gate applies second bit called target bit conditioned control bit 
black circle denotes bit condition denote xor gate phi way classical boolean functions transformed quantum gates 
matrix representing classical gate computes reversible function particular number inputs gate equals number outputs permutation possible classical strings 
permutation easily seen unitary 
course functions reversible easily converted reversible functions writing input bits erasing 
function bits bits get reversible function bits bits gamma 
gamma 
phi applying method example logical gate gamma 
ab known toffoli gate gamma 
phi ab described unitary matrix qubits toffoli gate applies bit conditioned bits describe diagram quantum gates perform complicated tasks simply computing classical functions 
example quantum gate classical gate disguise gate applies general rotation qubit oe cos sin ioe gamma sin cos perform quantum computation apply sequence elementary quantum gates qubits system 
suppose applied quantum gates algorithm computation come 
state initially basis state rotated state jffi want extract output state 
done process measurement 
notion measurement quantum mechanics puzzling 
example consider measurement qubit state jffi 
qubit state 
measurement postulate asserts state qubit observed decide possibilities 
decision non deterministically 
classical outcome measurement probability jc probability jc measurement state qubit consistency classical outcome measurement 
geometrically process interpreted projection state orthogonal subspaces ig ig measurement state qubit jffi observation subspaces state spite fact state 
probability decision norm squared projection jffi likewise 
due fact norm jffi probabilities add 
measurement jffi projected space answer space answer 
projection famous collapse wave function 
measure qubit system qubits 
project state subspaces subspace spanned basis states measured qubit rule measured superposition ji measurement qubit give outcome probability prob jc superposition collapse prob likewise 
simple example state qubits gamma probability measure left qubit probability measure 
measuring left qubit state collapsed probability pr gammaj probability pr 
resulting state depends outcome measurement 
collapse projected state renormalized back 
summarize definition model quantum circuits 
quantum circuit directed acyclic graph node graph associated quantum gate 
exactly definition section classical boolean circuits gates quantum 
input circuit basis state evolves time operation quantum gate 
computation apply measurements output qubits order matter 
string classical outcome bits classical output quantum computation 
output general probabilistic 
concludes definition model 
build repertoire quantum computations step step 
seen classical gates implemented making computation reversible 
explicitly lemma function bits bits computed boolean circuit size exists quantum circuit computes unitary transformation qubits ji gamma 
phi ji 
size linear proof replace gate reversible extension equation 
add extra bits purpose 
input circuit 
modified denoted viewed quantum circuit nodes correspond unitary matrices 
function computes required function input necessarily part output 
solve problem add extra wires qubits 
input wires 
sequence gates copy result qubits blank qubits applying cnot gates 
apply reverse order reversed gates gates applied far cnot gates 
reverse operations retain input qubits contain desired 
state system basis state computation described proof 
measurements final state yield exactly expected result 
shows computation done classically done efficiency order number gates 
shown theorem qp process conversion reversible operations gate replaced gate operating qubits 
means making circuits reversible costs adding linear number extra qubits 
bennett nice argument show space cost decreased logarithmic factor minor cost time gamma 
ffl conversion quantum circuit efficient 
implement classical computation show implement probabilistic algorithms 
need quantum subroutine generates random bit 
done easily measurements 
define hadamard gate acts qubit 
extremely useful gate quantum algorithms 
gamma applying gate qubit state get superposition sigma 
measurement qubit yields random bit 
classical circuit uses random bits converted quantum circuit replacing gates reversible gates adding quantum random bit subroutine needed 
note allow measuring middle computation 
shows theorem bpp bqp repertoire classical algorithms simulated efficiently quantum computers 
quantum systems feature characteristics far interesting 
encounter possibilities discuss quantum algorithms 
define model quantum turing machine qtm quantum analog classical tm 
difference degrees freedom quantum cell tape state machine reading head tape linear superpositions different possible classical states 
definition quantum turing machine specified items 
finite alphabet sigma ft blank symbol 

finite set fq machine states special states 

transition function ffi theta sigma theta theta sigma theta gamma gamma 
classical tm tape associated head reads writes tape 
classical configuration turing machine specified head position contents tape machine state 
hilbert space qtm defined vector space spanned possible classical configurations 
dimension space infinite 
computation starts qtm basis state jci corresponds classical configuration input symbols written positions tape symbols symbols blank head position 
time step machine evolves infinite unitary matrix defined way 
probability amplitude transform configuration determined transition function ffi state machine symbol current place tape head oe ffi oe oe ffl probability amplitude go equal locally 
machine state changed symbol head changed oe tape head moves step direction ffl 
note operation turing machine local depends current state machine symbol read tape 
unitarity infinite matrices easy check conditions unitarity bernstein vazirani :10.1.1.144.7852
opinion qtm model appealing model quantum circuits reasons 
qtms involve infinite unitary matrices 
second physical quantum computer resemble model head apparatus executing quantum operations classical position state 
point qtm model sequential model means able apply operation time step 
aharonov ben showed sequential model fundamentally incapable operating fault presence noise 
constructing algorithms simpler circuit model 
reasons restrict review quantum circuits 
model quantum circuits just classical circuits uniform non uniform versions 
restrict uniform model quantum circuits designed polynomial time classical turing machine 
yao showed uniform quantum circuits polynomially equivalent quantum turing machines proof surprisingly complicated 
proof enables freedom choosing whichever model convenient 
model worth mentioning context quantum cellular automaton 
model resembles quantum circuits different fact operations homogeneous periodic space time 
definition model subtle case quantum circuits trivial decide quantum cellular automaton obeys rules quantum mechanics 
interesting quantum model finite state quantum automaton similar quantum turing machine read write memory 
limited model 
model watrous showed interesting algorithm uses interference able compute function computed analogous classical model 
universal quantum gates kind elementary gates quantum computation program 
write program elementary steps algorithm sequence steps potentially implementable laboratory 
achieving controlled interactions large number qubits elementary step extremely difficult 
reasonable require elementary gate operate small number qubits independent large 
want computer able compute function 
set elementary gates universal 
classical reversible computation exists single universal gate called toffoli gate encountered 
gate computes function gamma 
ab phi claim reversible function represented concatenation toffoli gate different inputs 
example construct logical gate simply input bit contain ab phi 
implement gate third bit set bits equal 
known universal set gates gates 
quantum case notion universality slightly complicated operations continuous 
need require operations achieved exactly approximation suffices 
notion approximation important quantum computation 
frequently operations approximated achieved exactly significantly damaging correctness computation 
definition approximation unitary matrix said approximated ffl unitary matrix ju gamma ffl 
norm induced euclidean norm vectors hilbert space 
note unitary transformations thought rigid rotations hilbert space 
means angles vectors preserved computation result ju gamma ffl state tilted angle order ffl correct state 
angle grow computation rotation rigid 
state remains ffl angle correct state 
error entire computation additive sum errors gates 
shows accuracy gates approximated large 
gates circuit suffices approximate gate order computation correct constant probability :10.1.1.144.7852
define notion universal gates approximate possible quantum operation definition universal set gates set quantum gates called universal ffl unitary matrix number bits approximated ffl sequence gates words subgroup generated dense group unitary operators deutsch show universal elementary gate operates qubits 
bernstein vazirani gave proof universality terms qtm shown qubit gates universal :10.1.1.144.7852
important result impossible control interactions particles particle interactions easier implement 
surprising achievement reversible classical computation special case quantum computation set bit gates universal 
note qubit gate certainly construct operations 
deutsch showed bit gate universal see lloyd 
improvement result achieved shown classical controlled gate qubit gates construct universal set 
fact qubit gate controlled gate 
simplest economic set constructed far 
implementation qubit gates feasible implemented controlled gate 
possible sets gates 
adleman solovay suggested set gates entries matrices sigma sigma sigma 
universal sets gates suggested connection fault tolerant quantum computation 
need possible universal sets choose 
universal sets gates computer languages 
lowest level need quantum assembly machine language implemented 
purpose set consists easiest gates implement laboratory 
probably set qubit gates appropriate 
incentive analyzing complexity power quantum computers 
set suggested solovay adleman appropriate 
fortnow reported bounds set 
see error correction purposes need completely different universal set gates 
important question arise 
computer built set design algorithms set analyze computational power third set 
answer universal sets way translate languages 
gate set approximated sequence gates set 
turns universal sets described approximation ffl operation qubits takes poly log ffl gates set 
long gates local constant translation different universal sets efficient 
concept universal set gates understood example simple universal set gates 
relies proof deutsch universal gate 
idea underlying deutsch universal gate reversible computation special case quantum computation 
natural universal quantum computation achieved generalizing universal reversible computation 
deutsch showed generalize toffoli gate universal gate quantum computation matrix original toffoli gate see equation replaced unitary matrix qubit approximate omega matrix 
modification deutsch proof gates form 
define cos ff sin ff ff cos ff ff freedom choosing ff require sequence ff mod ff mod ff mod hits ffl neighborhood number poly ffl steps 
clearly ff irrational irrational numbers satisfy property 
difficult see irrational root polynomial degree satisfies required property 
generalized toffoli gate playing role conditioned matrix respectively 
theorem fu universal set quantum gates 
proof note choice ff approximates rotation real plane approximates rotation complex plane 
theta unitary matrix denote eigenvectors corresponding eigenvalues determined define achieved transformation denote apply correct number times approximate gamma 
take applying reverse transformation gamma left show apply take general state jii 
note approximate toffoli gate approximate permutations basis states 
apply gamma 
turn coefficient coordinate 
done applying appropriate number times phase coefficient equal 
coefficients ioe ioe rcos 
apply appropriate number times approximate rotation gamma 
transform weight 
way transform weight coordinates permutations coordinates 
achieves gamma 
transformation gamma constructed way 
shown qubit operations approximated 
operations qubits note group generated wm dense operations bits reasoning 
create um wm recursion compute logical bits toffoli gate writing extra bit apply um gamma wm gamma 
reader verify approximation polynomially fast fixed unitary matrix qubits approximated ffl poly ffl applications gates generalized toffoli gates operate qubits 
show explicit sequence bit gates constructs matrix qubits form generalized toffoli gate bit gates universal 
shown qubit matrix conditioned qubit expressed sequence qubit matrices cnot generalized toffoli gate deutsch written finite sequence qubit gates cnot shows gamma qubit gates universal 
description shows approximate unitary matrices poly ffl gates universal set 
fact exponentially faster approximation possible due theorem kitaev proved solovay theorem matrices su generate dense subset su 
matrix su approximated ffl product poly log ffl matrices su set theta unitary matrices determinant 
universal quantum set easily convert set su multiplying matrix complex scalar value phase 
phase effect result measurement gate multiplied phase affecting computation 
corollary approximation rate universal set quantum gates exponential 
idea proof theorem construct finer finer nets points su 
th net constructed points th net 
point th net product linear number gates set gates 
turns distance adjacent points net decreases exponentially having chosen set gates write algorithms writing algorithm assembler language tedious task 
just higher languages ordinary computer programming desirable quantum operations commonly treated black boxes rewriting elementary gates 
steps direction 
quantum algorithms simplest quantum algorithm achieves advantage classical algorithms deutsch jozsa 
deutsch jozsa algorithm addresses problem encountered context probabilistic algorithms 
boolean function ng 
assume integer promised equal constant half half balanced 
asked distinguish cases 
question oracle setting 
means circuit get input 
circuit access oracle query oracle gate input wires carrying integer ng bit representation 
output oracle gate 
quantum query oracle means applying unitary transformation gamma 
phi cost measured number queries oracle 
classical algorithm solves question exactly need queries 
quantum algorithm deutsch jozsa solves problem exactly merely quantum query 
algorithm transformation known discrete fourier transform group jii gamma 
gamma deltaj jji strings length delta mod inner product modulo 
need easily verified fact fourier transform apply transformation qubits simply apply hadamard transform equation qubits 
note reversed fourier transform ft gamma equal ft turn solve deutsch jozsa problem 
registers hold number consist qubits register consist qubit carry value function 
deutsch jozsa algorithm omega apply fourier transform register 
apply qubit ji omega gamma call oracle gamma 
phi gamma ji omega gamma apply reversed fourier transform register omega gamma measure register outcome equals output constant output balanced see algorithm works denote vector case constant vector case balanced 
note constant second fourier transform merely undoes fourier transform hand balanced vector gamma ji orthogonal ji unitary operations preserve angles vectors orthogonal probability measure balanced case zero 
algorithm gives correct answer probability 
algorithm shows advantage exact quantum complexity exact classical complexity 
restriction exact solution released advantage gone 
classical probabilistic machine solve problem constant number queries query 
shown overview 
discussing exact solutions problematic context quantum algorithms continuous characteristics quantum operators 
quantum computations achieved exactly finite universal set gates set unitary operations continuous set achievable operations finite universal set gates countable 
notion exact quantum algorithms robust set problems exact solution depend strongly universal set gates 
function example computed exactly deutsch universal machine 
algorithm due simon exponential advantage achieved requiring exact solutions 
problem specified follows simon problem function ng ng promised cases occurs different satisfies phi 
asked distinguish cases 
classical computer need order queries error allowed 
simon quantum algorithm solve question expected number queries log 
fact brassard improved result expected log queries worst case log queries 
registers qubits hold integer register carry numbers range function 
second register carry value function 
simon algorithm omega apply fourier transform register 
ji omega gamma call oracle ji omega gamma apply fourier transform register 
jk omega gamma deltak jf measure register 
outcome 
repeat previous steps cn times get cn apply gauss elimination find non trivial solution set equations delta mod delta mod 
cn delta mod output 
declare 
proof correctness see algorithm works analyze probability measure cases 
case probability measure independent prob fi fi fi fi fi gamma deltak fi fi fi fi fi formula derived computing squared norm projection measured vector jki omega jf summing possible 
thing case projection jki omega jf consist terms comes phi phi 
sum divide correct fact term counted twice 
case derive prob gamma deltak gamma phis deltak delta mod measure orthogonal order distinguish cases repeat experiment times observe space spanned random vectors space subspace 
perform large number trials sure case vectors span space 
finding non trivial solution mean case 
precise argument follows 
vector space dimension ae subspace spanned vectors measured trials 
equal random vector probability probability greater half dimension larger chernoff law probability vectors span space cn trials exponentially small algorithm exponentially efficient randomized classical algorithm 
extremely strong result important notice problem stated oracle setting algorithm apply oracle oracles restricted set balanced constant functions 
restriction called complexity theory promise algorithm algorithm promised oracle restricted subset 
see section promise quantum computation classical computation polynomially equivalent terms number queries oracle 
shows absence promise full range input quantum advantage exhibited number accesses input way information processed 
see example section shor factorization algorithm 
shor algorithm factoring integers shor algorithm important algorithmic result quantum computation 
algorithm builds ideas appear deutsch jozsa algorithm simon algorithm algorithms basic ingredient algorithm fourier transform 
problem stated follows input integer output non trivial factor exists 
proof polynomial classical factorization algorithm problem known np complete 
factorization regarded hard people tried solve efficiently failed 
shor published polynomial log quantum algorithm solving problem :10.1.1.144.6148
result regarded extremely important theoretically practically proof classical algorithm exist 
reason importance algorithm mainly fact security rsa cryptosystem widely assumed hardness factoring integers 
explaining algorithm explain short cryptosystem works 
cryptosystem secure way transform information eavesdropper information message sent 
rsa method receiver bob get message sends public key alice 
alice uses key encode message sends bob 
bob encode message assuming factoring hard 
rsa cryptosystem alice bob large primes set pq gamma coprime gamma gamma message mod gamma 
computes gamma mod gamma gamma computes gamma modn key chosen follows bob chooses large primes computes pq picks integer prime gamma gamma oe number primes smaller bob sends sender alice public domain newspaper phone 
pair called bob public key 
bob keeps secret gamma mod gamma gamma compute easily knowing extended euclid algorithm 
pair called bob secret key 
alice computes message power modulo sends number public channel bob 
note alice computation easy number power modulo done writing binary representation square times get add results take modulus bob decodes alice massage secret key computing modn bob get correct message 
follows fermat little theorem chinese remainder theorem imply koe mod security cryptosystem rests difficulty factoring large numbers 
eavesdropper factorization algorithm knows factors simply play role bob step cryptographic protocol 
converse statement asserts order crack rsa factoring algorithm proven 
known methods crack rsa polynomially converted factorization algorithm 
factorization assumed hard classically rsa believed secure cryptosystem 
order rsa securely integers hundreds digits length factoring smaller integers practical 
integers digits factorized classical computers longer weeks 
due fact classical factorization algorithm exponential factorizing number twice number digits take eavesdropper twice time order years 
alice bob numbers order hundreds digits presumably secure classical eavesdroppers 
shor algorithm provides quantum efficient way break rsa cryptosystem 
fact shor quantum algorithm factoring different problem order modulo input integer coprime output order minimal positive integer mod problem factorization polynomially reduced problem finding order modulo results number theory 
describe reduction explanation excellent review shor algorithm 
show way crack rsa efficient algorithm find order modulo suppose message sent find order modulo order coprime gamma gamma oe 
easy find efficiently inverse gamma modulo euclid algorithm 
simply mod mod shor beautiful algorithm finding order modulo description follows 
short idea algorithm create state periodicity apply fourier transform zq additive group integers modulo reveal periodicity 
fourier transform group zq defined follows jai gamma 
gamma iab jbi psi algorithm compute fourier transform section devoted entirely fourier transforms 
registers 
hold number 
fixed larger polynomial second register carry numbers registers consist log qubits shor algorithm omega apply fourier transform zq register gamma omega call subroutine computes gamma 
phi mod ni gamma omega jy measure second register 
gamma jy omega jy gamma jjr omega jy apply fourier transform zq register gamma gamma jr jki omega jy measure register 
outcome 
approximate fraction fraction denominator smaller classical method continued fractions 
denominator doesn satisfy mod throw away 
call denominator repeat previous steps poly log times get 
output minimal understand algorithm works 
second step algorithm numbers gamma superposition equal weights 
third step algorithm separated sets periodicity done follows possible values written second register fy gamma third state written gamma jy omega jy gamma jy omega jy gamma jy omega jy note values give periodicity smallest give term brackets periodicity set periodicity attached different state second register 
computation appeared equally superposition 
writing second register thought giving different color periodic set gamma 
visually viewed follows gamma measurement second register picks randomly sets state collapses superposition periodicity arbitrary shift obtain periodicity 
idea comes mind measure register twice order get samples periodic set deduce samples 
probability measurement second register yields shift runs algorithm periodic set chosen twice exponentially small 
gain information periodicity state simply sampling 
done fourier transform 
understand operation fourier transform diagram omega omega omega omega omega omega omega omega omega oe theta theta theta theta theta theta theta theta gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma edge diagram indicates probability amplitude transform bottom basis state upper 
measure register obtain find probability measure need sum weights coming periodic set 
prob qa gamma ik jr qa gamma order compute probability measure need evaluate geometrical series 
alternatively geometric series sum unit vectors complex plane 
exact periodicity assume second exact periodicity divides exactly 
case geometrical series equal zero 
measure probability kr mod destructive interference comes play satisfy kr mod remain cancel 

write kr mq integer know know measured 
reduce fraction coprime 
denominator exactly looking 
prime number theorem approximately log numbers smaller coprime chosen randomly repeating experiment large number times high probability eventually get coprime imperfect periodicity general case divide means picture clear 
bad completely cancel 
distinguish types geometrical series vectors complex plain looks follows 
theta theta 
xxxxxxx 

left case vectors point different directions tend cancel 
cause destructive interference cause amplitude small 
right case vectors point direction 
case constructive interference vectors 
happens close kr mod close zero 
means high probability measure satisfy approximate criterion kr mod particular consider satisfy gamma kr mod exactly values satisfying requirement runs gamma kr runs gamma set integers contains exactly multiples note complex vectors lie upper half complex plane interfering 
probability measure bounded choosing largest exponent possible prob qa gamma qa gamma ir qa gamma ira gamma ir qa sin ra sin approximation due fact chosen larger enumerator close negligible correction order denominator approximation sin small correction order probability measure satisfies approximately 
integer satisfies criterion find reasonably high probability 
note exists integer gamma remember chosen larger say means fraction denominator approximated fraction denominator smaller fraction small denominator approximates fraction large denominator 
approximating fraction efficiently method continued fractions integers 
finding fraction denominator 
precisely 
case coprime number find denominator reduced fraction case number fail test included shor algorithm thrown away 
fortunately probability coprime large greater log 
repeat experiment happens 
concludes shor algorithm 
chapter see alternative algorithm kitaev finding order modulo fourier transforms ability efficiently apply fourier transforms groups exponentially elements unique quantum world 
fact fourier transforms known tool quantum computation gives exponential advantage 
reason worthwhile devote chapter fourier transforms 
fourier transform defined follows 
denote additive group integers modulo zq function group zq complex numbers gamma 
fourier transform function function zq complex numbers gamma 
zq iab straight forward way compute fourier coefficients function take time 
factor way shorten trivial fourier transform algorithm recursion 
called fast fourier transform short fft enables compute fourier transform time steps 
large slow operation 
quantum world function abelian group zq complex numbers gamma 
represented superposition jfi gamma jai normalized 
fourier transform function fi gamma jai 
note quantum setting function elements represented compactly superposition log qubits 
compact representation allows cases apply transformation jfi gamma 
fi efficiently log time steps 
measuring fourier coefficients take time exponential log simply number coefficients exponential 
actual transformation superposition fourier transform fast 
order apply fourier transformation general states suffices apply transformation basis states jai gamma 
psi gamma iab jbi consider special case simpler general case classical techniques fast fourier transforms adopted give nice description cleve 
ll describe kitaev general quantum fourier transform abelian group implies beautiful alternative factorization algorithm 
quantum fast fourier transform 
integer gamma represented binary representation ja gamma gamma am gamma am interestingly fourier state case entangled written tensor product psi gamma iab jbi am gamma am gamma am see computing coefficient formula 
fact matters phases coefficient sides equality equal modulo 
see observe phase jbi left term gammam ab gammam gammai gammaj seen equal modulo delta am gamma am delta gamma am delta phase jbi right term 
apply need gates 
hadamard gate qubit 
second gate gate qubits applies conditioned phase shift qubit qubit state 
denotes phase shift qubit gamma operate gate array ja exp ja gamma exp gamma am 
ja rm gamma rm gamma exp gamma am ja rm gamma rm exp gamma am claim gate array implements ft output reverse order bits 
prove show bit gains phase supposed gain equation 
bit produces state qubits ja ja qubit correct state bit equation ja way phases rest qubits fixed 
simply reverse order bits obtain correct ft note number gates gamma log 
fact gates omitted exponentially close 
omitting gates obtain approximation fourier transform 
kitaev algorithm kitaev algorithm shows approximate efficiently ft cyclic group zq cyclic group group generated element 
generalization abelian group simple described 
sequence operation fourier transform la kitaev jai omega jai omega psi jai omega psi omega psi psi omega important difficult step algorithm third step 
understand perform steps 
gamma 
psi classical operation 
pick integer uniformly random recursive procedure 
gamma denote gamma gamma apply qubit gate gamma 

conditioned bit create gamma bits state psi qx recursively 

jai omega psi jai omega psi achieved applying ja bi gamma 
iab ja bi 
third operation surprisingly difficult part ft sketch idea 

operation merely swapping bits 
apply third step note vectors psi eigenvectors unitary operation jg gamma 
jg generator cyclic group eigenvalues gamma ia operation jai omega psi omega psi reverse computing eigenvalue eigenvector 
need able write eigenvalues unitary matrix 
kitaev proved lemma lemma kitaev unitary matrix qubits applied efficiently 
psi eigenvectors corresponding eigenvalues transformation psi omega psi omega approximated exponential accuracy efficiently 
proof idea lies theorem interference 
eigenvalues phases order gain information phase need compare phase just happens interferometer 
implementation idea setting qubits done adding control qubit 
proceed follows 
apply hadamard transform control qubit separates state paths control qubit state 
applied psi conditioned control qubit 
adds phase paths compared path 
controlled qubit rotated hadamard transform 
diagram captures idea schematically psi phi phi phi phi phi psi gamma 
psi psi gamma 
psi hj hj phi phi phi phi phi psi omega gammae control qubit state gammae qubit biased eigenvalue 
measure qubit behaves coin flip bias gamma idea create control qubits measure 
performing independent coin tosses 
deduce ratio number times got number times got 
apply classical algorithm outcomes measurements 
problems idea 
outcome algorithm classical want create unitary transformation writes eigenvalues applied superpositions 
deal problem 
severe problem algorithm find exponential accuracy polynomially bits exponentially eigenvalues 
achieve exponential accuracy need exponentially coin tosses chernoff inequality exponentially coin tosses required order achieve exponential accuracy 
limited polynomial algorithms deduce polynomial accuracy 
solution problem takes advantage fact powers applied efficiently 
deduce higher accuracy slightly modify interference scheme apply generate set biased qubits deduce polynomial accuracy 
thing done generate sets poly biased qubits 
outcomes measurements th set compute polynomial accuracy 
easy construct polynomial classical algorithm computes exponential precision need polynomial approximations 

left show computation unitary 
idea necessary measure set qubits order count number measuring bits apply unitary transformation counts portion writes portion counting register 
denote number string weight string transformation gamma 
mi resulting state look omega gamma gammaw extra phases 
weight state concentrated strings approximately pm bernoulli experiment 
set control qubits obtain portion written counting register set 
denote portions apply unitary version classical algorithm computes exponentially close approximation portions call procedure jw ijw delta delta delta jw ij gamma 
jw ijw delta delta delta jw ij written register 
denote unitary operation algorithm applies far 
tempting think desired transformation psi omega psi omega true 
exponentially close psi omega omega psi omega omega register consists control qubits qubits computation 
reason fact exactly classical coin tossing exponentially small probability get result far expected number mp 
translates equation appearance exponentially small weight strings far expected number mp 
want ask garbage qubits matter 
qubits carry information longer needed entangled rest computer 
point existence prevent interference computation 
develop tools think interference section roughly garbage effect interaction environment known cause decoherence 
get rid garbage 
problem simply erase garbage setting garbage qubits transformation takes general state unitary 
fortunately case unitary transformation erases garbage 
copy written register extra register initialized state 
copying done bit bit polynomially cnot gates 
apply reverse order reverse transformations done far algorithm cnot gates 
transformation exponentially close sequence operations apply copy apply gamma sequence operation achieves desired transformation garbage psi omega omega omega psi omega omega omega cnot gates psi omega omega omega gamma psi omega omega omega save qubits erasing garbage middle computation longer needed erased qubits register rest computation 
different proof lemma 
concludes fourier transform algorithm 
kitaev procedure writing eigenvalue implies simple alternative factorization algorithm 
way integer factorized done finding order number coprime 
recall order mod consider unitary transformation gamma 
mod ni 
eigenvectors fj exactly linear superpositions configurations subgroup fy coset subgroup gy gy gy appropriate phases psi ija gamma ia ija eigenvalues hold information 
idea apply kitaev lemma write deduce 
start basis state written equal superposition eigenvectors psi easily check 
applying kitaev lemma state get second register eigenvalues written uniform probability 
measure register carries exponentially close approximation divide get exponentially approximation method continued fraction shor algorithm find closest fraction denominator high probability coprime get denominator 
denominator satisfy modn repeat experiment 
summary algorithm factorization la kitaev psi ij apply kitaev transformation psi ij gamma 
psi ij ri psi ij ri measure second register 
classically compute outcome 
factorization viewed finding order elements abelian groups 
people tried generalize shor kitaev algorithms non abelian groups 
conjectured fourier transforms non abelian groups helpful tools complicated operations fourier coefficients complex matrices complex numbers 
step direction discovering efficient quantum fourier transform algorithm non abelian permutations group building classical fft 
motivated old hard problem computer science graphs say isomorphic simply permutation 
problem known np gamma complete best known algorithm exponential 
known fourier transform solving graph isomorphism 
interesting open question efficient quantum fourier transforms done group solve problems 
grover algorithm finding needle haystack grover algorithm surprising counter intuitive sight achieves polynomial quadratic improvement classical algorithms 
deals database search problem 
suppose access unsorted database size looking item satisfies property 
easy check property satisfied 
long take find item exists 
classical computation obviously take steps 
probabilistic classical computation reduce expected steps 
quantum computer find item steps 
algorithm grover 
different representation algorithm mainly geometrical interpretation boyer 
algorithm works follows 
set log define function gamma 
th item satisfy desired property case 
number items 
moment assume 
algorithm operates hilbert space qubits 
main part works subspace dimension space 
subspace spanned vectors jai gamma jii jbi gamma gamma jf jii ae ae ae ae ae ae ae 
jbi jai applying ft generates uniform vector jai hadamard gates 
want rotate vector dimensional subspace spanned jai jbi eventually large projection direction orthogonal jbi exactly item want 
idea rotation angle equivalent reflections respect jai respect jbi 
define boolean function rest 
reflection obtained jii gamma 
gamma jii 
reflection jai achieved ft ffi ffi ft reflect jbi apply transformation jii gamma 
gamma jii 
rotation angle achieved applying grover algorithm apply fourier transform get jai 
apply times 
measure bits 
crucial point satisfies cos gamma large sin rotations high probability measurement yields item satisfying 
note algorithm relies heavily assumption number items 
example number items probability measure item exactly expect probability 
ways generalize algorithm general case number items known 
known classical reduction 
generalization suggested 
suggestion finds item regardless number items gives estimation idea probability measure item periodic function number grover iteration period depends defined way 
period ideas similar shor algorithm fourier transforms 
grover algorithm solve np complete problems time classical simply goes items database 
grover algorithm provides quadratic advantage possible classical algorithm optimal due bennett result discuss dealing quantum lower bounds section 
describe variants grover algorithm grover iteration basic step 
variants refs 

estimating median precision ffl function ng ng extremely large 
ffl want find median allow deviation ffl number items smaller allow exponentially small ffl probability error 
assume large polylog operations considered feasible 
classically means median computed exactly estimated probabilistically 
classical probabilistic algorithm better sample random elements compute median 
error occur half elements chosen ffl items gammaffl items 
events exponentially small probability need ffl samples chernoff law 
quantum algorithm performs task ffl steps 
idea find binary search starting value guess 
estimate precision ffl number jjj items satisfy take ffl steps 
continue binary search 
note information sign simple binary search slight modification 
step reduces possible range factor half search take polylog ffl steps 
estimate jjj ffl steps guess median done 
define basic iteration rotation subspace spanned vectors jffi gamma jii gamma jii vector orthogonal dimensional subspace 
angle jffi sin rotation done grover algorithm 
start jffi rotate ffl times 
angle vector jffi ffl 
project jffi rotating jffi projecting 
result distributed coin flip bias cos ffl 
repeat experiment poly ffl number times 
allow estimate bias cos ffl jjj ffl exponentially small error probability 
estimate jjj ffl ffl time 
estimating mean precision ffl 
function ng gamma assumed large 
ffl want estimate mean precision ffl 
classically take ffl assuming extremely large 
grover suggested quantum algorithm solve problem ffl steps 
showing grover version show simple classical reduction allows solving mean estimation problem median algorithm 
idea boolean functions mean median problems coincide 
write real number gamma binary representation log ffl digits th bit 
boolean functions 
denote mean estimated median algorithm 
mean computed gammaj gammaj cutting number digits causes ffl error estimated precision ffl cause ffl additional error 
finding minimum function ng ng want find minimal 
classically take database sorted 
hoyer show quantum algorithm finds minimum 
done binary search minimum step threshold defines function 
fixed middle interval 
apply grover search find 
find fix new threshold 
fix middle interval 
continue binary search current interval shrunk size number 
minimum 
grover iteration achieve quadratic gap quantum classical communication complexity issue scope review 
gives quantum computers possible extra power ask quantum computers perform tasks hard impossible efficiently classical machines 
delicate question issue debate 
way look question feynman path integrals 
associate diagram computation vertical axis run possible classical configurations horizontal axis time 
example diagram phi phi phi phi phi phi phi gamma omega gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma omega hj hj gamma phi phi phi phi phi phi phi phi phi phi phi phi phi phi gamma omega diagram state initially 
operation applied bit second bit bit 
numbers near edges indicate probability amplitude transform configurations weights gamma corresponds gamma corresponds compute weight basis state final superposition 
weight sum weights paths leading initial configuration final weight path product weights edges path 
quantum prob see diagram weights final superposition zero paths leading states cancel 
learn diagram 
order analyze diagram define classical computation model called stochastic circuits associated similar diagrams 
comparison models quite instructive 
nodes stochastic circuit equal number inputs outputs nodes quantum circuit 
unitary matrices nodes associated stochastic matrices means entries matrices positive reals columns probability distributions 
matrices correspond applying stochastic transformations bits string transforms string probability equal matrix entry example stochastic matrix bit matrix takes input uniformly random bit 
consider probabilistic computation bits apply bit second bit bit 
diagram get phi phi phi phi phi phi phi omega gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma omega hj hj phi phi phi phi phi phi phi phi phi phi phi phi phi phi omega weights edges just quantum computation probability configuration final state computed summing weights paths leading configuration weight path product weights edges participating path 
stochastic prob prob diagram configurations final state probability models similar 
easily seen stochastic circuits equivalent probabilistic tm 
means find advantage quantum computation classical computation difference quantum circuits stochastic circuits 
tempting say quantum computation powerful exponential parallelism 
particles vertical axis run possible classical states 
true diagram stochastic computation bits 
difference quantum classical computations subtle 
reduce difference models shown complex numbers quantum computation replaced real numbers damaging computational power :10.1.1.144.7852
done adding extra qubit entire circuit carry information working real imaginary part numbers 
correspondence superpositions complex circuit real circuit jii gamma 
re ji im ji quantum computers maintain computational power real valued unitary gates 
differences gates stochastic gates 
stochastic gates positive entries real unitary gates positive negative entries 
difference unitary gates preserve norm vectors stochastic gates preserve norm 
difference quantum classical models summarized table quantum stochastic negative norm norm negative numbers important 
fact weights negative allows different paths cancel 
non zero paths leading final configuration cancelling causing destructive interference 
exactly happens deutsch jozsa algorithm simon algorithm shor algorithm paths lead bad strings step algorithm destructively interfering time paths lead strings constructively interfering 
probabilistic case interference occur 
paths talk influence path 
probabilistic computation power lacks power interference offered computation uses negative numbers 
exponential advantage computational power negative numbers familiar classical complexity theory comparing boolean circuits monotone boolean circuits 
computational models exhibit interference optical computers 
models exhibit 
quantum model combines features exponential space explored polynomial time ability interference 
see 
point view origin power quantum computation quantum correlations entanglement 
qubits said entangled state tensor product example epr pair 
system qubits entanglement spread macroscopic range state concentrated pairs particles state 
shown quantum computational power exists entanglement spread particles 
entanglement spread system easily simulated classical computer 
importance entanglement see example jozsa review 
macroscopic spread entanglement lies essence important topic quantum error correcting codes encounter 
quantum computers repertoire algorithms hands tempting try solve quantum computer 
doing worthwhile understand limitations model 
thing know model solve question undecidable classical machine 
simply due fact done model simulated classical machine computing coefficients superposition writing 
take exponential amount time solve done 
difference classical quantum computation lies computational cost 
trivial simulation quantum computers classical machines exponential time space 
bernstein vazirani showed classical turing machines simulate quantum computers polynomial space exponential time theorem bernstein vazirani bqp pspace theorem means done quantum machine done classical machine uses polynomial space :10.1.1.144.7852
prove result look feynman path graph sec 

compute weight path need polynomial space 
run paths leading configuration computing weight adding 
give probability configuration 
compute probability measure add probabilities configurations result bit 
take exponential time polynomial space 
valiant improved result show bqp contained complexity class weaker pspace define :10.1.1.144.7852
quantum computation powerful proof 
particular relation bqp np known 
understand lot question quantum computation efficient classical computation terms number accesses input 
consider accessing input bits problem function oracle applying unitary transformation gamma 
unitary transformation corresponds classical operation asking th bit 
getting answer hope quantum parallelism query oracle superposition gamma 
query oracle algorithm read bits intuitively quantum algorithm needs query oracle 
turns intuition completely wrong 
shown notion von neumann entropy see log bits information state bennett show quantum algorithm supposed compute oracle bits queries needed 
note exactly function computed grover database search 
gives lower bound database search shows grover algorithm optimal 
theorem quantum algorithm computes requires steps 
idea proof number queries oracle small exists index algorithm indifferent distinguish case bits case bits zero 
function algorithm computes contradiction 
generalized result building classical results nisan 
compare minimal number queries oracle needed quantum algorithm minimal number queries needed classical algorithm 
denote minimal number queries classical quantum algorithm respectively 
show polynomial 
theorem similar methods give lower bounds time required compute functions majority parity theta theta parity majority theta theta means behave asymptotically 
lower bounds achieved showing number times algorithm required access input large 
intuitive functions sensitive input bits 
example string satisfies flipping bit give gamma 
meaning results terms number accesses input quantum algorithms polynomial advantage classical algorithms 
polynomial relation give hint looking computational problems quantum algorithms may exponential advantage classical algorithms 
problems property classical algorithm solves bottle neck information processing number accesses input small 
factorization exactly problem 
log algorithm simply needs read number binary representation classical information processing takes exponential log steps 
shor quantum algorithm enables exponential speed information processing 
opposite example database search 
bottle neck classical computation information processing simply fact size input large 
case quantum computers quadratic advantage classical computers 
understand limitations advantages quantum model go subject quantum noise 
worries decoherence precision inaccuracies learning possibilities lie quantum computation gave rise lot enthusiasm physicist time entire field 
reason quantum algorithms achieve advantage classical algorithms assuming gates wires operate inaccuracies errors 
unfortunately reality expect system ideal 
quantum systems particular tend lose quantum nature easily 
inaccuracies errors may cause damage accumulate exponentially fast time computation 
order perform computations able reduce effects inaccuracies errors correct quantum state 
try understand types errors inaccuracies occur quantum computer 
simplest problem gates perform unitary operations slightly deviate correct ones 
shown bernstein vazirani suffices entries gates precise size computation :10.1.1.144.7852
reasonable assume inaccuracies decrease reasonable assume devices laboratory finite precision independent size computation 
errors occur behave presumably law constant probability error element time step 
severe problem decoherence 
decoherence physical process quantum system lose quantum characteristics due interactions environment 
interactions inevitable system kept entirely isolated environment 
effect entanglement environment viewed environment applied partial measurement system caused wave function collapse certain probability 
collapse wave function irreversible process definition 
correct wave function collapsed 
order solve problem correcting effects noise give formal description noise process 
observe general quantum operation system unitary operation system environment 
noise inaccuracies decoherence described form 
formally model noise time steps allow noise operator operate system environment 
assume environment renewed time step correlations noise processes different times 
crucial assumption noise local 
means qubit interacts environment noise process interactions correlations environments 
words noise operator qubits time step written tensor product local noise operators operating qubit omega omega delta delta delta omega qubits correlated time step quantum gate local noise operator operates qubits participating gate 
noise model assumes correlations errors different qubits appear due qubits interacting gate 
qubit interacts environment 
general noise operator qubit general unitary transformation qubit environment je ij je ij je ij je ij qubits interact gate general noise operation general unitary transformation qubit participating gate environments 
dealing noise convenient language density matrices vectors hilbert space 
define explain notion amount noise system rarely review 
density matrix describing system state jffi ae 
density matrix part system derived ae tracing integrating degrees freedom unitary operation environment system corresponds quantum noise viewed linear operator density matrix describing system 
metric density matrices fidelity trace metric exact definition matter 
quantum operations said close operating density matrix generate close density matrices 
say noise rate system local noise operators distance identity map density matrices 
want find way compute fault presence noise rate want assume knowledge noise operators noise rate 
concentrate simple special case computation consists time step computes identity operator qubits 
problem equivalent problem communicating noisy channels 
order understand subtle points trying communicate noisy channels consider classical analogous case 
classical information string bits qubits error model simply bit flips probability suppose alice wants send bob string bits channel noisy noise rate bit flips probability order protect information noise alice redundancy 
sending bits alice encode bits bits say bob apply recovery operation get original bits 
idea approximation bits damaged encoded bits called logical bits recovered 
simplest example classical code majority code encodes logical bit bits 
gamma 
gamma 
classical code corrects error bit flipped majority vote bits recovers logical bit 
bit flipped logical bit longer recovered 
probability bit flip probability bits recovered effective noise rate equals gamma require gain advantage reliability code implies threshold 
threshold code decrease reliability 
majority code extremely non efficient alice wants send long messages 
require bob receives logical bits high probability correct alice exponential redundancy bit 
error correcting codes map bits bits probability bob get original message bits correct high tends infinity 
useful class error correcting codes linear codes mapping bits bits linear set code words image mapping linear subspace code said correct errors recovery operation exists bits flipped 
hamming distance strings defined number coordinates strings differ 
able recover string bit flips occurred implies distance possible code words word corrected uniquely 
subject classical error correcting codes see van lint 
define quantum code similar way 
state qubits mapped state qubits 
term logical state original state qubits 
say code corrects errors exists recovery operation qubits damaged logical state recovered 
important bob control environment qubits interacted noise process 
require recovery operation operate environment merely qubits carrying message qubits 
image map hilbert space qubits called quantum code 
try construct quantum code 
suppose alice wants send bob qubit state encode information 
way simply send classical information describing desired accuracy 
interested way alice wants send bob state qubits amount classical bits needs sent grows exponentially want encode qubits qubits prevent exponential overhead 
simplest idea comes mind alice generates copies state sends state bob gamma 
omega omega bob supposed apply majority vote qubits 
unfortunately quantum majority vote general quantum states linear operation 
simple redundancy 
try quantum analog classical majority code gamma 
code turns bad quantum code 
protect quantum information error 
consider example local noise operator operates qubit encoded state 
qubit changes state environment bit omega gamma 
omega je omega gamma 
omega je je 
identity operation applied bit fact environment changed state bit equivalent environment measuring state qubit 
measurement irreversible process 
noise operation environment longer tensor product state 
bob apply local operations system control environment 
means entanglement state qubit environment broken recovery operation coherence state lost 
theorem due schumacher nielsen formalizes intuition 
claim reduced density matrix environment different different code words unitary operation operates system recovers logical state 
theorem impossible recover logical state information leaked environment noise process 
theorem underlines main distinction quantum error correcting codes classical error correcting codes 
quantum codes try hide information environment contrast protection classical information noise completely orthogonal question hiding secrets 
theorem gives insight basic idea quantum computation idea spread quantum information qubits non local way environment access small number qubits gain information quantum logical state information protected 
intuition requirements quantum codes proceed show construct codes 
correcting quantum noise order succeed correcting quantum noise need consider carefully process noise 
crucial step discovery quantum noise treated discrete 
quantum setting assume qubits undergo noise size want replace case qubits completely damaged rest qubits completely fine 
done rewriting effect general noise operator 
state qubits jffi 
noise rate develop operation general noise operator operating jffi orders magnitude jffi je je je jffi jffi gamma jffi jffi lower orders correspond small number qubits operated higher orders correspond qubits contaminated 
way writing noise operator discretization quantum noise term qubit damaged 
small neglect higher order terms concentrate lower orders qubits damaged special case model probabilistic model local noise operator applies certain operation probability identity operation probability gamma 
model quantum system consists qubits assume high probability qubits went noise process 
noise operators amplitude damping obey probabilistic behavior 
description equation shows treat discrete manner 
second step discretization noise operation 
general quantum operation th qubit environment described je ij je ij je ij je ij operation applied logical state acts operator je ii je gamma ioe je ioe gamma je gamma oe pauli operators acting th qubit oe oe gammai oe gamma environment states defined je sigma je sigma je je sigma je sigma je 
crucial observations enables correct quantum errors hide equation 
observation happen qubit composed basic operations correct errors 
resembles discrete model continuous gives hope discrete errors corrected 
second crucial point states environment entangled system operation noise independent depend operations oe applied 
particular superposition logical states operator look 
suggests scheme breaking entanglement system environment 
idea measure possible operators applied 
called syndrome error 
measuring syndrome collapse system state tensor products system environment je ii je gamma ioe je ioe gamma je gamma measure gamma 
je ii je gamma ioe je ioe je gamma know operators occurred simply apply reverse state recovered 
reduces problem error correction able detect operators occurred 
operator oe corresponds bit flip classical error 
suggests idea superposition encoded state sum strings jii strings classical code bit flips detected applying classical techniques 
correcting noise operator oe phase flip harder important observation oe oe hadamard transform 
phase flips correspond bit flips occurring fourier transform state 
fourier transform state superposition strings classical code enables correction phase flips correcting bit flips fourier transform basis 
idea discovered calderbank shor 
simple version recipe discovered cooking quantum code goes follows 
ae linear classical code corrects errors set strings orthogonal vectors strictly contained look cosets partition non intersecting sets translations form set vectors identification gamma called associate code word gamma 
jw ji wi omit normalization factors 
note strings appear superposition vectors code easy check true fourier transform code words achieved applying hadamard gate qubit omega omega omega jw gamma deltaj jji error correction goes follows 
detect bit flips apply classical error correction classical code states equation 
operation computes syndrome parallel strings writes qubits 
measuring collapse state state specific syndrome compute result measurement qubits affected bit flip apply qubits 
detect phase flips apply fourier transform entire state correct bit flips classically code apply reverse fourier transform 
operation correct phase flips 
oe combination bit flip phase flip corrected sequence error corrections 
number qubits encoded code logarithm base dimension space spanned code words 
calculate dimension observe code words different perpendicular 
dimension quantum code equal number different words dim number qubits encoded quantum code dim 
example due 
code encodes qubit qubits corrects error 
constructed classical code known hamming code subspace spanned vectors spanf 
spanned vectors 
dimension dimension number qubits encode 
code words observe minimal hamming distance words bit flip phase flip corrected 
qubit encoded qubits require error correction general error done 
shown knill 
code called perfect quantum code bennett 
restrict error bit flips phase flips occur qubit encoded qubits 
theory quantum error correcting codes developed 
group theoretical structure discovered known quantum error correcting codes obey 
codes obey structure called stabilizer codes group theoretical structure gives recipe constructing quantum codes 
quantum codes purposes quantum communication noisy channels scope review 
overview subject quantum communication consult refs 

tools deal question quantum computation presence noise discuss section 
fault tolerant computation order protect quantum computation idea compute encoded states 
entire operation occur protected subspace error correction procedure applied ensure errors accumulate 
original quantum circuit replaced quantum circuit operates encoded state 
suppose quantum code encodes qubit block qubits 
new circuit wire replaced wires state new circuit encode state original circuit 
order apply computation encoded states original gates replaced procedures apply corresponding operation 
phi encoding quantum gate phi encoded gate preserves encoding 
words diagram commutative jffi phi jffi phi jffi phi jffi phi phi code phi takes qubit qubits replace quantum circuit circuit operates encoded states circuit ffl qubit gamma 
qubits ffl gate gamma 
phi ffl time steps error correction procedure applied 
naive scheme encounters deep problems 
quantum gates create interactions qubits errors may propagate gates 
small number errors spread qubits error correction recover 
longer assume recovery operation error free 
correction procedure cause damage recovers 
consider example code phi takes qubit qubits 
gate qubits replaced encoded circuit encoded gate phi operates qubits 
consider scenarios encoded gate gate array large connectivity 
error occurred qubit propagate gates qubits 
procedure number damaged qubits large error correction take care 
procedure tolerate error 
see alternative way implement phi error propagate qubit block 
gate encoded error effects qubit block say encoded gate implemented distributively 
damage corrected error corrections 
course error correction procedures implemented distributed manner 
errors generated correction procedure contaminate state 
probably simplest gate implement distributively encoded gate code 
encoded simply achieved applying gate bitwise qubit code 
implementation xor gate applied bitwise network qubits 
gates needs done 
shor showed way implement universal set gates way implementation gates toffoli gate particular require hard additional working qubits 
set universal encoded gates needs error correction procedure encoding procedure computation decoding procedure 
procedures implemented distributively prevent propagation errors 
code accompanied set universal gates encoding decoding correction procedures implemented distributively called quantum computation code 
shor suggestion computation codes 
generalized results showed construct computation code stabilizer code 
encoded circuit reliable 
effective noise rate encoded circuit probability encoded gate suffer number errors corrected 
case error recoverable 
effective noise rate probability errors occur phi 
denote number places implementation phi errors occur 
stands area phi 
probability errors occur bounded simple counting arguments refer bound effective noise rate 
computation size reliable need effective noise rate order code blocks log qubits shor managed show computation reliable polynomial cost 
shor assume small log 
assumption physically reasonable parameter system independent computation size 
reader urged play parameters equation order convinced assuming constant lead polynomially small effective noise rate required 
idea independently groups needed close gap show computation presence constant noise rate finite precision possible 
idea simple 
apply shor scheme recursively gaining small improvement effective noise rate level circuit replaced slightly reliable circuit replaced circuit 
level gains slight improvement ffl final circuit implemented laboratory effective noise rate exponentially smaller gamma 
ffl gamma 
ffl ffl gamma 
ffl number levels recursion applied get polynomially small effective noise rate log log 
cost time space polylogarithmic 
similar scheme context classical self correcting cellular automata 
requirement noise rate improved level imposes threshold requirement satisfies requirement fault tolerant computation achieved 
known threshold result theorem fault tolerance quantum computation length applied efficiently arbitrary level confidence noise rate smaller threshold threshold depends parameters computation code largest procedure area number errors code correct 
estimations range gamma gamma presumably correct threshold higher 
highest noise rate fault tolerance possible known 
rigorous proof threshold theorem quite complicated 
gain insight view final th circuit multi scaled system computation error correction applied scales simultaneously 
largest procedures computing largest highest level blocks correspond operations logical qubits qubits original circuit 
smaller procedures operating smaller blocks correspond computation lower levels 
note level simulates error corrections previous level adds error corrections current level 
final circuit includes error corrections levels computation error corrections larger blocks smaller blocks lower levels corrected 
lower level error corrections level applied correspondence fact smaller blocks quickly damaged 
actual system consists log qubits size original circuit hilbert space hilbert space find subspace isomorphic protected noise 
subspace complicated multi scaled construction small dimensions compared hilbert space system negligible 
subspace protected noise long wish quantum computation done exactly protected subspace 
rate state increases distance subspace corresponds noise rate 
efficiency error correction determines rate distance subspace decreases 
threshold noise rate point distance decreases faster increases 
sense situation viewed operation renormalization group change noise rate renormalization flow 
oe noted proof fault tolerance implicit assumptions 
qubits need middle computation error correction assumed prepared state needed computation 
requires ability cool part system constantly 
shown aharonov operations unitary system keeps warming sense getting noise way cool rate system exponential 
fault tolerant quantum computation requires non unitary gates enables cool qubit 
ability cool qubits implicitly fault tolerant schemes 
point mentioned fault tolerant computation uses immense parallelism gates applied time 
implicit assumption essential 
operation sequential fault tolerant computation impossible shown aharonov ben 
mass parallelism constant supply cold qubits noise rate smaller possible perform fault tolerant computation 
fault tolerance result holds general local noise model defined includes probabilistic collapses inaccuracies systematic errors decoherence compute fault quantum circuits allowed operate nearest neighbor qubits case threshold smaller procedures bigger nearest neighbor interactions allowed 
sense question noisy quantum computation theoretically closed 
question minds assumptions noise correct 
dealing non local noise open challenging problem 
fundamental questions foresee goals achieved quantum computers step evolution computation 
question involves directions research 
negative side far understanding limitations quantum computers computation devices 
possible quantum fourier transforms real powerful tool quantum computation 
tool implies exponential advantage classical algorithms 
strong statement uniqueness fourier transform known 
positive view goal find techniques addition fourier transform 
main directions research quantum algorithms finding efficient solutions number problems known np complete known efficient classical solution 
problem checking graphs isomorphic known graph isomorphism 
important direction quantum algorithms finding algorithms simulate quantum physical systems efficiently 
field quantum complexity infancy 
hand hand complexity questions arise deep fundamental questions quantum physics 
computational power classical systems equivalent quantum complexity light results inherently different 
true quantum systems exponentially better computation devices classical systems give rise new definition quantum versus classical physics lead change way understand transition quantum classical physics 
phase diagram quantum versus classical behavior viewed follows 
quantum classical noise rate changing noise rate system transforms quantum behavior classical behavior 
shown aharonov ben constant bounded away system perform quantum computation 
fault tolerance shows constant bounded away quantum systems exhibit full quantum computation power 
regimes characterized range quantum entanglement quantum regime range macroscopic quantum computation possible 
right classical range entanglement confined microscopic clusters 
interesting question transition regimes occur 
gave indications fact transition sharp characteristics phase transition see 
order parameter corresponds range entanglement size entangled clusters qubits 
unfortunately unable prove existence phase transition presumably lack correct definition order parameter quantifies large scales 
conjecture transition macroscopic quantum behavior macroscopic classical behavior occurs phase transition 
idea transition quantum classical physics abrupt stands contrast standard view gradual transition due decoherence 
believe frontier quantum classical physics better understood gain better understanding transition quantum classical computational behavior 
interesting threshold result dimensional quantum systems exhibit non trivial phase transition critical noise rate mixing time system exponential system mixes rapidly 
phase transition different transition classical quantum behavior 
existence dimensional phase transition interesting dimensional phase transitions rare classical systems exist complicated examples 
vague deeper thought provoking question postulates quantum mechanics 
possibility model realized enable thorough test philosophical aspects quantum theory understanding collapse wave function process measurement elements everyday tools quantum algorithms 
realization quantum computation reveal fact understand quantum physics merely approximation holding small number particles extrapolated particles 
questions appealing motivations extremely challenging task realizing quantum computation model physically 
successes failures achieving ambitious task open new exciting paths possibilities computer science fundamental physics 
acknowledgments am grateful michael ben introduced beautiful subject 
lot fascinating discussions things 
noam nisan taught lot simply asking right questions clear point view 
pleasure know answers 
great fun argue avi wigderson quantum computation things 
special pleasure colleagues peter hoyer ran raz particularly michael nielsen 
read manuscript corrected errors extremely helpful suggestions 
ehud direct indirect contributions review 
abrams lloyd simulation body fermi systems universal quantum computer phys rev lett 
abrams lloyd non linear quantum mechanics implies polynomial time solution np complete problems lanl print quant ph xxx lanl gov adleman huang quantum computability siam journal computation pp october adleman molecular computation solutions combinatorial problems science nov aharonov ben fault tolerant quantum computation constant error proc 
th annual acm symposium theory computing stoc aharonov ben polynomial simulations quantum computers th annual symposium foundations computer science focs pp aharonov kitaev yu nisan quantum circuits mixed states proc 
th annual acm symposium theory computing stoc aharonov ben nisan limitations noisy reversible computation lanl print quant ph xxx lanl gov aharonov beckman chuang nielsen quantum computers powerful 
preprint phys unm science html aspect roger experimental test bell inequalities time varying analyzers phys 
rev lett 
aspect testing bell inequalities europhys 
news 
barahona phys 
vol 
universal bit gate quantum computation proc 
soc 
lond 
dense coding quantum entanglement mod 
opt 
deutsch jozsa conditional quantum dynamics quantum gates phys 
rev lett 
bennett cleve margolus shor sleator elementary gates quantum computation phys 
rev approximate quantum fourier transform decoherence phys 
rev deutsch jozsa stabilization quantum computations symmetrization siam comp effects noise quantum error correction algorithms phys 
rev caves fuchs jozsa schumacher non commuting mixed states broadcast phys 
rev lett nielsen schumacher phys 
rev pp 
quantum computation fourier transform symmetric groups proc 
th annual acm symposium theory computing stoc buhrman cleve de wolf quantum lower bounds polynomials th annual symposium foundations computer science focs beckman efficient networks quantum factoring phys 
rev bell einstein podolsky rosen paradox physics bell problem hidden variables quantum theory rev mod 
phys 
quantum mechanics cambridge university press computer physical systems microscopic quantum mechanical hamiltonian model computers represented turing machines stat 
phys 
quantum mechanical hamiltonian models turing machines stat 
phys 
bennett logical reversibility computation ibm res 
develop 
bennett thermodynamics computation review international journal theoretical physics bennett demons engines second law scientific american november pp bennett time space trade offs reversible computation siam journal computation pp bennett brassard experimental quantum cryptography cryptology pp bennett brassard cr jozsa peres teleporting unknown quantum state dual classical einstein podolsky rosen channels phys 
rev lett 
bennett mixed state entanglement quantum error correction phys 
rev bennett bernstein brassard vazirani strengths weaknesses quantum computing siam journal computation pp october berman holm quantum computer class onedimensional ising systems phys 
lett 
bernstein vazirani quantum complexity theory siam journal computation pp october deutsch jozsa stabilization quantum computation proceedings workshop physics computation los alamitos ieee computer society press brassard quantum challenge structural complexity theory proc :10.1.1.144.7852
seventh annual structure complexity theory conference ieee computer society press los alamitos ca brassard oracle quantum computing proc 
workshop physics computation ieee computer society press los alamitos ca taylor simulating quantum mechanics quantum computer physica pp 
pan experimental quantum teleportation nature boyer brassard hoyer tapp tight bounds quantum searching phys 
pp 
brassard searching quantum phone book science brassard sigact news brassard hoyer tapp quantum algorithm collision problem lanl print quant ph xxx lanl gov brassard hoyer exact quantum algorithm simon problem proceedings th israeli symposium theory computing systems brassard teleportation quantum computation physica brassard dawn new era quantum cryptography experimental prototype working sigact news buhrman cleve van dam quantum entanglement communication complexity lanl print quant ph xxx lanl gov buhrman cleve wigderson quantum vs classical communication computation proc 
th annual acm symposium theory computing stoc calderbank shor quantum error correcting codes exist phys 
rev calderbank rains shor sloane quantum error correction orthogonal geometry phys 
rev lett 
calderbank rains shor sloane quantum error correction codes gf lanl print quant ph xxx lanl gov appear ieee transactions information theory 
chernoff 
see feller probability theory applications wiley new york chuang shor zurek quantum computers factoring decoherence science chuang paz effects loss decoherence simple quantum computer lanl print quant ph xxx lanl gov chuang leung yamamoto quantum codes amplitude damping phys 
rev pp 
chuang yamamoto creation persistent qubit error correction phys 
rev chuang zhou leung lloyd experimental realization quantum algorithm nature church unsolvable problem elementary number theory amer 
math 
quantum computations cold trapped ions phys 
rev 
enforcing coherent evolution dissipative quantum dynamics science kimble quantum state transfer entanglement distribution distant nodes quantum network phys 
rev lett 
son reliable storage information system unreliable components local interactions 
lecture notes mathematics clausen fast generalized fourier transforms theoret 
comput 
sci 
holt horne shimony proposed experiment test local hidden variable theories phys 
rev lett 
cleve buhrman substituting quantum entanglement communication rev pp 
cleve van dam nielsen tapp quantum entanglement communication complexity inner product function lanl print quant ph xxx lanl gov cohen quantum mechanics wiley press new york coppersmith approximate fourier transform useful quantum factoring ibm research report rc cormen leiserson rivest algorithms pp fft primality test extended euclid algorithm rsa cryptosystem mit press cory fahmy nuclear magnetic resonance spectroscopy experimentally accessible paradigm quantum computing proc 
th workshop physics computation complex systems institute boston new england cory fahmy proc 
nat 
acad 
sciences 
cory mass price knill zurek experimental quantum error correction phys 
rev pp 
van dam universal quantum cellular automaton proceedings fourth workshop physics computation deutsch quantum theory church turing principle universal quantum computer proc 
roy 
soc 
lond 
deutsch quantum computational networks proc 
roy 
soc 
lond 
deutsch jozsa rapid solution problems quantum computation proc 
roy 
soc 
lond deutsch universality quantum computation proc 
soc 
lond 
diaconis efficient computation fourier transform finite groups ams communication epr devices phys lett bit gates universal quantum computation phys 
rev quantum computation science quantum gates circuits proceedings conference quantum coherence decoherence december proc 
soc 
london hoyer quantum algorithm finding minimum lanl print xxx lanl gov decision procedure formed linear quantum cellular automata proceeding th ieee symposium foundations computer science random structures algorithms einstein rosen podolsky phys 
rev jozsa quantum computation shor factoring algorithm rev mod 
phys 
quantum error correction communication phys 
rev lett 
proof parity lower bound interesting techniques goldstone gutmann sipser limit speed quantum computation determining parity lanl print quant ph xxx lanl gov feynman simulating physics computers int 
theor 
phys 
feynman quantum mechanical computers 
phys 
see optics news february 
fortnow rogers complexity limitations quantum computation technical report depaul university school computer science fredkin toffoli conservative logic int 
theor 
phys 
freedman logic np quantum field computer preprint ga cs self correcting dimensional arrays randomness computation edited micali vol series advances computing research pages series editor preparata ga cs dimensional self correcting array 
gardiner quantum noise springer verlag berlin garey johnson computers intractability published freeman new york set ropes la barcelona spain 
pictures la futures wharton upenn html computability physical theories quantum cosmos edited zurek van der merwe miller princeton university press gershenfeld chuang bulk spin resonance quantum computation science 
class quantum error correcting codes saturating quantum hamming bound phys 
rev theory fault tolerant quantum computation phys 
rev preprint horne going bell theorem bell theorem quantum theory conceptions universe ed kluwer academic dordrecht griffiths niu semi classical fourier transform quantum computation phys 
rev lett 
pp 
grover quantum mechanics helps searching needle haystack phys 
rev lett 
original stoc fast quantum mechanical algorithm database search proc 
th annual acm symposium theory computing stoc grover framework fast quantum mechanical algorithms lanl print xxx lanl gov grover quantum computers search arbitrarily large databases single query phys 
rev 
grover fast quantum mechanical algorithm estimating median lanl print quant ph xxx lanl gov generation einstein podolsky rosen pairs atoms phys 
rev lett quantum computing dream nightmare 
phys 
today august hughes dyer luther morgan ans quantum cryptography contemp 
phys 
jones hansen implementation quantum search algorithm nuclear magnetic resonance quantum computer nature see jones implementation quantum algorithm solve deutsch problem nuclear magnetic resonance quantum computer chem 
phys 
jozsa entanglement quantum computation appearing geometric issues foundations science eds oxford university press quantum classical correspondence light bell inequalities 
foundations physics july lord kelvin differential analyzer science museum aarhus denmark keyes science kitaev yu quantum computations algorithms error corrections russian math 
kitaev yu quantum measurements abelian problem lanl print xxx lanl gov kitaev 
yu quantum error correction imperfect gates quantum communication computing measurement eds caves plenum press new york 
kitaev yu fault tolerant quantum computation lanl print xxx lanl gov yu 
kitaev private communication knill concatenated quantum codes lanl print quant ph xxx lanl gov knill zurek resilient quantum computation science vol 
knill theory quantum error correcting codes phys 
rev knill zurek resilient quantum computation error models thresholds lanl print quant ph xxx lanl gov knill non binary unitary error bases quantum codes lanl print quant ph xxx lanl gov watrous power quantum finite state automata th symposium foundations computer science focs shih new high intensity source polarization entangled photon pairs phys 
rev lett 
paz zurek perfect quantum error correcting code phys 
rev lett 
landauer quantum mechanics useful 
phil 
trans 
roy 
soc 
london 
landauer ibm res 
dev 
ibm res 
dev volume page 
machines de turing en de equation est un de codes acad 
sci 
leung nielsen approximate quantum error correction lead better codes phys 
rev van lint coding theory springer verlag lipton dna solve np complete problems 
science apr lloyd universal quantum simulators science 
lloyd potentially realisable quantum computer science see science 
lloyd quantum logic gate universal phys 
rev lett 
lloyd capacity noisy quantum channel phys 
rev loss quantum computation quantum dots phys 
rev pp 
sloane theory error correcting codes elsevier science amsterdam dense coding experimental quantum communication phys 
rev lett 

margolus parallel quantum computation complexity entropy physics information santa fe institute studies sciences complexity vol viii ed zurek addison wesley paz factoring dissipative quantum computer phys 
rev paz zurek quantum computation phase drift errors phys 
rev lett 
monroe king demonstration universal quantum logic gate phys 
rev lett 
wave mechanics ff ray tracks proc 
roy 
soc 
london quantum theory measurement edited wheeler zurek princeton univ press princeton nj private communication von neumann probabilistic logic synthesis reliable organisms unreliable components automata studies mccarthy eds nisan szegedy degree boolean functions real polynomials proc 
th annual acm symposium theory computing stoc nielsen chuang programmable quantum gate arrays phys 
rev lett 
palma quantum computers dissipation proc 
roy 
soc 
lond 
papadimitriou computational complexity addison wesley mod 
opt 
special issue quantum communication see context quantum computers speed iterated applications black box lanl print quant ph xxx lanl gov gardiner decoherence continuous observation quantum computing cavity qed model phys 
rev lett 
peres quantum theory concepts methods kluwer academic press dordrecht fault tolerant quantum computation lanl print quant ph xxx lanl gov appear quantum computation edited 
lo popescu quantum computation quantum hall systems phys 
lett 
rabin probabilistic algorithms algorithms complexity new directions results pp 
academic press 
rains hardin shor sloane non additive quantum code phys rev lett 
rivest shamir adleman digital signatures public key cryptosystems mit laboratory computer science technical report mit lcs tr modern quantum mechanics revised edition 
addison wesley schulman vazirani lanl print quant ph xxx lanl gov schumacher nielsen quantum data processing error correction phys rev shamir factoring numbers log arithmetic steps information processing letters 
shannon mathematical theory communication bell syst 
tech 
shor polynomial time algorithms prime factorization discrete logarithms quantum computer siam comp pp october shor scheme reducing decoherence quantum computer memory phys :10.1.1.144.6148
rev 
shor fault tolerant quantum computation proceedings th symposium foundations computer science pages los alamitos california 
ieee press 

shor quantum analog identities classical coding theory phys 
rev lett 
simon feasible numbers proc 
th annual acm symposium theory computing stoc simon power quantum computation siam comp pp october simon private communication 
solovay yao preprint multiple particle interference quantum error correction proc 
roy 
soc 
london 
error correcting codes quantum theory phys 
rev lett 
simple quantum error correcting codes phys 
rev quantum reed muller codes submitted ieee trans 
inf 
theory preprint lanl print quant ph xxx lanl gov active stabilization quantum computation quantum state synthesis phys 
rev lett 
ion trap quantum information processor appl 
phys 
space time parallelism noise requirements reliable quantum computing 
phys 
stern aharonov phase uncertainty loss interference general picture phys 
rev 
interference back reacting environment quantum coherence ed 
anandan world scientific 
herzog experimental demonstration quantum correlations kilometers phys 
rev toffoli reversible computing automata languages programming seventh colloquium lecture notes computer science vol 
de bakker van leeuwen eds springer hood lange kimble measurement conditional phase shifts quantum logic phys 
rev lett 
turing computable numbers application proc 
lond 
math 
soc 
ser 
see proc 
lond 
math 
soc 
ser 
unruh maintaining coherence quantum computers phys 
rev 
valiant unpublished valiant negation exponentially powerful 
theoretical computer science november 
valiant vazirani np easy detecting unique solutions 
theoretical computer science quantum networks elementary arithmetic operations phys 
rev steiglitz dickinson complexity analog computation math 
comput 
simulation pp 

warren science 
watrous dimensional quantum cellular automata complex systems pp simulations body quantum systems quantum computer lanl print quant ph xxx lanl gov wheeler zurek eds quantum theory measurement princeton univ press princeton nj wigderson private communication zurek single quantum cloned nature measure distinguishability quantum states quantum optics general relativity measurement eds pierre plenum press new york yao quantum circuit complexity th annual symposium foundations computer science focs pp 
efficient simulation quantum systems quantum computers proc 
roy 
soc 
london press lanl print quant ph xxx lanl gov grover quantum searching algorithm optimal lanl print quant ph xxx lanl gov zurek decoherence transition quantum classical physics today october 

