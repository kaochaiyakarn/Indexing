new approach generic functional programming ralf hinze institut fur informatik iii universitat bonn bonn germany mail ralf informatik uni bonn de homepage www informatik uni bonn de ralf describes new approach generic functional programming allows define functions generically datatypes expressible haskell 
generic function defined induction structure types 
typical examples include pretty printers parsers comparison functions 
advanced type system haskell presents real challenge datatypes may parameterized types type constructors type definitions may involve mutual recursion recursive calls type constructors arbitrarily nested 
show despite complexity generic function uniquely defined giving cases primitive types type constructors disjoint unions cartesian products 
information generic function specialized arbitrary haskell datatypes 
key idea approach model types terms simply typed calculus augmented family recursion operators 
conceptually simple approach places high demands type system requires polymorphic recursion rank types strong form type constructor polymorphism 
point connections haskell class system show approach generalizes type classes respects 
programming challenge nuisance 
recurring routine tasks changing representation data converting internal representation human readable form pretty printing vice versa parsing fall category 
domain generic programming aims relieving programmer repeatedly writing functions similar functionality different user defined datatypes 
generic functional program essentially collection type indexed values typically functions defined induction structure types 
generic function pretty printer parser written times specialization different instances datatypes happens appear th annual acm sigplan sigact symposium principles programming languages popl boston massachusetts january copyright fl association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
effort user 
way generic programming greatly simplifies construction maintenance software systems automatically adapts functions changes representation data 
different approaches generic functional programming differ way structure datatypes modelled 
language extension polyp instance initial algebra semantics datatypes 
unfortunate consequence choice class datatypes restricted called regular datatypes 
regular datatype parameterized type definition contains function spaces recursive calls involve change type parameter 
compared class datatypes definable haskell polyp covers small important subset 
great 
especially importance generic programming increases complexity types 
get know involved datatypes skilled haskell programmer experience considerable trying implement say comparison functions types 
admittedly haskell rich type system presents real challenge implementors generic programming extensions datatypes may parameterized types type constructors type definitions may involve mutual recursion recursive calls type constructors arbitrarily nested 
aim extending generic programming full type system haskell advised model datatypes closely faithfully possible 
haskell supports type application implicit form type abstraction type terms correspond essentially terms simply typed calculus augmented family recursion operators additional constants denoting primitive types integers primitive type constructors disjoint unions cartesian products 
types type terms described called kinds 
haskell type system quite involved defining generic values comparatively easy 
see generic value uniquely defined giving cases primitive types primitive type constructors 
information generic value specialized arbitrary haskell datatypes 
interestingly process specialization seen interpretation simply typed terms 
main contributions 
explain define values indexed types type constructors order kind 
show specialize generic values concrete instances datatypes 
identify program ming language features required translation 
point connections haskell type classes show approach generalizes type classes respects 
rest organized follows 
sec 
introduces haskell type system means examples 
sec 
sketches approach generic functional programming 
sec 
introduces simply typed calculus explicit datatypes modelled terms 
sec 
shows define type indexed values explains specialize type indexed value concrete instances datatypes 
sec 
generalizes approach type constructors order kind 
sec 
works encoding instances generic values haskell relates definitions type classes 
sec 
reviews related sec 
concludes 
haskell type system section introduces main features haskell type system means examples 
important understand examples full detail 
purpose section demonstrate expressiveness haskell type system give evidence real features 
simple examples consider datatypes lists rose trees 
data list nil cons list data rose branch list rose equations introduce type constructors list rose kind 
kind system haskell specifies type type constructor 
kind represents nullary constructors int kind represents type constructors map type constructors kind kind kind system necessary haskell supports abstraction type constructors arbitrary kind 
generalization rose trees illustrates feature 
data grose grose slight variant definition extend implementation priority queues efficient merge operation 
type constructor grose kind 
related rose grose list rose note equation states isomorphism equality haskell type system name equivalence structural equivalence 
furthermore note grose secondorder kind 
order kind order 
order maxf order order definition introduces fixpoint operator level types 
definition appears instance employed give generic definition called cata anamorphisms 
data fix fix data nil cons kinds types fix 

note binary type constructors fact curried 
fix datatype polymorphic lists alternatively defined list fix 
type terms right hand side datatype definitions may arbitrarily nested 
equations implement binary random access lists exemplify nested type terms involving recursion 
data fork node data sequ empty zero sequ fork sequ fork type parameter sequ changed recursive calls sequ termed nested non regular datatype 
nested datatypes practically important capture data structural invariants way regular datatypes 
instance sequ captures invariant binary random access lists sequences perfect binary leaf trees stored increasing order height 
refer interested reader examples nested types 
equations employ abstraction type constructors nested recursion 
data data types 
represent called generalized tries fork sequ type constructor type level counterpart function twice applies function twice value 
example nested datatype secondorder kind 
type square square nil data square zero succ square cons data nil nil data cons cons type constructors kinds square nil 
square cons 
type square implements square theta matrices 
contrast common representations lists lists constraint automatically enforced type system 
examples nested types higher order kinds 
going reader invited consider programming say comparison functions datatypes 
non trivial task especially nested second order kinded types 
sequel show defining generic comparison function works datatypes surprisingly simpler task 
generic programming nutshell section sketches main ideas approach generic functional programming primarily programmer perspective 
formal treatment approach deferred sec 
sec 

explaining define type indexed values take closer look datatype definitions 
haskell data construct combines features single coherent form type abstraction ary disjoint sums ary cartesian products type recursion 
rewritings list grose structure datatype definitions explicit 
list theta list grose theta grose denotes unit type theta conventional notation binary disjoint sums binary cartesian products 
simplicity assume ary sums reduced binary sums ary products binary products 
treat theta datatype declarations 
data data inl inr data theta define type indexed value suffices specify cases primitive types say int primitive type constructors say theta 
example equations define generic function encodes elements type bit strings implementing simple form data compression 
type argument enc written angle brackets distinguish value argument 
type bin bit data bit bin inl inr theta type signature enc explicit type depends type parameter equation inevitable 
encode single element unit type bits required 
integers encoded primitive function existence assume 
encode element disjoint union emit bit constructor followed encoding argument 
encoding pair concatenation component encodings 
simple definition contains ingredients needed derive specializations compressing elements arbitrary datatypes 
instance inti type sequ int bin compresses random access lists integer elements list inti compresses generalized rose trees integer labels 
generic values directly implemented haskell standard ml 
reason simply value depends type value type dependencies expressed current functional languages 
circumvented problem encodings universal datatype dynamic types definition enc exhibits theta worst case behaviour easy remedy 
typecase result inefficient enc repeatedly interpret type argument :10.1.1.39.8178
specializing remove interpretative layer 
aside argue value type dependencies second order calculus polymorphic function depends type argument supplied 
dependence quite loose polymorphic function uses algorithm type 
note function type bit necessarily constant function simple consequence parametricity theorem 
order specialize simply unfold partially evaluate definition enc 
see consider specializing inti define inti require fork int 
simply unfold definition general obtain finite representation 
key idea specialization mimic structure types value level 
instance inti compositionally defined terms specializations constituent types say sequ function types consequently function encoders 
encoder type application sequ int application nutshell type abstraction mapped value abstraction type application value application type recursion value recursion 
exemplify grose fork sequ automatically derive specializations clarity original constructor names 
bin 
bin 
bin 
grose bin enca ts enca enca ts bin 
fork bin enca node enca enca bin 
sequ bin enca empty enca zero enca enca enca enca types functions motivated explained sec 

list processing functions generalized arbitrary datatypes 
consider instance polymorphic function length list int computes length list 
length size function defined rose trees random access lists datatypes 
recipe defining functions simple case count number elements type value type suggests able program generic function sizehf int works note type signature size involved signature enc size indexed type constructor kind 
type kind 
type size ensures determine size list rose tree haskell syntax universal quantification 
clarity write quantification explicitly giving type functions 
size boolean integer 
order define sizehf generically explicate structure type functions kind 
lift primitive type constructors int theta function level 
int int theta theta note kind 
lifted version kind 
interestingly type constructor kind 
expressed terms int theta identity type id claim justified sec 

sizehf uniquely defined equations 
sizehf 
int sizehf inl sizehf sizehf inr sizehf sizehf theta sizehf sizehf equations inevitable 
value type id contains exactly element type values type int int contain elements type determine size structure type calculate size structure type structure type depending component disjoint sum argument comes 
size structure type theta sum size components 
specializing size concrete instances datatypes works essentially 
instance list grose obtain specializations 
int 
list int sizea nil sizea cons xs sizea sizea xs int 
int 
int 
grose int sizea ts sizea sizea ts definitions rigidly follow structure types list function types transforms size functions size functions 
precisely sizea determines size structure type sizea determines size structure type list typings explained thoroughly sec 

obtain length function lists simply pass size function id likewise determine size structure type say grose list call kinds types section introduces kind type terms 
kind terms formed grammar 
agree associates right 
fixed set type variables fixed set primitive type constructors int theta type terms formed grammar 
denotes type application denotes type abstraction denotes fixpoint agree type application associates left type abstraction extends far right possible 
abbreviate delta delta delta xm write similarly theta 
note abstraction bound type variable annotated kind 
reasons readability usually omit kind annotation 
furthermore note choice arbitrary require primitive types order kinds kind see sec 

instance additionally include function space constructor 
omitted generic functions sensibly defined function space 
kinds primitives int 
theta 
kinds type terms determined rules depicted fig 

notation gamma means statement derivable set kind assumptions gamma 
delta delta delta 
derivable say arity worth mentioning polymorphic respect kinds represents family fixpoint operators 
essence haskell types represented terms simply typed calculus kinds playing role types 
translation datatype declarations sec 
type terms fairly straightforward 
examples 
list 
theta fork theta sequ fork theta fork order kinded regular types list rose modelled fixpoint operator kind 
nested types sequ require operator kind 
type recursion expressed fixpoint operator 
whilst sufficient datatype definitions introduced sec 
generalize easily handle mutually recursive types 
viable alternative consider systems recursion equations xn type variables type terms 
approach generic programming works equally recursion equations fixpoint operator 
development verbose provides additional insights 
gamma gamma gamma gamma gamma gamma gamma gamma gamma kind rules 
sections require notion bohm tree introduce 
bohm trees considered kind infinite normal form type terms obtained unwinding type terms ad infinitum 
definition convertibility relation type terms denoted axioms fi free plus usual logical rules reflexivity symmetry transitivity congruence 
definition head normal form hnf type term form xm un arity type term hnf hnf 
definition hnf bit unusual additionally require expanded order guarantee bohm trees defined 
term instance hnf type term hnf consider instance 
type terms hnf sense pointless excluded simple syntactic restriction adopt sequel form xm un arity definition bohm tree type term denoted bt labelled tree defined follows hnf xm un bt xm bt delta delta delta bt formal treatment bohm trees refer reader 
generic programming point view identify type terms bohm trees bt bt 
instance rose grose fix 
generic values defined induction structure types structure matters 
type indexed values framework developed steps characterize set normal forms types kind give prototype generic values indexed types kind show promote generic value defined types arbitrary kind 
normal forms types kind types kind simple normal form 
consider bohm tree type kind 
clearly root tree labelled type abstraction 
labelled primitive type constructor say arity root direct successors 
normal form type terms kind described grammar 
int theta 
understood 
contains type terms kind 
set type trees finite infinite formed grammar denoted 
defining indexed values characterization normal forms motivates prototype type indexed values 
poly poly int poly theta poly theta poly name type indexed value type variables kind poly poly int poly poly theta ingredients supplied generic programmer 
type type constructor kind 
type index may contain function types universally quantified types poly values types poly poly int int poly poly theta theta cases universally qualified poly poly theta possible argument types 
instructive see example sec 
maps formalism type bin functions enc enc int enc enc theta enc enc int enc enca enca inl enca enc enca enca inr enca enc theta enca enca enca enca definition type indexed values inductive structure 
equation primitive type constructor 
standard result theory infinite trees guarantees generic value poly possesses unique extension 
sense poly uniquely defined action primitive type constructors poly poly int poly poly theta proceed take look examples type indexed values 
example dec essentially inverse enc takes bit string decodes prefix string returns decoded value coupled unused suffix 
formally functions related bs bs 
bin 
bin bs bs bs bs error dec bs bs bs inl bs bs bs bs inr bs theta bs bs bs bs bs bs functions enc dec seen simple printers parsers 
pretty printers parsers produce process human readable format implemented give generic programmer additionally access constructor names 
extension define haskell show function generic way 
comparison functions typical examples values 
program realizes haskell compare function determines precise ordering elements 
data ordering lt eq gt ordering eq inl inl inl inr lt inr inl gt inr inr theta helper function equation implements lexicographic product orderings 
ordering ordering ordering lt ord lt eq ord ord gt ord gt specializing indexed values purpose generic value specialized 
discussed key idea promoting generic value types arbitrary kinds type abstraction interpreted value abstraction type application value application type recursion value recursion 
promoted version poly deltai denote consequently tacitly assume predefined functions satisfy relationship 
equations 
ii hht ii poly ii ii ii tii fix ranges environments map type variables value variables syntax extending environment binding function fix polymorphic fixpoint operator value level 
definition inductive structure type terms 
fact view definition interpretation simply typed calculus 
generic value poly deltai related ii ffl ffl denotes empty environment 
order specialize simply specialize 
note eq 
seen soundness condition specialization 
remains specify hht ii defined induction structure kinds 
ii ii hhx ii ii type constructor kind function maps values type hhx ii values type ii important universally quantified may applied different types 
nesting universal quantifiers dictated kind order ii rank type assuming rank 
instance bin 
ii hhf 
ii 
ii ii hhf ii 
hha ii ii 
grose bin 
bin 
bin 
grose bin grose order kind rank type 
consider examples 
fig 
lists specializations enc datatypes introduced sec 

clarity definitions original constructor names functions written equational style 
specializations illustrate interesting points 
instance function polymorphic recursion recursive call type fork bin 
sequ fork bin substitution instance declared type 
general polymorphic recursion required type recursion nested 
functions rank type signatures shows nutshell necessary argument applied different instances inner call type bin 
bin outer call type bin 
bin 
functions combine polymorphic recursion specialized polymorphic argument 
bin 
list bin enca nil cons xs enca xs bin 
rose bin enca encr encr branch ts enca encr ts bin 
bin 
bin 
grose bin enca ts enca ts bin 
bin 
fix bin encr encr encr bin 
bin 
bin enca nil enca cons enca bin 
fork bin enca node enca enca bin 
sequ bin enca empty enca zero enca enca enca enca bin 
bin 
bin 
bin tf tf bin 
bin 
bin 
bin te tz te tz bin 
square bin enca enca bin 
bin 
bin 
square bin enca zero enca enca succ enca bin 
nil bin enca nil bin 
bin 
bin 
cons bin enca cons xs enca enca xs specializing enc types sec 

values indexed order kinded types previous section considered values indexed types kind 
values indexed type constructors size additional machinery needed 
develop main ideas type indices kind 
straightforward extension order kinds explained sec 

sec 
discusses difficulties extending approach higher order kinds 
proceed previous section characterize set normal forms types kind 
give prototype generic values indexed types kind show promote generic value types arbitrary kind 
normal forms types kind 
recall type constructor kind 
function types kind 
consequently defining 
indexed values type patterns range functions 
appears functions conveniently expressed lift types function level 
formally lifting maps type type defined follows 

lifted version type assume type variable kind lifted variable named kind lifted versions primitive type constructors defined sec 

lifted version list instance reads list 
theta expanding lifted primitives obtain list 
theta lifted version type closely related kind 
id relation employed define poly deltai terms 
notion lifting easily characterize set normal forms types kind 
assume type kind 
applying expansion body abstraction kind know previous section shape normal form 
free variable treated additional constant kind 
passing explicit 
abstraction process replaces primitive type constructors lifted versions id motivates characterization 

id int 


theta 
fact view id int theta tiny combinator language defining type constructors kind 
defining 
indexed values characterization normal forms suggests prototype values indexed types kind 

poly id poly poly int poly theta poly theta type type constructor kind 
prototype 
indexed values nearly identical prototype indexed values primitive type constructors merely replaced lifted versions additional case identity type 
consider example sec 
fits scheme sizehf type int functions size id size size int size size theta size id size size int size sizea sizea inl sizea size sizea sizea inr sizea size theta sizea sizea sizea sizea note sizehf generic polymorphic function 
combination cogent generic function sums structure integers monomorphic type int int rest section examples generic values 
paradigmatic example 
indexed value probably map applies function element type structure type maphf 

ti maphf inl inl maphf maphf inr inr maphf maphf theta maphf maphf note type pattern covers int furthermore note haskell provides class functor mapping functions 
alas user program instances functor hand part tedious quite involving 
function size instance general concept termed reduction crush 
reduction function type collapses structure values type single value type define reduction require ingredients value binary operation op usually necessarily neutral element op 



op ti op op inl op op inr op theta op op op op number useful functions defined terms maphf see instance 
specializing 
indexed values promoting poly deltai types arbitrary kind proceeds exactly working function level lifted kinds types 
type promoted version hh inductively defined follows 
ii ii hhx ii ii promoted version poly deltai reads ii hht ii poly ii ii ii ii tii fix note depends poly poly id value defining poly deltai terms 


ii ffl poly id order specialize specialize tii defined induction structure lifted types 
resulting function type 
supplying poly id argument obtain value type id equal view eq 
soundness condition specialization 
practical problem remains type uses lifted types 
consider instance type signature 
int 
list int intend specialized program haskell compiler find way expressing list terms list type constructors kind 
relationship quite simple instance list list list equals type composition list delta relation rewrite type signature 
int 
list int general case delve bit theory combinators 
require type level counterparts combinators 
relate types kind types kind 
definition relation theta 
defined induction structure kinds 
base case 
relates types kind require equal 
type functions related related arguments mapped related results 
proposition type kind types kind lifted version simply ignores additional argument comes little surprise 
types kind 
prop 
implies delta setting id obtain id shows eq 
direct consequence prop 

apply prop 
rewrite type signature say int 
int 
fix int second order type fix prop 
reads 
fix fix relationship replace fix type signature 
ii int 
int 
fix int note rewrite involves change bound variable kind 
replaced kind 
change perfectly fine instantiated lifted types construction know prop 
lifted types kind expressed terms original types 
words consistently change types functions resulting program typed 
high time consider examples 
fig 
lists specializations size datatypes sec 

code looks pretty similar code generated enc see fig 

surprising code generation completely independent kind type index 
types involved size rank type ii assigned rank type order kind 
sec 
discussed features type system host language support rank types polymorphic recursion 
require additional feature strong form type constructor polymorphism 
consider call sizea definition requires argument type int sizea type fork int determine call typed solve equation fork 
setting fork call definition type checked 
clearly kind higherorder unification required 
unfortunately know practical language supports feature 
haskell instance uses kinded order unification reduces fork fork equation solvable 
lack type constructor polymorphism noted suggests generalizing haskell type system worthwhile 
problem disappears switch language explicit type annotations 
suitable candidates intermediate language glasgow haskell compiler secondorder calculus language henk barendregt cube 
int 
list int sizea nil cons xs sizea xs int 
rose int sizea branch ts sizea ts int 
int 
int 
grose int sizea ts sizea ts int 
int 
fix int int 
int 
int sizea nil sizea cons sizea int 
fork int sizea node sizea sizea int 
sequ int sizea empty sizea zero sizea sizea sizea sizea int 
int 
int 
int tf tf int 
int 
int 
int te tz te tz int 
square int sizea sizea int 
int 
int 
square int sizea zero sizea sizea succ sizea int 
nil int sizea nil int 
int 
int 
cons int sizea cons xs sizea sizea xs specializing size types sec 

generalizing order kinds far considered generic values indexed type constructors kind 
generalization type indices order kind straightforward 
assume type index kind abbreviates 
delta delta delta 
times 
redefine lifting put case specializes preceding treatment 
lifted version primitive type constructor arity fm define value indexed type kind 
programmer provide cases lifted primitive type constructors additionally projection types id 
specializing generic value works exactly initial call uses poly 
poly 
ii ffl poly poly limitations approach briefly discuss difficulties extending generic programming higher order kinds 
interestingly approach works type indices second order kind 
example consider generic value indexed type constructor kind 
characterize set normal forms proceed expanding type kind obtain body abstraction kind normal form characterized usual way variables 
simply treated additional constants 
abstracting yields grammar 

int 


theta 
lifted type constructors defined sec 

type patterns 
indexed values similar ones order case projection types slightly complicated 
unfortunately scheme breaks third level 
illustrate consider type kind 

normal form described grammar 

int 


theta 
note 
refers 
means generic value indexed type constructor kind inductively defined structure types 
similar reasons set primitive type constructors contain types second order kind higher 
see assume fix 
primitive 
fix argument type constructor longer define generic values inductively instance fall back kind 
summarize approach limited type indices secondorder kinds primitive types order kinds 
restrictions severe practice remains seen 
suspect case 
stress restrictions affect ability specialize generic values works types arbitrary kinds 
haskell specialization generic values described sec 
places high demands type system requires polymorphic recursion rank types strong form type constructor polymorphism 
haskell instance supports polymorphic recursion 
section show requirement rank types alleviated encoded called dictionaries 
encoding provides interesting link haskell type classes 
extensions haskell implemented ghc hugs provide rank type signatures local universal quantification datatypes 
feature circumvent rank types 
idea simple passing polymorphic value directly argument pass dictionary contains value single component 
course require single dictionary kind indexed family dictionaries 
definitions introduce suitable dictionaries enc function 
type bin type data promoted function ii type fig 
displays specializations enc types 
dictionary translation interesting respects 
suggests easy way dealing mutually recursive generic definitions see examples 
simply dictionaries multiple entries recursive function 
second relates generic definitions haskell type classes similar implementation 
recall overloaded function translated non overloaded function takes additional argument dictionary containing operations class 
instance class definition class eq bool gives rise dictionary type 
data eqd bool instance declaration form instance eq defines element eqd declaration form instance eq eq defines function type eqd eqd 
generic definitions type classes mechanism implementation level 
deriving construct instance declarations automatically generated user defined order kinded datatypes 
instance declarations limited handle types higher order kinds 
instance deriving eq fails compile time error haskell 
generic definitions generalize type classes respects allow define values generically types class instances programmed hand predefined classes eq specialization restricted order kinded types 
note instance declarations mimicked framework called ad hoc definitions see 
instance ad hoc compression scheme lists yields better compression rates generic scheme defined ai xs length xs concat map xs equation extends definition enc sec 
specifies exception general scheme 
related generic programming concept generic functional programming trades variety names refers concept structural polymorphism sheard calls generic functions type parametric jay term shape polymorphism harper morrisett coined phrase intensional polymorphism jeuring invented word 
mainstream generic programming initial algebra semantics datatypes see instance puts emphasis general recursion operators map catamorphisms folds 
variations operators informally defined algorithms specialize functions datatypes 
programming language charity automatically provides map catamorphisms user defined datatype 
general recursion available charity strongly normalizing 
functorial ml similar functionality different background 
theory shape polymorphism values separated shape contents 
polytypic programming language extension polyp mentioned offers special construct defining generic functions 
generic definitions similar modulo notation generic programmer additionally consider cases type composition type recursion see detailed comparison 
approaches restricted order kinded regular datatypes subsets class 
notable exception presents higher order language type system related type recursion missing 
genericity achieved type patterns interpreted run time 
contrast technique require passing types representations types run time 
distinguishes approach intensional polymorphism typecase defining type dependent operations 
regarded successor similar approach restricted order kinded types 
companion contains concrete proposal generic programming extension haskell theoretical framework developed 
type systems variations type system sec 
described literature see survey article 
instance drop fixpoint operator type language obtain system forms corner barendregt cube 
dropping type application abstraction yields system supports structural equivalence types 
system restricted types kind handle parametric types 
best author knowledge combination polymorphic fixpoint operator original 
type inference algorithms languages generic constructs developed jay jansson jeuring 
note system permit type reconstruction general 
consider expression size xs xs type list rose int 
size count number integers number rose trees list 
new approach generic functional programming simpler generic programmer point view considerably general previous complete type system haskell covered previous approaches limited order kinded regular types 
basic idea model types terms simply typed calculus augmented family recursion operators 
specializing generic value seen interpretation simply typed terms 
generated code places high demands type system underlying language polymorphic recursion rank types strong form type constructor polymorphism required 
shown rank types circumvented dictionary translation provides interesting link haskell type classes 
particular generic definitions generalize haskell deriving construct 
am grateful ian johan jeuring lambert meertens fritz suggesting dozens improvements regarding contents presentation 
due anonymous referees detailed helpful comments 
abadi cardelli pierce emy :10.1.1.39.8178
dynamic typing polymorphic languages 
journal functional programming january 
barendregt 
lambda calculus syntax semantics 
north holland amsterdam new york oxford revised edition 
barendregt 
lambda calculi types 
abramsky dov gabbay maibaum editors handbook logic computer science volume background computational structures pages 
clarendon press oxford 
richard bird 
functional programming haskell 
prentice hall europe london nd edition 
data bin data 


bin 

grose bin df da ts enc 
da enc 
df ts 
fork bin da node enc 
da enc 
da 
sequ bin da empty da zero da da enc 
da 
da dictionary implementation enc 
richard bird lambert meertens 
nested datatypes 
jeuring editor fourth international conference mathematics program construction mpc sweden volume lecture notes computer science pages 
springerverlag june 
richard bird ross paterson 
de bruijn notation nested datatype 
journal functional programming january 
richard bird ross paterson 
generalised folds nested datatypes 
formal aspects computing 
robin cockett tom fukushima 
charity 
yellow series report dept computer science univ calgary june 
bruno courcelle 
fundamental properties infinite trees 
theoretical computer science march 
karl crary stephanie weirich greg morrisett 
intensional polymorphism type erasure semantics 
acm sigplan notices 
jean yves girard 
interpr etation fonctionelle elimination des coupures dans arith etique ordre sup erieur 
phd thesis universit paris vii 
hagino 
category theoretic approach data types 
phd thesis university edinburgh 
cordelia hall kevin hammond simon peyton jones philip wadler 
type classes haskell 
acm transactions programming languages systems march 
robert harper greg morrisett 
compiling polymorphism intensional type analysis 
acm editor conference record nd acm symposium principles programming languages popl san francisco california pages 
acm press 
ralf hinze 
numerical representations higher order nested datatypes 
technical report iai tr institut fur informatik iii universitat bonn december 
ralf hinze 
generalizing generalized tries 
journal functional programming 
accepted publication 
ralf hinze 
generic programming extension haskell 
erik meijer editor proceedings rd haskell workshop paris france september 
proceedings appear technical report universiteit utrecht uu cs 
ralf hinze 
manufacturing datatypes 
chris okasaki editor proceedings workshop algorithmic aspects advanced programming languages paris france pages september 
proceedings appear technical report columbia university cucs available www cs columbia edu html 
ralf hinze 
polytypic functions nested datatypes 
discrete mathematics theoretical computer science 
ralf hinze 
polytypic programming ease extended 
th fuji international symposium functional logic programming flops tsukuba japan lecture notes computer science 
springer verlag november 
appear 
patrik jansson johan jeuring 
polyp polytypic programming language extension 
conference record th acm sigplan sigact symposium principles programming languages popl paris france pages 
acm press january 
patrik jansson johan jeuring 
polylib library polytypic functions 
roland backhouse tim sheard editors informal proceedings workshop generic programming sweden 
department computing science chalmers university technology goteborg university june 
patrik jansson johan jeuring 
polytypic compact printing parsing 
doaitse swierstra editor proceedings european symposium programming esop volume lecture notes computer science pages berlin 
springerverlag 
jay bell moggi 
functorial ml 
journal functional programming november 
jay 
shapely types shape polymorphism 
editor programming languages systems esop th european symposium programming edinburgh uk proceedings volume lecture notes computer science pages berlin april 
springerverlag 
johan jeuring patrik jansson 
polytypic programming 
launchbury meijer sheard editors tutorial text nd international school advanced functional programming wa usa volume lecture notes computer science pages 
springer verlag 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
journal functional programming january 
mark jones 
functional programming overloading higher order polymorphism 
international spring school advanced functional programming techniques volume lecture notes computer science pages 
springer verlag 
jones peterson 
hugs user manual may 
available www haskell org hugs 
nancy jean mccracken 
typechecking programs implicit type structure 
gilles kahn david macqueen gordon plotkin editors semantics data types international symposium france volume lecture notes computer science pages 
springer verlag 
lambert meertens 
calculate 
swierstra editors proceedings th international symposium programming languages implementations logics programs plilp aachen germany volume lecture notes computer science pages 
springer verlag september 
erik meijer graham hutton 
bananas space extending fold unfold exponential types 
conference record th acm sigplan sigarch ifip wg international conference functional programming languages computer architecture fpca la jolla san diego ca usa pages 
acm press june 
alan mycroft 
polymorphic type schemes recursive definitions 
paul robinet editors proceedings international symposium programming th colloquium toulouse france volume lecture notes computer science pages 
chris okasaki 
purely functional data structures 
cambridge university press 
chris okasaki 
fast exponentiation square matrices adventure types 
peter lee editor proceedings acm sigplan international conference functional programming paris france pages september 
simon peyton jones 
explicit quantification haskell 
available research microsoft 
com users simonpj haskell quantification html 
simon peyton jones john hughes editors 
haskell non strict purely functional language february 
available www haskell org definition 
simon peyton jones 
compiling haskell program transformation report 
hanne riis nielson editor programming languages systems esop th european symposium programming linkoping sweden april volume lecture notes computer science pages 
springer verlag 
simon peyton jones erik meijer 
henk typed intermediate language 
proceedings types compilation workshop amsterdam june 
available www cs bc edu muller tic fritz 
structural polymorphism 
roland backhouse tim sheard editors informal proceedings workshop generic programming sweden june 
dept computing science chalmers univ techn 
goteborg univ june 
karl fritz 
analytical structural polymorphism expressed patterns types 
phd thesis university michigan 
tim sheard 
automatic generation structure operators 
acm transactions programming languages systems october 
tim sheard 
type parametric programming 
technical report cs oregon graduate institute science technology department computer science engineering portland usa november 
philip wadler 
theorems free 
fourth international conference functional programming languages computer architecture fpca london uk pages 
addison wesley publishing september 
yang 
encoding types ml languages 
sigplan notices january 

