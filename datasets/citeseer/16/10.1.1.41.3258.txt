dataguides enabling query formulation optimization semistructured databases roy goldman stanford university cs stanford edu jennifer widom stanford university widom cs stanford edu semistructured databases schema fixed advance 
provide benefits schema environments introduce dataguides concise accurate structural summaries semistructured databases 
dataguides serve dynamic schemas generated database useful browsing database structure formulating queries storing information statistics sample values enabling query optimization 
presents theoretical foundations dataguides algorithm creation overview incremental maintenance 
provide performance results implementation dataguides lore dbms semistructured data 
describe dataguides lore user interface enable structure browsing query formulation means guiding query processor optimizing query execution 

traditional relational object oriented database systems force data adhere explicitly specified schema 
typical site world wide web demonstrates information available line semistructured 
data may exhibit structure varied irregular mutable easily map fixed schema 
research focused data models query languages systems require schema accompany database aqm bdhs bds ks mag 
define structure data schema serves important purposes schema form tables attributes class hierarchies enables users understand structure database form meaningful queries 
query processor relies schema devise efficient plans computing query results 
schema tasks significantly harder 
may possible manually browse small database general forming meaningful query difficult schema kind structural summary supported air force rome laboratories darpa contracts 
permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings rd vldb conference athens greece underlying database 
lack information structure database cause query processor resort exhaustive searches 
address challenges schema free environments introduce dataguides dynamically generated maintained structural summaries semistructured databases 
contributions give formal definition dataguides concise accurate convenient summaries semistructured databases 
motivate define strong dataguides suited implementation dbms 
provide simple algorithm build strong dataguides describe keep consistent underlying database changes 
show store sample values statistical information dataguide 
demonstrate dataguides successfully integrated lore mag lightweight object repository dbms semistructured data development stanford university 
dataguides vital lore user interface users depend dataguide learn structure database formulate meaningful queries 
addition users may specify submit queries directly dataguide 
explain query processor strong dataguide significantly optimize query execution 
cast context lore system 
data lore follows simple graph data model called oem object exchange model 
applied easily graph data model 
lore database queried lorel aqm oql language designed easy effective queries semistructured data 
lore dataguides serve role traditional metadata 
example dataguides stored directly lore oem objects 
metadata relational object oriented systems user interfaces client applications may access query dataguide lore standard interfaces mag 
way traditional query processor consults metadata dataguide available guide lore query processor 
course dataguides differ significantly metadata dynamically generated dataguides conform data forcing data conform dataguides 
related dataguides extend initial gives theoretical foundation concept dynamically generated structural summaries databases called representative objects ros 
foundational defines summaries functional style emphasis implementation 
related theoretical research discusses schemas graph structured databases 
formal definition graph schema algorithm determine database conforms specific schema 
traditional view schema take 
optimization browsing functionality depend having database large fragments database conform explicitly specified schema 
contrast focuses directly case inconvenient implausible specify maintain schema dataguide summaries dynamically generated maintained represent current state database 
dataguide includes information exist database definition database conforms dataguide 
graph schema hand superset database conforms 
research commercial user interfaces schema structural summary guide browsing query formulation influenced seminal query example 
addition early research efforts timber sk commercial relational front ends access paradox sophisticated interfaces visually specifying queries 
visual database browsers developed richer object oriented data models including ags 
visual tool exploring object databases integrates browsing querying single interface 
dataguide unique graphical browsing query tool presents template dynamically generated directly database regard fixed schema class hierarchy 
query optimization show dataguide path index 
substantial research object oriented query optimization focused design path indexes bk km 
general previous required explicit specification paths index 
issues create maintain path index semistructured data model oem set paths database may change time best knowledge addressed 
outline section reviews data model query language working 
provides motivation definition dataguides simple algorithm creating 
section experimental results showing time space required build store typical dataguides 
section explains incrementally maintain dataguide response database modifications 
section describes dataguides practice browse structure guide query formulation graphical interface lore system 
section see strong dataguide improve query processing lore 
discuss research section 
foundations section describe basic data model query language 
motivate define dataguides properties provide algorithm building 
object exchange model research object exchange model oem simple flexible data model originates tsimmis project stanford university 
oem particularly original adapts easily graph structured data model 
oem object contains object identifier oid value 
value may atomic complex 
atomic values may integers reals strings images programs data considered indivisible 
complex oem value collection oem subobjects linked parent descriptive textual label 
note single oem object may multiple parent objects cycles allowed 
details oem motivation see aqm 
presents small sample oem database representing portion imaginary eating guide database 
object integer oid 
database contains complex root object subobjects restaurants bar 
restaurant complex object bar atomic containing string value rose crown 
restaurant atomic name 
restaurant atomic data describing phone number available entree 
see database structure irregular restaurant doesn include phone number information 
see oem databases need tree structured smith owner restaurant manager 
give simple definitions useful describing oem database subsequently defining dataguides 
definition 
label path oem object sequence dot separated labels traverse path edges edge label restaurant name bar valid label paths object 
oem database queries label paths 
example valid query request values restaurant entree objects satisfy condition 
queries discussed section 
definition 
data path oem object alternating sequence labels oids form traverse path edges objects edge label object oid restaurant name data path object 
definition 
data path instance label path sequence labels equal restaurant name instance restaurant name bar instance bar 
definition 
oem object target set set oids exists label path data path instance 
target set set objects reached traversing label path say target set write 
element reachable likewise reaches element 
sample oem database example target set restaurant entree 
note different label paths may share target set 
instance target set restaurant owner restaurant manager 
lorel query language lorel lore language developed stanford enable queries semistructured oem databases 
lorel oql cat modifications enhancements support semistructured data details see aqm 
extremely simple example lorel query select restaurant entree returns served restaurant set objects 
simple example may request names restaurants serve select restaurant name restaurant entree burger answer query single object 
brief examples indicate knowledge structure database important forming meaningful queries 
lorel language provide facilities wildcards label paths enable queries database structure isn entirely known 
summary structure underlying database invaluable guiding formulation meaningful queries lorel 
dataguides ready define dataguide intended concise accurate convenient summary structure database 
refer database summarize source database simply source 
assume source database identified root object 
achieve conciseness specify dataguide describes unique label path source exactly regardless number times appears source 
ensure accuracy specify dataguide encodes label path appear source 
convenience require dataguide oem object store access techniques available processing oem databases 
formal definition follows 
definition 
dataguide oem source oem object label path exactly data path instance label path label path shows dataguide source oem database shown 
dataguide check label path length exists original database considering objects dataguide 
example need examine outgoing edges objects verify path restaurant owner exists database 
similarly traverse single instance label path dataguide reach object labels outgoing edges represent possible labels follow source database 
different labeled outgoing edges object represent possible labels follow restaurant source 
notice dataguide contains atomic values 
dataguide intended reflect structure database atomic values unnecessary 
see special atomic values added dataguides play important role query formulation optimization 
note target set dataguide singleton set 
recalling definition target set denotes objects reachable label path 
dataguide label path just data path instance target set contains object object data path 
considerable theoretical foundation dataguides 
proved creating dataguide source database equivalent conversion non deterministic finite automaton nfa deterministic finite automaton dfa studied problem hu 
source database tree conversion takes linear time 
worst case conversion graph structured database may require time space exponential number objects edges source 
despite worst case possibilities experimental results section encouraging indicating typical oem databases running time reasonable resulting dataguides significantly smaller sources 
unfortunately research known authors formally identifies nfas require exponential time space converted equivalent dfas 
existence multiple dataguides automata theory know single nfa may equivalent dfas hu 
similarly shown oem source database may multiple dataguides 
figures dataguides source 
label path source appears exactly dataguide dataguide introduces label paths exist source 
fact minimal smallest possible dataguide 
known state minimization algorithms convert dataguide minimal hop 
existence multiple dataguides source important decide kind dataguide built maintained semistructured database system 
intuitively minimal dataguide 
dataguide 
source dataguides desirable furthering goal having concise summary possible suggests building minimal dataguide 
explain minimal dataguide best 
incremental maintenance minimal dataguide difficult 
suppose add new child object label correctly reflect source insertion simply add new object label object 
reflect insertion minimal dataguide order generate dataguide updated version minimal dataguide source 
general maintaining minimal dataguide response source update may require original database reexamined 
subsection describes second significant problem minimal dataguides 
annotations dataguide summarize structure source may wish keep additional information dataguide 
example consider source label path aid query formulation want user sample database values reachable 
feature useful oem constraints type format atomic data 
example may wish provide user query processor statistical odds object reachable outgoing edges specific label 
query processing direct access dataguide objects reachable useful seen section 
definition classifies examples 
definition 
source database label path property set objects comprise target set said annotation annotation label path statement set objects database reachable path 
dataguide guarantees source label path reaches exactly object dataguide 
object ideal place store annotations access annotations simply traversing dataguide single data path instance unfortunately definition dataguide prevents multiple label paths reaching object dataguide label paths different target sets source 
referring see label paths reach object 
store annotation object know annotation applies label path label path 
dataguide distinct objects label paths correctly separate annotations 
formalize dataguide characteristics enable unambiguous annotation storage 
strong dataguides define class dataguides supports annotations described previous subsection 
intuitively interested dataguides set label paths share singleton target set dataguide set label paths share target set source 
formally definition 
consider oem objects dataguide source label path target set singleton target set 
set label paths share target set similarly 
set label paths having target set label paths strong dataguide example strong dataguide 
source target set dataguide target set 
source source label paths target set 
dataguide 
dataguide strong 
reader may verify fact strong dataguide 
show strong dataguide sufficient storage annotations 
proof appears gw 
theorem 
suppose strong dataguide source annotation label path stored object reachable describes target set label path reaches show strong dataguide induces straightforward correspondence source target sets dataguide objects proof appears gw 
property useful incremental maintenance section query processing section 
theorem 
suppose strong dataguide source target set definition target set label path compute target set single element describe procedure takes source target set input yields dataguide object output 
strong dataguide induces correspondence source target sets dataguide objects 
dataguide strong may impossible find correspondence source target sets dataguide objects 
example different target sets corresponding label paths empty path 
objects correspondence 
algorithm build strong dataguide input root oid source database effect dg strong dataguide global empty hash table map source target sets dataguide objects dg global oid initially empty dg insert dg dg children objects foreach unique label set oids paired lookup nil add edge label insert add edge label 
algorithm create strong dataguide building strong dataguide strong dataguides easy create 
depth fashion examine source target sets reachable possible label paths 
time encounter new target set path create new object dataguide object single element dataguide target set theorem guarantees see different label path creating new dataguide object add edge dataguide refer hash table mapping source target sets dataguide objects serves purpose 
algorithm specified 
note create insert dataguide objects recursing order prevent cyclic oem source causing infinite loop 
compute target sets construct dataguide easily augment algorithm store annotations dataguide 

experimental performance described section computing dataguide source equivalent converting non deterministic finite automaton equivalent deterministic finite automaton 
tree structured source conversion runs linear time size dataguide bounded size source 
arbitrary graph structured source creating dataguide may require exponential running time feasibly generate dataguide exponentially larger source 
needless say concerned potential exponential behavior far know research tried formalize automaton characteristics lead better worse behavior 
section show classes oem databases experimental performance results encouraging 
discussing performance operational oem databases admittedly relatively small require little time dataguide creation yield dataguides significantly smaller source 
plan build analyze larger realistic oem databases 
describe experiments conducted synthetic oem databases 
wide range parameters find large graph structured databases yield performance 
measurements taken running lore system sun ultra mb ram 
operational databases consider medium sized databases lore 
tree graph significant data sharing 
believe tree structured sources common lore relational database example modeled oem tree 
tree structured database contains snapshot data imported large popular web site covering different sports oem database structure menus links site 
structure quite regular data sport differs significantly 
captured small portion web site building database objects links unique labels maximum height 
building strong dataguide requires seconds dataguide contains objects links 
second operational database contains information stanford database group describing group members projects publications 
see database section discuss lore user interface 
database uses extensive data sharing graph structure 
example single group member reachable member projects author number publications 
graph contains numerous cycles example group member reachable link project links projects works 
database currently contains objects links unique labels 
building strong dataguide takes seconds resulting dataguide objects links 
performance databases summarized table 
synthetic databases study performance generated numerous large synthetic databases trees graphs cycles 
tree structured databases parameters 
height number levels tree 
level tree number unique labels outgoing edges labels level 
sets labels source dataguide description objects links labels height objects links time secs sports tree dbg graph table 
dataguide performance operational lore databases source dataguide db tree objects links height labs 
level fanout full objs 
level backlink freq level objects links time secs table 
dataguide performance synthetic databases corresponding different levels disjoint 
maximum outgoing edges non leaf fan 
maximum fan object full simulate irregular structure varying number outgoing edges object zero maximum fanout irregular 
graph structured databases modify supplement tree parameters follows 
height defined longest path breadth traversal root graph 
level includes objects shortest path root edges 
fan longer sufficient specify number objects level edges level may point object 
new parameter maximum number objects level integer multiplied level number 
number exceeded edge previous level points different object 
limit reached remaining edges evenly distributed existing objects level 
sending outgoing edges objects level proportion outgoing edges backlink frequency may redirected objects previous levels redirect edges objects fixed number levels backlink level current level 
results describing numerous synthetic databases captured table 
summarize results briefly discussion see gw 
impossible explore possible graphs see expected space time performance tree db db 
acyclic graphs repetitive structure cause problems common situations db db 
relatively shallow graphs large number outgoing edges object cycles pose problem db 
deeper graphs cycles cause dataguides larger source db db 
examples yield reasonable performance potential certainly exist poor performance 
unconstrained backlinks deep graphs instance cause significant problems 
confident practice oem databases rarely exhibit structure results poor performance plan build analyze additional operational lore databases empirical testing 
hope formalize properties guarantee prohibit performance find heuristics help algorithm detect database may result poor performance 
cases may able achieve better performance building strong dataguide levels 
way dataguides useful guiding queries examine long paths 
plan measure performance impact annotations section incremental dataguide maintenance section 

incremental maintenance dataguide useful query formulation especially optimization keep consistent source database changes 
section address update strong dataguide reflect insertions deletions edges source 
note updates atomic values affect dataguide 
modify dataguide creation algorithm incremental maintenance structures depicted 
construct target sets dataguide algorithm store database auxiliary oem objects 
persistent table maps source target sets dataguide objects 
dataguide object add edge labeled connecting corresponding target set guaranteed exist theorem 
parallel build additional persistent hash table map source object dataguide objects correspond target sets containing algorithm updates dataguide response number edge insertions deletions source 
edge written indicating edge object object label refer update point 
algorithm directly handle insertion complete subgraph update point connecting new graph existing database 
algorithm identifies dataguide regions affected changes update point find dataguide object corresponding source target set contains dataguide object sub dataguide describes potential structure object corresponding source target set including update points 
updates may affect sub dataguide recompute relying avoid excessive recomputation encounter target set corresponding dataguide object halt recursion 
algorithm slightly modified version dataguide creation algorithm specified full gw 
trace insertion example demonstrate algorithm 
example deletion gw 
example 
shows trickier cases insertion 
dashed edge objects original source strong dataguide source links 
data structures dataguide maintenance 
insertion edge omitted 
suppose insert edge 
object sole update point dataguide object corresponds target set object part 
recompute sub dataguide 
original algorithm examine children objects initial source target set label label 
suppose consider children label 
target set 
persistent see object corresponds set 
catch fact edge label exists additional required label 
proceeding examine children label see target set 
add new edge label doing remove existing edge 
detached subgraph garbage collected final result strong dataguide shown 
notice deleting edge just inserted regenerate dataguide equivalent 
deletion target set remains target set 
edge removed recursive calls generate new dataguide path root required maintain dataguide depends entirely structural impact updates 
example inserting new leaf tree structured database requires target set recomputed new object added dataguide 
extreme database extensive sharing may cause recomputed update 
regardless keeping accurate target set data prevents excessive recomputation recursion halted target set lookup successful indicating corresponding target set correct 

query formulation notion structure database formulating queries extremely difficult 
user limited adhoc combination browsing entire database issuing exploratory queries guesswork 
dataguides provide concise accurate date summarizing information structure database useful query formulation 
section demonstrate value dataguides context java web user interface created lore 
interface user interactively explore dataguide aid formulation lorel queries 
dataguide enables users specify large class queries example style knowledge lorel query language 
examples refer medium sized database built describing members projects publications stanford database group introduced section 
database mirrors information available database group web site fact contains links site home pages images publications 
connection database user html page framing java dataguide shown 
user explore dataguide clicking arrows triangles expand collapse complex objects dataguide 
immediately see dataguide guides specification path expressions queries recall section valid path expression dbg label followed group member project publication 
expanding dataguide complex object lists potential subobject labels database see subobjects label 
determine label path length exists database clicking dataguide arrows 
contrast browsing semistructured database directly may examine labeled objects finding specific outgoing label 
dataguide useful deducing valid path expressions values database point remain mystery 
user interested locating group members nevada doesn know original home las vegas stored las vegas nv nevada nevada usa 
option lorel pattern matching features aqm write query attempts encompass possible formats 
java dataguide 
dataguide path information cases better approach examine sample values database 
described section effectively store sample values annotations dataguide 
notice diamond accompanies label corresponding distinct label path root 
clicking diamond brings dialog box shown obtained clicking diamond original home label 
top portion dialog box identifies path expression shows dataguide annotations total number database objects reachable path expression list sample values 
currently fixed number values chosen arbitrarily database clearly sophisticated 
annotations stored specially marked children dataguide objects interpreted user interface 
easily computed dataguide creation maintenance 
elements dialog box allow users specify queries directly dataguide writing lorel style reminiscent query example 
shown user click button select path query result 
value filtering conditions may specified common arithmetic logical operators custom operators unix utility grep sql function 
comparisons correspond lorel conditions users need aware fact 
onscreen dataguide updated reflect query specifications highlighting diamonds selected path expressions displaying filtering conditions corresponding labels 
shows dataguide user specified select graduate students group originally nevada new york stanford years 
predicate satisfy phd student masters student 
user clicks go button java program generates lorel query equivalent dataguide query specification sends lore processed 
lore returns query results html hierarchical format easy browse navigate labeled objects grouped complex objects represented hyperlinks 
point user may return dataguide modify original query submit new 
currently dataguide queries specify lorel query simple path expressions path wildcards clauses conjunctive respect unique path expressions 
value comparisons constants 
hope add techniques expand expressive power dataguide queries disjunctions path expressions path wildcard specifications variables enable joins 
larger scale believe opportunity blurring distinction formulating query browsing query result spirit 
example suppose supplying just sample values dialog box path expression displayed values 
clicking diamond answers simple query find values reachable path 
furthermore integrating query processor dataguide maintenance algorithms quickly respond filtering condition specified dataguide updating dataguide value lists reflect condition 
example suppose user specified condition position restricting query consider students 
may database research interest data group members path removed temporarily dataguide 
importantly clicking diamond original home display homes students 
manner restricting years stanford original home evaluate entire desired query clicking diamonds labels group member display data matched query conditions 
point may desirable revert current model result browsing allowing user examine group members satisfied query 
dataguide driven user interface described accessible public lore home page web www db stanford edu lore 

query optimization section discuss technique uses information maintained strong dataguide significantly speed query processing broad class lorel queries 
essentially strong dataguide serve path index 
path indexes studied traditional object oriented database systems bk km typically created user specified path expressions semistructured environment set path expressions may flux isolating useful paths index may difficult 
conveniently build incrementally maintain comprehensive path index possible path expressions strong dataguide 
shown section incremental maintenance object strong dataguide link corresponding target set source 
time proportional length label path dataguide find source objects reachable path independent size source 
section analyze sequence queries show benefits having fast access target sets query processing 
query processing comparisons number objects examined 
simple cost model assigns uniform cost object examination general difficult guarantees clustering graph model oem object examination may require random disk access 
note value complex object sequence pairs representing subobjects mag time spent examine labels oids subobjects included cost examining complex object 
queries need find parents oem object 
parent pointers need stored explicitly database lore example uses hash index map object label parents reach mag 
simplicity assume examining object yields object parents additional cost 
example 
simple lorel query sample database showing dataguide dramatically 
dataguide query specification reduce query execution cost 
suppose wish execute lorel query recall section database structure similar stanford database group database described section 
finds publications troff format 
select dbg group member publication troff result set oids 
example consider extreme database dbg object containing group members objects 
average publications troff subobject exists entire database 
priori knowledge structure database query processor forced examine turn publication return troff object publication 
see addition root dbg object query processor examine objects 
note lore current indexing schemes applicable query mag 
example query result exactly objects target set dbg publication troff 
find target set simply traverse path root dataguide know path 
need examine objects find result dataguide root dbg object publication troff object object containing path target set 
section object dataguide reachable dbg publication troff includes part value link special complex object children objects path target set 
note traversing dataguide may find path exist 
query finding guarantees query result empty 
type optimization require strong dataguide fact suggested 
example 
show somewhat interesting query 
suppose wish find publication years group older publications select dbg group member publication year dbg group member publication year query introduces filtering condition 
conditions lore includes tree value index vindex takes label operator value returns set oids objects satisfy value constraint specified incoming label mag 
note index label label path object 
dataguide compute intersection set objects returned vindex year target set full label path dbg publication year 
dataguide algorithm constructs target set step modifies target set typically expect target sets stored contiguously disk 
oids returned vindex stored efficiently tree expect computation intersection fast additional random disk accesses 
specify sample database analyzing performance query example 
numbers contrived particular database representative size structure databases encounter practice 
suppose path dbg 
publication year target set objects 
assume objects satisfy value constraint reachable single publication path 
suppose year objects referenced publications path dbg project publication year year objects value reachable publications path 
vindex lookup year returns objects pointed different publications 
process query dataguide examine dataguide objects find oid identifying retrieve valid oids vindex intersect oids compute result 
consider processing query dataguide 
topdown exploration vindex need examine values objects previous example examine publication objects appropriate subobjects 
alternatively lore build query plan take advantage vindex traversing bottom identify objects reachable valid paths mag 
example object returned vindex system find objects year link check see objects incoming links label publication root determine object reachable label path dbg 
publication year 
processing example examine objects returned vindex find publications links objects 
find parents publication objects 
processing query bottom requires objects examined 
example 
suppose wish find actual older publications select dbg group member publication dbg group member publication year denote target set select path target set path traversing single data path dataguide 
mentioned example path exist query result empty 
proceed example intersect oids set oids returned vindex identify candidate year objects 
examine objects find set parent objects year links objects 
may include objects query result intersect oids compute final result objects 
assume publication single year objects 
essentially query result previous example objects 
data sharing contains objects 
addition required previous example compute need examine objects find parent objects intersect find total cost dataguide expensive object examinations plus relatively small costs involved retrieving oids vindex performing oid set intersections oids returned vindex oids oids oids 
comparison top approach vindex dataguide examine objects 
similarly previous example combining vindex parent traversal retrieve oids vindex examine objects 
techniques examples generalized queries 
instance optimize queries lorel support wildcards regular expressions path specifications aqm 
example select dbg group member project publication selects publications projects 
dataguide oem object reuse code handles constructs data find target sets paths dataguide 
practice impact dataguide query processing certainly depends structure database 
direct access target sets enables query processor prevent search space growing needlessly large 
follow plan run benchmarks carefully compare performance different query processing approaches described section 
ultimately hope build optimizer uses statistics detailed performance characteristics combine dataguides child parent link traversal efficient query plans 

theoretical standpoint investigate possibility performance guarantees dataguide creation certain classes databases 
ideally formalize database characteristics guarantee performance 
heuristics quickly identify databases may result poor dataguide performance helpful 
strategies dealing cases important 
plan measure performance dataguide creation maintenance large realistic oem databases 
mentioned section plan continue exploit dataguides enhance user interface lore 
addition allowing expressive queries specified directly dataguide plan blurring distinctions metadata data alternatively query formulation result browsing 
process demand considerable cooperation query processor dataguide management addition quickly repeatedly updating potentially remote user view database 
regard query optimization plan run extensive benchmarks comparing query processing lore dataguides 
process seek classify queries database characteristics dataguides improve performance 
acknowledgments authors wish nestorov jeff ullman janet wiener sudarshan chawathe initial representative objects 
grateful serge abiteboul jason mchugh nestorov jeff ullman helpful suggestions rest lore group stanford enabling research 
ags agrawal gehani srinivasan 
graphical interface ode 
proceedings acm sigmod international conference management data pp 
atlantic city nj may 
aqm abiteboul quass mchugh widom wiener 
lorel query language semistructured data 
journal digital libraries november 
buneman davidson fernandez suciu 
adding structure unstructured data 
database theory sixth international conference proceedings pp 
delphi greece 
bdhs buneman davidson hillebrand suciu 
query language optimization techniques unstructured data 
proceedings acm sigmod international conference management data pp 
montreal canada 
bds buneman davidson suciu 
programming constructs unstructured data 
proceedings international workshop database programming languages 
bk bertino kim 
indexing techniques queries nested objects 
ieee transactions knowledge data engineering pp 
june 
cat cattell ed 
object database standard odmg 
morgan kaufmann san francisco ca 
chawathe chen yu 
index selection schemes nested object hierarchies 
proceedings international conference large data bases pp 
santiago chile 
carey haas williams 
integrated query browser object databases 
proceedings second international conference large data bases pp 
bombay india august 
gw goldman widom 
dataguides enabling query formulation optimization semistructured databases 
technical report stanford university 
available www db stanford edu 
hop hopcroft 
log algorithm minimizing states finite automaton 
theory machines computations pp 
new york 
hu hopcroft ullman 
automata theory languages computation 
addison wesley reading ma 
km kemper moerkotte 
access support relations indexing method object bases 
information systems pp 

ks konopnicki shmueli 
qs query system world wide web 
proceedings international conference large data bases pp 
zurich switzerland 
mag mchugh abiteboul goldman quass widom 
lore database management system semistructured data 
sigmod record september 
motro 
design object oriented browser 
proceedings second international conference expert database systems april 
nestorov ullman wiener chawathe 
representative objects concise representations semistructured hierarchical data 
proceedings thirteenth international conference data engineering birmingham april 
papakonstantinou garcia molina widom 
object exchange heterogeneous information sources 
proceedings eleventh international conference data engineering pp 
taipei taiwan 
sk stonebraker 
timber sophisticated relational browser 
proceedings eighth international conference large data bases sept 
zloof 
query example 
ibm systems journal pp 

