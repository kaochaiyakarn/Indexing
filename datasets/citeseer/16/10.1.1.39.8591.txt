bibtex entry available www tuwien ac papers 
published principles programming languages popl copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
optimal code selection dags anton ertl institut fur technische universitat wien wien austria anton mips tuwien ac www tuwien ac anton tel fax extend tree parsing approach code selection dags 
general extension produce optimal code selection dags problem npcomplete certain code selection grammars 
method checking code selection grammar belongs set dag optimal grammars method check code selection grammars adapted lcc grammars mips sparc architectures dag optimal code selection grammar architecture dag optimal 
code generator compiler transforms programs compiler intermediate representation assembly language binary machine code 
code generation divided phases code selection translates operations intermediate representation instructions target machine instruction scheduling orders instructions way keeps register pressure number pipeline stalls low register allocation replaces pseudo registers intermediate representation real registers spills excess pseudo registers memory 
popular method code selection tree parsing 
allows fast code selectors guarantees optimality respect machine description 
tree parsing works intermediate representation tree 
preferred intermediate representation form dags directed acyclic graphs 
extends tree parsing dealing dags 
main contributions linear time method parsing dags section check method parses dags optimally grammar section 
report encouraging experiences checking method section 
nonterminal pattern cost start 
reg reg 
reg reg 
int reg 
addr fetch reg 
reg reg plus addr 
reg addr 
int addr 
reg int plus simple tree grammar section introduce code selection tree parsing section discuss perform code selection dags 
section presents related 
code selection tree parsing machine description code selection tree parsing tree grammar 
shows simple tree grammar pro 
conventions code selection literature show nonterminals lower case operators capitalized trees root top view intermediate representation trees data flow graphs data flows upwards 
rule consists production form nonterminal pattern cost code generation action shown 
productions similar productions string grammars derivation step replacing nonterminal occurring left hand side rule pattern right hand side rule 
complete derivation start nonterminal perform derivation steps nonterminal left 
shows ways derive tree adapted start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule fetch plus reg int fetch labeler information derivation tree information computed labeler resulting derivation tree 
fetch plus reg int fetch fetch plus reg int fetch cost cost derivations tree circles numbers indicate rules 
pro 
cost derivation sum costs applied rules 
code selection operators tree grammar operators intermediate representation costs rules reflect costs code generated rule 
cost derivation represents cost code generated derived tree 
example shows code selection grammars usually ambiguous 
problem tree parsing code selection find minimum cost derivation tree 
relatively simple method linear complexity dynamic programming approach beg esl days superscalar deeply pipelined processors high cache costs additive cost model direct prediction number cycles generated code resources code size functional unit usage conform additive cost model influence execution time events instruction cache misses instruction fetch unit contention functional unit contention 
reducing number instructions code selector tends shorten data dependence chains associated latencies mips processors instruction lw shorter latency equivalent sequence li lw produced naive code selector 
iburg fhp 
works passes labeler pass works bottom 
node nonterminal combination determines minimal cost deriving subtree rooted node nonterminal rule step derivation 
minimal cost lower node nonterminal combinations known performed easily checking applicable rules computing cheapest 
rules form nonterminal nonterminal chain rules checked repeatedly changes 
optimal rules 
reducer pass performs walk derivation tree 
starts start nonterminal root node 
looks rule recorded node nonterminal combination 
nonterminals pattern rule determine nodes nonterminals walk continues 
time processing rule typically subtrees processed code generation action rule executed 
shows information generated method 
resulting optimal derivation shown right hand side fig 

dags intermediate representation dags arise language constructs common subexpression elimination performing code selection basic blocks statements expressions 
gives example possibilities 
assume acceptable generate code shared subgraphs just acceptable generate code corresponds partial complete replication shared subgraphs 
assumption depends semantics intermediate representation intermediate operations functions scheduled correctly idempotent 
assumption usually intermediate representation int pc count pc pc code selection basic blocks count count common subexpression elimination count operators source store plus fetch int plus reg int count plus reg int count cse store plus fetch int plus reg int count ways getting intermediate representation dags optimal dag splitting lw count nop load delay addu sw count store plus plus fetch reg int count int reg reg addu count lw nop load delay addu sw cycles cycles code generated dag fig 
mips optimal dag splitting code selection 
resides register 
valid valid lcc intermediate representation fh fh 
note problem optimal parsing easier assumption valid choice replication non replication 
common subexpression elimination relies assumption approach handling dags split trees removing edges shared nodes parents see fig 
parse tree separately results tree forced register 
done twice resulting code suboptimal dag see fig 

parsing dags general approach straightforward extension tree parsing algorithm dags labeler information tree labeler computed node 
component visiting nodes bottom order may adapted recursive walk extended visited flag 
reducer reducer deal potential existence roots 
set assumption valid intermediate representation contains operator operator 
different perspective ok shared subgraph equal ones 
check visited flag node nonterminal combination visits ensuring reducer walks path derivation graph exactly 
shows method parses graph grammar fig 

dag parsing algorithm take node sharing account labeling stage 
reducing stage sharing considered node nonterminal combinations 
subgraph derived times nonterminal reduction subgraph shared 
contrast shared subgraph derived different nonterminals base rules root node reduced times operation represented node replicated generated code child subgraph node derived times sharing reductions depending derivations nonterminal 
fig 
left plus node reduced twice derived addr rule parent node fetch reg rule parent node right plus reduction left child left reg shared derived reg derivations 
cost deriving dag sum costs applied derivations shared derivations counted 
problem parsing dags code selection find minimum cost derivation dag 
general problem np complete pro 
method parsing dags linear time space 
labeler visits node time spends node constant independent graph size 
labeler information derivation dag start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule start cost rule addr cost rule reg cost rule plus reg fetch plus int reg start cost rule addr cost rule reg cost rule plus int plus reg fetch plus int reg dag cover cost parsing dag 
dag cover dashed lines represent rules shown slanted numbers 
similarly reducer visits node nonterminal combination spends constant time combination 
replication operations limited number nonterminals grammar independent grammar size 
method linear produce optimal derivations general 
fortunately certain class grammars method parses dags optimally show section 
note grammar design parsing dags grammars trees practice distributing cost rules contributing instruction assign cost addressing mode 
parsing dags practice lead cost counted generated code cost occurs twice 
grammars intended dags attribute full cost rules generate code general rules cause cost cost rules 
determining optimality normal form grammars simplify discussion assume grammar normal form contains rules form chain rules op base rules ns nonterminals 
tree grammar converted normal form easily introducing nonterminals 
rules example grammar see fig 
normal form rule converted normal form splitting rules nonterminal pattern cost addr 
reg plus 
int advantage normal form don think rules parse nodes jump nodes reducer know derivation node go nonterminal node 
basic idea dag parsing algorithm section choice rules parsing tree irrespective sharing subgraphs 
words case shared node optimizes locally parent 
job checker determine locally optimal choices globally optimal dag derived grammar 
basic principle checker subgraph consider derived number parents combination nonterminals globally optimal derivation cases represent ways sharing check condition nonterminal locally optimal derivation optimal cases derivation globally optimal 
just problem method requires knowing globally optimal derivations general know 
conservative approximation assume derivation globally optimal know ensures checker reports grammars parsing method optimal dags may report spurious problems 
checking derivation assume shared node nonterminal combinations fully paid parents derivation looking node nonterminal combinations cost 
rule optimal case full cost case optimal distributions costs 
checker check grammar dag optimality constructing inductive proof set possible dags base cases terminals step cases build larger dags smaller dags 
implemented checker called similar ll lalr parser generators report conflicts may caused ambiguous grammar artifacts parser generation algorithm 
structure checker similar generator tree parsing automata cha pro easy extend checker generator 
available www tuwien ac anton 
data structures item record contains cost set rules 
itemset array items indexed nonterminals 
costs items itemset absolute relative base ffi common itemset 
state record consisting full cost itemset set partial cost itemsets 
data structures meanings state represents class graphs certain commonalities respect rules costs deriving 
state corresponds base case step case proof 
full cost itemset information computed labeling pass parsing algorithm root node represented graphs twists relative costs allow representing graphs different absolute costs items store set optimal rules just rules 
partial cost itemset represents incremental costs rules deriving graphs specific sharing pattern 
incremental cost deriving partially shared graph nonterminal cost incurred nonshared rule derivations computed setting costs shared node nonterminal combinations doing labeling pass 
partial cost itemsets include itemset sharing corresponding itemset 
computing states computes states worklist algorithm tries build new state applying ary operator tuple states new states occur 
start states operators operands terminals applied 
applies operator tuple child states sk computes full cost itemset full cost itemsets child states just done labeling base rule form nk computes cost cost nonterminal builds item contains cost nonterminal set optimal rules nonterminal results preliminary itemset repeatedly applies chain rules change chain rule form computes cost cost resulting cost smaller cost item replaced cost rule set frg resulting cost equal cost rule added optimal rules item 
states tree parsing automaton generators differ having partial cost itemsets having rule set item 
may wonder case derivation shares node nonterminal combination shared parent diamond shaped graphs 
case equivalent case subgraph replicated copies paid derivation looking copies cost 
computation partial cost itemsets basically works way differences computing partial cost itemsets operator tuple states uses combination partial cost itemsets representing various sharing variants subgraphs 
produces partial cost itemsets subset nonterminals members subset absolute cost represents sharing graph represented state nonterminals produce zero cost item rules may applied cost normal cost contribute incremental cost items producing item cost contribute incremental cost 
rule optimal rules partial cost itemsets cost rule counts producing zero cost item avoids spurious errors warnings checking 
absolute cost important computations relative costs partial cost itemsets contain item cost 
itemsets uses relative costs cost ffi allows algorithm terminate cases relative costs allow worklist algorithm determine state new 
shows states computed example grammar 
rest section give example computation partial cost itemsets look specific case operator plus left child state right child state state represents graph reg state represents graph int state represents plus reg int 
partial cost itemset represents ways sharing graph 
partial cost itemsets ffl represents ways sharing reg paid directly indirectly parent nonterminals start reg cost rule costs 
ffl represents ways sharing reg shared paid parent nonterminals start reg come free 
combinations partial cost itemsets children plus plus 
subsets set nonterminals possible sharing variants important issue example reg subset ffl rule applicable deriving plus reg applied cost produces plus plus 
ffl rule applied cost legal plus giving 
reg nonzero cost shared shared graph plus 
rules optimal deriving tree addr addition rule optimal reg cost 
difference pays deriving right hand child state representing graph int reg parent looking plus node parent 
start reg addr state pattern itemset cost rules cost rules cost rules cost rules reg full cost ffi ffi ffi int full cost ffi ffi ffi ffi fetch full cost ffi ffi ffi ffi ffi ffi plus reg int full cost ffi ffi ffi plus full cost ffi ffi ffi ffi ffi ffi plus int full cost ffi ffi ffi ffi ffi ffi ffi ffi ffi states tree grammar fig 
itemsets checking computing state performs check nonterminal derive dags represented state intersection sets rules items nonterminal empty rule optimal sharing variants way parsing dags see section result suboptimal parsing dags 
result causes globally optimal derivation locally suboptimal nonterminal spurious conflict resulting considering derivation potentially globally optimal sharing pattern globally optimal sharing pattern 
checker produces result rule optimal full cost item partial cost items lhs nonterminal rule rule state result suboptimal parsing dags rule parsing state 
modify parser avoid rule simple way achieve generate tree parsing automaton states computed parser rules optimal itemsets state 
partially optimal rules grammar tree parser generator burg iburg course reducer adapted dags described section 
back example fig 
easy see partial cost items contain supersets rulesets corresponding full cost items example grammar parse dags optimally tree parser generator 
experiences results applied example grammar fig 
realistic grammars grammars supplied lcc fh mips sparc architectures mips grammar compiler ep 
discussed example grammar fig 
optimal parsing dags tree parser generator 
grammar mips grammar parsing dags burg generated parsing automaton 
similar spirit lcc mips grammar differences deal floating point instructions code selection mips fp instructions quite trivial anyway complex integer part patterns selecting instructions differences due differences intermediate representation 
terminate mips grammar 
nontermination uncovered bug grammar rule wrong cost fixing bug terminate 
reported state nonterminal combinations globally optimal rule 
fixed problems adding rules improved grammar optimal code selection dags warns burg generated parsing automaton may result suboptimal parsing dags generator knows dag optimal rules burg 
note adding rules decrease quality code selection result dag optimal 
typical problem mips grammar grammar contained rules nonterminal 
pattern cost cons 
cons reg 
cons reg 
reg reg reg 
reg cons reg 
cons reg deriving tree cons cons reg problem arises left cons node derived reg parent rule optimal rule optimal right cons node derived reg parent situation reversed 
knowing sharing situation decide rule 
solved problem adding rule nonterminal 
pattern cost cons 
cons cons rule optimal problematic case independent sharing pattern 
addition rule improves code selection trees constant folding performed compile time computing constant run time 
lcc grammars lcc grammars dynamic costs costs determined code selection time complex code selection decisions 
technique incompatible tree parsing automata general particular 
removed dynamic costs various ways cases replaced fixed costs cases removed rules 
particular grammar dynamic costs selecting read modify write instructions eliminated loss instructions cost equivalent sequence simple instructions pentium simpler instructions easier pair 
technique lcc grammars assign costs rules corresponding addressing modes 
allows simplifications grammar works trees dags instructions share computation addressing mode 
assigned costs corresponding rules instructions 
resulting grammar equivalent old tree parsing works better dags 
reports resulting mips sparc grammars optimal parsing dags tree parser generator 
grammar reported cases dag optimal rule 
vanished added rule base improves code selection trees allows code selector generate addressing mode displacement 
problem harder important 
take effect convert double integer node shared 
extremely rare suboptimality case acceptable 
apart problem grammar optimal parsing dags cases tree optimal rules dag optimal burg iburg resulting grammar may produce suboptimal parses absence shared nodes 
usability performing combinations itemsets may appear take huge amount time result huge number itemsets significantly increase danger non termination 
practice problem grammars looked number itemsets state moderate typically time generating states grammar dependent min mhz grammar min original mips grammar terminate uncovering bug 
apart generates slightly states added computation partial cost itemsets 
memory mb grammar related davidson fraser approach code selection gcc df wen deal dags guarantee optimality trees 
flexible kind code selection patterns allowed tree patterns produce better code tree parsing 
disadvantages harder adding new rule result worse code resulting code selectors slower 
lcc front fh fh produce intermediate representation dags trees 
code selectors fh tree parsing deal problem asking lcc front split dags trees 
approach dealing dags context tree parsing discussed results dag splitting general allows replication zero cost sub trees constants effective address expressions 
pw presents method performing single pass tree parsing code selection contrast classic method requires labeler pass reducer pass 
way optimal parsing dags method works certain grammars realistic code selection grammars 
nontermination problem experiments worthwhile investigate causes nontermination avoided ideally terminate burg terminates 
concerning spurious errors experimentation needed see practical problem 
methods improving accuracy optimality test need developed 
important practical issue report errors warnings way understood easily 
particular easy discern real spurious errors artifacts conservative 
real errors easy see changes grammar help 
users probably accept cases know cases handled optimally grammar 
providing guarantees worthwhile extension 
dynamic costs practice currently handle 
extension takes issue account great practical importance 
area investigation relation tree parsing pw 
dag parsing tree parsing decide comparatively early derivation probably large overlap grammars accepted wburg leading class grammars suited single pass 
extend tree parsing dealing dags 
extension simple parses dags linear time 
derivations selected tree parsing sharing nodes parents influence selection derivations 
general method produce optimal code selection dags certain code selection grammars 
tool check code selection grammar belongs set dag optimal grammars 
check realistic code selection grammars mips sparc architectures required additions optimal nearly optimal code selection dags 
discussions franz helped refining ideas 
manfred andreas krall franz referees popl pldi popl provided valuable feedback earlier versions 
balachandran dhamdhere biswas 
efficient retargetable code generation bottom tree pattern matching 
computer languages 
john boyland helmut 
discussion code generator specification techniques summary 
robert giegerich susan graham editors code generation concepts tools techniques workshops computing pages 
springer 
cha david chase 
improvement bottomup tree pattern matching 
fourteenth annual acm symposium principles programming languages pages 
df jack davidson christopher fraser 
code selection object code optimization 
acm transactions programming languages systems october 
ep anton ertl christian 
structure forth native code compiler 
conference proceedings pages oxford 
esl helmut friedrich wilhelm rudolf landwehr 
beg generator efficient back ends 
sigplan conference programming language design implementation pages 
fh christopher fraser david hanson 
code generation interface ansi software practice experience september 
fh christopher fraser david hanson 
retargetable compiler design implementation 
benjamin cummings publishing 
fhp christopher fraser david hanson todd proebsting 
engineering simple efficient code generator generator 
acm letters programming languages systems 
available ftp ftp cs princeton edu pub iburg tar pro todd proebsting 
burs automata generation 
acm transactions programming languages systems may 
pro todd proebsting 
cost instruction selection dags np complete 
research microsoft com papers proof htm 
pw todd proebsting benjamin whaley 
pass optimal tree parsing trees 
editor compiler construction cc pages linkoping 
springer lncs 
wen alan wendt 
fast code generation automatically generated decision trees 
sigplan conference programming language design implementation pages 
