tcp vegas congestion avoidance global internet lawrence brakmo larry peterson vegas implementation tcp achieves better throughput internet fifth half losses compared implementation tcp reno distribution bsd unix 
motivates describes key techniques employed vegas presents results comprehensive experimental performance study simulations measurements internet vegas reno implementations tcp 
keywords tcp reno vegas protocols congestion avoidance 
argue tcp strengths lies adaptive retransmission congestion control mechanism jacobson providing cornerstone mechanism 
attempts go earlier provide new insights congestion control propose modifications implementation tcp exploit insights 
tangible result effort implementation tcp modifications reno implementation tcp refer tcp vegas 
name takeoff earlier implementations tcp distributed releases bsd tahoe reno tahoe reno refer tcp implementation unix release 
note vegas involve changes tcp specification merely supported part national science foundation iri arpa contract dabt 
authors department computer science university arizona tucson az 
email brakmo cs arizona edu llp cs arizona edu alternative implementation valid implementation tcp 
fact changes confined sending side 
main result reported vegas able achieve better throughput reno 
improvement throughput achieved aggressive retransmission strategy effectively steals bandwidth away tcp connections current algorithms 
achieved efficient available bandwidth 
experiments show vegas retransmits half data reno 
organized follows 
section outlines tools measure analyze tcp 
section describes techniques employed tcp vegas coupled insights led techniques 
section presents comprehensive evaluation vegas performance simulation results measurements tcp running internet 
section discusses relevant issues section concluding remarks 
tools section briefly describes tools implement analyze different versions tcp 
protocols developed tested university arizona kernel framework 
implementation reno derived retrofitting bsd implementation kernel 
implementation vegas derived modifying reno 
limit discussion reno newer better performing tahoe 
section discusses results relative newer versions tcp berkeley network release bsd 
time seconds kb time seconds sending kb tcp reno trace examples 
simulator results reported obtained network simulator 
simulators available real decided build simulator kernel 
environment actual kernel protocol implementations run simulated network 
specifically simulator supports multiple hosts running full protocol stack test tcp ip eth link behaviors point point connections ethernets 
routers modeled network node running actual ip protocol code entity supports particular queuing discipline fifo 
kernel simulator provides realistic setting evaluating protocols protocol modeled actual code implements specification 
trivial move protocols simulator real world providing comprehensive protocol design implementation testing environment 
important protocols available simulator called traffic implements tcp internet traffic tcplib 
traffic starts conversations interarrival times exponential distribution 
conversation type telnet ftp nntp smtp expects set parameters 
example ftp expects parameters number items transmit control segment size item sizes 
parameters probability distributions obtained traffic traces 
conversations runs top tcp connection 
trace facility early effort clear needed facilities analyze behavior tcp 
added code kernel trace relevant changes connection state 
paid particular attention keeping overhead tracing facility low possible minimize effects behavior protocol 
specifically facility writes trace data memory dumps file test keeps amount data associated trace entry small bytes 
developed various tools analyze display tracing information 
rest section describes tool graphically represents relevant features state tcp connection function time 
tool outputs multiple graphs focusing specific set characteristics connection state 
fig 
gives example 
graphs explain read graph detail 
time seconds kb common elements tcp trace graphs 
tcp trace graphs certain features common illustrated fig 

circled numbers keyed explanations 
hash marks axis indicate ack received 

hash marks top graph indicate segment sent 

numbers top graph indicate th kilobyte kb sent 

diamonds top graph indicate periodic coarse grained timer fires 
imply tcp timeout just tcp checked see timeouts happen 

circles top graph indicate coarsegrained timeout occurred causing segment retransmitted 

solid vertical lines running height graph indicate segment eventually retransmitted originally sent presumably lost 
notice consecutive segments retransmitted example 
addition common information graph depicts specific information 
bottom graph fig 
simplest shows average sending rate calculated segments 
top graph fig 
complicated gives size dif simplicity say segment lost know sure sender retransmitted 
time seconds kb tcp windows graph 
ferent windows tcp uses flow congestion control 
fig 
shows detail keyed explanations 
dashed line gives threshold window 
slow start marks point congestion window growth changes exponential linear 

dark gray line gives send window 
minimum sender buffer size receiver window defines upper limit number bytes sent acknowledged 

light gray line gives congestion window 
congestion control upper limit number bytes sent acknowledged 

thin line gives actual number bytes transit time transit mean sent acknowledged 
window graph presents lot information easy get lost detail 
assist reader developing better understanding graph appendix presents detailed description behavior depicted fig 

graphs just described obtained tracing information saved protocol available protocol running simulator real network 
simulator reports certain information rate kb data entering leaving host router 
router traces save size queues function time time size segments dropped due insufficient queue space 
techniques section motivates describes techniques vegas employs increase decrease losses 
technique results timely decision retransmit dropped segment 
second technique gives tcp ability anticipate congestion adjust transmission rate accordingly 
final technique modifies tcp slow start mechanism avoid packet losses trying find available bandwidth initial slow start 
relationship techniques proposed discussed section appropriate subsections 
new retransmission mechanism reno uses mechanisms detect retransmit lost segments 
original mechanism part tcp specification retransmit timeout 
round trip time rtt variance estimates computed sampling time segment sent ack arrives 
bsd implementations clock time round trip ticks ms 
checks timeouts occur coarse grain clock ticks 
coarseness inherent mechanism implies time interval sending segment lost timeout segment resent generally longer necessary 
example series tests internet losses resulted timeout took reno average ms time sent segment lost timed resent segment ms correct timeout interval accurate clock 
unnecessarily large delay go unnoticed fast retransmit fast recovery mechanisms incorporated reno implementation tcp detailed description see 
reno retransmits coarse grain timeout occurs receives duplicate acks usually 
reno sends duplicate receives acknowledge received previous segments 
example reno receives segment segment dropped send duplicate ack segment segment arrives segment arrives 
sender sees third duplicate ack segment sent receiver gotten segment retransmits segment 
fast retransmit fast recovery mechanisms successful prevent half coarse grain timeouts occur tcp implementations mechanisms 
early analysis indicated eliminating dependency coarse grain timeouts result increase throughput 
rcvd ack packet packets transit send packet lost rcvd ack packet send packet rcvd ack packet send packet lost gotten ack packet rcvd dup ack packet due packet vegas checks timestamp packet decides retransmit reno need wait rd duplicate ack rcvd ack packets st nd ack retransmission vegas checks timestamp packet decides retransmit reno need wait new duplicate acks example retransmit mechanism 
vegas extends reno retransmission mechanisms follows 
vegas reads records system clock time segment sent 
ack arrives vegas reads clock rtt calculation time timestamp recorded relevant segment 
vegas uses accurate rtt estimate decide retransmit situations simple example fig 
ffl duplicate ack received vegas checks see difference current time timestamp recorded relevant segment greater timeout value 
vegas retransmits segment having wait duplicate acks 
cases losses great window small sender receive duplicate acks reno rely coarse grain timeout mentioned 
time seconds kb time seconds sending kb time seconds queue size router tcp reno traffic throughput kb 
ffl non duplicate ack received second retransmission vegas checks see time interval segment sent larger timeout value 
vegas retransmits segment 
catch segment may lost previous retransmission having wait duplicate ack 
words vegas treats receipt certain acks hint check timeout occur 
checks timeouts rare occasions overhead small 
notice reduce number duplicate acks trigger fast retransmit duplicate acks recommended result unnecessary retransmissions assumptions likelihood packets delivered order 
goal new retransmission mechanism just reduce time detect lost packets third duplicate ack second duplicate ack small savings detect lost packets may second third duplicate ack 
new mechanism successful achieving goal reduces number coarse grained timeouts reno half 
vegas contains reno coarse grain timeout code case new mechanisms fail recognize lost segment 
related making timeouts timely notice congestion window reduced due losses happened current sending rate due losses happened earlier higher rate 
reno possible decrease congestion window losses occurred rtt interval 
contrast vegas decreases congestion window retransmitted segment previously sent decrease 
losses happened window decrease imply network tested implementation vegas congestion avoidance slow start modification described section 
problem bsd versions reno pointed sally floyd 
router router host host host host host host ms delay kbytes sec ethernets network configuration simulations 
congested current congestion window size imply decreased 
change needed vegas detects losses sooner reno 
congestion avoidance mechanism tcp reno congestion detection control mechanism uses loss segments signal congestion network 
mechanism detect incipient stages congestion losses occur prevented 
reno reactive proactive respect 
result reno needs create losses find available bandwidth connection 
seen fig 
shows trace reno connection sending mb data network configuration seen fig 
traffic sources host sending host 
case router queue size packet kb queuing discipline fifo 
seen fig 
reno mechanism detect available bandwidth continually increase window size buffers connection path network segments lost 
detects losses decreases window size 
consequently reno continually network creating losses 
losses may expensive fast retransmit fast recovery mechanisms catch possible set experiment way little losses 
done limiting maximum window size exceeds delay connection plus number buffers bottleneck 
works knows available bandwidth number available buffers bottleneck 
doesn information real conditions consider experiments somewhat unrealistic 
seen losses seconds unnecessarily buffers bottleneck router creating losses connections sharing router 
aside possible set experiment way little losses 
done limiting maximum window size exceeds delay bandwidth product connection plus number buffers bottleneck 
done example 
works knows available bandwidth number available buffers bottleneck 
doesn information real conditions consider experiments somewhat unrealistic 
previously proposed approaches proactive congestion detection common understanding network changes approaches congestion excellent development 
changes seen fig 
time interval seconds 
change increased queue size intermediate nodes connection resulting increase rtt successive segment 
wang crowcroft dual algorithm reacting increase round trip delay 
congestion window normally increases reno round trip delays algorithm checks see current rtt greater average minimum maximum rtts seen far 
algorithm decreases congestion window eighth 
jain card congestion avoidance round trip delay approach analytic derivation socially optimum window size deterministic network 
decision change current window size changes rtt window size 
window adjusted round trip delays product current old theta rtt current rtt old follows result positive decrease window size eighth result negative zero increase window size maximum segment size 
note window changes adjustment oscillates optimal point 
change seen network approaches congestion flattening sending rate 
wang crowcroft scheme takes advantage fact 
rtt increase window size segment compare throughput achieved throughput window segment smaller 
difference half throughput achieved segment transit case connection decrease window segment 
tri calculates throughput dividing number bytes outstanding network rtt 
vegas approach similar tri looks changes throughput rate specifically changes sending rate 
differs tri calculates throughputs differently looking change throughput slope compares measured throughput rate expected throughput rate 
basis idea seen fig 
region seconds 
window size increases expect throughput sending rate increase 
throughput increase available bandwidth point increase window size results segments buffer space bottleneck router 
vegas uses idea measure control amount extra data connection transit extra data mean data sent bandwidth connection exactly matched available bandwidth network 
goal vegas maintain right amount extra data network 
obviously connection sending extra data cause congestion 
obviously connection sending little extra data respond rapidly transient increases available network bandwidth 
vegas congestion avoidance actions changes estimated amount extra data network dropped segments 
describe algorithm detail 
note algorithm effect slow start 
vegas behavior slow start described section 
define connection basertt rtt segment connection congested 
practice vegas sets basertt minimum measured round trip times commonly rtt segment sent connection router queues increase due traffic generated connection 
assume overflowing connection expected throughput expected basertt size current congestion window assume purpose discussion equal number bytes transit 
second vegas calculates current actual sending rate 
done recording sending time distinguished segment recording bytes transmitted time segment sent received computing rtt arrives dividing number bytes transmitted sample rtt 
calculation done round trip time 
third vegas compares actual expected adjusts window accordingly 
diff expected actual 
note diff positive zero definition actual expected implies need change basertt latest sampled rtt 
define thresholds ff fi roughly corresponding having little extra data network respectively 
diff ff vegas increases congestion window linearly rtt diff fi vegas decreases congestion window linearly rtt 
vegas leaves congestion window unchanged ff diff fi 
intuitively farther away actual throughput gets expected throughput congestion network implies sending rate reduced 
fi threshold triggers decrease 
hand actual throughput rate gets close don know exact value basertt experience suggests algorithm sensitive errors basertt 
attempt keep overhead vegas congestion avoidance mechanism small possible 
help quantify effect ran reno vegas connected ethernet measured penalty 
overhead expected drop processors faster 
time seconds kb time seconds sending kb time seconds cam kb time seconds queue size router tcp vegas traffic throughput kb 
expected throughput connection danger utilizing available bandwidth 
ff threshold triggers increase 
goal keep ff fi extra bytes network 
algorithm just compares difference actual expected throughput rates ff fi thresholds thresholds defined terms kb accurate think terms extra buffers connection occupying network 
example connection basertt ms segment size kb ff kb fi kb think ff saying connection needs occupying extra buffers network fi saying occupy extra buffers network 
practice express ff fi terms buffers extra bytes transit 
linear increase decrease mode opposed slow start mode described set ff fi 
interpreted attempt extra buffers connection 
settled values ff fi smallest feasible values 
want ff greater zero connection buffer bottleneck router 
aggregate traffic connections decreases bound happen connection take advantage extra available bandwidth immediately having wait rtt delay necessary linear increase occur 
want fi buffers greater ff small sporadic changes available bandwidth create oscillations window size 
words ff gamma fi region provides damping effect 
goal mechanism avoid congestion limiting number buffers bottleneck may able achieve large number bulk data connections going bottleneck small buffer size 
vegas successfully limit window growth connections smaller round trip times 
mechanisms vegas meant ultimate solution represent considerable enhancement reno 
time seconds cam kb congestion detection avoidance vegas 
fig 
shows behavior tcp vegas traffic condition reno ran fig 

new type graph third depicts congestion avoidance mechanism cam vegas 
detailed graph fig 
keyed explanation 
small vertical line rtt shows times vegas congestion control decision computes actual adjusts window accordingly 

gray line shows expected throughput 
throughput get bytes transit able get connection basertt 

solid line shows actual sending rate 
calculate number bytes sent rtt 

dashed lines thresholds control size congestion window 
top line corresponds ff threshold bottom line corresponds fi threshold 
fig 
shows trace vegas connection transferring mbyte data sharing bottleneck router tcplib traffic 
third graph shows output produced traffic protocol simulating tcp traffic thin line sending rate kb seen ms intervals thick line running average size 
bottom graph shows output bottleneck link maximum bandwidth kb clearly shows vegas congestion avoidance mechanisms throughput adapts changing conditions network 
example background traffic increases seconds third graph vegas connection detects decreases window size top graph results reduction sending rate second graph 
background traffic slows seconds vegas connection increases window size correspondingly sending rate 
bottom graph shows time utilization bottleneck link 
contrast fig 
shows behavior reno similar conditions 
shows little correlation window size level background traffic 
example background traffic increases seconds reno connection keeps increasing window size congestion 
results losses connections part background traffic 
graph shows seconds mbyte transfer took seconds complete transfer 
bottom graph shows utilization bottleneck link 
important thing take away information vegas increased throughput result bandwidth away reno connections due efficient utilization bottleneck link 
fact reno connections slightly better background traffic running top vegas compared traffic running top reno see section 
time seconds kb time seconds cam kb time seconds traffic kb time seconds bottleneck output kb tcp vegas tcplib generated background traffic 
modified slow start mechanism tcp self clocking protocol uses acks clock strobe new packets network 
segments transit connection retransmit timeout acks serve strobe 
slow start mechanism gradually increase amount data transit attempts keep segments uniformly spaced 
basic idea send segment starting restarting loss acks received send extra segment addition amount data acknowledged ack 
example receiving host sends acknowledgment segment receives sending host send segment rtt second rtt third 
easy see increase exponential doubling sending rate rtt 
behavior slow start mechanism seen fig 
fig 

occurs twice interval seconds interval seconds coarse grain timeout 
behavior initial slow start different ones occur important respect 
initial slow start priori knowledge available bandwidth exponential growth window slow starts time seconds kb time seconds sending kb time seconds traffic kb time seconds bottleneck output kb tcp reno tcplib generated background traffic 
occurs middle connection knowledge window size losses occurred reno considers half value safe 
retransmit timeout occurs reno sets threshold window half congestion window 
slow start period ends exponentially increasing congestion window reaches threshold window increase linear approximately segment rtt 
congestion window stops exponential growth half previous value losses occur slow start period 
knowledge safe window size connection starts 
initial threshold window value small exponential increase early take long time linear increase arrive optimal congestion window size 
result throughput suffers 
hand threshold window set large congestion window grow available bandwidth exceeded resulting losses order number available buffers bottleneck router losses expected grow network bandwidth increases 
needed way find connection available bandwidth incur kind losses 
incorporated congestion detection mechanism slow start minor modifications 
time seconds kb time seconds sending kb time seconds queue size router time seconds kb time seconds sending kb time seconds queue size router tcp vegas left experimental right 
able detect avoid congestion slowstart vegas allows exponential growth rtt 
congestion window stays fixed valid comparison expected actual rates 
actual rate falls expected rate equivalent router buffer vegas changes slow start mode linear increase decrease mode 
behavior modified slow start seen fig 
fig 

reason need measure actual rate fixed congestion window want actual rate represent bandwidth allowed connection 
send data acknowledged ack slow start reno sends extra segment ack received 
mechanism highly successful preventing losses incurred initial slow start period quantified section 
problems remain slow start period 
segments sent rate higher available bandwidth twice available bandwidth depending frequency segment segments 
results bottleneck router having buffer half data sent rtt increasing likelihood losses slow start period 
network speeds increase amount buffering needed 
second vegas congestion avoidance mechanism initial slow start period quite effective overshoot available bandwidth depends buffering bottleneck router prevent losses realizing needs slow 
specifically connection handle particular window size vegas double window size consequence double sending rate rtt 
point available bandwidth exceeded 
experimented solution problems 
simplify discussion refer alternative version vegas experimental slowstart mechanism vegas 
vegas spacing acknowledgments gauge available bandwidth 
idea similar keshav packet pair probing mechanism uses spacing segments sent slow start period 
segments results robust algorithm segments 
available bandwidth estimate set threshold window appropriate value vegas overshoot available bandwidth 
specifically ack received vegas schedules event certain point available bandwidth estimate increase congestion window maximum segment size 
contrast increasing window immediately receiving ack 
example assume rtt ms maximum segment size kbyte available bandwidth estimate currently kb slow start period time divided intervals length equal rtt 
current rtt interval expecting acks arrive vegas uses bandwidth estimate kb guess spacing incoming acks kb kb ms ack received schedules event increase congestion window send segment ms theta 
graphs fig 
show behavior vegas left vegas right initial slow start 
set experiments available bandwidth kb buffers router 
looking graphs left see packet lost second indicated thin vertical bar result sending kb vegas detected problems kb doubled sending rate particular case buffers protect losses 
bottom graph demonstrates need buffer half data sent rtt result sending rate twice available bandwidth 
graphs right illustrate behavior vegas 
sets threshold window dashed line available bandwidth estimate 
results congestion window halting exponential growth right time sending rate equals available bandwidth preventing losses 
middle graph shows sending rate exceeds available bandwidth kb 
bottom graph shows vegas need buffers vegas 
notice available bandwidth estimate jump immediately available bandwidth rate control rtt interval congestion result connection time 
possible network connection slow start time upper bound number bytes sent rtt congestion occurs regardless number connections simultaneously doing slowstart twice number bytes handled connection 
limit connection jumps available bandwidth 
strongly recommend doing known priori connections sharing path won increase sending rate time 
traces illustrate vegas experimental slow start mechanism fact address problems vegas outlined simulation data indicates new mechanism measurable impact throughput marginally improves loss rate 
additional simulations expose situations vegas beneficial decided include modifications vegas 
results section vegas vegas 
performance evaluation section reports analyzes results internet simulator experiments 
results internet experiments evidence vegas enhancements reno produce significant improvements throughput higher number losses half real conditions 
simulator experiments allow study related issues vegas connections affect reno connections happens connections running vegas 
note simple move protocol simulator real world numbers reported section exactly code internet results measurements tcp internet 
specifically measured tcp transfers university arizona ua national institutes health nih 
connection consists hops passes denver st louis chicago cleveland table mbyte transfer internet 
reno vegas vegas throughput kb throughput ratio retransmissions kb retransmit ratio coarse timeouts table effects transfer size internet 
kb kb kb reno vegas reno vegas reno vegas throughput kb throughput ratio retransmissions kb retransmit ratio coarse timeouts new york washington dc 
results derived set runs day period january 
run consists set transfers ua nih reno sends mb kb kb version vegas ff fi denoted vegas sends mb kb kb second version vegas ff fi denoted vegas sends mb inserted second delay transfer run give network chance settle run started approximately hour shuffled order transfers run 
table shows results mb transfers 
depending congestion avoidance thresholds shows improvement reno throughput retransmissions 
comparing vegas reno run vegas outperforms reno time levels congestion middle night periods high load 
throughput little higher bigger thresholds vegas connection buffers bottleneck router fill occurring background traffic slowed 
higher buffer utilization bottleneck resulted higher losses slightly higher delays 
prefer conservative approach fewer resources settled avoidance thresholds ff fi 
concerned vegas throughput improvement depended large transfer sizes varied size transfer 
table shows effect transfer size throughput retransmissions reno vegas 
observe vegas better relative reno transfer size decreases 
terms throughput see increase 
results similar retransmissions relative number vegas retransmissions goes reno reno 
notice number kilobytes retransmitted reno starts flatten transfer size decreases 
decreased transfer size half mb kb see decrease number kilobytes retransmitted 
decrease transfer size fourth previous value kb kb number kilobytes retransmitted decreases 
indicates approaching average number kilobytes retransmitted due reno slowstart losses 
results conclude kbs retransmitted slow start conditions experiment 
hand number kilobytes retransmitted vegas decreases linearly respect transfer size 
indicates vegas eliminates nearly losses slow start due modified slow start congestion avoidance 
note transfer size smaller twice bandwidth delay product losses vegas reno table kb mb transfers 
reno reno reno vegas vegas reno vegas vegas throughput kb throughput ratios retransmissions kb retransmit ratios bottleneck router buffers absorb temporary sending rates connections available bandwidth 
simulation results subsection reports results series experiments kernel simulator 
simulator allows better control experiment particular gives opportunity see vegas gets performance expense reno connections 
note experiments subsection network configuration shown fig 

run topologies different bandwidth delay parameters similar results 
experiments studying tcp connections interfere 
start mb transfer variable delay start kb transfer 
transfer sizes delays chosen ensure smaller transfer contained completely larger 
table gives results possible combinations column heading reno vegas denotes kb transfer reno contained mbyte transfer vegas 
combination table gives measured throughput number kilobytes retransmitted transfers case reno vegas kb reno transfer achieved kb throughput rate mbyte vegas transfer achieved kb throughput rate 
ratios throughput rate kilobytes retransmitted relative reno reno column 
values table averages runs buffers routers comparing small transfer large transfer column meaningful 
large transfer able run test 
delay starting smaller transfer ranging seconds 
main thing take away numbers vegas adversely affect reno throughput 
reno throughput stays pretty unchanged competing vegas ratios reno reno vegas vegas reno respectively 
competes vegas combined number kilobytes retransmitted pair competing connections drops significantly 
combined reno reno retransmits kb compared kb reno vegas kb vegas reno 
note combined vegas vegas retransmits kb average indication congestion avoidance mechanism working 
probability exactly connections time small real life modified experiment adding tcplib background traffic 
results similar reno vegas experiment reno increase retransmission versus background traffic 
increase losses reno reno vegas case explained follows 
vegas connection starts full bandwidth kb time reno connection starts 
vegas detects network starting get congested decreases sending rate kb losses incurred reno kb approximately losses reno experiences running network kb available bandwidth available buffers bottleneck router 
reason losses smaller kb transfer reno reno experiment time kb transfer starts mb connection stopped transmitting due losses slow start won start sending times seconds 
reno connection sending kb kb available bandwidth buffers table mbyte transfer tcplib generated background reno traffic 
reno vegas vegas throughput kb throughput ratio retransmissions kb retransmit ratio coarse timeouts bottleneck router losses kb 
type behavior characteristic reno slightly changing parameters network observe major changes reno behavior 
vegas hand show discontinuity behavior 
background traffic measured performance connection network loaded traffic generated tcplib 
protocol traffic running host host fig 
mbyte transfer running host host 
set experiments tcplib traffic running reno 
table gives results reno versions vegas vegas vegas 
varied thresholds study algorithm 
numbers shown averages runs obtained different seeds tcplib buffers routers 
table shows throughput rate distinguished connections protocols ratio reno throughput 
gives number kilobytes retransmitted ratio retransmits reno average number coarse grained timeouts transfer 
example vegas better throughput reno losses 
note little difference vegas vegas 
simulations tell expected improvement vegas reno improvement throughput half losses 
results experiments indicate gains vegas expense reno belief supported fact background traffic throughput unaffected type connection doing mbyte transfer 
ran tests background traffic vegas reno 
simulates situation world uses vegas 
throughput kilobytes retransmitted mbyte transfers didn change significantly 
experiments tried variations previous experiments 
results similar changed tcp send buffer size 
summarize experiments results 
ffl way background traffic 
reports change tcp behavior background traffic way way 
modified experiments adding tcplib traffic host host 
throughput ratio stayed loss ratio better 
reno resent data vegas remained 
fact wasn change probably due fact tcplib creates way traffic telnet connections send byte get bytes back ftp connections send get control packets doing transfer 
ffl different tcp send buffer sizes 
experiments reported far ran tcp kb 
experiment tried send buffer sizes kb 
vegas losses stayed unchanged kb kb point buffer decreased throughput 
due protocol able keep pipe full 
reno throughput initially increased buffers got smaller decreased 
remained throughput measured vegas 
previously seen type behavior running reno internet 
look back fig 
see reno increases congestion window uses buffers router loses packets queue 
limit congestion window reducing size send buffer may prevent router queue 
discussion throughput losses metrics transport protocol evaluated 
section discusses issues addressed 
comments relationship efforts improve performance internet 
fairness connection sharing bottleneck link connection receive equal share bandwidth 
unfortunately limited amount information currently available connection endpoints happen help routers 
protocol perfectly fair need way decide level fairness acceptable 
far internet community reno level fairness acceptable decided compare vegas fairness levels reno judge terms 
comparisons need metric 
decided jain fairness index defined follows set throughputs xn function assigns fairness index set xn throughputs nonnegative fairness index results numbers 
throughputs fairness index 
users receive equal throughput remaining gamma users receive zero throughput fairness index ran simulations connections sharing bottleneck link connections propagation delay half connections twice propagation delay half 
different propagation delays appropriate results averaged 
case connections connection transferring mb reno slightly fair vegas connections propagation delay vs vegas slightly fair reno propagation delay larger half connections vs 
experiments connections connection transferring mb vegas fair reno experiments regardless propagation delays vs 
study effect reno connections vegas connections vice versa ran connections sending mb data 
experiment consisted running connections top reno connections top vegas half top reno half top vegas 
little difference fairness index connections running particular tcp implementation vegas reno fairness index connections running tcp implementation sharing bottleneck connections running tcp implementation 
similarly saw little difference average size bottleneck queue 
experiment ran connections background traffic 
experiment vegas fair reno 
conclude vegas fair reno 
stability second concern stability itis undesirable protocol cause internet collapse number connections increases 
words load increases connection recognize decrease sending rate 
point window greater maximum segment size vegas better reno recognizing avoiding congestion seen reno avoid congestion contrary periodically creates congestion 
load high average connection send maximum segment worth data vegas behaves reno 
extreme condition implies coarse grain timeouts involved vegas uses exactly coarse grain mechanism reno 
experimental results confirm router large tcp transfers ts mbps link mbps link tcplib traffic sources hosts ts ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ts ts ts ts ts ts ts ts ts ts ts ts ts ts ts ts sdsc anl psc la sf ch cl complex simulation network 
intuition running connections ms way propagation delay router buffers kb bandwidth produced stability problems 
simulated complex network topologies shown fig 
consists traffic sources contains hosts 
host turn running tcplib traffic 
rectangular boxes represent sources bulk data transfers 
resulting traffic consists nearly new connections established simulated second connection telnet ftp smtp nntp conversation 
stability problems occurred simulations connections running vegas 
summary reason expect vegas lead network collapse 
reason vegas mechanisms conservative nature congestion window increases faster reno maximum segment rtt purpose congestion avoidance mechanism decrease congestion window losses occur slow start vegas stops exponential growth congestion window reno conditions 
queue behavior vegas purposely tries occupy extra buffers path connection possible persistent queues form bottleneck router world ran vegas 
persistent queues turn add latency connections crossed router 
analytical tools currently available realistically model analyze behavior reno vegas rely simulations answer issue 
simulations show average queue sizes reno vegas approximately 
show telnet connections tcplib experience latency average connections vegas reno 
suggest world ran vegas internet latency adversely affected 
bsd variations tcp fluid protocol years especially congestion control mechanism 
general form original mechanism described remained unchanged bsd implementations tahoe reno bsd constants changed 
example implementations ack segment ack segment increase window linear growth segment rtt increase half segment rtt plus th maximum segment size ack received rtt timestamp option 
experimented variations combination version reno reported effective 
example latest version tcp bsd lite achieves worse throughput reno internet type simulations 
compared vegas sunos implementation tcp derived reno reached similar 
alternative approaches addition improving tcp congestion control mechanism large body research addressing general question fairly effectively allocate resources internet 
conclude section discussing relevance tcp vegas efforts 
example gaining attention question guarantee bandwidth real time connections 
basic approach requires intelligent buffer manager placed internet routers 
question relevance tcp vegas light mechanisms 
believe congestion control remain important reasons 
significant fraction data flow internet real time nature bulk transfer applications image transfer want bandwidth currently available 
transfers able vegas compete available bandwidth 
second real time connection unreasonable application request pay minimally acceptable bandwidth guarantee vegas mechanism acquire additional bandwidth current load allows 
example selective acks proposed way decrease number unnecessarily retransmitted packets provide information better retransmit mechanism reno 
selective ack mechanism defined observations compares vegas 
relates vegas retransmission mechanism selective acks affect congestion slow start mechanisms 
second little reason believe selective acks implementation tcp available ftp cdrom com dated 
significantly improve vegas terms unnecessary retransmissions kb mb unnecessarily retransmitted vegas internet experiments 
third selective acks potential retransmit lost data sooner networks large delay bandwidth products 
interesting see vegas selective ack mechanism tandem networks 
note selective acks require change tcp standard vegas modifications implementation change isolated sender 
introduced techniques improving tcp including new timeout mechanism novel approach congestion avoidance tries control number extra buffers connection occupies network modified slow start mechanism 
experiments internet simulator show vegas achieves better throughput fifth half bytes retransmitted compared implementation tcp reno distribution bsd unix 
evidence vegas just fair reno suffer stability problems adversely affect latency 
detailed graph description assist reader develop better understanding graphs gain better insight reno behavior describe detail graphs 
trace reno traffic bottleneck router 
numbers parenthesis refer type line graph 
general output allowed number bytes sent acknowledged congestion window send window 
purpose congestion window prevent realistically reno case control congestion 
send window flow control prevents data sent buffer space available receiver 
threshold window set maximum value kb connection 
soon connection started sides exchange information size receive buffers send window time seconds kb tcp windows graph 
set minimum sender send buffer size receiver window size 
congestion window increases exponentially threshold window 
seconds losses start occur indicated tall vertical lines 
precisely vertical lines represent segments retransmitted usually lost 
second loss detected receiving duplicate acks reno fast retransmit fast recovery mechanisms go action 
purpose mechanisms detect losses retransmit timeout occurs keep pipe full think connection path water pipe goal keep full water recovering losses 
congestion window set maximal allowed segment size connection set zero momentarily allowing lost segment retransmitted 
threshold window set half value congestion window losses assumed safe level losses won occur window size 
congestion window set value retransmitting lost segment increases duplicate ack segments number previous segments carry data new window information 
receiver sends duplicate ack receives segment acknowledge received previous data reception duplicate ack implies packet left pipe 
implies congestion window reach count half data transit received 
point reception duplicate acks allow segment sent 
way pipe kept full half previous value losses occurred previous value assumed available bandwidth half previous value 
earlier versions tcp slow start mechanism losses detected 
implied pipe empty fill 
reno mechanism allows stay filled 
seconds non duplicate ack received congestion window set value threshold window 
congestion window temporarily inflated duplicate acks received mechanism keeping pipe full 
ack received congestion window reset half value losses occurred 
congestion window data sent 
seconds retransmit timeout occurs see black circle top data starts flow 
congestion window increases exponentially threshold window 
little seconds segment sent retransmitted 
skipping seconds notice congestion window increasing linearly threshold window 
acknowledgments sean malley help insightful comments lew berman national library medicine providing machine east coast experiments 

ahn danzig liu yan 
experience tcp vegas emulation experiment 
proceedings sigcomm symposium aug 
press 
brakmo peterson 
performance problems bsd tcp 
acm computer communication review 
press 
danzig jamin 
tcplib library tcp internetwork traffic characteristics 
technical report cs sys computer science department usc 
floyd 
tcp successive fast retransmits 
technical report lawrence berkeley laboratory 
available anonymous ftp ftp ee lbl gov papers ps 

network simulator 
technical report mit sept 
hutchinson peterson 
kernel architecture implementing network protocols 
ieee transactions software engineering jan 
jacobson 
congestion avoidance control 
proceedings sigcomm symposium pages aug 
jacobson braden 
tcp extensions long delay paths 
request comments oct 
jacobson braden borman 
tcp extensions high performance 
request comments may 
jain 
delay approach congestion avoidance interconnected heterogeneous computer networks 
acm computer communication review oct 
jain 
art computer systems performance analysis techniques measurement modeling 
john wiley sons new york 
keshav 
real network simulator 
technical report department computer science uc berkeley 
keshav 
control theoretic approach flow control 
proceedings sigcomm symposium pages sept 
braden 
integrated services internet architecture overview 
request comments sept 
stevens 
tcp ip illustrated volume protocols 
addison wesley publishing new york 
wang crowcroft 
new congestion control scheme slow start search tri 
acm computer communication review jan 
wang crowcroft 
eliminating periodic packet losses tahoe bsd tcp congestion control algorithm 
acm computer communication review apr 
zhang shenker clark 
observations dynamics effects way traffic 
proceedings sigcomm symposium pages sept 
list figures tcp reno trace examples 
common elements tcp trace graphs 
tcp windows graph 
example retransmit mechanism 
tcp reno traffic throughput kb 
network configuration simulations 
tcp vegas traffic throughput kb 
congestion detection avoidance vegas 
tcp vegas tcplib generated background traffic 
tcp reno tcplib generated background traffic 
tcp vegas left experimental right 
complex simulation network 
tcp windows graph 
list tables mbyte transfer internet 
effects transfer size internet 
kb mb transfers 
mbyte transfer tcplib generated background reno traffic 

