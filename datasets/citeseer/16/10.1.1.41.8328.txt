fast versions shor quantum factoring algorithm christof serv lanl gov june fast highly parallelized versions shor algorithm 
sizable quantum computer possible factor numbers millions digits 
main algorithm uses fft fast integer multiplication 
quick reader just read results section 
supported lanl contents motivation 
summary 
assumptions quantum computer architectures 
algorithm standard parallelized addition 
improved standard algorithm parallelizing addition 
second algorithm fft fast integer multiplication assumptions quantum computer architectures standard algorithm qubits 
parallelizing standard algorithm 
fft fast multiplication outline fft multiplication 
level fft multiplication 
computational cost level fft multiply 
space requirements 
time requirements 
results discussion 
appendices parallelizing addition 
log karatsuba algorithm 
fast fourier transform fft fft multiply 
fft algorithm 
quantum fast fourier transform 
computing convolutions fft 
level fft multiply 
level fft multiply 
compute fft reversible computation 

quantum quantum addition 
computing modulus 
computing delta mod 
assessment total cost 
parallelizing 
motivation algorithms useful factor large numbers thousands millions digits 
quantum computers best available decades 
think worth investigate machines 
shows messages encrypted large rsa keys possibly decrypted decades 
summary assumptions quantum computer architectures don know architecture power sizable quantum computers 
may premature optimize quantum algorithm admit results considered rough guide precise predictions 
plausible assumptions architecture quantum computers try justify 
main assumptions qc parallel qubits expensive qc high connectivity qubits qc may slow fault tolerant techniques quantum error correcting codes 
means looking highly parallelizable algorithms don space qubits simpler algorithms 
plenty qubits additional parallelization schemes relatively bad space time tradeoff form propositions fault tolerant techniques especially slow toffoli gates count performance analyses 
algorithm standard parallelized addition improved standard algorithm give improved version standard algorithm uses qubits toffoli gates number bits number factored 
ideas lead improvements due people 
contribution observation compute modular exponentiation correctly input values possible extract period function runs quantum computer 
allows substantial simplifications algorithm 
idea 
rsa widely public key cryptosystem security relies difficulty factor large numbers think shouldn call quantum bit system quantum computer parallelizing addition standard way compute modular exponentiation decompose modular multiplications decomposed additions 
usually addition done bit bit 
propose way parallelize execution time essentially constant large numbers 
space requirements algorithm increase qubits 
second algorithm fft fast integer multiplication directly attack modular multiplication fast fourier transform fft multiplication technique led famous algorithm 
note fft quantum fourier transform 
fourier transforms amplitudes quantum register 
classical operation applied superposition computed quantum parallelism 
applied classical basis state computes fourier transform values represented binary registers 
fft fast integer multiplication complicated consists subroutines figured reversibly 
fourier transform employed usual complex numbers finite ring integers modulo fixed integer 
fft multiply reduces multiplication big numbers smaller multiplications 
technique compute smaller multiplications propose level fft multiply 
investigated numerous versions level fft multiply parallelized addition log karatsuba algorithm modulus form usually 
algorithms perform space karatsuba time discussing possibilities 
assumptions quantum computer architectures mentioned main assumptions quantum computers parallel qubits expensive communication qc fast contrary cellular automaton 
parallelism assumption comes observations qubits controlled exterior field controlled classical computer 
probably qubit qubits independent classical control unit 
explains think qubits expensive want possible 
decoherence strong high rate memory errors acting resting qubits 
necessary periodic error recovery operations quantum error correction resting qubits qc capable high degree parallelism 
note case memory errors dominate gate inaccuracy errors loose running computation parallel increase error rate 
course assumed large quantum computations need fault tolerant techniques see shor 
computational qubits encoded physical qubits operations gates done encoded qubits decoding 
presently proposed schemes shor slower toffoli gates gates propose count toffoli gates assessing execution time 
assume better fault tolerant schemes ones space space consuming concatenation technique see knill aharonov 
think faster ways implementing toffoli gate fault 
argument knill private communication shows possible implement gates set universal gates transversally bitwise individual qubits encoded computational qubits 
errors don lead code space happen couldn detected 
schemes allow transversal implementation cnot hadamard transform 
schemes possible implement toffoli gate transversally 
propose look scheme classical gates toffoli cnot implemented transversally non classical gates hadamard 
help lot shor algorithm probably applications grover algorithm gates classical gates 
think qc may slower todays conventional computers 
think bit gates multi bit gates slow easy keep qubits interacting exterior fields interact strongly 
essentially true quantum computer hardware proposals 
assumption fast quantum communication possible relatively distant parts qc founded think simply necessity quantum computations 
possible qc photons represent qubits coupling photons possible 
connections simply optical possibly simply optical fibers 
ion trap scheme clear large qc hardly consist single ion trap 
extended proposal couple ion trap qubits photons 
degree connectivity may desired 
interpreting results computation time keep mind things worse realistic quantum computer 
general assumption measurements qubits hard fault tolerance harder achieve 
assume classical computation cheaper probably faster quantum computation 
possible pre compute things classically 
course sense certain point 
standard algorithm part shor quantum factoring algorithm consists computing modular exponentiation 
seen classical computation transforms computational basis states computational basis states 
course transformation applied quantum parallelism large superposition states 
think applied just basis state 
differs conventional computation reversible 
shor algorithm compute mod conventional algorithm run reversible machine lot garbage bits produced 
content leaving input general procedure get rid garbage 
say want compute necessarily produce garbage 
get rid nd step copy auxiliary register initialized 
simply done bitwise cnot 
step time reverse copy 
general space size number operations computation 
fortunately better modular exponentiation see 
compute efficiently modular exponentiation large exponent 
method mod mod pi mod mod bits binary expansion numbers mod calculated repeated squaring 
modular exponentiation computed modular multiplication subset numbers 
running product modularly multiply candidate factor mod 
reversibly delta mod delta mod nd step possible modular multiplication function furthermore know efficiently compute inverse 
general scheme reversible computation situation nd step imagine applied inverse obtaining nd step essentially time reverse 
modular multiplication inverse function simply modular multiplication inverse modulo inverse relatively prim assume constant relatively prime gamma mod easily precomputed classically euclid algorithm finding common divisor numbers 
concentrate compute delta mod simplification delta mod delta mod ix mod mod numbers mod precomputed classically 
reduced modular multiplication addition set numbers length modular addition possibilities add numbers modularly compute modulus running sum time add new number compute modulus 
conventional computation st possibility preferable say number bits length number summands 
total sum log bits longer compute modulus number take log steps steps compute modulus addition 
reversible computation problem computing modulus total sum modular addition fixed classical number fist describe modular addition technique show efficient method possible reversible computation 
see non modular addition fixed classical number quantum register 
done directly leaving input 
want addition course done binary place binary place starting significant bit 
binary place compute carry bit 
reversible computation need auxiliary register temporarily hold carry bits get 
say carry bit calculated place number gamma want add bit place operations phi phi parenthesis means logical expression phi means xor addition modulo 
show carries preferable compute new compute carry phi phi realized toffoli gate 
value need toffoli gate binary place toffoli gate carry 
want add conditional quantum bit 
gate conditional bit 
cnot cnot 
increase cost computation lot toffoli gates needs toffoli gates 
preferable little possible conditional enable qubit decides add 
addition propose carries conditional negation enable qubit 
computation usually needs cnot making operation conditional enable qubit avoid costly things 
quantum network shows operations binary place dashed lines mean run algorithm backwards gates depend negated enable bit look modular addition mod note gamma gamma gamma compute condition bit gamma depending add resp 
gamma condition bit 
able compute easy see simply 
formally 
gamma 
gamma 
gamma phi course gamma negative add complement gamma smallest power larger equal addition simply flip bit place value result 
look second step equation addition done 
th binary place classical bit want add gamma bits equal simple addition network described 
cases gamma network complicated way number toffoli gates 
describe case gamma remaining case similar 
gamma gamma dashed line left away compute sum solid forming toffoli gate carries possibly sum 
see network consider separately cases 
case carry set case set 
easy check works 
look computation comparison qu bits 
comparison cost addition 
say start comparison significant bits downwards 
random numbers usually see bits number larger numbers equal differ significant bit go bits 
course quantum parallelism usually fraction superposition computational basis states equal bits looked 
argue fraction small don really care 
generally say compute modular exponentiation wrongly small fraction input values doesn matter 
say mod say fraction input values superposition equal ffl 
scalar product state intended state gamma ffl 
clear little change distribution output values observed quantum computation 
clear quantum computer imperfectly error level expect small 
may true error correction techniques techniques expensive especially space necessary 
classical post processing take errors account 
propose simplify modular exponentiation computation allowing algorithmic deterministic errors 
particular propose compare significant bits numbers compared 
bits equal numbers say 
number larger 
plausible assumption estimating error rate think numbers uniformly distributed random numbers 
mathematically cautiously inclined people questioned validity assumption 
simply assume true note heuristically test running simplified modular exponentiation algorithm conventional computer inputs check error rate 
error rate modular addition tolerate 
modular exponentiation consists modular multiplications consists modular additions 
error rate ffl allowed error rate ffl 
random number assumption says comparison look log gamma log ffl significant bits numbers 
definiteness choose ffl 
bit numbers compare delta bits small fraction estimates cost time space algorithm leave small contribution away note contribution leading order 
toffoli gates 
need toffoli gate binary place carries 
conditional modular addition cost toffoli gates 
look algorithm add summands compute modulus mod 
problem computing modulus total sum function 
propose algorithm total sum compute approximate total sum carries significant bits 
compute course add significant bits summands doesn knill private objection cost 
determine subtract get modulus 
run part algorithm backwards particular detail bs nc mod bs nc mod mod bs nc means integral part compute mod gamma nbs nc 
significant bits want probability wrong modular multiplication smaller ffl 
log correct bits significant bit get bits correct log bits addition computing sum numbers size log bits longer length log addition bits 
won describe detailed quantum circuits rate cost associated relatively low 
exercise ambitious reader go trouble computing separately just copy significant bits look total number toffoli gates modular exponentiation 
simple non modular conditional addition circuit described 
compute sum carries needs toffoli gates binary place 
modular multiplication need additions length need modular multiplication old value running product gamma mod compute modular exponentiation need steps 
gives total toffoli gates 
qubits far algorithm uses qubits leading order 
see look modular multiplication step delta mod delta mod bit number delta mod bit numbers 
qubits workspace needed temporarily store carry bits addition 
get total qubits 
knill private communication possibly observed reduce qubits 
look quantum fft fourier transform amplitudes register 
shor algorithm operation readout 
case simplified see appendix interleaving unitary operations measurements qubits 
procedure structure hadamard transform significant qubit register measure 
observed value apply certain phase shifts qubits register 
hadamard transform second significant qubit measure 
depending measured values significant qubits apply certain phase shifts remaining unobserved qubits 
step consists hadamard transforming significant unobserved qubit measuring applying certain phase shifts remaining unobserved qubits 
values phase shifts depend far measured qubit values 
measured values give binary representation output number 
note bit reversed order get significant bits 
bit inversion feature fft algorithm 
register apply procedure input register action happens registers 
happens input register starts initialized state uniform amplitude superposition possible input values hadamard transforming qubit 
qubits controls modular multiplication decides multiplication done quantum parallel computations 
register undergoes procedure described 
having controlled modular multiplication qubit final 
usually imagine go significant modular multiplications significant ones significance significance associated control bit 
course order multiply doesn matter turn order 
significant qubits ready 
interleave controlled modular multiplication steps steps controlled modular multiplication get bit classical final output 
having hadamard transformed right qubit doesn controls modular multiplication 
qubits uniform amplitude superposition entangled 
don really prepare algorithm prepare qubit just modular multiplication 
eliminated qubit long register leading order need qubits 
parallelizing standard algorithm think classical computation modular exponentiation 
clearly possibilities parallelize algorithm ready space bits 
modular exponentiation consists modular multiplications multiplication consists additions 
look addition number length having just running sum adding summand parallel sum equal subsets summands add partial sums 
extreme case group summands pairs add pair add pairwise sums sum log steps course require order additional bit registers 
reversible computation partial sums possibly roughly doubling cost 
note ideas applied parallelization modular multiplications 
rough considerations show kind parallelization reduces time computation proportion increases space qubits consider space time tradeoff costly assuming qubits expensive just case may keep mind possibility parallelization 
propose technique parallelizing individual addition steps better space time tradeoff 
technique described detail appendix just give rough outline basic ideas usually addition binary place binary place lower significance bit change value higher significance bit 
observation exploit probability dependence goes exponentially distance bits binary representation observation algorithmic errors tolerable 
idea chop numbers added blocks fixed length 
add tw corresponding blocks really know value carry bit coming preceding block 
idea compute sum blocks possible values unknown carry bit 
second step go blocks low high significance block determine correct carry bit 
step takes time proportional length block second step proportional number blocks 
choosing block length number blocks equal get square root speed 
fft fast multiplication standard algorithm directly handle modular multiplication 
want fast integer multiplication techniques compose modular multiplication regular multiplications haven better way 
delta mod delta gamma delta bp delta bc means integral part 
note course precompute classically need significant digits 
compute times bit multiplications 
show reversibly 
way speed multiplication large integers fast fourier transform technique fourier transform performed ring integer modulo 
iterating technique obtains famous strassen algorithm complexity order ln ln ln multiply bit integers 
large numbers fastest known algorithm seldomly quite large numbers ways speeding multiplication faster 
particular log karatsuba algorithm variations 
won space show appendix 
hand fft multiplication technique naturally parallel space 
outline fft multiplication give rough outline speed multiplication fft 
things described details appendices 
say want multiply bit numbers 
split blocks size multiplication consists essentially convolutions delta gammaj deltai deltai deltai range summation indices figured carefully 
expression parenthesis known convolution 
fourier transformation comes fourier transform convolution functions pointwise product fourier transforms functions 
discrete fourier transform true discrete convolutions appearing equation 
discrete fourier transform numbers gamma am 
deltam fast fourier transform algorithm fft compute convolutions scheme delta fft gamma ft delta fft multiplication right hand side means pointwise multiplication 
pointwise multiplication course easier compute convolution furthermore trivially done parallel 
procedure help save time great efficiency fft 
problem really want exact integer arithmetic usual fft real complex numbers compute accuracy 
technique accuracy chosen high rounding gives correct integers 
higher efficiency generalizes fourier transform ring integers modulo fixed modulus 
apart term discrete fourier transform defined ring 
point want able fft algorithm course want convolution theorem true 
fast fourier transform algorithm need 
convolution theorem true furthermore need condition gamma jp true ring mod particular mod 
compute inverse fourier transform furthermore demand inverse ring usually problem 
compute fft modulo ring 
convolution theorem modified get modulus intended results 
usually simply choose modulus larger possible result modulus doesn change 
chinese remainder theorem 
compute convolution respect relatively prime moduli individually small allow recover correct result 
fft algorithm efficient power 
furthermore algorithm strassen chose small power modulus power plus 
operations fft easy multiplication just shift binary modulus easy compute 
precisely strassen chose modulus conditions fulfilled 
adopt choice 
get cost space time algorithm need know parameters number blocks essentially block length rounded power 
ring compute fft ring integer modulo handle numbers bits 
numbers order magnitude product delta usually rounded power 
delta depending things described detail appendix 
level fft multiplication mentioned strassen algorithm iterates fft multiplication technique 
component wise multiplication fft fft done fft multiply 
propose levels 
investigated various algorithms level fft multiply parallelized addition component wise multiplications 
simplicity algorithms turned perform 
particular level fft multiply individual operations fft parallelized described appendix 
important point nd level fft multiply efficient st level size numbers 
remember component wise multiplications done modulo modulus form 
turns done directly minor modification fft multiply 
modification consists multiplication square root 
simple choose power 
level fft parameters characterize second level fft number blocks number bits block 
modulus relative calculate fft 
computational cost level fft multiply see compute modular multiplication reversibly 
propose straight forward scheme bp delta bp delta nbp delta nbp delta pa gamma nbp delta steps compute multiplication garbage 
form pa pa modular multiplication need total simple multiplications form pa level fft multiply look follows delta delta delta pa tilde stands fourier transform delta component wise product 
level fft multiply delta delta pa represents lower level garbage produced multiplied component wise second level fft multiply 
multiplication consists level fft lower level multiplications 
modular multiplication mm write mm fft theta stands lower level multiplication 
schematically step delta done follows theta theta delta carries theta delta delta carries space lowest level multiplication done standard algorithm 
lower level multiplication consists lower level fft lowest level multiplications denoted 
mm fft theta fft theta space requirements look algorithm qubits 
relatively space intensive lower level fft multiply particular lowest level multiplication carries addition eq 

step delta carries space delta modulus 
modular multiplication scheme see apart bit number simplicity neglect relatively small contribution 
get theta delta theta delta delta depending size relative power 
average averaging log space requirements closer 
time requirements know cost fft consists steps form 
mod gamma mod non negative smaller 
costs investigated appendix 
get number toffoli gates operation bit numbers thought standing time toffoli 
measures level fft dominate time parallelized level algorithm 
appendix show parallelize individual fft operations 
number toffoli gates individual fft operation rises parallelization execution time approximately constant range input numbers means execution time parallelized algorithm measured units time needed toffoli gate 
plugging equation get number toffoli gates modular multiplication 
multiplying gives number toffoli gates modular exponentiation delta log delta delta theta log delta delta theta remember level fft parallel algorithm second level algorithm standard algorithm 
fft basic operation carried log delta times 
standard modular multiplication lowest level cost conditional addition 
obtain execution time parallelized algorithm 
drop factors plug execution time parallelized basic fft operation delta log delta log delta jj results dominant part shor quantum factoring algorithm modular exponentiation 
reversible algorithms modular exponentiation perform factoring large numbers 
particular introduced parallelism space qubits 
looked numbers digits approximate results valid range 
improved version standard version shor algorithm uses gates number bits number factored 
fast algorithms version standard algorithm parallelized addition 
performance summarized quantities number qubits algorithm total number toffoli gates execution time parallelized algorithm measured execution times single toffoli gate 
note result approximate valid range looking 
large numbers fft multiplication algorithm compute modular multiplications modular exponentiation 
technique iterated level fft multiply 
main virtue algorithm naturally parallel space qubits 
performance algorithm depends value relative power easy give closed form expressions expressions come rough fits graph 
plotted thick solid lines graph 
thin solid lines refer standard algorithm parallelized addition 
straight lines algorithm 
fair comparison fft algorithm give algorithm amount space space time tradeoff additional parallelization achievable additional space 
zig thin solid line represents 
assumed extra space parallelization space time tradeoff form zig zag amount space fft algorithm non continuous behavior 
straight dotted line standard algorithm note graph logarithmic number bits number factored discussion thin zig zag line lower thick line interest give execution times algorithms amount space 
see cross 
factor numbers bits fft algorithm preferable 
provided necessary qubits available 
quantum computer space speed comparable todays conventional pc fully parallel connected fft algorithm factor numbers millions binary digits 
consider number binary digits 
need qubits 
assuming toffoli execution time computation take month 
standard algorithm take times time 
note computational resources universe factor numbers decimal digits best known classical factoring algorithms 
possibility large numbers factored sizable quantum computers built may interest shows large rsa keys ensure message remains unreadable decades come 
appendices parallelizing addition known technique classical computation add bit numbers decompose blocks length delta simply add corresponding blocks parallel get sum don know carry bit coming preceding block 
idea compute block really pair blocks possibilities assuming carry bit coming preceding block 
takes time 
starting significant block go blocks time determining correct carry block trial additions correct correct carry block 
takes time 
method iterated scheme delta delta take time 
allowed algorithmic errors small fraction input values speed things 
probability flipping block carry bit change carry bit number small generic summands minus number bits 
nd step algorithm somewhat parallelized 
say group blocks superblocks containing blocks delta assume input carry bit superblock compute sequence correct block carry bits superblock 
probability outgoing carry bit superblock wrong incoming carry bit small 
course done parallel superblocks 
probably correct superblock input carry bits compute second sequence bits superblock 
look reversible version 
remember want add fixed classical number quantum register 
propose scheme computational qubits actual number physical qubits higher factor depending fault tolerant scheme may need explanation 
quantum number want add fixed number sequence operations doesn manage get rid input directly called twice nd step 
numbers get guessing input carry blocks 
numbers include output carries blocks 
computed leaving input 
compute leave input addition done carry bits need 
denotes provisional block carry bits determined assuming input carry superblock 
final carry series 
want assemble final sum tells block take remember want addition depending conditional qubit enable 
purpose bitwise bitwise quantum register initialized ready final sum copy block corresponding bit copy corresponding bit 
copy really mean xor 
xor depends need toffoli gate copying binary place 
intermediate quantities get back left schematically second run sequence bitwise xor register second minus 
depending enable bit left 
order result cases register swap exchange bits registers depending propose xor st register nd gives resp 
depending xor nd st costs toffoli gate binary place 
look algorithm performs 
space need 
get need qubits 
store carry bits getting space forces compute 
need qubits versions block carry bits final sum 

see range interested 
standard addition costs parallelization costs additional qubits 
count total number toffoli gates computing costs unconditional addition 
computing costs don carries 
bits computed copying bits depending bit 
certainly done 
cost 
cost copying resp 
get final sum costs 
totals 
twice plus need swap registers depending total addition step costs 
compares standard addition hope get substantial speed due parallelization 
time algorithm take 
measure sequential toffoli gates 
result may depend quantities unknown details quantum computer architecture essentially educated guess 
computed parallel blocks 
costs toffoli time steps 
computation takes steps involving 
true looks computed full parallelism 
practise may possible simultaneously control bit toffoli gates may want copies 
somewhat arbitrarily set time cost computing 
similar situation occurs obtain final sum copying conservative assumption sequentially block get time steps 
total doubled account take account conditional swapping registers 
conditional swapping assume time steps 
total addition step costs toffoli time steps 
index stands parallel 
consider decomposition superblocks blocks 
superblocks large improbable carry runs way 
error probability superblock smaller error probability full addition 
conservatively set ffl 
usual uniform random number assumption get superblock log bits long 
formal generality assume range log length superblock get error smaller ffl reduce length superblock log 
chose reasonable block size superblock note number blocks superblock length block contribute equally computation time minimize chose equal 
get approximate formula computation time addition log range get 
propose algorithm large values simply set 
consider table log delta speed addition get comparison space time full modular exponentiation conventional parallelized addition log karatsuba algorithm 
particular karatsuba algorithm running time log 
series algorithms smaller exponents approaching consider basic case 
conventional computation algorithms usually beats strassen size numbers interest 
course practical applications computer architecture word size play big role 
reversible computation assumptions possible architecture quantum computer things look differently variant strassen algorithm may actual find application 
reason assume qubits expensive 
look algorithms massively parallelized increasing space 
show strassen nicely massive parallelization increase space demand dramatically 
karatsuba naturally parallelized show lot space 
algorithm simple multiply bit numbers split numbers bit pieces assuming 
delta compute product computing products bit numbers takes time 
simple trick allows multiplications gamma gamma note compute iterating technique applying smaller multiplications get asymptotic log performance 
clearly smaller multiplications done parallel 
look space requirements parallelization 
level store bit numbers 
lower level space needed times space needed level 
summing geometric series noting log levels get result need total space log 
expect qubits expensive 
parallelization karatsuba algorithm uses space 
look point levels sums prepared 
fast fourier transform fft fft multiply fft algorithm discrete fourier transform numbers complex numbers gamma deltam am generalized numbers ring replacing fixed ring element 
general course normalization left away gamma deltam am decomposed small prime factors fast fourier transform fft algorithm widely computers 
usually power fft efficient best suited binary digital computers 
demonstrate fft case include normalization easily left away rings 
step fft reduce original task fourier transforms numbers 
iterated log times left trivial fourier transforms single numbers 
start gamma deltam am consider binary representations bn gamma bn gamma mod gamma gamma gamma mod gamma definitions clear 
symbol means integer part 
consider separately cases sum values gamma ea gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma second level gamma 
note leftmost bits parenthesis significant ones 
ea gamma gamma gamma interpret bits reversed order get numbers result right order 
actual operations transformations form numbers gamma quantum fast fourier transform note fourier transform complex numbers unitary transformation complex numbers 
principle possible apply physically amplitudes qubit quantum register gamma jni gamma jni jni computational basis states binary representation note transformation different usually done conventional computers values represented binary words transformed 
misleading say quantum computers faster conventional computers fft 
done efficiently 
fft done level level levels operations level individually unitary 
classical fft level basic operations form eq 
carried 
operations done parallel 
level number gamma transform amplitudes follows see eq 
gamma delta gamma gamma gamma gamma parenthesis mean value binary bits 
operation done steps phase factor multiplying basis states appropriate phase factors gamma gamma gamma gamma gamma gamma gamma step simply hadamard transformation qubit number conditional decomposed conditional individual qubits gamma gamma gamma gamma gates phase shift qubit conditional qubit number note swap bit number gamma bit number bit number gamma bit number get originally intended result usually necessary explicitly 
summarize words carried hadamard transforming significant qubit 
apply appropriate phase shifts significant qubits conditional significant 
hadamard transform second significant qubit conditional apply appropriate phase shifts significant qubits 
hadamard transforming qubit don apply gates 
shor algorithm register observed right measure qubits hadamard transformed interleaving unitary gates measurements 
advantage phase shifts conditional measured qubit don 
note phase shifts small carry log largest level significantly changing state qc 
wait applying phase shifts qubit just hadamard transformed measured 
size phase shift depend measured values higher significance qubits 
apply phase shift qubit hadamard transform measure 
move lower significance qubit 
fault tolerant quantum computing phase shift gates composed gates fixed set universal gates 
negligible part factoring algorithm 
computing convolutions fft say sets numbers gamma 
convolution gamma gamma ffi gamma efficiently computed fft 
statement essentially component wise product fft fft convolution 
try gamma gamman deltam ea gamma gamman deltam gamma deltak gamma deltal gamman ffi gamman ffi gamman step gamma deltan integer delta true sum geometric series general ring required addition 
note gamma gamma convolution gotten second unwanted term 
vanish setting upper half sets equal zero 
compute convolution number sets fft numbers 
level fft multiply assume reader looked outline fft multiply main body 
want fft ring integers modulo fixed element 
note things particular class moduli power 
easy see required operations modulo property eq 
demonstrated book hopcroft 
choose small power operations fft efficient binary digital computer 
mentioned numbers multiplied decomposed blocks bits 
question size blocks choose 
adequate modulus choose block size smaller number blocks 
unfortunately modulus proposed quite large point choosing small blocks course fft numbers operate quickly size modulus 
insist small modulus ready give ease operate trivial find moduli primitive roots condition eq 

may pay path complicated 
back choice choose number blocks size note number numbers fourier transform power 
modulus 
result get truncated block size somewhat log means going order magnitude number bits numbers want multiply 
justification show obtain optimal 
set dlog cases gamma odd gamma power modulus 
odd 
components convolution sum products numbers bits 
convolution truncated modulus require log condition true simply revise choice effectively going larger size algorithm 
practise increase get new 
efficient methods occurs seldomly large choose easier way 
level fft multiply iterate fft multiply apply component product fourier transformed factors 
fft multiply efficient second level lower levels 
second level multiply bit numbers modulo done quite efficiently modifying way computed convolution 
time don pad factors zeros decomposition blocks prime refers second level 
note block size automatically power 
factor decomposed blocks follows gamma delta fft numbers compute convolution numbers get previously unwanted second term eq 
ffi gamman ffi gamman final result fft multiply delta ffi gamman ffi gamman actual product delta ffi gamman modulo similar sign got fft multiply mod delta ffi gamman gamma ffi gamman fft multiply modified get just change sign 
need square root consider gamman deltam deltak deltal ffi ffi ffi gamma ffi doing get choose small power small power 
operations done modulo easy 
reversibly described appendix compute reversibly fft 
clear cost neglected 
chose modulus 
consider separately cases log odd gamma odd modulus safely large won problem result getting truncated computing remainder mod modulus large 
fix problem making fft multiply modulus chinese remainder theorem recover correct result 
computational cost negligible 
just give short outline derivations 
say looking non negative number smaller mod mod 
gamma gamma gamma mod delta gamma mod gamma see compute reversible computation leaving garbage qubits see appendix compute fft reversibly 
compute fft reversible computation show carry basic operations fft 
principle steps reversible fft algorithm particularly suited reversible computation consider fft ring integers modulo modulus form primitive root small power 
basic fft operations acting registers form 
mod gamma mod non negative smaller 
easy see operation reversed multiplicative inverse modulo odd modulus 
standard tricks eqs 
reversible computation get rid garbage input usually find efficient shortcuts try 
haven efficient way doing leaving result rhs eq 
propose scheme leaves qubits garbage 
problem doesn take space expected find elegant solution 
everybody interested invited try better 
note fft perform soon undone garbage qubits go away 
way attack problem decompose steps reversible 
steps 
step gamma 
step gamma 
mod gamma mod 
step gamma mod 
gamma mod 
step consists additions quantum numbers big problem 

step consists conditionally subtracting conditionally adding gamma problem conditional bits 

step looks simple operation easy conventional computation haven managed find efficient scheme leaving garbage 
quantum quantum addition 
step consists operations 
subtraction essentially complement technique 
expect addition quantum number quantum number toffoli gates previously described addition fixed classical number quantum number 
note quantum numbers stay operation reversible 
please remember fft fourier transforms amplitudes admit deciding count toffoli gates tempted minimize number may quite clean lets add register 
temporarily need carry qubits initially set 
denote carry comes gamma st binary place place value binary place operations compute carry compute sum bit phi phi parenthesis means logical expression phi addition modulo xor 
reason prefer calculate sum bit 
phi phi sequence quantum gates accomplishes check correctness sequence formulas recommend considering separately case 
gates left compute sum rest carry 
having computed sum run backwards carries 
don want sum leave away leftmost gates 
computing modulus want gamma 
mod sigma gammaf gamma mod delta gammab gamma note gamma 
compute conditional bits gamma gamma subtracting add obtained negative number course remain 
complement notation negative numbers gamma trivial obtain 
conditional addition get gamma gamma result get rid conditional bits 
equivalent computing bits result sigma delta 
odd easy obtain xor bits 
seen follows sigma delta gamma gamma gamma gamma gamma sum know gamma vice versa 
read simply lowest significance bits sigma delta 
reduce garbage qubit 
get rid remaining bit costly propose 
show done 
consider cases gamma delta gamma sigma fm gamma delta sigma gamma gamma sigma delta gamma sigma delta note doing quantum parallelism compute expressions 
quite costly prefer leave garbage qubit 
computing delta mod gamma mod modulus relatively easily compute remainder decomposing blocks bits mod deltan mod gamma mod terms sum 
potentially non zero bits blocks overlap exactly bit potential non zero bits 
compute sum deltan leave bits 
bits st bit propose leave 
may add sum negative get correct remainder 
propose leave associated control qubit haven easy way 
assessment total cost gamma 
mod gamma 
gamma gamma mod sigma delta odd gamma mod 
gamma mod garbage qubits lines unconditional additions 
carries doubles number toffoli gates 
lines essentially conditional addition type standard algorithm 
cost line comes conditional addition total number toffoli gates elementary fft operation fft numbers multiplied log delta log levels level elementary operations carried 
parallelizing large want parallelize additions scheme furthermore large substantial simplifications lead small algorithmic error rate 
improvements level fft proposed level fft multiply scheme dominate execution time 
estimated range consider error rate elementary fft operation gamma leads tolerable error rate 
level fft larger simplifications special form modulus 
assume numbers modulo smaller note reduce garbage bits assume zero st bit 
list costs individual operations lines cost simplified essentially involve addition subtraction 
note condition bit replaced trivial compute 
adding subtracting simple 
adding subtracting costs bit 
keep error rate low need extend addition significant bits 
conditional addition costs delta toffoli gates 
second third lines done simultaneously 
remains lines type additions 
turns scheme parallelizing type additions works just additions 
get addition total number toffoli gates number sequential toffoli gates essentially time measured units toffoli execution times 
get parallelized simplified version elementary fft operation delta delta delta delta delta delta exercise ambitious reader due uniformly distributed random number assumptions admit confident case quantum computations cold trapped ions physical review letters volume number may page quantum state transfer entanglement distribution distant nodes quantum network quant ph ch 
monroe atomic physics ion traps physics world march shor time algorithms prime factorization discrete logarithms quantum computer 
proc 
th annual symposium foundations computer science 
ieee press pp nov quant ph siam computing shor fault tolerant quantum computation 
th symposium foundations computing ieee computer society press pp 
quant ph knill zurek accuracy threshold quantum computation quant ph aharonov ben fault tolerant quantum computation constant error quant ph gershenfeld chuang bulk spin resonance quantum computer 
science coppersmith ibm research report rc griffiths niu phys 
rev lett 
paz phys 
rev phys 
rev beckman phys 
rev knill private communication 
daniel theory fault tolerant quantum computation quant ph journal ref phys rev strassen zahlen computing textbook aho hopcroft ullman design analysis computer algorithms addison wesley textbook knuth art computer programming addison wesley 
