interpreter compiler staging monads tim sheard el benaissa paci software research center oregon graduate institute box portland oregon usa april writing goals 
promote metaml programming language writing staged programs second demonstrate staging program signi cant bene ts 
example derivation executable compiler small language 
derive compiler rigorous fashion semantic description language 
done staging denotational semantics expressed monadic interpreter 
compiler program generator program source language program input producing ml program target 
ml program produced restricted subset ml programmer complete control 
encapsulated special data structure called code 
meta programming capabilities metaml allow data structure directly executed run time code generation analysed 
illustrate analysis generated code build source source transformation applies monad laws signi cantly improve generated code 
compilers staged interpreters interpreters implemented high level declarative languages close interpreted language denotational semantics 
interpreters usually development prototypes prototypes lack ciency connection underlying system compiled code run 
expressed monadic style interpreter mapped closer underlying system structuring properties monad allow interpreter reused system evolves :10.1.1.17.268:10.1.1.46.9009
ort build interpreter considered wasteful programmer needs re implement compiler scratch building interpreter 
solution problem multi step method 
construct denotational semantics interpreter functional language 
second capture ects language environment target language run monad 
rewrite interpreter monadic style 
third stage interpreter meta programming techniques 
staging similar staging interpreters partial evaluator explicit implicit programmer places annotations directly automatic binding time analysis discover placed 
leaves programmers complete control limit appears residual program 
fourth resulting program datastructure program directly executed analysed 
analysis include source source transformations translation form intermediate code assembly language 
programmer complete control structure residual program trivial task 
staging interpreters partial evaluation done 
contribution show done single program 
system incorporating staging rst class feature language powerful tool 
tool write compiler source language semantics staged translated optimized single paradigm 
requires additional processes tools complete control programmer maintaining direct link semantics interpreter compiler 
staging organizes task constructing compiler simple incremental steps semantic connection maintained stage derivation 
step relatively easy task compared building compiler scratch 
constructing compiler staged language bene ts simplicity 
task simple builds incrementally previous tasks 
correctness 
compiler remains connected semantics 
artifact produced task provably correct respect artifacts previous tasks 
nal artifact compiler language semantics equivalent original semantics 
reuse 
artifact reuses code previous artifact 
control 
programmer complete control resulting output 
develops program staging mind completely controls structure residual program 
staging metaml metaml conservative extension standard ml 
extensions include staging annotations 
delay expression stage places meta brackets 
expression pronounced bracket type int pronounced code int 
illustrate important features staging annotations short metaml session 
val val int val quad lift val quad int int int int fun val fn int int val val int run val int users access metaml read type eval print top level 
declaration read typed see consistent type int evaluated value type printed 
declaration quad contrasts normal evaluation ways objects type code constructed 
placing brackets expression defers computation stage returning piece code 
lifting expression lift evaluates expression lifts value piece code evaluated returns value 
brackets free variable creates new constant piece code value variable 
constants print sign indicate constants 
call lexical capture free variables 
metaml operators identi ers free occurrences operators appear front 
declaration function illustrates larger pieces code constructed smaller ones escape annotation 
bracketed expressions viewed frozen evaluation apply brackets 
convenient allow reduction steps inside large frozen expression constructed splicing previously constructed piece code 
metaml allows escape frozen expression pre xing sub expression tilde character 
escape appear inside brackets 
declaration function increment applied piece code constructing new piece code 
running piece code strips away enclosing brackets evaluates expression inside 
monads metaml assume reader working knowledge monads :10.1.1.33.5381
unit bind formulation monads 
metaml monad data structure encapsulating atype constructor unit bind functions 
datatype monad mon 
unit function 
bind function de nition uses sml post notation type application non standard extensions ml 
declares argument type constructor monad unary type constructor 
say kind 
second declares arguments constructor mon polymorphic functions 
type variables brackets universally quanti ed 
explicit type annotations datatype de nitions ect extensions hindley milner type inference system known poses problems metaml type inference engine 
metaml monad rst class pre de ned built type 
particular syntactic forms aware monad datatype return 
return metaml syntactic interface unit bind monad 
modeled notation haskell 
important di erence metaml return parameterized expression type monad 
users may freely construct monads careful instantiation meets monad axioms 
return syntactic sugar syntactic sugar derived form mon unit bind bind fn return mon unit bind unit addition syntactic sugar allows sequence xi ei forms de nes nested sequence 
example monad laws expressed metaml return notation return return step method compiler development section illustrate method building front compiler small imperative language 
proceed steps 
introduce language denotational semantics giving monadic interpreter stage metaml program 
second stage interpreter stage metaml program order produce compiler 
third illustrate usefulness staging approach de ning function takes output code compiler input returns optimized version 
function simply pattern matching implementation monadic identity associativity laws 
dramatic di erence quality generated code completely reusable laws hold monad just monad example 
illustrates usefulness combining monadic staged approaches 
monadic structure interpreter usefulness monadic laws re captured domain speci manner compiler 
structure provided staging pattern matching rewrite system impossible compile time computations intervene recognition patterns impossible 
staged interpreter compile time code disappeared time want apply pattern monadic law transformer 
language section weintroduce simple language composed syntactic elements expressions exp commands com 
simple language expressions composed integer constants variables operators 
simple algebraic datatype describe syntax expressions metaml datatype exp constant int variable string minus exp exp greater exp exp times exp exp commands include assignment sequencing commands conditional command loops print command declaration introduces new statically scoped variables 
declaration introduces variable provides expression de nes initial value limits scope enclosing command 
simple algebraic datatype describe syntax commands datatype com assign string exp seq com com cond exp com com exp com declare string exp com declare print exp print simple program concrete syntax declare declare print encoded abstractly datatypes follows val declare constant declare constant seq greater variable constant seq assign minus variable constant assign minus variable constant print variable structure solution staging important technique developing cient programs requires 
get best results design algorithms staged solutions mind 
meaning program depends meaning component expressions commands 
case expressions meaning function environments integers 
environment mapping names introduced declare values 
ways mapping implemented 
intend stage interpreter break mapping components 
rst component list names completely known compile time 
second component list integer values behaves stack known run time compiled program 
functions access environment distribute computation stages 
determining location name appears name list second accessing correct integer stack location 
complicated compiler mapping names locations depend just declaration nesting depth principle remains 
variable location completely computed compile time important locations appear constants stage 
splitting environment components standard technique called binding time improvement partial evaluation community 
capture precisely purely functional implementation 
type location int type index string list type stack int list position string index location fun position name index fun pos nm nms name nm pos nms pos index fetch location stack int fun fetch vs fetch vs put location int stack stack fun put vs vs put vs meaning com stack transformer output accumulator 
transforms stack values variables scope stack presumably di erent values variables accumulating output printed program 
produce monadic interpreter de ne monad encapsulates index stack output accumulation 
intend stage interpreter encapsulate index monad 
want monad encapsulate dynamic part environment stack value accessed position stack output accumulation 
monad combination monad state monad output 
datatype stout int list int list string fun stout fun unit stout fn fun bind stout fn val val val mswo monad mon unit bind monad state output non standard morphisms describe stack extended shrunk new variables come scope value particular variable read updated printed text accumulated 
thought action stack variables action print stream 
read location int fun read stout fn ns fetch ns ns write location int unit fun write stout fn ns put ns push int unit fun push stout fn ns ns pop unit val pop stout fn ns ns output int unit fun output stout fn ns ns tostring step monadic interpreter expressions alter stack produce output give function expressions monadic uses simpler monad monad de ned 
choose monad state output implementation reasons 
simplicity presentation language semantics evolve monad easy reuse monadic evaluation function changes 
non standard morphism evident eval function read describes value variable obtained 
monadic expressions takes index mapping names locations returns computation producing integer 
eval exp index int fun eval exp index case exp constant return mswo variable val loc position index read loc minus mswo eval index eval index return mswo greater mswo eval index eval index return mswo times mswo eval index eval index return mswo interpreter com uses non standard morphisms write push pop transform stack morphism output add output stream 
interpret com index unit fun interpret stmt index case stmt assign name val loc position name index mswo eval index write loc seq mswo interpret index interpret index return mswo cond mswo eval index interpret index interpret index body fun loop mswo eval index return mswo mswo interpret body index loop loop declare nm stmt mswo eval index push interpret stmt nm index pop print mswo eval index output interpret fairly standard feel things worth pointing 
clause declare constructor calls push pop implicitly changes size stack explicitly changes size index nm index keeping synch 
evaluates initial value new variable extends index variables name stack value executes body declare 
removes binding stack pop implicitly threading accumulated output 
mapping scope body declaration 
second clause constructor introduces local tail recursive function loop 
function emulates body 
tempting control recursion introduced recursion interpret function clause body mswo eval index return mswo mswo interpret body index interpret body index test loop true run body transform stack accumulate output repeat loop 
strategy correct disastrous results stage interpreter cause rst stage loop nitely 
recursions going 
unfolding nite data structure encodes program compiled second recursion program compiled 
interpreter single loop su ces 
staged interpreter loops necessary 
rst stage unfold program compiled terminate 
plan ahead follow step process 
despite concessions staging interpreter clear concise describes semantics language straight forward manner 
step staged interpreter specialize monadic interpreter program add levels staging annotations 
result rst stage intermediate code executed returns value program 
bracket annotation enables describe precisely code generated run stage 
escape annotations allow escape recursive calls interpreter compiling program 
eval exp index int fun eval exp index case exp constant return mswo lift variable val loc position index read lift loc minus mswo eval index eval index return mswo greater mswo eval index eval index return mswo times mswo eval index eval index return mswo lift operator inserts value loc argument action 
value loc known rst stage compile time transformed constant second stage run time lift 
understand escape operators necessary consider simple example eval minus constant constant 
unfold example hand eval minus constant constant mswo eval constant eval constant return mswo mswo return mswo return mswo return mswo mswo return mswo return mswo return mswo mswo return mswo return mswo return mswo recursive call produces bracketed piece code spliced larger piece constructed 
recall escapes may appear level higher 
splicing axiomatized reduction rule 
applies level 
nal step mswo mswo occurs free variables lexically captured 
state equivalence relationship monadic eval staged eval 
axiomatic semantics metaml particular axioms annotations splice axiom 
proposition 
expressions exp list names index eval exp index run eval exp index proof 
argue trivial proof proposition 
eval simply copy staging annotations erased functions type check semantics metaml equal 
include traditional proof appendix axiomatic semantics metaml see appendix 
interpreter commands 
staging interpreter commands proceeds similar manner interpret com index unit fun interpret stmt index case stmt assign name val loc position name index mswo eval index write lift loc seq mswo interpret index interpret index return mswo cond mswo eval index interpret index interpret index body fun loop mswo eval index return mswo mswo interpret body index loop loop declare nm stmt mswo eval index push interpret stmt nm index pop print mswo eval index output example 
function interpret generates piece code com object 
illustrate apply simple program declare print obtain mswo return mswo push mswo mswo mswo read return mswo return mswo write mswo read output return mswo pop note staged program essentially compiler translating syntactic representation program monadic object program compute meaning 
program decrement print ofx 
fully executable 
simply run operator metaml executed prototyping purposes 
equally important object program just piece data analyzed translated layer translation pipeline 
reader notice object program simpli ed applying monad laws 
opportunities doing 
laws applied obtain satisfying mswo push read return mswo write read output return mswo pop addition monad laws hold monads laws hold particular non standard morphisms 
instance example avoid second read location rule write read write target language laws target language executable code data structure perform optimizations 
accomplished subject section 
eval function state semantic equivalence monadic staged interpreters 
proposition 
commands com list names index interpret com index run interpret com index proof 
see appendix step optimizing target code monadic laws important contribution staged program produces piece code executable program data structure 
wants execute code uses run annotation 
wants optimize code possible 
section illustrate example providing implementation monad law transformations demonstrated section section brie explain method analysing computing doing intensional analysis metaml code 
believe operations patternmatching substitution code provided system user 
optimizations generally thought rewriting rules transformations 
rules strategy top bottom needed apply need described 
illustrate point write simple transformation implements monadic laws directed rewrites 
reminder monadic laws expressed terms metaml return notation repeated 
return return implement rules need mechanism pattern matching code 
metaml code result monadic interpreter just data structure possible 
consider simple example 
suppose want match pieces code form wehave indicate meta variable match piece code 
put variable just piece code pattern 
solution indicating meta variable pattern escaped variable level pattern 
pattern matches pieces code shape 
unfortunately scheme su cient matching code binding constructs fn 
wewould construct pattern matches function binding construct able metavariables bound inside pattern construct transformation 
see problematic consider examples 
want transformation increments body integer valued function applied fn obtain fn applied fn length obtain fn length 
rst approximation try fn fn 
looks promising happen wrote fn fn 
free occurrences longer binding site spliced context bound variable 
want transformation doubles argument int function applied fn obtain fn applied fn obtain fn 
problem pattern fn way express may free occurrences inside transformation needs substitute free occurrences 
solution higher order pattern 
suppose parameterize meta variable type code meta variable type code code 
inside pattern left hand side match pat exp higher order meta variable bound function successfully matched piece code 
right hand side match meta variable applying piece code substitutes occurrences argument itwas applied 
example consider table showing binding higher order meta variable pattern fn matched di erent pieces code 
code matched function bound fn fn fn fn fn sin fn sin fn match failure express metaml convention function escaped application arguments application explicitly bracketed code represents higher order meta variable 
escaped application appears inside pattern function part application higher order meta variable arguments formal parameters 
example 
problematic examples easily expressed fn fn fn fn higher order meta variables may appear function position escaped applications arguments escaped applications may bracketed bound variables pattern matching uni cation decidable 
possess tools monad law code optimizing opt fun opt st return st opt opt st return st constant opt opt st st opt st opt map code opt traversal code opt function implements limited form left id monad law 
wish duplicate substitution non constant 
composing optimization interpret obtain better compiler 
applying compiler declare declare obtain program state push push fun loop state read return state return state state read return state write loop pop pop read return state write loop optimizer fully sequentialized code bind associativity law removed super uous return unit identity laws 
optimizations arithmetic simpli cation transformations form assembly code implemented fashion 
related inspired di erent areas 
derivation compilers speci cations action semantics monads structure programs general language implementations particular staged programming structuring compilers partial evaluation higher order syntax pattern matching space considerations limit detailed discussion areas 
monads compilation related sheng liang thesis advisor paul hudak 
investigate derivation compiler modular monadic interpreter 
continuation ort monads standard compilation mechanism 
di erences remain staging lead early step development split environment static index names dynamic stack 
allows avoid environment monad 
state transformer monad state managed stack 
liang uses complicated monad combination environment monad state transformer 
code generation show residual code due environment lookups location variables eliminated axioms non standard morphisms environment monad 
staging allowed lookups rst stage lookups 
hand liang modular language components advantage attempted employ 
simplicity wehave monad expressions commands liang uses modular approach feature de ned independently 
features combined monad transformer 
necessary lift non standard morphisms transformer 
hard completely understood 
may try duplicate liang approach 
staging compilation thesis calculating compilers erik meijer advocates staging compiler self discipline 
construct compiler building composition compile time run time components 
critical step process nding representation source language construct combination lower level target level constructs 
representing source target languages algebraic datatypes say source target induced functors reduced nding polymorphic function trans type 
called algebra transformer 
semantic domain target algebra type value 
semantic meaning function target language target value expressed catamorphism cata phi phi value value lift phi interpreter source language applying algebra transformer trans 
trans phi value value interp cata trans phi source value 
similar construction construct compiler compiler source target 
function target target injection functor induced algebraic datatype target cata trans source target constructs compiler 
limiting factor approach nding algebraic datatype target encode target language 
monadic target language known constructors unit bind polymorphic encode algebraic datatype non standard morphisms polymorphic 
staging process metaml need algebraic datatype encode target language special type code 
constructors target algebra simply second stage representations real functions 
di erence staging partial evaluation staged programming closely related partial evaluation 
list believe salient di erences 
uses explicit annotations uses implicit annotations placed automatic binding time analysis 
gives programmer complete control residual program produced residual program produced contains surprises 
surprises caused di erences programmer knows binding time analysis discover 
solution mismatch programmer restructure program binding time improvements closely align knowledge capabilities binding time analysis 
course completely immune di culties staged programmer fully aware staging issues writes program 
staged type system great advantage 
simple programs automatic binding time analysis su cient hand staging simply annoyance 
system combined advantages allowing simple type directed binding time analysis exist manual staging annotations 
analysis existence scope 
programming language feature 
exists level program 
algorithm staging developed hand hand 
additional tools processes users learn staging thought processes problem solving techniques 
provides complete uni ed typed environment supporting type reconstruction polymorphism staged constructs 
implementation seen higher order pattern matching code implemented metaml implementation 
examples actual runs system 
higher order pattern matching currently development 
normalizing ect monad laws compelling implemented ad hoc fashion inside metaml system 
shown staging programs ers exciting new programming paradigm reinforced notion staging monadic interpreter compile time run time components provides direct link interpreter compiler 

research reported supported usaf air materiel command contract nsf iri 
anders bondorf olivier danvy 
automatic recursive equations global variables data types 
science computer programming 
anders bondorf jens palsberg 
compiling actions partial evaluation 
conference programming languages computer architecture pages new york june 
acm press 
copenhagen 
consel 
tour partial evaluation system higher order applicative languages 
partial evaluation semantics program manipulation copenhagen denmark june pages 
new york acm 
danvy 
compiling monads 
technical report cis kansas state university manhattan kansas december 
rowan davies 
temporal logic approach binding time analysis 
proceedings th annual ieee symposium logic computer science pages new brunswick new jersey july 
ieee computer society press 
rowan davies frank pfenning 
modal analysis staged computation 
rd annual acm symposium principles programming languages popl st petersburg beach florida january 
laws value normalization value reduction carsten sch frank pfenning jo elle despeyroux 
primitive recursion higher order syntax 
third international conference lambda calculi applications number lncs pages 
springer verlag april 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
journal functional programming january 
neil jones carsten gomard peter sestoft 
partial evaluation automatic program generation 
series editor hoare 
prentice hall international international series computer science june 
isbn number 
paul hudak simon peyton jones philip wadler brian boutel john fairbairn joseph fasel maria guzman kevin hammond john hughes thomas johnsson dick kieburtz nikhil partain john peterson 
report programming language haskell 
sigplan notices section 
peter lee 
realistic compiler generation 
foundations computing series 
mit press 
sheng liang 
modular semantics compilation 
phd thesis yale university 
sheng liang paul hudak 
modular denotational semantics compiler construction 
esop th european symposium programming number lncs pages linkoping sweden january 
sheng liang paul hudak mark jones 
monad transformers modular interpreters 
conference record popl st acm sigplan sigact symposium principles programming languages san francisco california pages january 
erik meijer 
calculating compilers 
phd thesis katholieke universiteit nijmegen 
dale miller 
logic programming language lambda abstraction function variables simple uni cation 
peter schroeder heister editor extensions logic programming international op tubingen germany december volume lncs pages 
springer verlag 
torben 
self applicable partial evaluation pure lambda calculus 
acm sigplan workshop partial evaluation semantics program manipulation pages june 
yale university department computer science technical report yaleu dcs rr 
eugenio moggi 
notions computations monads 
information computation july 
peter mosses 
sis semantics implementation system manual users guide 
technical report daimi report md university aarhus aarhus denmark 
nielson 
level functional languages 
cambridge university press cambridge mass 
martin odersky konstantin laufer 
putting type annotations 
proc 
rd acm symposium principles programming languages pages january 
jens palsberg 
correct compiler generator 
krieg bruckner editor esop th european symposium programming rennes france pages new york february 
springer verlag 
lecture notes computer science 
paulson 
methods tools compiler construction editor 
cambridge university press 
john peterson kevin hammond report programming language haskell non strict purely functional programming language version 
technical report yale university may 
qian 
linear uni cation higher order patterns 

gaudel 
jouannaud editors proceedings tapsoft volume lncs pages 
springer verlag 
michael spivey 
functional theory exceptions 
science computer programming june 
guy steele 
building interpreters composing monads 
st annual acm symposium principles programming languages popl portland oregon january 
walid taha el benaissa tim sheard 
multi stage programming axiomatization type safety 
colloquium automata languages programming lncs 
springer verlag july 
appear 
william scherlis 
compilers staging transformations 
symposium principles programming languages pages 
acm acm press january 
philip wadler 
comprehending monads 
proceedings acm symposium lisp functional programming nice france pages june 
philip wadler 
comprehending monads 
mathematical structures computer science 
special issue selected papers th conference lisp functional programming 
philip wadler 
essence functional programming invited talk 
th acm symposium principles programming languages albuquerque new mexico january 
philip wadler 
monads functional programming 
jeuring meijer editors advanced functional programming volume lncs 
springer verlag 
daniel weise roland erik ruf scott seligman 
automatic online partial evaluation 
proceedings functional programming languages computer architecture th acm conference pages cambridge ma usa august 
springer verlag 
lecture notes computer science 
proofs repeat axiomatic semantics metaml 
sake simplicity omit level annotations 
run run escape beta escape axiom applies level inside exactly bracket run beta apply level inside brackets 
lemma 
typed expression proof 
typed evaluate terminates 

wehave replace equals equals escape axiom lemma 
type expression run run run run 
proof 
term level possible reduction escape axiom 
assume evaluate values respectively 
evaluate level beta step 
run run replacing equals equals run axiom definition run run run axiom run run replacing equals equals lemma 
type expression run run run 
proof 
proof similar lemmas 
consequence previous lemmas run distributes subexpressions 
particular run distributes 
run 
en run run 
run en run run val val run run run proposition 
expressions exp list names index eval exp index run eval exp index proof 
induction structure exp case exp minus run eval minus index beta axiom run mswo eval index eval index return mswo run mswo run eval index run eval index run return mswo lemma twice run axiom mswo run eval index run eval index return mswo induction hypothesis twice mswo eval index eval index return mswo beta eval minus index cases similar 
proposition 
commands com list names index interpret com index run interpret com index proof 
induction structure com 
case com body 
run interpret body index beta run fun loop mswo eval index return mswo mswo interpret body index loop loop run run fun loop mswo run eval index run return mswo mswo run interpret body index run loop run loop lemma run axiom fun loop mswo run eval index return mswo mswo run interpret body index run loop run loop induction hypothesis proposition fun loop mswo eval index return mswo mswo interpret body index run loop run loop run axiom fun loop mswo eval index return mswo mswo interpret body index loop loop step possible step derivation annotations particular escapes body function loop body loop level value normal form 
cases easier 

