proof carrying code george necula school computer science carnegie mellon university pittsburgh pennsylvania necula cs cmu edu describes proof carrying code pcc mechanism host system determine certainty safe execute program supplied possibly binary form untrusted source 
possible untrusted code producer supply code safety proof attests code adherence previously defined safety policy 
host easily quickly validate proof cryptography consulting external agents 
order gain preliminary experience pcc performed case studies 
show proof carrying code develop safe assembly language extensions ml programs 
context case study prove adequacy concrete representations safety policy safety proofs proof validation 
briefly discuss proof carrying code develop network packet filters faster similar filters developed techniques formally guaranteed safe respect operating system safety policy 
high level programming languages designed implemented assumption closed world 
tak research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document authors interpreted representing official policies expressed implied advanced research projects agency government 
appear proceedings th annual acm sigplan sigact symposium principles programming languages popl paris france january 
ing ml example programmer normally assume components program written ml order establish program properties conferred type safety 
practice programs components written ml different language assembly language 
situations lose guarantees provided design ml extremely expensive mechanisms sockets processes employed 
implementation terms extremely difficult determine invariants ml heap respected foreign code kind expensive firewall simply live dangerously 
problem exacerbated realms distributed web computing particularly mobile code allowed 
kind situation agent part network write component software system ml compile native machine code transmit agent node execution 
agent convince agent native code type safety properties shared ml programs furthermore respects representation invariants chosen maintaining state heap 
manifestations problem 
example realm operating systems profitable allow application programs run address space kernel 
problem kernel know inherently untrusted application code respects kernel internal invariants 
problem worse practice kinds properties required application code difficult sense standard type systems express easily 
example spin kernel basic requirements proper synchronization locks hard impossible express ml modula type systems :10.1.1.117.6702
situations described code consumer convinced code supplied untrusted code producer previously agreed set properties 
referred establishing trust consumer producer 
cryptography ensure code produced trusted person compiler :10.1.1.117.6702
scheme weak dependency personal authority trusted persons compilers written errors occasionally act maliciously 
proof carrying code pcc short mechanism dealing problems 
proof carrying code code producer required create safety proof attests fact code respects formally defined safety policy 
code consumer able simple fast proof validator check certainty proof valid foreign code safe execute 
analogy safety proofs types 
analogy carries proof validation type checking 
analogy mind note attempts tamper code proof result validation error 
cases code proof modified validation succeeds new code safe 
consider proof carrying code intrinsically safe need external authentication cryptography 
previous shown proof carrying code implement safe fast network packet filters 
provide necessary technical details theorems establish soundness adequacy certification scheme second case study involving extension run time system ml implementation 
overview stages involved creation code 
case study extending simplified form run time system til compiler standard ml :10.1.1.27.353
doing show sample formal system pcc state necessary theorems soundness adequacy methodology 
continue brief description network packet filter example previous 
case studies discuss problems involved generating proofs engineering matters 
summarize accomplished far see interesting directions research 
proof carrying code shows typical process generating proof carrying code 
process centered safety policy defined public code consumer 
policy code consumer specifies precisely conditions considers execution foreign program safe 
cpu safety rules interface proof enable safety policy code consumer code producer user process runtime system os kernel source program certification compilation code safety binary native pcc proof validation overview proof carrying code 
safety policy consists main components safety rules interface 
safety rules describe authorized operations associated safety preconditions 
interface describes calling conventions code consumer foreign program invariants holding consumer invokes foreign code invariants foreign code establish calling functions provided consumer returning consumer 
analogy types safety rules typing rules interface signature foreign module compiled 
life pcc binary spans stages 
stage called certification code producer compiles assembles generates proof source program adheres safety policy 
general case certification essentially form program verification respect specification described safety policy 
addition proof successful verification produced suitably encoded yield safety proof native code component forms pcc binary 
code producer store resulting pcc binary deliver code consumers execution 
second stage called validation code consumer validates proof part pcc binary execution loads native code component execution 
validation quick driven straightforward algorithm 
implementation simple algorithm consumer trust addition soundness safety policy 
existence proof allows verification process performed line program independently number times executed 
important engineering advantages especially cases verification hard time consuming requires user interaction 
cases undesirable perform verification consumer site 
stage process code consumer executes machine code program possibly times 
stage proceed performing additional run time checks previous validation stage ensures code obeys safety policy 
completes overview general code technique 
attempt practical implementation pcc decide concrete representations safety policy safety proofs validation procedure 
summary current choices continue section details formal adequacy theorems 
current experiments extensions firstorder predicate logic basis formalizing safety policy 
extensions predicates denoting application specific safety requirements derivation rules 
setup interface part safety policy consists set precondition postcondition predicates foreign function functions exported code consumer 
safety rules expressed floyd style verification condition generator program set preconditions postconditions produces verification condition predicate vc logic 
vc property proved proof rules logic program satisfies safety invariants 
case safety proof appropriate encoding proof vc predicate proof reduced theorem proving logic validation proof checking 
particular safety policy extensions til run time system show choices adequate 
case study safe extensions til run time system practice software development languages ml haskell involves extending runtime system usually writing code implement new primitive types operations functionality easily programmed high level language 
raises question ensure foreign code respects basic assumptions run time system 
considering user extensions run time systems high level languages usually include sizeable part written unsafe languages assembly language 
mechanism allows untrusted user safely extend run time small kernel run time system bootstrap rest increasing level confidence system 
propose proof carrying code allow arbitrary untrusted users safely link foreign functions safe programming language run time system 
possible compiler designer defines safety policy basically formal description data representation invariants preserved calling conventions obeyed foreign functions 
user produces attaches foreign code safety proof preservation invariants 
presentation concrete show detail pcc develop safe dec alpha assembly language extensions simplified version run time system til compiler standard ml :10.1.1.27.353:10.1.1.116.2392
purposes consider small example simplifying assumptions til 
described 
scaling technique entire standard ml language subject current research 
datatype int int pair int int fun sum list fun foldr nil foldr foldr foldr fn acc int 
acc acc pair 
acc standard ml source program 
consider standard ml program fragment shown 
program defines union type function sum adds integers list 
plan rest section define safety policy extensions til run time system prove type safety hand optimized assembly language version sum function 
establishing safety policy order business define safety policy til run time system presence foreign functions 
job compiler designer trusted person familiar conventions basic invariants maintained til compiler run time system 
safety policy case requires foreign code maintains data representation invariants chosen til compiler 
data representation til type directed types involved example int list convenience abbreviation type int int int 
subset ml types til data representation rules follows integer value represented untagged bit machine word pair represented pointer sequence memory locations containing values appropriate types value type represented pointer pair locations containing respectively constructor value inj inj value carried constructor empty list represented value non empty list pointer list cell 
see examples til representations sml values 
compiler designer describes formally strategy means typing judgment expression memory state 
memory state part judgment types represented pointers valid certain states memory underlying value allocated 
sets expressions memory states example defined follows sel upd bit integer literal dec alpha machine registers pseudo register holding state memory computation sel denotes contents location memory state upd denotes memory state obtained old state updating location val int val int int val pair val int val list data representation til 
box represents machine word 
simplify memory safety aspect safety policy compiler designer introduces additional type called addr 
type expressions value memory address safely read 
known data representation strategy til compiler compiler designer defines typing judgment set inference rules shown 
show elimination rules typing judgment example hand concerned constructing values non base types 
purpose ignore overflow semantics addition standard ml 
safety policy just typing rules far 
illustration purposes shall remaining mechanisms safety policy context concrete example foreign function 
foreign function experiment code producer writes dec alpha assembly language implementation sum function shown 
code assumes register contains argument type list entry integer result exit 
registers temporaries 
purpose inv instruction explained shortly 
code written obey til data representation strategy fact proved consumer 
note assembly language program optimized hand 
goals show proof carrying code pose restrictions addr addr sel sel addr addr sel oe sel sel oe sel list addr addr sel sel list int int int int typing rules 
sum inv list acc mov initialize acc inv list int loop invariant beq list empty 
ld load head ld load tail ld load constructor ld load data beq integer 
ld load ld load add add add addition br loop mov copy result ret result dec alpha assembly language implementation sum function 
register allocation scheduling low level optimization techniques 
rest section consider foreign program represented vector pi instructions 
convention program point index vector pi 
computing verification condition basic method check compliance safety rules computing floyd style verification condition foreign function 
predicate order logic property validity respect order logic rules typing rules sufficient condition ensuring compliance safety policy 
code producer code consumer compute verification condition code producer purpose proving code consumer ensure foreign code accompanied contains valid proof 
floyd style verification condition generator loop invariants interfaces functions called 
invariant associated loop starting list int interface function sum precondition postcondition shown re list ost int general loop invariant type safety policies conjunction typing predicates registers live invariant point 
interfaces derived similarly function types 
flexibility allow invariants associated arbitrary points program necessarily part loops 
points marked program inv pseudo instructions set denoted inv 
point write inv denote corresponding invariant 
simplify presentation assume code consumer prepends instruction inv pre untrusted program analyzing 
convention inv inv pre verification condition generator defined computes vector vc predicates instruction 
notation stands predicate obtained substituting expression occurrences practice invariants kept separate code allowing code executed directly physical processor 
vc op vc pi add op addr sel vc pi ld oe vc oe vc pi beq post pi ret pi inv verification condition generator 
vc function defined loop program contains invariant instruction 
current implementation requires target invariant instruction 
conditions entire vector vc computed pass program 
vector vc define verification condition entire program follows vc pi inv post inv inv oe vc example program vc predicate conjuncts precondition invariant associated conjunct corresponds control path function entry point start loop 
conjunct says loop invariant established loop conditional executed foo list oe foo list int second conjunct corresponds rest program says loop invariant preserved loop entails postcondition loop finishes 
part vc predicate complicated show 
soundness vc certification vc predicate defined proved code producer proof constitutes safety proof 
discuss section adequacy proof vc predicate safety proof defer sections difficult problem proof search 
write predicate proved inference rules proof rules order predicate logic shown 
note implication rule hypothetical assumption rule schematic side conditions satisfied proof valid 

oe impl 
fragment order predicate logic proof rules 
appendix prove soundness proof vc predicate basis safety certification 
formalize execution programs dec alpha processor machine 
show program valid verification condition executed machine starting state satisfies precondition memory locations defined valid typing rules 
furthermore program terminates final state satisfies postcondition 
stated informally theorem formalized appendix theorem program pi set invariants inv postcondition post pi inv pre vc pi inv post initial state satisfies precondition pre program reads valid memory locations defined typing rules terminates state satisfying postcondition 
proof soundness vc certification appendix simpler correctness arguments floyd vc generators mainly precise definition programs invariants program points assembly language programs flowcharts 
safety proofs argued previous section prove appendix proof validity vc predicate sufficient ensure compliance safety policy 
safety proof suitable encoding derivation vc pi inv post 
stage encoding derivations 
stage represent predicates proofs objects edinburgh logical framework referred lf :10.1.1.21.5854
second stage encode lf objects compact binary format suitable storage transmission code consumers 
shall discuss detail lf representation 
lf designed meta language highlevel specification logics provides natural support management binding operators hypothetical schematic judgments 
lf type theory language entities levels objects types kinds 
syntax entities shown kinds type pix types pix objects represent logic lf means signature assigns types set constants describing syntax expressions predicates proof rules logic 
lf judgments represented types judgment derivations objects type representation judgments prove 
type checking lf type discipline check logic proofs 
start signature define lf types exp expressions pred predicates tp ml types 
atomic lf types exp type pred type tp type expression predicate constructor define lf constant shown 
exp exp exp exp exp exp exp true pred pred pred pred impl pred pred pred exp pred pred hastype exp exp tp pred note binding predicate constructors represented higher order lf constants effectively shifting machinery related bound variables substitution logic lf 
relies representing variables lf variables 
lf representation function deltaq inductively defined structure expressions predicates 
definition cases shown pp rq ppq prq pq exp ppq representation derivations define type family indexed representation predicates pf pred type model expressions predicates define constant proof schema 
constants shown pip pred pir pred pf pf pf impl pip pred pir pred pf pf pf impl pip exp pred piv exp pf pf extend representation function deltaq derivations 
doing care taken hypothetical schematic judgments implication universal quantification rules shown 
representation conjunction typical rules 
pp pp pd pd 
oe impl pp pp pf pp pd exp pp exp pd implication rule introduces hypothesis labelled purpose deriving checking instance rule schema involves verifying discharges properly hypothesis equivalently derivation hypothetical expressed naturally lf representing hypothesis variable bound lf representation logic contains representation application specific proof rules 
representation straightforward involve hypothetical judgments 
example show lf representation typing rules lists tp list pim exp pie exp pit tp pf hastype list pf neq pf hastype addr hastype sel hastype addr hastype sel list purpose lf representation lf type checking algorithm checking validity proofs 
advantage code consumer need trust implementation proof checking 
logics encoded derivations checked type checker just changing signature 
furthermore lf typing rules simple naive implementation takes couple pages code 
important minimizes concern type checker trusted 
show typing rules full lf 
define appendix fragment lf expressive encode order higherorder logics strictly simpler expressive full lf 
fragment called lf show typing rules adequacy encoding predicates derivations 
statement adequacy theorem shown 
lf typing judgment gamma says object canonical type respect type assignment gamma signature theorem adequacy order logic bijection deltaq derivations parameters hypotheses canonical lf objects pdq exp pf pp pdq pf ppq corollary adequacy theorem states lf type checking sufficient procedure checking safety proofs 
corollary closed predicate canonical lf object delta lf pf ppq exists derivation valid 
furthermore pdq 
similar theorem proved harper honsell plotkin canonical forms full lf :10.1.1.21.5854
lf proofs somewhat simpler syntax directed form typing judgments canonical forms 
practical advantage lf full lf definitional equality responsible exponential worst case complexity lf type checking replaced localized syntax directed normalization judgment 
particular signature normalization involved checking instances universal quantification elimination rule schema 
quantitative results motivation experiments measure size safety proofs time takes validate simple examples 
safety proof contains lf representations invariants precondition supplied code producer proof vc predicate 
lf objects encoded portable compact binary format 
recall pcc binary contains native code 
example section size entire pcc binary bytes 
safety proof occupies bytes code bytes 
rest bytes fixed size overhead 
implementation lf type checking algorithm validating proof example takes ms dec alpha workstation running mhz 
time significantly take trusted optimizing compiler generate safe extension compilation sml source 
case study safe packet filters case study proof carrying code implement collection network packet filters 
details experiment described give brief summary experiment results 
modern operating systems provide facility allowing application programs receive packets directly network device 
typically application interested receiving packet network small fraction exhibit specific property application want tcp packets destined telnet port 
cases highly profitable allow application program specify boolean function network packets filter run kernel address space 
kernel avoid delivering uninteresting packets application saving cost unnecessary context switches 
packet filters supported today workstation operating systems :10.1.1.36.8755
main technical problem application programs inherently untrusted kernel employ method ensuring safety 
popular solution exemplified bsd packet filter architecture bpf define safe programming language writing packet filters interpreter kernel execute 
bpf language example filter programs restricted loop free memory checked run time bounds packet data statically allocated scratch memory 
experiment able pcc define safety policy defined bpf write collection typical packet filters hand coded dec alpha assembly language 
vc generator machine essentially shown figures branches restricted forward 
packet filters written hand tuned assembler interpreted language times faster functionally equivalent packet filters written bpf times faster packet filters written safe subset modula faster filters developed software fault isolation :10.1.1.142.4909
furthermore proofs small ranging bytes size validation times negligible ranging ms ms 
note exactly implementation lf type checking previous application signature modified 
generating safety proofs remaining aspect pcc experiment discussed generation safety proofs 
open questions proof generation scalability large programs 
currently obtain proofs simple theorem prover produces witness successful proof 
possible methods better especially larger programs 
discuss section 
experiments programming language elf prove vc predicates produce lf representation proofs 
elf logic programming language lf 
program elf lf signature execution elf search canonical lf objects inhabiting lf type context signature 
case program signature interested finding closed object type pf verification condition vc object corollary constitutes canonical lf representation proof vc incidentally exactly required safety proof 
proof search elf performed depth fashion prolog 
operational view natural deduction style presentation logic appropriate proof search elimination rules lead non termination 
solution problem observation vc predicates current experiments order horn clauses order hereditary harrop formulas 
fragments order logic admit complete sequent style proof system declarative meaning logical connectors coincides search related reading 
resulting proofs called uniform 
lf representation uniform proof system logic logic program perform proof search 
represent lf uniform derivation rules logic manner similar natural deduction representation 
representation elf perform goal directed search uniform derivation validity vc predicate 
represent lf proof soundness uniform derivations respect natural deduction formulation logic 
exploit operational reading soundness proof elf convert uniform derivation vc predicate natural deduction proof 
lf signatures representing logic uniform proof derivations soundness uniform proofs consist constant declarations 
discussion type safety example able employ simple rules finding sufficiently strong loop invariants interfaces functions called 
general case difficult problem main factor certification hard 
engineering advantage pcc regard hard done line code producer employ variety tools including costly program analyses user interaction 
factor problem simpler general program verification code producer allow certification process alter code inserting run time checks strategic locations 
tendency easier generate proof automatically 
example insert run time bounds checks array operations easy verify bounds array accesses performed 
verification approach scale programs realistic size 
believe promising technique producing proofs rely compiler prove target code preserves interesting properties source program termination lack deadlock type safety 
generally achieved instrumenting compiler generate proofs safety parallel code transformations 
currently little experience certifying compilers 
implemented compiler small type safe imperative language sum product types 
target language similar source language products 
target programs sum type values represented pairs manner similar til representation strategy 
employ typing rules similar prove type safety target program 
able implement compiler way type safety proof source code transformed proof parallel transformation code target language 
exploring feasibility extending realistic compiler til generate type safety proofs 
til currently preserves proof type safety high level optimizations means typed intermediate languages 
til certifying compiler need extend safety policy entire standard ml language modify compiler preserves safety proof back optimizations translations 
quite daunting task encouraging code scheduling register allocation done correctly change safety predicate 
fact may simple correctness criterion optimizations preserve safety predicate code initially 
aspect pcc experiments deserves discussion choice underlying logic safety policy representation derivations 
somewhat delicate point choice axioms proof rules reasoning arithmetic 
experiments chosen rules axioms bit extending logic need arose 
approach workable circumstances widespread pcc say safe applets require proof validators adopt logic 
choose right system may difficult task practice amounts establishing kind standard basis library 
matter arithmetic plan experiment logics expressive order logic linear logic temporal logic 
logics provide expressive mechanisms defining practical safety policies 
example linear logic useful expressing revocation single threading capabilities 
temporal logic possibly express fairness lack deadlock 
higher order logic basis reasoning code generating code 
working expressive logics require meta language machinery provided lf 
case linear logic example 
reason experiment representation techniques known decidable criteria ensuring lf signature proof theorem deductive system 
encode easy check representation theorems typesafe code memory safe mechanism untrusted users safely define safety policies 
proof carrying code mechanism allows code consumer interact safely native code supplied untrusted code producers 
pcc incur run time overhead previous solutions problem 
code producer required generate proof attests code safety properties 
kernel easily check proofs validity absolutely certain code respects safety policy 
furthermore pcc binaries completely tamper proof attempt alter native code proof pcc binary detected harmless respect safety policy 
main contribution principle staging program verification certification proof validation proof acting witness certification performed correctly 
staging great engineering advantages intuition proof checking believed easier proof generation 
application specific proving strategies goal directed search interactive theorem proving just brute force search guided heuristics associated complexity computational costs moved line certification stage 
validation stage need simple reliable proof checker cases inexpensive performance critical paths 
proof checker covers practical applications increases reliability methodology 
lastly certification done independently times code 
shown way standard verification techniques check type safety level 
important certifying extensions safe programming languages main building block constructing certifying compilers 
similar techniques applied assembly lan guage basis creating safety proofs checking type safety 
show encoding safety proofs order logic derivations lf 
contribution area identify fragment lf sufficient applications pcc admits simple fast type checking algorithm 
proof carrying code application ideas program verification logic type theory case extend low level languages safety properties normally enjoyed high level languages 
shown technique useful safe interoperability programming languages operating system components 
growth interest highly distributed computing web computing extensible kernels clear ideas programming languages destined increasingly critical robust performing systems 
acknowledgments outgrowth done jointly peter lee suggested numerous improvements presentation 
robert harper valuable comments earlier drafts 
bershad savage pardyak sirer becker fiuczynski chambers eggers extensibility safety performance spin operating system :10.1.1.117.6702
symposium operating system principles dec pp 

boyer yu automated proofs object code widely microprocessor 
acm jan 
carr verification low level code 
ieee software engineering journal may 
floyd assigning meanings programs 
mathematical aspects computer science schwartz ed 
american mathematical society pp 

harper honsell plotkin framework defining logics :10.1.1.21.5854
journal association computing machinery jan 
mccanne jacobson bsd packet filter new architecture user level packet capture 
winter usenix conference jan usenix association pp 

miller nadathur pfenning scedrov uniform proofs foundation logic programming 
annals pure applied logic 
milner tofte harper definition standard ml :10.1.1.116.2392
mit press cambridge massachusetts 
mogul rashid accetta packet filter efficient mechanism user level network code :10.1.1.36.8755
acm symposium operating systems principles nov acm press pp 

updated version available dec wrl research report 
necula lee proof carrying code 
technical report cmu cs computer science department carnegie mellon university sept 
appeared fox memorandum cmu cs fox 
necula lee safe kernel extensions run time checking 
second symposium operating systems design implementations oct usenix 
pfenning elf language logic definition verified meta programming 
fourth annual symposium logic computer science pacific grove california june ieee computer society press pp 

web navigator applets caml 
proceedings th international world wide web conference computer networks telecommunications networking may 
sites alpha architecture manual 
digital press 
tarditi morrisett cheng stone harper lee til type directed optimizing compiler ml :10.1.1.27.353
pldi conference programming language design implementation may pp 

wahbe lucco anderson graham efficient software fault isolation :10.1.1.142.4909
th acm symposium operating systems principles dec acm pp 

ae pc ae ffi op pc pi pc addq op ae ffi sel pc pi pc ldq addr ae pc pi pc beq ae pc pi pc beq ae pc pi pc inv machine soundness proof 
soundness vc certification appendix prove vc predicate defined body sufficient ensure compliance safety policy 
context example means memory read operation readable address defined typing rules termination postcondition holds 
soundness proof easily extended examples 
order formalize soundness property define machine defines safety formally 
state machine consists value program counter pc state machine registers including pseudo register view current state registers substitution ae register names values 
write ae denote value register state ae 
write ae ae express substitution register names values state ae 
write ae ffi state obtained executing assignment state ae 
definition state ae satisfies predicate ae 
notation define machine set state transition rules shown 
interesting aspects machine definition 
firstly machine specifies explicit safety conditions shown boxed 
example safety condition memory read rule addr satisfied current state ae ae ae addr 
assumes application specific extension predicate logic set inference rules example sound respect safety policy 
secondly machine return errors explicitly 
execution halts due lack appropriate rules cases safety conditions satisfied invalid instructions encountered 
lastly machine ignores invariant instructions 
appropriate physical machine know execute 
ignore boxed safety condition memory read rule obtain faithful abstraction dec alpha processor 
show rest appendix valid vc predicate program guarantees moment execution safety conditions satisfied equivalently execution halt 
program effect executed physical machine perform safety checks 
central result appendix progress lemma 
informally lemma says current state satisfies vc predicate current instruction execution terminates immediately state satisfies postcondition subsequent state execution halt 
lemma progress program pi pi inv pre vc pi inv post ae vc pc ffl pi pc ret ae ost ffl exists new state ae ae pc 
ae pc ae vc pc 
proof proof case analysis current instruction 
case pi pc ret 
ae vc pc vc pc post conclude ae post 
case pi pc add op hypothesis ae vc pc 
simple substitution manipulation get 
ae ffi vc pc 
follows immediately pick pc pc ae ae ffi 
case pi pc ld 
hypothesis ae addr sel vc pc 
conjunction elimination rules follows ae addr means side condition memory read rule machine satisfied 
pick pc pc ae ae ffi sel deduce ae vc pc 
case pi pc beq distinguish cases depending value ae 
show case ae 
case similar 
hypothesis get ae oe vc pc oe vc pc 
conjunction implication elimination get ae vc pc exactly prove 
case pi pc inv hypothesis ae 
validity vc predicate 
universal quantification elimination instantiation ae conjunction elimination proof vc predicate get ae oe vc pc 
implication elimination get desired 
lemma program pi set invariants inv postcondition post pi inv pre vc pi inv post initial state ae satisfies precondition pre subsequent state ae machine ae 
ae pc ae vc pc 
proof induction length derivation ae 
ae pc 
base case follows immediately hypothesis observing vc pre 
inductive case lemma 
lemmas easily show point execution program valid vc predicate safety check memory load rule satisfied furthermore program terminates state satisfies postcondition 
proves theorem main body 
adequacy lf representation proofs appendix introduce lf fragment full lf defined :10.1.1.21.5854
benefits lf full lf proof representation validation lf admits simpler type checking algorithm 
lf checking proofs signature kinds involved trusted designed code consumer 
eliminates need type checking kinds lf dependent kinds allowed lf distinguishing feature lf allows second order constants order abstractions 
representing wide array order higher order logics :10.1.1.21.5854
benefit gained normalization judgment syntax directed admits simple efficient implementations 
examination lf encoding functions notice lf objects canonical form produced 
fact crucial technical detail proofs adequacy :10.1.1.21.5854
lf define typing judgments objects canonical form simplifying typing rules adequacy proofs 
object canonical form fij long normal form 
write gamma sigma object canonical form type respect type assignment gamma lf signature sigma 
judgment defined terms atomic typing judgment gamma sigma object atomic constant variable applied zero arguments 
arguments application non functional atomic type 
variation typical presentations lf definitional equivalence judgment normalization judgment 
furthermore normalization localized app rule 
canonical atomic typing judgments syntax directed simplifies adequacy proofs 
abstractions restricted order pi rule atomic type functional 
turn justifies syntax directed form normalization judgment 
particular nm beta rule term known canonical form canonical atomic type 
theorem relates typing judgments lf typing judgment lf justifies claim lf fragment lf 
theorem soundness lf 
gamma sigma gamma sigma lf 
gamma sigma gamma sigma lf 
gamma sigma gamma sigma lf 
gamma sigma lf type lf gamma sigma lf type 

gamma sigma lf gamma sigma lf proof proof simultaneous induction structure lf derivations 
state adequacy theorems expression predicate derivation representation defined signature proofs adequacy theorems follow closely model similar adequacy theorems :10.1.1.21.5854
technically proofs somewhat simpler lf syntax directed form typing judgments canonical forms 
extend signature firstorder predicate logic order proof constants adequacy holds 
means lf adequate representation order predicate logic order extensions 
canonical objects gamma sigma gamma sigma type gamma sigma pix pi gamma sigma gamma sigma type gamma sigma atomic objects gamma gamma sigma var sigma gamma sigma ct gamma sigma pix gamma sigma gamma sigma app atomic types sigma gamma sigma gamma sigma gamma sigma gamma sigma pi normalization na na app pix pix na pi nm var nm nm app nm beta typing rules lf theorem adequacy expression representation 
compositional bijection deltaq expressions free variables xn atomic lf objects exp xn exp exp bijection compositional sense pe pe theorem adequacy predicate representation 
compositional bijection deltaq predicates free variables xn canonical lf objects ppq exp xn exp ppq pred 
bijection compositional sense pq pp theorem adequacy derivation representation 
bijection deltaq derivations parameters hypotheses canonical lf objects pdq exp pf pp pdq pf ppq 
adequacy derivation representation central result justifies lf type checking sufficient procedure checking validity proofs 
stated formally corollary 
corollary closed predicate canonical lf object delta pf ppq exists derivation valid 
furthermore pdq 

