expected cost query optimization exercise utility francis chu joseph halpern praveen seshadri department computer science upson hall cornell university ithaca ny usa halpern cs cornell edu identify unreasonable standard assumptions database query optimizers adversely affect quality chosen evaluation plans 
assumption optimize expected case case various parameters available memory take expected value 
assumption parameters constant execution query 
algorithm system style query optimization algorithm rely assumptions 
algorithm chooses plan expected cost plan cost fixed value parameters 
execution environments exhibit high degree variability techniques result better performance 
database query specified declaratively procedurally 
query job dbms choose appropriate evaluation plan 
task performed cost query optimizer 
theory task optimizer simple performs search large space equivalent plans query estimates cost plan returns plan cost 
practice things simple 
major problems far possible plans optimizer consider accurate cost estimation virtually impossible requires detailed priori knowledge nature data run time environment 
query optimization critical component database system queries typically optimized evaluated repeatedly months years effort gone dealing problems 
query optimizer complex software modules dbms 
dynamic programming techniques typically deal problem sac randomized supported part nsf iri 
supported part nsf iri 
algorithms proposed swa ik 
shall see apply approach focus second problem 
accurately estimate cost executing particular plan need estimate values various parameters 
typically parameters divided categories 
parameters representing properties data cardinalities tables distributions values 
dbms typically maintains estimates parameters 

parameters representing properties query components sizes groups selectivities predicates research focused accurate estimates selectivities result sizes 
techniques typically histograms part data properties sampling 

parameters representing properties run time environment amount available memory processor speed multiprogramming level access characteristics secondary storage 
gathered observations realistic deployment environments 
value parameter exactly predicted case especially change execution query best modeled distribution 
current optimizers simply approximate distribution mean modal value 
choose plan cheapest assumption parameters take specific values sac remain constant execution 
call specific cost lsc plan 
propose different approach 
view query optimizer agent trying decision choose different plans 
standard decision theoretic approach choose plan maximizes expected utility res 
utility essentially negation cost lower cost attractive plan 
argue choosing lsc plan query optimization algorithms directed finding plan expected cost lec 
motivating example example help motivate lec plans 
pedagogical reasons focus example parameter amount available memory known difficult predict accurately practice loh 
assume predicate selectivities known 
consider case parameter section 
example consider query requires join tables result needs ordered join column 
pages pages result pages 
consider evaluation plans ffl plan apply sort merge join optimizer cost formulas tell available buffer size greater pages square root larger relation join requires passes relations sha 
fewer pages available requires pass 
pass requires pages read written 
ffl plan apply grace hash join sha sort result 
know available buffer size greater pages square root smaller relation hash join requires passes input relations 
subsequent sort incurs additional overhead especially data fit buffer 
available buffer memory accurately known easy choose plans plan pages available plan 
assume available memory estimated pages time pages time 
distribution obtained observing actual query execution environment 
current optimizers assume specific memory value case pages modal value pages mean value 
case plan chosen plan 
claim plan cheaper average large number evaluations 
intuition simple runs plan slightly expensive plan extra expense arises sorting small result cases plan far expensive plan extra expense comes extra pass data 
average expect plan preferable 
example shows flaw arises parameter distributions characterized single expected value cost plan value necessarily plan expected cost 
discontinuities cost formulas case database join algorithms effect arise 
contributions contributions 
introduce lec plans guaranteed typically better specific lsc plan 

show lec query optimization take account parameters constant value specific query execution static parameters vary execution dynamic parameters 
applied compile time start time 

show traditional dynamic programming query optimizers easily extended produce lec plan 
extension increases cost query optimization factor depending granularity parameter distribution 

extend lec query optimization handle queries selectivity predicate parameter modeled distribution 
depending actual distribution parameters arises practice lec plan efficient average specific lsc plan 
greater run time variation values parameters affect cost query plan greater cost advantage lec plan 
parameter distributions common worth implementing approach commercial database systems 
rest organized follows 
section review traditional approaches query optimization discuss related 
section introduce lec query optimization discuss lec plans may generated practice typical dbms 
consider extensions widely system query optimization algorithm 
algorithms apply case parameters static simplifying assumptions case dynamic 
section discuss simplifying assumptions possible directions 
background standard query optimization basic approaches proposed query optimization algorithms ffl bottom optimization synthetic approach suitable plan created starting stored tables building increasingly larger plans plan entire query formed 
ffl top optimization divide conquer approach entire query divided pieces piece optimized pieces put form query plan 
ffl transformational optimization starts valid complete query plan repeatedly transforms different valid complete plan 
stage plan cost retained 
query optimizer uses element approach 
typically query divided graph query blocks transformational optimizations performed query blocks 
query block graph typically optimized independently 
specific kind query block select project join spj block received lot attention occurs queries involves expensive join operations 
optimization spj block basic approaches 
commercial database systems bottom optimizer dynamic programming 
approach suggested system project sac 
briefly describe works 
sections describe variations algorithm find lec plans 
system approach suppose relations join want compute 
ease exposition assume join predicates pair relations 
realistic assume existence trivially true predicate 
basic observations influence algorithm 
joins commutative 

joins associative 

result join depend algorithm compute 
consequently dynamic programming techniques may applied 
system optimizer applies heuristics limit space plans considered 
particular relevance heuristics 
binary join algorithms considered 
consequently relation join evaluation plan involves combination join relation join result stored relation 

find best plan relation join plans considered involve joining subset gamma relations adding kth 
possible approaches example considering best plan joining subset gamma relations joining remaining relations joining results considered 
heuristics system essentially trying find permutation ng produces best plan form delta delta delta delta delta delta plans called left deep plans 
conceptually think system optimizer working dag single root node indegree 
node dag labeled subset ng 
label root empty set 
nodes depth labeled subsets ng cardinality edge node depth gamma labeled node depth labeled iff fix setting parameters 
associated node labeled best left deep plan compute join join relations indices setting parameters 
plan determined inductively follows 
initially algorithm determines best plan access individual relations 
step algorithm examines possible joins relations 
pair relations different join algorithms considered cheapest evaluation plan retained 
assume inductively associated node depth plan computing join associated node 
compute best plan node depth consider gamma fjg sum cost best plan accessing cost best plan known quite accurate physical properties interesting orders join result depend specific plan create 
requires simple extensions optimization algorithm described sac 
ignore issue solutions apply change presence extensions 
computing determined cost best plan computing find minimal 
gives best plan computing cost 
note phase results phase utilized 
phase label root best plan compute join cost 
approach takes time space exponential usually small practice approach feasible 
summarize theorem system optimizer computes lsc left deep plan specific setting parameters 
formal proof theorem provided lines proof theorem 
previous dealing uncertainty parameter values widely recognized query optimizers poor decisions compile time cost models inaccurate estimates various parameters 
efforts past address issue 
categorize strategies decisions start query execution strategies decisions query execution 
assume parameters predicted accurately compile time accurately known query begins execution 
example parameter number concurrent users 
assume value parameter stays constant execution query 
case aware kinds strategies ffl trivial strategy perform query optimization just query execution 
approach database systems illustra ill particularly efficient query may executed repeatedly 
ffl strategy find best execution plan possible run time value parameter 
requires additional compile time little query execution time simple table lookup find best plan current parameter value 
inss authors suggest randomized optimization reduce compile time optimization effort 
ffl gc suggests hybrid strategy performs search activity compile time 
decisions affected value parameter deferred start time choice nodes query evaluation plan 
parameters accurately predicted start query execution predicate selectivities strategies clearly inapplicable 
aware strategies address case involve potential modification query execution 
ffl kd proposes regular query optimizer generate single plan annotated expected cost size statistics stages plan 
statistics affected choice parameter value 
actual query execution expected statistics compared measured statistics 
significant difference query execution suspended re optimization performed accurate measured value parameter 
ffl ant implements interesting variant idea 
order execute query multiple query plans run parallel 
plan finishes significant progress competing plans killed 
strategy assumes resources plentiful wasted applied subcomponents query typically individual table accesses ffl ufa examines specific kind parameter variation cost accessing table occasionally faulty network internet 
strategy query system recognizes query execution source table available 
restarting query kd remainder query plan adjusted scrambled try forward progress 
ffl sbm focuses uncertainties reduced sampling specifically uncertainty selectivity predicate 
decision theoretic methods pre compute scenarios may worthwhile sampling sampling comes cost 
scenario arises sampling modify plan appropriate result sampling 
approach closest advocated view query optimization decision problem aim minimizing expected cost 
techniques sbm combined suggested 
note approaches involve making decision compile time 
way deal uncertainty wait information 
deal uncertainty treating parameters random variables approach applied completely compile time start time run time 
approach applied compile time size query plan created increase approaches 
lec query optimization formal model fix query 
inss start assuming cost function takes arguments plan vector values relevant parameters returns cost 
intuitively cost executing plan assumption relevant variables take values standard lsc approach choose fixed value usually expected value parameters find cost 
assume probability measure space possible values parameters 
pr compute expected cost plan ec denote expected cost respect cost function probability pr usual ec pr standard decision theoretic approach goal find lec plan expected cost 
distribution pr accurate model distribution parameters encountered run time cost estimates accurate definition expected execution cost lec plan low specific lsc plan 
goal finding lec plan sense compile time start time 
start time distribution parameters typically different compile time 
parameters distribution may concentrated value 
complete information values relevant parameters start time 
particularly true parameters values may change execute query 
note lec approach applies dynamic parameters 
need probability distribution possible sequences parameter values execution compute plan expected cost 
explore details approach section 
assume parameters change value query execution 
leads obvious questions 
get probability distributions 

get cost estimates 

compute lec plan 
regard question noted dbms practice constantly gathering statistical information 
believe statistics enhanced provide reasonable estimates relevant probabilities certainly area research 
purposes assume comment probabilities available 
second question making assumptions costs standard query optimizers 
regard question remainder section provide number ways modify standard optimizers produce lec plan reasonable approximation 
approaches vary need modify underlying query optimizer quality plan produced underlying assumptions distribution 
algorithm standard query optimizer black box ease exposition assume sections relevant parameter amount available memory take represent quantity 
assumption dropped section assume partition distribution amount available memory small number say buckets cost plan remain relatively constant bucket 
example example appropriate buckets intervals 
choosing buckets appropriately nontrivial discuss issue detail section 
identify standard approach doing query optimization special case bucket 
chosen buckets pick representative bucket call assume probability measure pr pr characterizes run query ith bucket 
assumptions straightforward approach finding approximations lec plan uses standard query optimizer black box 
suppose want compute delta delta delta assume memory stays constant execution plan 
algorithm value memory parameter run optimizer assumption actual amount memory available 
gives candidate plans 
compute expected cost candidate choose expected cost 
long expected value memory traditional lsc approach possible values consider loss generality assume guaranteed plan expected cost higher plan chosen traditional approach 
assume practice actual lec plan cost close optimal plan value memory 
extent true algorithm gives approximation lec plan 
cost algorithm cost invocations optimizer plus cost evaluating expected cost candidate plan 
candidate plan gamma joins different memory sizes determine expected cost 
candidates leading total cost gamma smaller cost candidate generation bn gamma 
consequently approximate cost algorithm times cost single optimizer invocation 
note sense algorithm startup time compile time simply appropriate distribution memory sizes checking see candidate plan best 
combine ideas parametric query optimization approach inss 
precompute best expected plan number possible distributions ones give coverage expect encounter run time store expected plans query execution time 
approach advantage requiring change optimizer whatsoever major drawbacks 
requires buckets point clearer section second may return lec plan 
conceivable plan optimal better average candidate considered algorithm 
example plan second best memory size may better memory sizes best plan memory size may better expectation 
simple modification approach generates candidate plans disadvantage requiring modify basic query optimizer 
algorithm generating candidates suppose generating best plan memory size generate top plans 
relatively straightforward modify existing query optimizers 
concreteness show done system algorithm assume inductively associated node depth dag top plans computing join associated node 
compute top plans node depth consider gamma fjg 
consider top plans computing join top plans accessing combining possible join method gives top plans computing join join 
combinations plans need considered join method actual number combinations lower 
proposition suffices consider log combinations plans join method produce top plans 
proof suppose sc top plans computing sorted increasing order cost ac top plans accessing sorted increasing order cost 
note cost combination ak higher combination ik gamma combinations cost higher ak 
consider ak ik ik implies get plans ak 
note ik implies need consider top bc kc entries kth column arrange combinations theta matrix 
total number entries need consider recall dx log total number entries need consider log compute best plans particular join method joining evaluate cost formula join method 
note variants input properties behave identically respect cost formula 
consequently difference log combinations arises sum costs input plans 
consequently cost checking combinations expected small compared cost evaluating cost formula 
considering get lists top plans 
take top plans combined list 
extension easily implemented relatively small localized change current optimizers 
theorem algorithm computes top left deep plans choices parameter values ffb times cost computing single best left deep plan specific setting parameters small constant ff 
top plans memory sizes compute expected cost cb plans choose plan expected cost 
showed previous section computation expected costs candidate plans small compared cost candidate generation 
case number candidates increased factor expect algorithm roughly times expensive single optimizer invocation 
algorithm generates candidates approximation lec plan necessarily lec plan 
show willing modify basic query optimization algorithm produce actual lec plan 
algorithm generic algorithm computing lec plan provide generic modification basic system query optimizer directly compute lec plan merging candidate generation costing phases 
assume inductively associated node depth dag plan expected cost computing join associated node expected cost 
assume node associated probability distribution possible memory sizes 
intuitively probability distribution available memory reach node actual execution query plan containing node subplan 
assume memory size change course executing plan join operations pipelined plan distribution node 
away restriction section 
algorithm proceed inductively dag 
stored relation find lec access path 
compute plan expected cost node depth labeled consider gamma fjg 
expected total cost expected cost computing assumption hand added expected cost joining compute probability distribution available memory 
consider probability distribution different memory sizes computation requires evaluations cost formula join algorithm 
retain plan expected total cost discarding candidates 
theorem algorithm gives lec left deep plan 
proof proof straightforward adaptation argument correctness basic system algorithm fact expectation distributes addition 
suppose nonempty subset ng 
ps denote left deep plan computing conceptually think ps consisting choice plan accessing jsj plan computing plan computing jsj ps follows ec ps ec ec ec ps plan algorithm outputs want show ec ps ec ps ps proceed induction jsj 
base case jsj 
suppose fig 
ec ps ec ps algorithm choose lec access path assume claim holds jsj subset ng elements 
plan ps fjg lec method compute join 
clear description algorithm ps fp sg ec ps sg 
suppose ps arbitrary left deep plan compute suppose ps computes 
computes induction hypothesis definition see ec ec ps ec 
furthermore ec ec fjg ec fjg lec access path 
ec ec lec join method 
ec ps ec ec ps required 
assume memory change execute plan cost computation times cost standard computation single memory size 
algorithm works compile time start time 
combine ideas parametric query optimization precomputing lec plans various assumptions probability distributions storing start time 
dealing change execution far assumed amount available memory stays constant execution plan 
may reasonable query takes long time order minutes 
execution concurrent new queries may start old queries may finish 
assume available memory mainly determined number queries run concurrently may change execution 
deal dynamic memory changes assume probability measure possible sequences memory sizes 
evaluate candidate plan respect sequence determine expected cost 
keep analysis unwieldy assume plan execution takes place phases corresponding join plan 
assume memory change execution phase change phases 
compute join relations gamma phases 
need consider possible run time environments corresponding sequence memory sizes length gamma 
need probability distribution memory size sequences 
distribution come 
natural assumption assume distribution initial memory sizes transition probability describing memory change units value simplicity assume transition probability depends current memory usage time 
reasonable assumption theta systems stable operational mode 
simplifying assumptions apply algorithm previous subsection calculate lec plan dynamic memory 
simply associate initial distribution root dag transition probabilities compute distribution associated node tree 
apply pr pr oe pr jb pr ja ec pr jb distributions needed node depends algorithm change algorithm rely fact consists single memory size 
note complexity algorithm clearly affected parameter space potentially bigger bm memory values consider bm gamma sequences length gamma 
theorem simplifying assumptions algorithm returns lec left deep plan presence dynamically varying parameters 
proof consists sequence memory sizes proof theorem works proof rely fact single memory size way 
dealing multiple parameters focused parameter far amount available memory 
practice typically deal number parameters 
section consider effect multiple parameters algorithms specifically available memory selectivities query predicates 
selectivities particular notoriously uncertain 
believe representing uncertainty probability distribution computing lec plan ameliorate difficulty 
note ideas sbm deciding sample may usefully applied 
focus static case section 
apply idea section deal dynamic case 
amount available memory uncertainty need single probability distribution node dag allow compute lec plan 
uncertain parameter may need expand joint distribution size may grow exponentially number parameters 
independence holds practice default assumption existing query optimizers assume rest section parameters interest independent 
simplifying assumption means carry separate distribution parameter avoid exponential blow description joint distribution 
dependencies variables describe distribution succinctly bayesian network pea 
believe techniques applicable case 
note standard formulas computing cost join plan typically take parameters sizes relations joined amount available memory 
compute expected cost join method applied particular pair relations need just distributions 
means may parameters deal apply algorithm multi parameter setting node distributions required compute lec plan node 
able apply idea inductively node dag need compute distribution size result join parent node current node needs distribution input size 
order compute distribution size result need distribution selectivity join predicates 
node need exactly distributions distributions computing expected cost plus distribution selectivity join predicate matter distributions start 
shows distributions carry node quantity depends 
generic modified algorithm 
section algorithm works dag 
algorithm compute lec plan node depth labeled consider gamma fjg 
assume inductively lec plan distribution jb assume best way access distribution ja initial selection 
evaluate cost formula triple possible values jb ja compute expected cost calculating method 
bx denote number buckets random variable shows need bm jb ja evaluations compute expected cost particular method computing compute expected cost choice retain plan expected cost 
total cost naive computation bm jb ja join algorithm considered 
compute distribution size result fix compute triple oe possible values ja jb selectivity oe probability join size 
assuming independence just product pr ja pr jb probability selectivity oe 
fill distribution size result 
require jb ja oe operations compute distribution 
size result independent choice need computation choose jb ja minimal 
practice expect ja jb choice matter 
summarize generic method takes bm jb ja evaluations cost formula takes jb ja oe operations compute distribution jb better knowledge cost formula 
join methods practice relatively simple cost formulas 
pick sort merge join page nested loop join examples demonstrate subsections better 
case sort merge join cost sort merge join sm delta jaj jbj delta jaj jbj delta jaj jbj note ec sm ec sm jaj jbj pr jaj jbj ec sm jaj jbj pr jaj jbj show term computed efficiently 
second term computed analogously leave details reader 
jaj jaj denote representatives bx buckets variable rewrite summand follows jbj pr jbj pr pr pr describe compute ec sm jaj jbj pr jaj jbj time bm jaj jbj 
compute pr 
easily compute probabilities time bm 
store values table 
table lookup compute pr pr pr value constant time 
compute pr jaj jbj store values table 
pr jaj pr jaj pr jaj compute probabilities time jaj jbj need go set buckets 
compute jaj jaj jbj store values 
done time jaj jbj jaj jaj jaj jaj pr jaj jaj jaj pr jaj need go set buckets 
compute ec sm jaj jbj 
note need constant time compute summand jbj computed adding jaj jaj takes constant time compute probabilities involving stored 
compute expectation total time bm jaj jbj including time take compute values stored tables 
need compute pr jaj jbj 
done time jbj pr jaj jbj jbj pr jaj pr jbj computed pr jaj 
formulas consider costs analysis sha simplified cases 
commercial database systems complicated formulas usually represented form complex code 
result aiming accuracy modeling algorithm despite fact parameters instantiate model inaccurate 
speculate return simple formulas combination lec optimization may result reliable query optimizers 
write abbreviation statement takes value bucket representative 
computation takes time bm jaj jbj algorithm informally described linear total number buckets 
note algorithm asymptotically optimal look entries individual distributions 
need carry computation node dag 
earlier notation 
note cost amortized nodes 
need computation pr pr probability distributions change course execution 
precompute values amount node jb sort merge 
case nested loop join example look nested loop join method 

cost formula nested loop join nl ae jaj jbj jaj jaj delta jbj previous section split ec nl terms ec nl jaj jbj pr jaj jbj ec nl jaj jbj pr jaj jbj 
focus term leave second term reader 
ga jbj jbj jaj 
note term rewritten follows jaj pr jaj ga pr aga pr computation time bm jaj jbj 
procedure similar sorted merge join just sketch details 
compute pr 
takes bm steps enables compute pr constant number steps 
compute pr jbj jaj 
compute jaj probabilities time jaj jbj 
compute jbj jbj jaj 
arguments similar sort merge case show done time jaj jbj 
compute ec nl jaj jbj 
summand requires constant time ga determine probabilities involving constant number steps 
compute pr jaj jbj time jaj just case sort merge 
process takes time bm jaj jbj algorithm linear total number buckets 
considered single node dag 
precompute pr pr amount node nested loop jaj 
distribution result size showed expected cost specific join methods computed time linear number buckets 
recall need compute distribution size result node 
takes time jaj jbj oe 
better 
specific distributions may possible 
say 
suppose uniformity decide buckets node variable 
buckets variables jaj jbj oe get buckets size join maintain buckets computing probability 
doing computation jaj jbj oe buckets 
computation takes time desired buckets ja bj 
generally jaj jbj oe jaj jbj oe buckets respectively carry computation time jaj jbj oe jaj jbj oe jaj jbj oe steps 
strategies partitioning parameter space seen complexity algorithms computing approximating lec plan depends partitioning parameter space number buckets 
large number buckets gives closer approximation true probability distribution leading better estimate lec plan 
hand smaller number buckets optimization process expensive 
mentioned earlier algorithm bucket reduces standard system algorithm 
specific examples example choosing buckets straightforward function join algorithms considered sizes relations joined 
general mechanism choosing buckets optimally efficiently 
insights help explore issue 
consider algorithms sections system algorithm number parameter settings generate candidate plans evaluated candidates find expected cost 
partitioned parameter distributions ways generate candidate plans computing best plan best plans parameter value considered second computing actual expected cost candidates generated 
different related issues arise case 
generating candidates basically interested determining region parameter space search candidates 
partition coarsely generate candidates region parameter space contain best candidates 
computing costs recall goal find candidate expected cost 
need extremely accurate estimate cost 
expect able associate degree accuracy particular partitioning guarantee estimated expected cost plan partitioning certain degree true expected cost 
may able coarse bucketing eliminate plans refined bucketing decide remaining plans 
insight applies third algorithm section computes lec plan 
algorithms compared node dag expected cost algorithm cost needs computed accurately plans pruned 
respect pruned plans simply need satisfied expected costs higher chosen plan 
consequently start coarse bucketing strategy pruning refine buckets necessary 
note partitioning strategy node 
partition appropriate strategies considered node 
cost formulas common join algorithms simple respect parameter available memory 
saw fixed relation sizes cost sort merge join possible values depending relationship memory size larger relation similarly cost nested loop join possible values 
consequently considering sort merge join resp nested loop join fixed relation sizes need deal resp buckets memory sizes 
general expect able features cost formulas reduce number buckets needed algorithm node basis 
way approach bucketing realize ultimately want compute expected cost 
fix plan note express ec follows ec pr fixed values yields called level set 
cost relatively level sets may wise bucket parameter space level sets mind 
suppose level sets 
principle compute ec evaluations cost function multiplications gamma additions 
probabilities level set 
general buckets correspond level sets may evaluate cost function times get answer time 
bucket joint distribution level sets bucket parameter separately minimize computation involved computing expected cost 
cost function may level sets 
willing settle approximate answer bucket range function coalescing level sets 
problem approach probability level set may easy determine 
concluding remarks presents simple idea searching query execution plans expected cost 
best knowledge new approach query optimization departing established approach past decades 
approach viewed generalization traditional approach sense traditional approach essentially approach restricted bucket static case 
proposes approach aware details need worked 
task easier simplifying assumptions 
revisit assumptions 
ffl presentation system query optimization algorithm simplistic 
major issue consider parallelism play role ways bushy join trees pipeline parallelism 
cases interaction parallel components terms memory 
ignored issue current query optimizers model believe lower bound want exact expected cost treat cost function black box 
techniques applied lec optimization 
ffl dealing changes execution plan simplifying assumption change occurs join phase 
clearly approximation reality 
pipelined joins treated single phase algorithms sort merge join may involve multiple phases 
certainly simplifying assumptions note approach allows tackle problem addressed works area 
ffl considered multiple parameters assumed parameters independent 
may reasonable assumption practice 
interest see extent extend techniques situations dependencies variables 
clearly needs done lec query optimization production database systems believe approach worth exploring 
currently prototyping algorithm section test benefits realistic queries execution environments 
prototype useful investigate impact bucket choice see section quality lec plans 
ant 
dynamic query optimization rdb vms 
proceedings ninth ieee conference data engineering taipei taiwan pages 
gc goetz graefe richard cole 
optimization dynamic query evaluation plans 
proceedings acm sigmod international conference management data minneapolis mn 
ik ioannidis kang 
randomized algorithms optimizing large join queries 
proceedings acm sigmod conference management data pages 
ill illustra information technologies broadway suite oakland ca 
illustra user guide june 
inss ioannidis ng shim sellis 
parametric query optimization 
proceedings eighteenth international conference large databases vldb vancouver canada pages 
kd kabra david dewitt 
efficient re optimization sub optimal query plans 
proceedings acm sigmod conference management data pages 
richard lipton jeffrey naughton donovan schneider seshadri 
efficient sampling strategies relational database operations 
theoretical computer science pages 
loh guy lohman 
personal communication praveen seshadri 
pea pearl 
probabilistic reasoning intelligent systems 
morgan kaufmann san francisco calif 
hamid pirahesh joseph hellerstein hasan 
extensible rule query rewrite optimization starburst 
proceedings acm sigmod international conference management data san diego ca 
poosala ioannidis haas shekita 
improved histograms selectivity estimation range predicates 
proceedings acm sigmod conference management data pages 
res resnik 
choices decision theory 
university minnesota press minneapolis 
sac patricia selinger astrahan chamberlin raymond lorie price 
access path selection relational database management system 
proceedings acm sigmod international conference management data pages 
sbm barnes morris 
bayesian approach database query optimization 
orsa journal computing 
sha leonard shapiro 
join processing database systems large main memories 
acm transactions database systems september 
swa arun swami 
optimization large join queries combining heuristic combinatorial techniques 
proceedings acm sigmod conference management data pages 
ufa urhan franklin 
cost query scrambling initial delays 
proceedings acm sigmod international conference management data pages wa june 
