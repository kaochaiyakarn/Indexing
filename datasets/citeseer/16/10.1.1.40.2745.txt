programmed graph replacement systems andy schurr lehrstuhl fur informatik iii rwth aachen 
aachen germany mail andy informatik rwth aachen de various forms programmed graph replacement systems extensions contextsensitive graph replacement systems proposed today 
differ considerably respect underlying graph models supported forms graph replacement rules offered rule regulation mechanisms 
additional constructs definition graph schemata derived graph properties forth 
difficult develop precise compact descriptions programmed graph replacement systems necessary prerequisite attempt compare properties detail 
programmed logic structure replacement systems kind intermediate definition language purpose 
treat specific graph classes sets predicate logic formulas certain properties called structures 
rules preserve consistency manipulated structures nonmonotonic reasoning checking needed preand postconditions 
called basic control flow bcf expressions underlying fixpoint theory provide needed means programming rules 
chapter introduces basic framework systems studies essential properties context sensitive graph replacement approaches popular rule regulation mechanisms 
history graph replacement systems starts years ago seminal papers called web grammars chomsky systems partial orders 
graph replacement systems developed solve real world problems fields computer science biology 
surveys graph replacement systems short version distinguishes different types applications describing generating known languages graphs instance certain graph theoretical properties model growing plants 
recognizing languages graphs model instance underlying logical structure natural language sentences scanned images office documents 
specifying new classes graphs graph transformations represent instance databases database manipulations software documents document manipulating tools 
solving problems category pure graph replacement systems sufficient accompanying tools urgently needed 
second category problems requires classes graph replacement systems powerful describe interesting languages graphs restricted efficiently working parsing execution tools realized 
design adequate classes graph replacement systems subject ongoing research activities outside scope cf 
section chapter volume 
third category problems needs graph replacement systems kind executable specification high level programming language 
order able fulfil resulting requirements new concepts added pure generation graph replacement systems see especially discussion needed extensions 
important extensions new means controlling application graph replacement rules 
lead definition programmed graph replacement systems main topic contribution 
programmed graph replacement systems practice historical reasons mainly earlier proposals programmed graph replacement systems belong main branches graph replacement systems algorithmic set theoretic approach cf 
chapter volume algebraic category theory approach see chapter volume 
complete implementations programmed graph replacement systems built 
programmed attributed graph grammars pagg mainly specifying graph editors cad systems 
second programmed graph replacement systems progres tightly coupled development software engineering tools 
progres predecessors project specifying internal data structures tools integrated project support environments 
pure algorithmic graph replacement systems 
soon evident additional means defining complex rule application conditions manipulating node attributes needed 
appropriate extensions suggested 
support ffl separating definition static graph integrity constraints dynamic graph manipulating operations database languages separate definition database schemata definition database queries manipulations ffl specifying derived attributes relations purely declarative manner similar style attribute tree grammars relational languages deal derived data ffl solving typical generate test problems implicitly available means depth search backtracking manner prolog deals problems 
various extensions graph replacement systems studied resulted development programming language progres integrated programming support environment 
programmed graph replacement systems theory produce formal definition programmed graph replacement systems pagg progres means set theory difficult timeconsuming task 
especially definition control structures derived graph properties graph schemata constitutes major problem 
switching set theory formalism category theory solve 
category double push dpo approach cf 
chapter volume single push approach cf 
chapter volume difficulties definition integrity constraints derived information 
necessary establish framework formal definition application oriented graph replacement systems 
observations major influence development framework ffl relational structures obvious generalization various forms graphs hypergraphs 
ffl logic formulas suited defining required properties generated graph languages cf 
chapter volume ffl nonmonotonic reasoning appropriate inferring derived data verifying integrity constraints deductive database systems 
ffl fixpoint theory natural candidate defining semantics partially defined nondeterministic recursive graph replacement programs 
combining sources inspiration logic graph replacement systems developed produce complete definition language progres 
generalized logic structure replacement systems programmed logic structure replacement systems 
see www informatik rwth aachen de research progres index html contents contribution presentation systems survey application oriented programmed context sensitive graph replacement systems organized follows ffl section introduces systems demonstrates may specify graph schemata schema consistent graphs consistency preserving graph transformations 
ffl section presents basic set control structures programming graph replacement rules denotational semantics definition fixpoint theory 
control structures systems extended systems 
ffl section compares typical representatives application oriented algorithmic graph replacement systems sketches translation systems 
furthermore discusses relationships dpo spo families algebraic approaches 
ffl section surveys collection currently popular rule regulation mechanisms translates basic control structures systems 
topics design readable syntax static type system language progres implementation tools support programming graph replacement systems outside scope volume 
logic structure replacement systems nowadays surprisingly large variety different graph replacement formalisms existent 
restricted expressiveness suited proving properties generated graph languages 
complex mainly specification rapid prototyping purposes 
underlying graph data models differ great extent respect treatment edges attributes order able reason differences common properties graph replacement approaches underlying data models section general framework urgently needed 
framework provide proper means definition specific graph models graph replacement approaches 
attempt direction called high level replacement hlr systems construction categories certain properties 
generalizes algebraic graph replacement approaches incorporates algebraic specification technologies definition adam harry andy fred charlie linus sally clio mary hannah eve wife edge child edge man node woman node income value running example person database tribute domains see 
hlr systems problems formalizing derived graph properties graph integrity constraints graph grammar specification language progres 
generic framework developed comprises different graph replacement systems special cases underlying formalism specification language progres 
combines elements algorithmic algebraic graph replacement systems elements deductive database systems 
outcome cross fertilization process logic structure replacement systems topic section 
formalism systems intended directly specification language provides definition ffl specific graph models special cases relational structures ffl family accompanying graph replacement notations 
presentation systems accompanied number examples sketch human readable graph grammar specifications written progres notation may translated 
means examples reader hopefully understand systems may define semantics compare intended behavior specific graph replacement systems 
rest section organized follows ffl subsection repeats basic terminology predicate logic contains formal definition relational structures structure schemata sets formulas 
ffl subsection deals substructure selection finding matches left hand sides rules additional application conditions 
ffl subsection introduces structure replacement formalism 
ffl subsection summarizes main properties systems relationships approaches hlr systems 
subsections coherent running example drawn area deductive database systems 
specification person database includes definition derived relationships integrity constraints complex update operations displays sample database 
structure schemata schema consistent structures subsection introduces basic terminology predicate logic 
furthermore explains modeling node edge labeled graphs special cases schema consistent structures sets formulas certain properties 
running example person database modeled directed graph 
way able demonstrate graphs special case structures graph replacement special case structure replacement 
definitions propositions sections independent selected graph model encoding 
definition signature tuple sigma af ap signature af alphabet function symbols including constants 
ap alphabet predicate symbols 
special alphabet object identifier constants 
special alphabet constants representing sets objects 
alphabet logical variables quantification purposes 
signature definition introduces names specific objects sets objects special constants 
constants play important role selection rule matches 
elements rule left hand side denote match single objects structure elements denote match sets objects structure 
please note alphabet logical set variables monadic second order logic chapter volume 
quantification set variables needed definition graph theoretic properties strict formal definition graph replacement formalisms studied 
order logic distinction constant symbols af functions arity necessary distinguish different kinds constants subsection play different roles application structure replacement rules 
family alphabets symbols take domain range functions account 
family alphabets symbols take arities predicates account 
signature example may definition person databases precisely graph representations sets formulas 
presents graph representation database twelve persons 
person man node woman node 
man woman nodes may sources targets child edges wife edges man source woman target 
furthermore person integer valued income attribute 
example signature person database 
graph signature fig 
sigma af ap af child woman wife man person income integer 
ap node edge attr type 
value 

alphabets sets arbitrarily chosen constant variable names 
set af hand contains just needed symbols node labels edge labels attribute types attribute values evaluation functions 
alphabet ap contains predicate symbols important arbitrarily selected encoding directed attributed graphs node distinct class label attribute value designated type 
interpretation ffl node graph contains node label ffl edge graph contains edge label source target ffl attr attribute node value ffl type attribute value type sequel assume sigma signature mentioned alphabets 
definition sigma term und sigma atom 
tx sigma set sigma terms usual sense contain function symbols constants af free variables additional identifier symbols sigma set atomic formulas sigma atoms tx sigma contain predicate symbols ap expressing equality sigma terms 
sigma ae tx sigma set terms contain symbols variables object set identifiers leafs 
definition sigma formula derivation sigma formulas 
sigma set sets closed order predicate logic formulas sigma formulas sigma atomic formulas logical connectives quantifiers 
furthermore phi phi sets phi phi means formulas phi derivable set formulas phi consistent complete inference system order predicate logic equality 
elements sigma represent structures structure schemata schema consistent structures left right hand sides pre postconditions structure replacement rules 
definition sigma structure 
set closed formulas sigma sigma structure write sigma sigma contain formulas form 
example person database structure 
structure set formulas graph model node adam man node eve woman node sally woman attr adam income attr eve income edge adam wife eve edge eve child sally set formulas different graphs models 
models graph interested 
may contain additional nodes edges different identifiers eve sally graph node 
definition introduce called completing operator allows get rid unwanted graph models sigma structures reason properties minimal models pure syntactical level 
models structures introduced formally sequel 
example demonstrates needs completing operator detail 
presents definition single person database explains difficulties prove database contains person 
related problem extensively studied field deductive database systems tackled number quite different requiring bindings logical variables means existential universal quantification restrict expressiveness formulas avoids difficulties varying treatments free variables different inference systems 
approaches called closed world assumption nonmonotonic reasoning capabilities cf 

main idea approaches distinguish basic facts derived facts add negations basic facts rule base derivable original set facts 
scope chapter explain nonmonotonic reasoning detail 
simply assume existence completing operator adds certain set additional formulas structure 
resulting set formulas consistent may contain contradictions sufficiently complete prove mentioned properties axioms order predicate logic 
definition sigma structure completing operator 
function sigma sigma sigma structure completing operator structures sigma consistent set formulas ae ae ae sigma sigma substitution renames object identifiers object set identifiers introducing name clashes consistent renaming identifiers completion formula sets compatible operations 
identity operator sets formulas structures trivial example completion operator 
structure set atomic formulas free contradictions 
furthermore inference systems predicate logic property consistent renaming constants destroy constructed proofs 
troubles requirement renaming completion compatible 
useful example completion operation union set basic facts derivable facts carefully selected subset negated non derivable facts graph contain node name unequal adam example 
please note need additional set formulas able derive new facts atomic formulas structures 
set order formulas part definition 
example nonmonotonic reasoning 
singleton set adam man structure graphs containing man node models 
interested properties minimal graph models able prove contains single node 
purpose operator defined follows omitted sets formulas deal edges node class person attribute income integer node class man person node class woman person edge type child person person edge type wife man woman path ancestor person person child self ancestor path brother person man child child instance man self excerpt progres graph schema definition node 
object ids fg 
able prove contains male node adam node adam node adam man 
completing operators may definitions specific regarded class structures 
part definition structure schemata definition sigma structure schema 
tuple phi sigma structure schema write sigma sigma phi sigma consistent set formulas specific object set identifiers contains integrity constraints derived data definitions 
sigma structure completing operator 
definition schema consistent structure 
phi sigma schema 
sigma structure schema consistent respect write phi consistent set formulas 
definition schema consistency similar related definition knowledge representation language telos 
states structure inconsistent respect schema able derive contradicting formulas completed structure schema 
example definition person database schema 
set formulas phi consists subsets ffl subset defines integrity constraints selected graph data model excludes dangling edges attributes nodes 
ffl second subset contains person database specific integrity constraints man woman nodes person nodes 
ffl subset deals number derived graph properties known ancestor relation definition brother child 
example schema person databases 
structure schema phi graph fig 
form phi edge xl yl node xl node yl attr node node man node person node woman node person edge wife node man node woman edge wife edge wife edge wife edge wife attr income type integer node person attr income ancestor edge child ancestor brother edge child edge child node man displays corresponding progres specification graph properties 
declarations establish node class hierarchy person root class man woman subclasses 
nodes labeled classes income attribute 
declarations introduce child wife edges constrain labels classes source target nodes 
furthermore annotations wife edge declaration require man node outgoing wife edge woman node incoming edge type 
derived binary relations declared called paths define known concepts ancestor brother 
ancestors person determined evaluating child gamma self ancestor follows ffl compute parents person set sources incoming child edges child gamma traverses child edges reverse direction 
ffl concatenates subexpressions return union parents self ancestors 
brothers person computed ffl determining parents child gamma ffl finding male children 
instance man ffl eliminating person result self 
way progres allows users define complex graph schemata elaborate integrity constraints derived relationships attributes 
translation schema definitions sets formulas straightforward example 
forthcoming rules systems observe integrity constraints transform schema consistent structure graph 
furthermore may access derived information pre postconditions 
please note possible construct structure replacement machinery checking integrity constraints pre postconditions guaranteed terminate 
depends selected nonmonotonic reasoning strategy implementation programmed graph replacement approach certain types constraints prohibited lead rule application process infinite loop 
reconsider termination problem section fixpoint semantics definition potentially nonterminating control structures 
substructures additional constraints subsection formalizes term rule match additional constraints means morphisms 
term central definition structure replacement pre postconditions follows 
determines substructures structure legal targets structure replacement step match rule left hand side 
main difficulty definition new structure replacement approach requirement include expression oriented algorithmic graph grammar approach 
approach powerful means deleting copying redirecting arbitrary large bundles edges 
handle manipulation edge bundles introducing special object set identifiers structure replacement rule left right hand side 
set identifiers match arbitrarily large maximal set object identifiers see example definition 
consequence mappings structures select affected substructure rule structure total partial functions 
general case mappings relations object set identifiers 
relations required preserve properties source structure rule left hand side embedding target structure structure manipulate usual take additional constraints chosen embedding account 
problem comes fact deal attributes rules able write read modify attribute values way able manipulate structural information 
sufficient map object set identifiers sets object identifiers need possibility map sets attribute value representing sigma terms 
definition sigma term relation 
sigma sets formulas vf wf vf wf object set identifiers 
furthermore sigma set variable object identifier free sigma terms cf 
def 

relation vf theta vf sigma wf theta wf vf sigma sigma relation vf ju ug object identifier mapped single object identifier single attribute value representing sigma term 
wf ju vf sigma object set identifier mapped object set identifier set object identifiers attribute value representing sigma terms 
definition introduces relations object set identifiers sets sigma terms 
extensions relations arbitrary formulas defined follows definition sigma relation sigma term relation definition 
extension domain sigma formulas called sigma relation defined follows 
oe oe sigma free variables xn identifiers ng sigma oe xn oe xn furthermore phi sigma short hand sequel phi foe sigma oe phi oe oe definition simply states formulas oe oe related differ respect related terms 
object identifier oe replaced uniquely defined oe object set identifier oe replaced element oe occurrences oe get substitute 
relations formulas able define mappings morphisms sets formulas structures preserve certain properties 
definition sigma structure morphism 
sigma 
sigma relation sigma morphism write 
sigma sigma sigma structures called sigma structure morphism 
definition morphism requires simplest case subset example example simple structure morphism structure example represents graph man node woman attr income value edge wife edge child edge child value ae ae xn denotes consistent substitution corresponding ae sigma relations structure morphisms hannah charlie fred andy value hannah sally andy adam eve value selected examples morphisms show different object set identifiers may mapped object identifier explicitly prohibited means additional formulas 
furthermore object set identifier may mapped arbitrarily large set identifiers terms empty set permitted special case 
sequel show morphisms structures define transitive reflexive associative relation build category 
proposition category sigma structures 
assume ffi usual composition binary relations 
sigma family sigma morphisms defined ffi category holds true set sigma structures sigma family morphisms 
proof sigma morphisms closed ffi ffi sigma relations def 
ffi sigma relation def 
ffi ffi morphisms def 
subst 
preserves proofs ffi modus ponens ffi 
ffi morphism 
existence neutral sigma morphism id sigma obviously relation id maps object set identifier neutral element family sigma relations 
id id id id required neutral morphism 
associativity ffi sigma morphisms follows directly fact ffi associative binary relations 
order obtain proof family sigma structure morphisms sigma ffi category simply replace sigma sigma 
definition substructure 
sigma structures 
substructure respect sigma relation write fc substructure selection additional constraints definition coincides usual meaning homomorphic substructure subgraph contain object set identifiers 
proposition soundness substructure property 
sigma structures properties equivalent substructure respect sigma relation subset proof see def 
see def 
sigma step proof follows fact sets atomic formulas normal set inclusion equivalent relations 
definition substructure additional constraints 
phi sigma structure schema sigma psi sigma set constraints object set identifiers 
constrained substructure respect sigma relation additional set constraints psi write psi 
psi phi phi psi psi conditions equivalent existence diagram inclusions morphisms map object set identifier psi psi psi 
phi phi 
homomorphic means different object identifiers may mapped object identifier test condition income person person woman child child brother wife wife man subgraph test written progres informally speaking structure substructure respect additional constraints able prove constraints embedding fulfilled 
may basic facts including formulas generated completing operator set formulas phi structure schema purpose 
example substructure selection 
phi schema example database example 
structure sigma accompanying set constraints psi sigma defined represent progres subgraph test select pair persons children brother sister appropriate income values children man node woman attr income attr income edge child edge child psi brother edge wife edge wife node person node person remember value object identifiers object set identifiers cf 
example 
definition harry sally linus clio clio mary correct sigma relation psi furthermore assume completing operator generates formulas means able prove ffl harry target child edge brother sally cf 
definition brother example ffl harry source wife edge ffl sally target wife edge 
bound bound attribute condition valid 
formulas graph schema example able prove linus clio mary direct members classes man woman respectively members class person 
relation example maximal respect number object identifiers bound set identifiers important property sigma relations involved process structure rewriting 
schema preserving structure replacement having definitions structure schemata schema consistent structures structure morphisms prepared introduce structure replacement rules quadruples sets closed formulas 
application structure replacement rules defined construction commuting diagrams similar way done algebraic graph grammar approach 
note sigma relations partial functions 
main properties algebraic approach necessarily lost sub diagrams pushouts application rule invertible general case 
unfortunately pay price ability formalize complex rules match sets nodes able delete copy redirect arbitrarily large edge bundles 
definition structure replacement rule 
quadruple ar ar sigma sigma structure replacement rule production signature sigma write sigma set left hand side application embedding conditions contains object set identifiers left hand side set right hand side application embedding conditions ar contains object set identifiers right hand side 
set identifier set identifier vice versa deleting dangling establishing connections new substructures created rule right hand side rest modified structure 
example defines structure replacement rule structure selecting example 
persons certain preconditions person adopts person children 
corresponding progres production displayed 
example structure replacement rule marry 
psi defined example structure replacement rule marry ar form psi 

fattr income value wife attr income value value edge child edge child 
ar fg displays result applying structure replacement rule marry twice database 
sally married harry fred clio 
identifier bindings structure replacement step shown example 
second structure replacement step bound fred clio 
furthermore set identifiers rule left right hand side empty bindings fred clio children 
steps executed follows ffl find suitable matches object identifiers database corresponding preconditions satisfied 
ffl extend selected match object set identifiers bind set identifier maximal set objects database preconditions valid 
ffl remove image image database old income attribute value selected node 
ffl add image image database new income attribute value wife edge child edges children nodes 
production marry condition income transfer income income income person person woman child child brother wife wife man person person woman child child man child child wife graph replacement rule written progres ffl test postconditions ar 
postcondition violated cancel modifications return step list restart rule application match 
ffl test constructed database schema consistent treat inconsistency violated postconditions 
applications rule marry worry postconditions schema inconsistencies 
necessary context conditions part preconditions move brother check set preconditions set postconditions ar 
drop married checks schema example contains integrity constraints preventing 
normally integrity constraints repeated postconditions postconditions new objects replace complex preconditions 
open question set postconditions referencing instance derived properties new objects may transformed equivalent set preconditions 
definition schema preserving structure replacement 
phi sigma structure schema schema consistent structures 
furthermore ar sigma structure replacement rule 
structure direct derivable applying write adam andy fred charlie linus sally clio mary hannah eve wife edge child edge man node woman node income value harry modified person database morphism selected redex respects preconditions 
morphism ae selects maximal substructure ae inclusion relations 
morphism ar selected subgraph respects postconditions ar 
morphism maps new object identifier defined separate new object identifier defined 
property holds identifier kg identifier kg identical respect identifiers 
exists structure sigma represents intermediate state deletion old substructure insertion new substructure 
straightforward task transform definition schema preserving structure replacements effective procedure application rule schema consistent structure execution proceeds explained definition equivalent construction diagram 
unfortunately guarantee process computing derived data checking pre postconditions integrity constraints terminates general case 
introduce special symbol nonterminating computations section define semantics structure replacement programs 
ar diagram application structure replacement rule note kind structure replacement prohibit selection homomorphic matches identifiers mapped object application replacement rule marry relates instance set identifiers node clio graph database 
sharing permitted belongs 
deleting preserving conflicts resolved favor preserving objects spo approach chapter volume 
relation restriction longer morphism readability reasons sigma morphisms map different node identifiers production node graph may need prohibited language progres 
note take care dangling general case person database replacement rule subset guarantee node removed related edge edge attr formulas 
may accomplished adding appropriate formulas set identifiers rule left hand side 
way able overcome problem algebraic double pushout approach deletion nodes unknown context cf 
chapter volume 
proposition structure replacement construction diagrams 
assuming terminology definition able construct diagram fig 
inclusions 
diagram commuting 
proof existence commuting guaranteed definition 
proving existence commuting show step definition constructs morphism start definition condition def 
prop 
condition def 
simple transformation simple transformation condition def 
def 
prop 
rest proof follows directly ffi ffi ffi ffi restriction identifiers equipped definition structure replacement able define systems generated languages 
usual generated isomorphic language elements identified concrete sigma structures definition replaced equivalent classes concrete sigma structures called sigma structures 
definition sigma structure 
set sigma structures sigma sigma consists equivalence classes sigma structures respect equivalence relation sigma isomorphism worth notice isomorphism sigma structures bijective function maps object identifiers object identifiers object set identifiers object set identifiers cf 
def 
sigma relations sigma morphisms 
contain object set identifiers way round 
consequence possible construct left right inverse morphism gamma line argumentation longer true arbitary sets sigma formulas regarded 
single nonatomic formula represents set derivable facts 
possible sets formulas equivalent isomorphic differ respect number object set identifiers 
definition schema consistent sigma structure 
sigma schema set schema consistent structures 
set schema consistent sigma structures defined sigma proposition soundness schema consistent sigma structures 
phi sigma schema sigma arbitrary sigma structures 
sigma structures equivalence class sigma schema consistent inconsistent 
proof def 
isomorphism bijective function props 
true def 
phi consistent set formulas phi consistent set formulas consistent renaming preserves proofs def 
phi consistent set formulas phi identifiers phi phi def 
phi consistent set formulas phi consistent set formulas 
similar way prove 
definition logic structure replacement system 
tuple logic structure replacement system respect structure schema sigma schema consistent initial structure 
sigma set structure replacement rules 
definition generated language system 
definition language defined follows af af transitive reflexive closure af af sigma theta af af definition states language system consists structures may generated applying rules arbitrary number times initial structure 
distinction terminal nonterminal structures preceding subsections 
generated structure definition element generated language 
summary definitions propositions preceding subsections constitute framework formal treatment various forms graph replacement systems special cases logic structure replacement systems 
approaches intention high level replacement hlr systems structured graph grammars 
hlr systems belong algebraic branch graph grammars cf 
section chapter 
provide general framework definition new kinds replacement systems construction categories certain properties 
hlr systems restricted manipulation graphs relational structures systems 
structured graph grammars hand restricted data model directed acyclic graphs 
attempt combine properties algebraic graph grammars cf 
chapter volume algorithmic node replacement graph grammars cf 
chapter volume single framework 
hlr systems structured graph grammars introduce notion schema support modeling derived properties constraints 
systems attempt close gap manipulation data structures means rules description data structures means logic knowledge representation languages 
way disciplines graph grammar theory mathematical logic theory profit ffl structure graph replacement rules comfortable defined mechanism manipulating knowledge bases deductive data bases cf 
ffl logic techniques proposed efficiently maintaining derived properties data structures solving constraint systems proving correctness data manipulations cf 

currently systems restricted sequential graph replacement 
subject extend approach parallel application rules supported 
furthermore questions considered detail restrictions sufficient guarantee pushouts 
characterize useful subset rules consistency constraints effective proof procedure exists derivable structures schema consistent problem see chapter volume 
develop general procedure transforms set structure replacement rule postconditions weakest preconditions 
problems related transforming global consistency constraints equivalent postconditions individual rewrite rules techniques proposed 
having procedure translates postconditions corresponding preconditions problem reducible question new preconditions derivable original set preconditions rule set guaranteed integrity constraints input rule 
programmed structure replacement systems far able define sets schema consistent structure replacement rules structure languages generated applying rules order structure axiom 
sufficient theoretical point view structure replacement systems specification purposes additional means necessary regulating application rules 
quite different proposals controlling application rules may literature instance ffl apply rules long appropriate long possible order standard semantics replacement systems 
ffl introduce rule priorities prefer applicable rules higher priorities case overlapping matches 
ffl regular expressions complex programs define permissible derivation sequences 
ffl draw control flow graphs interpret graphical representations rule controlling programs 
idea programs controlling application rules imperative control structures popular superior rule regulation approaches respect expressiveness 
pages ffl study required properties graph replacement programs general control structures structure replacement rules subsection ffl introduce minimal set control structures form called basic control flow bcf operators discuss intended semantics informal level subsection ffl appropriate semantic domain bcf operators developed fixpoint theorem subsection ffl define semantics bcf expressions recursion semantics programmed logic structure replacement systems means fixpoint theorem subsection ffl summarize main properties systems discuss possible extensions subsection 
requirements rule controlling programs called programmed graph grammars suggested years ago 
nowadays fundamental concept graph grammar specification languages pagg progres 
experiences languages predecessors specification software engineering tools showed control structures possess properties boolean nature application programmed graph transformation succeeds fails application single graph replacement rule depending success failure execution may proceed different control flow paths 
atomic character programmed sequence graph replacement steps modifies host graph intermediate replacement steps fail 
consistency preserving programmed graph replacement preserve graph consistency respect set separately defined integrity constraints 
nondeterministic behavior nondeterminism single rule replaces match left hand side preserved far possible level programmed graph transformations 
recursive definition reasons convenience expressiveness programmed graph transformations allowed call restrictions including kind recursion 
conditions difficulties replace complex graph replacement rule equivalent sequence simpler rules condition manipulation recursively defined data structures quite cumbersome 
sequel programmed graph transformations mentioned properties termed transactions 
usage term transaction underlines important properties programmed transformations atomicity consistency 
usually mentioned additional properties transactions isolation duration irrelevant long parallel programming supported backtracking may cancel effects successfully completed transactions cf 
subsection 
skip loop def undef syntax graph transactions bcf expressions basic control flow operators definition fixed set control structures structure manipulating transactions complicated contradicting requirements 
theoretical point view set offered control structures small possible allowed combine restrictions 
practical point view control structures needed easy cover frequently occurring control flow patterns application may directed number context sensitive rules 
quite natural distinguish basic control flow operators sequel termed bcf operators underlying theory recursively defined transactions complex higher level programming mechanisms 
starting formal definition basic control flow operators able define meaning large class programming mechanisms translating equivalent bcf expressions cf 
section 
contains definition bcf expressions transactions functional abstractions bcf expressions 
distinguishes basic actions ffl skip represents successful identity operator relates graph ffl loop succeeds terminates structure represents crashing forever looping computations calls simple rules graph transactions unary binary bcf operators ffl def action succeeds applied structure applied produces defined result returns ffl undef action succeeds applied structure applied terminates failure returns ffl action sequential composition applies structure suitable result application ffl action represents nondeterministic choice application ffl action returns intersection results requires equality testing operator graphs 
note operators suggested intentionally similar proposed dijkstra especially nelson essential difference due boolean nature basic structure replacement rules complex transactions forced distinguish side effect free boolean expressions state modifying actions 
consequence complex guarded commands form cond body body longer necessary may replaced expressions def cond body def cond body def cond tests applicability single rule transaction modifying input structure 
furthermore bcf expressions offer possibilities combining binary relations structures semantic domain structure manipulating transactions 
operators intersection union concatenation 
missing difference operator supported reasons subrelation subrelation 
consequence nonmonotonic difference operator excluded order able come sound definition recursively defined transactions cf 
subsection 
having motivated reasons selection unary binary bcf operators prepared discuss intricacies intended semantics 
problem comes definition meaning apply suitable result 
assume application transformation structure possible results named respectively 
furthermore assume graph transformation applied fails applied succeeds 
case may select suitable result application means need knowledge states ongoing transformation process order able discard possible results single transformation step cause failure transformation process 
quite obvious realization oriented definition kind nondeterminism requires kind depth search semantics backtracking dead ends 
problem comes definition expressions loops forever applied certain structure defined set possible results 
having depth search semantics mind forced define outcome expression nonterminating computation defined result produced means kind nondeterminism going define erratic backtracking able discard nondeterministic selections lead defined failures basic actions structure replacement rules selections cause nonterminating computations 
example uses nondeterministic depth search backtracking 
defines transaction tries complete person database person nodes married 
uses rule marry example assumes existence rule 
rule selects marks single person database existent fails 
example person database manipulating transaction 
marry def marry marry undef 
transaction initiates calls rule marry long rule applicable 
terminates successfully persons married 
database state reached second branch executable 
case transaction aborts database modifications 
note execution marry requires backtracking general case 
consider instance application marry database 
transformation process may start linus marry harry sally 
problem partner hannah left 
backtracking starts couple harry sally married harry hannah 
preliminary definitions informal transactions named bcf expressions define intended semantics semantic function domain bcf expressions range extended binary relations structures 
order able deal recursion nondeterminism presence atomic sequence operator follow lines new form fixpoint theorem give axiomatic definition called nondeterministic commands 
proposition fixpoint theorem 
monotonic function partially ordered set chain join ff ordinal ff defined inductively ff fi fi ff fi fixpoint ff ordinal ff 
proof see appendix 
able apply fixpoint theorem bcf expressions appropriate partially ordered semantic domain needed definition semantic domain 
consistent class structures schema sigma semantic domain transactions defined power set binary relations theta semantics transaction binary relation structures symbol second component represents potentially nonterminating computations 
word potential includes computations partially unknown effects computations may abort loop forever 
relation theta instance maps structure represents computation completely unknown outcomes 
order able apply fixpoint theory recursively defined transactions construct suitable partial order semantic domain suitable means practical point view relation defined element means better approximation transaction suitable means theoretical point view proof chain join sequence elements ff ff ordinal ff equal ff fi ordinals ff fi upper element definition partial order semantic domain 
underlying structure schema suitable partial order defined follows 
sequence operator chain continuous nd argument 
original version fixpoint theorem proved case 
please note 
equivalent definition partial order 
easier handle 
relation definition approximates input related set outputs related symbol potentially greater set outputs eventually dropping 
obvious partial order proof chains joins condition lemma chains joins 
ff ff ordinal chain ordinals holds ff ff fi join chain defined follows ff ff ff ff ff proof show element greater element chain element property ff ff ff 
ff fi ff ff fi ff ff ff ff ff 
ff ff ff ff fixpoint semantics transactions prepared define semantic function syntactic domain bcf expressions transactions semantic domain inductively definition bcf expressions transactions semantics 
defined definition sigma set structure replacement rules 
denotes set bcf expressions set transactions context free syntax displayed semantic function rp defined follows structures rp skip 
rp loop 
rp production sigma execution may terminate 
rp def rp rp 
rp undef rp rp 
rp rp rp rp 
rp rp rp 
rp rp rp rp rp 
definitions straightforward exception treatment operators def undef 
expressions def undef loop forever returns single defined result loops forever 
furthermore def may return input returns defined result may loop forever 
terminates failure terminates failure 
hand undef returns input fails fails defined result may loop forever 
undef stricter def respect treatment looping computations expression def may return defined result may loop forever 
practical point view distinction may justified follows ffl know computes defined result evaluating possible execution paths successful path 
ffl hand answering question fails possible execution paths account running nonterminating execution branch strict version def useful 
longer independent definition undef may follows definition semantics transactions calls transactions bcf expressions postponed precondition previously introduced fixpoint theorem checked 
definition strict version def operator 
strict version def operator may defined follows structures definition rp def rp undef undef rp undef rp undef rp rp rp 
order able proposition treatment recursive transactions prove bcf expressions correspond monotonic functionals 
bcf expression contains instance applied transaction identifiers interpreted functional signature rp provided semantics rp rp semantics definition denoted follows rp rp 
way able define semantics bcf expressions transactions bottom absence recursion 
having recursively defined transaction marry def marry marry undef looking element fixpoint equation rp def marry marry undef holds 
proposition provides fixpoint able show bcf operators define monotonic functionals complex bcf expressions lemma bcf operators monotonic functionals 
rp definition sigma rp rp implies rp rp 
rp rp 
rp rp rp rp 
rp rp rp rp 
rp def rp def 
rp undef rp undef 
proof ad rp rp rp rp rp rp rp 
rp rp rp rp rp rp rp rp rp rp 
ad rp rp rp rp rp rp rp rp rp rp 
rp rp rp rp rp rp rp rp rp rp rp 
ad rp rp rp rp rp rp rp 
rp rp rp rp rp rp rp rp rp rp 
ad rp rp rp rp rp rp rp 
rp rp rp rp rp rp rp rp rp rp 
ad rp def rp def rp rp rp rp def rp def 
rp rp def rp rp rp def rp rp rp def 
ad rp undef rp undef rp rp rp rp undef rp undef 
rp implies rp undef rp undef rp undef 
proof able define fixpoint semantics set transactions may call arbitrary manner 
please note superficial point view treatment transactions requires complex semantic domain corresponding semantic function 
function takes binary relations input computed approximations transactions produces better approximations form binary relations output 
applying fixpoint theory extended setting semantics th transaction defined th component common fixpoint extension semantic domain including new partial chain continuous order straightforward 
omitted implicitly corollary corollary fixpoint semantics transactions 
ft set transactions contain bodies en calls transactions calls structure replacement rules sigma en sigma corresponding class schema consistent structures propositions hold define new semantic function unique fixpoints 
approximations fixpoints may constructed follows theta theta takes approximations transactions input yields new approximation applying definition expression proof ad follows directly proposition lemmata 
ad relations approximations 
follows directly proposition lemmata kl fg theta 
note corollary interesting theoretical point view guaranteeing existence fixpoints recursively defined set transactions 
additionally provides straightforward algorithm computes results terminating transactions approximates results potentially nonterminating transactions 
equipped fixpoint computing function able define programmed structure replacement systems generated structure languages 
definition programmed structure replacement systems 
assuming vocabulary definition programmed structure replacement system respect signature sigma sigma structure schema 
schema consistent initial structure 
sigma set structure replacement rules 
set recursively defined transactions 
main transaction 
definition language programmed structure replacement system 
def 
language defined follows 
definition states language programmed structure replacement system consists structures may generated applying main transaction initial structure transaction calls structure replacement rules transactions turn contain calls rules transactions 
case systems define data types structure graph languages useful replace single main transaction set exported transactions step module concept structure replacement systems 
case language possibly generated structures definable result new main transaction skip returns input applies transactions arbitrary number times 
summary definitions propositions preceding subsections constitute framework defining comparing various approaches support programming graph replacement rules 
framework provides formal definition partial nondeterministic recursive structure replacement programs termed transactions 
added new symbol domain structures represents unknown results nonterminating computations 
able overcome difficulties operators test success failure subprograms presence recursion cf 
detailed discussion problems 
operators prerequisite writing programs try execute subprogram fails try execute 
note presents axiomatic semantics definition nondeterministic partial commands gave initial impulse symbol selection adequate fixpoint theorem version 
prefer denotational axiomatic approach structure replacement rules play role simple assignments 
definition intended semantics binary relations definition unsolved problem general case push postconditions rules obtaining corresponding weakest preconditions cf 
list unsolved question subsection 
furthermore note bcf expressions related approaches discussed section deal sequential replacement processes 
called programmed derivation relational structures approach exception 
approach supports parallel programming graph replacement rules provides fixpoint semantics recursive programs program traces 
unfortunately constructs def undef available testing complex structure transformation returns defined result 
parallel composition testing applicability valuable means require completely different formal treatments 
parallel composition hand interleaving semantics excludes definition program semantics function semantics subprograms 
testing success failure subprograms hand enforces special symbol nonterminating computations usage complicated partial order resulting semantic domain 
investigations necessary check combination approaches possible 
emphasize results section valid rule approach rules define binary relations domain objects 
having developed common framework different rule regulation mechanisms offers opportunity combine different regulation mechanisms needed graph grammar specification languages 
idea closely related grace initiative attempt combine different graph models graph replacement approaches rule regulation mechanisms single graph centered language environment 
far see systems act common underlying formalism envisaged types graphs rules control structures 
grace complete specification built defining composing called transformation units 
transformation unit may different style graph replacement cf 
section overview currently existing variants graph replacement approaches 
defines binary relation certain classes graphs 
operators combine single transformation units complex transformation units similar bcf operators 
systems define semantics transformation units composition operators 
way round transformation units grace provide kind module concept structuring systems reusable subcomponents defined interfaces 
context sensitive graph replacement systems overview general framework definition specific graph data models especially definition various types programmed graph replacement systems 
framework reviewing number different context sensitive graph replacement approaches cf 
table subsection 
expression oriented algorithmic graph replacement approach exp afore mentioned successors pagg progres 
approaches compared families algebraic graph replacement systems dpo spo main subject chapter volume 
selected called delta grammars similar pagg claim member algebraic branch 
obvious different graph data models directed graphs hypergraphs may seen relational structures certain properties 
furthermore graph replacement systems data model directed graph labeled nodes edges 
differences ffl approach exp support node attributes ffl algebraic dpo spo approaches handle edges identifiable objects easily extendible ary relations form hyperedges ffl second approach knows concept label hierarchy general node edge labels match specific node edge labels 
omit detailed discussion graph data model differences sequel simply assume class graphs running example section 
furthermore omit subject graph schema definitions covered subsection 
bewildering long list characteristics remains distinguish selected graph replacement approaches ffl subsection discusses matches rules host graph may restricted deletion nodes edges handled 
ffl subsection presents completely different ways specify embedding created nodes remaining part host graph 
ffl subsection shows additional application conditions rules needed usually defined 
ffl subsection sketches attributes handled graph replacement systems 
ffl subsection summarizes discussion table column approach row identified graph replacement system characteristics 
woman man man man woman child child example context sensitive graph replacement rule context sensitive graph replacement rules simplest case graph replacement rule consists graphs labeled directed edges labeled identifier carrying nodes 
graphs left right hand side 
idea application graph replacement rule find match left hand side host graph remove match host graph construct isomorphic copy rule right hand side add copy remaining rest host graph 
procedure leads host graph new subgraph isolated old rest host graph 
additional mechanism needed called embedding transformation establishing connections new old nodes 
straight forward realization embedding transformation identification nodes rule left righthand side called gluing approach 
matches nodes deleted recreated application replacement rules 
simply preserved edges unmatched nodes host graph 
graph replacement rule instance nodes part left right hand side matches host graph may connections arbitrary number unmatched nodes host graph 
kind graph replacement questions arise ffl shall allow match rule nonisomorphic image left hand side nodes left hand side share node host graph 
ffl edges matched node matched edge left hand side node deleted rule 
reviewed graph replacement formalisms different answers questions 
exp approach called path expressions know concept preserved nodes solves embedding problem different manner cf 
subsection 
matched nodes deleted permitting nonisomorphic images sense 
furthermore unmatched edges matched nodes allowed matched subgraph equivalent induced subgraph 
consequence rule applicable man node parents connected wife edge 
edges matched nodes unmatched nodes handled different way 
deleted matched nodes 
graph replacement rules able delete nodes connections preserved unmatched nodes 
pagg programmed attributed graph grammars approach knows concept preserved nodes requires matches isomorphic images left hand sides exception embedding part replacement rules explained subsection 
differences exp induced subgraph condition dropped unmatched edges deleted node handled way deleted 
graph replacement rule delete man node independent fact node parent nodes sources targets additional edges 
subsection contains example notation pagg rules 
default behavior progres graph replacement rules pagg 
explicit folding statements allow left hand sides share matches long nodes part right hand side 
called identification condition prevents situations rule preserve delete node time 
rule instance nodes may match node host graph host graph contains man node child edge loop 
approach delta rules form delta similar progres respect supported form graph replacement cf 
subsection 
isomorphic matching default explicit folding statements may overwrite default 
deletion preservation conflicts possible probably prohibited identification condition 
dpo double pushout approach restrictive concerning treatment unmatched edges nodes deleted 
called dangling edge condition forbids application rules case 
may delete man nodes outgoing wife child edges 
furthermore nonisomorphic matching identification condition default 
dangling edge identification condition summarized name gluing condition 
spo single pushout approach permits kind nonisomorphic images left hand sides drops dangling edge condition 
consequence edges deleted nodes deleted deletion preservation conflicts resolved favor deletion 
mention discussed approaches allow certain extent single node edge graph replacement rule matches node edge host graph 
exp dpo spo extensions allow parallel application single rule rules various matches host graph 
furthermore dpo spo variants developed socalled amalgamated graph replacement rules 
amalgamated rule represents infinite family simple rules general case 
useful manipulating different occurrences single pattern host graph simultaneously 
simplified forms amalgamation mainly specifying embedding transformations graphical notation part pagg progres delta 
example summarizes discussion possible interpretations simple graph replacement rules example translation structure replacement rule 
translation graph replacement rule structure replacement rule accordance informal discussion form left hand side translation man node woman node man edge child edge child plus optional extension deletion dangling edges set identifiers child 
right hand side translation woman node man 
dangling edge preventing post condition translation ar edge 
node node 
optional identification pre condition fv optional induced subgraph pre condition edge case useless isomorphic match pre condition fv 
embedding rules path expressions style graph replacement introduced previous subsection chance define rule ffl deletes man node unknown number emanating child edges ffl creates deleted child edge node new grandchild edges parents scenario requires complex embedding transformation rules 
exp early graph replacement approach famous powerful embedding rules 
rules components ffl left hand side node identifier match host graph potentially connected arbitrary number unmatched context nodes 
ffl called path expression describing path host graph selected left hand side node match relevant set unmatched context nodes 
ffl node right hand side copy host graph source target new embedding edge 
ffl part determines label direction new edge 
simplest case path expression form label label requires traversal single edge direction instance grandchild child embedding rule completes rule creates child edge context node new grandchild edges general case path expressions constructed building concatenations unions iterations simple path expressions 
may defining derived relationships ancestor brother 
reader may imagine path expression embedding rules powerful concept difficult understand 
pagg delta rely graphical embedding rules progres offers textual embedding rules exp graphical embedding rules delta 
graphical embedding rules common mark certain nodes edges graph replacement rules allowed match arbitrary number nodes edges host graph 
progres nodes depicted double dashed rectangles cf 
subsection 
underlying formalism structure replacement rules supports concept means set identifiers example translation embedding rules 
translation pagg progres delta graph replacement rules equivalent structure replacement rule example fact extended follows woman man man man woman child child man woman man woman man edge label child edge label grandchild woman man man woman man edge label child edge label grandchild woman man woman man grandchild grandchild grandchild grandchild progres notation child child pagg notation delta notation notations graph replacement rules graphical embedding rules woman node man edge child edge child 
woman node man edge grandchild edge grandchild edge grandchild edge grandchild node set identifiers match zero nodes host graph cf 
def 

pagg notation graph replacement rule read follows nodes edges left section deleted incident edges application rewrite rule 
nodes edges right section created anew rewrite rule applied 
nodes edges lower section denote preserved part host graph remains unmodified 
nodes edges upper section denote graphical embedding rules 
preserved general case single match maximal number matches host graph 
meaning section crossing edges obvious lower upper part wear additional label gamma 
label gamma denotes edges application rule longer 
label denotes edges need application rule 
delta grammar rules similar pagg rewrite rules cf 

area left delta corresponds left section area right delta right section inner area delta upper lower part preserved nodes multiple matches single matches identified having additional label 
purpose region delta explained subsection 
positive negative application conditions quite case graph replacement step may take place additional nodes edges certain graph pattern 
progres delta spo know concept positive negative context conditions 
general version additional application conditions suggested extension spo approach 
arbitrarily large context graphs may attached left hand side graph replacement rule existence may required prohibited 
delta concept negative context graphs 
depicted bottom line delta 
positive context conditions correspond preserved part graph rewrite rule inner region delta 
way spo delta able require existence absence context subgraphs priori known size 
lower part shows example delta replacement rule previously persons 
preconditions require nodes wife edge 
require furthermore nodes wife edge connections nodes 
contains upper part corresponding progres definition additional restriction nodes may ancestors 
example negative context condition size prohibited subgraph path host graph fixed rule 
requirement expressible spo woman man woman man wife wife wife wife negative context woman man man woman progres notation delta notation man woman wife child wife wife wife progres delta rules negative context conditions delta 
progres reuses concept path expressions originally defining context embedding rules overcome restriction 
way control structures path expressions conditional branching transitive closure conditional iteration available defining complex application conditions 
translation positive negative application context conditions preconditions structure rewrite rules obvious 
example subsection presents complete translation subgraph test similar context conditions 
furthermore translation complex path expressions transitive closure operators part example subsection 
normal derived attributes discussed means graph replacement rules allow manipulation nodes edges data important internal structure specifiers point view 
cases additional data manipulated strings numbers handled atomic items 
graph replacement approaches exp support definition attributes attached nodes single item set atomic items values 
order able write read attributes textual extensions graph replacement rules offered 
similar node class person derived self 
self 
progres definition derived attribute language progres example subsection 
graph replacement rule marry tests modifies income attribute matched person node 
general different categories attributes may distinguished distinguished attribute tree grammars ffl intrinsic attributes mentioned income attribute represent extensionally defined properties nodes graph 
change value explicit assignments graph replacement rules 
ffl derived attributes hand represent intentionally defined node properties 
defined means directed equations attributes nodes context node 
progres supports categories attributes pure form 
normal attributes tested manipulated graph replacement rules cf 
example subsection 
derived attribute value definitions part graph schema construction 
path expressions welcome specifying complex context attributes foreign nodes directed equations 
shows example attribute specification 
number ancestors distinct person sum number ancestors mother plus existent number ancestors father plus existent 
case nonexistence mother father evaluation subexpression fails subexpression returned 
example translation derived attribute definition 
attribute equation may translated follows formula part structure schema definition cf 
definition node person attr edge child type man attr edge child type man edge child type woman attr edge child type woman 
man woman man body income child child attribute manipulating graph replacement rule pagg specifying derived attributes graphs keeping consistent difficult underlying structure arbitrary directed graph tree 
attempt traverse edge evaluation directed equation may fail due nonexistence edge 
hand case path expression attribute equation returns set nodes single node 
additional means necessary determining alternatives case partially defined subexpression aggregating sets attribute values single useful attribute value 
detailed discussion various incremental attribute evaluation strategies reader referred 
presentation outside scope contribution 
developers pagg attribute graph grammar approach adopted idea attribute tree grammars attach directed attribute equations structure replacement rules productions defining separately 
consequence derived attribute definitions value assignments extensionally defined attributes handled syntactic construct cf 
able distinguish case attribute income gets value computed attribute values preserves value foreign attributes change values case attribute change value soon referenced foreign attributes change values 
furthermore attaching equations rules drawback equations different related rules insert modify delete instance certain type nodes may inconsistent 
real problem long graph replacement systems generating graph languages tends serious disadvantage soon graph replacement systems specifying data types 
attachment attribute equations graph replacement rules advantages 
longer necessary define separate graph schema equations nodes rules path expressions purpose easier read derivation history graph may influence selection active attribute equations 
mention exp dpo delta know concept derived attributes spo variant defined supports derived data definition certain extent 
summary table summarizes presentation different graph replacement approaches previous subsections 
condensed version preceding discussion readable explanations 
construction solve problems ffl available input delta sufficient answering questions verifying delta belongs family algebraic graph replacement systems 
column contains question marks 
ffl headlines spo dpo represent single proposal family related formalisms evolved time 
difficult give definite answers cases 
ffl classification embedding rules traditionally fine grained classification subsection 
additional embedding rows added readers familiar graph replacement systems 
algorithmic approaches algebraic approaches exp pagg progres delta dpo spo graph model node label hierarchy edge label hierarchy edge identifiers hyperedges derived edges path expr 
normal node attributes mixture special label derived node attributes separate schema definition graph replacement rules matching homo isomorphic isomorphic isomorphic homo iso 
homo iso 
induced subgraph induced sub 
subgraph subgraph subgraph subgraph subgraph multiple matches host graph simultaneously parallel mixed 
embedding graphs set nodes rules set nodes rules rule amalgamation rule amalgamation appl 
conditions implicit conditions induced sub 
gluing cond 
explicit cond 
attribute cond 
positive context graph 
fix nodes paths context graph 
fix graph 
fix graph 
fix negative context nodes paths context graph 
fix graph 
fix delete del preserve conflict impossible impossible forbidden forbidden forbidden delete handling dangling context edges automatic deletion automatic deletion automatic deletion automatic deletion forbidden gluing cond 
automatic deletion embedding transformation textual graphical text paths graphical text graphic graphical simulation amalgamation possible simulation amalgamation possible referenced context context 
fix context fix change orientation change label test context label test context edges preserved nodes different treatment ident 
labeled nodes table comparison algorithmic algebraic graph replacement approaches programmed graph replacement systems overview section introduced basic means defining comparing various forms sequential programmed graph replacement systems 
topic section review previously proposals programmed grammars specific programmed graph grammars replacement systems 
review divided subsections ffl subsection introduces number programmed grammar formalisms preserve declarative rule oriented character replacement systems 
exists single meta algorithm applies rules long appropriate takes additional information rule preferences required application sequences account 
ffl subsection presents number related programmed graph grammar approaches belong application oriented branch algorithmic graph grammars 
approaches common adapt control structures imperative programming languages purpose controlling graph replacement rules 
ffl subsection deals programmed graph grammars belong family algorithmic graph grammar approaches control flow diagrams textually written control structures regulating graph replacement processes 
single example complex person database transformation discuss advantages disadvantages approaches 
extended version transaction marry example 
assumes existence introduced basic rules marry cf 
example new rule 
fails person nodes married deletes nondeterministically selected person node 
example complex database transformation 
marry def marry marry undef 
main marry undef marry main 
transaction main tries marry singles database terminates successfully possible 
subtransaction marry fails undef marry succeeds 
consequence removes person node database main calls 
process stops soon singles married deleted 
declarative rule regulation mechanisms subsection presents types programmed graph grammars preserve rule oriented declarative character rule systems 
offer limited support determining order rule applications main match replace loop pure rule systems 
main loop terminates rules applicable 
result definition element specified language long terminals nonterminals distinguished 
having user defined termination conditions hand means distinguish failing successful derivation sequences difficult simulate behavior transactions main marry additional nonterminals application conditions new rules necessary guarantee instance fire possible derivation sequences marry failed 
define running example formalisms definition graph grammars rule priorities 
graph grammar rule priorities axiom plus set graph replacement rules partial order fp fp transaction defines semantics rule priorities skip undef undef undef gamma definition rule priorities just approximation usual semantics 
definition execution lower priority rule blocked soon higher priority rule executable case rules modify disjoint parts graph 
unfortunately liberal definition rule priorities capabilities bcf expressions 
principle problem approach enlarging nonempty set matches graph rule may reduce set allowed matches graph replacement rule lower priority 
kind nonmonotonic behavior able deal 
quite different rule regulation mechanism studied called matrix graph grammars 
simply sets sequences rules semantics set natural numbers including zero 
definition matrix graph grammars 
matrix graph grammar axiom plus set graph replacement rule sequences form transaction defines semantics set sequences skip undef undef rule sequences selected executed similar simple rules grammar 
rules sequence applied possible skipped 
formalism studied called programmed graph grammars borderline purely declarative regulation mechanisms programmed approaches sense subsection 
allow definition atomic sequences rule applications support branching flow control depending success failure single rules 
support functional abstraction allow branching flow control depending success failure complex graph replacement processes 
definition programmed graph grammars 
programmed graph grammar set graph replacement rules sense axiom plus set triples components defined follows rule applied 
fp set rules may applied successful replacement step 
fp set rules may applied application fails 
transaction defines semantics type grammar undef translation fp fp translation translation 
programming imperative control structures previously introduced regulation mechanisms adequate defining complex graph transformation processes running example 
new mechanisms people started graph grammars specifying complex data structures software engineering environments cad systems 
cases quite natural control structures imperative programming languages adapt new purpose regulating graph replacement processes 
formal definitions kind programmed graph grammars vague 
furthermore didn attempts resolve conflict nondeterministically working graph replacement rules deterministically working control structures 
typical representatives category may 
direct predecessors new generation programmed graph grammars reviewed subsection 
start definition simplified version control structures language progres cf 

definition control structures progres 
control structures progres form semantics fail undef skip failing command 
nondeterministic branch statement executes 
def def undef deterministic branch statement applies applicable testing applicability cause graph modifications 
atom deterministic atomic sequence fails fails 
nondeterministic sequence operator executes arbitrary order 
def call def undef conditional iteration executes long executable 
syntax simplified readability reasons additionally available abbreviations occurring control flow patterns def discussed 
example transformation main progres 
control structure definition able produce quite readable version running example 
marry def marry 
main def marry marry atom main 
definition programmed attributed graph grammars pagg imperative control structures may definition control structures pagg 
control structures pagg form semantics def def undef undef 
try undef 
repeat call undef 
control structures compromise required boolean nature atomic character graph transactions favor efficiently working implementation 
read follows ffl construct requires sequential application followed definition complicated execution fails fail 
failing subexpression skipped execution process continues 
ffl construct try semantics progres control structure 
may arguments general case 
ffl construct repeat applies long possible succeeds applied 
may argument repeat just shorthand sequence repeat 
nonatomic sequence statement offering means equivalent previously introduced bcf operators def undef cf 
def 
reduces expressiveness pagg significantly advantage implementation needs backtracking undoing performed graph modifications 
able provide reader semantically equivalent pagg version transformation original definition uses try repeat 
main 
try approximate intended meaning far possible order highlight deficiencies pagg control structures example transformation main pagg 
marry repeat marry fail person exists 
main repeat try marry 
problem example means test graph replacement rule applicable executing 
replacing needed test fail sequence unmark useless rewrite rules cause failure sequence simply skipped 
emphasise discussed deficiencies pagg control structure relevant long specified graph transformation processes deterministic confluent 
case pagg control structures efficiently executable meet exactly needs users 
developed graph grammar programming approach properties pagg discussed detail 
offers merely combination progres restriction boolean conditions nonatomic pagg 
programming control flow graphs previous subsections typical exponents various programmed graph replacement approaches 
cases denotational semantics definitions sketched translating control structures bcf expressions defined fixpoint semantics definition 
discussed approaches bcf expressions readable form language progres fulfill list requirements subsection 
bcf expressions low level text representation compromise visual nature programming graph replacement rules 
obvious solution problem replace text oriented control structures kind control flow graphs 
variants control flow graphs fulfill needed properties control structures ffl control flow graphs allowed call properly support functional abstraction defined 
ffl control flow graphs introduced node may call control flow graph branching depending success failure subgraph calls supported 
start call marry call undef def def main def call main def start call call marry undef def def marry def start call undef def control flow graph version transformation main ffl presents variant control flow graphs mentioned deficiencies semantics definition 
sequel show bcf expressions may define fixpoint semantics control flow graphs 
control flow graphs properties previously defined transactions boolean character 
furthermore expressive power bcf expressions strict def operator version intersection operator 
contains example control flow graph additional subgraphs 
main properties ffl vertex subgraph reachable unique start vertex path unique vertex 
ffl execution sub graph begins start vertex ends vertex 
ffl normal vertices graph basic action inscription nop call simple rewrite rule start vertex control flow subgraph 
ffl execution vertex succeeds fails execution start nop vertices succeeds effects 
ffl successful execution vertex follow outgoing def edges multiple def edges reflect nondeterministic computations absence def edges partially defined computations 
ffl failing execution vertex follow outgoing undef edges multiple undef edges reflect nondeterministic computations absence undef edges partially defined computations 
detailed explanation kind control flow graphs including operational semantics definition reader referred 
denotational semantics definition may provided translating control flow graph equivalent set transactions bcf expressions 
vertex control flow graph translated transaction calls transactions reflecting outgoing def undef edges definition graph replacement systems control flow graphs 
semantics set control flow sub graphs set graph replacement rules set control flow vertices defined follows vertex control flow graphs inscription call start nop outgoing def edges vertices outgoing undef edges vertices translated undef undef fail undef skip inscription call skip 
vertex inscription translated transaction skip terminating execution control flow subgraph successfully 
please note definition control flow graphs identical definition programmed graph grammars 
essential difference control flow graphs know concept functional abstraction 
calls complex may treated way calls simple rules 
way arbitrary forms recursion supported complex conditions may defined cause failure successful termination derivation sub processes 
proposition equivalence bcf expressions control flow graphs 
set transactions bcf expressions bodies intersection operator strict def operator version original def version cf 
definition definition may translated equivalent set control flow graphs definition vice versa 
sequ 
atomic control flow 
control flow success failure test recursive calls paradigm notation simple rule priorities declarative text oriented matrix grammars atomic sequence decl imperative text oriented programmed grammars nonatomic sequence rules tail recursion decl imperative text oriented prog 
attributed graph grammars nonatomic sequence rules imperative text oriented prog 
graph rewriting systems nonatomic sequence imperative text oriented progres bcf expressions imperative text oriented prog 
deriv 
rel 
structures parallel 
text oriented control flow diagrams imperative graphical control flow diagrams rules imperative graphical new control flow diagrams imperative graphical table comparison various rule regulation mechanisms proof translation control flow graphs bcf expressions part definition 
direction follows directly definition 
rule sequences nondeterministic branching operator skip calls subprograms directly supported 
undef may simulated vertex inscription outgoing def edge single outgoing undef edge vertex represents computation step expression undef expression form def equivalent undef undef cf 
definition 
construction proof able translate example control flow diagram bcf expressions control flow diagrams bcf expressions 
please note results translation processes complex structured inputs 
example translations sense proposition followed number semantic preserving simplification steps cf 
def 
summary section various approaches sequential programming graph replacement rules defined compared translating equivalent bcf expressions 
results discussion summarized table column headlines referring required rule programming properties subsection 
table shows proposed regulation mechanisms deficiencies 
progres def 
control flow graphs def 
difficulties guaranteeing properties simple graph replacement steps complex transformation processes 
worse single approach existent supports parallel programming testing success failure complex time 
subject find possible combine trace fixpoint semantics parallel graph replacement systems fixpoint semantics approach definition operators def undef see subsection 
acknowledgments author grateful manfred nagl gregor engels claus lewerentz bernhard westfechtel andreas winter albert members project stimulating discussions pro graph replacement systems invaluable efforts pave way 
furthermore anonymous referees chapter helpful comments previous version andre producing version table comparison graph replacement approaches alexander bell excellent framemaker compiling job 

claus ehrig rozenberg eds proc 
int 
workshop graph grammars application computer science biology lncs springer verlag 
ehrig nagl rozenberg eds proc 
nd int 
workshop graph grammars application computer science lncs springer verlag 
ehrig nagl rozenberg rosenfeld eds proc 
rd int 
workshop graph grammars application computer science lncs springer verlag 
ehrig 
kreowski rozenberg eds proc 
th int 
workshop graph grammars application computer science lncs springer verlag 
ausiello atzeni eds proc 
int 
conf 
database theory lncs springer verlag 
blostein fahmy practical graph rewriting tr computing information science queen university canada 
boehm 
habel amalgamation graph transformations applications synchronization ehrig floyd nivat thatcher eds mathematical foundations software development lncs springer verlag 
bry martens integrity verification knowledge bases 
bunke und dissertation tr 
universitat erlangen germany 
bunke attributed programmed graph grammars application schematic diagram interpretation ieee pattern analysis machine intelligence vol 
ieee computer society press 
courcelle graphs relational structures algebraic logical approach 
dijkstra guarded commands formal derivation programs communications acm acm press 
regulated rewriting formal language theory eatcs springer verlag 
dorr efficient graph rewriting implementation ph thesis fu berlin lncs springer verlag 
corradini heckel compositional approach structuring refinement typed graph grammars appears corradini montanari eds proc 
joint workshop graph rewriting computation electronic notes theoretical computer science entcs amsterdam elsevier science publ 

ehrig habel 
kreowski parisi presicce graph grammars high level replacement systems 
ehrig algebraic theory graph grammars survey 
ehrig lowe tutorial algebraic approach graph grammars double single pushouts tr tu berlin germany 
engels lewerentz nagl schafer schurr building integrated software development environments part tool specification acm transactions software engineering methodology vol 
acm press 
engels lewerentz schafer graph grammar engineering software specification method 
engels als einer dissertation universitat vdi verlag 
fahmy blostein graph grammar programming style recognition music notation machine vision applications vol 

gallaire logic data bases plenum press 
gunther graph grammars design cad systems 
attribute graph grammars graphics 
der ifb springer verlag 
van constraint satisfaction logic programming mit press 
habel heckel taentzer graph grammars negative application conditions appears 
heckel muller taentzer wagner attributed graph transformations controlled application rules appears 
hudson incremental attribute evaluation algorithm lazy evaluation graphs tr arizona 
kaplan loyall specifying concurrent languages systems delta grammars 
algebraic transformation equationally defined graph structures tr tu berlin germany 

kreowski rozenberg structured graph grammars part ii tr university bremen fb mathematik informatik germany 

kreowski graph grammars software specification programming praise grace eds proc 
colloquium graph transformation application computer science technical report universitat de les 
schurr westfechtel graph oriented database system software engineering applications information systems vol 
pergamon press 
lewerentz konzepte und dissertation rwth aachen ifb springer verlag 
lowe wagner algebraic framework transformation attributed graphs 
lowe algebraic approach graph transformation single pushout derivations ph thesis tr fachbereich informatik tu berlin germany 
manna mathematical theory computation mcgraw hill usa 
mylopoulos borgida jarke telos language representing knowledge information systems acm transactions information systems vol 
acm press 
minker perspectives deductive databases journal logic programming elsevier science publ 

programmed derivations relational structures 
nagl vieweg verlag 
nagl tutorial bibliographical survey graph grammars 
nagl graph technology applied software project 
nagl characterization project 
sh naqvi extensions closed world assumption databases 
sh naqvi negation failure order queries proc 
th sigact sigmod symp 
principles database systems acm press 
nelson generalization dijkstra calculus acm transactions programming languages systems vol 
acm press 
ed algorithmen proc 
nd workshop graphtheoretic concepts computer science wg applied computer science verlag 
nagl schurr specification environment graph grammars 
sh naqvi sh 
tsur data knowledge bases ieee computer society press 
rosenfeld web grammars proc 
int 
joint conf 
artificial intelligence washington 
rozenberg salomaa eds book springer verlag 
rozenberg ed special issue graph transformation systems fundamenta informaticae vol ios press 
rekers schurr parsing algorithm context sensitive graph grammars tr university leiden netherlands 
order logic databases acm transaction database systems vol 
acm press 
uber eine fur programmiersprachen und verteilte dissertation tr 
universitat erlangen 
schmidt eds proc 
int 
workshop graph theoretic concepts computer science wg lncs springer verlag 
schneider chomsky systeme fur tr 
universitat erlangen germany 
schneider ehrig eds proc 
int 
workshop graph transformations computer science lncs springer verlag 
schneider conceptual database descriptions graph grammars 
schurr progres language graph grammars 
schurr mit formale anwendungen und dissertation rwth aachen deutscher 
schurr logic structure rewriting systems 
schurr logic programmed structure rewriting systems appears 
schutte und von fur durch dissertation koblenz express edition 
sleep plasmeijer van eekelen eds term graph rewriting theory practice john wiley sons 
schurr non deterministic control structures graph rewriting systems 
taentzer beyer amalgamated graph transformations specifying agg algebraic graph grammar system 
voronkov ed logic programming lncs springer verlag 
weber eds proc 
int 
conf 
systems development factories press 
westfechtel einer dissertation rwth aachen springer verlag 
eine fur dissertation rwth aachen deutscher universit 
