type inference constrained types martin odersky university south australia school computer information science levels south australia martin sulzmann yale university department computer science new haven ct martin university edinburgh laboratory foundations computer science lfcs eh jz edinburgh keywords constrained types subtypes record types constraint systems constraint solving type inference principal types ideal semantics general framework hm type systems constraints 
framework stays tradition hindley milner type system 
type system instances sound standard untyped compositional semantics 
give generic type inference algorithm hm sufficient conditions type inference compute principal type term 
discuss instances framework deal polymorphic records equational theories subtypes 

type systems extend hindley milner mil system constraints 
examples record systems em wan overloading jon kae np cho bm subtyping cch aw est smi 
extensions hindley milner constraints increasingly popular program analysis tj 
type systems different constraint domains largely alike aspects 
general framework hm hindley milner style type systems constraints analogous clp framework constraint logic programming jm 
particular type systems obtained instantiating parameter specific constraint system 
hindley milner system obtained instantiating standard herbrand constraint system 
supported darpa 
fl year john wiley sons large treatment constraints type systems syntactic constraints regarded sets formulas specific form 
hand constraint programming generally uses semantic definition constraint systems constraint system cylindric algebra additional properties hmt sar 
cylindric algebras define projection operator ff binds subset variables ff constraint 
usual case constraints boolean algebras projection corresponds existential quantification 
lead constraint programming treat constraint system cylindric algebra projection operator 
projection useful purposes reasons projection allows formulate logically pleasing pragmatically useful rule intro quantifier intro gamma ff fv fv gamma ff gamma ff constraints type variables type context gamma type scheme discuss proposals quantifier show approach improves existing ones 
second projection important source opportunities simplifying constraints jon pot est 
framework simplifying means changing syntactic representation constraint changing denotation 
example subtyping constraint fi ff fi fi fl theory practice object systems vol 
volume number optional issue number year ccc information safely simplified ff fl denotation constraints 
projection operator constraints different restricts variable fi 
main strengths hindley milner system type soundness result existence type inference algorithm computes principal types 
hm stays tradition hindley milner type system 
type systems hm sound standard untyped compositional semantics provided underlying constraint system sound 
result summarized slogan typed programs go wrong 
key ideas sufficient conditions constraint domain principal types property carries hm 
conditions fairly simple natural 
constraint systems meeting conditions generic type inference algorithm yield principal type term 
type inference algorithm explained treating typing problem constraint 
generally constraint system needs rich express constraint problems generated type derivations 
hand admit possibility constraints left hand side turnstile type schemes come restricted set call solved forms 
task type inference split typing problem substitution residual constraint solved form 
call constraint normalization 
require normalization yields best solution solution 
ensures type inference algorithm computes principal types 
generalizes milner results systems non standard constraints possible experiment new constraint domains having invent type inference algorithm having repeat tedious proofs soundness completeness type inference 
object oriented languages 
object oriented languages record calculi type systems supporting notion subtyping 
cardelli wegner cw gave early survey general research directions 
reynolds rey mitchell mit foundational papers develop basic concepts constraints subtyping 
palsberg pal gave efficient inference algorithm calculus objects 
subtyping orthogonal notion parametric polymorphism supported hindley milner system 
natural approach type system supports notions add subtype constraints types aw est 
systems expressed instances hm system recursive records extension 
encodings object oriented languages forgo subtyping calculi extensible records overloading em wan bm 
systems regarded instances framework 
demonstrate ohori system example 
outline 
rest structured follows section discusses previous approaches type systems constraints 
section gives characterization constraint systems 
section presents framework hm hindley milner style type systems constraints 
section presents ideal semantics type systems framework type soundness theorem derived 
section establishes conditions constraint system type inference feasible principal types theorem holds 
section describes instance framework type system polymorphic records 
section concludes 

related hindley milner style type systems constrained types number instances 
type systems extend type judgments gamma oe original hindley milner system constraint hypothesis left side turnstile written gamma oe 
furthermore extend type schemes ff hindley milner system constraint component write ff express constraint restricts types legally substituted bound variables ff 
type systems essentially rule eliminating quantifiers write follows elim gamma ff ff gamma ff rule refinement corresponding rule hindley milner system 
says instantiating type scheme ff valid instances instances ff satisfy constraint part type scheme 
agreement proper technique eliminating quantifiers type schemes remarkable disagreement proper way introduce 
shows different rules proposed literature 
edited rules somewhat uniform style attempted compensate considerable variations detail published type sys theory practice object systems year satisfiability check jon gamma ff fv fv gamma gamma ff intro weak satisfiability check aw gamma ff fv fv gamma gamma ff intro strong satisfiability check smi gamma ff ff fv fv gamma gamma ff intro duplication est gamma ff fv fv gamma gamma ff intro fig 

versions quantifier rule tems 
details matter particular type system order concentrate general principles 
discuss schemes turn 
qualified types jon jones uses general framework type qualification rule equivalent rule intro 
constraint shifted assumption left type scheme right turnstile checked traded constraint satisfiable 
lead programs typed parts unsatisfiable constraints 
give example assume constraints subtyping constraints type system classes subtyping relation determined programmer declarations 
assume parametrized class list ff subtype type comparable list ff comparable declared follows type comparable ff ff assume value nil type ff true list ff represents empty list 
consider nonsensical program 
example 
ff list ff comparable ff list ff list ff true nil haskell style notation adding type annotations illustration purposes 
rule intro program typed expect constraint function type scheme solution function type list ff subtype comparable bool 
ideal semantics types mps represents universal quantification intersection type empty intersection equal type universe including error element wrong 
program sound application provide valid instantiation constraint 
constraint unsatisfiable application possible 
essence jones treats constraints proof obligations fulfilled presenting evidence instantiation site 
scheme clearly inspired haskell implementation overloading dictionary passing 
runs problems wants compute value constrained type instantiation sites slight variation example 
example 
ff list ff comparable ff bool nil true jones excludes code grounds type ambiguous unclear generalize restriction arbitrary constraint systems 
possible integrate jones approach hm framework giving semantic basis independent dictionary passing 
essential idea restrict constraint systems projections solved constraints trivial ff constraints appear left hand side turnstile type variables ff fv 
case rule intro simplifies intro 
note trivial projections correspond haskell open world assumption says range possible instance types overloaded operation fixed advance 
rule constraint free variables solution 
formalization principle bottom type possible define compositional semantics haskell style overloading 
theory practice object systems year type system aiken wimmers aw moving constraint left hand side turnstile right hand side allowed constraint satisfiable solution 
previous examples typable rule intro 
example typable 
example 
fi fi int ff list ff comparable fi bool nil true constraint list ff comparable fi solution fi list ff 
rule intro generalize type ff list ff comparable fi bool hand substitute actual parameter true definition get example typable system intro 
system intro enjoy property subject reduction says term typable reduction instances typable 
version rule intro 
aiken wimmers require weak form satisfiability traded constraints smith requires strong smi 
rule intro traded constraint solvable instantiation quantified variables ff 
previous examples untypable system 
intro rule overly restrictive depending constraint system 
instance assume comparable precisely instances int comparable int char comparable char consider program example 
fi fi int typing definition smith system requires solution constraint comparable type 
solutions exist int char best type improves solutions 
system hopkins objects group est differs previous systems rule intro constraint copied moved restrictions copying take place 
scheme examples rejected fourth accepted corresponds fairly intuition 
time rule intro strange contains copies constraint type variables ff bound free 
hopkins objects group uses slightly different system generalization coupled rule constraints undergoes variable renaming 
hm seen proper logical formulation algorithmically formulated type system 
furthermore dealing exclusively subtype constraints admit arbitrary constraint systems 

constraint systems characterization constraint systems lines henkin hmt saraswat sar 
building standard notions simple cylindric constraint systems introduce term constraint systems constraint systems behaved notion substitution 
constraint systems parameter allows framework customized different application domains 
start definition simple constraint system 
definition 
simple constraint system structure omega omega non empty set tokens primitive constraints 
refer constraints predicates 
relation omega theta omega entailment relation omega set finite subsets omega call omega constraint set simply constraint 
constraint system omega satisfy constraints omega extend relation omega theta omega iff furthermore define iff term abbreviation true pg represents true element 
give example generate simple constraint system order language example 
order language countably infinite set variables var take omega arbitrary subset open var formulas entailment relation respect class delta structures 
fp pn iff structure delta valuation realizes realizes pn omega theory practice object systems year simple constraint system 
extend simple constraint system projection operator ff 
leads cylindric constraint system 
definition 
cylindric constraint system structure cs omega var ff ff varg ffl omega simple constraint system ffl var infinite set variables ffl variable ff var ff omega omega operation satisfying ff implies ff ff ff ff ff ff ff fi fi ff 
simplicity omit set notation constraints connect constraints union operator 
generally enclose simple constraints opening closing braces 
instance abbreviation fpg fqg 
assume binds tighter ff 
instance ff stands ff 
write iff example 
token set omega consist subclass var formulas closed existential quantification finite conjunctions 
operator ff interpreted function maps finite set fp pn tokens set tokens ff pn easy see conditions satisfied 
projection operator ff allows bind variables ff constraint 
means project away information 
constraint system models boolean algebra projection corresponds existential quantification 
projection operator define free variables fv satisfiability constraint definition 
constraint 
fv fff ff cg 
definition 
constraint 
satisfiable iff fv lemma states important property projection operator 
projection constraint influence satisfiability constraint 
lemma 
constraint 
satisfiable iff ff satisfiable 
final step modeling constraint systems extension cylindric constraint systems term constraint systems 
assume term algebra signature sigma var cons 
var set variables cons set type constructors containing function constructor arity 
examples multi sorted algebra terms constructors partitioned sorts 
sort types ranged definition 
substitution oe idempotent mapping set variables var term algebra term sigma identity finite set variables 
definition 
term constraint system cs omega var ff ff varg term algebra cylindric constraint system predicates form holds ffl pair types equality predicate cs satisfies ff ff ff fi fi ff ff fi fi fl ff fl ff fi ff ff fi arbitrary term context ffl predicate ff ff ff ff fv 
conditions conditions imposed cylindric constraint system diagonal elements usually taken foundation constraint programming languages 
says equals substituted equals effect leibniz principle 
states congruence 
connects syntactic operation substitution predicates semantic concepts projection equality 
substitution extended arbitrary constraints canonical way ff pn ff ff basic lemmas hold term constraint systems 
lemma renaming 
constraint fi new type variable 
ff fi fi ff lemma normal form 
constraint oe ff substitution 
oec ff ff ff 
lemma essential substitutions idempotent mappings 
case substitution oe ensures type variables ff appears types lemma substitution 
constraints oe substitution 
oec oed 
theory practice object systems year discuss instances term constraint systems 
section elaborate example term constraint system deals records 
example 
term algebra herbrand omega var ff ff varg minimal term constraint system omega contains primitive constraints form types equality herbrand syntactic free algebra 
entailment constraints checked matching algorithm 
example entail 
satisfiability checked order unification 
refined example term constraint system deals physical dimension types style kennedy ken example 
sorted term algebra consisting dimensions types 
dimensions ff prod types ff dim dimension constructor delta corresponds inverse dimension prod delta delta product dimensions 
dimension constants unit measure meters seconds 
dimension constructors mentioned ones 
type type variable dimension function type 
dim term constraint system obeys additional conditions specify dimension types form abelian group 
dim prod ff fi prod fi ff dim prod ff prod fi fl prod prod ff fi fl dim prod ff ff dim prod ff ff final example consider extension term constraint system subtyping 
example 
subtype constraint system term algebra term constraint system subtype predicate pair types satisfies conditions 
sub ff ff ff ff ff ff sub ff ff ff ff ff ff ff ff sub ff ff ff ff ff ff sc subtype constraint system primitive types int float record types form fl records modeled admitting constructors form fl term algebra 
assume record fields ordered respect ordering relation field labels 
additional types obey rules 
sub int float sub fl fl sub fl fl 
hm framework section describes general extension hm hindley milner type system term constraint system term algebra development similar original presentation dm 
syntactic domains 
values expressions types ff type schemes oe ff oe consider sorted algebras straightforward extend treatment multi sorted algebras 
formulation generalizes dm respects 
types members arbitrary term algebra constructors 
definition stands additional type constructors vary depending specific hm instance 
seen examples instantiated dimension record types 
second type schemes ff oe include constraint component restricts types substituted type variable ff 
require constraint satisfiable 
hand language terms exactly dm 
assume language constructs type constraints expressible predefined values names types recorded initial type environment 
typing rules system 
typing judgments form gamma oe satisfiable constraint gamma type environment oe type scheme 
typing judgment valid derived application typing rules constraint component satisfiable 
quite restrict set constraints appear type schemes left hand side turnstile called solved forms 
set theory practice object systems year var gamma oe oe gamma sub gamma gamma abs gamma gamma app gamma gamma gamma gamma oe gamma oe gamma intro gamma ff fv fv gamma ff gamma ff elim gamma ff ff gamma ff fig 

logical type system solved forms denoted subset satisfiable constraints interesting rules intro rule elim rule 
rule intro quantify type variables 
vector notation type variables type schemes 
term ff abbreviation ff true ff ff abbreviation ff ff standard treatments hindley milner style systems subsumption rule sub allows derive term type derive term type type subsumes type subsumption relation determined constraint system assumed satisfy standard axioms partial ordering plus contra variance rule refl ff ff ff ff ff ff asym ff ff ff ff ff ff trans ff ff ff ff ff ff contra ff ff ff ff ff ff ff ff conditions choice arbitrary 
example 
hindley milner system instance type system framework 
take herbrand constraint system algebra types take set solved forms set consisting true represented empty token set 
take syntactic type equality 
type schemes arising proof trees valid typing judgments form ff fg oe equate hindley milner type schemes ff oe 
subsumption rule trivial tautology states judgment derived derived 
easy convince oneself judgment gamma oe derivable hindley milner fg gamma oe derivable hm herbrand 
example 
constraint system dim set solved forms set consisting true subsumption equality relation dim 
kennedy system recovered simply adding primitives initial type environment gamma deal dimensions 
assume div dim dim dim prod contained gamma basic connectives treated analogously 
example 
subtype constraint system sc subsumption relation equal subtyping relation 
set solved forms satisfiable constraints sc 
record fl program add datatype theory practice object systems year constructor fl field label add function fl initial type environment gamma corresponds record creation second record selection 
basic primitive functions defined analogously 
resulting system related subtyping approach hopkins object group est 
main difference logical rules quantifier elimination syntactic approach quantifier coupled quantifier elimination coupled variable 
important difference system includes recursive types 
recursive types scope deal system full generality 
deal variant system recursive types system recursive records instances explicitly declared classes similar datatype constructions functional languages class interface system java gls 
applications non trivial constraint systems include overloading jon kae np cho bm record calculi em wan static program analysis techniques binding time analysis 
extended example section record calculus similar ohori 

semantics give type soundness theorem ideal semantics mps hm type systems 
show type system sound provided underlying constraint system sound subsumption predicate satisfies coherence property 
say constraint system sound satisfiable constraint monotype solution 
coherence constraint system means type subsumes type denotation ideal model subset denotation definition 
monotype type fv 
range monotypes 
definition 
constraint system sound type variables ff constraints ff monotype ff ff soundness proof ideal semantics types direct extension semantics mil 
meaning term value cpo contains continuous functions error element usually pronounced wrong 
depending concrete type system contain elements 
require values additional type constructors representable cpo solution equation 
arity set values additional type constructor meaning function terms original semantics hindley milner terms 
assume language constructs type constraints expressible predefined values names types recorded initial type environment 
show meaning typed program different wrong 
step give meaning types 
mil types denote ideals non empty downward closed limit closed subsets meaning function delta maps closed types type schemes ideals 
function types type schemes defined follows ff fk true gamma ff ff ff cg position define coherence subsumption predicate 
definition 
constraint system coherent monotypes 
lemma 
oe closed type scheme 
oe ideal 
proof 
straightforward induction structure oe 
theory practice object systems year furthermore conclude sound constraint system error element contained closed type scheme 
lemma 
sound constraint system closed type scheme oe 
oe 
proof 
true monotypes consider type scheme oe ff 
oe closed get ff remember constraints appear typing judgments derivation need satisfiable 
sound monotype vector ff denotation oe empty intersection 
contained denotation monotype ff contained oe 
definition 
variable environment models closed typing environment gamma written gamma oe gamma oe 
theorem type soundness 
gamma oe valid typing judgment hm sound coherent constraint system 
oe substitution oe gamma oeoe closed oec 
variable environment oe gamma 
oeoe oeoe proof 
follows immediately lemma 
prove structural induction typing derivations 
interesting cases 
case var step derivation gamma oe oe gamma oeoe oe gamma 
oe gamma oeoe 
case intro step derivation gamma ff fv fv gamma ff gamma ff oe oe gamma oe ff closed oe ff 
furthermore assume name clashes oe ff 
arbitrary vector monotypes ff ff oed sound vector oe ff ffi oe 
ff fv oe oec oe expands oec ff ff oed 
assumption constraint valid 
furthermore oe gamma oe closed 
induction hypothesis oe 
arbitrary ff oed ff oe ff oed oe ff case sub step derivation gamma gamma know substitution oe oe gamma oe closed oec 
follows oe oe 
case oe contains free variables 
extend oe substitution oe oe closed 
oe extension oe get oe gamma closed oe applying induction hypothesis get oe 
coherent know oe oe 
oe closed type oe extends oe get oe oe yields oe 
type soundness theorem simplified top level programs 
corollary find milner slogan types programs go wrong carries sound constraint extensions 
corollary 
sound coherent constraint system 
true gamma oe valid closed typing judgment hm 
gamma proof 
immediate theorem 
find hm herbrand hm dim hm sc satisfy requirements 
applications sound respect provided semantics 

type inference turn problem type inference hm type systems 
follow standard approach translating typing problem constraint problem 
typing problem solvable constraint problem solvable 
solution constraint problem constraint solved form solution exists typing problem solvable 
instance consider function application inferred type inferred type solve typing problem need solve constraint ff fresh type variable ff corresponding unspecified result type application moment take closer look specific typing situations 
hm sc subsumption predicate corresponds subtype predicate 
set defined set satisfiable constraints sc 
solving constraint problem means simply checking constraint satisfiable 
example considered hindley milner system instance hm herbrand hm theory practice object systems year framework 
subsumption predicate corresponds type equality predicate set consisting just true 
case solving constraint problem requires just satisfiability test 
additionally discard equality problems achieved herbrand unification 
observe type inference consists phases constraint generation constraint solving 
constraint generation hm type systems 
simply generate constraints form 
kind constraint solving differ different typing situations 
depending structure set solved forms apply different methods obtain constraint solved form 
requirement put constraints satisfiable 
solving constraint problem requires satisfiability test 
constraint systems structure set arbitrary complex 
solving constraint problems involve sophisticated methods satisfiability test herbrand unification 
refer solving constraint problems constraint normalization normalization short 
section give formal treatment normalization constraint system give generic type inference algorithm hm type systems state main results type inference sound sufficient conditions complete 
normalization section study normalization constraints 
giving axiomatic description normalization introduce preliminary definitions 
preliminaries oe ju restriction substitution oe domain oe ju oe oe ju 
substitutions oe write oe iff oe write oe oe iff oe ffi oe 
write oe oe oe oe 
omit set note general substitution smaller element pre order choice reverses usual convention treatments unification lmm stay line semantic notion type instances 
partial order identifying substitutions equal variable renaming equivalently defining oe iff oe oe 
follows lmm complete lower semi lattice upper bounds exist correspond unifications greatest lower bounds correspond anti unifications 
consider task normalization 
generally typing problem translated constraint term constraint system substitution 
refer pair constraint problem 
normalization means computation normal form constraint problem 
definition 
term constraint system term algebra set solved constraints constraints oe substitutions 
normal form oe iff oe 
principal normal forms oe principal normal form represents best solution constraint problem 
example consider constraint system herbrand 
principal normal form corresponds general unifier normal form corresponds unifier constraint problem 
lemma states principal normal forms unique variable renaming 
lemma uniqueness 
principal normal forms oe 
variable renaming oe oe oe ffi 
identify normal forms equivalent variable renaming 
define defined function normalize constraint problems oe normal forms follows normalize oe principal normal form oe fail extend property having principal normal form constraint systems 
definition 
constraint system term algebra set solved constraints constraint system principal constraint property constraint substitution oe oe normal form oe principal normal form 
say hm type system principal constraint property principal constraint property 
section discuss detail type system ohori style records satisfies principal constraint property 
example belongs class constraint systems constraint solving involves form unification 
examples constraint systems kind herbrand dim 
apply similar techniques introduced section show herbrand dim satisfy principal constraint property 
situation different constraint system sc 
set solved forms consists theory practice object systems year var ff gamma fi new normalize fi ff gamma gamma abs gamma ff ff new gamma ff 
app gamma gamma ff ff new normalize gamma gamma ff gamma oe gen gamma gamma oe normalize gamma gamma fig 

type inference satisfiable constraints 
constraint problem oe distinguish cases 
oed unsatisfiable oe normal form 
assume oed satisfiable oed id principal normal form oe 
normal form oe oe 
holds oe oe oe follows immediately oed id principal 
conclude constraint system sc satisfies principal constraint property normalize function defined follows normalize oe oec id oec satisfiable fail normalization function computable satisfiability sc decidable 
follows easily adapting techniques developed ts 
type inference algorithm connect principal constraint property constraint system principal types property type system 
gives generic type inference algorithm computes principal types constraint system satisfies principal constraint property 
algorithm formulated deduction system clauses form gamma type environment gamma expression input values substitution constraint type output values 
syntactic construct expressions clause 
deduction rules interpreted operationally logic program constructs bottom derivation clauses 
var rule assume unqualified type represented true avoids separate case rule unqualified types 
note var function normalize specified subsection 
deduction rules yield algorithm normalize computable 
assume dealing computable normalization functions 
type inference algorithm straightforward extension algorithm see dm 
algorithm consists basic components constraint generation constraint normalization generalization unbound type variables 
components original algorithm extended deal constraints 
discussed constraint generation normalization 
generalization procedure algorithm left underspecified require satisfies gen gamma oe ff ff oe constraint gamma type environment oe type scheme ff fv oe fv gamma fv ff 
generalization splits constraint parts 
generalized variables free parts part ends constraint generalized type scheme 
note requirement fulfilled practice object systems year ing true 
depending actual constraint system exist better strategies keep constraint generalized type scheme smaller 
type inference algorithm interleaves constraint generation normalization 
inference rule combines constraint problems premises performs normalization step 
means perform strict normalization type inference 
essence need perform normalization right rule constraint type scheme needs normal form 
corresponds lazy normalization 
example lazy formulation type inference hindley milner type system wan 
lemma states views equivalent 
perform normalization order obtain result 
lemma 
constraints substitutions oe oe normalize oe oe normalize normalize oe normalize oe term oe oe stands oe oe 
main results state main results concisely extend subsumption predicate type schemes 
subsumption type schemes defined deduction system clauses form oe oe state type scheme oe general type scheme oe constraint deduction system defined follows 
sub oe oe ff tv oe tv ff oe ff oe ff oe oe ff ff oe oe result triple type inference algorithm forms typing configuration oe consists constraint type scheme oe substitution oe oe consistent respect gamma 
substitution oe consistent respect type scheme oe ff assume name clashes ff 
extends naturally type environments 
typing configurations oe oe say oe general oe iff oe fv gamma oe oe oe oe situation write oe oe 
lemma 
type environment gamma term gamma typing configuration 
furthermore typing configuration represents valid typing term type environment 
theorem soundness inference 
term type environment gamma 
gamma gamma sketch proofs soundness completeness type inference appendix 
detailed discussion refer sul 
discuss completeness type inference hm type systems 
general require hm type system fulfill principal constraint property achieve complete type inference 
turns sufficient 
examples non regular equational theories unification unitary means general unifiers algorithm infer principal types 
equational theory regular implies fv fv 
say constraint system regular underlying equational theory regular 
example non regular theory dimension constraint system dim 
find prod fv prod fdg fv 
section observed dim satisfies principal constraint property 
fails infer principal types dimension type system hm dim 
observation due kennedy 
section give concrete example see algorithm fails 
state completeness theorem large classes hm type systems 
consider class constraint systems set solved forms contains satisfiable constraints denote set constraint systems additionally satisfy principal constraint property 
second class put restrictions set solved forms 
assume constraints simplified form means non trivial equality problems resolved 
constraint simplified form implies 
denote set regular constraint systems satisfy principal constraint property solved form simplified form 
example member constraint system sc 
constraint systems herbrand record constraint system introduced section theory practice object systems year examples members dim dim non regular 
obtain completeness result type inference assume hm type system belongs furthermore consider typing judgments gamma oe type environment constraint left hand side turnstile realizable type instance 
type environment gamma realizable constraint oe gamma oe completeness result 
informally speaking want 
derivation oe gamma oe type inference algorithm report constraint small type general oe theorem completeness inference 
oe gamma oe typing judgment oe gamma realizable gamma substitution constraint type gen gamma oe oe oe oe completeness theorem simplified top level programs corollary states type inference algorithm computes principal types 
corollary 
true gamma oe closed typing judgment gamma realizable true 
oe gamma substitution oe constraint gen oe gamma true oe oe oe case hm type systems formulated completeness result general terms necessary 
section observed normalization sc corresponds satisfiability test 
observation generalized constraint systems class conclude type inference returns identity substitution 
type inference consists accumulating constraints checking constraints satisfiable 
holds var case 
rename bound type variables constraint check satisfiability renamed constraint 
constraint satisfiable return renamed constraint 
renaming substitution equivalent identity substitution free type variables type environment 
find substitutions introduced base case normalization procedure 
type inference returns identity substitution 
substitution identity substitution completeness theorem class case hm type systems put stronger conditions set solved constraints 
set simplified form 
normalization involves computation residual substitution 
restriction regular theories case class important establish complete type inference see example due kennedy ken 
dimension type system hm dim define initial type environment follows gamma fkg div dim prod dim pair theta kg basic dimensions pair pairing operator div primitive operation dimensions 
consider expression div pair kg want type type environment gamma 
subexpression div type type environment gamma dim prod gamma dim prod div dim possible quantify type variables derive type div type environment gamma dim prod div dim prod dim prod simply instantiated prod prod 
kennedy calls problem polymorphism 
types div general third type generalizes 
algorithm fails infer principal type expression type environment gamma 
interesting point computes principal types dimension types contains satisfiable constraints dim 
dim belongs class completeness result 
reason unification problems explicit 
unification involved type inference 
type inference performs satisfiability test 
problem polymorphism comes play normalization involves unification non regular theory 

polymorphic records ideas ohori give instance hm system deals polymorphic theory practice object systems year records 
ohori system abbreviated type variables function types record types denoted fl element enumerable set record labels 
assume ordering relation field labels 
record fields ordered respect ordering relation 
fixed ordering record fields apply herbrand unification solving equality constraints records 
type quantification kinded type scheme ff ff oe type variable ff ranges kind kind form hl comprises records contain fields types constraint left hand side typing judgment ohori uses kind assignment considered function assigns type variable ff kind writes ff disjoint extension new type variable ff kind example program typed example 
ff fi ff hl fii ff int fi bool eq haskell style notation type scheme annotations added illustration purposes 
program assumes function eq ff ff ff bool initial type environment 
type system translate hm framework 
add initial type environment gamma primitive constructs deal record formation selection update 
ordered sequence record labels postulate ary parameterized data type record type fl represented simplicity keep record type notation synonym datatype notation 
record datatype initial environment datatype constructor represents record formation fl field label add initial type environment gamma functions ff fi ff hl fii ff fi modify ff fi ff hl fii ff fi ff function corresponds record selection second record update 
kinded quantification modeled primitive constraints form type kind 
technically means add set omega primitive constraints primitive predicate arity 
define rec smallest term constraint system satisfies additional rules rec fl hl distinct rec hl hl rec hl rec ff ff true ff fv note conditions rule recursive records type algebra recursive types 
hand allow recursive constraints type variables rec 
instance constraint ff hl ff ffi formed 
constraint satisfiable appear solved form 
ruled conditions rec rec overloading field labels 
set solved forms hm rec consists satisfiable constraints form fg ff hl ff take empty token set representation true 
furthermore require constraints simplified form imply 
instance ff hl fii ff hl fl fli simplified form excluded 
type system hm rec subsumption modeled 
example annotated program example re formulated hm rec example 
ff fi ff hl fii ff int fi ff hl fii fi bool eq hm rec quantify innermost type variable fi leaving just ff quantified toplevel function possible ff kind depends fi 
question arises hm rec permissive type system specifically examples function polymorphically 
answer 
instance satisfy constraint theory practice object systems year fi ff hl fii 
ff field entry label body 
general observe hm rec type exactly programs types precise hm rec 
theorem full faithful 
program typable typable hm rec vice versa 
type inference consider type inference hm rec 
rec regular constraint system obtain type inference principal types provided fulfills principal constraint property 
show principal constraint property rec proceed steps 
show possible formulate constraint projection projection free subpart 
constraint projection free considered set contains tokens form ff 
give procedure computes principal normal form projection free constraints fails normal form exists 
show sufficient compute principal normal forms projection free constraints 
achieved lifting method 
arbitrary constraint compute principal normal form projection free part 
lift result projected part 
show lifting method sound complete 
step transform constraint projection projection free subpart 
idea rename type variables bound projection operator 
holds ff fi fi ff fi new type variable 
means name clashes projected constraints ff fi 
lift projection operators outermost level condition cylindric constraint system ff fi ff fi summarize observations lemma 
lemma 
rec 
exists projection free constraint ff step show compute principal normal forms projection free constraints 
assume projection free constraint contains primitive predicates form 
assume predicates form ff 
achieved know ff ff ff ff new type variable 
closure cl smallest constraint fulfills conditions 
cl 
ff fl cl ff hl ff hl cl 
ff hl ff hl cl cl semantic view point done cl changed syntactic representation intention building closure generate predicates hl cause inconsistencies 
predicates generate unification problems resolved 
lemma states really generated predicates 
lemma 
field label types hl hl cl iff hl 
furthermore cl iff 
apply unification herbrand terms rob resolve equality predicates cl 
obtain general unifier oe equality predicates cl 
remains check general unifier oe consistent cl 
done checking inconsistencies 
oe represents principal normal form id 
summarize observation lemma 
lemma 
projection free constraint rec substitution oe 
oe principal normal form computed procedure described normal form exists 
remains lift procedure arbitrary constraints 
state essential lemmas necessary establish lifting method 
apply lifting method state rec satisfies principal constraint property 
lemma gives procedure lift principal normal forms constraints arbitrary constraints 
states compute principal normal form constraint get principal normal form constraint ff free 
lemma 
rec oe substitution ff codom oe dom oe 
normalize oe ff normalize ff oe 
lemma states normal form constraint exists iff normal form projected constraint exists 
theory practice object systems year lemma 
substitution oe ff codom oe dom oe constraint rec 
oe normal form iff ff oe normal form 
hand prove rec satisfies principal constraint property 
proof theorem consists describing method lift computation principal normal forms projection free constraints arbitrary constraints 
theorem 
constraint system rec satisfies principal constraint property 
proof 
arbitrary constraint problem oe ff projection free 
consider cases 
assume oe normal form 
lemma know holds iff oe normal form 
checked normalization procedure projection free constraints 
assume oe normal form 
apply lemma find normal form oe exists 
assumption know normalize oe 
means oe principal normal form compute principal normal form 
lemma lift principal normal form projection free constraint problem obtain principal normal form oe 
conclude rec satisfies principal constraint property 

general framework hindley milner style type systems constraints 
innovative aspect framework new formulation quantifier rule avoids problems previous 
formulation requires presence projection operator constraints 
requirement main motivation progress syntactic notion constraints sets formulas semantic notion constraints cylindric algebras 
cylindric algebras projection operator operator need syntactic form 
projection readily available syntactic constraint systems type system literature 
simple way introduce marking variables projected 
fact marking usually reconstructed type judgment simply mark variables appear free final type schemes final type environment projected 
projection provides important opportunity constraint simplification legal eliminate variables constraints long variables projected elimination change constraint denotation 
simplification context subtypes studied pottier pot hopkins object group ts 
plan investigate simplification techniques fit hm framework 
framework includes subsumption rule subsumption relation constraint system adapted wide variety type system instances 
instance classical hindley milner system falls subsumption syntactic equality free algebra wand emy style records em wan dimension types ken fall richer notion equality subsumption standard object calculi est fall identifying subtyping subsumption relations 
give type soundness result sound coherent hm type systems standard untyped denotational semantics 
furthermore formulated generic type inference algorithm hm type systems 
large class constraint systems state sufficient conditions type inference computes principal types 
design full language static analysis approach simply check conditions constraint system met 
case gets type inference algorithm principal type property free 
hope results open door new class program analyses program checking tailored specific application domains 
instance possible add dimension analysis existing programming language fact modular way changing semantics base language compiler 
type system framework basis language tool framework tailored specific analysis needs 
construction investigation tool framework remains topic research 
alex aiken kim marriott harald phil wadler referees valuable comments 
aw 
alexander aiken edward wimmers 
type inclusion constraints type inference 
fpca conference functional programming languages computer architecture copenhagen denmark pages new york june 
acm press 
bm 
francois bourdoncle stephan metz 
type checking higher order polymorphic multi methods 
confer theory practice object systems year ence record annual acm symposium principles programming languages paris france 
acm press january 

kim bruce angela robert van gent 
type safe polymorphic object oriented language extended 
ecoop pages 
springer verlag 
lncs 
cch 
peter canning william cook walter hill walter john mitchell 
bounded polymorphism object oriented programming 
functional programming languages computer architecture pages september 
cho 
kung chen paul hudak martin odersky 
parametric type classes 
proc 
lisp pages 
acm press june 
cw 
luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys december 

dirk fritz henglein christian mossin 
polymorphic binding time analysis polynomial time 
proceedings sas pages 
springer verlag september 
dm 
damas milner 
principal type schemes functional programs 
conference record ninth annual acm symposium principles programming languages pages 
acm acm january 
est 
smith trifonov 
sound polymorphic type inference objects 
oopsla conference proceedings volume acm sigplan notices pages 
est 
jonathan scott smith trifonov 
type inference constrained types application object oriented programming 
electronic notes theoretical computer science volume 
hmt 
henkin monk tarski 
cylindric algebra 
north holland publishing 
jm 
jaffar michael maher 
constraint logic programming survey 
journal logic programming 
jon 
mark jones 
qualified types theory practice 
phil 
thesis oxford university september 
jon 
mark jones 
simplifying improving qualified types 
fpca conference functional programming languages computer architecture 
acm press 
gls 
james gosling bill joy guy steele 
java language specification 
java series sun microsystems isbn 
kae 
stefan kaes 
type inference presence overloading subtyping recursive types 
volume pages 
proceedings acm conference lisp functional programming 
ken 
andrew kennedy 
type inference equational theories 
technical report lix rr lix ecole polytechnique palaiseau cedex france september 
lmm 
lassez maher marriott 
unification revisited 
minker editor foundations deductive databases logic programming 
morgan kauffman 
mil 
robin milner 
theory type polymorphism programming 
journal computer system sciences dec 
mit 
john mitchell 
coercion type inference 
proceedings th acm symposium principles programming languages pages 
mps 
macqueen plotkin sethi 
ideal model recursive polymorphic types 
information control 
np 
tobias nipkow christian prehofer 
type checking type classes 
conference record twentieth annual acm sigplan sigact symposium principles programming languages charleston south carolina january pages 
acm press january 

atsushi ohori 
polymorphic record calculus compilation 
acm toplas november 

martin odersky philip wadler martin 
second look overloading 
proceedings seventh international conference functional programming languages computer architecture fpca pages la jolla california june 
acm sigplan sigarch ifip wg acm press 
pal 
jens palsberg 
efficient inference object types 
information computation 
pot 
francois pottier 
simplifying subtyping constraints 
international conference functional programming pages may 
em 
emy 
typechecking records variants natural extension ml 
pages 
acm january 
em 
didier emy 
extending ml type system sorted equational theory 
research report institute national de recherche en informatique en automatique 
em 
didier emy 
typing record concatenation free 
acm editor conference record nineteenth annual acm sigplan sigact symposium principles programming languages papers symposium albuquerque new mexico january pages new york ny usa 
acm press 
rey 
john reynolds 
approaches type structure 
proceedings tapsoft caap pages 
springer verlag 
lecture notes computer science 
rob 
robinson 
machine oriented logic resolution principle 
journal association computing machinery 
sar 
vijay saraswat 
concurrent constraint programming 
logic programming series acm doctoral dissertation award series 
mit press cambridge massachusetts 
smi 
geoffrey smith 
polymorphic type inference languages overloading subtyping 
phd thesis cornell university ithaca ny august 
sul 
martin sulzmann 
proofs soundness completeness type inference hm 
research report yaleu dcs rr yale university department computer science february 
tj 
jean pierre talpin pierre jouvelot 
type effect discipline 
seventh annual ieee symposium logic computer science santa cruz california pages los alamitos california june 
ieee computer society press 
ts 
trifonov scott smith 
subtyping constrained types 
proceedings third static analysis symposium volume lncs pages 

cordelia hall kevin hammond simon peyton jones philip wadler 
type classes haskell 
acm toplas march 
wan 
mitchell wand 
simple algorithm proof type inference 
fundamenta informaticae pages 
north holland 
wan 
mitchell wand 
type inference record concatenation multiple inheritance 
proceedings ieee symposium logic computer science pages june 
theory practice object systems year appendix proof theorem soundness lemmas proven straightforward induction derivation say substitution oe consistent respect type scheme oe ff assume name clashes ff 
extends naturally type environments 
furthermore substitution oe consistent respect constraint oec lemma 
gamma oe substitution oe oe consistent respect gamma 
oec oe gamma oeoe 
lemma 
gamma oe constraint gamma oe 
restate theorem lemma 
lemma soundness type environment gamma term gamma gamma proof 
apply induction derivation consider case 
cases proven similar style 
case app situation gamma gamma ff ff new normalize gamma gamma ff apply induction hypothesis left right premise obtain gamma gamma lemma conclude gamma gamma assume identifier gamma contained 
fact normalization ensures consistent gamma 
apply lemma obtain gamma gamma know ff apply sub rule get gamma ff 
remains apply app rule find gamma ff appendix proof theorem completeness give proof sketch completeness hm type systems satisfies principal constraint property 
technical lemmas point rely fact regular 
proof similar need weaker versions technical lemmas rely regularity constraint system 
order prove completeness little 
idea introduce intermediate derivations show derivations expressive power 
introduce conventions 
generalization procedure gen takes constraint type environment gamma type returns generalized constraint type written gen gamma oe 
specialized generalization versions gen gamma returns constraint part gen gamma returns type scheme part 
introduce basic lemmas 
stated proof 
detailed discussion sul 
lemmas rely fact consider regular theories 
give proof lemma see needs regular theory 
lemma states lift entailment constraints generalized constraints 
lemma 
type context gamma constraints types substitutions oe oe oe oe fv gamma oe 
oe gen oe gamma gen gamma 
proof 
assume ff fi show ff fv oe 
assume contrary 
ff fv gamma fv codom oe rename bound variables type inference new type variables introduced 
means fl fv ff fv oe fl 
holds fl fv gamma 
assume fl fv gamma ffi fv gamma ffi fv fl 
know oe ffi oe ffi ffi need fact regular sides equation contain set free variables find ff codom oe contradiction 
get fl fv gamma fl fv 
contradiction generalized constraint 
starting assumption false find ff fv oe 
theory practice object systems year conclude follows oe oe yields oe obtain ff oe ff fv oe means get oe desired 

proof previous lemma relies fact regular 
need restricted version lemma 
achieve complete type inference lemma similar previous compares types constraints 
lemma 
type context gamma constraints types substitutions oe oe oe oe oe fv gamma oe 
oe oe oe oe gen oe gamma oe gen gamma 
lemma states lift properties constraint substitution constraint extended substitution 
lemma 
set variables constraints substitutions oe oe oe oe oe oe oe codom fv codom fv oe ffi lemma similar previous stated relation 
lemma 
set variables constraint type schemes oe oe substitutions oe oe oe oe oe oe oe oe oe oe oe codom fv codom fv oe ffi oe oe introduce intermediate derivations 
introduce derivation derivation 
rule elim new rule inst gamma oe gamma oe rules stay unchanged 
note var rule derivation idea derivation simply enforce elim steps early possible 
consider syntax directed derivation want get rid intro rule 
rule combined rule 
furthermore var inst rules combined var inst rule 
rules follows var inst gamma oe gamma oe abs gamma gamma app gamma gamma gamma sub gamma gamma gamma oe gen gamma gamma oe gamma rule implicitely require constraint solved form 
remember set constraints solved forms necessarily closed means apply rule ensure solved form 
lemmas state derivations connected 
lemmas proven straightforward induction derivation relation 
lemma equivalence type environment gamma constraint term type scheme oe 
gamma oe iff gamma oe 
lemma soundness gamma gamma show complete respect complete respect order prove strengthen assumption type environment 
due rule premises different type environments 
introduce definition 
definition 
constraint gamma gamma type environments gamma fx oe xn oe gamma fx oe xn oe gamma gamma iff oe oe ng 
theorem essential type environment gamma realizable 
remember type environment gamma realizable constraint oe gamma oe lemma completeness gamma oe gamma gamma gamma realizable oe gamma gamma oe gen gamma oe oe theory practice object systems year proof 
induction derivation due space limitation show cases 
case var know gamma oe oe gamma assumption know oe gamma oe oe oe immediately apply var inst rule done 
assume oe ff set fi ff fi ff fi fresh type variables 
apply var inst rule find gamma set oe gen gamma oe essentially renamed version oe 
find oe oe assumption gamma realizable ff leads done 
case situation gamma oe gamma oe gamma consider case oe type apply induction hypothesis left premise obtain gamma set oe gen gamma 
easy observation oe holds 
apply induction hypothesis right premise 
yields gamma oe know ensures solved form 
apply rule obtain gamma consider case oe type scheme 
application induction hypothesis left premise yields gamma oe gen gamma oe oe apply induction hypothesis right premise show gamma oe realizable know gamma oe holds 
appear free variables sufficient consider gamma assumption realizable 
know type instantiated monomorphic type shows gamma oe realizable apply induction hypothesis right find gamma oe conclude ensures solved form 
apply rule find gamma lemma 
completeness oe gamma gamma substitutions oe constraint type oe fv gamma oe oe oe proof 
induction derivation due space limitation show interesting cases 
case app situation oe gamma oe gamma oe gamma application induction hypothesis yields gamma oe fv gamma oe oe oe gamma oe fv gamma oe oe oe set find oe fv gamma oe 
want apply lemmas 
identify set lemmas fv gamma 
assume type variables introduced part inference tree appear part 
formally means codom fv fv gamma codom fv fv gamma preconditions lemmas fulfilled 
conclude oe ffi oe ffi oe ffi oe ffi set ff ff fresh type variable 
obtain oe ffi ffi ff find oe ffi ffi ff normal form 
assumption hm satisfies principal constraint property 
obtain principal normal form oe oe ffi ffi ff 
principal find oe 
oe ffi conclude oe ffi ffi ff gamma oe 
leads oe fv gamma oe 
furthermore holds oe ff oe ffi ffi ff ff oe ffi ff oe ff reasoning steps holds ff new type variable ff dom 
apply app rule find gamma gamma ff theory practice object systems year establishes induction step 
case situation oe gamma oe gen oe gamma oe gamma oe oe gamma induction hypothesis applied left part yields gamma oe fv gamma oe oe oe lemma lemma obtain oe oe oe oe oe gen gamma 
set oe oe ffi oe 
holds oe gamma oe oe gamma oe oeoe oe ffi oe oe oe ffi oe ffi gamma oe oe oe easy observation yields oe gamma oe rewrite right premise stronger type environment fact stated proof detail sul find oe gamma oe able apply induction hypothesis right part find gamma oe oe fv gamma fv oe oe oe oe deduce oe fv gamma fv oe oe holds oe ffi gamma oe oe gamma ff fv oe assume ff fv gamma know oe ff ff ff ff deduce oe ffi ff oe ff oe ff find upper bound exists 
holds oe fv gamma fv oe oe find oe fv gamma oe know oe oe oe app case conclude lemmas oe ffi oe ffi oe ffi set obtain oe ffi normal form 
assumption hm satisfies principal constraint property 
assume principal normal form oe oe ffi apply rule find gamma gamma furthermore obtain oe oe ffi oe fv gamma oe 
hand prove completeness type inference 
theorem 
oe gamma oe oe gamma realizable gamma substitutions oe constraint type oe fv gamma oe oe oe oe oe oe gen gamma 
proof 
apply lemma order get derivation apply lemma completeness 
yields oe oe gamma oe gamma oe gen oe gamma oe oe apply lemma completeness find gamma oe fv gamma oe oe oe set oe gen gamma 
remains show theory practice object systems year 
oe oe oe 
oe fact follows application lifting lemmas 
theory practice object systems year 
