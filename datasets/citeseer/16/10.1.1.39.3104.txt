logic programming real world zoltan somogyi fergus henderson thomas conway cs mu oz au department computer science university melbourne victoria australia richard keefe ok cs rmit edu au department computer science royal melbourne institute technology melbourne victoria australia objective logic programming languages years 
despite theoretical advantages conventional programming languages significant impact computer industry 
applications prolog list small industrial standards fewer exceed lines code user base exceeding people 
believe changing situation establishing logic programming major paradigm non academic world appropriate objective successor prolog 
convincing programmers switch new language languages currently requires new language meet criteria 
new language demonstrably superior user current language aspect superiority realizable economic advantage 
second new language lack qualities programmer values current language 
meet criterion new logic programming language need realize advantages promised logic programming advocates inception field 
advantages include 
ffl logic programming languages expressive high level languages allow programmers concentrate done done 
automating mundane tasks logic programming allows programmers spend time productive endeavors 
automatic memory management automatic management searches transparent interfaces relational deductive databases examples 
unique logic programming shared functional languages 
ffl logic programming languages useful formal semantics 
automatic analysis transformation logic programs simpler effective analysis transformation imperative programs 
theory allow programmers worry efficiency productive 
ffl semantics logic programming languages need prescribe order evaluation easier compiler emit parallel code 
comparison automatic parallelization code written imperative language requires extensive non local analysis program programs acceptable results require significant user intervention 
ffl logic programming languages potential debugging easier implement declarative debuggers languages 
realization potential improve productivity eliminate large fraction uncertainty schedules major projects 
realization advantages full requires pure language 
language godel allows bulk program pure requires impure features may realize advantages doubtful marketplace 
qualities language meet second criterion include 
support creation reliable programs 
software systems bigger complex difficult foresee interactions pieces system ftp src doc ic ac uk packages prolog progs db prolog gz interactions bugs 
language prevents entire classes bugs catching compile time increases programmer productivity bugs don chased reliability final product realistic testing process effective 
support creation efficient programs 
hardware getting faster quickly sizes tasks people expect computers perform increasing fast fast hardware continues carry price premium slow hardware 
factors equal fast software product beat slow software product market 
implies new language accepted implementation yields speeds competitive available implementations alternative languages 
support programming teams 
commercially important software systems big created reasonable time single programmer working 
working teams fact life 
team projects require languages support modularity information hiding programmers effectively isolate effects changes programmers spend time forward progress reacting changes parts program control 
support program maintenance 
program sizable active user base needs maintenance adapt program new environments new requirements 
successful software product higher fraction life cycle cost devoted maintenance 
programmers need maintain code written language easy programmers read understand 
significant advantage language helps maintainers preserve consistency system pointing parts system updated change 
support accessing external databases 
companies depend absolutely access databases 
companies adapt new language language provides convenient method access data held existing repositories 
proposal propose successor prolog pure language strong type system strong mode system strong determinism system support higher order programming explicit uniqueness information modern module system 
subsections justify choice features describing contributions objectives 
working lines years 
incorporated results researches language mercury 
publically available mercury implementation proves feasibility proposal 
claims subsections derived experience writing lines mercury code 
mercury rest example 
mercury means possible language design fits proposal framework 
strong type system believe new language strong type system similar type system proposed mycroft keefe turn inspired type systems functional languages hope ml basis type system haskell 
type systems idea discriminated union types support parametric polymorphism 
examples shows mercury syntax declaring new types declaring type signatures predicates 
type bintree 
empty tree bintree bintree 
pred search bintree 
mercury supports heterogeneous collections universal type univ 
values type converted type univ back back conversion checked runtime ensure type safety 
mercury supports standard type term similar operations distinction values type term www cs mu oz au zs mercury html manipulated mercury programs standard way terms type univ black boxes 
hand conversions type term require representation change conversions involving type univ 
obvious desirable extension current mercury type system support constrained genericity mechanism analogous type classes haskell 
argue favor support subtypes union types 
reliability advantages strong type systems long recognized 
major imperative languages aim support creation reliable programs strong type systems quite 
ada eiffel languages stand respect 
conceived typed extension strongly typed language turns compiler warnings refrains casts 
allowing term representations specialized strong types contribute efficient implementations 
type declarations help program readers understand intended uses predicates team programming program maintenance easier 
having type system expressive type systems sql data definition languages simplifies interfacing external database systems 
strong mode system ways view modes descriptive view prescriptive view 
descriptive view modes describe instantiation states arguments predicate execution enters predicate possibly execution leaves predicate 
prescriptive view modes assign responsibility instantiation variables various subgoals predicate definition 
descriptive modes prescriptive modes affect computation rule 
original mode declarations dec prolog take view mode declarations parlog certain extent delay declarations godel nu prolog coroutining take second view 
believe second prescriptive view useful 
programmers write predicates compute values values view modes captures important aspect programmer intention 
writing mode declarations helps readers program 
delay declarations godel similar systems say responsibility caller get arguments certain state instantiation assign responsibility predicate 
predicate takes sole responsibility instantiating way sure input requirements various calls program met means program may flounder runtime 
prefer mode system allows compiler guarantee detect situations variable consumers producers 
guarantee program flounder 
mercury predicate mode declarations 
mode declaration states predicate called arguments state instantiation success arguments state instantiation 
achieving initial instantiation state responsibility caller achieving final instantiation state responsibility predicate 
common instantiation states free ground 
mode maps ground ground mode maps free ground 
modes suffice vast majority predicates real programs see compare annotations parameters procedures ada 
mercury allows programmers define new instantiation states structures types 
required operations partially instantiated data structures predicate create list skeleton fill elements list mode declaration mode search 
states caller responsibility ground arguments responsibility predicate ground argument 
programmer job provide design level information 
compiler job reorder conjunctions containing calls predicate necessary ensure caller ground arguments sure search fact ground third argument 
compiler fails task reject program 
implies mercury implementation omit occur check losing soundness failures occur check happen presence mode error 
current mercury compiler limitation causes reject program tries fill partially instantiated data structure 
limitation removed 
mercury allows predicate mode mode having separate implementation 
cause problems code size practice 
body predicate may reordered differently mode mercury considerably support reversible predicates prolog 
strong mode system imposes discipline programmer logical variables prolog equivalent pointers terms easy mistakes 
compile time enforcement discipline effectively guarantees absence class errors corresponds uninitialized variables imperative programs 
modern imperative languages eiffel ada language described mechanisms reduce incidence class errors 
modes contribute reliability making declarative debugging focused productive user knows part answer incorrect sense look bugs producer producer turns correct predicates generated inputs 
strong mode system provides information vital efficient implementation 
mode predicate code code specialized unifications implemented simple tests assignments parameter passing streamlined indexing simpler 
aliasing strictly limited dereferencing totally avoided 
compiler complete knowledge instantiation state variable point program means unbound variables need storage initialization need trail 
knowledge allows compiler ensure safety negations runtime checks 
mercury extended subtypes mode information allow compiler insert subtype checking code minimal set places 
close long list advantages note high level optimizations availability mode information 
database systems allow storage variables strong mode system simplifies interfacing external databases 
strong determinism system divide modes predicates classes number solutions different calls 
classes exactly solution mode solution solution number solutions 
programmers provide declarations regarding aspect intended behavior predicates compiler exploit redundancy introduces detect errors program 
type mode declarations determinism declarations directly reflect intent original programmer team programming program maintenance easier 
mercury attaches determinism declarations mode declarations mode append det exactly solution mode append multi 
solution compiler analyses bodies predicates check determinism declarations correct 
problem undecidable general fast approximate conservative solutions known practice 
determinism analysis algorithm especially designed take advantage extra information provided strong type mode systems 
algorithm produces error messages 
example omits base case definition append resulting messages append append append error determinism declaration satisfied 
append declared det inferred 
append argument clause head append unification xs fail 
append append append error determinism declaration satisfied 
append declared multi inferred 
append argument clause head append unification zs fail 
messages prevent frustrating experiences prolog programmer occurs large computation intended succeed fails bug computation 
mercury determinism system pinpoint bug compile time 
capability particularly useful program maintenance 
type modified addition new function symbol modify predicates perform case analysis type 
strong determinism system trivial just compiles program fixes determinism errors reported compiler 
reports specific draw switch shape cover circle 
practice high percentage predicates deterministic semideterministic 
implementation exploit information specializing execution algorithm predicates example discarding stack frames predicates soon succeed 
interfaces database systems exploit determinism information avoid runtime checks maintenance functional dependencies 
higher order programming decades experience functional programming languages shown higher order functions extremely powerful expressive programming construct 
easy concisely express essential part algorithm abstracting away details vary different uses algorithm 
doing allow programmers avoid unnecessary dependencies improve modularity increase code reuse 
furthermore experience strongly typed logic programming languages godel turbo prolog lack higher order facilities shown languages lacking expressiveness example languages possible write generalized sort predicate 
consider support higher order programming essential feature potential successor prolog 
mercury provides support higher order predicate terms closures constructed predicate names lambda expressions currying passed predicates stored data structures 
mercury type mode determinism systems contain support shown example pred map pred list list 
mode map pred det det mode map pred 
map pred 
map pred xs ys call pred map pred xs ys 
explicit uniqueness information aspect conventional imperative languages superior existing logic programming languages provide simple efficient mechanism destructive modification data structures 
low level notion destructive update expressed directly predicate calculus 
destructive update critical algorithms data structures example arrays hash tables useless 
reason essential language aims widespread industry provide facility destructive update 
prolog provides infamous assert retract predicates cumbersome inefficient destroy declarative semantics 
alternatives blackboard variables cumbersome significant efficiency overhead destroy declarative semantics 
course logic provides perfectly adequate way expressing modifications data structures simply specify relation old state new state 
problem situations safely implemented destructively updating old state compilers information available determine safe perform optimization 
theory incremental global analysis able provide uniqueness information practice turns difficult 
weren consider global analysis guarantee case overhead comes overhead procedure call overhead checking argument number range overhead trail check cases overhead unnecessary trailing 
compiler able perform optimization analysis perfect program may 
uniqueness quite fragile small change part program affect uniqueness parts program 
reason mercury mode system provides unique modes allow programmer declare necessary uniqueness information 
mercury mode declaration unique modes checked compiler reject prove correct 
programmer sure compiler information needed perform destructive update optimization 
believe language aims compete imperative languages provide mechanism achieve effect 
modern module system current mercury module system simple copy module systems imperative languages modula 
module interface section containing declarations entities usually types predicates possibly instantiation states modes exported module implementation section containing definitions exported entities declarations definitions entities module 
types name exported definition isn represent data types 
get access entities exported module module explicitly import module module get access way entities private module obvious potential improvements arrangement 
may want module able import entities exported module 
second may useful refine current level visibility hierarchy private module public modules level hierarchy divides modules classes regarded module friends regarded clients access clients 
third desirable module name space hierarchical flat 
research opportunities large number research questions explored context language features proposed 
include 
ffl algorithms required automatic accurate inference type mode determinism information ffl best ways integrate constraint solving capabilities framework proposed 
example possible adopt approach taken 
ffl integrate exception handling framework 
sort semantics appropriate logic programming language supports exceptions 
ffl extensions mode system necessary express parallel algorithms 
best ways exploit information provided type mode determinism systems reduce overheads parallel implementation 
ffl useful idioms supported basic type mode determinism systems proposed 
extensions systems required support idioms 
effect extensions compiler checking inference algorithms efficiency generated code programmers 
ffl languages kind propose appropriate writing operating systems 
discussion justified proposed language characteristic merits striking seen requirements fully declarative logic programming language 
argument goes 
pure language requires pure way provide basis viewing operations transformations state world 
actual implementation view requires way ensure old state world referred 
explicit uniqueness information serves purpose forward execution just linear types functional framework 
arguments apply system speed swi prolog nu prolog quintus prolog sicstus prolog prolog mercury table benchmark speed ratios approaches declarative streams monads 
making sure old state referred backtracking requires determinism information course available free functional languages languages compulsory committed choice logic programming 
uniqueness determinism systems require mode information mode system turn depends type information sufficient expressiveness 
important impure features prolog reduce memory consumption program increase speed 
shows impure features required objectives 
mercury implementation exploit uniqueness information compile time garbage collection fastest logic programming language implementation large margin 
tested speed prolog systems collection standard logic programming benchmark programs 
system table gives harmonic mean speedups system achieved swi prolog 
table shows mercury double speed prolog times speed sicstus prolog times speed quintus prolog 
furthermore mercury implementation generates relatively small executables 
mercury compiler standard mercury library written intersection mercury nu prolog sicstus prolog lines source code totalling mb 
executable generated mercury default optimization mb full optimization mb statically linked 
nu prolog generates mb save file 
save file sicstus mb sicstus mb 
expect language organized lines proposed suitable industrial applications applications people prolog moment 
approach trades kinds flexibility improved reliability performance 
historically usually tradeoff applications currently standard approaches require flexibility trade away 
main example programs prolog constraint solver herbrand universe 
constraint programs moded general constraint solver determine value variable set equations cases data dependent 
prolog programs need constraint solving capabilities clp programs usually significant portions moded 
issue pure strongly typed moded languages require different programming style prolog idioms different idioms prolog 
example cases mercury enforces practices prolog merely considered style 
consider representations data structure case 
representations long recognized bad style prolog lead space leaks due choice points left programs sprinkled cuts 
mercury representations simply allowed 
example meta programming 
standard prolog meta interpreter typed moded requires impure code test user level term represents variable 
case john lloyd years demonstrated writing meta programs standard non ground representation unsound conflates user level meta level variables 
chooses ground representation standard features mercury entirely sufficient convenient creation meta programs 
different types programming require different languages matter successor prolog turn prolog remain better suited tasks small number small tasks 
case expect significant number logic programming practitioners continue prolog continue write untyped programs 
just large number functional programmers continue program lisp dialects 
hoping convert prolog programmers attainable goal 
bruynooghe 
adding redundancy obtain reliable readable prolog programs 
proceedings international logic programming conference pages marseille france september 

retire fortran 
debate 
technical report lawrence livermore national laboratory ftp sisal llnl gov pub sisal publications dir retire ps clark gregory 
parlog parallel logic programming language 
technical report doc department computing imperial college science technology london england may 
debray warren 
detection optimisation functional computations prolog 
proceedings third international conference logic programming pages london england june 
denning 
sacrificing calf flexibility reliability 
proceedings second international conference software engineering pages san francisco october 

logic programs resemble programs conventional languages 
proceedings fourth ieee symposium logic programming pages san francisco california august 
henderson 
strong modes change world 
technical report department computer science university melbourne melbourne australia october 
henderson 
purely functional operating systems 
darlington henderson turner editors functional programming applications pages 
cambridge university press 
hill lloyd 
godel programming language 
mit press 
kemp ramamohanarao 
propagating constraints recursive deductive databases 
proceedings north american conference logic programming pages cleveland ohio october 

type synthesis ground prolog 
proceedings fourth international conference logic programming pages melbourne australia june 
lloyd 
declarative error diagnosis 
new generation computing 
winsborough bruynooghe 
analysis shared data structures compile time garbage collection logic programs 
proceedings seventh international conference logic programming pages jerusalem israel june 
mycroft keefe 
polymorphic type system prolog 
artificial intelligence 
keefe 
craft prolog 
mit press 
pereira 
rational debugging logic programming 
proceedings third international conference logic programming pages london england june 
peyton jones wadler 
imperative functional programming 
proceedings twentieth conference principles programming languages january 
shapiro 
systems programming concurrent prolog 
van warren editors logic programming applications pages 
ablex 
shapiro 
algorithm program debugging 
mit press 
smolka 
making control data flow logic programs explicit 
conference record acm symposium lisp functional programming pages austin texas july 
somogyi 
stability logic programs connect don know nondeterministic logic programs outside world 
technical report department computer science university melbourne melbourne australia 
somogyi henderson conway 
determinism analysis mercury compiler 
technical report department computer science university melbourne melbourne australia august 
somogyi ramamohanarao 
backtracking algorithm stream parallel execution logic programs 
international journal parallel programming june 
strom 
typestate programming language concept enhancing software reliability 
communications acm pages january 

types 
proceedings fifth international conference symposium logic programming pages seattle washington august 
wadler 
linear types change world 
proceedings ifip tc conference programming concepts methods pages april 

