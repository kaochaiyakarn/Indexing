lock free linked lists compare swap john valois rensselaer polytechnic institute cs rpi edu lock free data structures implement concurrent objects mutual exclusion 
approach avoid performance problems due unpredictable delays processes critical sections 
universal methods known give lock free data structures data type overhead methods inefficient compared conventional techniques mutual exclusion spin locks 
give lock free data structures algorithms implementing shared singly linked list allowing concurrent traversal insertion deletion number processes 
show basic data structure building block lock free data structures 
algorithms single word compare swap synchronization primitive implement linked list directly avoiding overhead universal methods practical alternative spin locks 
concurrent object data type permits concurrent operations appear atomic 
implement concurrent object data structure shared memory set algorithms manipulate data structure atomic synchronization primitives read write fetch add compare swap 
care required synchronize concurrent processes data structure corrupted operations return correct results 
conventional way mutual exclusion guaranteeing exclusive access process manipulating data structure 
mutual exclusion understood particular number efficient spin locking techniques developed 
delay process critical section example due page fault multitasking preemption memory access latency forms bottleneck cause performance problems priority inversion 
lock free data structures implement concurrent objects mutual exclusion 
data structures may able guarantee process complete operation finite amount time processes halt case data structure non blocking data structure guarantee non faulty process complete operation finite amount time wait free 
universal methods known implementation arbitrary concurrent object involve considerable overhead making impractical especially compared spin locks 
possible devise lock free data structures implement particular concurrent object directly universal methods 
techniques offer benefits lock free synchronization sacrificing efficiency 
algorithms data structures directly implement non blocking singly linked list 
knowledge algorithms allow processes arbitrarily traverse linked list structure inserting deleting nodes point list commonly available compare swap primitive providing performance competitive spin locks 
linked list useful building block concurrent objects 
show lock free linked list build non blocking implementations concurrent dictionary object 
rest organized follows section reviews related describes requirements linked list data structure problems encountered implementing lock free manner 
section describes data structure basic algorithms list traversal insertion deletion 
section shows extend techniques implement higher level data types dictionary 
section discusses management allocation memory garbage collection aba problem 
section concludes directions 
related researchers considered benefits avoiding mutual exclusion early 
lamport gave lock free algorithm problem writer multi reader shared variable 
herlihy proved non blocking implementation interesting data types linked lists synchronization primitive universal conjunction read write necessary sufficient 
universal test set fetch add easily implemented compare swap 
compare swap address old new word returns boolean atomic old new return true return false atomic compare swap synchronization primitive 
primitive solve consensus problem number processes compare swap universal primitive 
universal method herlihy followed 
increasingly apparent universal methods suffer sources inefficiency wasted parallelism excessive copying generally high overhead 
addition universal methods algorithms developed lock free objects implemented directly 
focused fifo queue data type cf 
algorithms developed sets union find scheduling garbage collection 
large body implementing primitive types objects atomic registers counters 
note papers data structures linked list permit modifications interior list 
massalin pu coined term lock free implemented multiprocessor operating system kernel lock free data structures 
algorithms require word version compare swap synchronization primitive widely available 
requirements concept list collection items linear order item list position 
singly linked list data structure consists collection cells representing item list 
cells contains number fields particular field contains pointer cell occupying position list 
fields may contain memory management information data dependent application list special root pointer points cell list 
notation algorithms pointer represents contents memory location pointed 
points structure memory example cell field refers field structure 
compare swap main synchronization primitive 
compare swap primitive takes arguments pointer old new values 
shown atomically checks value pointer equal old value updates pointer new value 
case returns indication succeeded 
compare swap primitive swing pointers atomically change value 
primitives test set fetch add 
atomically read modify value shared memory location returning original value 
test set primitive sets new value true fetch add adds arbitrary value 
compare swap primitive widely available common architectures 
newer architectures include load locked store conditional primitives implement compare swap 
implemented uniprocessors technique atomic restartable sequences 
note growing support providing compare swap distributed memory machines 
order concrete notion position convenient introduce idea cursor cursor associated item list cursor said visiting item 
cursor may visiting distinguished position list associated item 
access list accomplished cursor 
new cursor created visiting item list special position list empty 
existing cursor traverse list moving current position list 
new items added list inserting position immediately preceding visited cursor 
item visited cursor removed list deleting 
require lock free objects non blocking necessarily wait free 
non blocking requirement ensures delay process affect wait free property desirable imposes overhead implementation 
furthermore starvation high levels contention efficiently handled techniques exponential backoff example see 
require objects linearizable implies operations appear happen atomically point execution 
proofs data structures linearizable scope straightforward 
problems compare swap swing pointers susceptible aba problem discussed depth section 
solution relies careful memory management particular operations release 
fully described section time treated normal read release treated op 
addition operations discuss management free cells section 
glance may difficult implement lock free linked list 
traversing data structure simple involve changes list structure 
insertion new cells straightforward compare swap pointer new cell pointers cells list initialize swing field operation succeeds new cell linked list concurrent operation changed list structure retry operation re reading pointers 
consider deleting cells list run difficulties 
note delete cell list processes may cursors visiting cell processes able continue cursors traverse list access contents deleted cell 
accomplished simply keeping contents deleted cell intact complicate reuse cells deleted list 
call cell persistence 
serious difficulties 
delete cell list swing pointer preceding cell point cell 
suppose process concurrently inserts cell position immediately cell deleted 
possible situation cell containing deleted successfully cell containing inserted list correctly 
problem occurs process concurrently deletes adjacent cell result deletions undone shown 
problems stem fact observe state fields different cells simultaneously overcoming require synchronization primitive capable operating words memory simultaneously 
shall show section case 
deletion concurrent insertion concurrent deletion second undone 
auxiliary nodes basic operations order overcome problems described section add auxiliary nodes data structure 
auxiliary node cell contains field 
require normal cell list auxiliary node predecessor successor 
permit chains auxiliary nodes list require auxiliary node normal cell predecessor successor chains undesirable performance reasons 
list contains dummy cells normal cells list 
cells pointed root pointers 
dummy cells need respectively preceded followed auxiliary nodes 
empty list data structure consists dummy cells separated auxiliary node 
empty linked list dummy nodes auxiliary node 
cursor implemented pointers data structure target pointer cell position cursor visiting 
cursor visiting list position target equal 
pointer pre aux points auxiliary node data structure 
cursor pre aux target cursor valid invalid pointer pre cell points regular cell data structure 
pointer operation described 
invalid cursor indicates structure list vicinity cursor changed due concurrent insertion deletion process pointers cursor read 
update algorithm examines state list updates pointers cursor valid 
list structure contains auxiliary nodes row update algorithm skip 
adjacent auxiliary nodes list update algorithm remove 
traversal list data structure accomplished operations update operation 
algorithms figures 
operation returns false cursor list advanced 
adding new cells list requires insertion cell new auxiliary node 
insertion restricted occur way new auxiliary node follow new cell list insertion occur auxiliary node normal cell shown 
gives algorithm takes arguments cursor pointers new cell auxiliary node 
algorithm try insert new cell auxiliary node update cursor pre aux target return pre aux release target normal cell compare swap pre cell release pre aux target cursor update algorithm 
cursor pre cell pre aux target null update algorithm 
cursor returns boolean target return false release pre cell pre cell target release pre aux pre aux target update return true algorithm 
inserting new cell auxiliary node 
cursor cell aux 
node returns boolean write write target csw pre aux target return algorithm 
position specified cursor returning value true successful 
cursor invalid operation returns inserting new cell returns value false 
allows higher level operation detect change structure list occured take account attempting insert new cell 
example section show items list kept sorted technique 
valid cursor cell visiting deleted list 
insertion new cells list structure changes cursor invalid operation fails tried 
gives algorithm 
deletion cell list leaves extra auxiliary node concurrent processes deleting adjacent cells result longer chains 
algorithm concerned removing extra auxiliary nodes list 
normally removing extra auxiliary node results deletion cell list accomplished simply swinging pointer cell pointed pre cell pointer cursor 
particular cell may deleted list case swinging pointer remove extra auxiliary node 
order overcome problem add back link field normal cells list 
cell deleted list pre cell field cursor copied cell back link field 
algorithm pointers traverse back cell deleted list 
just processes possible create chain auxiliary nodes intervening normal cells length 
chain exist list long process executing algorithm 
deletions completed list contain extra auxiliary nodes 
see assume chain auxiliary nodes list 
normal cell deleted auxiliary nodes chain 
note implies normal cell immediately preceded list deleted 
assumption operation deleted completed 
consider loop lines algorithm 
way process exit loop complete operation deletion operation extended chain auxiliary nodes deleting normal cell immediately chain cell front chain 
furthermore deletion occured operation deleting set back link pointer line auxiliary node cursor returns boolean target target csw pre aux true return false write back link pre cell pre cell back link null back link release normal cell release repeat csw false release true back link null normal cell release release release return true algorithm 
key cursor returns boolean target target key return true target key return false return false algorithm 
included chain lines 
chain back link pointers followed process deleted lead normal cell preceded way operation deleted completed reason operation extend chain auxiliary nodes deleting cell length list finite deletion argument completed 
operation progress contradicting assumption operations progress 
dictionaries linked list useful building block data structures 
show ideas section applied problem implementing various data structures dictionary data type 
dictionary contains collection items distinguished distinct keys provides operations find insert delete 
data structures algorithms section implement nonblocking dictionary data structures sorted list hash table skip list binary search tree 
list structures assume cell field key contains unique key item stored cell 
ensure keys items stored dictionary unique keeping items list sorted key values 
gives algorithm searches list starting cursor position cell containing key 
returns boolean value indicating item requested key 
dictionary find operation implemented operation starting position list 
dictionary insert operation performed algorithm 
necessary ensure item key dictionary 
algorithm leave cursor positioned correct place insert new cell 
insertion new cell fails due changes list structure concurrent operations necessary check key value unique updating value cursor 
note cursor update algorithm ensures cell inserted insert key new cell new aux 
node initialize loop true return true return update goto loop insert algorithm 
delete key loop false return true return update goto loop delete algorithm 
key cursor positioned way algorithm find 
dictionary delete operation accomplished similar way algorithm locate position cell containing key list algorithm delete cell 
algorithm fails update cursor continue search key 
compare performance non blocking concurrent dictionary implementation similar sequential implementation sorted linked list 
non constant factor slowdown come sources done traversing extra auxiliary nodes list structure repetitive calls 
single operation impossible place bounds extra 
bound amortized considering sequence dictionary operations performed number processes 
concurrent processes successfully completed operation cause gamma concurrent processes retry operation 
addition worst case operation may traverse extra auxiliary node left previous operation 
total done concurrent non blocking implementation sequence operations processes constant factor optimal 
straightforward extension implementation uses hash table 
case assume hash function evenly distributes operations lists expect extra done 
implement lock free skip list collection sorted singly linked lists higher level lists contain subset cells lower level lists 
insertions deletions performed level time insertions starting bottom level working deletions starting top working 
structure skip list reduces amount done traversing list large amount extra may incurred due processes attempting modify portion list 
worst case extra may log 
binary search trees binary search trees implemented adapting techniques section 
cell tree left right auxiliary node subtrees auxiliary nodes subtree empty 
searching cell key binary search tree identical algorithm standard sequential binary search tree 
insertion new cells occurs leaves tree adding new cells tree fairly straightforward involving simply swinging pointer auxiliary node leaf 
remainder section deal deletion cells tree 
delete cells child insure cell gain second child deletion 
merge subtrees swinging auxiliary node pointer preceding empty child point auxiliary node preceding child deleted 
effectively short circuit processes traversing tree proceeding branch tree shunting branch 
splice cell deleted remove extra auxiliary nodes techniques similar section 
cell children move subtrees 
note move cell closer root result concurrent processes unable find key traversing tree resulting non linearizable behavior 
move subtrees cell deleted tree making left subtree left child order successor 
illustrates done find order successor node node deleted node 
swing auxiliary node preceding empty left child point left subtree cell deleted 
remove cell extra auxiliary nodes steps indicated 
effect deletion method performance binary search tree unknown 
consider find insert dictionary operations amount extra done sequence operations expected log tree expected height log cell inserted retried cell path back root 
parameter generally chosen theta log number items expected skip list 
deletion cell children 
memory management far assumed new cells allocated necessary deleted cells left intact cursors continue traversing 
addition claimed section solution aba problem relied careful memory management 
section address issues 
aba problem compare swap primitive algorithms atomically swing pointers current value new 
compare swap manner susceptible problem known aba problem 
swinging pointer want pointer change value changed read 
problem occurs pointer changed subsequently changes back original value 
case compare swap primitive successfully change value pointer possibly corrupting data structure 
ways avoid problem 
commonly approach double word version compare swap operation 
idea attach tag value pointer time pointer changed tag incremented double word compare swap change pointer tag values simultaneously pointer changes back previous value tag value different compare swap operation fail 
unfortunately double word version compare swap available architectures 
approach stronger primitive 
example architectures dec alpha load locked operation read pointer store conditional operation swing 
compare swap store conditional primitive change pointer changed susceptible aba problem 
load locked store conditional primitives fair number newer architectures technique suffers fact primitives implemented certain restrictions example generally possible read memory load locked store conditional cf 

restriction impossible implement algorithms primitives 
approach take observation normal operation algorithms previous sections pointer changed back previous value 
way pointer take previous value cells reused deleted data structure 
prohibit reuse may compare swap primitive worrying aba problem 
applications probably realistic assume cells reused 
observation aba problem occur cell reused process pointer 
safely reuse cells avoiding aba problem long guarantee processes pointers cell 
accomplish counts cell field field claim described 
counts manipulated release operations algorithms 
note problem cell persistence solved counts cells longer accessed list cursors available reuse 
operation atomically reads pointer increments count cell pointed 
release operation decrements count reclaims cell reuse pointers cell 
figures give algorithms operations 
pointer returns pointer loop read null return null increment read return release goto loop algorithm operation 
release pointer fetch add gamma return test set claim return reclaim algorithm release operation 
note care taken release algorithm possible processes concurrently see count go zero cell 
claim field cell ensure process try reclaim cell reuse 
managing free cells addition release operations need able allocate reclaim cells 
way solving problem concurrent object acts set containing free cells may allocated processes 
object provides operations alloc removes free cell set returns process reclaim returns cell longer set free cells 
brevity describe simple implementation object free cells size 
kept simple list 
elaborate schemes possible particular show extend ideas implement lock free buddy system provides management variable sized cells 
keep cells free list 
new cells allocated removing front list cells reclaimed putting back front list acts stack 
figures give algorithms alloc reclaim operations 
alloc returns pointer repeat freelist null return null csw freelist false release true write claim return algorithm alloc operation 
variable freelist pointer free cell list 
note alloc algorithm release operations order avoid aba problem 
reclaim pointer repeat freelist write csw freelist true algorithm reclaim operation 
algorithms compare swap manipulating singly linked list concurrent processes mutual exclusion 
includes traversing list cursors insertion deletion nodes point list memory management 
shown techniques building blocks types concurrent objects dictionary data type 
algorithms property non blocking 
chose compare swap synchronization primitive reasons 
universal sense powerful implement non blocking linked list commonly available number architectures 
expect performance algorithms competitive similar data structures spin locks 
time consuming operation performing cell traverse list useful operation implemented hardware 
preliminary performance analysis algorithms remains done order quantitatively determine performance tradeoffs algorithms traditional methods mutual exclusion 
currently examining performance algorithms data structures experimentally 
felten 
performance issues non blocking synchronization shared memory multiprocessors 
proceedings eleventh symposium principles distributed computing pages 
anderson woll 
wait free parallel algorithms union find problem 
proceedings third acm symposium theory computing pages 
anderson 
operating system support high performance multiprocessing 
phd thesis university washington department computer science engineering seattle wa 
university washington department computer science engineering technical report 
barnes 
method implementing lock free shared data structures 
proceedings fifth symposium parallel algorithms architectures pages 
bershad redell ellis 
fast mutual exclusion uniprocessors 
proceedings fifth international conference architectural support programming languages operating systems pages 
easton 
process synchronization longterm interlock 
proceedings third symposium operating systems principles pages 
fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm pages 
graunke 
synchronization algorithms shared memory multiprocessors 
computer june 

scalable coherent interface related standards projects 
ieee micro pages february 
herlihy 
wait free synchronization 
acm transactions programming languages systems january 
herlihy 
methodology implementing highly concurrent data objects 
acm transactions programming languages systems november 
herlihy moss 
lock free garbage collection multiprocessors 
proceedings third symposium parallel algorithms architectures pages july 
herlihy 
impossibility universality results wait free synchronization 
proceedings seventh symposium principles distributed computing pages 
herlihy wing 
linearizability correctness condition concurrent objects 
acm transactions programming languages systems 
huang weihl 
evaluation concurrent priority queue algorithms 
proceedings third ieee symposium parallel distributed processing pages 
hummel schonberg 
low overhead scheduling nested parallelism 
ibm journal research development sep 
lamport 
concurrent reading writing 
communications acm 
shasha 
concurrent set manipulation locking 
proceedings seventh symposium principles database systems pages march 
massalin pu 
lock free multiprocessor os kernel 
technical report cucs columbia university 
mellor crummey scott 
algorithms scalable synchronization shared memory multiprocessors 
acm transactions computer systems february 
michael scott 
implementation general purpose atomic primitives distributed shared memory multiprocessors 
international symposium high performance computer architecture january 
univ rochester computer science dept tr 
plotkin 
sticky bits universality consensus 
proceedings eighth symposium principles distributed computing pages 
pugh 
concurrent maintenance skip lists 
technical report cs tr institute advanced computer studies department computer science university maryland college park 
pugh 
skip lists probabilistic alternative balanced trees 
communications acm june 
sites editor 
alpha architecture manual 
digital press burlington ma 
turek shasha prakash 
locking blocking making lock concurrent data algorithms nonblocking 
proceedings eleventh symposium principles database systems 
valois 
implementing lock free queues 
proceedings seventh international conference parallel distributed computing systems pages las vegas nv october 
available rpi dept comp 
sci 
tech 
report 
valois 
lock free data structures 
phd thesis rensselaer polytechnic institute department computer science 
