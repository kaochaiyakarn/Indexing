reasoning infinite computations moshe vardi ibm almaden research center pierre wolper universit de li ege investigate extensions temporal logic connectives defined finite automata infinite words 
consider different logics corresponding different types acceptance conditions finite looping repeating automata 
turns logics expressive power decision problems pspace complete 
investigate connectives defined alternating automata show increase expressive power logic complexity decision problem 
years logics programs tools reasoning input output behavior programs 
dealing concurrent nonterminating processes operating systems need reason infinite computations 
considering states finite computations need consider infinite sequences states program goes 
logics reason sequences include temporal logic pn temporal logic process logics ni 
propositional case computations viewed infinite sequences propositional truth assignments 
reasoning individual propositional truth assignments propositional logic descriptively complete language specify set propositional truth assignments 
priori robust notion descriptive completeness reasoning sequences propositional truth assignments 
preliminary version authored wolper vardi sistla appeared proc 
th ieee symp 
foundations computer science pp 
title reasoning infinite computation paths 
address ibm almaden research harry rd san jose ca usa vardi almaden ibm com address institut mont universit de li ege li ege sart belgium pw ac propositional temporal logic ptl shown expressively equivalent monadic order theory natural numbers relation 
taken indication ptl process logics descriptively complete 
assumes order notions need reason infinite computations 
fundamental notion regularity sets event sequences order simple assertion proposition holds state path expressible ptl wo 
fact ptl order theory known expressively equivalent star free regular languages lad tho tho 
hand regular sequences natural way describing concurrent processes sh mi furthermore ability describe regular sequences crucial task program verification 
different ways extend expressive power ptl 
add non order construct fixpoint second order quantification prefer add explicit mechanism specifying regular events done wo 
ptl extended temporal connective corresponding nondeterministic finite automaton infinite words 
example sigma fa bg automaton accepting infinite words sigma having position binary temporal connective formula true satisfied paths holds state 
important point considered wo define regular sequences needs impose certain repeating conditions accepting automata runs 
example buchi automata define exactly regular languages require accepting state occurs infinitely run bu mcn 
buchi automata define temporal connectives gives rise extended temporal logic call etl addition notion repeating acceptance consider notions acceptance 
notion finite acceptance automaton accepts infinite word accepts prefix word standard notion acceptance finite words 
second notion looping acceptance automaton accepts infinite word infinite run word notion wo 
automata finite looping acceptance conditions define temporal connectives gives rise extended temporal logics call etl etl respectively 
note interest finite looping acceptance due automata theoretic precise formalism wo right linear context free grammars infinite words 
note automata conceptually different automata dynamic logic cf 
ha hs pr 
dynamic logic automata describe flowchart programs automata describe temporal sequences 
dynamic logic automata describe regular sequences program statements temporal logic automata describe regular properties state sequences 
significance due significance specification constructs 
finite acceptance viewed describing liveness property eventually happen looping acceptance viewed safety condition bad happen 
finite looping acceptance viewed extensions eventually constructs ptl 
notions finite looping acceptance incomparable strictly weaker notion repeating acceptance 
example sequence ab defined repeating acceptance finite looping acceptance 
expect logics etl etl etl different expressive powers 
main results logics expressively equivalent 
expressive power regular expressions bu monadic second order theory usually denoted 
consider complexity decision problem etl etl turns logics complexity ptl polynomial space cf 
hr sc 
contrast decision problem nonelementary emptiness problem regular expressions complement ms 
important contribution show temporal logic formulas directly compiled equivalent buchi automata 
construction proof correctness easier systematic define variants buchi automata geared recognizing models temporal formulas prove variants converted buchi automata 
construction obtain decision procedures 
approach starting formula build equivalent buchi automaton check automaton nonempty 
note construction buchi automata temporal logic formulas useful obtaining decision procedures logic cornerstone synthesis verification methods temporal logic mw pr vw wo 
construction cornerstone applications temporal logic verification probabilistic real time programs cf 
ah va 
explore full power technique introduce alternating finite automata connectives 
exponentially succinct nondeterministic extensive study acceptance conditions automata see ch ka lan sta tho wa 
conditions corresponds conditions lan 
known conditions exhaust possibilities landweber classification cf 
wa 
notions safety liveness due lamport lam 
notion liveness corresponds notion guarantee mp 
shown decision problem etl pspace complete 
result requires significantly complicated automata theoretic techniques scope 
comments complexity etl see section 
automata theoretic approach described viewed specialization approach decision problems dynamic logic described vw see es st 
note tree automata constructed es st vw accept models formulas automata constructed accept models formulas 
automata connectives may expect push complexity logic 
investigate atl atl alternating analogues etl rtl surprisingly show decision problems logics pspace complete 
finite automata infinite words section define classes finite automata infinite words examine nonemptiness problem 
framework developed specialization framework developed vw 
view wide range applications temporal logic cf 
bbp describe word automata framework detail order self contained 
definitions start making notation infinite words precise 
denote set natural numbers notation interval fi jg 
infinite word alphabet sigma function 
sigma 
ith letter infinite word 
denote write 
nondeterministic finite automaton abbr 
nfa infinite words tuple sigma ae ffl sigma finite alphabet letters ffl finite set states ffl ae theta sigma transition function mapping state letter set possible successor states ffl set initial states ffl set accepting states 
automaton deterministic ae sigma 
finite run infinite word finite sequence oe gamma ae gamma 
run infinite word infinite sequence oe ae 
depending acceptance condition impose get different types automata 
finite acceptance automata finite run oe gamma accepting gamma looping acceptance automata run oe accepting condition imposed set repeating acceptance automata buchi automata bu run oe accepting accepting state repeats infinitely infinitely types automata infinite word accepted accepting run set infinite words accepted automaton denoted 
different types automata recognize different classes languages 
turns class languages accepted repeating acceptance automata repeat strictly contains class languages accepted looping loop finite acceptance finite automata 
classes incomparable 
languages accepted buchi repeating acceptance automata called regular languages 
results buchi bu see mcnaughton mcn class languages closed union intersection complementation equivalent class languages describable monadic second order theory successor regular expressions 
monadic second order theory successor interpreted formalism individual variables ranging natural numbers monadic predicate variables ranging arbitrary sets natural numbers constant successor function boolean connectives quantification types variables 
regular expressions expressions form ff fi union finite ff fi classical regular expressions denotes countable repetition 
establish relations repeat loop finite state known facts cf 
ch ka lan sta tho wa 
lemma 
language alphabet sigma fa bg loop finite 
language alphabet sigma fa bg finite loop 
language alphabet sigma fa bg repeat finite loop corollary 
repeat strictly contains finite loop 
finite loop incomparable 
rest section deal buchi automata 
nonemptiness problem buchi automata important problem solve buchi automata nonemptiness problem buchi automaton determine accepts word 
interested complexity problem function size automaton 
assume standard encoding automata size automaton length encoding 
sigma ae automaton 
say state reachable state finite word sigma finite sequence states ae gamma 
lemma tb buchi automaton accepts word iff accepting state automaton reachable initial state reachable 
prove theorem nonemptiness problem buchi automata logspace complete nlogspace 
proof prove problem nlogspace 
lemma determine buchi automaton accepts word need check accepting state reachable initial state reachable 
nondeterministically guess initial state accepting state nondeterministically attempt construct path 
construct path state state proceed follows 
current state 

choose transition current state replace current state target transition 

current state 
repeat step 
point states remembered 
algorithm requires logarithmic space 
show nlogspace hardness lemma straightforward construct reduction graph accessibility problem proved nlogspace complete jo 
solve satisfiability problem extended temporal logic proceed follows build buchi automaton accepting models formula determine automaton nonempty 
automata build exponential size formula 
fact nonemptiness problem nlogspace indicates possible solve satisfiability problem polynomial space 
argument necessary build automaton applying algorithm nonemptiness 
similar argument somewhat different framework hr sc wo 
argument precise 
delta fixed finite alphabet 
problem subset delta instance element delta want determine membership assume delta encode buchi automata constituent elements alphabet states 
lemma problem polynomial ff fi fl ffi algorithms associate instance encoding buchi automaton sigma ae manner 
sigma 
delta ff determines sigma space 
delta fi determines space 
delta fl determines space 
delta ffi determines space 
delta determines ae space 
iff accepts word 
polynomial space algorithm determining membership proof algorithm described proof theorem check nonempty 
assumptions steps algorithm executed polynomial space 
states remembered size polynomial size problem 
algorithm requires polynomial space 
establishes problem pspace 
constructing buchi automata temporal logic formulas take intersection buchi automata 
lemma special case theorem vw extends construction ch see es 
theorem gamma buchi automata 
buchi automaton theta pi gamma ja states gamma 
proof sigma ae 
define sigma ae follows theta theta gamma theta gamma theta theta gamma theta theta theta theta gamma theta gamma ae gamma iff ae gamma mod automaton consists copies cross product automata intuitively starts running copy cross product 
jumps copy copy mod final state encountered 
acceptance condition imposes goes infinitely final state copy 
forces components visit accepting states cyclic order 
leave reader formally prove gamma 
subword automata construction buchi automata extended temporal logic formulas easier define specialized classes automata subword automata set subword automata 
specialization words subtree automata set subtree automata defined vw 
completeness sake give detailed treatment specialization 
intuitively subword automaton checks starting position infinite word finite word accepted automaton 
automata accepting finite words various positions differ initial state 
initial state corresponding position determined symbol appearing position infinite word 
formally subword automaton tuple sigma ae ffl sigma alphabet ffl state set ffl ae theta sigma transition function ffl sigma labeling function ffl nonempty set accepting states 
infinite word sigma accepted conditions hold ffl labeling condition ae ffl subword condition exists mapping ae 
labeling condition requires labeling word compatible transition function subword condition requires position word subword accepted viewed automaton finite words initial state 
construction similar flag construction choueka ch subword automaton labeling condition converted buchi automaton exponential increase size 
show labeling condition conversion quadratic increase size 
proving need technical lemma 
lemma sigma ae subword automaton 
accepts word 
sigma iff ffl ae ffl exists mapping ae 
proof difference condition lemma standard condition acceptance requirement interval contain points accepted subword gamma nonempty 
direction trivial 
direction assume accepts labeling condition clearly holds remains show existence right subword 

exists mapping satisfies subword condition done 
assume know exists mapping satisfies subword condition point 
claim interval satisfies subword condition labeling condition mapping satisfies required conditions theorem subword automaton states equivalent buchi automaton states 
proof sigma ae subword automaton 
define new transition functions ae ae theta sigma ffl ae ae ae 
ffl ae ae ae ae 
transition functions define buchi automata sigma ae sigma ae 
basically take care checking labeling condition checking subword condition 
show word 
sigma accepted iff accepted suppose accepted means accepting runs oe oe resp 
verify labeling property holds 
clearly ae 

consequently ae ae remains verify subword condition 

run oe accepting reason assume loss generality consider interval 
claim satisfies subword condition suitable mapping defined way 
clearly ae ae ae ae ae ae ae ae show accepted accepted consider run oe 
labeling condition oe accepting run define computation oe defining sequence increasing intervals interval define arbitrary member suppose oe defined interval 
induction jn lemma exists interval mapping jn ae 
loss generality assume define 
show ae 
jn consequently ae ae consequently ae ae clearly 
defined run oe jn run accepting 
shown accepted theorem construct automaton word accepted iff accepted follows subword automaton equivalent buchi automaton subword automata adequate buchi automata purpose reducing satisfiability formulas nonemptiness automata 
facilitate task rest specialize notion subword automata 
words shall deal going consists sets formulas states automata accept words going sets formulas 
consider automata alphabet set states set structure power set 
call automata set subword automata 
formally set subword automaton pair psi ae ffl psi finite set basic symbols fact symbols just formulas logic 
power set psi serves alphabet sigma state set empty set serves single accepting state 
denote elements psi viewed letters alphabet sigma viewed elements state set intuitively letter set formulas alleged true state set formulas automaton tries verify 
ffl ae theta sigma transition function 
ae iff 
ae 
ae ae 
ae ae ae 
word 
sigma accepted exists finite interval mapping ffl ffg ffl ffl ae 
acceptance condition requires position word formula right formulas appear letters 
intuitively transition automaton meant capture fact certain formula appears certain formulas appear conditions imposed transition relation ae explained follows 
formulas state automaton formulas automaton trying verify 
minimal requirement formulas appear letter scanned position word 
see condition related labeling condition defined subword automata 

call monotonicity conditions 
transition automaton minimum requirement formulas formulas automaton trying verify clearly verify required condition 
transition legal try verify fewer formulas formulas 

additivity condition 
says interaction different formulas automaton trying verify position union transitions legal transition 
acceptance condition requires position word start automaton singleton sets corresponding members letter position accepts finite subword 
prove conditions equivalent require automaton accept started state identical letter node 
theorem psi ae set subword automaton 
psi word 
equivalent 
exists mapping ae 

exists mapping ffg ae 
proof 
take define follows ffg show ae follows monotonicity condition definition set subword automata 

take take max fj extend defining define define 

furthermore condition definition set subword automata ae 
prove set subword automata converted subword automata increase size 
theorem set subword automaton converted equivalent buchi automaton quadratic increase size 
theorem set subword automaton psi ae equivalent subword automaton psi psi ae identity function 
proof lemma immediate word accepted automaton accepted lemma word accepted set subword automaton subword condition subword automaton satisfied 
remains show satisfies labeling condition 
words identity mapping show ae 
accepts exists mapping ae 
monotonicity conditions ae 
ae 
consider 
clearly ae condition definition set subword automata monotonicity condition ae 
temporal logic automata connectives definition consider propositional temporal logic temporal operators defined finite automata similarly extended temporal logic etl wo 
precisely consider formulas built set rop atomic propositions 
set formulas defined inductively follows ffl proposition rop formula 
ffl formulas formulas 
ffl nondeterministic finite automaton sigma ae sigma input alphabet fa set states ae sigma theta transition relation set initial states set accepting states formulas sigmaj formula 
call automaton connective 
assume standard encoding formulas 
length formula length encoding 
course includes encoding automata connectives 
structure logic infinite sequence truth assignments function 
rop assigns truth values atomic propositions state 
note function infinite word alphabet rop terms word sequence interchangeably 
define satisfaction formulas runs formulas sequences mutual induction 
satisfaction formula position structure denoted say sequence satisfies denoted ffl iff atomic proposition ffl iff ffl iff ffl sigma ae iff accepting run oe starting ffl run formula sigma ae structure starting point finite infinite sequence oe states joej sigma ae 
depending define accepting runs get different versions logic ffl etl run oe accepting iff state occurs oe finite acceptance ffl etl run oe accepting iff infinite looping acceptance ffl etl run oe accepting iff state occurs infinitely oe repeating buchi acceptance 
formula defines set sequences set sequences satisfy 
say formula satisfiable set nonempty 
satisfiability problem determine formula satisfiable 
interested expressive power logics defined 
yardstick measuring power ability logics define sets sequences 
note corollary etl expressive etl etl corollary infer etl expressive etl etl similarly corollary give information relative expressive power etl etl example consider automaton sigma ae sigma fa bg fs ae fs ae fs ae ae fs fs consider finite acceptance accepts language defines etl connective true sequence iff true true 
equivalent connective 
hard see extended temporal logics etl etl etl expressive ptl 
example consider automaton sigma ae sigma fa bg fs ae fs ae ae ae fs fs 
consider looping acceptance accepts word 
defines etl connective true sequence iff true state true odd state sequence 
shown wo property expressible ptl 
translations automata decision procedure pointed structures etl interpreted viewed infinite words alphabet rop hard show logics translatable bu mcn define regular sets words 
formula logics etl etl etl build buchi automaton accepts exactly words satisfying formula 
negation front automata connectives causes exponential blow expected complexity translation nonelementary translation buchi automata bu 
logics defined exponential translation buchi automata 
translation yields pspace decision procedure satisfiability problem 
section give translation etl etl translation etl 
start translations etl outline differences occur dealing etl need define notion closure etl formula denoted cl 
similar nature closure defined pdl fl 
identify formula automaton sigma ae define automaton sigma ae fsg 
closure cl etl formula defined follows ffl cl 
ffl cl cl 
ffl cl cl 
ffl cl cl 
ffl cl cl 
ffl cl cl intuitively closure consists subformulas negations assuming considered subformula 
note cardinality cl easily seen length structure 
rop etl formula extended sequence pi 
cl natural way 
point associate formulas cl satisfied point 
sequences cl corresponding models formula satisfy special properties 
hintikka sequence etl formula sequence pi 
cl satisfies conditions 
state conditions mapping automaton connective associates states elements cl precisely cl sigma ae define mapping oe cl oe fs ae sigma ag conditions cl mentioned assume sigma ae 
conditions 
pi 
pi iff pi 
pi iff pi pi 
pi exists mapping cl ffl pi ffl ffl ffl oe pi 
pi ffl ffl pi oe pi 
hintikka conditions intended capture semantics propositional connectives hintikka conditions intended capture semantics automata connectives 
note propositional connective need condition double implication iff need conditions automata connectives due single implication 
reason doing hintikka condition weaker converse hintikka condition 
easier construct automaton checks conditions 
proposition etl formula model iff hintikka sequence 
proof etl formula model define hintikka sequence pi follows pi fh cl hg 
show pi hintikka sequence 
definition model implies hintikka condition 
hintikka conditions hold follows immediately semantic definition etl etl formula pi hintikka sequence consider structure fp rop pi show show induction cl pi iff base case rop immediate construction 
inductive step formulas form follows directly hintikka conditions respectively 
remains prove inductive step formulas form 
suppose pi hintikka condition inductive hypothesis finitely accepting run starting 
suppose pi 
finitely accepting run starting finite sequences ae 
hintikka condition induction follows pi particular pi hintikka condition violated 
build buchi automaton alphabet cl accepts precisely hintikka sequences building automata ae ae set hintikka sequences automaton called local automaton checks sequence locally checks hintikka conditions 
automaton buchi automaton 
second automaton ae called eventuality automaton set subword automaton checks hintikka condition 
automaton ensures eventualities formulas form finite word condition hintikka satisfied 
convert eventuality automaton buchi automaton combine local automaton 
local automaton local automaton cl cl ae cl 
state set collection sets formulas cl 
transition relation ae ae iff ffl iff ffl iff ffl oe set starting states consists sets clearly accepts precisely sequences satisfy hintikka conditions 
eventuality automaton eventuality automaton set subword automaton ae cl ae 
transition relation ae ae iff ffl ffl state oe immediate check conditions definition set subword automata satisfied ae furthermore ae accepts precisely sequences satisfy hintikka condition 
proposition etl formula pi 
cl sequence pi hintikka sequence iff pi ae 
theorems build buchi automaton accepts ae 
automaton cl states 
theorem build buchi automaton accepting ae 
automaton cl states 
automaton constructed accepts words cl models defined words rop step construction take projection automaton rop done mapping element cl element rop rop equivalently automaton runs word rop guesses corresponding word cl verify hintikka sequence summarize theorem etl formula built set atomic propositions rop construct buchi automaton alphabet rop size jgj accepts exactly sequences satisfying give algorithm complexity bounds satisfiability problem etl test satisfiability etl formula sufficient test 
theorem done nondeterministic logarithmic space size hard see construction satisfies conditions lemma 
combining fact satisfiability propositional temporal logic restriction etl pspace hard sc theorem satisfiability problem etl logspace complete pspace 
consider etl construction proceeds similarly etl difference hintikka conditions replaced pi oe pi pi pi exists mapping cl ffl pi construction contains redundancy done component checks labeling condition proof theorem subsumed done local automaton 
eliminating redundancy build equivalent automaton cl states 
ffl ffl ffl oe pi 
analogue proposition holds theorem etl formula model iff hintikka sequence 
proof proposition direction immediate 
etl formula pi hintikka sequence consider structure fp rop pi show induction cl pi iff show inductive step corresponds automata connectives 
suppose pi hintikka condition infinite sequences ae pi induction hypothesis 
suppose pi hintikka condition pi infinite run oe starting explicitly sigma ae 
induction hypothesis pi hintikka condition hold 
construct automaton recognize hintikka sequences parts local automaton eventuality automaton 
time local automaton deals hintikka conditions eventuality automaton deals condition 
local eventuality automata differ etl transition functions 
local automaton ae iff ffl iff ffl iff ffl oe eventuality automaton ae iff ffl ffl oe analogues proposition theorems proposition etl formula pi 
cl sequence pi hintikka sequence iff pi ae 
theorem etl formula built set atomic propositions rop construct buchi automaton alphabet rop size jgj accepts exactly sequences satisfying theorem satisfiability problem etl logspace complete pspace 
construction described simultaneously takes care running automata parallel automata connective nested automata connective complementing automata negated automata connective 
construction viewed combining classical subset construction rs choueka flag construction ch 
contrasted treatment etl special construction needed complement buchi automata 
result size automaton constructed etl formula jgj results safra sa improved jgj log jgj provably optimal 
construction etl etl construction etl exponential exponent etl etl linear nonlinear etl interesting compare technique pratt model construction technique pr 
starts building maximal model eliminates states eventualities satisfied 
local automata correspond maximal models 
eliminating states combine local automata eventuality automata checking satisfaction eventualities 
construction yields automata size exponential size formula 
construct automata tableau technique pr 
technique efficient maximal model technique 
major feature framework set subword automata check eventualities 
direct construction buchi automaton check eventualities essentially constructions theorems 
appreciate simplicity construction set subword automata reader encouraged try directly construct buchi automaton checks hintikka condition etl checks hintikka condition etl possible approaches translation formulas automata 
streett st suggested called formula checking automata 
approach eliminates need distinction local automaton eventuality automaton 
approach weak alternating automata described mss 
approach distinction local automaton eventuality automaton automaton constructed simple induction structure formula 
believe distinction local automaton checks local properties eventuality automaton checks global properties fundamental avoidable etl etl example etl temporal calculus construction local automaton straightforward main difficulty lies construction global automaton va 
approach unitary approaches mss st generalize logics 
translations logics results previous section show set sequences describable etl etl etl formulas expressible buchi automata 
case etl converse clearly true 
etl exactly expressive power buchi automata 
lemma notions finite looping acceptance weaker notions repeating acceptance conceivable etl etl expressive etl buchi automata 
show case translation etl formulas etl etl see translations involves exponential increase length formula 
giving constructions nontrivial automata theoretic results sa show straightforward translations etl etl involves single exponential increase length formulas 
start going etl etl theorem etl formula length construct etl formula length satisfied exactly sequences proof prove theorem need show etl formula defined nondeterministic finite acceptance automaton translated etl idea translation sequences accepted finite acceptance automaton rejected closely related looping acceptance automaton automaton deterministic 
finite acceptance automata classical subset construction rs 
subset construction assure sufficient determinism 
want structure run deterministic automaton structure 
automaton deterministic formula nondeterministic states structure satisfy formula overcome type nondeterminism replace sigma ae automaton sigma automaton sigma ae transition relation ae defined follows ae iff ae equivalent formula corresponding set sigma 
clearly state exactly satisfied 
step apply subset construction automaton yields automaton sigma ae fs ffl ae iff fs ae ffl fs js structure unique computation structure computation accepting iff reaches state words computation looping computation automaton sigma gamma ae fs gamma translation etl size clearly exponential size translation formula length length turn translation etl etl theorem etl formula length construct etl formula length satisfied exactly sequences proof proof identical theorem time automaton finite acceptance automaton defined sigma ae fs 
translate etl etl etl determinization automaton defining connective 
automata buchi automata subset construction 
possible build deterministic finite state automaton corresponding buchi automaton automaton general type accepting condition infinite repetition state set mcn ch 
general type automaton rely construction partially buchi automata 
lemma sa buchi automaton sigma ae jsj construct nondeterministic automata finite words size deterministic buchi automata size language accepted satisfies ik 
give translations 
deal etl theorem etl formula length construct etl formula length satisfied exactly sequences remember looping automata set designated states irrelevant 
proof convenience proof temporarily definition 
set etl formulas ff set infinite words alphabet sigma fa satisfied sequence iff word note definition coincides definition automata connectives language language accepted automaton 
prove theorem need show etl formula defined nondeterministic buchi automaton translated etl main difficulty express etl condition imposed repetition set nondeterministic buchi automaton 
lemma replace nondeterministic buchi automaton deterministic automata show repetition deterministic buchi automata expressed etl similarly proof theorem want deterministic automata deterministic structure 
implies ensure argument automaton connective true state structure 
construction theorem replace automaton sigma ae automaton sigma ae 
formula equivalent 
lemma automaton lemma enables express language accepted ik terms union defines language infinite strings 
similarly automata connectives languages satisfied set sequences 
clearly sequence satisfies iff satisfies languages 
build etl formula corresponding terms union etl formula corresponding ik give translation terms union 
start infinite parts term deterministic buchi automaton sigma ae want construct etl formula sequence satisfies iff satisfies 
fact infinite sequence exactly run sequence 
run accepting goes state infinitely 
similarly point goes state express condition negate 
express eventually reaches state goes state sequences cause go state state rejected finite acceptance automaton sigma ae fsg 
satisfying formula 
express eventually reaches satisfies finite acceptance automaton sigma fag feg ae feg new letter new state 
transition relation ae ae extended ae feg 
formula expresses automaton eventually reaches state goes state state computation automaton accepting need state states formula hold 
words construct need express computation holds 
le automaton sigma ffi 
build automaton sigma fag feg ffi feg new letter new state transition relation ffi ffi augmented ffi feg size exponential size original automaton size linear 
formula contains copy theta jb copies exponential size formula ik exponential size 
translating etl formula length etl result length consider translation etl result similar etl theorem etl formula length construct etl formula length satisfied exactly sequences proof proof lines theorem looping acceptance automata finite acceptance automata 
outline done finite acceptance automata appearing proof theorem automaton looping automaton loop sigma gamma ae fsg gamma automaton loop automaton set designated states removed transition relation updated accordingly 
formula loop 
second finite acceptance automaton replace loop sigma theta ae loop gamma transition relation ae loop defined follows ffl oe letters ff sigma ae loop ff oe ae loop ff oe ae ff oe 
ffl oe letters ff sigma ae loop ff oe ae ff oe ae loop ff oe loop intuitively constructed operator loop strictly deterministic true formula false time goes state negation satisfied point goes state true 
finite acceptance operator appearing proof theorem shown theorem possible replace etl operator etl operator cost exponential increase size 

affect exponential complexity translation automaton size linear length original formula 
alternating temporal logic results preceding sections show technique applicable automata connectives negation automata connectives 
suggests technique deal alternation 
set states denote set boolean formulas states variables 
members viewed boolean valued functions boolean value states assigned states gamma assigned 
formulas form called atomic formulas 
alternating finite automaton bl cks abbr 
afa tuple sigma ae sigma input alphabet set states fs mg ae theta sigma transition function associates state letter boolean formula start formula set accepting states 
extend ae theta sigma ae obtained substituting ae example ae ae ae 
define auxiliary mapping ff ff fs tg gamma tg consider acceptance finite words afa 
run word sequence formulas ae gamma 
accepts 
equivalent way defining acceptance finite words afa terms finite run forests 
finite run forest collection finite trees labeled atomic formulas satisfying conditions ffl length branches ffl set ff tree forest root labeled 
ffl internal node depth labeled set ae ff child labeled 
node labeled accepting 
run forest accepting accepting leaf 
accepts accepting run forest afa define regular languages 
follows results le cks exponentially succinct nfa 
state afa construct state nfa accepts language 
furthermore states afa language defined definable nfa states 
notion alternation extended automata infinite words mh 
finite acceptance defined means finite acceptance forests 
finite run forest infinite word collection finite trees labeled atomic formulas satisfying conditions ffl set ff tree forest root labeled 
ffl internal node depth labeled set ae ff child labeled 
run forest accepting accepting leaf 
accepts accepting run forest note opposed definition case finite words branches run forest required length 
looping acceptance defined means infinite run forests 
infinite run forest infinite word collection infinite trees labeled atomic formulas satisfying conditions ffl branches infinite 
ffl set ff tree forest root labeled 
ffl internal node depth labeled set ae ff child labeled 
accepts run forest repeating acceptance defined means infinite run forests 
condition branch run forest infinitely accepting nodes 
case finite words alternation add expressive power nondeterminism 
precisely finite acceptance resp looping acceptance repeating acceptance afa expressive power finite acceptance resp looping acceptance repeating acceptance nfa mh 
gain alternation succinctness 
deal alternating analog etl atl defined analogously etl afa connectives replacing nfa connectives 
sigma ae formula define afa sigma ae 
semantics atl defined follows ffl iff atomic proposition ffl iff ffl iff define semantics automata connectives adapt definition finite run forests 
finite run forest sigma ae structure starting collection finite trees labeled atomic formulas satisfying conditions ffl set ff tree forest root labeled 
ffl internal node depth labeled sigma set ae ff child labeled 
run forest accepting accepting leaf 
accepts accepting run forest notice difference definitions run forests afa afa formulas 
run forest afa spawned automata read input 
case run forests afa formulas possible argument afa connective holds point structure essentially afa read complete description states input letter afa formulas read partial description states input formula 
believe definition appropriate context 
furthermore shown standard definition run forests afa causes exponential increase complexity logic 
define satisfaction automata connectives ffl accepting run forest starting clearly atl expressive etl restrict formulas positive disjunctions atl reduces etl exponential translation atl etl interest logic twofold 
translation atl etl causes exponential blow may expect atl higher complexity etl surprisingly complexity 
study afa connectives reveals full power techniques 
theorem 
atl formula built set atomic propositions rop construct buchi automaton alphabet rop size jgj accepts exactly sequences satisfying 
satisfiability problem atl complete pspace 
proof prove claim second claim follows section 
proof parallels section 
formula construct automaton cross product local automaton eventuality automaton 
notion closure similar section 
atl formula cl defined follows ffl cl ffl cl cl ffl cl cl ffl cl cl ffl cl cl ffl cl cl ffl cl cl hintikka sequences atl formulas defined similarly section conditions 
need technical definition state conditions 
cl sigma ae define mapping oe cl oe ft sigma ae conditions cl mentioned assume sigma ae 
new conditions pi exists mapping cl ffl ffl set ff ffl oe pi 
pi oe pi exists ff pi local automaton local automaton cl cl ae cl 
transition relation ae ae iff ffl iff ffl iff ffl ffl oe exists ff set starting states consists sets eventuality automaton eventuality automaton set subword automaton ae cl ae 
transition relation ae ae iff ffl ffl atomic oe ff deal alternating analog etl atl defined analogously etl afa connectives replacing nfa connectives 
define semantics automata connectives atl need definition infinite run forest sigma ae structure starting collection infinite trees labeled states negation states satisfying conditions ffl branches infinite 
ffl set ff tree forest root labeled 
ffl node depth labeled sigma set ae ff child labeled 
define satisfaction automata connectives atl ffl infinite run forest starting clearly atl expressive etl restrict formulas positive disjunctions atl reduces etl exponential translation atl etl proof theorem similar proof theorem left reader 
theorem 
atl formula built set atomic propositions rop construct buchi automaton alphabet rop size jgj accepts exactly sequences satisfying 
satisfiability problem atl complete pspace 
describe alternating analog etl recall accepting node run forest node labeled 
atl infinite run forest accepting branch infinitely accepting nodes 
satisfaction automata connectives atl defined ffl accepting infinite run forest starting mh shown alternation eliminated repeating acceptance automata exponential construction 
conjecture construction combined techniques prove analogue theorems nonlinear exponent exponential bound atl concluding remarks approaches extending ptl 
hp language extended regular operators corresponding concatenation kleene star 
pushes decision problem language nonelementary complexity 
furthermore show fine interplay different acceptance conditions considered 
si ptl extended quantifiers propositions 
extension complexity decision procedure nonelementary 
extension ptl closest discussed probably temporal calculus ptl extended fixpoint operators 
introduced ec see bkp bkp 
expressive power etl shown va pspace complete decision problem see bb 
interesting note result obtained extension automata theoretic techniques 
relation various types acceptance criteria finite automata framework propositional dynamic logic pdl fl 
reasoning computation paths consider pdl deterministic atomic program structures infinite sequences 
framework finite acceptance condition corresponds diamond construct fl looping acceptance condition corresponds loop construct hp repeating acceptance condition corresponds repeat construct hp 
follows adding looping repeating fixpoint quantification propositions change expressive power language render undecidable 
sharp contrast happens propositional dynamic logic general 
known pdl expressive pdl loop pratt see hs expressive pdl repeat hs expressive pdl fixpoint ko shown expressive pdl quantification 
language shown highly undecidable pi gamma complete 
noted automata theoretic techniques developed applicable propositional dynamic logic see va vw 
temporal logics discussed combined dynamic logic yield expressive process logics amenable automata theoretic methods vw 
note results interesting interpretation purely automata theoretic point view 
ability automaton operator nested automaton operator essentially equivalent ability automaton consult oracle 
automaton reaches certain states asks oracle accepts rest word move depends answer 
consider hierarchy 
class nondeterministic finite automata class nondeterministic finite automata oracles gamma class automata denotes class languages defined automata hierarchies depending finite looping repeating acceptance respectively 
results show hierarchies collapse equivalent complementation causes exponential blow expected complexity emptiness problem automata nonelementary 
results show problem logspace complete pspace types automata 
contrasted emptiness problem regular expressions complement ms 

wish fagin halpern rosner stockmeyer helpful comments 
grateful streett anonymous referees careful reviews 
ah alur henzinger real time logics complexity expressiveness proc 
th ieee symp 
logic computer science pp 

bb barringer temporal logic fixed points proc 
temporal logic specification barringer pnueli eds lecture notes computer science springer verlag pages 
bkp barringer kuiper pnueli compositional temporal approach csp language formal methods programming neuhold eds north holland pp 

bkp barringer kuiper pnueli really concurrent model temporal logic proc 
th acm symp 
principles programming languages st pp 

bbp barringer pnueli eds temporal logic specification lecture notes computer science springer verlag 
bl brzozowski equations regular languages finite automata sequential networks theoretical computer science pp 

bu buchi decision method restricted second order arithmetic proc 
internat 
congr 
logic method 
philos 
sci 
stanford university press pp 

ch choueka theories automata tapes simplified approach computer system sciences pp 

cks chandra kozen stockmeyer alternation acm pp 

ec emerson clarke characterizing correctness properties parallel programs fixpoints proc 
th int 
colloquium automata languages programming lecture notes computer science springerverlag pp 

es emerson sistla deciding full branching time logic information control pp 

fl fischer ladner propositional dynamic logic regular programs computer system sciences pp 

gabbay pnueli shelah temporal analysis fairness proc 
th acm symp 
principles programming languages las vegas pp 

ha harel order dynamic logic lecture notes computer science springer verlag ha harel dynamic logic handbook philosophical logic vol 
gabbay eds pp 

hp harel pratt nondeterminism logics programs proc 
th acm symp 
principles programming languages pp 

harel kozen parikh process logic expressiveness decidability completeness computer system science pp 
hp harel peleg process logic regular formulas theoretical computer science pp 

harel rosner vardi power bounded concurrency iii reasoning programs proc 
th ieee symp 
logic computer science pp 

hr halpern reif propositional dynamic logic deterministic structured programs theoretical computer science pp 

hs harel sherman looping vs repeating dynamic logic information control pp 

hs harel sherman propositional dynamic logic flowcharts information control pp 

jo jones space bounded reducibility combinatorial problems computer system science pp 

ka classification regular languages theoretical computer science pp 

ko kozen results propositional calculus theoretical computer science pp 

lad ladner application model theoretic games discrete linear orders finite automata information control pp 

lam lamport proving correctness multiprocess programs ieee trans 
soft 
eng 
se 
lan landweber decision problems automata math 
systems theory pp 

le succinct representation regular languages boolean automata theoretical computer science pp 

lichtenstein pnueli zuck glory past proc 
workshop logics programs brooklyn springer verlag lecture notes computer science pp 

mcn mcnaughton testing generating infinite sequences finite automaton information control pp 
meyer weak monadic second order theory successor elementary recursive proc 
logic colloquium lecture notes mathematics springer verlag pp 

mh miyano hayashi alternating automata words theoretical computer science pp 

mi milner calculus communicating systems lecture notes computer science springer verlag 
mss muller schupp weak alternating automata give simple explanation temporal dynamic logic decidable exponential time proc 
rd ieee symp 
logic computer science pp 

ms meyer stockmeyer non elementary word problems automata logic proc 
ams symp 
complexity computation april 
mp manna pnueli anchored version temporal framework linear time branching time partial order logics models concurrency de bakker de roever rozenberg eds lecture notes computer science springer verlag pp 

mw manna wolper synthesis communicating processes temporal logic specification acm trans 
programming languages systems pp 

mu muller infinite sequences finite machines proc 
th ieee symp 
switching circuit theory logical design new york pp 

accepting conditions automata languages theoretical computer science pp 

ni nishimura descriptively complete process logic acta informatica pp 

pn pnueli temporal logic programs proc 
th ieee symp 
foundations computer science providence pp 

pr pratt semantical considerations floyd hoare logic proceedings th ieee symposium foundations computer science october pp 

pr pratt models program logics proc 
th ieee symp 
foundation computer science san juan pp 

pr pratt near optimal method reasoning action computer system sciences pp 

pr pratt graphs understand pdl proc 
workshop logics programs kozen ed yorktown heights lecture notes computer science springer verlag pp 

pr pnueli rosner synthesis reactive module proc 
th acm symp 
principles programming languages austin pp 

rs rabin scott finite automata decision problems ibm journal research development pp 

sa safra complexity automata proc 
th ieee symp 
foundation computer science pp 

sc sistla clarke complexity propositional linear temporal logic acm pp 

sh shaw software specification languages regular expressions technical report eth zurich june 
si sistla theoretical issues design analysis distributed systems phd thesis harvard university 
st streett propositional dynamic logic looping converse elementarily decidable information control pp 

st streett personal communication 
sta staiger research theory languages electron 
inf 

pp 

sistla vardi wolper complementation problem buchi automata applications temporal logic theoretical computer science pp 

tb trakhtenbrot barzdin finite automata behavior synthesis north holland 
tho thomas star free regular sets sequences information control pp 

tho thomas combinatorial approach theory automata information control pp 

tho thomas automata infinite objects handbook theoretical computer science vol 

leeuwen ed elsevier pp 

vw vardi wolper 
automata theoretic techniques modal logic programs computer system sciences pp 

vw vardi wolper automata theoretic approach automatic program verification proc 
st ieee symp 
logic computer science boston pp 

va vardi taming converse reasoning way computations proc 
workshop logics programs brooklyn springer verlag lecture notes computer science pp 

va vardi automatic verification probabilistic concurrent finite state programs proc 
th ieee symp 
foundations computer science portland oct pp 

va vardi temporal fixpoint calculus proc 
th acm symp 
principles programming languages san diego pp 

vw vardi wolper process logic proc 
workshop logic programs lecture notes computer science springer verlag pp 

wa wagner regular sets information control pp 

wo wolper temporal logic expressive information control pp 

wo wolper synthesis communicating processes temporal logic specifications ph 
thesis stanford university 
wo wolper relation programs computations models temporal logic proc 
temporal logic specification barringer pnueli eds lecture notes computer science springer verlag pages 

