visibility octree 
data structure navigation brunet departament de inform universitat polit de catalunya describes visibility octree data structure accelerate navigation complex scenes 
conservative visibility algorithm computes hierarchically stores structure preprocessing stage 
visibility octree navigation main contribution ability provide effective control coarseness visibility approximation 
tests indoor ship scenes show visibility octree performs densely occluded environments 
previous focused interactive navigation complex polygonal models 
wide range applications nowadays requirements surpass expensive high graphics workstations 
name ship design architectural design virtual reality applications hundreds thousands millions polygons 
current graphics hardware able cope kind scenes interactive frame rates 
years navigation algorithms developed lessen limitations current workstations 
problem specified follows set static polyhedral objects dynamic viewpoint want compute set visible polygons feasible position 
computation done quickly constant logarithmic time 
ideal algorithm supported tic project author supported fpi de ciencia spanish ministry education science preprint submitted elsevier preprint th june take desired frame rate input able guarantee 
research area classified main families multiresolution algorithms image rendering visibility computation algorithms 
multiresolution techniques create simplified polygonal impostors object scene 
computer originals objects pixel contribution low 
algorithms render objects scene 
upper bound amount geometry save computer drawing number rendered objects remains constant 
hand image rendering techniques able condense large clusters objects simpler image rendered quickly represent cluster accurately 
main drawbacks visual artifacts huge memory requirements 
research field visibility computation characterized relaxation concept visibility 
redefinition set visible polygons viewpoint superset set real visible polygons 
algorithm pertains family weak visibility algorithms 
methods easily classified hierarchical buffer hierarchical occlusion map 
methods quadtrees store image space information 
main drawback hierarchical buffer need special hardware 
case indoor scenes weak visibility algorithms better performance hierarchical occlusion maps 
view frustum culling algorithms visibility definition polygon object visible iff inside view frustum 
order discard invisible polygons quickly hierarchical data structures store scene clark utilizes hierarchy bounding volumes baum octree 
authors consider hierarchical view frustum culling predecessor weak visibility computation 
teller preprocessed kd tree store scene :10.1.1.139.5144
preprocessing time associate user bounded sets convex occluders leaf kd tree 
sets occluders created criterion solid angle viewed points inside node 
set occluders corresponds set different viewing directions 
selected occluders need inside node kd tree nodes 
navigation time algorithm determines kd tree leaf node contains position user 
sets occluders associated selected 
navigation algorithm traverses kd tree decides kd tree node occluded selected occluders 
occlusion computed navigation time algorithm restrict number occluders employ order avoid overhead 
restriction bounds amount geometry culled 
hudson manocha method structured preprocessing stage line stage 
navigation computer stores scene hierarchy bounding boxes 
voxel structure model visibility space 
cell voxel space set potentially convex occluders associated 
occluders selected solid angle criterion 
navigation time algorithm builds shadow occluders associated current viewpoint voxel scene 
main difference teller independent structures visibility geometry 
share bound number occluders due fact occlusion computed line 
cohen build approximation visibility space partition voxel partition 
compute region visibility visibility single point 
algorithm casts rays vertices potential object vertices current visibility voxel 
single convex object intersects rays means potential occluded 
preprocess concluded voxel set objects associated 
set corresponds objects visible weak sense arbitrary viewpoint located inside node 
report significant improvement level hierarchy voxels employed 
size relationship levels left user decision 
wang compute region visibility 
uniform grid mixed octree quadtree data structure 
visual space partition considers location observer viewing direction 
means algorithm dimensional space 
behaviour restricts feasibility due memory costs 
matter fact empirical tests article compute octree 
visibility single node octree computed 
table summarizes works cited takes glance proposal 
cited algorithms require occluders convex row table 
second row shows entities visibility computed 
cohen computes visibility directly objects 
requires occluders convex 
third row refers visibility computation done 
algorithms high cpu demanding stages trivial navigational stages 
row occlusion detection refers method compute occlusions shows casting shadow volumes 
occluder selection row reflects occluders selected viewpoint 
teller hudson put limit avoid excessive overhead 
visibility octree uses box viewpoint size varies obtained degree culling 
rest compute occlusion possible occluders 
algorithms teller hudson take little profit large cells constant constant visibility 
cohen benefits level hierarchy parameters hierarchy manually tuned adaptive computation row 
real scene 
works bounded navigational space user allowed get 
teller cohen wang hudson visibility octree convex convex convex convex convex kind occlusion convex node node convex node convex convex node node node relation node object computation static static static static static dynamic dynamic occlusion plane ray casting shadow shadow shadow detection set number bounded unlimited unlimited bounded unlimited occluders occluder threshold threshold adaptive selection computation dimension adaptive manual automatic automatic computation scenes tested real random real real pseudo random simulated full partial partial full full navigational bounded bounded bounded bounded bounded universe table analysis prior sketch 
similar hudson manocha method approach uses separate data structures scene geometry hierarchy bounding boxes visibility octree 
compute visibility casting shadows 
visibility computations done completely preprocessing stage 
visibility octree adaptive data structure stores potentially visible sets terminal nodes 
uniform grid structures size depends nature scene 
octree computed top fashion 
compute node algorithm selects convex occluders 
scene computes set potentially visible polygons node region 
set small node subdivided occlusion expected 
main contributions algorithm adaptive nature adaptive selection occluders null computation requirements navigation time 
main difference proposed data structure adaptiveness octree visibility structure 
algorithm cohen requires user specify number levels size relationship 
octree adjusts automatically 
general presentation proposed algorithm follows section 
section presents empirical results order evaluate goodness visibility octree 
section concludes details 
theory notation due complexity visibility spatial partition fact want fast access data structure octree store visibility information 
data structure proved efficient areas computing science 
order octree compute store kind information efficient manner requirement fulfilled able compute visibility region 
clear efficiently natural definition visibility 
furthermore restrict occlusion due single convex occluder interesting property arises observer sets shadow computed exactly shadows points set 
words compute region shadows sampling 
state formally need introduce notation 
definition shadow point set fq pq ag pq segment follows naturally concept shadow set points 
definition shadow set set fq pq ag property shadows noticed okamura 
lemma convex set hyperplane separates segment proof 
follows immediately definition 
prove 
collinear holds trivially proof 
say pi supporting plane 
restrict pi convex 
consider points xp see existence guaranteed fact 
convex segment lies completely inside different edges triangle xp supporting line separates say point segment px completely inside triangle intersects point assure proof complete 

computing shadow segment left polyhedron right need result comes naturally previous 
lemma convex set hyperplane separates polyline proof 
prove induction number points polyline 
gamma gamma gamma gamma introduce key theorem theorem convex set plane separates closed bounded polyhedron vertices polyhedron proof 
just prove inclusion trivial 
say want see invisible vertex invisible point closed bounded segment px intersects face point see invisible iff say infinite lines supporting plane incident polyline formed edges segments interior extreme segments intersect points respectively point segment polyline se 
proof complete 
note necessary require convexity viewpoint set 
property allows compute region invisibility caused single convex occluder 
occluders compute region visibility intersecting respective visible sets 
visibility octree section details data structures proposed algorithm computation visibility octree 
explains navigation stage 
data structures proposed algorithm uses different data structures 
ffl list potential occluders 
prior computation octree convex objects scene large generate significant occlusion selected inserted list see subsection 
list pre processing stage computation visibility octree 
discarded run time 
ffl hierarchy bounding boxes 
preprocessing stage algorithm computes ary tree bounding boxes scene objects 
algorithm goldsmith salmon 
node hierarchy bounding boxes associated axis aligned box contains boxes children 
leaf nodes correspond bounding boxes scene objects 
tree node counter depicting number polygons contains 
ffl list computed samples 
sample binary search tree stores visibility information vertex object scene tree allows computer retrieve set objects scene occluded viewpoint located sets pointers nodes hierarchy bounding boxes 
sets implemented binary search trees improve intersection union operations 
list samples preprocessing stage discarded octree fully computed 
size list bounded trade memory speed 
ffl visibility octree 
node octree fields delta separating plane 
polygons scene split node 
polygon exist supporting plane stored separating plane node 
delta lists visible boxes 
list stores potentially visible boxes viewpoints side separating plane node 
delta pointers items list computed samples 
pointed sample stores visibility information vertices node 
node octree computed merging visibility information vertices 
nodes share vertices possible accelerate algorithm samples stored reuse 
computation visibility octree apart scene main input parameters maximum number polygons node maximum depth octree 
parameter directly related desired frame rate second amount available memory 
pre process stage computation visibility octree subdivided main steps 
occluder selection 
initial step list potentially occluders created 
algorithm selects objects scene match conditions convex second sufficiently large generate significant occlusion 
say area faces node maximum depth volume 
algorithm considers object large occluder volume bigger face surface greater 
computation hierarchy bounding boxes 
tree computed scene objects algorithm goldsmith salmon 
computation visibility octree 
key stage algorithm 
octree computed top 
computation node includes main steps sampling 
point visibility computed vertices node computed parent neighbour node 
non computed vertices algorithm selects occluders list potential occluders inside box size centered vertex 
initial size box parameter algorithm adjusted automatically computer top construction tree 
shadow generated selected occluders corresponding vertex sample created 
sample added list computed samples 
calculate shadow point convex occluder computer determines silhouette ways 
implementation selects faces visible convex done easily evaluating equations supporting planes faces checking signs 
traverses edges selected faces prunes shared different faces 
remaining edges silhouette edges 
silhouette edge jointly viewpoint defines plane shadow frustum 
frustum convex set planes suffices define 
testing point inside frustum done checking sign equations planes evaluated polygon polyhedra inside frustum iff vertices interior 
node visibility computation 
algorithm computes set objects scene fully partially contained current node 
searches polygon splitting node 
means effectively divided convex sets gamma segment endpoints gamma respectively intersection empty 
polygon exists supporting plane selected separating plane node 
separating plane divides vertices node disjoint sets positive set negative set 
sets treated separately separating plane exists set considered 
positive set contains vertices set invisible polygons positive side node set invisible polygons vertex due occlusion object gamma computed way 
sets gamma visible polygons side separating plane computed gamma gamma sets gamma simply separating plane existed define visibility node computed algorithm states ffl sets gamma small compatible desired frame rate say cardinalities specified threshold 
case octree node labeled leaf node tree subdivided 
ffl sets gamma sufficiently small desired frame rate visibility samples node vertices similar cardinalities clearly different 
case differences vertex visibilities obviously decreased node subdivision 
algorithm subdivides node keeps box size enlarges list potential occluders 
new valid occluders inside box having size larger subdivided node size 
ffl visibilities gamma sufficiently small desired frame rate visibility samples node vertices similar terms difference cardinalities 
case clear subdivision decrease node visibilities 
step test doubling box size enlarging list potential occluders occluders new box performed 
doubling visibilities sufficiently small node labeled leaf node desired frame rate reached 
node labeled leaf node target frame rate reached 
observe octree subdivision stops case small acceptable visibilities case large visibilities zones lack occluders 
hand set occluders adaptive algorithm decide increase set occluders enlarging size searching box reducing occluder size 
octree constructed post process performed order merge neighbour nodes similar visible sets 
basically done brother nodes large visibility sets 
run time navigation stage simplest part algorithm 
navigation virtual scene computer keeps track leaf node visibility octree containing viewpoint frame 
node determined computer calculates side separating plane viewpoint located 
corresponding list visible bounding boxes obtained clipped view frustum classical hierarchical view frustum culling algorithm 
mean std 
dev 
min max depth polygons table measures number visible polygons depth leaf nodes depth mean std 
dev 
min max table measures number visible polygons leaf nodes different depths 
histograms number leaf nodes level octree number visible polygons mean std 
dev 
hierarchical culling hierarchical culling visibility octree table measures number polygons sent hardware pipeline results tests performed silicon graphics mhz workstation 
computed visibility octree polygonal model part ship 
oil design applications require representations 
histograms number visible polygons leaf nodes different depths seventh level isolated better comprehension mean std 
dev 
hierarchical culling hierarchical culling visibility octree table measures number frames second interactive walkthroughs 
oil ships typically composed rooms provide environments occlusion techniques 
shows rooms tested model 
complete model rooms polygons took mb physical memory 
parameters octree set levels maximum depth polygons leaf node 
order keep memory usage low split computation octree pieces 
due nature octree simple 
mean cpu time seconds 
mean memory mb 
standard deviation mb maximum mb 
pieces get smaller number samples repeatedly computed total computation time increase 
important note memory requirements high computation size final octree smaller memory intensive data structure list samples 
fact final size complete octree test mb 
tables show measures depth leaf nodes number potentially visible polygons leaf nodes 
leaf nodes appear depths 
worst node visibility octree visible polygons culled significant scene 
table shows leaf nodes levels required threshold visible polygons 
deeper terminal nodes requirement fulfilled cases subdivision stopped lack occluders 
shows maximum number leaf nodes obtained level terminal nodes number visible polygons close required threshold 
shows visible polygon distributions different tree levels 
total number leaf nodes octree number voxels uniform grid resolution 
figures prove spatial efficiency visibility octree compared uniform grid 
performed random navigations measure actual frame ratio improvement 
paths traversed ship model 
tables show number polygons sent graphic pipeline obtained frame ratio 
figures obtained silicon graphics equipped infinite reality graphics card 
show usage visibility octree improved frame ratio factor 
standard deviation low improvement sustained 
seen mean number polygons sent pipeline significantly mean weak visible polygons node table 
behaviour due hierarchical view frustum culling 
today graphics hardware unable satisfy current user requirements navigation large scenes 
solve problem computer graphics community developed techniques grouped fam multiresolution algorithms image rendering weak visibility computation 
introduced new weak visibility algorithm advantages previous 
occlusions computed preprocessing stage 
computer increase number occluders amount culled geometry 
increase adaptively user interaction 
ii visibility octree adaptive data structure saves cpu time large zones similar visibility concentrates complicated zones 
iii memory requirements high visibility octree computed reasonably low computation 
worth noting cpu requirements execution time small 
preprocessing limited high expensive computers dynamic phase 
possible preprocess high computers navigate cheaper workstations 
preprocessing done considering graphics hardware low workstation 
address subjects currently visibility undefined user located outside octree 
want study visibility information user outside scene bounding box 
ii necessity occluder convexity shared previous weak visibility area restricts performance algorithm 
authors propose polyhedra decomposed convex parts processing 
approach increases considerably size scene 
resultant convex polyhedra small serve occluders 
want study algorithms compute family maximal size possibly intersecting convex polyhedra set small non convex occluders polyhedron occlude subset polygons occluded iii size octree affordable significantly decreased standard compression techniques store octree 
cpu remains inactive navigation idle cpu cycles decompress current octree node 
want analyze effect different existent compression methods 

view room oil authors anonymous reviewers useful comments 
daniel 
architectural walkthroughs portal textures 
ieee visualization october 
cignoni scopigno 
comparison mesh simplification algorithms 
computer graphics 
james clark 
hierarchical geometric models visible surface algorithms 
communications acm october 
daniel cohen dan halperin eyal 
conservative visibility strong occlusion partitioning densely occluded scenes 
computer graphics forum 
seth teller 
temporally coherent conservative visibility 
proceedings twelfth annual symposium computational geometry pages new york may 
acm press 
seth teller 
real time occlusion culling models large occluders 
proceedings symposium interactive graphics pages 
acm press april 
baum 
interactive viewing large geometric data bases multiprocessor graphics workstations 
siggraph course notes parallel algorithms architectures image generation volume pages 
goldsmith salmon 
automatic creation object hierarchies ray tracing 
ieee computer graphics applications may 
ned greene michael kass gavin miller 
hierarchical buffer visibility 
computer graphics proceedings annual conference series pages 
hudson manocha cohen lin hoff zhang 
accelerated occlusion culling shadow 
proceedings thirteenth annual symposium computational geometry pages june 
okamura 
shading models point linear sources 
acm transactions graphics april 
carlos isabel brunet 
data structures algorithms navigation highly polygon populated scenes 
technical report lsi universitat polit de catalunya 
dagstuhl seminar hierarchical methods computer graphics may 
francois george drettakis benoit 
efficient impostor manipulation real time visualization urban scenery 
computer graphics forum 
wang bao peng 
accelerated walkthroughs virtual environments visibility preprocessing simplification 
computer graphics forum 
zhang dinesh manocha tom hudson kenneth hoff iii 
visibility culling hierarchical occlusion maps 
siggraph conference proceedings pages 
acm siggraph addison wesley august 

