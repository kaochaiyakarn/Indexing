notation describing inverse multiple functions functions multiple arguments 
technique notation program written pure lisp automatically deriving program computes inverse function program 
technique differs previous methods heuristics invert conditionals 

applications useful compute inverse program find program feeding output original program input new program produces original input 
application programming specification define program compute square root number equation supplying actual iterative method solving equation 
application program inversion debugging 
program erroneous result step backwards program trace source error 
third application transforming input domain program known technique multiplying polynomials performing fft get result back original domain needs find inverse transformation 
methods suggested performing inversion 
unfortunately suffer defects 
mccarthy suggests generate test approach correctly find inverse exists computationally infeasible determine inverse unique 
dijkstra provides technique inverting programs symbolically requires programmer provide inductive assertions conditional loop statements 
korf suggests method automatically provides assertions recursions derived method guaranteed founded 
efforts gone inverting prolog differs inverting programming languages prolog procedural declarative 
methods inverting procedural languages useful prolog reverse necessarily true 
suggests method providing assertions automatically heuristic methods 
method find inverse program correctly terminate output original program input 
addition inverse case original function principle inverse inverted recover original program 
method described implemented maclisp program 
program able derive inverse append shown detail version reverse unary integer negation defined recursively add sub small programs 
example unary negation especially interesting case korf method unable find inverse existence recursive clauses definition 
heuristic approach program inversion david eppstein computer science department columbia university new york 
inversion multiple functions multiple arguments usual definition inverse function function unfortunately notation lend inversion functions argument 
instance lisp programming language true car cons cdr cons intuitively thinks car cdr inverses cons function call cons hand express relation extend multiple arguments multiple functions assume definition converse similarly holds 
similarly true cons car cdr true 
definition inversion say cons inverts car cdr 
general say list functions fun arguments inverts list functions arguments xj yi set equations fun 
xm fun 
xm yn fun 
xm simultaneously hold inverse set equations inv 
yn inv 
yn 
yn xm simultaneously hold 
note relationship symmetric inverting inverses list functions produces original list 
requirement functions number arguments turns problem necessary add dummy arguments functions need 
attempting invert programs need inverses primitive operations language inverting 
lisp fact cons inverts car cdr add inverts sub 
define arithmetic list manipulation functions usually lisp implementation 

inversion method perform inversion search state space program descriptions 
state set facts composed left side right side set preconditions 
fact interpreted meaning preconditions hold left side equal right side 
operators move state state conditional expansion precondition replacement expression inversion conditional contraction 
example suppose want invert function append 
want find programs result call append return second arguments 
unfortunately possible pairs arguments produced result append need introduce auxiliary function distinguish 
function returns length argument ignores second call flength 
call arguments append names firstn reasons shall see 
definitions original functions give initial state append cond null firstn cons car firstn append cdr firstn flength cond null firstn add flength cdr firstn atoms left sides correspond call functions defined right side correspond arguments calls unbound variables 
initial facts preconditions left sides atomic 
similarly define goal state sets preconditions empty right sides atomic 
new atoms introduced transformations atom occur side facts original arguments names inverse programs original program names inverse arguments 
facts current state preconditions right side conditional expression 
perform transformations facts separate conditional parts preconditions 
conditional expansion operator replaces fact right side conditional expression facts corresponding case predicate condition true corresponding case false 
applying facts initial state produces new state null firstn append flength null firstn append cons car firstn append flength add flength note state consists facts precondition null null firstn firstn null firstn 
preconditions combined display merely sake brevity 
final inverse programs need conditional expression determine path original programs took 
way think preconditions current state functions arguments original functions replace new functions arguments inverse functions true exactly old ones 
replacement heuristic portion inversion general possible preconditions analytic method finding 
details find new precondition described case notice flength zero firstn null 
new precondition precondition replacement operator 
note simply replaced occurrences old precondition new derive useless fact zerop flength flength produce zerop flength nil firstn complete derivation 
account come new transformed state zerop flength append nil firstn zerop flength append cons car firstn append cdr firstn flength add flength cdr firstn derivation goes sequence expression inversions pulling functions right side facts left 
process completely mechanical somewhat complicated go step time 
notice call add outer call right side fact 
invert call sub state zerop flength append nil firstn zerop flength append cons car firstn append cdr firstn sub flength flength cdr firstn case inverted function function total number facts state didn change 
invert cons car cdr get facts zerop flength append nil firstn zerop flength car append car firstn cdr append append cdr firstn sub flength flength cdr firstn inversions done functions knew inverses 
invert recursive calls original functions recursive calls new inverses 
case functions arguments replace facts new facts 
inversion split steps new fact parts old facts 
note arguments calls match exactly changed result flength second argument recursive call different impossible complete inversion 
performing inversion get new state zerop flength append nil firstn zerop flength car append car firstn firstn cdr append sub flength cdr firstn cdr append sub flength right sides atomic atomic inversion car cdr cons 
zerop flength append nil firstn zerop flength cons car append firstn cdr append sub flength firstn cdr append sub flength goal state remaining task remove preconditions 
achieved conditional contraction operator acts inversely conditional expansion takes facts opposite preconditions identical right sides combines fact having left side conditional expression evaluating previous left sides depending precondition true 
careful accept preconditions terms inverse arguments come defined program reason precondition replacement 
applications conditional contraction produce goal state cond zerop flength nil cons car append firstn cdr append sub flength firstn cond zerop flength append cdr append sub flength 
precondition replacement method provides framework inversion need heuristics framework finding replacement preconditions 
heuristic effective simple recursions uses sort data type system 
objects members type top divided integers nil 
data type systems types corresponding major subsets integers negative numbers positive numbers zero unions pairs sets 
main requirement type system form lattice need type bottom object belongs 
functions assigned types contain possible return values 
cons returns cons add returns number car cdr return type top 
type function function mapping function input types output type simplicity done add sub add return positive numbers argument non negative 
list new functions inverted list inverse functions inversions calculate types simple relaxation process start assuming return type bottom 
evaluating types expressions defining making assumptions types arguments arrive new assignment types iterate function type changed iteration 
definition flength example iteration result type zero base clause bottom recursive clause combine type zero 
second iteration gives base clause type recursive clause known return positive numbers new type non negative numbers 
adding non negative number adding zero returns positive number third iteration type doesn change 
final type flength non negative numbers 
complicated recursion preliminary types recursive clauses cause new types change iterations depth type lattice 
type system provide replacement preconditions 
done looking facts identical left sides identical preconditions particular precondition wish replace true fact false 
calculate types right sides facts intersection types bottom replace precondition test membership common left side types 
append example fact precondition firstn true positive zero firstn false 

main obstacle inversions current implementation inability heuristic described find replacement preconditions functions argument 
effort put methods finding complex predicates prove fruitful heuristics notice function inverted arithmetic list processing tailor search accordingly 
inversion append needed introduce auxiliary function 
append recurs linearly simply count number recursive calls sufficient 
done automatic detection need auxiliary function automatic generation function need detected 
thought program transformation world gone idea macsyma system computer programs 
representations operators appear useful domains inversion study applicable general program transformation system incorporated system 
advisor rich korf helpful discussions suggestions 
research sponsored part national science foundation student fellowship defense advanced research projects agency contract 
dijkstra program inversion program construction 
springer verlag berlin 
korf richard inversion applicative programs proc 
ijcai 
vancouver 
mccarthy john inversion functions defined turing machines shannon mccarthy editors automata studies 
princeton university press princeton 
scherlis expression procedures program derivation ph thesis department computer science stanford university 
shoham yoav knowledge inversion proc 
aaai 
austin texas 
sharon invertibility logic programs proc 
fourth workshop automatic deduction 
austin texas 
