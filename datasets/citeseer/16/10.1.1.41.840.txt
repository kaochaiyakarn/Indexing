notions computation monads eugenio moggi calculus considered useful mathematical tool study programming languages programs identi ed terms :10.1.1.26.2787
goes uses conversion prove equivalence programs gross simpli cation introduced programs identi ed total functions values values may applicability theoretical results :10.1.1.26.2787
introduce calculi categorical semantics computations provide correct basis proving equivalence programs wide range notions computation :10.1.1.26.2787
logics reasoning programs particular proving equivalence programs :10.1.1.26.2787
consolidated tradition theoretical computer science identify programs closed terms possibly containing extra constants corresponding features programming language consideration :10.1.1.26.2787
semantic approaches proving equivalence programs operational approach starts operational semantics partial function mapping program closed term resulting value induces congruence relation open terms called operational equivalence see plo :10.1.1.26.2787
problem prove terms operationally equivalent :10.1.1.26.2787
denotational approach gives interpretation programming language mathematical structure intended model :10.1.1.26.2787
problem prove terms denote object intended model :10.1.1.26.2787
logical approach gives class possible models programming language :10.1.1.26.2787
problem prove terms denotes object possible models :10.1.1.26.2787
operational denotational approaches give theory operational equivalence set th formulas valid intended model respectively :10.1.1.26.2787
hand logical approach gives consequence relation ax formula true models set formulas ax deal di erent programming languages functional imperative non deterministic uniform way simply changing set axioms ax possibly extending language new constants :10.1.1.26.2787
relation possible give sound complete formal system th ed cases :10.1.1.26.2787
take starting point proving equivalence programs theory conversion identi es denotation program procedure type total function identi cation completely behaviours nontermination non determinism side ects exhibited real programs :10.1.1.26.2787
proceed follows :10.1.1.26.2787
take category theory general theory functions develop top categorical semantics computations monads :10.1.1.26.2787
research partially supported eec joint collaboration contract st edb :10.1.1.26.2787

consider simple formal systems matching categorical semantics computation :10.1.1.26.2787

extend stepwise categorical semantics formal system order interpret richer languages particular calculus :10.1.1.26.2787

show may consider monads toposes exploit fact establish conservative extension results :10.1.1.26.2787
methodology outlined inspired sco followed ros mog obtain calculus :10.1.1.26.2787
view category theory comes logically calculus led consider categorical semantics computations rst modify directly rules conversion get correct calculus :10.1.1.26.2787
related operational approach nd correct calculi operational equivalence rst considered plo call value call name operational equivalence :10.1.1.26.2787
approach extended similar methodology consider features computations nondeterminism see sha side ects continuations see ff :10.1.1.26.2787:10.1.1.26.2787
calculi operational considerations calculus sound complete operational semantics program value operational semantics provably equivalent value necessarily calculus weak proving equivalences programs :10.1.1.26.2787
previous axiom systems proving equivalence programs side ects shown importance constructor see mas mt mt :10.1.1.26.2787:10.1.1.26.2787
framework computational lambda calculus importance apparent :10.1.1.26.2787
denotational approach may suggest important principles point induction see sco gmw developing semantics mathematical structures term models give clear criteria single general principles properties satis ed model :10.1.1.26.2787
theory heart denotational semantics domain theory see gs mos focused mathematical structures giving semantics recursive de nitions types functions see sp structures relevant better understanding programming languages overlooked :10.1.1.26.2787:10.1.1.26.2787
identify structures monads probably just waiting discovered :10.1.1.26.2787
categorical semantic computations strongly uenced reformulation denotational semantics category cpos possibly bottom partial continuous functions see plo categories partial morphisms ros mog :10.1.1.26.2787
generalises categorical account partiality notions computations partial cartesian closed categories turn special case models see de nition :10.1.1.26.2787
type theoretic approach partial functions computations proposed cs cs introducing type constructor intuitive meaning set computations type categorical semantics similar idea :10.1.1.26.2787
constable smith adequately capture general axioms computations notion model untyped partial applicative structure accounts partial computations :10.1.1.26.2787
categorical semantics computations basic idea categorical semantics order interpret programming language category distinguish object values type object ta am trying nd calculus come fact notion cartesian closed category late developing eilenberg kelly relevant argument shall try explain words section look rst :10.1.1.26.2787
computations type take denotations programs type elements ta :10.1.1.26.2787
particular identify type object values type obtain object computations type applying unary type constructor call notion computation abstracts away type values computations may produce :10.1.1.26.2787
choices ta corresponding di erent notions computations :10.1.1.26.2787
example give notions computation category sets :10.1.1.26.2787
partiality ta 
diverging computation nondeterminism ta fin side ects ta set states set stores set input output sequences exceptions ta set exceptions continuations ta set results interactive input ta set characters :10.1.1.26.2787
explicitly ta set branching trees nite branches labelled leaves interactive output ta :10.1.1.26.2787
explicitly ta isomorphic examples category cpos denotational semantics various programming languages see sch gs mos :10.1.1.26.2787:10.1.1.26.2787
focusing speci want nd general properties common notions computation impose requirement programs form category :10.1.1.26.2787
aim section convince reader sequence informal requirement amounts say part kleisli triple category programs kleisli category triple :10.1.1.26.2787
de nition man kleisli triple category triple obj obj ta obj ta tb tb equations hold id ta tb tb tc :10.1.1.26.2787
kleisli triple satis es mono requirement provided mono intuitively inclusion values computations cases mono extension function values computations function computations computations rst evaluates computation applies resulting value :10.1.1.26.2787
summary 
ta 
tb ta 
tb order justify axioms kleisli triple rst introduce category morphisms correspond programs :10.1.1.26.2787
proceed analogy categorical semantics terms types interpreted objects terms type parameter free variable type interpreted morphisms denotation programs type supposed elements tb programs type parameter type ought interpreted morphisms codomain tb domain alternatives ta depending parameters type identi ed values computations type choose rst alternative entails second :10.1.1.26.2787
computations type values type ta :10.1.1.26.2787
take tb :10.1.1.26.2787
remains de ne composition identities show satisfy unit associativity axioms categories :10.1.1.26.2787
de nition kleisli triple kleisli category de ned follows objects set morphisms tb identity ta followed tc :10.1.1.26.2787
natural take identity category maps parameter viewed computation :10.1.1.26.2787
similarly composition simple explanation terms intuitive meaning fact :10.1.1.26.2787
tb 
tc 
tc followed parameter program rst evaluates program feed resulting value parameter point give simple justi cation axioms kleisli triples equivalent unit associativity axioms tb tb tb tc td :10.1.1.26.2787
example go notions computation example show part suitable kleisli triples :10.1.1.26.2787
partiality ta inclusion :10.1.1.26.2787
tb 
nondeterminism ta fin singleton map :10.1.1.26.2787
fag tb ta side ects ta map 
ha si tb ta ha exceptions ta injection map :10.1.1.26.2787
inl tb inr inl continuations ta map :10.1.1.26.2787
tb ta interactive input ta maps tree consisting leaf labelled tb ta tree obtained replacing leaves labelled tree interactive output ta map :10.1.1.26.2787
ai tb hs ai hs bi hs bi concatenation followed kleisli triples just alternative description monads :10.1.1.26.2787
formers easy justify computational perspective widely literature category theory advantage de ned terms natural transformations suitable manipulation :10.1.1.26.2787
de nition mac monad category triple functor id natural transformations diagrams commute ta ta ta ta id ta id ta ta ta proposition man correspondence kleisli triples monads :10.1.1.26.2787
proof kleisli triple corresponding monad extension function endofunctor id ta conversely monad corresponding kleisli triple restriction functor objects tf tb :10.1.1.26.2787
general categorical semantics partial maps category equipped dominion see ros reformulated terms kleisli triple satisfying additional properties lifting inclusion functor category partial maps right adjoint characterised natural isomorphism :10.1.1.26.2787
mismatch disappears considering partial cartesian closed categories :10.1.1.26.2787
simple languages monads section consider formal systems motivated di erent objectives reasoning programming languages reasoning programs xed programming language :10.1.1.26.2787
reasoning programming languages di erent monads simplicity assume category programming language main aim study relate :10.1.1.26.2787
natural base formal system metalanguage category treat monads unary type constructors :10.1.1.26.2787
reasoning programs monad programming language xed main aim prove properties programs :10.1.1.26.2787
case obvious choice term language programming language naturally interpreted kleisli category :10.1.1.26.2787
regard metalanguage fundamental :10.1.1.26.2787
fact models general don satisfy mono requirement interpretation programs programming language de ned simply translation suitable extension metalanguage :10.1.1.26.2787
pointed mono requirement axiomatised metalanguage need conditional equations existence assertions translated formulas metalanguage need existentially quanti ed formulas section explain correspondence theories simple programming language categories monad satisfying mono requirement :10.1.1.26.2787
programming languages give translation suitable extension metalanguage :10.1.1.26.2787
way issues call value versus call name ect translation metalanguage :10.1.1.26.2787
categorical logic common practice identify theory category additional structure correspondence models category additional structure structure preserving functors see kr identi cation originally proposed lawvere showed algebraic theories viewed categories nite products :10.1.1.26.2787
section give class theories viewed categories monad category monad equivalence categories monad theories :10.1.1.26.2787
reformulation terms theories suitable formal manipulation appealing unfamiliar category theory :10.1.1.26.2787
advantages having alternative presentation monads :10.1.1.26.2787
instance natural extensions syntax may suggest extensions categorical structure may immediate motivate justify exploit section :10.1.1.26.2787
section take programming language perspective establish correspondence theories equivalence existence assertions simple programming language categories monad satisfying mono requirement mono starting point take sorted monadic equational logic primitive sorted equational logic monadic theories equivalent categories additional structure :10.1.1.26.2787
sorted monadic equational logic language formal system sorted monadic equational logic parametric signature set base types unary function symbols language types type terms equations de ned formation rules type base type var type eq uniqueness follows mono requirement :10.1.1.26.2787
ls stronger relation sought theories categories additional structure equivalence category theories translations category small categories additional structure structure preserving functors :10.1.1.26.2787
case typed calculus instance equivalence theories cartesian closed categories requires modi cation de nition theory allows equations terms equations type expressions :10.1.1.26.2787
rule syntax semantics type var type id eq table interpretation sorted monadic equational language terms sorted monadic equational logic exactly free variable declared context occurs exactly equations terms free variable :10.1.1.26.2787
interpretation language category parametric interpretation symbols signature de ned induction derivation formedness types terms equations see table general pattern interpretation base type object interpretation unary function morphism similarly interpretation term interpretation assertion case just equation true false :10.1.1.26.2787
interpretation equations standard :10.1.1.26.2787
want consider complex assertions formulas rst order logic interpreted subobjects particular equality interpreted diagonal :10.1.1.26.2787
formal consequence relation set equations generated inference rules equivalences re simm trans congruence substitutivity see table :10.1.1.26.2787
formal consequence relation sound complete interpretation language categories equation formally derivable set equational axioms interpretations satisfying axioms satisfy equation :10.1.1.26.2787
soundness follows admissibility inference rules interpretation completeness follows fact theory set equations closed inference rules set equations satis ed canonical interpretation category viewed category :10.1.1.26.2787
de nition monadic equational theory category de ned follows objects base types morphisms equivalence classes terms equivalence relation induced theory :10.1.1.26.2787
re symm trans congr subst table inference rules sorted monadic equational logic composition substitution identity correspondence opposite direction category additional structure viewed theory theory language equivalent categories additional structure :10.1.1.26.2787
case monadic equational theories categories isomorphic :10.1.1.26.2787
sequel consider equational theories :10.1.1.26.2787
viewed categories way described monadic theories categories equipped additional structure depending speci nature theories consideration :10.1.1.26.2787
simple metalanguage extend sorted monadic equational logic match categories equipped monad equivalently kleisli triple :10.1.1.26.2787
consider monad conceptually straightforward monads :10.1.1.26.2787
rst step extend language :10.1.1.26.2787
done ways ecting correspondence theories monads choose presentation inspired kleisli triples speci cally introduce unary type constructor term constructors informally section :10.1.1.26.2787
de nition signature slightly modi ed domain codomain unary function symbol type just base types fact sorted monadic logic types base types :10.1.1.26.2787
interpretation language category kleisli triple parametric interpretation symbols signature de ned induction derivation formedness types terms equations see table :10.1.1.26.2787
add sorted monadic equational logic appropriate inference rules capturing axiomatically properties new type interpretation see table :10.1.1.26.2787
proposition theory simple metalanguage viewed category equipped kleisli triple ml ml ml rule syntax semantics ml type ml type ml type var ml type ml id ml ml ml ml ml ml ml eq ml ml ml table interpretation simple metalanguage ml ml ml ml ml ass ml ml ml ml ml ml ml ml ml table inference rules simple metalanguage proof show axioms kleisli triples valid :10.1.1.26.2787
validity axiom amounts derivability equation :10.1.1.26.2787
instance id valid provided ml derivable follows :10.1.1.26.2787
reader check equations corresponding axioms follow ass respectively :10.1.1.26.2787
simple programming language section take programming language perspective introducing simple programming language terms interpreted morphisms kleisli category monad :10.1.1.26.2787
metalanguage section programming language allow consider monad :10.1.1.26.2787
interpretation kleisli category indirectly translation simple metalanguage section mapping programs type terms type try establish correspondence equational theories simple programming language categories monad done metalanguage run problems way general recover establish correspondence theories equivalence existence assertions categories monad satisfying mono requirement mono object note ta mono ta id ta :10.1.1.26.2787
intended extension existence predicate computations type set computations form value type natural require mono interpret existence predicate subobject corresponding simple programming language parametric signature set base types unary command symbols :10.1.1.26.2787
stress interpretation unary command symbols unary function symbols call pl program term write equality computations type category kleisli triple satisfying mono requirement interpretation programming language parametric interpretation symbols signature de ned induction derivation formedness types terms equations see table pattern sorted monadic equational logic replaced interpretation base type object equivalently object interpretation unary command morphism equivalently morphism similarly interpretation program pl interpretation equivalence existence assertion truth value :10.1.1.26.2787
constructor play fundamental role operationally corresponds sequential evaluation programs categorically corresponds composition kleisli category substitution corresponds composition :10.1.1.26.2787
calculus treated syntactic sugar think right way proceed explains constructor sequential evaluation programs terms constructors available functional languages :10.1.1.26.2787
hand treated syntactic sugar involving primitive substitution collapsing computations values :10.1.1.26.2787
existence predicate inspired logic partial terms elements see sco mog important di erences strict pl pl admissible partial computations general :10.1.1.26.2787
certain notions computation may predicates computations worth considering existence predicate may specialised meaning instance rule syntax semantics pl type pl type pl type var pl type pl pl pl pl pl pl pl pl pl pl eq pl pl pl ex pl pl table interpretation simple programming language re pl pl symm pl pl trans pl pl pl congr pl pl pl type pl congr pl pl pl subst pl pl pl table general inference rules partial computation exists terminates non deterministic computation exists gives exactly result computation side ects exists change store :10.1.1.26.2787
programs translated terms metalanguage translation wellformed program pl term ml formed pl ml proof properties left reader :10.1.1.26.2787
de nition signature programming language signature metalanguage base types function command :10.1.1.26.2787
translation programs terms de ned induction raw programs inference rules deriving equivalence existence assertions simple programming language partitioned follows general rules see table terms denoting computations variables ranging values rules replace table sorted monadic equational logic rules capturing properties type term constructors see table interpretation programming language rules replace additional rules metalanguage table :10.1.1.26.2787
pl pl pl pl pl pl pl pl pl pl pl unit pl pl ass pl pl pl pl 
pl pl pl pl pl table inference rules simple programming language soundness completeness formal consequence relation interpretation simple programming language categories monad satisfying mono requirement established usual way see section :10.1.1.26.2787
step di ers view theory simple programming language set equivalence existence assertions closed inference rules category required structure :10.1.1.26.2787
de nition theory simple programming language category de ned follows objects types morphisms equivalence classes pl existing programs pl equivalence relation induced theory :10.1.1.26.2787
pl pl pl composition substitution pl pl pl identity pl order composition de ned essential consider equivalence classes existing programs simple programming language satis es restricted form substitutivity :10.1.1.26.2787
proposition theory simple programming language viewed category equipped kleisli triple satisfying mono requirement pl pl pl proof show axioms kleisli triples valid :10.1.1.26.2787
validity axiom amounts derivability existence equivalence assertion :10.1.1.26.2787
instance id valid provided pl pl derivable :10.1.1.26.2787
existence assertion follows immediately equivalence derived follows pl re pl unit pl pl trans :10.1.1.26.2787
leave reader derivation existence equivalence assertions corresponding axioms kleisli triples prove mono requirement implies pl derive pl pl pl pl rst assumption pl pl trans :10.1.1.26.2787
show canonical interpretation program pl category morphism pl interpretation establishes correspondence morphisms category morphisms kleisli category equivalence classes programs pl existing :10.1.1.26.2787
inverse correspondence maps morphism pl equivalence class pl pl pl derivable provided pl extending simple metalanguage far considered languages formal systems monadic terms having exactly free variable occurring :10.1.1.26.2787
section want extend languages formal systems allowing algebraic terms xn having nite number free variables occurring nitely times investigate ects interpretation structure theories viewed categories :10.1.1.26.2787
convenience relating theories categories additional structure allow types closed nite products particular typing context xn identi ed type :10.1.1.26.2787
general interpretation algebraic term xn category nite products morphism :10.1.1.26.2787
extension monadic equational logic algebraic terms equational logic theories correspond categories nite products :10.1.1.26.2787
introduce metalanguage extension simple metalanguage described section algebraic terms show theories correspond categories nite products strong monad monad natural transformation tb :10.1.1.26.2787
intuitively transforms pair value computation computation pair values follows tb :10.1.1.26.2787
ha yi understand category nite products monad interpret metalanguage natural transformation needed look interpretation expression ml ml ml typing context :10.1.1.26.2787
interpretations ml ml respectively interpretation typing context interpretation type interpretation ml ought morphism identity monad identity functor identity natural transformation computations get identi ed values :10.1.1.26.2787
case replaced simply hid general case table suggests composition kleisli category hid replaced hid hid type mismatch codomain hid domain tg :10.1.1.26.2787
natural transformation tb mediates objects de ned hid metalanguage nite products conjecture theories longer correspond categories nite products strong monad objects contexts envelope sco associate cartesian closed category untyped theory multicategories kleisli triple :10.1.1.26.2787
felt greater generality having products metalanguage worth mathematical complications :10.1.1.26.2787
de nition strong monad category explicitly nite products monad natural transformation tb ta ta ta tc tc tc id id tb id tb tb natural isomorphisms diagrams taken koc characterisation strong monads terms enriched categories see kel :10.1.1.26.2787
kock xes commutative monoidal closed category particular cartesian closed category setup establishes correspondence strengths st :10.1.1.26.2787
tb ta tensorial strengths tb endofunctor see theorem koc :10.1.1.26.2787
intuitively strength st action morphisms precisely st enriched endofunctor enriched hom object :10.1.1.26.2787
setting diagrams de nition meaning rst diagrams koc saying tensorial strength enriched endofunctor :10.1.1.26.2787
diagrams say id enriched natural transformations id enriched obvious way see koc :10.1.1.26.2787
purely categorical characterisation strong monads suggested plotkin terms indexed categories see jp :10.1.1.26.2787
characterisations instances general methodological principle studying programming languages logics categorically see mog studying complex language category cat small categories functors natural transformations may adequate may replace cat di erent category objects captures better fundamental structure language fundamental structure modelled categorical concepts monads categorical concept expect notions computations complex language modelled monads suitable category :10.1.1.26.2787:10.1.1.26.2787
rst characterisation takes commutative monoidal closed structure laf see model fragment linear logic enriched :10.1.1.26.2787
strong monad cartesian closed category just monad category enriched categories :10.1.1.26.2787
second characterisation takes class display maps hp model dependent types de nes indexed category strong monad category nite products amounts monad category indexed categories class rst projections corresponding constant type dependency :10.1.1.26.2787
general natural transformation explicitly part additional structure :10.1.1.26.2787
uniquely determined may exists cartesian structure points :10.1.1.26.2787
proposition uniqueness monad category nite products points implies strong monad unique family morphisms points tb ha bi id unique morphism terminal object :10.1.1.26.2787
proof note ha bi id points tb points :10.1.1.26.2787
show strong monad satis es equation :10.1.1.26.2787
naturality rst diagram de nition diagram commutes ha bi tb hid bi id tb id tb tb tb isomorphism inverse :10.1.1.26.2787
id composite morphisms ha bi hid bi tb idb coincide :10.1.1.26.2787
second composition rewritten id :10.1.1.26.2787
second show unique family morphisms satisfying equation strong monad :10.1.1.26.2787
amount prove natural transformation diagrams de nition commute :10.1.1.26.2787
proof tedious diagram chasing relies having points :10.1.1.26.2787
instance prove ta show hid ai hid ai ta points example go monads example show tensorial strength :10.1.1.26.2787
partiality ta ha bi nondeterminism ta fin fha cg side ects ta hb hha bi exceptions ta inr inr inl inl ha bi continuations ta ha bi interactive input ta tree obtained replacing leaves labelled leaf labelled ha bi interactive output ta hs bi hs ha bii :10.1.1.26.2787
tensorial strength induces natural transformation ta tb ta tb tb tb natural isomorphism morphism correct domain codomain interpret pairing computation type type obtained rst evaluating rst argument second ta tb :10.1.1.26.2787
hx yi dual notion pairing ta tb see koc amounts rst evaluating second argument rst :10.1.1.26.2787
interpretation formal system position give metalanguage algebraic terms interpretation inference rules :10.1.1.26.2787
de nition metalanguage interpretation metalanguage category terminal object binary products strong monad parametric interpretation symbols signature de ned induction derivation formedness types see table terms equations see table :10.1.1.26.2787
finite products interpret contexts variables de ned induction inference rules metalanguage see table divided groups general rules sorted equational logic rules nite products rules rule syntax semantics ml type ml type ml type ml type ml type ml type ml type ml type xn table interpretation types metalanguage proposition theory metalanguage viewed category equipped nite products strong monad tensorial strength ml proof similar proposition metalanguage algebraic terms straightforward add data types characterised universal properties extend categorical semantics accordingly instance want function spaces simply require category metalanguage interpreted exponentials add inference rules simply typed calculus see table metalanguage :10.1.1.26.2787
programming language perspective situation delicate :10.1.1.26.2787
instance semantics functional types re ect choice calling mechanism call value procedure type expects value type computes result type interpretation tb call name procedure type expects computation type evaluated needed computes result type interpretation tb ta cases exponentials needed interpret functional types programming language form tb analogy partial cartesian closed categories exponentials required exists see mog ros adopt de nition model dicult step extending metalanguage combination dependent types computations currently investigation :10.1.1.26.2787
call need simple categorical semantics environment expression evaluated may undergo evaluation :10.1.1.26.2787
rule syntax semantics var ml type xn hi hg ml ml ml ml ml ml ml hid eq ml ml ml table interpretation terms metalanguage re symm trans congr subst inference rules sorted equational logic hi rules product types ml ml ml ml ml ass ml ml ml ml ml ml ml ml ml table inference rules metalanguage app ee ex dv table rules function spaces de nition model category nite products strong monad satisfying mono requirement mono exponential tb de nition model generalises sense viewed model :10.1.1.26.2787
analogy exponentials exponential de ned giving isomorphism tb natural refer mog interpretation call value programming language model corresponding formal system calculus :10.1.1.26.2787:10.1.1.26.2787
strong monads topos section show far monads strong monads concerned assume topos see theorem :10.1.1.26.2787
proof theorem involves nonelementary notions category theory postpone discussing applications particular emphasis extensions metalanguage conservative extension results :10.1.1.26.2787
take formal system toposes type theory described ls sorted intuitionistic higher order logic equality set types satisfying closure properties terminal object natural number object subobject classi er types type power object pa type types binary product function space types type predicate fx aj type :10.1.1.26.2787
notation introduce notational conventions formal systems ml metalanguage algebraic terms set types closed terminal object binary products ta ml extension ml function spaces interpreted exponentials hml type theory described see ls extended objects computations ta pl programming language algebraic terms see mog pl extension pl function spaces interpreted exponentials called calculus mog :10.1.1.26.2787:10.1.1.26.2787
de nition say formal system formal consequence relation conservative extension provided restriction theorem hml conservative extension ml ml particular ml conservative extension ml lambek scott require closure function spaces subsets fx aj instance case ml elements formed equality judgements ml exists derivation assumptions proof rst result follows theorem implies model ml yoneda embedding maps interpretation ml term interpretation faithfulness yoneda embedding implies ml terms interpretation interpretation second result follows yoneda embedding preserves function spaces :10.1.1.26.2787
third conservative extension result follows immediately rst :10.1.1.26.2787
result means think computations naively terms sets functions provided treat intuitionistically full apparatus higher order intuitionistic logic expressive sorted equational logic :10.1.1.26.2787
giving conservative extension result programming language express mono requirement equivalence existence hml idea extend translation pl terms ml terms de nition exploit increased expressiveness hml ml axiomatise mono requirement translate existence equivalence assertions see mono requirement mono axiomatised mono requirement equaliser axiomatised mono axiom :10.1.1.26.2787
translation extended assertions functional types follows theorem hml mono type plg built base types ta conservative extension pl translation :10.1.1.26.2787
similarly hml mono type plg built base types ta conservative extension pl translation :10.1.1.26.2787
proof proof proceeds previous theorem :10.1.1.26.2787
additional step show type pl pl axiom mono holds assumption satis es mono requirement :10.1.1.26.2787
interpretation yc interpretation axiom mono holds provided yc mono :10.1.1.26.2787
mono mono requirement yc mono preserves monos :10.1.1.26.2787
theorem types programming language satisfy mono requirement :10.1.1.26.2787
hml mono type hml conservative extension pl pl :10.1.1.26.2787
lemma monad topos satisfying mono requirement satis es requirement :10.1.1.26.2787
proof see lemma page bw :10.1.1.26.2787
words type axiom derivable hml set axioms mono type hml general topos mono requirement entail requirement easily de ne strong monads heyting algebra satisfy mono requirement just take element heyting algebra :10.1.1.26.2787
terms formal consequence relation means hml mono requirement existence assertion pl derivable pl derivation possible pl know hml requirement conservative extension pl requirement pl conservative extension pl language combines computations higher order logic hml ideal framework program logics go proving equivalence programs hoare logic partial correctness imperative languages :10.1.1.26.2787
hml ml pl describe programming language introducing additional constant axioms :10.1.1.26.2787
ml pl constants correspond program constructors instance lookup tu location produces value location current store update changes current store assigning value bool ta ta ta bool new tl returns newly created location read tu computes value reading input write writes value output :10.1.1.26.2787
hml describe program logic adding constants ta corresponding properties computations :10.1.1.26.2787
example monad non deterministic computations see example de ne predicate may ta may true value possible outcome computation :10.1.1.26.2787
uniform way de ning may predicate type :10.1.1.26.2787
predicate set note may :10.1.1.26.2787
may de ned 
previous example suggests predicates de ned uniformly computations type better described terms modal operators relating computation truth values truth value :10.1.1.26.2787
possibility investigated depth give tentative de nition :10.1.1.26.2787
de nition monad topos modal operator algebra id subobject classi er commutativity diagrams expressed metalanguage :10.1.1.26.2787
consider examples non examples modal operators :10.1.1.26.2787
example monad non deterministic computations see example modal operators nondeterministic computation type predicate term type true possible results satisfy :10.1.1.26.2787
monad computations side ects see example operator express hoare triples exists fs operator satisfy second equivalence direction valid :10.1.1.26.2787
predicates storable values computation type locations :10.1.1.26.2787
intended meaning triple fp initial state content satis es nal state executing content satis es :10.1.1.26.2787
intended meaning expressed formally terms modal operator program constructors lookup update follows update lookup ta tb tb derived operation free state main theorem outline proof :10.1.1.26.2787
doing assume reader familiar non elementary concepts category theory :10.1.1.26.2787
theorem small category topos presheaves yoneda embedding monad exists monad diagram commutes equations hold ya ya strong monad exists natural transformation strong monad equation holds ya yb implicitly assume yoneda embedding preserves nite products nose diagrams commute simplifying assumption :10.1.1.26.2787
purposes natural isomorphism remaining equations patched :10.1.1.26.2787
instance equation relating ya equations hold ya :10.1.1.26.2787
ya yb de nition mac functor small categories cocomplete category :10.1.1.26.2787
left kan extension left adjoint de ned follows colim comma category objects pairs hc di projection functor mapping pair hc fi colim small category functor mapping diagram colimit :10.1.1.26.2787
proposition categorical reformulation theorem :10.1.1.26.2787
sake simplicity strict notions functor natural transformation pseudo functors pseudo natural transformations :10.1.1.26.2787
proposition cat category small categories cat category locally small categories cat cat inclusion functor :10.1.1.26.2787
cat cat functor small category topos presheaves set op functor left kan extension set op natural transformation natural transformation corresponding id tf sequence steps op tf tf tf op tf op tf sf tf natural transformation :10.1.1.26.2787
monads categorical concept see str functor maps monads cat monads cat :10.1.1.26.2787
statement theorem lifting monads follows immediately proposition :10.1.1.26.2787
remains de ne lifting tensorial strength monad small category proposition small category nite products endofunctor natural transformation exists unique natural transformation tg ya yb proof isomorphic colimit colim shortly colim yi yoneda embedding similarly isomorphic colim yj :10.1.1.26.2787
functors preserves colimits left adjoints commute yoneda embedding ya yb ya ta :10.1.1.26.2787
tg isomorphic colimits colim yi yj colim yi yj respectively :10.1.1.26.2787
natural transformation looking yi yj yi yj tg yi yj naturality yi yj :10.1.1.26.2787
exists exactly morphism making diagram commute ht ji ji morphism diagrams shape diagrams colimit cones hf gi jf gi respectively :10.1.1.26.2787
monad partial computations induced dominion lifting monad partial computations induced dominion obtained lifting topos presheaves described ros :10.1.1.26.2787
monads lifting expected :10.1.1.26.2787
instance monad side ects general endofunctor ys ys topos presheaves :10.1.1.26.2787
research main contribution category theoretic semantics computations general principle extending complex languages see section formal systems straightforward fallout easy understand relate calculi :10.1.1.26.2787
just example achieved study programming languages category theoretic methodology avoids irrelevant syntactic detail focus important structures underlying programming languages :10.1.1.26.2787
believe great potential exploited :10.1.1.26.2787
mog give categorical account phase distinction program modules lead higher order modules programming languages ada ml see hmm mog propose modular approach denotational semantics idea monad constructor endofunctor category monads category :10.1.1.26.2787:10.1.1.26.2787
metalanguage open possibility develop new logic computable functions see sco semantic computations domain theory studying axiomatically di erent notions computation relations :10.1.1.26.2787
crole pitts see cp consider extension metalanguage equipped logic inductive predicates goes equational reasoning :10.1.1.26.2787
ambitious goal try exploiting capabilities ered higher order logic order give uniform account various program logics idea modal operator see de nition :10.1.1.26.2787
semantics computations corroborates view constructive proofs programs unrelated understood terms functions :10.1.1.26.2787
monads comonads model logical modalities possibility necessity modal logic course linear logic usually tensorial strength :10.1.1.26.2787
general expect types suggested logic provide ne grained type system changing nature computations :10.1.1.26.2787
identi ed monads important model notions computations computational monads additional properties tensorial may satisfy mono requirement :10.1.1.26.2787
properties computational monads identi ed reason believe properties literature monads :10.1.1.26.2787
people advice suggestions criticisms particular amadio burstall felleisen harper honsell hyland jay kock lafont longo milner pitts plotkin power talcott :10.1.1.26.2787
bw barr wells 
toposes triples theories :10.1.1.26.2787
springer verlag 
cp crole pitts :10.1.1.26.2787
new foundations xpoint computations :10.1.1.26.2787
th lics conf :10.1.1.26.2787
ieee 
cs constable smith :10.1.1.26.2787
partial objects constructive type theory :10.1.1.26.2787
nd lics conf :10.1.1.26.2787
ieee 
cs constable smith :10.1.1.26.2787
computational foundations basic recursive function theory :10.1.1.26.2787
rd lics conf :10.1.1.26.2787
ieee 
ff felleisen friedman :10.1.1.26.2787
syntactic theory sequential state :10.1.1.26.2787
theoretical computer science :10.1.1.26.2787:10.1.1.26.2787
felleisen friedman kohlbecker duba :10.1.1.26.2787
reasoning continuations :10.1.1.26.2787
st lics conf :10.1.1.26.2787
ieee 
fourman :10.1.1.26.2787
logic topoi :10.1.1.26.2787
barwise editor handbook mathematical logic volume studies logic :10.1.1.26.2787
north holland :10.1.1.26.2787
gmw gordon milner wadsworth :10.1.1.26.2787
edinburgh lcf mechanized logic computation volume lecture notes computer science :10.1.1.26.2787
springer verlag 
gs gunter scott :10.1.1.26.2787:10.1.1.26.2787
semantic domains :10.1.1.26.2787
technical report ms cis dept comp :10.1.1.26.2787:10.1.1.26.2787
inf 
science univ pennsylvania :10.1.1.26.2787:10.1.1.26.2787
appear north holland handbook theoretical computer science :10.1.1.26.2787
hmm harper mitchell moggi :10.1.1.26.2787
higher order modules phase distinction :10.1.1.26.2787
th popl 
acm 
hp hyland pitts 
theory constructions categorical semantics topos theoretic models :10.1.1.26.2787
proc :10.1.1.26.2787
ams conf :10.1.1.26.2787
categories comp :10.1.1.26.2787
sci 
logic boulder :10.1.1.26.2787
jp johnstone pare editors :10.1.1.26.2787
indexed categories applications volume lecture notes mathematics :10.1.1.26.2787
springer verlag 
kel kelly 
basic concepts enriched category theory :10.1.1.26.2787
cambridge university press 
koc kock :10.1.1.26.2787
strong functors monoidal monads :10.1.1.26.2787
archiv der mathematik 
kr kock reyes :10.1.1.26.2787
categorical logic :10.1.1.26.2787
barwise editor handbook mathematical logic volume studies logic :10.1.1.26.2787
north holland :10.1.1.26.2787
laf lafont :10.1.1.26.2787
linear machine 
theoretical computer science :10.1.1.26.2787
ls lambek scott :10.1.1.26.2787
higher order categorical logic volume cambridge studies advanced mathematics :10.1.1.26.2787
cambridge university press 
mac maclane 
categories working mathematician :10.1.1.26.2787
springer verlag 
man manes 
algebraic theories volume graduate texts mathematics :10.1.1.26.2787
springer verlag 
mas mason :10.1.1.26.2787
veri cation programs destructively manipulate data :10.1.1.26.2787
science computer programming :10.1.1.26.2787
mog moggi :10.1.1.26.2787
categories partial morphisms partial lambda calculus :10.1.1.26.2787
proceedings workshop category theory computer programming guildford volume lecture notes computer science :10.1.1.26.2787
springer verlag 
mog moggi :10.1.1.26.2787
partial lambda calculus 
phd thesis university edinburgh :10.1.1.26.2787
mog moggi :10.1.1.26.2787:10.1.1.26.2787
view programming languages :10.1.1.26.2787
technical report ecs lfcs edinburgh univ dept comp :10.1.1.26.2787
sci :10.1.1.26.2787
lecture notes course cs stanford univ mog moggi :10.1.1.26.2787:10.1.1.26.2787
category theoretic account program modules :10.1.1.26.2787
proceedings conference category theory computer science manchester uk sept volume lecture notes computer science :10.1.1.26.2787:10.1.1.26.2787
springer verlag :10.1.1.26.2787
mog moggi :10.1.1.26.2787:10.1.1.26.2787
computational lambda calculus monads :10.1.1.26.2787
th lics conf :10.1.1.26.2787
ieee :10.1.1.26.2787
mos mosses :10.1.1.26.2787:10.1.1.26.2787
denotational semantics :10.1.1.26.2787
technical report ms cis dept comp :10.1.1.26.2787:10.1.1.26.2787
inf 
science univ pennsylvania :10.1.1.26.2787:10.1.1.26.2787
appear north holland handbook theoretical computer science :10.1.1.26.2787
makkai reyes 
order categorical logic :10.1.1.26.2787
springer verlag 
mt mason talcott :10.1.1.26.2787:10.1.1.26.2787
programming transforming proving function abstractions memories :10.1.1.26.2787
th colloquium automata languages programming :10.1.1.26.2787
eatcs :10.1.1.26.2787
mt mason talcott :10.1.1.26.2787:10.1.1.26.2787
sound complete axiomatization operational equivalence programs memory :10.1.1.26.2787
popl :10.1.1.26.2787
acm :10.1.1.26.2787
plo plotkin :10.1.1.26.2787
call name call value calculus 
theoretical computer science :10.1.1.26.2787
plo plotkin :10.1.1.26.2787
denotational semantics partial functions :10.1.1.26.2787
lecture notes summer school :10.1.1.26.2787
ros rosolini :10.1.1.26.2787
continuity ectiveness topoi :10.1.1.26.2787
phd thesis university oxford :10.1.1.26.2787
sch schmidt 
denotational semantics methodology language development :10.1.1.26.2787
allyn bacon :10.1.1.26.2787
sco scott :10.1.1.26.2787
type theoretic alternative cuch iswim :10.1.1.26.2787
oxford notes :10.1.1.26.2787
sco scott :10.1.1.26.2787
identity existence intuitionistic logic :10.1.1.26.2787
fourman mulvey scott editors applications sheaves volume lecture notes mathematics :10.1.1.26.2787
springer verlag 
sco scott :10.1.1.26.2787
relating theories calculus :10.1.1.26.2787
hindley seldin editors curry essays logic lambda calculus formalisms :10.1.1.26.2787
academic press 
see seely 
linear logic autonomous categories cofree coalgebras :10.1.1.26.2787
proc :10.1.1.26.2787
ams conf :10.1.1.26.2787
categories comp :10.1.1.26.2787
sci 
logic boulder :10.1.1.26.2787
sha sharma 
syntactic aspects non deterministic lambda calculus :10.1.1.26.2787
master thesis washington state university september :10.1.1.26.2787
available internal report cs comp :10.1.1.26.2787
sci 
dept sp smith plotkin :10.1.1.26.2787
category theoretic solution recursive domain equations :10.1.1.26.2787
siam journal computing :10.1.1.26.2787
str street 
formal theory monads :10.1.1.26.2787
journal pure applied algebra :10.1.1.26.2787

