ieee transactions software engineering vol 
march evaluating deadlock detection methods concurrent software james corbett static analysis concurrent programs hindered known state explosion problem 
different techniques proposed combat state explosion little empirical data comparing performance methods 
information essential assessing practical value technique choosing best method particular problem 
carry evaluation techniques combating state explosion problem deadlock detection reachability search partial order state space reduction symbolic model checking inequality necessary conditions 
justify method comparison carefully analyze sources potential bias 
results evaluation provide valuable data kinds programs technique best applied 
furthermore believe methodological issues discuss general significance comparison analysis techniques 
keywords concurrency analysis empirical evaluation state space reduction symbolic model checking inequality necessary conditions ada tasking 
ada tasks arm software developers power dangers concurrency 
power systems composed cooperating agents concisely specified communication protocol agents faulty resulting program may contain concurrency errors deadlock starvation 
concurrent software increasingly part safety critical systems research methods tools increasing reliability software badly needed 
concurrent system modeled set communicating finite state components static reachability analysis provides method automatically detecting concurrency errors 
application practice limited state explosion problem number states concurrent system tends increase exponentially number processes 
techniques proposed combat explosion including state space reductions symbolic model checking compositional techniques abstraction dataflow analysis integer programming techniques personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
research supported national science foundation ccr 
author department information computer sciences university hawai honolulu hawaii corbett hawaii edu 
preliminary version appeared proceedings international symposium software testing analysis 

techniques excels certain examples complexity results indicate heuristic concurrent system modeled set communicating finite state automata analysis simple properties deadlock pspace hard 
addition empirical data comparing performance different techniques rare 
understandable effort constructing single analysis tool variations models input languages various existing tools difficulty conducting fair meaningful evaluation 
kind data essential assessing practical value techniques assisting developers selecting technique particular application 
growing recognition software engineering research focus designing carrying experiments yield quantifiable reproducible results 
contributions 
examine methodological issues empirically comparing different deadlock detection techniques ada tasking programs 
second evaluate performance analysis techniques report results evaluation 
specifically evaluate efficacy partial order state space reduction symbolic model checking inequality necessary conditions detecting communication deadlocks ada tasking programs 
techniques clearly superior significant variation performance techniques particular programs 
data provide indication kinds programs technique best applied 
evaluation narrow scope restricted property class concurrent system believe basic approach broadly applicable 
conducting empirical comparison automated verification techniques finite state concurrent systems benefit experience 
organized follows 
section ii defines model concurrent software 
section iii gives overview different approaches state explosion problem provides brief description techniques evaluated 
section iv discusses method comparison discusses issues arise evaluation 
section presents results experiments draws relative strengths weaknesses techniques evaluated 
section vi considers alternative models concurrent software explores models affected results evaluation 
fi ieee transactions software engineering vol 
march nally section vii summarizes experience conducting evaluation 
ii 
model presentation evaluation uniform adopt canonical model concurrent software 
different kinds concurrent systems ranging gate level hardware asynchronous network protocols ada tasking programs 
chose model natural representing class systems plan conduct evaluation ada tasking programs 
selection model issues affect outcome evaluation discuss section iv 
formally model concurrent system set communicating finite state automata fsas mn sigma delta ffl set local states ffl sigma set actions ffl delta theta sigma theta transition relation ffl start state ffl final states write delta delta clear 
task ada program represented automaton local states typically represent points control task may encode values variables critical modeling synchronization behavior task 
concurrent system modeled set automata defined fsa sigma delta ffl theta theta sn global states ffl sigma sigma ffl delta iff sigma sigma ffl ffl theta theta fn model ada rendezvous may assume tasks synchronize pairs symbol sigma alphabets symbols alphabet called internal actions represent execution code corresponding task symbols alphabets called communication actions represent rendezvous corresponding tasks 
deadlock state non final global state transitions terminal state final global state transitions 
trace prefix string accepted illustrate techniques simple concurrent system comprising tasks synchronize perform internal action 
fsas model system automaton system shown fig 

definition deadlock current 
particular definitions require cyclic wait 
fig 

example concurrent system iii 
methods section review basic approaches state explosion problem discuss selected techniques evaluate provide brief overview techniques selected evaluation 
approaches state explosion problem different techniques proposed combat state explosion problem 
state space reductions standard reachability analysis efficient reducing number states explored verify property 
range virtual coarsening techniques coalesce internal actions adjacent external actions partial order techniques alleviate effects representing concurrency interleaving symmetry techniques take advantage symmetries state space 
symbolic model checking uses symbolic representation system states compact explicit enumeration 
techniques proven especially successful verifying hardware 
compositional techniques exploit modularity system dividing smaller subsystems verifying subsystem combining results analyses verify full system 
subsystems simple interfaces hierarchical analysis quite effective 
abstraction reduces number states ignoring state information 
example static analysis software considers state process consist control location ignores values variables 
behaviors model superset behaviors actual program 
results conservative approximation technique reports property holds behaviors model hold behaviors program 
property hold behaviors model may may hold behaviors program coun corbett evaluating deadlock detection methods concurrent software may behavior model behavior program 
important issue conservative analysis accuracy closely behaviors model match behaviors program 
data flow analysis employed yield conservative analysis program properties potential cyclic deadlocks general safety properties 
techniques really analyze flow data program employ algorithms find fixed point set flow equations 
integer programming analysis certain kinds deadlocks conservative analysis general safety liveness properties 
techniques reduce verification property question integral solutions linear systems 
selecting methods evaluate techniques available selected partial order state space reduction symbolic model checking inequality necessary conditions evaluate 
selected techniques reasons 
represent different approaches state explosion problem expected perform best different kinds systems 
second base case techniques verifying properties systems parts systems decomposition 
compositional abstraction techniques part divide conquer strategy verification 
may simplify system manageable pieces lowest level pieces verified technique 
expect compositional abstraction techniques play vital role verification large system regardless technique verify base case subsystems 
selected techniques implementation available discussed section iv 
worst case time complexity techniques exponential size system 
practice techniques may lower complexity certain kinds systems 
remainder section provide brief overview techniques selected evaluation 
partial order state space reduction simplest deadlock analysis technique enumerate states automaton representing system search deadlock states 
intractable number states usually exponential function number tasks 
possible solution problem construct machine sigma delta delta delta property deadlock state property test testing may smaller 
general approach called state space reduction 
powerful state space reductions partial orders 
techniques observation state explosion due modeling concurrency interleaving 
example fsas fig 
perform internal actions concurrency actions represented traces ac ca produces simple semantics greatly increases size partial order semantics represents actions concurrent system set partially ordered events 
events related partial order precede semantics processes interaction 
example single partial order unrelated represents possible traces 
properties deadlock depend partial order events occur particular linearization events 
contains trace partial order may check deadlock checking deadlock conditional stubborn sets sleep sets techniques constructing techniques involve identifying sets transitions commute disable global state firing transition set 
example fig 
set transitions enabled system start state 
firing transitions represent possible order events reducing number states generated 
see details 
symbolic model checking approach making deadlock detection tractable different representation statespace searches typically generate states explicitly store hash table 
state space real systems large regular 
example consider simple system modeling bit counter states gamma transition state state mod size typical machine register system far large state enumeration techniques transition relation symbolically delta mod way represent delta symbolically encode relation boolean function represented ordered binary decision diagram obdd 
obdds represent frequently occurring boolean functions compactly symmetric functions addition 
obdd function xn total order boolean variables xn rooted directed acyclic graph properties 
internal node labeled variable var fx xng exactly children denoted lo hi 
leaf node labeled 
internal node var var lo var var hi path root variables appear order 
assignment values xn value label leaf node reached traversing path root node arc lo var arc hi var 
obdd example function ieee transactions software engineering vol 
march fig 

obdd fig 

dashed arcs connect lo solid arcs connect hi 
finite set encoded obdd dlog variables assigning element unique bit sequence oe building obdd characteristic function xn ae oe xn relations similarly encoded simply sets tuples 
function fig 
encodes transition relation fig 
represents current state represents input represents state 
encodings states symbols respectively 
transition relation delta set reachable states smallest set states containing including state reachable state delta 
obdd computed obdd delta fixed point techniques manipulate sets characteristic functions encoded obdds 
obdd check reachable states certain properties deadlock 
fact model checking temporal logic formulas performed framework constructing explicit representation see details 
inequality necessary conditions approach making deadlock detection tractable forgo representation state space 
verify system property technique generates necessary conditions existence trace violating conditions satisfiable property conditions satisfiable may may satisfy conditions necessary sufficient 
conditions strong rarely satisfiable holds easy check technique quite effective 
previous techniques kind technique yield inconclusive result course technique intractable analysis inconclusive 
different kinds necessary conditions deadlock analysis ada tasking 
ryder dataflow techniques search potential cyclic waits 
consider general technique uses linear inequalities 
flow state communication symbol hang symbol require fig 

inequality system necessary conditions form linear inequalities verify variety different properties concurrent system including freedom deadlock general safety liveness properties real time properties 
basic idea view fsa flowgraph find flow start state final state 
flow represents path takes trace sought trace violating 
flow arc represented integer variable flows generating flow equation state equating flow state flow state 
implicit flow start state implicit flow final state 
additional inequalities generated enforce consistency paths taken fsas 
consider example fig 

action represent synchronization tasks 
internal action represent task permanently blocked waiting task synchronize internal action represent task permanently blocked waiting task synchronize inequalities representing necessary conditions existence trace task permanently blocked fig 

flow equations find flows fsa communication equation requires communication occur number times tasks hang inequality prevents tasks permanently blocked waiting communication action events occur requirement inequality requires task permanently blocked events occur 
notice inequalities integral solution proving deadlock impossible 
see details 
iv 
method comparison performance analysis technique depends different factors including examples applied property verified quality technique implementation way problems modeled specified input language possibly parameters specific particular technique obdd variable ordering symbolic model checking 
method comparison control factors way resulting performance data corbett evaluating deadlock detection methods concurrent software ered may meaningfully compared 
section describe method empirically evaluating deadlock detection techniques ada tasking programs 
selection examples noted section ii different kinds concurrent systems 
restrict scope evaluation kind concurrent system ada tasking programs reasons 
allows simple interleaving model concurrency type communication represented 
asynchronous protocols naturally represented model explicit message buffers 
hardware circuits naturally represented models allow state component depend states components allow components change state simultaneously 
model represent probably represent 
second limited resources results evaluation limited class systems meaningful range examples provides better coverage particular class 
third familiar class systems collection examples 
course restriction class systems limits scope results 
experiments described section interpreted evaluation techniques general evaluation techniques applied ada tasking programs 
restriction class systems technique tried examples possible 
examples scalable parameter applying technique sizes example gives indication scalability technique 
collected real ada tasking programs possible standard benchmark examples concurrency analysis literature 
examples analyzed listed section 
choice ada reflects standard field concurrent software analysis 
selecting property techniques test deadlock communications protocol tasks 
selected deadlock undesirable property setting essentially examples program deadlocks automaton contains deadlock state defined section ii 
complex properties mutual exclusion starvation system specific require knowledge program source code 
restriction class systems restriction particular property limits scope results 
note verification safety property reduced check deadlock 
implementation implementation technique greatly affect performance 
developer technique strong incentive implement technique efficiently possible order demonstrate technique effectiveness 
decided tools written developers techniques insure implementation techniques evaluated 
alternative available implementations implement techniques guided technical reports describing details 
requiring effort approach produced implementations significantly inferior crafted experts years experience particular technique 
patrice godefroid didier pierre wolper university liege implemented partial order technique extension fast protocol analyzer called spin written gerard holzmann bell labs 
refer spin partial order package installed spin po 
note latest version spin version supports different partial order technique significantly memory overhead liege package include partial order reductions synchronous communication evaluation 
kenneth mcmillan cadence systems implemented symbolic model verifier smv 
tools publicly available stable reasonably robust 
unfortunately inequality necessary condition analyzer inca research tools desirable properties constructed components currently problem 
inca descended constrained expression toolset supports powerful analysis techniques efficient 
specifying examples decision existing implementations techniques faced problem analysis tool unique specification language 
see solutions problem 
specify example directly tool specification language specify example canonical form generate input tool automatically canonical form 
approach technically simpler avoids tricky issues involved automatic generation input 
hand specify example different specification languages formal basis say specifications represent system 
issue serious may appear specification languages different slight changes way system specified produce large variations performance tool 
sure specifications example different languages formally equivalent meaningfully compare performance techniques example 
believe requires second approach 
step decide canonical form examples 
possibility input language tools canonical form 
problem ieee transactions software engineering vol 
march ada spin po inca back smv verifier promela smv smv translator fsas spin translator inca front result result result fig 

generation input approach semantics specification languages sufficiently complex varied translating difficult 
language constructs awkward represent tool input language considered canonical enjoy unfair advantage evaluation 
tools regardless input language represent concurrent system finite state transition system model concurrent systems section ii canonical form examples 
model simple semantics relatively straightforward embed richer semantics specification languages 
example specified set communicating fsas translators automatically generate semantically equivalent input different tools 
translators spin po smv described sections iv respectively 
back inca performs analysis accepts communicating fsas directly translation required 
communicating fsas representing example generated automatically ada specification front inca tool 
aspect comparison method summarized fig 

may input language inca canonical form view front inca tool constructing canonical form 
inca constructs fsa task standard techniques constructing control flow graphs automata similar produced internally spin tool constructs finite state representation control flow imperative code 
believe front inca produce communicating fsas conveys advantage back inca performs analysis 
true input inca go translator easily written inca translator reversed mapping performed inca front converted communicating fsas back original ada specification applied inca translated input 
communicating fsas analyzed case performance inca changed 
real issue choice canonical form introduces bias discuss issue section iv 
description algorithm front inca translate ada specification language 
details translation extensive probably scope give example sample specification fsas generated 
fig 
shows ada specification basic dining philosophers problem fig 
shows fsas generated inca front specification selected example smallest specification probably familiar 
constant problem size set inca front varying sizes example generated source code 
task discriminant set index array philosopher fork task placed 
rendezvous tasks modeled shared symbol encodes caller acceptor entry 
example fsa state encodes syntactic location source code 
examples values small ranged variables flags counters encoded task state accurate modeling task synchronization behavior adding variables task specifications causes inca perform encoding 
identifying potential bias model concurrent systems may introduce bias spin smv 
model natural representing ada tasking programs particularly appropriate representing asynchronous protocols hardware domains tools designed 
believe bias worse obdd technique reasons 
interleaving model concurrency simultaneous model multiple actions occur simultaneously obdd techniques generally perform better simultaneous models depends communication structure system 
second encoding task variable values monolithic task state may increase size obdds needed represent transition relation task fsa 
elaborate second effect 
large fsas generated data intensive tasks containing variables encoded state task accurate modeling task synchronization behavior 
system directly specified smv input language smv encode states efficiently representation obdds 
example consider bit counter states gamma transition relation delta mod addition represented efficiently obdds obdd representing transition relation smaller corbett evaluating deadlock detection methods concurrent software number philosophers forks constant type range 
task type philosopher task type fork entry entry fork forks array fork array philosopher task body philosopher philosopher loop pick right left fork forks mod forks eat put forks forks mod forks loop philosopher task body fork fork loop accept fork picked accept fork put back loop fork fig 

ada source code dining philosophers example phil fork phil fork phil fork phil fork phil fork phil fork phil fork phil fork philosopher fork fig 

fsas dining philosophers example state number binary smv state encoding 
inca states gamma smv arbitrary order resulting arbitrary binary encoding state expose regularity transition relation 
practice task variable fsa contains essentially state value variable type bias introduced states smv order 
task multiple variables message type mtype synch rendezvous channel chan byte proctype fsa state internal action skip 
goto rendezvous channel synch 
goto fi halt proctype fsa state rendezvous channel synch 
goto internal action skip 
goto fi halt init atomic run run fig 

promela generated translator position state ordering chosen translator reveal values variables encoded state introduces bias 
model chosen match domain examples analysis tools 
conducting evaluation domain spin smv designed bias unavoidable 
inca built analyze ada tasking programs suffer bias 
section vi explore extent bias considering different models 
spin translator describe communicating fsas representing concurrent system translated promela input language spin 
promela guarded command language csp syntax 
directly supports communicating processes translation relatively straightforward 
fsa represented process created proctype declaration 
state fsa represented statement labeled name state 
statement implements transitions state represents goto statements guarded action causing transition 
fig 
shows pair communicating fsas fig 
shows promela code generated fsas comments added hand 
statement promela alternative command csp allowing arbitrary selection alter ieee transactions software engineering vol 
march natives guards true 
alternative transition state 
state transitions statement state executable causing process halt 
alternative representing transition action state consists goto statement state label guarded statement representing internal actions enabled represented statement skip 
communication actions discussed 
state label begins string considered final state process purposes deadlock detection 
promela supports communication processes channels declared ordinary variables having type chan 
channel variables initialized indicating number messages channel buffer 
channels zero capacity implement synchronous communication 
declare channel communication action fsas 
communication action shared processes designated sender receiver 
promela statements send receive message type channel respectively 
channels zero capacity statements executable may chosen statement state processes containing corresponding communication action states take action 
information passed messages declare single message type synch mtype declaration 
promela supports specification safety liveness properties 
generate specifications translation causing spin spin po search invalid deadlocks 
smv translator describe set communicating fsas translated smv input language 
promela ada smv input language designed primarily hardware specification 
smv language systems specified set variables set functions define value variables terms current values 
facilities constructing replicating connecting components provided 
convenient specifying gate level logic certain kinds protocols awkward specifying communication sequential processes 
fortunately smv language provides escape allows transition relation specified directly 
meant specifically facilitate writing translators languages smv proved invaluable comparison 
smv specification generate parts 
var part declares state variables 
state assignment values state variables 
init part boolean function state variables 
state legal initial state system function true state 
trans part allows transition relation specified 
comprised single boolean function module main var state fsa state fsa init initial state trans transition transition transition spec ag paths globally ex state fsas final states fig 

smv generated translator values state variables current state values state 
function returns true pair states transition state state spec part temporal logic formula logic ctl specifying property system satisfy 
represent set communicating fsas follows 
declare state variable hold current state 
init function forces start state 
trans function encodes transition relation entire system large boolean formula construction described 
spec formula ag ex final search deadlocks final formula true state final state 
ctl translates paths exists state current state final 
formula final main part translation construction trans formula 
interleaving model transition occur time 
trans function consist disjunction possible global transitions concurrent system 
global transitions types internal actions changes state communication actions change state 
state variable represents value state represents corbett evaluating deadlock detection methods concurrent software value current state 
disjunct representing occurrence internal action transition requires move state state remain state 
similarly disjunct representing occurrence communication action transition synchronously communication action transition possible pairing matching communication action transitions produces distinct global transition 
smv input generated system fig 
shown fig 

smv uses respectively 
experiments section presents results experiments conducted comparison method described section iv 
applied spin po smv inca seventeen families scalable examples non scalable programs measuring amount time memory tools check deadlock 
scalable example applied tool sizes example gauge scalability technique 
applied spin straight reachability analyzer example provide baseline measuring effectiveness tools state explosion problem 
raw performance data scalable examples derived numerical measure fast resource requirements grew problem size 
growth rates raw data non scalable examples able correlate scalability technique certain features examples characterize kinds programs technique best applied 
section organized follows 
section presents brief description examples evaluation 
section discusses issues arose modeling examples analysis 
section describes general approach analyses run 
section presents raw data analyses details collection 
section develop numerical measure rate growth time memory required tools example scaled 
section growth rates draw scalability various techniques different kinds programs 
examples section lists examples analyzed 
size parameter scalable examples denote size version scalable example 
space permits brief description example 
specifications examples communicating fsas generated inca front promela smv inputs generated translators available anonymous ftp ftp ics hawaii edu pub corbett eval tar raw characteristics example summarized table columns give lines code number tasks number unique rendezvous additional features analysis results section 
lines code ada input inca accurate measure size resulting system scalable examples arrays tasks measure vary problem size 
specifications extracted real programs give size specification size original program amount unmodeled non concurrent code relevant analyses 
count distinct shared symbol unique rendezvous symbol encodes caller acceptor entry name parameters passed rendezvous 
examples analyzed alternating bit protocol abp simple analyzed example modeled tasks representing users sender receiver lossy channels 
border defense system bds example analyzed communication skeleton real ada tasking program simulates border defense system 
original source code written comprised lines ada 
obtained communication skeleton concurrent systems software laboratory university illinois chicago indicated table skeleton lines 
example tasks skeleton relatively simple 
cyclic scheduler cyclic milner cyclic scheduler uses scheduler tasks keep customer tasks loosely synchronized 
divide conquer dac program modeling divide conquer computation forking solver tasks proceed parallel 
program communication skeleton fairly complex ada program tasks 
dining philosophers dp dph dpd realistic problem contain nontrivial deadlock probably commonly analyzed example 
model philosophers forks task 
tasks synchronize model forks acquired released 
addition standard version dp deadlock analyzed versions problem deadlock prevented 
version host dph additional host task philosopher synchronize attempting acquire forks 
model real world situation task wishing ieee transactions software engineering vol 
march communication task size problem loc tasks structure structure cyclic linear small dac linear small dp linear small dpd linear small single star small large dph linear single star small medium linear elevator multiple stars medium large furnace multiple stars small medium gasnq multiple stars medium large multiple stars small medium large single star small large linear key single star small medium multiple stars small medium gamma linear single star small medium ring linear small medium rw single star small medium linear single star small large linear abp linear small medium bds multiple stars small medium multiple stars small medium ftp multiple stars small medium ftp multiple stars small medium multiple stars small medium speed multiple stars small table characteristics examples resource get permission central server task 
host allow gamma philosophers hold forks time 
dictionary version dpd effect achieved having philosophers pass dictionary table 
philosopher holding dictionary hold forks 
version fork manager philosophers pick forks simultaneously rendezvous fork manager task records state forks lieu fork tasks 
elevator elevator program models controller building elevators tasks model behavior elevators 
size version tasks 
file transfer program ftp program services requests users transfer files network 
version abstraction original program complex analyze 
size version tasks 
remote furnace program furnace program manages temperature data collection 
analyze original design abstracted slightly model temperature data furnace identifier verifying freedom deadlock proper transmission data 
size version tasks 
gas station gasnq example models self service gas station originated analyzed 
customers arrive pay operator gas 
operator activates pump customer pumps gas 
customer finished pump reports amount gas pumped operator gives customer change 
analyzed versions operator task pump tasks customer tasks 
analyzed different versions example 
original version operator task queues customer requests keep track customers waiting pump order 
non queuing version gasnq operator enforce come serve order customers record number customers waiting pump order activate pump waiting customers remain 
program communication skeleton ada program analyzed task starts stops worker tasks 
keyboard program key communication skeleton ada program analyzed manages keyboard screen interaction window manager 
scaled program making number customer tasks parameter 
size version tasks 
distributed memory manager communication skeleton ada program implementing memory management scheme users 
size version tasks 
overtake protocol ada version automated highway system overtake protocol cars comprising tasks 
user interface ada skeleton rpc client server user interface tasks real applications 
corbett evaluating deadlock detection methods concurrent software token ring mutual exclusion protocol ring ada implementation standard distributed mutual exclusion algorithm user tasks synchronize access resource sever tasks pass token ring 
readers writers rw example models database may simultaneously accessed number readers single writer 
reader tasks writer tasks synchronize controller task accessing finished accessing database 
system analyzed 
sensor test program communication skeleton ada program analyzed starts tasks test sensors 
size version tasks 
speed regulation program speed communication skeleton ada program analyzed tasks monitor regulate speed car 
modeling issues examples elevator gasnq convenient task accepting entry able test value call parameter deciding accept call 
functionality absent ada statement ada effectively adds 
effect achieved ada different entry value critical parameter scaling specification cumbersome 
specifications employ special assume statement purpose 
example operator task gasnq accept charge entry pump customers currently waiting 
expressed accept charge pump assume waiting charge assume statement modeled assuming clause yeh young 
believe examples standard dining philosophers dp free deadlocks models ada programs key speed contain spurious deadlocks due presence global variable synchronizing task termination 
currently global variables processed inca front represented model concurrent systems additional fsa variable hold value variable communication actions testing setting value variable 
model program contains spurious deadlock due abstraction timing information program heavy conditional entry calls 
examples contain deadlocks chose leave spurious deadlocks models provide data quickly tools find deadlock exists 
drawback deadlocks subtle deadlock dining philosophers problem deadlocks random simulation 
examples dac elevator key speed ada terminate alternative synchronize termination groups tasks 
examples tasks declared single package task select terminate alternative exactly tasks terminated similarly blocked terminate alternatives 
represent model making state task fsa select terminate alternative final state 
general approach ran spin po smv inca examples described section 
ran spin straight reachability analyzer examples give baseline measuring efficacy techniques state explosion problem 
examples measure cpu time memory consumed tools performing analysis 
scalable example selected increasing sizes near maximum size handled tools 
facilitates comparison tools measured run times small maximum size set tool performs worst example 
step value size growth chosen magnify variation resource measurements 
examples meant dividing size range roughly equal pieces maximum size run sizes 
examples resource requirements tools increased quickly size small size approached maximum 
examples chose larger sizes minimize number small measurements dominated fixed overhead 
finding largest size tool handle certain resource constraints preliminary version simply measure growth resources consumed example scaled calculation growth rates described section 
believe growth rates meaningful maximum sizes gathered reasons 
various kinds constant overhead implementations factored 
second examples translated input tool imposes maximum size see discussion difficulty scaling section 
larger sizes examples inca front runs memory building fsas translated input larger native specification large tool 
limitation comparison method compact canonical model section better translators language constructs ieee transactions software engineering vol 
march promela arrays replicate components largely solve problem 
third resource constraints reasonable somewhat arbitrary especially limit cpu time 
hours argue higher lower limit 
section investigate relationship size concurrent system resources consumed tools perform analysis 
concurrent system model section ii define exactly size system number reachable states model jsj obscures state explosion making size measure explode systems scaled 
bears little relation size ada program model derived 
alternatively number tasks 
closer programmer view program size take account size tasks state fork tasks dp counted state operator task 
account task size number component states js measure obscures state explosion results data component gas station elevator examples 
number bits required store state task measure task size sum measures log js measure size program 
avoid confusion call measure size scale example continue word size denote value scalable examples 
note examples scale linear function size arithmetic sequence sizes example arithmetic sequence scales 
raw data section data experiments various details collected 
experiments conducted sparcstation model mb memory 
analysis times reported user cpu seconds collected time command get internal run time function common lisp 
statistical analysis behavior functions reveals time report near normal distribution standard deviation 
tool takes little time sizes example small variations significant effect growth rate calculate section 
measured run times tool sizes example seconds run tool times average time point estimate 
inca results analysis times reported include translation ada source language fsas 
tools analysis times include actual run times tools time translate ada source fsas time translate fsas tool input language 
tools report amount memory trust figures regard approximations 
memory usage difficult measure externally tool generally allocate memory uses 
variation tools memory code stack heap counted total reported 
differences small constant factors significantly affect rate growth memory usage examples scaled 
experiments version spin version partial order package spin unofficial version smv dated version inca 
spin spin po smv written inca written common lisp integer programming package written fortran 
spin po smv take various command line parameters affect performance 
parameters suggested authors tools produced best performance 
spin po run proviso disabled flag 
proviso causes spin po generate states needed deadlock detection order allow state assertion checking 
evaluating deadlock detection needed removing improves performance tool 
smv run flag calculates reachable states system checking ctl formula 
spin spin po arrays sizes set various command line parameters including maximum number processes size state vector maximum search depth 
default values parameters sufficed examples increase complete analysis examples 
maximum number processes default raised rw 
state vector size default raised 
maximum search depth default raised dp spin 
parameters raised uniformly sizes scalable example 
increased memory usage unnecessarily smaller sizes examples feel consistent vary parameters different sizes scalable examples 
analysis performance section concerned primarily growth rates magnitudes 
spin spin po analysis tool generates source code analyzer compiled run perform analysis 
include generation compilation times data 
translated input generate larger equivalent promela code specify system takes longer generate compile gasnq native promela specification takes seconds generate compile compared seconds translated input 
real run times tools slightly larger 
programs simple communication structure 
number states examples grows linearly problem corbett evaluating deadlock detection methods concurrent software size 
difficulty scaling examples limits tools due translated input spin spin po 
noted translated input usually larger equivalent native promela specification 
large sizes generated analyzer big compiler run 
smv order state variables declared input file order appear obdds 
greatly impacts performance technique assisted tool providing reasonable ordering example knowledge obdds limited trials different possible orderings 
unfortunately general algorithm determine best order particular situation heuristics exist 
general state variables tasks communicate placed close possible 
examples dp key speed contain deadlocks 
systems spin spin po smv display sequence state changes leading deadlock state inca finds solution interpreted sequence actions task 
examples tools correctly declared system free deadlocks 
raw performance data tables ii iii 
columns table show problem name size scalable scale log js rounded nearest integer number reachable states jsj memory megabytes cpu time seconds consumed tools perform analysis 
dash indicates analysis completed mb memory day cpu time 
spin generate number reachable states example dp key spin ran memory 
note spin able complete analysis systems finding deadlock state generating entire state space 
comparing numbers inca version may notice slight differences examples 
front inca extensively modified version support described section vi 
analysis section consider data suggest scalability evaluated techniques 
general difficult characterize scalability analysis technique 
complexity results indicate exist problems technique scale 
practice interested average case difficult know average program looks 
techniques may scale certain kinds programs poorly 
furthermore techniques sufficiently complex hard estimate cost particular problem priori 
best examine performance technique nontrivial collection programs try determine kinds programs technique scale 
table iii gives performance data seventeen scalable examples 
scalable example tool resource set points ji scale different size example amount resource consumed tool size 
looking column get informal sense quickly resource requirements growing scale problem 
examination data tedious comparisons difficult 
explored graphing raw data range measured resource units great plot data example single graph separate graphs different scales facilitate comparison 
tried selectively plotting certain data mathematical transformations data fit log linear log log graphs resulting graphs best difficult interpret worst extremely misleading 
decided obtain numerical measure rate growth resource tool example 
want measure quickly resource requirement growing scale example 
considered fitting curve kind points ji parameter fitted curve estimate growth rate linear fit take slope fit points ax parameter 
unfortunately underlying forms actual resource functions generating data unknown 
furthermore clearly single form data appear linear appear highly exponential 
assumptions form actual resource functions simply estimate faster function appears growing right side interval left size 
specifically data set ji calculate growth rate resource function ratio slope line segment connecting slope line segment connecting 
considered ratio slopes line segments connecting data sets consecutive resource measurements equal slopes segments zero 
determined growth rate state space example similar way points js ji set global states th size example 
growth rates obtained shown table iv 
growth rate measures apparent curvature actual resource function factors fixed overhead memory taken analyzer code constant factors units resources measured speed machine run tool 
consequently may compare growth rate single resource different tools examples may directly compare growth rates different resources 
hand measure conceals actual slope growth function interval ieee transactions software engineering vol 
march spin spin po smv inca problem size scale states mem time mem time mem time mem time abp bds ftp ftp speed table ii raw data non scalable examples growth rate 
growth rate clearly important constant factors limit practice large constant factors may significant impact scalability technique range sizes tool run 
slope resource function interval large considered function growth rate estimating scalability technique example 
discussed section chose measure growth rates determine maximum sizes tool handle certain resource constraints 
concern approach behavior tool large sizes example may dominated different factors behavior small sizes measure growth rate 
words measured growth rate may accurate characterization scalability tool 
validate scalability measure comparing growth rates calculated maximum sizes determined couple examples 
consider dp example tools scaled larger sizes shown table iii 
example spin spin po inca exhausted mb limit imposed smv exceeded hour time limit 
memory growth rate spin spin po smv inca 
rates expect spin po able handle significantly larger sizes spin inca able handle larger sizes 
fact spin exhausted memory size spin po size inca size 
note difficult predict maximum sizes additional information roughly consistent growth rates 
consider data intensive example gasnq 
spin spin po exhausted memory limit smv inca exhausted time limit 
memory growth rate spin spin po 
rates expect spin po able scale bit farther spin 
fact tools exhausted memory size 
memory growth rate high additional customer adds great deal memory spin po take extra step exceeding limit 
memory growth rates smv inca respectively 
expected memory problem tools example 
time growth rate smv inca 
rates expect inca able scale bit farther smv 
fact tools exhausted time limit size 
examining raw data reveals time function inca larger slope time function smv maximum sizes consistent growth rates 
believe growth rates provide useful characterization behavior tools larger sizes examples reasonable measure scalability 
results discuss implications growth rates scalability techniques different kinds programs 
convenience discussion refer rates low rates high intermediate rates moderate 
chose boundaries rates near linear functions low state growth rates high admit classification somewhat arbitrary 
picture results fig 
plots growth rates table iv tool 
able correlate performance different tools various features example programs principally structure 
may view communication structure program graph task represented node possible rendezvous tasks represented edge corresponding nodes 
examples exhibited different communication structures 
linear communication structure tasks arranged line ring task communicates primarily neighbors 
single star structure communication particular task tasks 
couple examples exhibited combination patterns line ring tasks communicating neighbors central task 
multiple star communication structure tasks communicate tasks 
task size structure 
discussed section iv data intensive tasks require values certain task variables encoded state task fsa accurate modeling task synchronization corbett evaluating deadlock detection methods concurrent software spin spin po smv inca problem size scale states mem time mem time mem time mem time cyclic cyclic cyclic cyclic dac dac dac dac dp dp dp dp dpd dpd dpd dpd dph dph dph dph elevator elevator elevator elevator furnace furnace furnace furnace gasnq gasnq gasnq gasnq key key key key ring ring ring ring rw rw rw rw table iii raw data scalable examples ieee transactions software engineering vol 
march spin spin po smv inca problem states mem time mem time mem time mem time cyclic dac dp dpd dph elevator furnace gasnq key ring rw table iv time memory growth rates scalable examples dp key dph dpd elevator rw dac furnace gasnq ring cyclic spin spin po key dac dpd dp rw dph furnace cyclic gasnq elevator smv key dph gasnq ring furnace elevator cyclic dac rw dpd ring dp elevator ring gasnq cyclic dp dpd key furnace rw dph dac inca fig 

plot time growth rates logarithmic scale corbett evaluating deadlock detection methods concurrent software havior 
tasks usually produce fsas states tasks data intensive usually produce fsas states 
classify size task small fsa fewer states medium fsa states large fsa states 
data intensive tasks examples exhibited linear structure states arranged line transitions adjacent states 
linear tasks result modeling value single integer variable counter 
table characterize communication structure task size structure example 
scalable examples task size classification determined size tasks largest size example analyzed fork manager task states states classified large table 
deadlock free scalable examples spin exhibited low growth rates examples state spaces grow linearly scale 
synchronization structure examples simple master task starts stops worker tasks structure may uncommon software 
spin exhibited low growth rates key example spin able find deadlock state exploring significant fraction state space 
spin po exhibited significantly lower memory growth rates spin cyclic dac dp dpd ring 
common feature examples communication structure linear 
structure creates commuting transitions allows partial order technique spin po achieve significant reduction state space 
partial order state space reduction helped cases especially memory growth rate generally limiting factor state space tools spin po exhibited somewhat higher growth rates spin dph elevator rw 
examples contain single star communication structure 
spin spin po creates data structure possible pair synchronizing transitions performs poorly examples communication structure 
memory overhead artifact implementation technique 
smv exhibited low time growth rates cyclic dac rw moderate time growth rates dp dpd dph gasnq key ring 
spin po smv performed better examples linear communication patterns performed reasonably examples single star communication pattern 
smv performed worse elevator furnace gasnq examples communication patterns contained multiple stars 
surprising nonlinear structure difficult find variable ordering obdds 
smv exhibited moderate high growth rates programs data intensive tasks 
programs include single star communication pattern elevator gasnq 
symbolic model checking primarily verification hardware experience indicate may prove effective verifying software 
note smv performed better spin scalable examples exhibiting lower growth rates time lower growth rates memory 
inca performs worst elevator gasnq ring 
elevator gasnq contain data intensive task size grows rapidly example scaled 
tools inca generally sensitive communication structure program kind tasks comprise 
time required solve ilp problems inca generates increases rapidly size task fsas simple linear structure dph rw 
mentioned section iii inca uses necessary conditions analysis inconclusive conditions strong 
note conditions strong analyses 
meaningful comparisons difficult examples 
smv clearly worse tools large systems simple deadlocks clearly better ftp large system deadlocks 
reflects general trend experiments smv tended slower tools finding deadlocks 
spin po inca techniques allow soon deadlock state integral solution case inca 
smv construct obdd reachable states system entirety checking deadlock states 
draw data sample contained programs deadlocks deadlocks trivial random simulation 
general difficult evaluate performance analysis tools find errors prove absence time takes find error dependent factors analyst little control order reachability analyzer explores state space 
note smv performed better spin finding obscure deadlock standard dining philosophers dp 
deadlock free scalable example spin exhibited memory growth rate similar growth rate state space 
spin po smv inca exhibited significantly lower memory growth rates examples indicating techniques tools tend require time memory problem scaled 
memory usually resources allows tools tackle larger problems 
ieee transactions software engineering vol 
march vi 
alternative models experience controversial aspect comparison method choice communicating fsas canonical model 
people questioned choice model translators bias evaluation techniques 
address issue explore alternative canonical models 
consider informal model manually generated native specifications analysis tool avoiding potentially biasing translators second consider complex canonical model data values explicit 
consider simultaneous model concurrency 
alternative models affect degraded performance tools increasing confidence validity results 
native specifications formal canonical model informal model example prose description specify example tool specification language directly 
smv input language intended describing systems different programs analyze 
result convert programs kind state machine just encode language 
little choice model examples generate input smv 
promela easily specify communicating processes 
determine effect native promela specification experiments selected examples coded directly promela spin straight reachability analyzer compare number states native model number states translated model 
example selected version standard dining philosophers problem deadlock avoided having philosopher pick left fork philosophers pick right fork 
example representative programs analyzed variables modeled states automata representing program encode control location task 
example number states native model exactly number states translated model reassuring result 
second example selected non queuing version common gas station problem gasnq 
example representative programs state task automata encode values task variables control location task 
story selection example interesting 
sent draft predecessor gerard holzmann author spin solicit comments tool 
request supplied generated promela inputs 
concerned translated inputs unduly bias evaluation gave version gasnq directly coded promela 
translated promela scaled customers native promela scaled customers result suggesting translated promela code inferior native promela specification 
closer examination code noticed version gasnq quite 
familiar problem difference operator task allowed customers kept count customers pump pumps activated long waiting customers remained 
causes state explosion operator task number customers scaled 
holzmann worked directly translated promela knowledge problem ada specification specified system operator allows customer pump 
system size operator task increase number customers 
pointed difference wrote native promela version gasnq illustrate structure program intended model 
real promela specification written quite inefficient scaled customers size smaller translated model 
holzmann specification guide modified version allow multiple customers 
version scaled customers sizes larger translated promela 
examined new version noticed quite gasnq 
promela allows multiple processes read channel ada allows task accept entry call 
holzmann promela channel represent ada entries achieved reduction state space result 
example task call entry time behaviors generated 
knowing multiple entries sharing channel called simultaneously verified independently reduction applied correctly model synchronization behavior ada tasks general entry modeled channel 
modified holzmann specification channel entry resulting model scaled customers translated model size roughly times states translated model reassuring result 
exchange gave confidence promela translator introducing significant bias evaluation 
importantly convinced canonical model essential seemingly small differences specification problem produce large variations resulting model 
extended model simple model section ii suited programs little data represented 
data intensive programs model may introduce bias discussed section iv 
hiding variable corbett evaluating deadlock detection methods concurrent software spin smv example model states time trans time dph fsa efsa gasnq fsa efsa mem table experiments comparing efsa fsa models values monolithic task state may hinder technique problems 
section consider alternative model variable values explicitly represented state task automata 
extend model section ii adding memory fsa 
memory array cells holds integer value finite subrange 
transitions may guarded expressions memory values may transform memory assignments 
general model call efsa extended finitestate automata capable representing uses data encountered ada tasking programs including rendezvous parameters arrays records arbitrarily nested parameters inlined procedures 
modified inca front build ada specifications 
wrote new translators spin smv generate input new canonical form 
spin smv support arrays integers translation relatively straightforward despite richer semantics 
omit formal definition details translators extensive evaluation described section note encoding memory contents state automaton inca translates fsas inequality necessary condition technique affected different model 
applied new translators examples compared performance tools inputs generated performance inputs generated fsas 
examples comparison dining philosophers host dph philosophers non queuing gas station gasnq customers 
dph example task data host task single variable counter 
gasnq example tasks data operator task array counters customer tasks variable storing pump selected 
results experiment shown table columns show example model number reachable states reported spin analysis time seconds spin number obdd nodes transition relation generated smv analysis time smv 
see section details analysis times obtained experiments reported 
richer canonical model generally degraded performance tools reading translated input 
effect greater smv data intensive example gasnq 
spin efsa model dph identical fsa model efsa model worse gasnq 
extra states efsa model result inability express certain kind atomicity promela 
fsa model memory updates processes involved rendezvous performed atomically rendezvous memory encoded state 
efsa translator employed atomic sequence construct promela simulate semantics quite 
problem possible memory updates processes part atomic action efsa model generated spin additional states 
performance spin po similarly degraded efsa model 
smv efsa models examples required larger obdds represent transition relation 
believe benefit representing variable values explicitly overwhelmed significant increase number state variables required store task memories 
case gasnq believe array indexing caused explosion obdd size exhausted memory 
ada version example naturally coded entry accepting pump number parameter index array storing number customers waiting pump 
comparison coded example array separate entry pump integer variables hold number waiting customers 
smv able analyze translated input generated just twice time took analyze input generated fsas slowdown comparable obtained dph 
experience efsa translators disappointed find produced uniformly worse performance fsa translators 
believe possible improved efsa translator produce comparable better performance smv 
hu explored verification higher level specifications obdds techniques attempted interleaving bits memory cells functionally related partitioning transition relation 
decided pursue matter time reasons 
ada tasking programs collected data intensive issue critical evaluation 
second data intensive examples clear representing task state symbolically obdds done efsa model produce better performance explicitly enumerating task states done fsa model 
hu dill report state enumeration efficient obdd techniques real life protocols tried 
tried avoid special purpose techniques specific kinds problems favor techniques generally applicable 
fully automatic tools sacrifice efficiency generality ease 
ieee transactions software engineering vol 
march simultaneous model potential bias obdd technique interleaving model concurrency simultaneous 
interleaving model events totally ordered exactly event occurs step 
simultaneous model events may occur simultaneously 
obdd techniques tend perform better simultaneous models especially number asynchronous processes large 
section convert model section ii simultaneous model describe translation scheme model smv language compare performance smv simultaneous model performance interleaving model 
redefining composition set fsas mn fsa sigma delta ffl theta theta sn ffl sigma sigma ffl delta iff sigma sigma fag ffl ffl theta theta fn model take transition step may take transitions simultaneously 
translate model smv language different approach described section 
transition relation disjunction transitions give transition relation conjunction formulae represents legal behavior action participates action sigma sigma 
declare state variable oe enumerated type sigma stores action took previous step 
variables necessary insure synchronizes step 
declare state variable enumerated type 
init function 
trans function constructed follows 
ffi internal action transition trans ffi oe ffi communication action transition synchronizing action trans ffi oe oe idle function oe 
trans function idle ffi delta trans ffi ran sizes standard dining philosophers problem interleaving simultaneous models 
example model trans time dp interleaving simultaneous dp interleaving simultaneous dp interleaving simultaneous table vi experiments simultaneous model results shown table vi columns show example size model number obdd nodes transition relation generated smv analysis time smv 
dining philosophers systems ring structure simultaneous model perform 
unfortunately addition action state variables unnecessary interleaving model performance worse 
note original translation scheme interleaving model included action state variables caused similar performance problems smv 
conclude interleaving model section ii better simultaneous model representing ada tasking programs 
vii 
explored methodological issues involved empirically evaluating deadlock detection techniques ada tasking programs 
issues selection examples implementations specification examples analysis resulting behavior implementations 
chose represent program canonical model apply tools implementing techniques inputs generated automatically canonical representation 
analysis calculated numerical measure rate growth time memory required tools complete analysis example scaled 
believe issues general significance empirical comparison analysis techniques 
conducted empirical evaluation techniques deadlock detection ada tasking programs partial order state space reduction symbolic model checking inequality necessary conditions 
technique clearly superior certain kinds programs 
state space reduction symbolic model checking techniques performed best programs linear communication structure 
programs single star communication structure symbolic model checking generally performed better state space reduction technique 
inequality necessary conditions performed programs small linear tasks regardless communication structure 
evaluation gives indication kinds programs evaluated techniques best applied 
considerable effort part researchers required fully characterize range applicability technique 
corbett evaluating deadlock detection methods concurrent software require large collection example programs common model agreed method evaluation 
takes important step rigorous evaluation concurrency analysis techniques 
george avrunin suggesting slope ratio growth measure extensive valuable comments various drafts 
gerard holzmann ken mcmillan patrice godefroid assistance guidance tools comments draft 
ugo buy matt dwyer steven supplying examples swami assistance conducting experiments advice data analysis gerard holzmann valuable discussions difficulty evaluation 
avrunin buy corbett dillon wileden 
automated analysis concurrent systems constrained expression toolset 
ieee trans 
softw 
eng nov 
avrunin corbett dillon wileden 
automatic derivation time bounds uniprocessor concurrent systems 
ieee trans 
softw 
eng 
bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys 
burch clarke mcmillan dill hwang 
symbolic model checking states 
proceedings fifth annual ieee symposium logic computer science pages 
cheung kramer 
enhancing compositional reachability analysis context constraints 
proceedings acm sigsoft symposium foundations software engineering pages dec 
clarke grumberg long 
model checking abstraction 
acm trans 
prog 
lang 
syst september 
cleaveland parrow steffen 
concurrency workbench semantics tool verification concurrent systems 
acm trans 
prog 
lang 
syst jan 
corbett 
verifying general safety liveness properties integer programming 
probst pages 
corbett 
translator 
technical report ics tr information computer science department university hawaii 
corbett 
empirical evaluation methods deadlock analysis ada tasking programs 
ostrand editor proceedings international symposium software testing analysis issta pages 
acm press august 
corbett avrunin 
practical method bounding time events concurrent real time systems 
ostrand weyuker pages 
corbett avrunin 
integer programming verify general safety liveness properties 
formal methods system design january 
courcoubetis editor 
computer aided verification th international conference proceedings greece 
buy 
state space reduction methods deadlock analysis ada tasking 
ostrand weyuker pages 
dwyer 
data flow analysis verifying correctness properties concurrent programs 
phd thesis university massachusetts amherst 
dwyer clarke 
data flow analysis verifying properties concurrent programs 
editor proceedings second symposium foundations software engineering pages dec 
ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
prog 
lang 
syst july 
ford 
concurrent algorithms real time memory management 
ieee software pages september 
godefroid 
partial order methods verification concurrent systems approach state explosion problem 
phd thesis universite de liege 
godefroid 
refining dependencies improves partial order verification methods 
courcoubetis pages 
godefroid wolper 
partial orders efficient verification deadlock freedom safety properties 
larsen skou editors computer aided verification rd international workshop proceedings volume lecture notes computer science pages aalborg denmark july 
springer verlag 
graf 
tool verification abstraction 
courcoubetis pages 
helmbold luckham 
debugging ada tasking programs 
ieee software march 
hoare 
communicating sequential processes 
prenticehall international 
holzmann 
design validation computer protocols 
prentice hall englewood cliffs nj 
hu dill 
efficient verification bdds implicitly conjoined invariants 
courcoubetis pages 
hu dill drexler yang 
higher level specification verification bdds 
probst pages 
buhr 
starvation critical race analyzers ada 
ieee trans 
softw 
eng 
long clarke 
task interaction graphs concurrency analysis 
proceedings th international conference software engineering pages pittsburgh pa may 
ryder 
static infinite wait anomaly detection polynomial time 
proceedings international conference parallel processing volume ii pages 
mcdowell 
practical algorithm static analysis parallel programs 
journal parallel distributed processing june 
mcmillan 
symbolic model checking 
kluwer academic publishers boston 
milner 
calculus communicating systems volume lecture notes computer science 
springer verlag berlin 
murata shenker 
detection ada static deadlocks petri net invariants 
ieee trans 
softw 
eng 
osterweil clarke 
proposed testing analysis research initiative 
ieee software pages sept 
ostrand weyuker editors 
proceedings international symposium software testing analysis issta new york june 
acm press 

reachability analysis petri nets symmetries 
systems analysis modeling simulation 
stockmeyer meyer 
word problems requiring exponential time 
proceedings fifth acm symposium theory computing pages 
tichy habermann prechelt 
summary dagstuhl workshop directions software engineering 
acm sigsoft jan 
tu murata 
theory application petri net reduction ada tasking deadlock analysis 
technical report eecs department university illinois chicago 
probst editors 
computer aided verification th international workshop proceedings volume lecture notes computer science montreal canada 
springer verlag 
valmari 
stubborn attack state explosion 
clarke kurshan editors computer aided verification number dimacs series discrete mathematics ieee transactions software engineering vol 
march theoretical computer science pages providence ri 
american mathematical society 
yeh young 
compositional reachability analysis process algebra 
proceedings symposium testing analysis verification tav pages new york oct 
acm sigsoft association computing machinery 
yeh young 
compositional analysis ada programs process algebra 
technical report software engineering research center department computer science purdue university july 
yeh young 
redesigning tasking structures ada programs analysis case study 
journal software testing verification reliability december 
young taylor 
integrated concurrency analysis software development environment 
kemmerer editor proceedings acm sigsoft third symposium software testing analysis verification pages 
appeared software engineering notes 
james corbett received degree computer science rensselaer polytechnic institute ph degrees computer science university massachusetts amherst 
currently assistant professor department information computer science university hawaii 
research directed devising practical techniques building automated tools analysis verification concurrent real time software 
