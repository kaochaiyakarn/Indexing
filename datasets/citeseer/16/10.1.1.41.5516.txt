principles programming complex objects collection types peter buneman naqvi val tannen limsoon wong january new principle development database query languages primitive operations organized types 
viewing relational database consisting sets records principle dictates investigate separately operations records sets 
immediate advantages approach partly inspired basic ideas category theory 
provides language structures record set types may freely combined nested relations complex objects 
second fundamental operations sets closely related collection types bags lists suggests database languages may uniformly extended new types 
general operation sets structural recursion programs welldefined 
looking limited forms operation give rise defined operations find number close connections existing database languages notably developed complex objects 
general paradigm structural recursion shown expressive existing languages complex objects possesses certain properties uniformity better candidate efficient practical language 
developing query languages extending example relational calculus advocate powerful paradigm number known database database languages natural sublanguages 
invited appeared theoretical computer science 
extended appeared proceedings th international conference database theory 
university department computer information science south rd street philadelphia pa 
email cis upenn edu bellcore south street morristown nj 
email bellcore com institute systems science 
heng mui keng terrace singapore 
email limsoon iss nus sg overcoming limitations order logic database query language major focus relational database research 
limitations known order logic express certain simple computations relations nature directly express queries structures simple relations nested relations useful database types bags multisets lists 
overcome limitations general strategies 
add extra operations fixpoint 
second consider higher order logics restricted algebras higher order nested relations 
extensions order logic leave desired clear fit address problems bags lists clear process extending order logic 
noted practical query languages object oriented databases require extensions sql aggregate operations bags 
special problems writing programs operate sets bags 
database systems provide interface conventional programming languages allows write programs iterate collection program sum int sum foreach sum sum program diff int foo foreach foo foo collection may typically list bag multiset set 
meaning sum appears obvious meaning attach diff collection set 
outcome depends order set traversed 
awkward way dealing problem assume non deterministic semantics meaning set outcomes programs diff 
possibility assume set carries intrinsic ordering dictates order iteration progresses 
ordering known programmer natural order choose integers generating ordering complex structures non trivial sensitive arbitrary choices database design 
practical languages contain general purpose iterators allow construction ill defined programs ensuring program defined left programmer 
approach problem characterize languages iterate collections look defined fragments languages 
database query languages appear avoid issue having built aggregate functions sum general purpose iterator assumption iteration encounter element set twice program sum ill defined sets issue arises query languages sql 
led look basic programming constructs collections allow reason definedness programs propose structural recursion general paradigm certain operations constructing sets 
add relatively simple operations records obtain language manipulating collections records relations restrict collections sets 
fact better obtain language query structures produced freely combining types complex object nested relational databases 
brings main point find known languages nested relations cleanly described approach 
benefit principles provide languages collection types fully develop languages 
process organizing programming primitives types known category theory useful take basic ideas subject 
particular shall calculus equivalent algebra functions nested relations 
algebra inspired understood categorical construction monad triple 
idea monads organize semantics programming constructs due moggi 
wadler showed useful organizing syntax particular explain list comprehension syntax functional programming 
trinder wadler showed extension comprehensions implement flat relational calculus 
trinder watt sought uniform algebra different bulk types particular proved number optimizations categorical identities 
technical development require familiarity category theory readers interested understanding motivation may wish refer introductory material texts 
deal practical aspects design syntax query languages focusses semantics constructs langauge 
comment problems syntax 
organization section introduce forms structural recursion collections give conditions definedness 
general method checking program satisfies conditions examine natural restriction structural recursion ensures definedness 
restriction leads immediately core language nested collections section enables develop calculus functional algebra 
exhibit translations languages preserve meaning preserving reflecting equational theories see appendices 
freely combined single language build nested relational language 
express number familiar operations relations nested relations show section express empty set set union 
adding gives stronger language language express operations equality test subset test membership test relational nesting set intersection non monotonic respect certain ordering 
show languages obtained adding operations equally expressive 
languages polynomial time complexity 
similar weaker result obtained assuming presence powerset operation 
show augmented equality testing equivalent known nested relational algebra thomas fischer 
follows nested relational language conservative respect flat relational algebra 
queries flat relations input flat relations output expressible flat relational algebra 
flat nested relational algebra seen natural fragments general programming paradigm position extend collection types see 
section augment language powerset operation cond obtain algebra abiteboul beeri 
view conservativity relational algebra algebra express functions transitive closure parity test potentially expensive excursion powerset type 
furthermore show uniformly compute cardinality set matter extra arithmetic primitives added 
power unrestricted structural recursion considered section 
show compute powerset powerful language abiteboul beeri 
importantly prove efficient uniform algorithms transitive closure cardinality expressed structural recursion simple arithmetic primitives 
clear efficiency obtained abiteboul beeri algebra 
lastly show certain conditions language abiteboul beeri simulate structural recursion 
section show axioms monad derive generalize known optimizations relational languages show categorical notion naturality provides general equational techniques 
conclude mentioning practical developments 
structural recursion collection types definitions structural recursion consider follow mathematical characterizations certain algebras operations collection types 
closely related familiar definitions functions simple recursion natural numbers example double double double fact function double satisfying equations function unique follows universality property enjoyed natural numbers successor operation 
algebra initial similar algebras exists unique homomorphism algebra 
case double homomorphism equations state precisely double homomorphism 
important necessary condition initiality natural number obtained finitely applications call operations constructors data type natural numbers 
functions defined simple recursion homomorphisms respect constructors 
structural recursion concept generalizes simple recursion data type defined similar algebraic universality property 
consequently devote subsection exhibiting groups constructors collection types interest 
followed subsection presentation forms structural recursion correspond groups constructors applicability conditions 
collection types constructors collection types interest foeg type finite sets elements type oe type finite bags elements type oe oe type finite lists elements type oe 
wish refer generically types common notation coll oe type finite collections elements type oe 
type constructions shall oe theta type pairs type oe type oe type functions argument type oe result type operations play role constructors collection data types 
observe appear principal ways constructing collection 
sets obtain finite set empty set fg finitely insertions notation 
may alternatively start singleton set constructor deltag perform finitely unions notation adding empty set special operation 
analogous constructors lists bags 
summarized table includes common notation allow give definitions types simultaneously 
empty addition singleton combination lists nil cons append bags 
increment sum sets fg fxg insert union common empty add sng comb list operations familiar 

bag operation increments number occurrences bag sums number occurrences element 
groups constructors collection types empty addition form group empty singleton combination form 
analogy simple recursion natural numbers look subsection universality properties enjoyed algebras coll oe add delta delta empty coll oe comb delta delta sng delta empty 
forms structural recursion collection type case lists constructors nil cons immediate generalization natural numbers situation 
isomorphic lists containing fixed element case nil zero cons successor function 
initial algebra yields functions defined structural recursion respect constructors sum sum sum sum unique homomorphism list algebra algebra mentioned kinds algebraic structures collection types coll oe add delta delta empty coll oe comb delta delta sng delta empty 
algebras initial appropriate class similar algebras 
gives forms definition structural recursion kind algebraic structure 
form empty add typing oe theta coll oe function depends shall notation sr add 
sr add structural recursion insertion 
shall notations sr add list sr add bag sr add set individual collection types 
lists sr add familiar fold reduce operation functional programming languages 
second form structural recursion empty sng comb typing oe theta coll oe depends shall notation sr comb structural recursion union 
may sr comb list sr comb bag sr comb set respectively individual collection types consider 
fixing arbitrary oe consider homogeneous sorted algebras infinite signatures unary operation add delta nullary operation sng 
examples forms structural recursion sum sum sum 
sum count bag count bag count bag count bag count bag count bag reverse reverse oe oe reverse reverse reverse reverse max fg max fng max max max alternatively written count bag sr add bag max sr comb set max id id definedness conditions happens functions shown defined stated types 
note equations definitions structural recursion state desired functions homomorphisms 
state algebras targets functions belong class collection type algebras initial necessary condition existence desired functions 
naive analog sets definition count bag set fxg set set set doesn set erroneous function counts twice elements doesn exists mathematical function set satisfying equations 
existed set fag set fag fag set fag set fag essential note algebra bags summation singleton empty bag operations initial algebras form commutative monoid algebra lists append singleton nil require just monoid structures algebra sets union singleton empty set need commutative idempotent monoids equivalently upper semilattices element 
similarly algebra sets insertion empty set operations initial similar algebras left commutative left idempotent operation algebra bags increment require left commutativity 
table summarizes definedness conditions structural recursion constructs 
note conditions downwards cumulative 
defined sets defined bags lists defined bags defined lists 
sr add sr comb lists associative condition identity bags left commutative commutative sets left idempotent idempotent examples observe sr comb sr add 
expressible sr comb immediately expressible sr add 
number powerful functions obtained structural recursion 
example general form mapping follows 
oe arbitrary function map defined map empty empty map coll oe coll map add add map sets example meaning map delta map fa ff straightforward show map defined collection type 
carrying define power operator power empty sng empty power coll oe coll coll oe power add comb power map power add gives generalization powerset collection types shown welldefined 
example fg foeg 
obtained sr comb bag deltag fg 
similarly easily write sr add sr comb 
section contains examples functions definable structural recursion 
fact consider sr comb definitions results generalize binary trees dropping associativity requirement levels boom hierarchy types 
higher order programming exponential computations define sr add terms sr comb 
identities initiality postulates unique homomorphisms composition homomorphisms homomorphism follows immediately left commutative sr add list sr add bag ffi particular ffi follows left commutative left idempotent sr add bag sr add set ffi analogous identities sr comb easily seen hold 
bad news unfortunately simple programming languages featuring structural recursion basic constructs ability manipulate pairs asking equational conditions associativity left idempotence commutativity true program phrases undecidable fact recursively axiomatizable 
programming languages full fledged structural recursion collections language easy sell 
see database programming necessarily serious inconvenience programming done restrictions defined 
restriction structural recursion view fact checking definedness structural recursion decidable consider limited form defined sets bags lists 
empty empty sng comb comb typing oe coll ext coll oe coll notation ext 
specializations ext set ext bag ext list 
meaning ext apply member flatten resulting collection collections 
ext set fx delta delta delta ext bag fjx jg delta delta delta ext list delta delta delta expressiveness ext delta examples expressive power ext delta suggest interest database programming 
ffl map ext sng 
ffl flatten coll coll oe coll oe flattens collection collections combining members flatten ext id 
ffl pi coll oe theta coll oe projects component pi map similarly pi coll oe theta coll 
sets relational projections 
ffl function pairwith oe theta coll coll oe theta pairs element element collection pairwith map 
similarly pairing right pairwith coll oe theta coll oe theta 
ffl depending argument traverse generalizations cartesian product type coll oe theta coll coll oe theta 
ext pairwith second ext pairwith 
bags sets coincide 
sets usual cartesian product 
ffl function unnest coll oe theta coll coll oe theta nested collection unnest ext pairwith 
see simple defined instance structural recursion express important operations interpreted sets operations relational nested relational algebra 
monads ext delta interesting expressive instance mathematically ubiquitous studied concept monad see monads called algebraic theories 
category theory monads scope 
main body monads notably section mainly terminology 
reader interested information monads appendix category theoretic version monad axioms preceded short discussion relationship structural recursion monads 
core language built monad constructs want develop core language starting expressive power ext delta 
sets treated follows 
bags lists treated similarly 
shall take complex object types types constructed set product 
types unit theta fg ranges base types 
example instantiated basic data type integers strings type unit contains just element 
taken type ary tuples tuple product set types described subsection 
section equivalent formulations monad core language complex objects 
subsection calculus heavy bound variables 
second subsection algebraic variable free 
equivalent sense describe class functions map complex objects complex objects subsection 
appendix give deeper equivalence result relates equational theories formulations 
core calculus complex objects assume infinite collection variables simplicity assigned forever complex object type oe variables range complex objects important restriction precludes variables bound functions 
expressions types rules 
rules range expressions variables oe complex object types 
order additional point function definitions avoided core language done expressions denote data objects shall syntax phix oe denote ext oe lambda notation phix oe ext oe 
typing phix oe fg foeg phix oe fg expression phix oe little special bound variable similar variables bound lambda abstractions purpose introducing special notation specifically avoid introducing language general construct lambda abstraction 
scope oe subexpression note part scope 
easier see recall phix oe suggested alternative notation ext oe 
customary identify expressions differ name bound variables adopt bound variable convention says mathematical context assume bound variables distinct distinct free variables occurring context 
addition phi add language expected operations associated products type unit singleton set formation 
variables oe oe products oe oe theta oe theta oe unit sets feg fg foeg fg phix oe fg note typed expression unique type denote type 
note operations sets absent notably emptyset union 
choice order language corresponds closely monad operations obtain exact correspondence equivalent formulation category theoretic operations functions 
see subsection theorem 
emptyset union operations added formalisms calculus complex objects equivalent algebra functions consider extensions section 
informal meaning expressions quite clear theorems follow benefit concise formal definition standard meaning 
expressions free variables introduce valuations environments type preserving functions ae variables complex objects 
ae assigns value free variable define meaning expression environment ae denoted ae follows oe ae ae oe ae ae ae ae ae ae ae unique element unit viewed tuple components unit viewed ary cartesian product feg ae aeg phix oe ae ae oe delta delta delta ae oe ae fa ae ae ae phix oe ae 
easy see ae depends values ae takes free variables meaning expressions free variables understood function 
example expression free variables oe oe associate function oe theta oe takes ae 
remarkably elegant alternative description functions definable complex object expressions core calculus subsection 
equivalent variable free core algebra functions algebraic variables 
alternative complex object calculus introduced subsection 
important distinction operations calculus manipulate complex objects operations algebra manipulate functions complex objects complex objects 
natural look category theory inspiration operations borrow general category theoretic terminology notation terminators functorial strength algebra 
talking sets set theoretic functions meaning operations easily explained elementary terms right away interested reader consult appendix category theoretic axiomatization operations 
algebra sorted language 
usual language category theory sorts form oe oe denotes source domain object denotes target codomain object 
case oe complex object types 
operations algebraic presentation category oe ae ffi oe ae id oe oe oe binary products oe oe hf oe theta fst oe oe theta oe snd oe oe theta terminator ter unit monad sng fg oe map foeg fg flatten fg functorial strength pairwith oe oe theta fg foe theta omit type subscripts possibility confusion 
standard model presentation functions complex objects 
meaning operations model ffi function composition id identity functions hf fst snd second projection functions ter maps unique element unit sng produces singleton sets single elements map fa ff flatten fs sm delta delta delta sm pairwith fa useful abbreviation dealing products 
oe oe write theta hf ffi fst ffi oe theta oe theta choice sng map delta flatten describe monads 
example monads equivalently described sng ext delta view identities map ext sng ffi flatten ext id fg ext flatten ffi map examples functions definable algebra consider ffl pi map fst pi map snd relational projections sets pairs 
ffl pairwith map ffi pairwith ffi 
pairwith pairwith pairs left 
ffl flatten ffi map pairwith ffi pairwith ffl unnest flatten ffi map pairwith 
interesting note language designed pragmatic purpose communicating functional network databases roughly set functional operators 
translations calculus algebra mentioned expressions calculus define functions consider free variables arguments 
generally want consider finite sequence distinct variables oe oe include free variables expression 
gamma range sequences 
deal closed expressions free variables want consider empty sequence 
gamma oe denotes sequence obtained adding variable oe gamma provided oe gamma 
sequence associate type cartesian product types variables sequence type unit type gamma oe type gamma theta oe notation gamma pair consisting typed calculus expression sequence variables gamma containing free variables pair associate function gamma type gamma type recall type unique type follows oe oe oe proj gamma 
ha gamma gamma gamma fst ffi gamma gamma snd ffi gamma gamma 
ter type gamma gamma feg sng ffi gamma gamma phix oe flatten ffi map gamma oe ffi pairwith type gamma oe ffi hid type gamma gamma proj defined proj id proj snd proj proj gamma ffi fst translation gamma phix oe assume bound variable convention oe gamma 
note translation essential functorial strength pairwith translate algebra functions calculus complex objects associate function oe pair oe typed calculus expression exactly free variable oe translation goes follows ffi oe oe result substituting id oe oe oe hf oe 
oe oe fst oe oe theta 
snd oe oe theta 
ter 
sng fxg 
map foeg phix oe feg oe flatten phis fg pairwith oe oe thetaf phiy translations preserve meaning 
formally theorem 
pair gamma calculus denoting gamma ffl gamma ae unique element type unit ae arbitrary ffl gamma oe oe ae delta delta delta unique element type unit ae arbitrary 

function oe algebra denoting oe ae ae oe ae 
proof theorem straightforward inductions calculus expressions part algebra expressions part omitted 
semantic relationship calculus algebra sufficient concern query language expressiveness 
standard model functions complex objects considering worthwhile considering associated equational theories may possible models 
explain section equational axiomatization standard mathematical properties play important role validating discovering optimizations 
algebra equational theory axiomatized commutative diagrams standard category theory style appendix 
calculus find corresponding axiomatization style lambda calculus appendix see 
think equational theories semantics turns profound relationship exists calculus algebra show appendix translations preserve reflect equational theories 
notation 
calculus algebra equivalent speak conceptually core language constructs associated monad 
choose formalisms need prove core language 
equivalence calculus algebra effective translations syntactic sugar mixes formalisms wish show expressible example oe function algebra oe expression calculus apply writing calculus expression oe type obtained translating calculus oe 
expression calculus oe oe sequence distinct variables containing free variables obtain function algebra variables add auxiliary function definition fname fname oe theta delta delta delta theta oe function algebra knowing fname stands algebra expression ffi delta delta delta idi theta id theta delta delta delta theta id obtained translating algebra oe oe 
sections extend primitives 
important keep mind extensions done differently formalisms 
complex object calculus add expression construct form arg type delta delta delta arg type type algebra functions add functional constant dtype ctype equivalence calculus algebra preserved typically gamma straightforwardly expressed terms terms notation 
sigma signature additional primitives denote extension primitives sigma 
nested relational algebra proceed enrich order express operations relational algebra particular interest nested relational algebra 
equivalent formulations nested relational algebra goals section rational reconstruction 
mention specific operations nested relational algebra unnest foe theta fgg foe theta saw section expressible nest foe theta foe theta fgg considered 
operations relational algebra seen section relational projections pi pi cartesian product expressed union expressed section extend parsimoniously staying polynomial time computability 
reach formulation equivalent nested relational algebra argue utility conditional conclude section discussion advantages formulation 
adding union empty set theorem binary union emptyset expressed proof 
assume domain complex objects base type distinct elements consider sub domain set type exactly member 
sub domain closed operations functional algebra theorem 
contain empty set closed union union fc fc members 
set union operation empty set definable add primitives types 
complex object calculus fg fg fg fg fg algebra functions emptyset unit fg union fg theta fg fg notations 
shall fg 
wadler noted usefulness extension monad termed see 
shall shorthand notations fe fe fe fe relational algebra operation selection normally requires boolean type 
conceptual economy possible simulate booleans representing true false fg values type note disjunction interesting jg simulate type natural numbers 
sr usual recursion natural numbers type 
representation selection definable select phix pi fxg oe foeg predicate free variable trick false empty 
consequently fxg empty 
contribute result 
adding non monotonic operations remaining operator flat relational algebra set difference operator 
weaker operation positive relational algebra set intersection operator 
theorem intersection expressed proof 
define ordering oe complex objects type oe follows ffl object base type ffl oe theta oe ffl foeg oe checked functions definable monotone respect ordering set intersection 
follows set difference defined similar argument shows equality defined membership subset predicates 
nesting operation nested relational algebra defined mutually definable operations nest nest example nest right nesting operation type foe theta foe theta fgg 
extension necessary 
turns extension equivalent ways 
shall notation sigma augmented additional primitive operations sigma 
example augmented calculus style oe oe corresponding function eq oe oe theta oe functional algebra 
theorem sigma additional primitive signature 
languages equivalent intersection sigma sigma difference sigma subset sigma member sigma nest sigma 
proof 
show equivalences exhibit translations functions 
course provide usual complement boolean functions 
equality define pi fxg eq 
returns singleton set fxg eq true fg 
set intersection obtained flat mapping function cartesian product intersection 
conversely equality may defined intersection eq map ter intersection fxg fyg 
sigma intersection sigma 
recall implemented booleans values type fg false true 
disjunction conjunction directly implemented union intersection 
implement negation consider relation fg fg pairs false true true false 
select relation tuple left component matches input project right component flatten pi select fg fg eq implement existential universal quantification 
define satisfies phix satisfies satisfies predicate expression free variable represent predicate calculus notation satisfies predicate calculus notation satisfies brings implementation set difference terms equality difference select satisfies eq noting intersection easily obtained difference sigma intersection sigma difference sigma 
equality obtained membership eq member fyg 
membership obtained equality member satisfies eq 
mutual dependence member subset immediate 
sigma member sigma subset sigma 
examine nest derived equality follows 
consider function oe theta foe theta oe theta fg returns pair fy sg 
defined pi select eq 
nest obtained pairing member left column mapping relation formed nest map pairwith pi 
conversely show difference derived nest nest observe negation obtained nest follows 
writing fg consider boolean variable form set apply nest pi yields ff gg true ff gg false 
apply flatten ffi map map fst theta snd ffi ffi hid idi obtain respectively 
empty set cartesian product empty set applying flatten ffi map fst ffi gives respectively 
obtain difference sets pair member member nest left column 
compute nest ffi union pairwith pairwith 
tuples relation form ff tg ffg ftg difference difference 
apply flatten right hand column apply sng left tuples form fag fbg fcg 
negate second column just shown done nest apply cartesian product tuple obtain elements difference 
completes proof 
related result proved gyssens van gucht showed non monotonic operators inter definable language schek scholl powerset operator available additional primitive 
view results follow theorem indicates language polynomial time complexity theorem shows language equivalent schek scholl theorem significant improvement 
equivalence result choose non monotonic operations equality add theorem ptime computability assuming functions denoted primitive function symbols computable polynomial time respect size input 
functions definable sigma computable polynomial time respect size input reasonable definition complex object size 
proof 
consider presentation sigma algebra functions 
function definable way polynomial time bound function jf jf jgj jhj hg hi jgj jhj ffi delta jgj map kp primitive function bound assumption fact result strengthened showing implementation suggested operational semantics structural recursion polynomial 
relating nested relational algebras 
language thomas fischer widely known nested relational algebras 
language schek scholl extension thomas fischer recursive projection operator 
language colby turn extension schek scholl operators recursive 
theorem colby algebra expressible algebra thomas fischer 
result strengthened showing coincides expressive power nested relational languages 
argued possesses just right amount expressive power manipulating nested relations 
detailed description thomas fischer language required proving result 
ffl union sets 
union oe foeg theta foeg foeg 

ffl intersection sets 
intersection oe foeg theta foeg foeg 
definable theorem 
ffl set difference 
difference oe foeg theta foeg foeg 
definable theorem 
ffl relational nesting 
nest oe foe theta foe theta fgg 
definable theorem 
ffl relational unnesting 
unnest oe foe theta fgg foe theta defined section 
ffl cartesian product 
oe foeg theta fg foe theta defined section 
ffl projection operator relational projection 
general relational projection works multiple columns form projection 
interpreted map restriction placed form built entirely fst snd delta deltai delta ffi delta id ffl selection operator relational selection form selection 
interpreted select eq stands input relation 
restriction projection placed ffl traditional relational algebra thomas fischer letters represent input relations 
loss generality input relation considered 
reserve letter purpose assumed distinct variables 
constant relations written directly 
example constant relation element empty set 
query just expression complex object type free variable 
view thomas query function theorem thomas schek scholl colby 
proof 
show function thomas 
clearly definable terms prove function definable definable thomas 
encode oe oe theta oeg function encode oe decode theta partial function decode note encode oe decode definable thomas oe products set types 
suppose claim 
closed morphism oe complex object type ffi query fffi theta oeg fffi theta thomas denotes function map id theta 
calculate ffl decode ffi ffi encode decode ffi map id theta ffi encode claim 
decode ffi sng ffi fi encode sng ffi idi 
remains provide proof claim 
difficult define induction structure complete proof wong 
provide case form map illustration 
define map fffi fffi thetaf gg assume hypothesis fffi fffi theta exists 
define ffi fst id ffi nest unnest map hid 
map id theta contains exactly pairs right component nonempty 
define projection fst ffi fst selection snd ffi fst snd 
map id theta contains exactly pairs right component empty 
set map union 
seen definition map simple 
reasons 
reason may satisfy severe restriction thomas fischer put projection operation 
second reason way implement emptiness test language thomas fischer selection operation 
immediate corollary theorem corollary function flat relations flat relations expressible expressible flat relational algebra 
proof 
known paredaens van gucht function flat relations flat relations expressible thomas expressible flat relational algebra 
corollary follows theorem 
fact able strengthen theorem paredaens van gucht general theorem conservative extension property various extensions 
show definability function independent restriction imposed depth set nesting intermediate data 
conditionals construct needed programming 
consider function cond oe theta oe theta oe oe cond returns nonempty 
function definable types oe 
techniques proof theorem allow define oe form foe theta delta delta delta theta foe cond oe definable oe base type function output type base type constant function chain projection operations 
find useful conditional calculus style oe oe oe algebra style cond oe theta oe theta oe oe noted addition conditional convenience greatly affect expressive power 
discussion nested relational algebras introduced relax normal form restriction originally imposed codd considered unacceptable modern applications 
earliest definition schek allowed components tuples sets atomic values 
nesting relations restricted levels 
restriction relaxed thomas fischer allowed relations nested arbitrary depth 
algebraic query language consisted operators flat relational algebra generalized nested relations operators nesting unnesting relations 
operators applied outermost level nested relations 
deeply nested relation manipulated necessary bring outermost level sequence unnest operations top level manipulation push result back right level nesting 
nest unnest mutual inverses care taken restructuring gauged full proof theorem 
constant need restructuring eliminated schek scholl introduced recursive projection operator navigation colby operators recursive 
method ad hoc sense individual definitions required recursive operator 
example semantics schek scholl recursive projection operator cases 
map delta construct cond allows operations performed levels nesting completely eliminating need restructuring nest unnest thomas fischer algebra 
recognition function passed map delta simplifies language eliminating need ad hoc operations complicated semantics 
expression construct cond enjoys status freely mixed long typing rules violated eliminating need special syntax parameters different operators 
addition provides framework extend nested relational algebra collection types allows reason languages external functions aggregate operations sql 
believe cond may profitably considered right nested relational algebra 
power structural recursion languages powerset shown nested relational algebra admits elegant formulation operations complex objects suggested concept monad 
time nested relational algebra severe limitations expressiveness 
view corollary polynomial time operations transitive closure parity defined cond 
section consider constructs extend expressive power cond 
subsection discuss abiteboul beeri complex object algebra essentially adds finite powerset operations cond 
increases expressive power suggest inflexible programming style 
subsection show structural recursion express efficient polymorphic algorithms functions reach nested relational algebra 
subsection show absence external functions powerset operation express functions defined structural recursion albeit inefficient non polymorphic manner 
abiteboul beeri complex object algebra view theorem powerset definable cond 
abiteboul beeri introduce languages express powerset show equivalent complex object algebra calculus extension datalog certain higher order predicates subset membership 
gyssens van gucht show augmentations nested relational algebra recursive iterative constructs equivalent augmentation powerset 
add complex object type oe primitive powerset oe foeg obtain formalism equivalent complex object algebra 
purpose define abiteboul beeri algebra cond powerset abiteboul beeri show express transitive closure relation selecting powerset pi pi relations transitive contain intersection 
intersection set sets readily defined cond complements difference flatten phis fg difference flatten test equal cardinality expressed sets construct powerset test contains bijection test parity cardinality set testing subset sets difference equal cardinality 
discussed operational semantics languages considered clearly expressions transitive closure parity powerset suggest exponential time algorithms obvious exponential space fact queries polynomial 
fact corollary clear queries transitive closure equal cardinality parity definable potentially costly excursion powerset 
observation begs question efficient way programming queries delicate question depends accepting reasonable notion operational semantics suciu paredaens show adopt usual eager evaluation strategy queries expression transitive closure construct intermediate result exponential size obtaining expspace lower bound 
abiteboul hillebrand show operational semantics pipelining optimizations yields pspace exptime algorithm expression transitive closure mentioned 
strongly inclined think offer flexible programming style able code transitive closure parity efficiently 
shall see subsection structural recursion express efficient algorithms transitive closure parity straightforward manner 
aspect inflexibility precise considering cardinality 
turns cardinality function primitive type natural numbers definable matter arithmetic functions take primitives 
extension primitive type arbitrary primitive arithmetic signature constants functions form theta delta delta delta theta careful mean cardinality definable finite complex object type oe containing specific trivial expression oe cardinality function type foeg sets type foeg known definable language recall assumed oe doesn contain just compare argument oe build answer oe course expressions oe depend uniformly type 
precisely uniform parametric polymorphic definition exist 
describe precisely polymorphic definitions introduce type variables ff fi consider complex object type expressions ff unit theta avoid technical problems type variables occurring type usual variables free bound consider expressions functional algebra formalism bound variables 
interested closed variable free expressions call polymorphic expressions 
type variables may occur polymorphic expressions subscripts id fst sng ter snd flatten pairwith emptyset union eq powerset substitute 
example snd fff ff ff snd say cardinality polymorphically definable exists polymorphic expression count set fffg ff type variable complex object type oe expression count set oe ff foeg denotes cardinality function foeg theorem cardinality polymorphically definable 
proof 
complex object max largest natural number occurs occurs 
show claim 
polymorphic expression exists increasing map instantiation obtained substituting complex object types type variables max max 
proof claim 
take id fst delta delta delta cond powerset identity explains gives bound instantiations arithmetic primitive take max xn yn 
claim follows induction prove theorem assume polymorphic cardinality function count set fffg exists count 
oe complex object type containing foeg elements example oe form delta delta delta delta delta delta claim count set oe ff denote cardinality function type foeg shall see structural recursion allows straightforward polymorphic definition cardinality 
power structural recursion powerful time flexible language sets consider uses structural recursion specifically construct introduced section fg oe theta foeg denoted sr add set 
seen subsection express sr comb set terms sr add set ext delta phi expressed sr add set direct formulation phix fg fg conditional expressed fg seen section structural recursion express powerset powerset fg map structural recursion primitives distinct phi powerful problems arise proven conjectured interesting show structural recursion offers flexible programming style allows polymorphically expressing efficient algorithms parity test set cardinality transitive closure 
parity test notice predicate fffg satisfies fg true member quite structural recursion collections defined 
general form empty add oe theta foeg theta coll oe recalling idea kleene code predecessor function lambda calculus apparently stronger form obtained simple structural recursion snd ffi sr add oe theta coll oe theta coll oe theta defined add empty 
suitably generalized forms left commutativity left idempotence constitute sufficient conditions defined sets 
easily verified definition 
case bags require generalized left commutativity conditions needed lists 
set cardinality promised earlier count set fffg polymorphically definable structural recursion similar manner count set fg count set member count set count set transitive closure clear implementation transitive closure section severely inefficient 
show better algorithm transitive closure expressed structural recursion 
need binary relation composition expressible map select fact higher order lambda calculus express efficient algorithm testing equality cardinality 
consider ff theta ff theta fff theta ffg fff theta ffg defined frg frg frg frg transitive closure tc fff theta ffg fff theta ffg tc fg fg tc tc verify tc defined 
semantics commutativity idempotence conditions right set values meaning tc fact transitive closure operator 
follows slight abuse notation writing semantic proofs semantic facts programming syntax 
fact proofs lemma formalized syntax logics described 
need notation semantic transitive closure denoted proposition 
fg transitive 
transitive transitive 

transitive 


transitive 
key observation proving part simple fact fsg fsg fsg 
part implies tc correctly defined working range consisting transitive relations shown part 
part follows immediately part part part 
part lemma essential step showing structural induction insert presentation sets tc algorithm transitive closure resembles warshall algorithm doing edge insertion node insertion 
obtain warshall algorithm suppose set nodes fffg set edges fff theta ffg nodes 
transitive closure defined fg show defined set pairs nodes connected paths intermediate nodes belong warshall algorithm runs time edge insertion algorithm runs delta time number nodes number edges 
case efficient algorithms transitive closure comparison query mentioned earlier 
spirit warshall algorithm represent floyd shortest paths algorithm 
equivalent structural recursion external functions absent explained theorem sense structural recursion strictly powerful want explain intuition certain fixed points fact simulate datalog language predicates sets able express functions defined structural recursion relations appropriate properties 
turn justify intuition formally reduction structural recursion polymorphic 
difficulty formalizing intuition comes fact order express relations powerset intersection set sets need kind universe collects elements involved computation fixed point 
simple get case transitive closure simply elements occurring relation 
situation general quickly realize done presence primitive functions 
consider finite constants fc base type 
theorem class functions expressible essentially closed structural recursion 
proof 
define type oe functions forth oe back oe forth oe oe computes set elements type occur complex object type oe forth sng forth unit emptyset forth oe theta union ffi forth oe theta forth forth foeg ext forth oe back oe foeg basic set constants computes set finite universe complex objects type oe constructed elements back fc back unit back oe theta ffi oe back back foeg powerset ffi back oe verify definitions proving claim complex object type oe back oe forth oe 
claim ii 
oe function expressed plus structural recursion basic set constants 
complex object type oe back oe back 
claims proved induction complex objects function expressions 
details omitted 
show closed definitions structural recursion 
oe oe theta expressible 
foeg variable 
need expression sr add set expressed foeg words expresses result applying foeg think foeg expressing complex object takes argument 
forth foeg foeg expresses basic set constants occur argument 
back expresses set complex objects type built constants 
view claim ii result applying foeg complex objects 
step express binary relation type theta graph restricted arguments built constants set powerset back foeg back consists binary relations complex objects built constants 
set select relations contain fg oe foeg satisfies subset map foeg oe foeg 
clearly expressed want smallest relation selected achieved intersection see subsection 
resulting expression 
universality property defines follows expresses desired graph restricted arguments built constants select pairs left component foeg pair function take second relational projection 
result expression type fg semantically equivalent gs foeg modulo small desired result returns singleton set containing result 
set type product set types remedied composing relational projections 
types translation adjusted take care reason qualifier essentially theorem statement straightforward 
point result practical transformations suggests polymorphic efficient 
addition formalizing certain intuitions flavor languages hope able transfer theoretical results example complexity lower bounds languages structural recursion 
optimization equational theories equationally provable optimization equational theory exhibit query languages validate algebraic optimizations 
trinder studied optimizations languages ones 
comprehension syntax equivalent phi identifies qualifier interchange identity comprehensions generalizes important optimization known selection promotion 
illustrate power equational theories appendices show similarly selection promotion provable theories 
foeg fg sets oe theta predicate 
wish show really tests component argument equivalent appropriate oe example take fun selection select pz provably equal select may reduce size sets involved cartesian product product computed 
calculations obscure redefine selection select phix fxg fg small variation pointed section types conditional fact definable definition get back original definition selection 
recall phix pairwith pairwith phiy expanding syntactic sugar applying axioms axiom axiom appendix select pz phix phiy fg replace progress simplifying expression need axioms extension cond axiom axiom appendix 
applying get phix phiy fg sort normal form try reach transforming equationally expression select 
fact wong organizes equational theories confluent terminating rewrite systems 
expanding syntactic sugar get phix phix fxg fg pairwith applying axiom appendix phix phix fxg fg pairwith progress need axioms specific cond axiom axiom appendix 
applying axiom appendix get normal form reached completes proof 
naturality 
equational theory validation tool optimizations hope foundations discover useful optimizations 
example algebraic optimizations take form constructs 
property known category theory typically form commutation naturality 
see consider complex object type expressions type variables 
interpret type expressions type variables functors set set closed polymorphic expressions eq turns show meanings various sets assigned type variables natural transformations 
action morphisms functors expressible language 
naturality expressed family equations hold expressions 
equational theory prove naturality construct separately know general category theoretic considerations able prove naturality equations expression eq 
precisely consider type expression primitive types list distinct type variables ff ff includes type variables 
define functor set set associated type expression follows 
action objects oe oe 
oe ff oe ff abbreviation oe ff delta delta delta oe ff 
action morphisms defined entirely inside language follows 
oe 
oe define morphism oe ff ff induction ff unit id unit theta theta map abbreviation theorem naturality polymorphic expression eq type variables list ff ff oe 
oe equation ff ffi ffi oe ff true fact provable equational theory appendix enriched axioms state naturality emptyset union cond powerset 
mentioned notice equational theory proves naturality language constructs theorem holds general category theoretical principles 
appears generalizes identities algebraic optimizations especially regarding projections 
recall definition pi ff ff map fst ff ff note action type expression functors morphisms similarly combines map tuple manipulation 
simple application theorem yields oe oe pi ffi map theta map ffi pi oe oe interesting application fffg simplicity just type variable ff 
take fst oe oe theta oe role theorem gives pi oe ffi oe theta ff oe ff ffi fst oe turns meanings injective functions deal non monotonic primitives equality theorem holds semantically semantic statement bijections get queries definable generic consistent 
genericity respect additional primitive operations shown working bijections homomorphisms operations 
results extend structural recursion 
developments related semantics languages derive structural recursion collection types 
considerable effort needed realize semantics syntax practical programming language 
inception practical developments 
implementation practical languages naqvi colleagues bellcore 
model telecommunications operations support systems 
prototype system allows planners designers manipulate models digital loop carrier systems multiple choices subcomponents parts explosion functionally equivalent subparts 
experimental prototype system veil design design manager telecommunications equipment 
second practical development collection programming language cpl programming environment kleisli implemented wong hart university pennsylvania 
implementation uses optimizing transformations derive directly 
addition substantial body research expressive power various forms structural recursion complexity languages structural recursion investigation structural recursion collection types focussed sets 
collection programming language cpl observation monad operations interpret syntax comprehensions functional programming languages wadler connection database query languages shown trinder wadler watt 
comprehension syntax realized cpl superficially resembles zermelo fraenkel set notation important differences 
example composition binary relations expressed cpl nx ny gamma ny nz gamma right hand part body comprehension contains syntactic forms generators nx ny gamma conditions general form generator gamma pattern expression denoting collection 
patterns serve introduce variables 
matching pattern successive components collection variables bound values 
explicit marking nx variable introduced important general form pattern matching 
example expression equivalent nx ny gamma nz gamma sg 
wadler observed comprehension form fe nx gamma remaining components generators conditions body comprehension may expressed phix fe extension idea account general patterns conditions interpret comprehension syntax 
language cpl exploits obtain query semantics manipulates collection types lists bags sets records variants 
description cpl example employee type taken 
name firstname string lastname string int status regular salary int extension string consultant day rate int phone string projects string firstname string lastname string record type regular 
consultant 
variant tagged union type 
variants known programming languages overlooked data models absence creates needless fragmentation database confusion null values 
variants conveniently pattern matching name phone name nn status consultant phone nt gamma name count name nn status regular nr projects np gamma query finds names telephone numbers consultants pattern comprehension matches consultants 
second query returns regular employee name number projects employee assigned 
cpl allows expression queries 
allows function definitions general forms structural recursion described 
obvious similarity comprehension syntax known languages sql form select 


authors believe ideas may better starting point relational algebra practical implementation query languages number reasons 

need mentioned extend query languages new collection types allow nested collections 

ability incorporate variants give clean interpretation pattern matching 

ability construct data structures complicated analyzed 

ability implement functions incorporate external functions systematic fashion 
implement query languages allow function definition 
believe functional account database query languages important 
university pennsylvania interfaces constructed cpl biological databases part human genome project 
language provided biological researchers simple language querying integrating number biological data sources performed existing query languages 
sources include standard relational databases include data number data exchange formats 
data sources expressed asn format describe sets lists variants records arbitrary combinations types points 
frequent requirement data restructured complex format suitable input say user interface point 
data contained special purpose software sequence matching programs implement external functions point 
results structural recursion collection types appearance papers substantial body related research appeared 
conservative extension result shows adding bounded fixed point construct cond gives relational types inflationary datalog 
shown nesting intermediate types add expressiveness presence aggregate functions certain generic queries 
results expressive power 
approach different collections languages sets studied bag languages 
mentioned shows transitive closure efficiently expressible structural recursion necessarily exponential implementation complex object algebra 
show encode related database languages simply typed lambda calculus 
possibility treating arrays collection types suggested 
connections parallel complexity classes studied 
shows presence suitable external functions sr add set strictly expressive sr comb set studies foundational issues concerning complex objects queries external functions 

authors afrati dirk van gucht leonid libkin hermann jon riecke dan suciu steve vickers helpful discussions paul taylor diagram macros 
tannen partially supported onr nsf ccr aro prime 
buneman partially supported onr nsf iri uk serc visiting fellowship imperial college london 
wong partially supported nsf iri aro prime 
abiteboul beeri power languages manipulation complex objects proceedings international workshop theory applications nested relations complex objects darmstadt 
abiteboul hillebrand space usage functional query languages lncs proceedings th international conference database theory prague czech republic january 
abiteboul vianu fixpoint extensions order logic datalog languages proceedings th ieee symposium logic computer science pacific grove california june 
aho ullman universality data retrieval languages proceedings th symposium principles programming languages texas january 
bancilhon briggs khoshafian valduriez powerful simple database language proceedings th international conference large data bases 
barendregt lambda calculus syntax semantics elsevier 
breazu tannen buneman naqvi structural recursion query language proceedings rd international workshop database programming languages greece august 
breazu tannen subrahmanyam logical computational aspects programming sets bags lists lncs proceedings th international colloquium automata languages programming madrid spain july 
breazu tannen buneman wong naturally embedded query languages lncs proceedings th international conference database theory berlin germany october 
buneman libkin suciu tannen wong comprehension syntax sigmod record 
buneman frankel nikhil implementation technique database query languages acm transactions database systems 
buneman fast fourier transform database query 
technical report ms cis department computer information science university pennsylvania philadelphia pa march 
chandra harel computable queries relational databases journal computer system sciences 
chandra harel structure complexity relational queries journal computer system sciences 
codd relational model large shared communications acm 
colby recursive algebra nested relations information systems 
fegaras efficient optimization iterative queries proceedings th international workshop database programming languages new york august 
fegaras maier effective calculus object query languages proceedings acm sigmod conference management data san jose may 
appear 
goguen thatcher wagner initial algebra approach specification correctness implementation data types current trends programming methodology prentice hall 
goguen meseguer completeness sorted equational logic houston journal mathematics 
gyssens van gucht comparison algebraic query languages flat nested databases theoretical computer science 
gyssens van gucht powerset algebra natural tool handle nested database relations journal computer system sciences gunter libkin sml functional database programming language disjunctive information proceedings conference database expert systems applications athens greece september 
hart wong query interface heterogeneous biological data sources manuscript february 
available www ftp www cis upenn edu pub papers db research kleisli ps hart wong overton buneman query language integrate biological data abstracts meeting interconnection molecular biology databases stanford august 
available www www cis upenn edu cpl html 
imielinski naqvi querying design planning databases lncs proceedings nd international conference deductive object oriented databases munich germany december 
immerman stemple expressiveness family finite set languages proceedings th acm symposium principles database systems may 
iso standard information processing systems database language sql 
schek remarks algebra non normal form relations proceedings acm symposium principles database systems los angeles california march 
hillebrand kanellakis mairson 
database query languages embedded typed lambda calculus 
proceedings th ieee symposium logic computer science montreal canada june 
lambek scott higher order categorical logic cambridge university press london 
libkin aspects partial information databases phd thesis department computer information science university pennsylvania philadelphia pa august 
libkin wong semantic representations query languages sets proceedings th acm symposium principles database systems washington may 
libkin wong aggregate functions conservative extension linear orders proceedings th international workshop database programming languages manhattan new york august 
libkin wong conservativity nested relational calculi internal generic functions information processing letters 
libkin wong new techniques studying set languages bag languages aggregate functions proceedings th acm symposium principles database systems minneapolis minnesota may 
libkin wong properties query languages bags proceedings th international workshop database programming languages manhattan new york august 
libkin approximation databases lncs proceedings th international conference database theory prague czech republic january 
maclane categories working mathematician springer verlag berlin 
macleod database management system document retrieval applications information systems 
consideration normal form necessarily normalised relation relational data model proceedings rd international conference large databases tokyo japan october 
manes algebraic theories springer verlag berlin 
meertens algorithmics programming mathematical activity proceedings cwi symposium mathematics computer science north holland 
meyer mitchell moggi statman empty types polymorphic calculus proceedings th symposium principles programming languages 
january 
milner tofte harper definition standard ml mit press 
moggi notions computation monads information computation 
naqvi tsur logical language data knowledge bases computer science press 
ohori buneman breazu tannen database programming machiavelli polymorphic language static type inference proceedings acm sigmod international conference management data portland oregon june 
paredaens van gucht converting nested relational algebra expressions flat algebra expressions acm transaction database systems 
optimizing functional query languages proceedings conference information knowledge management washington 

schek scholl relational model relation valued attributes information systems 
suciu fixpoints bounded fixpoints complex objects proceedings th international workshop database programming languages manhattan new york august 
suciu tannen query language nc proceedings th acm symposium principles database systems minneapolis minnesota may 
suciu paredaens algorithm complex object algebra powerset needs exponential space compute transitive closure proceedings th acm symposium principles database systems minneapolis may 
suciu domain independent queries databases external functions lncs proceedings th international conference database theory prague czech republic january 
suciu wong forms structural recursion lncs proceedings th international conference database theory prague czech republic january 
thomas fischer nested relational structures advances computing research theory databases jai press 
trinder comprehensions query notation proceedings rd international workshop database programming languages greece august 
trinder wadler list comprehensions relational calculus proceedings glasgow workshop functional programming scotland august 
venkatesh database query language design planning applications bellcore technical memorandum 
bellcore box morristown nj wadler comprehending monads mathematical structures computer science 
watt trinder theory bulk types fide technical report glasgow university glasgow qq scotland july 
wong normal forms conservative properties query languages collection types proceedings th acm symposium principles database systems washington may 
wong querying nested collections phd thesis department computer information science university pennsylvania philadelphia pa august 
appendices monads equational axiomatization algebra functions saying coll oe comb delta delta sng empty initial appropriate class algebras saying coll oe comb delta delta empty free commutative idempotent monoid generated oe sng delta 
category theoretic terminology forgetful functor category commutative idempotent monoids category sets functions left adjoint sng delta unit adjunction 
adjunction composing functor gives free commutative idempotent monoid forgetful functor get monad category sets functions 
finite list bag set monads arise adjunctions basis structural recursion 
equivalent formulations monads see monads called algebraic theories ext delta salient operation singleton 
monads extension form 
formulation map cot flatten sng 
give commutative diagrams describe formulation give equational axiomatization algebra functions 
perspective essential axioms listed 
reflexivity axiom symmetry transitivity congruence inference rules omitted axioms algebra functions category 

oe oe oe ffi ffi ffi ffi oe 
oe id ffi oe 
oe ffi id oe axioms theta binary products unit terminal object finite products 

oe theta hfst ffi snd ffi fi oe theta 
oe fst ffi hf gi 
oe snd ffi hf gi 
oe unit ter oe unit psi gamma gamma gamma gamma gamma oe fst gamma gamma gamma gamma gamma snd oe theta hf gi axioms say functor action objects 
fsg morphisms 
map 
axioms say sng flatten natural transformations functor 
fsg natural transformations monad 

oe oe map ffi map ffi map fg fg fg map foeg map ffi fg map 
map id id foeg foeg 
oe map ffi sng sng ffi oe fg oe foeg sng map fg sng 
oe map ffi flatten flatten ffi map map fg flatten foeg map map flatten fg map 
flatten ffi sng id foeg foeg 
flatten ffi map sng id foeg foeg gamma gamma gamma gamma gamma sng map sng foeg foeg id psi gamma gamma gamma gamma gamma id foeg flatten 
flatten ffi map flatten flatten ffi flatten foeg map flatten flatten flatten foeg flatten axioms monad strong monad natural transformation pairwith 

map snd ffi pairwith snd unit theta foeg foeg unit theta foeg pairwith theta oeg phi phi phi phi phi phi phi phi phi phi phi map snd foeg snd 
pairwith ffi id theta sng sng oe theta foe theta 
pairwith ffi id theta flatten flatten ffi map pairwith ffi pairwith oe theta foe theta foe theta fgg map pairwith theta gg flatten foe theta phi phi phi phi phi phi phi phi phi phi phi pairwith oe theta pairwith id theta flatten oe theta fg oe id theta sng oe theta sng 
map ffi pairwith pairwith ffi id theta pairwith ffi theta oe theta fg theta oe theta hfst ffi fst ffi fst 
theta oe theta fg pairwith theta oe theta theta oe theta fg id theta pairwith theta foe theta pairwith theta oe theta map 
oe oe map theta ffi pairwith pairwith ffi theta map oe theta fg foe theta oe theta fg pairwith foe theta oe theta theta map pairwith foe theta map theta axioms complex object calculus equational axiomatization core complex object calculus follows immediately manes axioms monads extension form 
similar axiomatization moggi 
order allow reasoning sound models empty types case occur iff base type empty tag equations sequences distinct variables gamma free variables included gamma 
reflexivity axiom symmetry transitivity congruence inference rules omitted congruence respect phi construct analogous rule lambda calculus 
gamma foeg gamma oe fg phix oe gamma phix oe fg axioms binary ary products 
oe gamma oe 
oe gamma 
oe theta gamma oe theta 
unit gamma unit axioms monads extension form 
foeg phix oe fx oe gamma foeg 
oe fg phix oe feg gamma oe fg 
fg foeg fg phix phiy oe gamma phiy oe phix fg state result relates translations section equational theory appendix need notation define tupling transformation constructs sequence distinct variables gamma expression calculus tuple tuple gamma oe tuple gamma oe theorem 
pair gamma letting type gamma gamma equation gamma tuple gamma provable axioms rules 

function oe algebra letting unit theta oe equation ffi oe id oe provable axioms rules appendix 
gamma provable axioms rules iff gamma gamma provable axioms rules appendix 
oe provable axioms rules appendix iff oe provable axioms rules oe 
proofs parts straightforward inductions expressions 
sides parts proved straightforwardly induction equational proof trees 
parts sides parts follow 
details omitted 
additional axioms extensions offer equalities relating phi emptyset union conditionals main merit 
true 
axioms wadler express fundamental properties 
third axiom probably follow cleaner representation booleans unit unit deliberately ignored sums 
status axioms unclear 
quite possible derivable rest 
reasonable axiomatization equality 

phix phix phix 
phix fg fg 

phix phix phix 

phix phix phix 
phix fg fg 

phix phix phix free 
