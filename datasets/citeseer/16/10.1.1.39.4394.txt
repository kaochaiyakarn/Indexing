representing type information dynamically typed languages david cs arizona edu department computer science gould simpson building university arizona tucson az usa tr october report discussion various techniques representing type information dynamically typed languages implemented general purpose machines costs discussed terms modern risc machines 
intended readily available large body knowledge currently absorbed piecemeal literature re invented language implementer 
discussion covers tagging schemes forms representation discussion strictly limited representation type information 
noted report purport contain survey relevant literature 
report gathers body folklore organizes logical structure generalizations discusses results terms modern hardware 
contents tagged words tagged pointers tagged integers arithmetic tagged integers staged tags distributed tag fields tagged floats partitioned words testing ranges segmented ranges object pointers executable type descriptions hooked values large wrappers double wrappers qualifiers double wrapper optimizations typed location hybrid techniques tagged object pointers tagged words partitioning magnitude tagged words double wrappers hybrids typed locations dispatching dynamic type sequential search staged tags binary search jump table testing traps miscellaneous considerations avoiding operations dynamic representations language design machine considerations automatic choice representation glossary statically typed language problem floating point number representation identical representation integer type representation known compile time compiler generate right code deal representation 
dynamically typed language machine representations data objects general determined compile time syntax language tell compiler type data object represented 
languages necessary include information runtime distinguish value value 
theoretically requirement dynamic typing representation represent unique value regardless type 
practically representation possible efficiently convert machine representations uniform representation quickly determine sort object represented 
report general discussion representation schemes tagging various trade offs available 
speed major concern portability space requirements register usage discussed 
theoretical treatment dirty discussion real machines real costs real implementations 
dynamic type operations frequent trick save just machine cycle noticeable effects performance set benchmarks deals seriously tricks 
aware discussion implementations word type mean implementation type encoding set values machine words type 
aware general agreement terminology representational issues 
document introduces defines terms understood definition term defined way relevant literature 
fact new terms introduced talk things previously names 
terms literature defined easy talk specific implementation specific language tend unnecessarily restricted 
cases document offers generalized definition term leaves meaning unchanged previous incarnations time useful general discussions 
glossary provided 
process converting statically typed representation value dynamically typed representation referred wrapping value process converting back statically typed representation referred unwrapping 
representation wrapped value called wrapper 
wrapper minimal representation encode piece data part passed procedures returned procedures data value needs large amount memory represent usually encoded special block memory allocated wrapper contains block memory 
values represented way said represented indirectly called indirect values 
values said represented directly called direct values literature operation creating indirect wrapper number called boxing 
example integer boxed represented tagged pointer integer boxed represented directly 
avoid terminology avoid possible confusion meanings wrap unwrap tag box unbox 
data element bits possible represent different values 
important note means different values total different values type 
technique implementing objects indirectly pointers increase number objects represented time effect defining representations dynamically 
data element represent different values different times pointer block direct values confused immediate values compile represented machine code 
change 
broad categories techniques wrapping data tagged words 
machine words divided tag field data field 
indirectly represented objects value represented machine word pointer object 
partitioned words 
set bit patterns word represent divided types type restrict values represented bit patterns allocated type 
object pointers 
wrapped value simply pointer self identifying block memory usually heap type block encoded block example word block integer type code 
large wrappers 
wrapper consists words large represent full sized machine value type code 
typed locations 
type value determined value stored 
static typing special case technique 
hybrid representations 
combination techniques 
discusses representation strategies costs various implementation tricks reduce redistribute costs 
costs discussed terms generic operations performed wrapped values ist test dynamically typed value see type probably common operation fully reflect cost identifying dynamic types 
section dispatch ing dynamic type discusses detail 
type name tt name integer type code type code 
machine representation value produce appropriate dynamically typed value type dynamically typed value type produce machine representation operation inverse wrap unwrap unwrap wrap long appropriate domains 
operations described macros term produce meanings 
viewed macro value produced making result evaluating macro 
viewed lower level value produced simply putting register 
extension added purposes binary numbers form bn sequence binary digits representing binary number 
increase readability macros written extra parentheses needed cost operation number machine cycles required execute operation generic risc machine 
logical arithmetic instructions assumed operate registers require cycle 
loads stores take cycles load store word fetch decode load store instruction ignore cache affects 
values operated assumed registers operation 
general comparison cycles instruction set condition code second instruction test condition branch 
risc machines delayed branches execute instructions normal instruction stream encountering branch branching 
extra instruction positions branch called delay slots complicate cost analysis considerably slots filled instructions useful case branch fails case branch succeeds branch costs cycle 
hand slot filled instruction branch costs 
branch nop operation instruction delay slot extra cycle added cost branch 
delay slot contains instruction useful case fraction cycle added cost depending frequency cases 
ist macros assume success case expected success expected test probably part dispatch discussed section 
case delay slot generally filled instruction expected control path assume filled 
sorts branches numeric tests assumption 
word size object fits general purpose register examples assume word bits 
immediate operand non zero bits upper half word adds cost cycle bits lower half word zero cycles 
operand big fit instruction word operands constructed run time fetched instruction stream current instruction requiring memory fetch cycle 
generally constants constructed special load high instruction sets high bits word adding low bits add instruction 
constant zero bits lower half word constructed single load high instruction cost cycle correct machine full word sized immediates 
constant non zero bits lower half requires cycles construct machines full word sized immediates cost 
cost correct risc machines machines full word sized immediates 
risc architecture sparc bit immediates half word costs discussion applicable sparc machines 
systems speed large constants dedicating general purpose registers hold techniques considered report 
reason techniques specific job faster cost adding overhead rest execution 
case implementor known cost cost building constant runtime associated known operation amortizing cost rest execution restricting register availability 
subsequently code pays cost large constants may particular program little constants pays cost having available 
quite difficult measure cost technique quite difficult show optimization 
bits word numbered significant significant 
words significant sign bit numbered significant bit numbered bit word 
significant word called low significant called high 
cons cell pair words implement linked list 
cons cell operations common lisp prolog type frequently examples 
tagged words common way represent dynamically typed data lisp prolog implementations tag field 
representation wrapped value single machine word machine word viewed sequence bits 
sequence bits divided tag fields encoding type usually value field encoding data 
means value represented smaller number bits available machine word general unwrapped values represented wrapped values 
technique leads compact representations fairly access times 
restriction tagging number types severely restricted order leave value representations type 
problem built types modern languages provide user defined types arbitrarily 
tagged word representations generally allocate tag represent user defined types object pointer method section distinguish 
stage representation additional overheads taken account 
typically field value field tag systems add fields garbage collection cdr coding things 
operation extracting value field tagged word referred operation constructing tagged value setting tag value portions word referred tagging value 
cases un tagging identical un wrapping cases 
examples generally assume bit tag field shifts unsigned indicated 
tagged pointers different concerns tagging different types objects pointers unsigned values integers floats 
difference pointers unsigned values minor types discussed integers floats discussed separately sections 
tag field placed high significant low word advantages choice 
suppose machine bit word address space bytes 
restrict pointers lower bytes memory upper bits pointers bits tags 
macros wrapping unwrapping testing define ist tt define tt define 

value wrapped unwrapped tt tag code associated type testing type costs cycle shift cycles compare total cycles 
tt constant tt cost wrapping appear cycle runtime operation bitwise 
constant tt large represented bit integer adds cost cycle load high discussed wrapping costs cycles 
unwrapping done shifts cost cycles 
alternative implementation define costs cycles risc machines constructed cycles load high followed addition 
machine full word sized immediate operands cost method shifts 
putting tags directly upper bits bit shift put tags lower bits 
macros look define ist tt define 
tt define 
costs operations listed table compares costs low bits vs high bits tag 
table appears better low word functor arity prolog terms considered sort user defined type 
tag operation low bits tag high bits tag ist table costs high vs low tags tag field considerations 
particular numbers table operations general type codes various optimizations special type codes 
example tags low non zero bit tested cycles masking tag value comparing zero assuming comparison done cycle define ist tt high tag fields pointer tag need wrapped unwrapped tagged representation untagged representation 
done tags kept lower word word shifted tagging type tagged value identical untagged representation 
machines implementations alignment restrictions certain kinds pointers cases number significant bits 
lower bits tagging shifting value tag zeros tagged untagged free 
example byte addressable byte word machines lower bits aligned word pointer equal bits tags 
implementation enforce additional alignment restrictions increase size field 
example concurrent implementation values represented words tagged value semaphore prevent race conditions changing value 
values need words anyway system loses allocating values word boundaries bit tagging scheme need shift pointer values 
lisp implementations example enforce word allocation boundary reason wastes space 
enforcing new alignment restrictions alternative just represent pointer types shifting shift rest see section 
machines addressing mode automatically add small constant address register part load store 
case pointers tagged shifting untagged free long unwrapped value access memory long done immediately unwrapping value 
example word aligned cons cells bit tag operations access fields cons cell defined define word char define word char macros cast byte pointer addition scaled 
addition pointer re cast pointer word 
machine load store indirect immediate offset instructions instructions take cycles fetching decoding instruction cycle loading value memory cycle 
compare define define word takes cycles instruction fetch decode shift load value 
machine load store indirect immediate offset instruction tag value chosen wrapped value viewed pointer points frequently accessed field 
scheme puts tag field low word get free wrapping unwrapping value free unwrapping values 
restricted size tag field technique problem handled having staged representation section 
machine values value representation hardware machine load register operate special instructions integers floating point values value machine value 
operations wrapping unwrapping involve translating machine representations value represented tagged pointer direct wrapped value wrapping unwrapping incur costs referencing memory 
tagged pointer machine value operation unwrapping tagged pointer involves pointer loading referenced value register 
wrapping value requires allocating storage storing memory tagging pointer newly allocated location 
operations define new new define macros tag pointers incur costs operations 
potential confusion terminology 
example machine values wrapped integers operation unwrapping integer involves tagged pointer integer loading integer 
words unwrapping instance 
wrapped integer represented tagged pointer unwrapped integer 
reason important distinguish machine values sorts values way possible wrap machine values directly restricting range values 
direct representations encode values allocating extra storage referencing memory necessary discuss techniques way extra costs taken consideration 
tagged integers integers represented direct wrapped values 
signed integers difficult represent way pointers unsigned values upper bits depend sign integer complement machines universal 
consequently possible just restrict range integers order get zero bits high word unsigned values 
machines provide signed shift possible put integer tags lower word 
needed sure macro signed shift shift sign bit shifted left 
compilers machines signed left shift instruction signed shift signed quantity 
ansi standard requires shift signed value signed shift macros considered portable 
words unsigned get signed shifts cooperative compilers cast wrapped value signed quantity shifting define int 
cause sign bit shifted left reversing effect tagging operation integer restricted range 
signed shift costs unsigned shift cost operations signed quantities unsigned quantities tag field low 
integers bit code added word pointers directly get offset addresses 
contrast integers machine representation shifted bits left doing address arithmetic word pointers 
complicated put integer tags high word operations look define unsigned 

tint define int 

tint bit tag integers 
macro works shifting upper bits attaching tint tag cost cycles 
pointers legitimate assume upper bits integer negative upper bits 
tag integers shifting avoided reducing cost cycles load high bitwise bitwise 
special tag unavailable objects specialization discussed separately 
left shift operation effects removes tint tag shifting moves sign bit tagged integer position sign bit word 
signed right shift done shift correct sign bits 
way reduce cost wrapping unwrapping integers high word representation tagged integers untagged integers 
unfortunately requires assigning different tags integers non negative integers zeros high bits negative integers ones high bits 
scheme tagging integers sign extension pair tags referred collectively sign extension tag 
note scheme rules pointer tag 
problem tagging integers sign extension isint operation expensive 
possible implementations discusses options discussed 
obvious test sequence define isint cost right shift assume done result cached register conditional branch assuming machine jump zero instruction delay slot filled compare second test cycles second conditional branch taken 
total cycles integer cost cycles expected case 
alternative sign extend see result equal define isint int 
cost cycles equal worst case time previous technique 
machine jump zero instruction example sparc jump technique costs 
third option takes cycles sign bit discussed section 
table summarizes costs various integer tagging schemes 
arithmetic tagged integers table int tag costs fully reflect costs tagged integers uses tagged integers arithmetic operations cost operations may vary depending tagging scheme 
general doing arithmetic tagged integer values necessary fully operands tag result 
macro addition naive way look define tag operation low bits low bits high bits high bits sign zero zero extension isint table costs integer tag operations machine integers come tagged integers fewer bits machine integers generally machine arithmetic full sized machine integers 
ways digit integer operation integers fixed digits get digit result 
excess precision method arithmetic normally result requires digits overflow 
technique requires overflow handled explicitly 
alternative scaled arithmetic method involves scaling integers operation overflow digit operation result overflow digit operation 
advantage approach overflow handled implicitly 
assumed things done operation overflows overflowing digits truncated exception raised 
case arithmetic operation causes overflow machine word assumed machine right thing truncates causes interrupt cost cycles test overflow 
case overflow said handled implicitly 
arithmetic done low machine word result requires bits represented tagged integer specific check usually taken operation overflow cost checks added cost arithmetic 
case overflow said handled explicitly 
arithmetic integers high tags tag field high word integer low word 
needed implement excess precision arithmetic remove tag 
course advantage tagging integers sign extension masking necessary 
necessary check overflow explicitly isint test expensive test shown 
cost arithmetic operation overflow cycles plus cost operation 
adds cycles cost addition subtraction multiplication 
scaled addition high tags done define 
saves right shift shifting arguments back right shifting result 
macro provides overflow handled implicitly saving overhead 
recall tagging integer arbitrary high tag expensive cycles upper bits shifted 
result case starts high word right shifted position 
right shift unsigned zeros shifted mask necessary 
optimized define unsigned 
tint tint integer tag 
operation costs cycles 
int constant tint need constructed mask need done cost cycles 
integers tagged sign extension final right shift done signed shift masking needed 
cost cycles 
reasoning applies subtraction addition costs 
integers tagged sign extension integer negation done machine integer negation cost cycle 
tags high word necessary unwrap tagged integer negation result re wrapped integer 
cost cycle plus cost wrapping integer 
integer represented tag high left shifting bits large number bits tag field produces machine representation untagged integer fact identity ij says scaled multiplication necessary fully operands just left shifted define 
operation costs shifts addition tag operation operation multiplication 
integers tagged sign extension tag necessary long correct sort right shift signed unsigned 
division note implementation define case avoided integers tagged sign extension right shift done 
final integer operation considered signed comparison 
test equal equal regardless representation assuming representable integers just wrapped representation cost testing equal greater greater equal depends representation 
refer comparisons collectively inequalities 
clearly integers tagged sign extension integer inequality tests done directly machine inequality tests 
mentioned assume instruction set status bit branch conditionally cycles ignore delay slots discussing inequality tests different techniques affect filled 
integers single tag high word efficient way inequality test tagged integers shift high word scaled comparison 
case extra cycles shifts giving total cycles 
arithmetic integers low tags high tags low tags optimized arithmetic trick doing excess precision arithmetic way saves cycles naive method operands tagging result 
excess precision requires explicit overflow test expensive scaled arithmetic considered 
integers tag low word scaled addition subtraction free multiplication division cycle overhead define define define define different tag operation int equivalent int 
gamma int int gammai int negation implemented define tint mentioned 
similarly int int gamma int int addition implemented define tint int gamma int int gamma int subtraction implemented define tint note tint compile time constant 
section just special cases int ones 
mi mj positive number number tagging low equivalent multiplying positive number adding number comparisons done tagged integers unwrapping comparison wrapped integers done directly machine comparison cost cycles 
costs integer arithmetic various tagging schemes summarized table 
operation low bits low bits high bits sign zero zero extension negate add subtract multiply cm cm cm cm divide cm inequality table costs tagged integer operations constants cm numbers machine cycles needed multiply divide respectively 
tables appears noticeable advantage tagging values low word high 
testing operation suggested addition tagged integers improved integer tag tagged integers added directly result correctly tagged integer result operation tagging integers sign extension zeros low choosing tags way adding tagged values integers result look integer 
scheme allows compiler add numbers checking types find integers fact checking type result 
supposedly common case operands integers bit faster 
hand requires bit added tag field technique addition numeric types expensive 
order effective technique require integer addition extremely common operation type checking integers expensive addition types rare 
staged tags staged tagging scheme uses tags different sizes different types 
example possible different bit tags long bit code reserved staging tag 
bit codes called stage tags value lower bits equivalent stage tag type associated tag 
tagged value bits equal staging tag second stage higher tag 
suppose staging tag larger tags bits addition smaller stage tags 
classes tagged values diagrammed represent bits xxx xx second stage value stage values tagging scheme different stages called stage 
scheme stage called staged stages stage tagging scheme 
stage tagging scheme uses bits stage tag bits second stage tag called bit tagging scheme similarly schemes stages 
note staging tag level 
example bit tag codes staging tags signal bits tag 
bit scheme outlined removes bits address space second stage tags may considered excessive 
second stage word pointers tagged shifting just places take advantage bits lower word pointer 
cost technique pointer done bit right shift shift tag bits pointers tags form xyz tag bits subtracted shifted 
pointer untagged just dereferencing extra step subsumed store load indirect offset 
serious problem staged tagging schemes extracting tag separate value expensive worst case cost mask cycle stage test cycles stage total cost gamma gamma cycles number stages 
scheme outlined cost extract tag high cycles times cost stage tagging scheme 
major reason extract tag separate value dispatch type branch different address different type 
example test determine equality values needs compare different types value different ways 
contrast operation extract car wrapped value representing cons cell needs distinguish case wrapped value represents cons cell case 
test needs determine type operation ist expensive staged tags tags 
example cons cells second stage tag low word staging tag discussed implementation define cost cycles 
cost testing tag low word need check staging tag separately 
penalty staged tagging scheme depends dynamic distribution tests executions programs language 
tests ist variety little overhead staged tags 
tests dispatching variety overhead depends implementation tests 
topic worthy section discussed 
sign bit tag field bits top half machine word machines testing bit requires cycles mask shift bits cycles jump zero 
contrast sign bit tested cycles 
suggests possibility sign bit staged tagging scheme data type tag sign bit 
example staged tag fields high word cons cells bit tag highest bit types assigned bit tags form xyz 
test take cycles wrapping unwrapping cons cells free 
example tag pointer pointer tagged untagged negation shifting masking 
instance tag unbound variables operations define define order necessary ensure negating pointer produce high bits word 
complement negative bit signed number equivalent subtracting unsigned operation condition satisfied ensuring gamma xf upper bits tag field pointers limited range anyway 
distributed tag fields priori reason tag field data field matter needs contiguous number interesting strategies tag field low word tag field high 
example implementation nil described pp uses tagging scheme integers tag low word bit codes low word represent staging tags 
second stage tags low bits high bits word 
high bits tag integers integers tagged untagged shifting arithmetic integers described tagged integers tag zeros low word 
scheme pointer types distributed bit tag upper word pointers dereferenced store load indirect offset 
type checking quite expensive technique 
simple type test define ist xe tt types integers costs cycles constants xe tt cost cycles construct 
alternatively separate tests done define ist tt tt cost cycles success delay slot jump filled shift 
constants tt tt parts tag 
field just non zero bit field tested cycles values tested costs cycles 
tag small constant comparison shifting top bits define ist tt cost cycles 
masking cycle saved advantage zeros get shifted 
requires reversing low bits high bits define ist tt cost cycles 
test reduces maximum cost testing distributed tags cycles 
table compares ended stage tagging scheme ended stage tagging scheme 
columns table represent stage scheme bit tags integers get tag tag operation low bits low bits ended shift shift isint ist address bits table costs stage tagging schemes bit codes staging tags 
column word pointers get shifted bits tagging second column get shifted bits 
columns assume tag bits low word column bit tag field low word bit tag field high 
operations ist non integer types 
row labeled address bits tells bits available representing word pointers 
numbers parentheses costs special word pointers code upper bits 
tagged floats floating point numbers special problems tagged word schemes 
ieee standard requires bits bit word bits discarded room tags implementation adhere standard 
second ieee format bits reasonably discarded low word 
contrast values discardable bits high word 
third may programs floating point arithmetic performance floating point arithmetic critical performance program 
leaves implementer choice optimizing common case expense making compiler unacceptable large class important programs burdening common case programs overheads intended improve performance relatively rare cases 
wrapped floats represented tagged pointers unwrapped floating point numbers described section 
case wrapping floats requires allocate store unwrapping floats requires load possible full machine floats 
particular allows ieee compliance machines comply 
wrapped floats represented tagging float number directly implementation claim compliance ieee floating point standards bit machines comply 
furthermore costs tagging floats different discardable bits low 
decision word tag bit complex 
operations tag floats high define define costs cycles cycle wrapping floats expensive wrapping types unwrapping floats cheaper 
floats tagged low word operation define tag cost cycles 
note looks large constant really just gamma included immediate operand machine sign extends immediate operands logical operations 
define 
float values untagged shifting lower bits define 
cost cycles 
complication note machines floats tagged untagged integer register bit operations allowed registers arithmetic done float register 
involve extra register moves situations 
ieee nan codes ieee floating point standard defines large set encodings nan values nan stands number 
encodings exponent ones non zero significand 
standard basically allows codes encode non float values tagged word scheme values floats xff bits bit word page 
restricts data types bit representations allows full ieee floating point compliance 
example bit tag high non zero object pointer see section tag integers 
bit tags represent ieee floating pointer numbers 
problem representation integer encodes ieee value negative infinity object pointer points byte positive infinity 
various ways get problem bit set pointers integers reducing representation spaces types special tests floating point operation recode infinite results representation 
option expensive 
partitioned words mentioned earlier essential requirement implement wrapped values single word partition set possible bit patterns machine word various types type determined examining bit pattern 
done dividing words separate tag field value field discussed section done allocating type certain subset available bit patterns 
words available representations divided types way type restricted representing values represent bit patterns allocated 
strategy different tag field tag field technique value field word legitimate value partitioned words fact code wanted conversion floats ints changes representation 
necessary declare tagged value union 
entire word legitimate value format machine uses 
strategy tagging impossible represent word unwrapped values direct wrapped values 
generally words partitioned magnitude number represent machine representation signed unsigned integers special case referred partitioning words magnitude 
example word bits represent natural numbers gamma set numbers divided ranges magnitudes 
numbers define define define define xc define ranges types data integers arrays cons cells atoms symbolic constants 
arrays cons cells implemented pointers blocks heap 
array pointers restricted range addresses cons start gamma array blocks allocated addresses 
likewise cons cell pointers restricted range addresses atom start gamma 
atoms may may implemented pointers implemented atom represented bit pattern represents natural number larger equal 
course acceptability addresses depends virtual memory system 
virtual memory large operating system requires virtual memory allocated contiguously scheme practical 
representation support negative integers problem remedied making complement representation integers 
complement negative integer gammai represented subtracting absolute value number bits word 
means negative integer small absolute value represented positive integer large value necessary reserve largest numbers negative integers 
example define define define define xa define xe gives sort wrap integer range includes positive negative integers 
characteristic partitioning words pattern direct cost wrapping unwrapping data 
object represented pointer simply allocated right place type identified location tagged integers look exactly untagged integers 
integer representation scheme tagging integers sign extension extra costs arithmetic discussed section 
may hidden cost constraints scheme imposes memory allocation requirement multiple memory regions translate overhead storage management 
example simple allocation method space allocated merely incrementing heap pointer allocation faster keeping heap pointer register multiple memory regions multiple heap pointers needed registers hold pointers unavailable uses 
implementer decides keep heap pointers registers extra cost allocation partly ascribed tagging scheme 
similarly allocation system uses free list allocation heap pointer tagging scheme part reason slower allocation method overhead maintaining allocating free lists partly ascribed tagging strategy 
consequences particular representation far reaching costs hidden features implementation 
requirement allocate structures certain places may cause problems depending space allocated virtual memory system works 
particular operating systems allow allocation arbitrary regions middle virtual memory allocating virtual memory section virtual memory space 
data shared programs written languages may restrictions data allocated 
testing ranges problem partitioning words magnitude large cost testing type wrapped value 
example macros test types look define isint define define define cost successful test cycles test involves comparisons large immediates values branches 
delay slots filled instructions success branch 
integer test succeed just branch advisable switch order tests non negative integers probably common negative integers 
range tests optimized trick complement representation integers fact machines signed unsigned comparison 
positive constant signed complement integer variable consider effect casting unsigned quantity comparison unsigned effect greater 
negative signed integers test large unsigned integers meaning test fail 
words unsigned equivalent fact optimize range tests 
example suppose desired range test variable non negative constants subtract side inequality get equivalent unsigned shown 
consequently previous range tests changed define isint unsigned define unsigned define unsigned define unsigned cost cycles test 
integer range test formulated negating original test define isint transforming define isint unsigned simplifying 
positive integers occur great frequency better test method integers testing positive integers best case test just cycles depending delay slot filled 
negative integer encoding testing integers optimized assigning range values represent negative machine integers negative wrapped integers keeping range integers contiguous 
words negative machine integer represents integer wrapped value nonnegative machine integer range represents integer wrapped value 
allocates half available representations negative integers test integers done single signed comparison maximum representable positive integer define isint cost test cycles assuming large represent immediate 
note technique test integers tagged sign extension 
segmented ranges call range form bff bff ff initial sequence bits segmented range segment 
segmented ranges useful property membership range bff bff determined testing upper jffj bits see match ff 
words partitioned magnitude segments testing type wrapped value identical testing type word tagged high bits 
segmented scheme wrap integers identical integers tagged sign extension testing overheads involved scheme outlined section works 
example define define define define define provides set constants tests define isint int define define define scheme costs cycles test 
extra cycle required large constants cost cycles mask lower bits compare upper bits 
dynamically typed segments lisp implementations dynamic variant segmented ranges assigning type codes ranges dynamically 
done setting aside large range pointers partitioning range segments 
segment type code dynamically types values allocated particular segment recorded table segments called big bag pages 
segments bytes macro test type define ist tt assuming address kept register keep mind costs having register available local computation cost operation cycles shift add address table load type compare conditional branch 
testing slower strategy statically partitioned segments virtual memory allocated contiguously 
types represented directly word pointer special tags pointer types looked table 
essentially staged representation scheme highest stage tag index 
keeping type information table kept segment 
example information kept word segment type extraction implemented define ist tt cost cycles 
note constant immediate constant 
scheme faster method need reserved register reserve record block 
requires staged representation represent non pointer types optional method 
object pointers object pointer scheme wrapped value simply machine pointer block memory block contains type information 
representation relatively pure form smalltalk prolog functional languages 
word object special meaning contexts mean simply block structure contains information identify type value block represents represents value 
simple way accomplish simply word object integer type code 
case testing type object pointer requires memory load type define ist typecode tt cost cycles 
wrapping unwrapping bit complicated cost depends data type pointer block represented directly machine registers 
wrapping pointer block done assigning type code correct field block pointer define typecode tt example maclisp pp franz lisp pp interlisp vax page 
smalltalk implementations represent values extra level indirection object pointer block 
representation motivated need represent dynamic types ignored 
requires cycle load constant tt register assuming machine instruction store immediate value cycle fetch execute store instruction cycle store value total cycles 
unwrapping free pointer unwrapped value define non pointer types integers wrapping done creating object heap storing value storing tag define new typecode tt new val new cost cycles plus cost allocation 
allocation cost little cycle hardware interrupts detect allocation heap boundary heap pointer newly allocated memory 
unwrapping non pointer value requires fetching value memory define val cost cycles 
executable type descriptions putting integer code word object possible place piece executable code 
determining type object done jumping code 
example executable code fragment type subroutine sets condition code argument tt integer type code type checking done define ist tt wrapping unwrapping scheme previous 
machine shortest possible calling sequences method requires cycles line test call return 
problem requires separate piece executable code allocated object 
get expensive space practical put object pointer executable type description execute indirection cost cycle 
programming languages objects frequently executed object oriented languages languages lazy evaluation executable type descriptions help avoid extra tests providing piece code specific type 
possible variations notion executable type descriptions 
example ist operation type dispatching combined unwrapping 
variation handle conditional jump type description just setting condition code 
notions combined additional indirection discussed follows define lbl tt lbl type represented tt value unwrapped fixed register control returns normally instruction call 
type tt return lbl instruction immediately call 
executable type description integer look compare tint branch eq return lbl load jump input argument registers output argument register contains unwrapped integer successful test 
label instruction call stored register return lbl presumably call instruction 
execution code takes cycles added cost dereferencing call cycles 
variation multiple fragments code associated executable type description 
multiple code fragments different purposes example garbage collection 
different ways dispatching type 
example value defined object pointer block contains function pointers test code lbl return lbl type code code return normally 
eq lbl return lbl equal return normally 
jump tbl return address tbl code code type code jump table dispatching course open ended technique possible come number useful procedures 
fact object oriented language fixes possible message names compile time possible operations objects jumping addresses executable type description 
tables get large small ones add considerably size small objects ints floats 
save space type codes generally implemented extra level indirection values internal type table functions 
course level indirection reduces speed 
hooked values object pointer representations executable type descriptions convenient representing hooked values 
hooked value value causes special things happen accessed 
example icon hooked variable pos integer value restricted range 
attempt assign value outside range pos causes piece code executed special 
icon hooked values 
example icon substring expression creates hooked value evaluates normal substring dereferenced hooked value assigned case executes special piece code changes value languages concurrent constraint evaluation example procedure evaluation suspend needs value unbound variable woken variable gets assigned value 
way implement behavior assigning hooked value unbound variable behavior assignment hooked value suspended process gets woken 
hooked values arise languages lazy evaluation 
lazy evaluation expression means expression evaluated value expression needed 
lazy evaluation implemented creating hooked values unevaluated expressions 
hooked value accessed evaluate expression replace value expression 
spineless tagless machine virtual machine implementing functional languages lazy evaluation 
represents wrapped values object pointers name tagless type object encoded piece executable code described 
value object needed code component executed code fragment puts type code unwrapped value accessible 
elegant model cost accessing non hooked values relatively high 
assume light procedure call overhead cycles call return call instruction loads return address register jumps cycle delay slot filled instruction jump target 
return instruction takes icon literature uses term trapped variable cycle delay slot instruction filled instruction called procedure 
assume executable type descriptions shared different values address jumped loaded memory cost cycles 
value tested needs moved argument register cost cycle 
total overhead doing type check cycles 
system uses non executable type codes point program accesses value insert special code test hooked values 
typically code test immediately followed code verify type 
hooked values unusual case may best test expected types delay test hooked value 
assume tag extracted regardless test type tests need 
cost doing test just cost compare jump 
value hooked overhead test just cycles assume delay slot filled instruction hooked continuation 
value hooked test costs cycles instruction delay slot wasted call handle hooked value cycles total overhead case value hooked cycles 
test done second overhead value hooked 
value hooked call handle 
return handling code type test 
example value tested code look lbl execute normal case value goto lbl overhead hooked involves test cycles call cycles tag extraction cycle say type test cycles 
total overhead hooked values cycles 
table presents summary relative costs assumptions 
table shows technique hooked hooked executable type code test test type table costs hooked values choice best scheme depends percentage values hooked run time 
figures partially confirmed experiments reported discussion re introducing tags speed case value hooked 
note techniques executable type descriptions restricted object pointer schemes 
type descriptions quite easily large wrappers representation type codes type codes indexes table addresses executable type descriptions 
case hooked value wants modify usually non hooked value evaluated object pointers better techniques direct representations values 
reason representation direct may way modify instances value may copies 
object pointers copies object pointers block 
serious problems object pointers require values heap allocated 
order reduce overhead heap allocating small objects integers lisp systems technique called 
involves values say integers gamma values wrapping new ones 
example arithmetic operation include test see result range gamma produces value wrapping new integer 
modification scheme special addresses represent values allocating 
course schemes limited object pointer representations generally applicable integers represented indirectly 
large wrappers necessary restrict data representations single word schemes 
alternative simply wrappers large represent type information complete machine value 
keeping large wrapped value registers requires registers schemes single word modern machines problem 
similarly large wrappers require memory single word wrappers memory sizes today large getting rapidly larger 
serious problem representations loading storing wrapped values takes longer single word representations techniques reducing costs time optimizations available large wrappers available single word wrappers 
consequently multi word representations deserve careful consideration 
wrappers restricted representing word sized values means pointers larger values number types restricted number word representations wrapped values represented words type encoding value encoding 
implementations icon described represent dynamically typed data pairs extra information type word 
word representations called double wrappers 
double wrappers double wrappers type code value code different registers operations unwrapping extracting tag essentially free recall extra cost loading registers place 
represent pair general purpose registers type refer pair val refer 
operations double wrappers described define ist type tt define val type tt define val notation little convoluted attempts maintain uniform framework representation techniques 
definition ist says test type code pair registers representing double wrapper simply compare register contains type code 
tt small immediate costs cycles 
definition says construct double wrapper value register val simply load type code type double wrapper register pair represented note tt shifted high word reasons discussed operation costs extra load high replaces load immediate 
definition says machine representation value register pair register val 
notation assumes uniform arrangement registers value registers corresponding type registers 
qualifiers sequences statically unknown lengths represented ways 
assuming sequence stored contiguous array minimal requirement representation possible easily determine contiguous array 
array generally represented pointer 
represented pointer length having special sequence object sequence character strings 
sequence marker implementation requires special value appear sequences requires traversing entire sequence find length sequence 
choice mark pointer length depends sequence 
pointer representation probably bit better general rule common length assume representation 
sequence represented pointer length necessary decide length encoded 
common approaches 
approach put length just contiguous array data 
pointer sequence needed encode entire sequence 
approach allocate qualifier word block contains length pointer contiguous array data 
qualifier representation versatile allows contiguous array data shared different sequence representations 
example strings represented qualifier possible create substring string just creating new qualifier subrange array characters represent necessary copy characters 
course assumes sequences immutable acceptable side effects sequence change elements sequence 
disadvantage qualifier representation may require extra allocation create sequence represented qualifier accessing elements sequence requires extra level indirection 
qualifier requires words storage represented single double wrapper removing bits tagging 
case extra overhead qualifier representation overhead accessing double wrappers 
qualifier implemented double wrapper keeping length pointer value word double wrapper keeping type word 
course set type codes distinguishable length pointer kept type field allow dynamic type checking 
ways problem encode length pointer type word double wrapper similar problem tag words considerations apply 
example limit upper magnitude representable pointers lengths type field double wrappers choose type codes larger largest magnitude 
analogous technique partitioning words magnitude 
problem encoding types type codes immediate values large fit half word constructed run time 
said previously problem double wrapper representation type codes bit masks simply loaded directly type word difference loaded load immediate load high 
type double wrapper requires type word contain data sequence length type code type double wrapper requires type code bit mask 
strategy tag field high word 
alternatively type word divided tag field length pointer field tag field high word low 
expected advantages disadvantages method 
examples discuss options assuming bit tag field bit field qualifier lengths type word 
type code put low type word length put high non qualifier types operated masking define ist type tt define val type tt define val costs cycles ist cycle cycles 
qualifier operations masked general define ist type tt define type type tt define type type assumed unwrapped qualifiers kept register pairs double wrappers length field qualifier replacing type word double wrapper pointer qualifier replacing value word 
operation ist operates double wrapper representation costs cycles begins qualifier representation converts double wrapper representation cost cycles begins double wrapper representation converts qualifier representation cost cycle 
tag field kept high word qualifiers non qualifiers shift type word construct large constants run time 
implementation non qualifiers define ist type tt define type tt define val costs cycles ist cycle recall tt constructed loaded time single load high instruction cycles 
qualifiers ist operation operations take care length representation define type type tt define type type costs cycles cycles 
type qualifier tag type qualifier gets free wrapping unwrapping 
likewise type qualifier tag type wrapped unwrapped just negating type word cost cycle 
type qualifier sign bit distinguish value types 
negative words type codes operations non qualifiers define ist type tt define type tt define val expression tt compile time constant small immediate operand assuming sign extension immediate operands costs cycles ist cycle cycles 
single qualifier type double wrapper representation qualifier representation operations define ist type define define costs cycle ist assuming branch le operation cycles 
double wrapper optimizations ways reduce extra costs loading storing double wrappers technique passing parameters registers stack idea anyway 
avoids need pushing double wrappers stack popping call eliminates large number memory 
major remaining sources memory traffic saving values stack procedure calls accessing double wrappers aggregate objects lists 
memory accesses reduced considerably local unwrapped values passing unwrapped values parameters storing unwrapped values aggregates sections 
double wrappers represent qualifiers efficiently may worthwhile language arrays represents values double wrappers special representations contiguous array data contains unwrapped values 
possible avoid storing word double wrapper known word correct 
example icon expression destructively update number produce value type absence overflow 
case necessary store new value value word double wrapper type word need updated 
similarly icon expression remove character string implemented subtracting length field double wrapper string qualifier touching pointer field 
double wrappers optimize representation bit ieee floating point numbers allocated heap methods 
data represented double wrappers float represented directly value word double wrapper 
double wrappers directly represent types data represented word heap blocks 
example special type code directly represented cons cells 
type word double wrapper represent pointer car type value word pointer cdr 
encoding save space save cycles shortening chains car cdr cons cell longer represented directly cons cell 
example cons cell represented pointer pair elements heap take memory access cdr 
encoding suggested cons cell directly represented pair registers cdr represented pointer register val take memory access cdr val 
large number type codes available user defined types represented double wrapper type code pointer object pointer representation 
type checking efficient objects 
prolog terms represented similarly functor word pointer args word save cycles unifying terms functors registers 
typed location ways type values stored 
note refers data element stored points 
example data element pointer type determined region memory pointer type encoded representation pointer location pointer 
example partitioned word representation typed location 
typed location type pointer known just pointer certain place stack certain register similar matter pointer points 
pure statically typed language type value known stack register location point program 
sense locations types values 
dynamic versions typed locations types encoded type code value type code kept separate places 
example stack frame may contain sequence bytes containing type codes followed sequence local variables type value local variable type code byte type codes kept separately values refer segregated type codes 
segregated type codes costs identical costs double wrappers differences type located data element known fact segregated type codes smaller word 
type data kept sum sizes add natural size machine segregated type codes necessary 
typed locations common languages statically typed values need dynamic type information purposes storage management debugging 
languages necessary keep type information separate codes 
type hardwired special functions doing storage management debugging 
words user defined function fixed pattern static types stack frame 
pattern static types possible compile specialized function garbage collecting debugging stack frame function need deal type codes knows type stack slot static criteria 
hybrid techniques representation schemes combined various ways trade various advantages disadvantages 
possible merge schemes share representations 
example implementation tagged words represent integers partitioning magnitude integers 
essentially tagging integers sign extension amounts 
commonly techniques combined nesting representation inside 
words specific representation scheme wrapped values 
types wrapped values fact dynamically typed values representation may may technique representation 
sort scheme called staged representation distinguished staged tagging scheme 
staged tagging scheme particular form staged representation stages tags 
certain optimizations possible staged tags especially involving dispatching apply staged representations general 
tagged object pointers object pointers tagged words combined staged representation scheme 
pure object pointer schemes rare sorts values integers small represented word common impractical allocate heap 
pure tagged word schemes rare tag fields provide large range type codes types needed especially languages provide user defined types 
objects typically word aligned machines lower bits object pointer available free tagging 
suggests staged representation scheme stage tagging scheme lower bits word second stage general object pointer scheme 
operations stage types described section 
operations object pointers define tobject tobject tt define tt tobject define tobject number tobject represents stage staging code assumed addition subtraction treat integer scaling tobject necessary casts expressions complicated 
cost test type value cycles type represented tagged object cycles represented direct tag 
presumed load indirect instruction generated expression tobject expression charged cycles 
choosing tag appropriately cost testing wrapped value object pointer reduced cycle see section get total cost cycles 
wrapping object requires storing type code object cycles see section adding tag pointer cycle total cycles 
unwrapping object requires subtracting staging tag cost cycle values machine representations represented directly 
unwrapping pointers common operation possible access fields object offsetting tagged pointer efficiently offsetting untagged pointer 
tagged words partitioning magnitude set words partitioned magnitude segments distinguished upper bits word bits viewed tag field 
case type values represented bit tag upper part word represented word fixed bit segment 
recall difference tagging partitioning tagged words value extracted value field partitioned words word legal value 
clearly possible mix strategies value field represent types unwrapped values word represent types 
tagged words double wrappers extent representations described sections hybrids tagged words double wrappers representations part benefit double wrappers place treated part double wrapper representation hybrid scheme 
possible true hybrid scheme implementer willing give property wrapped values size 
allows representation values tagged words double wrappers 
example integers couple pointer types represented bits low word fourth tag value staging tag informs runtime system value 
remainder value different places different situations 
example parameters passed register argument register tagged staging tag indicate register represents type word double wrapper value word register say maximum number argument registers 
machines special floating point registers special staged tag indicates value float float register 
wrapped value loaded stack staging tag indicate value word word stack 
course problem possible save registers stack examining see requires saving register 
expensive programs lot procedure calls 
representation causes problems representing aggregate objects 
example word array heap tagged staging tag indicates word contains value 
difficult implement aggregates efficiently double space case benefit method pure double wrapper strategy 
hybrids typed locations case aggregate structures elements type object 
cases possible avoid including dynamic type information elements type known fact occur particular place 
particularly useful tagging representations allows avoid costs tagging elements aggregate double wrapper representations allows save space avoid cost storing type type code element aggregate 
dispatching dynamic type type variable dynamic type variable value 
type code constant number bit pattern represent type runtime 
dispatch type means select piece code execute type code represents type 
mentioned earlier type tests variety done efficiently ist macros document 
sequence ist macros seldom efficient way implement general dispatch 
best way dispatch type extract type register ffl sequence equality comparisons register 
ffl binary search value register 
ffl indexing jump table jumping correct piece code 
ffl combination 
doing sequential binary search number tests done compare type type code includes failed tests successful test 
value depends order tests generated statistical properties value tested 
example point program dynamically seen wrapped integer time testing tint cost dispatch cost single test time 
sequential search sequential search total cost cost extracting type plus cost comparisons type 
representation uses bit tags low dispatch look type case type case type case type case 
delay slot test filled compare instruction test long jump test costs cycles 
jump exits chain compare instruction delay slot useful jump costs cycles jump static sequence ignore 
cost cycles jump plus extra cycle final jump giving cost 
cost extracting type wrapped value cost dispatch 
maximum value total number type codes 
staged tags staged representations dispatch type contain branches second stage dispatching code second stage types 
staged representation schemes bit patterns word types special optimizations 
assumed staged tags comments apply types partitioned magnitude 
stage tagging scheme cost extracting type larger stage scheme test needed find value second stage tag 
test tells stage reduces search space tests binary search comparison 
words type code second stage tag need test stage tags 
cost extracting tag stage cost sequential search stage tags stage types second stage types 
case worst case value number non staging tags level 
particular non staging tag level stage 
assumes staging code level non staging code testing code stage code takes cycles 
multiple staging multiple non staging codes usually arranged way stages identified cycle test 
tags stage efficient extract type code stage compare types testing stage tag 
binary search set type codes representable sequence machine integers dispatching done binary search 
example wrapped values words tagged lower bits dispatch done type case type case type case type case 
delay slots filled sequential search predicted jumps compare delay slot ignore worst case cost gamma best case logarithmic number type codes linear 
type code selected ruling type codes settles type code tt determined type greater type codes 
branch half type codes ruled number tests dlog ne blog nc number type codes 
assume power floors ceilings ignored 
reduce expected value possibly frequency distributions tags possible insert equality tests inequality tests 
example search changed type case type case type case type case type case 
worst case way test cuts search space half leaves test needed giving log gamma way tests 
way test requires branches worst case log gamma worse previous strategy best case 
branch cycles giving cost gamma 
variation equality test second 
example fragment changed type case type case type case type case type case 
worst case previously type codes require worst case number tests case type codes 
way test requires compare branches just requires compare branch 
direction test costs cycle direction 
binary searches done mixed strategy way branches points way branches points mixing forms way branches 
optimal strategy depends dynamic distribution type codes 
jump table jump table array addresses 
dispatching value integer storing position address code executed dispatching done jumping th address jump table 
general safe index array checking range index variable holds true jump tables jump table dispatches require range check indexing table 
index known type code type codes small fixed range check avoided 
range check needed usually done cycles range testing method described section constants assumed small immediates cycles subtracted range test 
code dispatching value tag variable scale word size addr get address jump table cycles large immediate addr addr load code address cycles goto addr jump cycles delay slot filled total cost cycles cost extract type code 
staged tags necessary determine stage tag extract 
possible extract just largest size tag smaller tags fill slots jump table 
bit staged tagging scheme bit type code tt gets slots jump table bit number lower bits equal tt 
example consider staged tag scheme low word tags define int define flt define cons define arr define num scheme jump table implemented switch case goto case goto case goto case goto case goto case goto case goto case goto note similar table type codes written extract tag value 
words possible construct array indexed bit numbers element corresponding bit tag 
implementation ought pick method dispatching type variable expected value ought order tests way minimize done overhead staged representations small staging useful 
writing test switch statement speed important 
compiler generate dispatch code intelligently compiler know type code frequencies seriously affect best method 
compilers smart notice range test needed 
testing traps percentage type tests merely verify applicability certain operation 
example car tagged cons cell necessary confirm tagged value fact cons cell 
cases possible avoid specific test arranging operation cause machine interrupt value expected 
example machines trap word access done address word aligned 
machine pointer type tag pointer type dereferenced checking type long trap caught handled correctly type correct 
course method generalized type checking situations error type expected costs interrupts modern machines expensive technique cost effective cases 
miscellaneous considerations avoiding operations dynamic representations number ways avoid dynamic type operations altogether probably techniques eventually dynamically typed languages efficient statically typed languages 
example procedure possible infer types values 
values manipulated unwrapped state need wrap 
applies numbers implementations lisp scheme prolog addresses 
example tagged sequence type represented contiguous array heap manipulated getting pointer array heap directly 
optimization class optimizations called call forwarding skips unnecessary instructions call including conditional branches generalized skip instructions points 
optimization particularly effective skipping type checks program uses types consistent manner 
single value multiple times different branches procedure languages possible test type just procedure unwrap value immediately 
call forwarding skip test unwrapping 
resulting code close produced statically typed language 
global type inference done possible pass unwrapped parameters return unwrapped values 
especially important functional logic languages rely heavily recursion languages recursion loops local unwrapped values limited usefulness 
course presence unwrapped values dynamically typed language cause difficulties garbage collection 
language design language design choices seriously impact effectiveness type inference effectiveness tag optimizations 
example separate compilation global type inference effective type inference delayed linking phase language typed import declarations 
doing type inference link time tends defeat main purpose separate compilation speed compilation time avoiding need re compile modules changed global type inference typically responsible substantial fraction compilation time 
typed import declarations required external procedures tends defeat purpose having dynamically typed language 
declarations optional global optimizations better programs 
course may necessary link time run time checking ensure declarations correct 
type system set arbitrary conversion integers floats type inference inferring types numbers unwrapped arithmetic 
hand language provides explicit conversions floats ints requires integer operands places integers needed array index example provides information type inference 
example variable array index constructed expression gives information going required integers 
allows tests moved early function frequently skipped call forwarding 
burden places programmer unusual case really intended array index formed floating point number explicit float integer conversions 
arbitrary precision arithmetic performance problem requires arithmetic done efficient arbitrary precision format different types integers comments apply arbitrary arithmetic sorts numbers 
type inference able infer value small integer opposed just integer language feature practically impossible unwrapped numbers producing different copies code unwrapped numbers arbitrary precision numbers 
machine considerations instruction set sets condition codes logical operations possible save cycle common sequence tag tested extracted 
example suppose cons cells tagged tag low word 
normal test sequence needed get pointer take cycles 
optimized sequence define lbl goto lbl sequence costs just cycles test done cycles 
mips machine single instructions equality disequality tests changes costs possibly changing preferred strategies cases 
sparc special arithmetic instructions intended bit integer tags low word 
instructions add subtract integers set overflow flag operand lower bits equal 
related instructions similar cause trap lower bits 
intended support tagged integer arithmetic may useful practical bit tags practical integers integer case common overcome extra cost handling cases 
non trapping instructions test operands operation section cost cycle extra tag bits 
trapping instructions test types arithmetic operands traps section 
special purpose architectures support tagging machines outside scope 
machine circular shift instructions shift bits word just shifting sign bit possible tags bits high low word shift low masking cycles 
save cycle cost section testing distributed tags 
support manipulating bit fields 
may impact choice tagging scheme machine 
machines including sparc instructions load store words 
instructions take cycles load store double wrappers may representation attractive 
realistic count memory access cycle memory word accessed cache 
words machine code generally reasonable data applicable depends great deal access patterns individual programs 
particular times wrap unwrap test data object pointer strategy worse program access data favorable sequence 
extra memory method double wrappers may cache behavior worse 
course similar comments apply caching virtual memory physical memory 
machines lower bits word pointer integers tag garbage collector traverse stack contains machine pointers return addresses stack pointers ignore lower bits 
need tag machine addresses distinguish wrapped values 
note applies correctly initialized locations arbitrary registers example applies code relocated garbage collection 
segmented architectures intel family different addresses specify location 
machines technique partitioned word representations breaking allocation space 
lower half word pointer just chosen points right space tag upper half word 
similarly machines word bits needed address addressable memory ignore bits needed 
extra bits partitioned word scheme restriction objects allocated 
automatic choice representation clearly choice best representation scheme involves complex cost analysis finite number possible representations looks automated 
words looks write heuristic take machine description sort description type frequencies produce representation scheme 
course number representations exponential parameters asking optimal scheme probably reasonable 
program written implements great deal suggestion subset possible representations contains summary data representations language systems 
program intended help decide representations implementation runtime system reason principle automatic choice representation individual program 
trade runtime system compiled uniquely representation 
techniques discussed sections tagging tagged arithmetic brought attention author discussions saumya debray koen de 
entirely clear techniques known ones reinvented 
saumya debray david andre mikael pettersson mark offered helpful comments earlier draft 
writing author posted article internet asking information representations discussed 
people responded helpful ideas suggestions replies lead useful exchanges 
author wishes respondents helpful project 
particular electronic mail exchanges paul stavros david keppel substantial impact 
glossary alignment restrictions 
machine restrictions addresses objects stored memory size object 

abbreviation big bag pages 
technique representing values dynamically typed segments table memory pages associated types section 
boxing number 
allocating space number copying memory representing wrapper containing pointer value 
cycle 
machine instructions take amount time fetch execute cycle time required fetch execute instruction 
delay slot 
instruction position jump instruction executed jump taken 
direct representation 
representation wrapped value entirely wrapper part value kept 
common type direct representation small integer 
dispatching type 
branching locations depending type dynamically typed value 
double wrapper 
large wrapper consisting machine words section 
excess precision arithmetic 
integer arithmetic done way result precision handled final representation 
requires overflow check final representation constructed result section 
hooked value 
value requires special handling referenced section 
hybrid representation 
representation basic representational techniques section 
immediate value 
constant machine instruction encoded instruction 
machine value 
type value supported directly machine operations 
large wrapper 
wrapper consisting machine word section 
object 
block memory contains information needed determine sort value block represents 
literature term widely varying meanings seldom means 
object pointer 
representation dynamically typed value wrapper contains machine pointer object block memory identified structure section 
partitioned word 
representation dynamically typed value set possible bit patterns machine word divided various types section 
partitioned word magnitude 
partitioned word representation type sequential range integers representation 

boxing numbers start program boxed values needed boxing new versions section 
qualifier 
representation sequence pointer length pointers separate sequence 
term various meanings 
range test 
testing number see range section 
scaled arithmetic 
integer arithmetic done way result exactly precision handled final representation result may positioned correctly final representation section 
segment 
range numbers segmented range 
literature term ways 
segmented ranges 
partitioning set natural numbers magnitude membership range decidable subsequence higher order digits binary representation section segregated type codes 
typed location representation type code encoded dynamically separately value section 
sign extension tag 
tag ones negative integers zeros non negative integers tag integers 
significand 
part floating point representation encodes mantissa 
stage 
single level representation staged representation scheme 
staged representation 
representation type codes shared types distinguished representation scheme 
staged tags 
staged representation stages tagged words 
tag field 
section tagged word represent type information 
tag 
type code tagged representation 
tagged word 
representation dynamically typed value wrapper contains single word divided separate fields representing type value 
tagging 
setting tag field word 
type 
set values set representations values implementation level 
term various meanings 
type code 
integer bit pattern represent specific type 
typed location 
representation dynamically typed value type value known location value 
unbound variable 
variable value assigned 
term applies especially languages legal defined way refer value variable value assigned prolog 
unwrapping 
converting wrapped value unwrapped value 

removing tag tagged word 
may may equivalent unwrapping tagged value 
value field 
part tagged word represents value 
word 
unit memory size machine register set values representable machine register memory word 
example word tagged word refers representable values registers memory words 
wrapping 
converting unwrapped value wrapped value 
wrapper 
part representation wrapped value copied place place value passed procedure returned procedure assigned variable include portion representation accessed indirectly say pointer move value moved 
representation schemes wrapper single machine word 
wrapped value 
dynamically typed value encoded type information 
robert bernstein 
producing code case statement 
software practice experience october 
koen de saumya debray david kannan 
call forwarding simple interprocedural optimization technique dynamically typed languages 
proc 
st acm sym 
principles programming languages portland january appear 
timothy budd 
little smalltalk 
addison wesley publishing reading ma 

high performance implementation shared memory multiprocessors 
technical report cis tr department computer information science university oregon 
richard gabriel 
performance evaluation lisp systems 
mit press cambridge ma 
adele goldberg david robson 
smalltalk language implementation 
addisonwesley publishing reading ma 
benjamin goldberg michael glover 
polymorphic type reconstruction garbage collection tags 
proceedings acm conference lisp functional programming pages san francisco ca june 
ralph griswold griswold 
implementation icon programming language 
princeton university press princeton nj 
david de saumya debray 
jc efficient portable sequential implementation janus 
proceedings joint international conference symposium logic programming pages cambridge ma 
mit press 
kevin hammond 
spineless tagless machine 
technical report published department computer science glasgow university 
samuel harbison guy steele jr manual 
prentice hall englewood cliffs nj 
john hennessy david patterson 
computer architecture quantitative approach 
morgan kaufmann publishers san mateo ca 
douglas johnson 
trap architectures lisp systems 
proceedings acm conference lisp functional programming pages nice france june 
simon peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming april 
guy lewis steele jr data representations pdp maclisp 
proc 
macsyma users conference washington july 
nasa scientific technical information office 
atsushi ito 
common lisp efficient portable implementation 
proceedings acm conference lisp functional programming pages san francisco ca june 
michael newton 
high performance implementation prolog 
technical report tr computer science department california institute technology april 
stan robert kessler 
automatic design implementation language datatypes 
proceedings sigplan symposium interpreters interpretative techniques pages st paul minnesota 
acm press 

implementing primitive datatypes higher level languages 
technical report uucs university utah 
peter steenkiste john hennessy 
tags type checking lisp hardware software approaches 
proceedings second international conference architectural support programming languages operating systems pages 
computer society press ieee october 
paul 
personal communication implementation 
april 
kenneth walker 
implementation optimizing compiler icon 
technical report tr department computer science university arizona august 

