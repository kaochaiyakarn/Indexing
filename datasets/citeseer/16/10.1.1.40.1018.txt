constraint networks rina dechter information computer science university california irvine ca constraint reasoning paradigm formulating knowledge set constraints specifying method constraints satisfied 
variety techniques developed finding partial complete solutions different kinds constraint expressions 
successfully applied diverse tasks design diagnosis truth maintenance scheduling spatiotemporal reasoning logic programming user interface 
constraint networks graphical representations guide strategies solving constraint satisfaction problems csps 
basic definitions constraint network cn consists finite set variables fx 
associated domain discrete values 
set constraints fc 
constraints expressed relation defined subset variables tuples simultaneous value assignments members variable subset far constraint concerned legal formally constraint parts subset variables fx 
defined called constraint subset relation rel defined rel properties cn depend structure constraint subsets scheme cn defined set subsets constraints defined scheme cn fs 
projection relation ae subset variables 
ae fx 
ul ae extension published encyclopedia artificial intelligence second edition wiley sons pp mean actual representation constraint necessarily form defining relation relation principle generated constraint specification need consult constraints network 
aron steer earn laser sheet steer aron earn run sun eat laser sheet earn crossword puzzle cn representation 
assignment unique domain value member subset variables called instantiation 
instantiation said satisfy constraint partial assignment specified instantiation violate belongs projection rel common variables 
instantiation said legal locally consistent satisfies relevant constraints network 
legal instantiation variables constraint network called solution network set solutions relation ae defined set variables 
relation said represented constraint network 
formally ae 
scheme ae rel example presents simplified version crossword puzzle see constraint satisfaction 
variables horizontal vertical vertical horizontal horizontal 
scheme problem fx domains constraints specified 
tuple relation associated puzzle solution sheet earn aron 
typical tasks defined connection constraint networks determine solution exists find solutions determine instantiation subset variables partial solution part global solution tasks collectively called constraint satisfaction problems 
techniques processing constraint networks classified categories 
category consists search techniques systematic exploration space solutions 
common algorithm class backtracking traverses search space depth fashion 
second category consistency algorithms transforming cn explicit representation 
primarily preprocessing phase improve performance subsequent backtracking search incorporated search procedure 
third structure driven algorithms exploit topological features network guide search 
structure driven algorithms support consistency algorithms backtracking search 
survey concentrates techniques third kind structure algorithms 
backtracking consistency algorithms see constraint satisfaction give complete picture available techniques 
brief summary backtracking consistency enforcing procedures 
backtracking consistency enforcing strategies standard solution procedure solving constraint satisfaction problems backtracking search 
algorithm typically considers variables order starting assigns provisional value successive variable turn long assigned values consistent assigned past 
process variable encountered domain values consistent previous assignments situation referred dead backtracking takes place 
value assigned immediately preceding variable replaced search continues systematic way solution may concluded solution exists 
improving backtracking efficiency amounts reducing size expanded search space 
depends way constraints represented extent explicitness order variables instantiation solution suffices order values assigned variable 
factors improve performance backtracking algorithms researchers developed procedures types employed advance performing search dynamically search 
include variety consistency enforcing algorithms 
montanari mackworth freuder freuder transform constraint network equivalent explicit network deducing new constraints added network 
intuitively consistency enforcing algorithm partial solution small subnetwork extensible surrounding network 
example basic consistency algorithm called arc consistency consistency known constraint propagation constraint relaxation ensures legal value domain single variable legal match selected variable 
path consistency consistency algorithms ensure consistent solution variable subnetwork extensible third variable general consistency algorithms guarantee locally consistent instantiation variables extensible th variable 
deciding level consistency enforced network choice 
generally speaking backtracking benefit representations explicit possible having higher consistency level 
complexity enforcing consistency exponential result trade effort spent preprocessing spent search backtracking 
experimental analyses trade published dechter meiri dechter haralick elliott 
variable orderings decisions received consideration heuristics proposed freuder dechter pearl intuition tightly constrained variables come 
strategies dynamically improving pruning power backtracking conveniently classified look ahead schemes look back schemes 
look ahead schemes invoked algorithm preparing assign value variable 
functions schemes perform 
calculate record way current instantiations restrict variables 
process referred constraint propagation 
examples include waltz algorithm waltz forward checking haralick elliott 

decide variable instantiate order predetermined 
generally advantageous instantiate variables maximally constrain rest search space 
variable participating highest number constraints usually selected 
freuder purdom stone stone 
decide value assign variable candidate 
generally finding solution attempt assign value maximizes number options available assignments haralick elliott dechter pearl 
look back schemes invoked algorithm encounters dead prepares backtracking step 
schemes perform functions 
decide far backtrack 
analyzing reasons dead possible go back directly source failure immediate predecessor ordering 
idea referred backjumping gaschnig 
constraint graph crossword puzzle 

record reasons dead form new constraints conflicts arise search 
terms describe idea constraint recording constraints 
dependency directed backtracking incorporates backjumping goods recording stallman sussman 
constraint recording viewed form explanation learning ebl 
graph algorithms graphical representations graphical properties cn initially investigated class binary constraint networks 
freuder binary constraint network constraint subset involves variables 
case network associated constraint graph node represents variable arcs connect nodes variables explicitly constrained members network scheme 
shows constraint graph associated crossword puzzle 
graphical representation higher order networks provided hypergraphs nodes represent variables hyperarcs drawn regions group variables belong constraint 
variations representation facilitate structure driven algorithms primal constraint graph dual constraint graph 
primal constraint graph generalization binary constraint graph represents variables nodes associates arc nodes residing constraint 
dual constraint graph represents constraint subset node called variable associates labeled arc nodes constraint subsets share variables 
arcs labeled shared variables 
ce ac aef abc ace cde primal dual constraint graphs csp 
example depicts primal dual hypergraph representations cn variables constraints subsets abc aef cde ace 
constraints symbolically inequalities domains variable integers 
dual constraint graph viewed transformation nonbinary network special type binary network domain variables ranges possible value combinations permitted corresponding constraints adjacent variables obey restriction shared variables values variables bounded equality constraints 
instance domain variable abc binary constraint abc cde relation rel abc cde viewed way network solved binary networks techniques 
solving tree networks known structure techniques rely observation binary constraint networks constraint graph tree solved linear time freuder mackworth freuder dechter pearl 
solution tree structured networks discussed shown facilitate solution general cn tree network variables fig 
step tree algorithm generate rooted directed tree 
node tree excluding root parent node directed may child nodes directed away 
nodes children called leaves 
ordering 
enforced parent precedes children 
second step algorithm processes arc associated constraint leaves root orderly layered fashion 
directed arc removes value domain consistent match domain root processed backtracking algorithm find solution ordering shown algorithm linear number variables 
particular backtracking general exponential procedure guaranteed find solution facing dead ends 
tree algorithm sketched procedures tree algorithm 

generate rooted tree ordering 


revise denotes parent 
domain empty 
solution exists 


backtracking instantiate variables 

revise procedure mackworth freuder defined revise 


consistent 
delete 



complexity tree consistency algorithm bounded nk steps bounds domain size ordering step produced linear time revise procedure bounded steps executed times loop 
tree algorithm instance general classes ordered algorithms discussed 
direction arc consistency tree network directional adaptive consistency general problem considered easy admits solution polynomial time 
context constraint networks problem easy algorithm backtracking solve backtrack free manner dead ends producing solution time linear number variables constraints 
concept prompted theoretical investigation see freuder freuder freuder dechter pearl dechter pearl dechter pearl level local consistency suffices ensuring backtrack free search 
theory identified topological features determine level consistency yielded tractable algorithms transforming networks backtrack free representations 
paragraphs summary theory 
theory centered graphical parameter called width definitions relative primal constraint graph 
ordered primal constraint graph defined nodes linearly ordered reflect sequence variable assignments executed backtracking algorithm 
width node number arcs connect node previous ones width ordering maximum width nodes width graph minimum width orderings graph 
presents possible orderings constraint graph 
width node ordering left second ordering 
shown ordering achieve width lower width constraint graph 
graph cycle known trees width graphs freuder 
width graph determined greedy algorithm 
algorithm selects direction order orderings constraint graph representing widths respectively 
node having number neighbors puts ordering 
node removed adjacent edges algorithm proceeds recursively remaining graph 
ordering instance generated procedure 
connection width local consistency requires elaboration 
constraint network said consistent set variables values satisfy constraints exists value th variable values satisfy constraints variables 
strong consistency holds problem consistent ordering directional consistency consistency requires consistent instantiation variables consistently extended variables succeed ordering strong consistency defined accordingly 
general relationship width network amount local consistency required tractability summarized theorem theorem ordered constraint graph backtrack free level directional strong consistency order greater width ordered graph 
particular graph width tree directional consistency sufficient 
width strong directional consistency suffice 
intuition theorem rests fact backtrack works ordering tests consistency past current variables considering relevant local constraints 
constraints ensure locally consistent partial solution remain consistent relative variables dead occur 
required level local consistency related number constraints variables current variables 
variable constrained past variables high width required level local consistency past variables higher 
problem instances satisfy desired relationship width consistency level possible try push factors relationship holds 
possibility increase level directional consistency matches width problem 
specifically width problem consistent algorithms enforcing directional consistency applied 
dechter pearl consider case width 
theorem tree ordered width ordering enforced directional consistency arc consistency result backtrack free problem 
tree algorithm earlier exactly rooted tree ordering width ordering node adjacent predecessor internal loop steps enforces directional arc consistency ordering 
lead general scheme constraint network find width enforce directional strong consistency appropriate ordering followed backtrack free instantiation variables 
unfortunately enforcing directional consistency requires addition new constraints constraints reflected additional arcs constraint graph may cause width increase 
resulting problem directional consistent width may greater backtrack free search longer guaranteed 
algorithm dechter pearl overcomes difficulty 
ordering algorithm adaptive consistency establishes directional consistency recursively changes node node match width time processing 
accomplished processing nodes decreasing order time node processed final width determined required level consistency achieved 
parents denote set predecessors connected called processing 
adaptive consistency 


compute parents 
connect elements parents connected 
perform consistency parents 
endfor procedure consistency set generates records tuples variables set consistent internally value procedure may impose new constraints clusters variables tighten existing constraints 
adaptive consistency terminates backtracking solve problem order prescribed dead ends 
important realize topology resulting graph called induced graph prior executing procedure recursively decreasing order connecting parents sharing common successor 
consider ordering shown 
adaptive consistency proceeds imposes constraints parents processed variable 
chosen parent algorithm merely domain necessary amounts enforcing arc consistency 
selected having width algorithm enforces consistency parents fx operation may require constraint added case arc added constraint graph 
algorithm reaches node width consistency enforced parents fx arc exists operation may merely tighten corresponding constraint 
resulting graph 
width ordering width induced graph 
complexity solving problem adaptive consistency preprocessing phase backtracking freely order dominated 
worstcase complexity consistency parents step exponential cardinality parent set solves network constraints having variables 
maximal size parent set equal width induced graph solving constraint network ordering bounded exp 
notice adaptive consistency applied ordering resulting induced width 
constraint graph adaptive consistency 
tractability minimum induced width identify classes easy problems 
primal graph constraint network problem solved exp steps 
finding smallest induced width graph corresponding ordering np complete problem arnborg 
deciding problem equal polynomial particular deciding problem instance small induced width say efficiently determined 
trees width equal induced width minimal width ordering optimal induced width ordering linear time 
linear time algorithm recognizing problems having available arnborg 
algorithm selects node having smallest degree eliminates connects neighbors residual graph previously connected continues recursively 
result ordering having concluded graph 
network induced width equals called regular width network 
spite nice structure complexity guarantees provided adaptive consistency experimental results shown low algorithm expensive average 
cost stems determination ensure absolutely backtrack free search investing amount computation trying eliminate just remaining dead ends 
simple backtracking potentially encounter dead ends efficient 
suggests vigorous consistency enforcing algorithm appropriate striking compromise preprocessing search 
bounded directional consistency algorithms dechter pearl fulfill compromise enforcing limited directional consistency eliminating dead ends possible predetermined computational bounds 
recording constraint parents node procedures record set smaller constraints size subsets parents 
shown classes artificially generated cn directional consistency eliminates large subset dead ends directional consistency eliminates dechter meiri 
acyclic networks tree clustering provides measure tractability problems admit easy solution independently width 
happens induced width ordering identical width arcs added adaptive consistency constraint recording consumes linear amount computation problem input 
acyclic constraint networks acyclic csps properties characterized evaluated relational database literature beeri 
viewed trees dual graph representation 
clearly dual graph nonbinary cn tree tree algorithm apply 
dual graph tree arcs may redundant removal result tree structure 
arc dual graph deleted variables shared arc alternative path points 
subgraph resulting removal redundant arcs called join graph 
instance arc aef abc eliminated variable common cycle aef abc ac ace ae aef consistent assignment ensured remaining arcs 
similar argument possible remove arcs labeled turning join graph tree called join tree 
see 
general finding transformation exists tractable problem maier 
constraint networks represented join tree called acyclic networks solved efficiently follows 
constraints join tree variables allowing tuples straightforward application algorithm developed tree singletons nk steps yield solution pl steps 
refinement indexing reduce complexity steps dechter pearl 
generalization acyclic networks called webs permits backtrack free solutions larger class network topologies 
requires constraints aef abc ac ae cde ace ce aef abc cde ace ce ac ae dual constraint graph join tree 
possess special properties typical causal mechanisms dechter pearl 
web structures conveniently represented form directed constraint networks causal networks indicate ordering solutions obtained 
recognizing acyclic networks efficient procedures identifying finding representative join tree described maier 
scheme proved particularly useful observation cn acyclic primal graph chordal conformal beeri 
graph chordal cycle length chord edge joining nonconsecutive vertices cycle 
graph conformal maximal cliques subsets nodes completely connected corresponds constraint original cn graph identified ordering called maximal cardinality ordering ordering assigns number node having largest set numbered neighbors breaking ties arbitrarily 
instance ordering ordering figures 
shown tarjan yannakakis ordered chordal graph parents node completely connected 
addition maximal cliques coincide constraint subsets original cn conditions acyclicity satisfied 
chordal graphs node parent set constitutes clique maximal cliques identified linear time join tree constructed connecting maximal clique ancestor clique shares largest set variables 
noted acyclic networks chordal primal graph width induced width identical ordering 
applied ordered cns add arcs graph 
tuples parent set locally consistent amount constraint recording bounded log resulting complexity bound log steps 
tree clustering recognition process suggests scheme combining subsets constraints higher level constraints join tree emerges network acyclic 
tree clustering scheme triangulation algorithm tarjan yannakakis transforms graph chordal graph filling edges recursively reverse order ordering connecting nonadjacent nodes connected nodes higher ordering 
maximal cliques resulting chordal graph clusters necessary forming clusters represent subproblems independently solved operation exponential clique size 
shown maximal clique size generated way equals transformation join tree exponential tree clustering differs conceptually adaptive consistency effectively results behavior performance 
applied ordered constraint graph algorithms produce induced graph 
words adaptive consistency viewed effective scheme assembling 
desirable adaptive consistency time solutions required tree clustering network knowledge base subjected repeated queries 
note tree clustering applied ordering ordering produces close optimal induced width chordal graphs optimal 
subclass maximal cliques size characterized special class chordal graphs called trees 
tree chordal graph maximal cliques size defined recursively follows complete graph vertices tree 
tree vertices extended vertices connecting new vertex vertices clique size particular trees ordinary trees 
addition vertex step generates new clique size associating new clique parent clique shares vertices join tree obtained 
example acyclic cn tree primal graph constructed order trees investigated extensively graph theoretical literature 
particular shown graph embedded tree induced width detailed discussions graph decomposition nonseparable components 
properties available arnborg freuder rossi montanari 
decomposition nonseparable components approach exploits structure constraint graph involves notion nonseparable components freuder dechter pearl 
similar tree clustering idea identify subsets variables grouped transform problem tree nonseparable components graph property 
connected graph set nodes set edges said separation node exists nodes paths connecting pass graph separation node called separable called nonseparable 
subgraph separation nodes called nonseparable component 
algorithm exists finding nonseparable components separation nodes depth search traversal graph called dfs ordering 
graph super tree nodes represents components 
separating nodes 

shows graph components separating vertices 
components recognized represents subproblem solved defines domains new compound variable 
tree algorithm applied resulting problem treating component compound variable 
instantiated variable cuts cycles 
complexity approach nk size largest component 
cases constraint network decomposition small clusters nonseparable components resulting performance improved 
comparing nonseparable component method tree clustering adaptive consistency immediately realized improve worst case complexity frequently scheme natural extension trees extended dual graph representation 
cycle cutset scheme decomposition method section identifying cycle cutset set nodes removed render constraint graph cycle free 
method uses trees different way previous schemes exploiting fact variable instantiation changes effective connectivity constraint graph 
example instantiating value say renders choices independent pathway blocked similarly instantiation blocks pathway leaving path variables 
effective constraint graph rest variables shown instantiated variable duplicated neighbors 
group instantiated variables constitutes cycle cutset remaining network cycle free solved tree algorithm 
example cuts single cycle renders graph cycle free 
practical cases take single variable cut cycles graph 
general way solving problem constraint graph contains cycles find consistent instantiation variables cycle cutset solve remaining problem tree algorithm 
solution restricted problem solution entire problem hand 
instantiation cycle cutset variables considered solution 
task solve crossword puzzle assumed remaining tree problem solved 
solution assumed attempt solution 
complexity cycle cutset scheme bounded exp steps size cycle cutset utmost number times tree algorithm invoked equals number partial solutions cutset variables 
finding cycle cutset np hard practical incorporate scheme general problem solver backtracking 
backtracking works progressively instantiating sets variables necessary keep track connectivity status constraint graph 
soon set instantiated variables constitutes cycle cutset search algorithm switched tree algorithm remaining problem finding consistent extension remaining variables finding solution entire problem concluding extension exists case backtracking takes place instantiation tried dechter 
graph schemes improving backtracking ideas improving look back phases backtracking received wide attention gaschnig stallman sussman doyle dechter 
referred backjumping constraint recording constraint literature commonly recognized umbrella name dependency directed backtracking truth maintenance literature 
backjumping suggests jumping back levels search tree variable may relevance current dead constraint recording suggests storing reasons dead form new constraints conflict arise search recording goods 
section graph variants backjumping constraint recording 
exploiting structure problem simplifies implementation schemes enables assessment complexity network parameters 
backjumping idea going back levels dead situation retreating chronologically decision exploited independently gaschnig term backjumping introduced stallman sussman 
idea truth maintenance systems doyle intelligent backtracking prolog bruynooghe pereira 
gaschnig algorithm uses marking technique variable maintains pointer highest ancestor incompatible values 
case dead algorithm safely jump directly ancestor pointed dead variable 
scheme retains bit information variable requires additional computation consistency check 
graph backjumping dechter extracts knowledge dependencies constraint graph 
dead occurs particular variable algorithm backs variable connected graph 
consider instance ordered constraint graph 
search performed order dead occurs algorithm jump back variable connected variable algorithm values back parent original variable new dead variable 
implementation backjumping scheme general require careful maintenance variable parents set dechter orderings facilitate especially simple implementation 
depth search constraint graph generate dfs tree backjumping conducted order traversal dfs tree finding jump back destination amounts simple rule dead occurred variable go back parent dfs tree 
consider example 
dfs tree graph order traversal tree 
dead occurs node algorithm parent backjumping performed dfs ordering variables complexity bounded exp steps depth dfs tree 
parameters encountered finding minimal depth dfs tree np hard 
constraint recording dependency directed backtracking opportunity learn deduce new constraint backtracking encounters dead current instantiation 
extended value variable case conflict dfs tree ordering 
conflict set 
problem included explicit constraint prohibiting instantiation current dead avoided 
point recording constraint stage backtracking control strategy recur 
hand set contains subsets conflict recording information form new explicit constraints prove useful states may contain subsets 
constraint graph provides easy way identifying subsets conflict removing assignments variables connected subset obtained conflict removed assignments irrelevant dead 
procedure graph dependency directed backtracking called graphbased constraint recording dechter implements idea recording conflict sets new constraint dead 
specifically subsets 
assignments connected procedure records constraint variables 
disallows tuple instance suppose backtracking solves crossword puzzle ordering currently state aron dock 
state extended value obviously tuple aron dock conflict set instantiations aron irrelevant conflict explicit constraint tuple disallowed recording new constraint dependency directed backtracking performed variable ordering 
complexity exp steps providing scheme performance governed induced width 
survey techniques exploit structure network 
graph parameters stood analysis induced width appearing adaptive consistency tree clustering constraint recording backtracking cycle cutset size appearing cycle cutset method depth dfs tree backjumping size largest non separable component appearing tree component scheme 
clear problem structure relationships holds shown 
comparable trees mesh 
parameter mentioned literature bandwidth zabih dominated concluded provides informative graph parameter regarded intrinsic measure worse case complexity constraint network 
arnborg arnborg efficient algorithms combinatorial problems graphs bounded decomposability survey bit vol 
pp 

beeri beeri fagin maier yannakakis desirability acyclic database schemes journal acm vol 
pp 
july 
dynamic programming academic press new york 
bruynooghe pereira bruynooghe pereira deduction revision intelligent backtracking implementation prolog campbell ed 
ellis harwood pp 

modeling probability distributions web structures technical report university california los angeles 
dechter pearl dechter pearl network heuristics problems artificial intelligence vol 
pp 

dechter meiri dechter meiri experimental evaluation preprocessing techniques constraint satisfaction proceedings th international conference ai ijcai detroit mi august 
dechter pearl dechter pearl tree clustering constraint networks artificial intelligence pp 

dechter dechter enhancement schemes constraint processing backjumping learning cutset decomposition artificial intelligence vol 
pp 
january 
dechter pearl dechter pearl directed constraint networks relational framework causal modeling proceedings twelfth ijcai sydney australia morgan kaufmann san mateo ca 
doyle doyle truth maintenance system artificial intelligence vol 
pp 

graph algorithms computer science press md 
freuder freuder synthesizing constraint expression communications acm vol 
pp 
freuder freuder sufficient condition backtrack free search journal acm vol 
pp 

freuder freuder sufficient condition backtrack bounded search journal acm vol 
pp 
october 
freuder freuder complexity structured constraint satisfaction problems proceedings aaai pp 
boston ma july 
gaschnig gaschnig performance measurement analysis certain search algorithms computer science department carnegie mellon university pittsburgh pa tech 
report cmu cs 
haralick elliott haralick elliott increasing tree search efficiency constraint satisfaction problems artificial intelligence vol 
pp 

mackworth freuder mackworth consistency networks relations artificial intelligence vol 
pp 

mackworth freuder mackworth freuder complexity polynomial network consistency algorithms constraint satisfaction problems artificial intelligence vol 

maier maier theory relational databases computer science press rockville md 
montanari montanari ugo networks constraints fundamental properties applications picture processing information sciences vol 
pp 

purdom purdom search rearrangement backtracking polynomial average time artificial intelligence vol 
pp 

rossi montanari rossi montanari exact solution linear time networks constraints perfect relaxation proceedings international conference principles knowledge representation reasoning pp 
toronto ontario canada may 
seidel new method solving constraint satisfaction problems proceedings ijcai pp 

stallman sussman stallman sussman forward reasoning backtracking system computer aided circuit analysis artificial intelligence vol pp 

stone stone stone stone efficient search techniques empirical study queens problem ibm watson research center tech 
report rc yorktown heights ny 
tarjan yannakakis tarjan yannakakis simple linear time algorithms test graphs test acyclicity hypergraphs selectivity reduce acyclic hypergraphs siam journal computing vol 
pp 

waltz waltz understanding line drawings scenes shadows psychology computer vision winston ed mcgraw hill new york 
zabih zabih applications graph bandwidth constraint satisfaction problems proceedings eighth national conference artificial intelligence aaai pp 
boston ma july 

